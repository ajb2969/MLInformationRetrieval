<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1417">Communicating sequential processes</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Communicating sequential processes</h1>
<hr>In [[computer science]], '''communicating sequential processes''' ('''CSP''') is a [[formal language|formal language]] for describing [[pattern]]s of [[interaction]] in [[concurrent systems]].<ref name="roscoe">{{cite book|first=A. W.|last=Roscoe|authorlink=Bill Roscoe|title=The Theory and Practice of Concurrency|publisher=[[Prentice Hall]]|isbn = 0-13-674409-5|year=1997}}</ref></hr></body></html>f&gt; It is a member of the family of mathematical theories of concurrency known as process algebras, or <a href="process_calculus" title="wikilink">process calculi</a>, based on <a href="message_passing" title="wikilink">message passing</a> via <a href="Channel_(programming)" title="wikilink">channels</a>. CSP was highly influential in the design of the <a href="occam_(programming_language)" title="wikilink">occam</a> programming language,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and also influenced the design of programming languages such as <a href="Limbo_(programming_language)" title="wikilink">Limbo</a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and <a href="Go_(programming_language)" title="wikilink">Go</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a>

<p>CSP was first described in a 1978 paper by <a href="C._A._R._Hoare" title="wikilink">C. A. R. Hoare</a>,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> but has since evolved substantially.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> CSP has been practically applied in industry as a tool for <a href="formal_specification" title="wikilink">specifying and verifying</a> the concurrent aspects of a variety of different systems, such as the T9000 <a class="uri" href="Transputer" title="wikilink">Transputer</a>,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> as well as a secure ecommerce system.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The theory of CSP itself is also still the subject of active research, including work to increase its range of practical applicability (e.g., increasing the scale of the systems that can be tractably analyzed).<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="history">History</h2>

<p>The version of CSP presented in Hoare's original 1978 paper was essentially a concurrent programming language rather than a <a href="process_calculus" title="wikilink">process calculus</a>. It had a substantially different <a class="uri" href="syntax" title="wikilink">syntax</a> than later versions of CSP, did not possess mathematically defined semantics,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> and was unable to represent <a href="unbounded_nondeterminism" title="wikilink">unbounded nondeterminism</a>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> Programs in the original CSP were written as a parallel composition of a fixed number of sequential processes communicating with each other strictly through synchronous message-passing. In contrast to later versions of CSP, each process was assigned an explicit name, and the source or destination of a message was defined by specifying the name of the intended sending or receiving process. For example the process</p>

<p><code>COPY = *[c:character; west?c → east!c]</code></p>

<p>repeatedly receives a character from the process named <code>west</code>, and then sends that character to process named <code>east</code>. The parallel composition</p>

<p><code>[west::DISASSEMBLE || X::COPY || east::ASSEMBLE]</code></p>

<p>assigns the names <code>west</code> to the <code>DISASSEMBLE</code> process, <code>X</code> to the <code>COPY</code> process, and <code>east</code> to the <code>ASSEMBLE</code> process, and executes these three processes concurrently.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>Following the publication of the original version of CSP, Hoare, Stephen Brookes, and <a href="Bill_Roscoe" title="wikilink">A. W. Roscoe</a> developed and refined the <em>theory</em> of CSP into its modern, process algebraic form. The approach taken in developing CSP into a process algebra was influenced by <a href="Robin_Milner" title="wikilink">Robin Milner</a>'s work on the <a href="Calculus_of_Communicating_Systems" title="wikilink">Calculus of Communicating Systems</a> (CCS), and vice versa. The theoretical version of CSP was initially presented in a 1984 article by Brookes, Hoare, and Roscoe,<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> and later in Hoare's book <em>Communicating Sequential Processes</em>,<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> which was published in 1985. In September 2006, that book was still the <a href="http://citeseer.ist.psu.edu/articles.html">third-most cited</a> <a href="computer_science" title="wikilink">computer science</a> reference of all time according to <a class="uri" href="Citeseer" title="wikilink">Citeseer</a> (albeit an unreliable source due to the nature of its sampling). The theory of CSP has undergone a few minor changes since the publication of Hoare's book. Most of these changes were motivated by the advent of automated tools for CSP process analysis and verification. Roscoe's <em>The Theory and Practice of Concurrency</em><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> describes this newer version of CSP.</p>
<h3 id="applications">Applications</h3>

<p>An early and important application of CSP was its use for specification and verification of elements of the INMOS T9000 <a class="uri" href="Transputer" title="wikilink">Transputer</a>, a complex superscalar pipelined processor designed to support large-scale multiprocessing. CSP was employed in verifying the correctness of both the processor pipeline, and the Virtual Channel Processor which managed off-chip communications for the processor.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>Industrial application of CSP to software design has usually focused on dependable and safety-critical systems. For example, the Bremen Institute for Safe Systems and <a href="DaimlerChrysler_Aerospace" title="wikilink">Daimler-Benz Aerospace</a> modeled a fault management system and avionics interface (consisting of some 23,000 lines of code) intended for use on the International Space Station in CSP, and analyzed the model to confirm that their design was free of deadlock and livelock.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> The modeling and analysis process was able to uncover a number of errors that would have been difficult to detect using testing alone. Similarly, <a href="Praxis_High_Integrity_Systems" title="wikilink">Praxis High Integrity Systems</a> applied CSP modeling and analysis during the development of software (approximately 100,000 lines of code) for a secure smart-card Certification Authority to verify that their design was secure and free of deadlock. Praxis claims that the system has a much lower defect rate than comparable systems.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>Since CSP is well-suited to modeling and analyzing systems that incorporate complex message exchanges, it has also been applied to the verification of communications and security protocols. A prominent example of this sort of application is Lowe’s use of CSP and the <a href="FDR2" title="wikilink">FDR refinement-checker</a> to discover a previously unknown attack on the <a href="Needham-Schroeder_protocol" title="wikilink">Needham-Schroeder public-key authentication protocol</a>, and then to develop a corrected protocol able to defeat the attack.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h2 id="informal-description">Informal description</h2>

<p>As its name suggests, CSP allows the description of systems in terms of component processes that operate independently, and interact with each other solely through <a href="message_passing" title="wikilink">message-passing</a> communication. However, the <em>"Sequential"</em> part of the CSP name is now something of a misnomer, since modern CSP allows component processes to be defined both as sequential processes, and as the parallel composition of more primitive processes. The relationships between different processes, and the way each process communicates with its environment, are described using various <a href="process_calculi" title="wikilink">process algebraic</a> operators. Using this algebraic approach, quite complex process descriptions can be easily constructed from a few primitive elements.</p>
<h3 id="primitives">Primitives</h3>

<p>CSP provides two classes of primitives in its process algebra:</p>
<dl>
<dt>Events</dt>
<dd>Events represent communications or interactions. They are assumed to be indivisible and instantaneous. They may be atomic names (e.g. <em>on</em>, <em>off</em>), compound names (e.g. <em>valve.open</em>, <em>valve.close</em>), or input/output events (e.g. <em>mouse?xy</em>, <em>screen!bitmap</em>).
</dd>
<dt>Primitive processes:</dt>
<dd>Primitive processes represent fundamental behaviors: examples include <em>STOP</em> (the process that communicates nothing, also called <a class="uri" href="deadlock" title="wikilink">deadlock</a>), and <em>SKIP</em> (which represents successful termination).
</dd>
</dl>
<h3 id="algebraic-operators">Algebraic operators</h3>

<p>CSP has a wide range of algebraic operators. The principal ones are:</p>
<dl>
<dt>Prefix</dt>
<dd>The prefix operator combines an event and a process to produce a new process. For example,
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Communicating_sequential_processes:0">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>→</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>a</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\rightarrow P
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>is the process which is willing to communicate 

<math display="inline" id="Communicating_sequential_processes:1">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{a}
  </annotation>
 </semantics>
</math>

 with its environment, and, after 

<math display="inline" id="Communicating_sequential_processes:2">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{a}
  </annotation>
 </semantics>
</math>

, behaves like the process 

<math display="inline" id="Communicating_sequential_processes:3">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{P}
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
<dl>
<dt>Deterministic Choice</dt>
<dd>The deterministic (or external) choice operator allows the future evolution of a process to be defined as a choice between two component processes, and allows the environment to resolve the choice by communicating an initial event for one of the processes. For example,
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Communicating_sequential_processes:4">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mi>a</mi>
    <mo>→</mo>
    <mi>P</mi>
    <mo>)</mo>
   </mrow>
   <mi mathvariant="normal">□</mi>
   <mrow>
    <mo>(</mo>
    <mi>b</mi>
    <mo>→</mo>
    <mi>Q</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">□</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">Q</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(a\rightarrow P\right)\Box\left(b\rightarrow Q\right)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>is the process which is willing to communicate the initial events 

<math display="inline" id="Communicating_sequential_processes:5">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{a}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Communicating_sequential_processes:6">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{b}
  </annotation>
 </semantics>
</math>

, and subsequently behaves as either 

<math display="inline" id="Communicating_sequential_processes:7">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{P}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Communicating_sequential_processes:8">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{Q}
  </annotation>
 </semantics>
</math>

 depending on which initial event the environment chooses to communicate. If both 

<math display="inline" id="Communicating_sequential_processes:9">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{a}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Communicating_sequential_processes:10">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{b}
  </annotation>
 </semantics>
</math>

 were communicated simultaneously the choice would be resolved nondeterministically.
</dd>
</dl>
<dl>
<dt>Nondeterministic Choice</dt>
<dd>The nondeterministic (or internal) choice operator allows the future evolution of a process to be defined as a choice between two component processes, but does not allow the environment any control over which one of the component processes will be selected. For example,
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Communicating_sequential_processes:11">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mi>a</mi>
    <mo>→</mo>
    <mi>P</mi>
    <mo>)</mo>
   </mrow>
   <mo>⊓</mo>
   <mrow>
    <mo>(</mo>
    <mi>b</mi>
    <mo>→</mo>
    <mi>Q</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">square-intersection</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">Q</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(a\rightarrow P\right)\sqcap\left(b\rightarrow Q\right)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>can behave like either 

<math display="inline" id="Communicating_sequential_processes:12">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mrow>
    <mi>a</mi>
    <mo>→</mo>
    <mi>P</mi>
   </mrow>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>a</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(a\rightarrow P\right)
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Communicating_sequential_processes:13">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mrow>
    <mi>b</mi>
    <mo>→</mo>
    <mi>Q</mi>
   </mrow>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>b</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(b\rightarrow Q\right)
  </annotation>
 </semantics>
</math>

. It can refuse to accept 

<math display="inline" id="Communicating_sequential_processes:14">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{a}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Communicating_sequential_processes:15">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{b}
  </annotation>
 </semantics>
</math>

, and is only obliged to communicate if the environment offers both 

<math display="inline" id="Communicating_sequential_processes:16">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{a}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Communicating_sequential_processes:17">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{b}
  </annotation>
 </semantics>
</math>

. Nondeterminism can be inadvertently introduced into a nominally deterministic choice if the initial events of both sides of the choice are identical. So, for example,
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Communicating_sequential_processes:18">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mi>a</mi>
    <mo>→</mo>
    <mi>a</mi>
    <mo>→</mo>
    <mi>S</mi>
    <mi>T</mi>
    <mi>O</mi>
    <mi>P</mi>
    <mo>)</mo>
   </mrow>
   <mi mathvariant="normal">□</mi>
   <mrow>
    <mo>(</mo>
    <mi>a</mi>
    <mo>→</mo>
    <mi>b</mi>
    <mo>→</mo>
    <mi>S</mi>
    <mi>T</mi>
    <mi>O</mi>
    <mi>P</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">S</csymbol>
     <csymbol cd="unknown">T</csymbol>
     <csymbol cd="unknown">O</csymbol>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">□</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">S</csymbol>
     <csymbol cd="unknown">T</csymbol>
     <csymbol cd="unknown">O</csymbol>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(a\rightarrow a\rightarrow STOP\right)\Box\left(a\rightarrow b\rightarrow
STOP\right)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>is equivalent to
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Communicating_sequential_processes:19">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>→</mo>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>(</mo>
     <mi>a</mi>
     <mo>→</mo>
     <mi>S</mi>
     <mi>T</mi>
     <mi>O</mi>
     <mi>P</mi>
     <mo>)</mo>
    </mrow>
    <mo>⊓</mo>
    <mrow>
     <mo>(</mo>
     <mi>b</mi>
     <mo>→</mo>
     <mi>S</mi>
     <mi>T</mi>
     <mi>O</mi>
     <mi>P</mi>
     <mo>)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">S</csymbol>
      <csymbol cd="unknown">T</csymbol>
      <csymbol cd="unknown">O</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="latexml">square-intersection</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">S</csymbol>
      <csymbol cd="unknown">T</csymbol>
      <csymbol cd="unknown">O</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\rightarrow\left(\left(a\rightarrow STOP\right)\sqcap\left(b\rightarrow STOP%
\right)\right)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dt>Interleaving</dt>
<dd>The interleaving operator represents completely independent concurrent activity. The process
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Communicating_sequential_processes:20">
 <semantics>
  <mrow>
   <mpadded width="+2.8pt">
    <mi>P</mi>
   </mpadded>
   <mo stretchy="false">|</mo>
   <mo stretchy="false">|</mo>
   <mo rspace="5.3pt" stretchy="false">|</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-|</ci>
    <ci>normal-|</ci>
    <ci>normal-|</ci>
    <csymbol cd="unknown">Q</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\;|||\;Q
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>behaves as both 

<math display="inline" id="Communicating_sequential_processes:21">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{P}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Communicating_sequential_processes:22">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{Q}
  </annotation>
 </semantics>
</math>

 simultaneously. The events from both processes are arbitrarily interleaved in time.
</dd>
</dl>
<dl>
<dt>Interface Parallel</dt>
<dd>The interface parallel operator represents concurrent activity that requires synchronization between the component processes: any event in the interface set can only occur when <em>all</em> component processes are able to engage in that event. For example, the process
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Communicating_sequential_processes:23">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo>|</mo>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mo>{</mo>
      <mi>a</mi>
      <mo>}</mo>
     </mrow>
     <mo>]</mo>
    </mrow>
    <mo>|</mo>
   </mrow>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <set>
       <ci>a</ci>
      </set>
     </apply>
    </apply>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\left|\left[\left\{a\right\}\right]\right|Q
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>requires that 

<math display="inline" id="Communicating_sequential_processes:24">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{P}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Communicating_sequential_processes:25">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{Q}
  </annotation>
 </semantics>
</math>

 must both be able to perform event 

<math display="inline" id="Communicating_sequential_processes:26">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{a}
  </annotation>
 </semantics>
</math>

 before that event can occur. So, for example, the process
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Communicating_sequential_processes:27">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mi>a</mi>
    <mo>→</mo>
    <mi>P</mi>
    <mo>)</mo>
   </mrow>
   <mo>|</mo>
   <mrow>
    <mo>[</mo>
    <mrow>
     <mo>{</mo>
     <mi>a</mi>
     <mo>}</mo>
    </mrow>
    <mo>]</mo>
   </mrow>
   <mo>|</mo>
   <mrow>
    <mo>(</mo>
    <mi>a</mi>
    <mo>→</mo>
    <mi>Q</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-|</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-|</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">Q</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(a\rightarrow P\right)\left|\left[\left\{a\right\}\right]\right|\left(a%
\rightarrow Q\right)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>can engage in event 

<math display="inline" id="Communicating_sequential_processes:28">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{a}
  </annotation>
 </semantics>
</math>

, and become the process
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Communicating_sequential_processes:29">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo>|</mo>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mo>{</mo>
      <mi>a</mi>
      <mo>}</mo>
     </mrow>
     <mo>]</mo>
    </mrow>
    <mo>|</mo>
   </mrow>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <set>
       <ci>a</ci>
      </set>
     </apply>
    </apply>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\left|\left[\left\{a\right\}\right]\right|Q
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>while
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Communicating_sequential_processes:30">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mi>a</mi>
    <mo>→</mo>
    <mi>P</mi>
    <mo>)</mo>
   </mrow>
   <mo>|</mo>
   <mrow>
    <mo>[</mo>
    <mrow>
     <mo>{</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo>}</mo>
    </mrow>
    <mo>]</mo>
   </mrow>
   <mo>|</mo>
   <mrow>
    <mo>(</mo>
    <mi>b</mi>
    <mo>→</mo>
    <mi>Q</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-|</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-|</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">Q</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(a\rightarrow P\right)\left|\left[\left\{a,b\right\}\right]\right|\left(b%
\rightarrow Q\right)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>will simply deadlock.
</dd>
</dl>
<dl>
<dt>Hiding</dt>
<dd>The hiding operator provides a way to abstract processes, by making some events unobservable. A trivial example of hiding is
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Communicating_sequential_processes:31">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mi>a</mi>
    <mo>→</mo>
    <mi>P</mi>
    <mo>)</mo>
   </mrow>
   <mo>∖</mo>
   <mrow>
    <mo>{</mo>
    <mi>a</mi>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <setdiff></setdiff>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(a\rightarrow P\right)\setminus\left\{a\right\}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>which, assuming that the event 

<math display="inline" id="Communicating_sequential_processes:32">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{a}
  </annotation>
 </semantics>
</math>

 doesn't appear in 

<math display="inline" id="Communicating_sequential_processes:33">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{P}
  </annotation>
 </semantics>
</math>

, simply reduces to
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Communicating_sequential_processes:34">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{P}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h3 id="examples">Examples</h3>

<p>One of the archetypal CSP examples is an abstract representation of a chocolate vending machine and its interactions with a person wishing to buy some chocolate. This vending machine might be able to carry out two different events, “coin” and “choc” which represent the insertion of payment and the delivery of a chocolate respectively. A machine which demands payment before offering a chocolate can be written as:</p>

<p>

<math display="block" id="Communicating_sequential_processes:35">
 <semantics>
  <mrow>
   <mtext>𝑉𝑒𝑛𝑑𝑖𝑛𝑔𝑀𝑎𝑐ℎ𝑖𝑛𝑒</mtext>
   <mo>=</mo>
   <mtext>𝑐𝑜𝑖𝑛</mtext>
   <mo>→</mo>
   <mtext>𝑐ℎ𝑜𝑐</mtext>
   <mo>→</mo>
   <mtext>𝑆𝑇𝑂𝑃</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <mtext>VendingMachine</mtext>
     <mtext>coin</mtext>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <mtext>choc</mtext>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <mtext>STOP</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textit{VendingMachine}=\textit{coin}\rightarrow\textit{choc}\rightarrow%
\textit{STOP}
  </annotation>
 </semantics>
</math>

</p>

<p>A person who might choose to use a coin or card to make payments could be modelled as:</p>

<p>

<math display="block" id="Communicating_sequential_processes:36">
 <semantics>
  <mrow>
   <mtext>𝑃𝑒𝑟𝑠𝑜𝑛</mtext>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mtext>𝑐𝑜𝑖𝑛</mtext>
    <mo>→</mo>
    <mtext>𝑆𝑇𝑂𝑃</mtext>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal">□</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mtext>𝑐𝑎𝑟𝑑</mtext>
    <mo>→</mo>
    <mtext>𝑆𝑇𝑂𝑃</mtext>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>Person</mtext>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>coin</mtext>
     <ci>normal-→</ci>
     <mtext>STOP</mtext>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">□</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>card</mtext>
     <ci>normal-→</ci>
     <mtext>STOP</mtext>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textit{Person}=(\textit{coin}\rightarrow\textit{STOP})\Box(\textit{card}%
\rightarrow\textit{STOP})
  </annotation>
 </semantics>
</math>

</p>

<p>These two processes can be put in parallel, so that they can interact with each other. The behaviour of the composite process depends on the events that the two component processes must synchronise on. Thus,</p>

<p>

<math display="block" id="Communicating_sequential_processes:37">
 <semantics>
  <mrow>
   <mrow>
    <mtext>𝑉𝑒𝑛𝑑𝑖𝑛𝑔𝑀𝑎𝑐ℎ𝑖𝑛𝑒</mtext>
    <mrow>
     <mo>|</mo>
     <mrow>
      <mo>[</mo>
      <mrow>
       <mo>{</mo>
       <mtext>𝑐𝑜𝑖𝑛</mtext>
       <mo>,</mo>
       <mtext>𝑐𝑎𝑟𝑑</mtext>
       <mo>}</mo>
      </mrow>
      <mo>]</mo>
     </mrow>
     <mo>|</mo>
    </mrow>
    <mtext>𝑃𝑒𝑟𝑠𝑜𝑛</mtext>
   </mrow>
   <mo>≡</mo>
   <mtext>𝑐𝑜𝑖𝑛</mtext>
   <mo>→</mo>
   <mtext>𝑐ℎ𝑜𝑐</mtext>
   <mo>→</mo>
   <mtext>𝑆𝑇𝑂𝑃</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <times></times>
      <mtext>VendingMachine</mtext>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <set>
         <mtext>coin</mtext>
         <mtext>card</mtext>
        </set>
       </apply>
      </apply>
      <mtext>Person</mtext>
     </apply>
     <mtext>coin</mtext>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <mtext>choc</mtext>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <mtext>STOP</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textit{VendingMachine}\left|\left[\left\{\textit{coin},\textit{card}\right\}%
\right]\right|\textit{Person}\equiv\textit{coin}\rightarrow\textit{choc}%
\rightarrow\textit{STOP}
  </annotation>
 </semantics>
</math>

</p>

<p>whereas if synchronization was only required on “coin”, we would obtain</p>

<p>

<math display="block" id="Communicating_sequential_processes:38">
 <semantics>
  <mrow>
   <mtext>𝑉𝑒𝑛𝑑𝑖𝑛𝑔𝑀𝑎𝑐ℎ𝑖𝑛𝑒</mtext>
   <mo>|</mo>
   <mrow>
    <mo>[</mo>
    <mrow>
     <mo>{</mo>
     <mtext>𝑐𝑜𝑖𝑛</mtext>
     <mo>}</mo>
    </mrow>
    <mo>]</mo>
   </mrow>
   <mo>|</mo>
   <mtext>𝑃𝑒𝑟𝑠𝑜𝑛</mtext>
   <mo>≡</mo>
   <mrow>
    <mo>(</mo>
    <mtext>𝑐𝑜𝑖𝑛</mtext>
    <mo>→</mo>
    <mtext>𝑐ℎ𝑜𝑐</mtext>
    <mo>→</mo>
    <mtext>𝑆𝑇𝑂𝑃</mtext>
    <mo>)</mo>
   </mrow>
   <mi mathvariant="normal">□</mi>
   <mrow>
    <mo>(</mo>
    <mtext>𝑐𝑎𝑟𝑑</mtext>
    <mo>→</mo>
    <mtext>𝑆𝑇𝑂𝑃</mtext>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>VendingMachine</mtext>
    <ci>normal-|</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <mtext>coin</mtext>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-|</ci>
    <mtext>Person</mtext>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>coin</mtext>
     <ci>normal-→</ci>
     <mtext>choc</mtext>
     <ci>normal-→</ci>
     <mtext>STOP</mtext>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">□</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>card</mtext>
     <ci>normal-→</ci>
     <mtext>STOP</mtext>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textit{VendingMachine}\left|\left[\left\{\textit{coin}\right\}\right]\right|%
\textit{Person}\equiv\left(\textit{coin}\rightarrow\textit{choc}\rightarrow%
\textit{STOP}\right)\Box\left(\textit{card}\rightarrow\textit{STOP}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>If we abstract this latter composite process by hiding the “coin” and “card” events, i.e.</p>

<p>

<math display="block" id="Communicating_sequential_processes:39">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>(</mo>
     <mtext>𝑐𝑜𝑖𝑛</mtext>
     <mo>→</mo>
     <mtext>𝑐ℎ𝑜𝑐</mtext>
     <mo>→</mo>
     <mtext>𝑆𝑇𝑂</mtext>
     <mi>P</mi>
     <mo>)</mo>
    </mrow>
    <mi mathvariant="normal">□</mi>
    <mrow>
     <mo>(</mo>
     <mtext>𝑐𝑎𝑟𝑑</mtext>
     <mo>→</mo>
     <mtext>𝑆𝑇𝑂𝑃</mtext>
     <mo>)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mo>∖</mo>
   <mrow>
    <mo>{</mo>
    <mtext>𝑐𝑜𝑖𝑛</mtext>
    <mo>,</mo>
    <mi>c</mi>
    <mi>a</mi>
    <mi>r</mi>
    <mi>d</mi>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <mtext>coin</mtext>
      <ci>normal-→</ci>
      <mtext>choc</mtext>
      <ci>normal-→</ci>
      <mtext>STO</mtext>
      <csymbol cd="unknown">P</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">□</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <mtext>card</mtext>
      <ci>normal-→</ci>
      <mtext>STOP</mtext>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <setdiff></setdiff>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <mtext>coin</mtext>
     <ci>normal-,</ci>
     <csymbol cd="unknown">c</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="unknown">d</csymbol>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\left(\textit{coin}\rightarrow\textit{choc}\rightarrow\textit{STO}P%
\right)\Box\left(\textit{card}\rightarrow\textit{STOP}\right)\right)\setminus%
\left\{\textit{coin},card\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>we get the nondeterministic process</p>

<p>

<math display="block" id="Communicating_sequential_processes:40">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mtext>𝑐ℎ𝑜𝑐</mtext>
    <mo>→</mo>
    <mtext>𝑆𝑇𝑂𝑃</mtext>
    <mo>)</mo>
   </mrow>
   <mo>⊓</mo>
   <mtext>𝑆𝑇𝑂𝑃</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>choc</mtext>
     <ci>normal-→</ci>
     <mtext>STOP</mtext>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">square-intersection</csymbol>
    <mtext>STOP</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\textit{choc}\rightarrow\textit{STOP}\right)\sqcap\textit{STOP}
  </annotation>
 </semantics>
</math>

</p>

<p>This is a process which either offers a “choc” event and then stops, or just stops. In other words, if we treat the abstraction as an external view of the system (e.g., someone who does not see the decision reached by the person), <a href="Nondeterministic_algorithm" title="wikilink">nondeterminism</a> has been introduced.</p>
<h2 id="formal-definition">Formal definition</h2>
<h3 id="syntax">Syntax</h3>

<p>The syntax of CSP defines the “legal” ways in which processes and events may be combined. Let 

<math display="inline" id="Communicating_sequential_processes:41">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{e}
  </annotation>
 </semantics>
</math>

 be an event, and 

<math display="inline" id="Communicating_sequential_processes:42">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{X}
  </annotation>
 </semantics>
</math>

 be a set of events. Then the basic <a class="uri" href="syntax" title="wikilink">syntax</a> of CSP can be defined as:</p>

<p>

<math display="block" id="Communicating_sequential_processes:43">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="center">
     <mrow>
      <mi>P</mi>
      <mi>r</mi>
      <mi>o</mi>
      <mi>c</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi></mi>
      <mo>:</mo>
      <mo>:=</mo>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mtext>𝑆𝑇𝑂𝑃</mtext>
    </mtd>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
    <mtd columnalign="center">
     <mo stretchy="false">|</mo>
    </mtd>
    <mtd columnalign="center">
     <mtext>𝑆𝐾𝐼𝑃</mtext>
    </mtd>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
    <mtd columnalign="center">
     <mo stretchy="false">|</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi>e</mi>
      <mo>→</mo>
      <mtext>𝑃𝑟𝑜𝑐</mtext>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mo stretchy="false">(</mo>
      <mtext>prefixing</mtext>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
    <mtd columnalign="center">
     <mo stretchy="false">|</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mpadded width="+2.8pt">
       <mtext>𝑃𝑟𝑜𝑐</mtext>
      </mpadded>
      <mpadded width="+2.8pt">
       <mi mathvariant="normal">□</mi>
      </mpadded>
      <mtext>𝑃𝑟𝑜𝑐</mtext>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+2.8pt">
        <mtext>external</mtext>
       </mpadded>
       <mtext>choice</mtext>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
    <mtd columnalign="center">
     <mo stretchy="false">|</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mpadded width="+2.8pt">
       <mtext>𝑃𝑟𝑜𝑐</mtext>
      </mpadded>
      <mo rspace="5.3pt">⊓</mo>
      <mtext>𝑃𝑟𝑜𝑐</mtext>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+2.8pt">
        <mtext>nondeterministic</mtext>
       </mpadded>
       <mtext>choice</mtext>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
    <mtd columnalign="center">
     <mo stretchy="false">|</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mpadded width="+2.8pt">
       <mtext>𝑃𝑟𝑜𝑐</mtext>
      </mpadded>
      <mo stretchy="false">|</mo>
      <mo stretchy="false">|</mo>
      <mo rspace="5.3pt" stretchy="false">|</mo>
      <mtext>𝑃𝑟𝑜𝑐</mtext>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mo stretchy="false">(</mo>
      <mtext>interleaving</mtext>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
    <mtd columnalign="center">
     <mo stretchy="false">|</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mpadded width="+2.8pt">
       <mtext>𝑃𝑟𝑜𝑐</mtext>
      </mpadded>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mo stretchy="false">{</mo>
         <mi>X</mi>
         <mo stretchy="false">}</mo>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
       <mo rspace="5.3pt" stretchy="false">|</mo>
      </mrow>
      <mtext>𝑃𝑟𝑜𝑐</mtext>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+2.8pt">
        <mtext>interface</mtext>
       </mpadded>
       <mtext>parallel</mtext>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
    <mtd columnalign="center">
     <mo stretchy="false">|</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mtext>𝑃𝑟𝑜𝑐</mtext>
      <mo>∖</mo>
      <mi>X</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mo stretchy="false">(</mo>
      <mtext>hiding</mtext>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
    <mtd columnalign="center">
     <mo stretchy="false">|</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mtext>𝑃𝑟𝑜𝑐</mtext>
      <mo>;</mo>
      <mtext>𝑃𝑟𝑜𝑐</mtext>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+2.8pt">
        <mtext>sequential</mtext>
       </mpadded>
       <mtext>composition</mtext>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
    <mtd columnalign="center">
     <mo stretchy="false">|</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mpadded width="+2.8pt">
       <mi>if</mi>
      </mpadded>
      <mpadded width="+2.8pt">
       <mi>b</mi>
      </mpadded>
      <mpadded width="+2.8pt">
       <mi>then</mi>
      </mpadded>
      <mpadded width="+2.8pt">
       <mtext>𝑃𝑟𝑜𝑐</mtext>
      </mpadded>
      <mpadded width="+2.8pt">
       <mi>else</mi>
      </mpadded>
      <mi>P</mi>
      <mi>r</mi>
      <mi>o</mi>
      <mi>c</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+2.8pt">
        <mtext>boolean</mtext>
       </mpadded>
       <mtext>conditional</mtext>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
    <mtd columnalign="center">
     <mo stretchy="false">|</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mpadded width="+2.8pt">
       <mtext>𝑃𝑟𝑜𝑐</mtext>
      </mpadded>
      <mo rspace="5.3pt">▷</mo>
      <mtext>𝑃𝑟𝑜𝑐</mtext>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mo stretchy="false">(</mo>
      <mtext>timeout</mtext>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mi></mi>
    </mtd>
    <mtd columnalign="center">
     <mo stretchy="false">|</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mpadded width="+2.8pt">
       <mtext>𝑃𝑟𝑜𝑐</mtext>
      </mpadded>
      <mpadded width="+2.8pt">
       <mi mathvariant="normal">△</mi>
      </mpadded>
      <mtext>𝑃𝑟𝑜𝑐</mtext>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mo stretchy="false">(</mo>
      <mtext>interrupt</mtext>
      <mo stretchy="false">)</mo>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>r</ci>
      <ci>o</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <csymbol cd="latexml">absent</csymbol>
      <csymbol cd="latexml">assign</csymbol>
     </apply>
     <mtext>STOP</mtext>
     <csymbol cd="latexml">absent</csymbol>
    </matrixrow>
    <matrixrow>
     <csymbol cd="latexml">absent</csymbol>
     <ci>normal-|</ci>
     <mtext>SKIP</mtext>
     <csymbol cd="latexml">absent</csymbol>
    </matrixrow>
    <matrixrow>
     <csymbol cd="latexml">absent</csymbol>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>e</ci>
      <mtext>Proc</mtext>
     </apply>
     <mtext>prefixing</mtext>
    </matrixrow>
    <matrixrow>
     <csymbol cd="latexml">absent</csymbol>
     <ci>normal-|</ci>
     <apply>
      <times></times>
      <mtext>Proc</mtext>
      <ci>normal-□</ci>
      <mtext>Proc</mtext>
     </apply>
     <apply>
      <times></times>
      <mtext>external</mtext>
      <mtext>choice</mtext>
     </apply>
    </matrixrow>
    <matrixrow>
     <csymbol cd="latexml">absent</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="latexml">square-intersection</csymbol>
      <mtext>Proc</mtext>
      <mtext>Proc</mtext>
     </apply>
     <apply>
      <times></times>
      <mtext>nondeterministic</mtext>
      <mtext>choice</mtext>
     </apply>
    </matrixrow>
    <matrixrow>
     <csymbol cd="latexml">absent</csymbol>
     <ci>normal-|</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <mtext>Proc</mtext>
      <ci>normal-|</ci>
      <ci>normal-|</ci>
      <ci>normal-|</ci>
      <mtext>Proc</mtext>
     </cerror>
     <mtext>interleaving</mtext>
    </matrixrow>
    <matrixrow>
     <csymbol cd="latexml">absent</csymbol>
     <ci>normal-|</ci>
     <apply>
      <times></times>
      <mtext>Proc</mtext>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <set>
         <ci>X</ci>
        </set>
       </apply>
      </apply>
      <mtext>Proc</mtext>
     </apply>
     <apply>
      <times></times>
      <mtext>interface</mtext>
      <mtext>parallel</mtext>
     </apply>
    </matrixrow>
    <matrixrow>
     <csymbol cd="latexml">absent</csymbol>
     <ci>normal-|</ci>
     <apply>
      <setdiff></setdiff>
      <mtext>Proc</mtext>
      <ci>X</ci>
     </apply>
     <mtext>hiding</mtext>
    </matrixrow>
    <matrixrow>
     <csymbol cd="latexml">absent</csymbol>
     <ci>normal-|</ci>
     <list>
      <mtext>Proc</mtext>
      <mtext>Proc</mtext>
     </list>
     <apply>
      <times></times>
      <mtext>sequential</mtext>
      <mtext>composition</mtext>
     </apply>
    </matrixrow>
    <matrixrow>
     <csymbol cd="latexml">absent</csymbol>
     <ci>normal-|</ci>
     <apply>
      <times></times>
      <ci>if</ci>
      <ci>b</ci>
      <ci>then</ci>
      <mtext>Proc</mtext>
      <ci>else</ci>
      <ci>P</ci>
      <ci>r</ci>
      <ci>o</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <times></times>
      <mtext>boolean</mtext>
      <mtext>conditional</mtext>
     </apply>
    </matrixrow>
    <matrixrow>
     <csymbol cd="latexml">absent</csymbol>
     <ci>normal-|</ci>
     <apply>
      <ci>normal-▷</ci>
      <mtext>Proc</mtext>
      <mtext>Proc</mtext>
     </apply>
     <mtext>timeout</mtext>
    </matrixrow>
    <matrixrow>
     <csymbol cd="latexml">absent</csymbol>
     <ci>normal-|</ci>
     <apply>
      <times></times>
      <mtext>Proc</mtext>
      <ci>normal-△</ci>
      <mtext>Proc</mtext>
     </apply>
     <mtext>interrupt</mtext>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{matrix}Proc&::=&\textit{STOP}&\\
&|&\textit{SKIP}&\\
&|&e\rightarrow\textit{Proc}&(\text{prefixing})\\
&|&\textit{Proc}\;\Box\;\textit{Proc}&(\text{external}\;\text{choice})\\
&|&\textit{Proc}\;\sqcap\;\textit{Proc}&(\text{nondeterministic}\;\text{choice%
})\\
&|&\textit{Proc}\;|||\;\textit{Proc}&(\text{interleaving})\\
&|&\textit{Proc}\;|[\{X\}]|\;\textit{Proc}&(\text{interface}\;\text{parallel})%
\\
&|&\textit{Proc}\setminus X&(\text{hiding})\\
&|&\textit{Proc};\textit{Proc}&(\text{sequential}\;\text{composition})\\
&|&\mathrm{if}\;b\;\mathrm{then}\;\textit{Proc}\;\mathrm{else}\;Proc&(\text{%
boolean}\;\text{conditional})\\
&|&\textit{Proc}\;\triangleright\;\textit{Proc}&(\text{timeout})\\
&|&\textit{Proc}\;\triangle\;\textit{Proc}&(\text{interrupt})\end{matrix}
  </annotation>
 </semantics>
</math>

</p>

<p>Note that, in the interests of brevity, the syntax presented above omits the 

<math display="inline" id="Communicating_sequential_processes:44">
 <semantics>
  <mi>𝐝𝐢𝐯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐝𝐢𝐯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{div}
  </annotation>
 </semantics>
</math>

 process, which represents <a href="Divergence_(computer_science)" title="wikilink">divergence</a>, as well as various operators such as alphabetized parallel, piping, and indexed choices.</p>
<h3 id="formal-semantics">Formal semantics</h3>

<p>CSP has been imbued with several different <a href="Semantics#Computer_science" title="wikilink">formal semantics</a>, which define the <em>meaning</em> of syntactically correct CSP expressions. The theory of CSP includes mutually consistent <a href="denotational_semantics" title="wikilink">denotational semantics</a>, <a href="algebraic_semantics_(computer_science)" title="wikilink">algebraic semantics</a>, and <a href="operational_semantics" title="wikilink">operational semantics</a>.</p>
<h4 id="denotational-semantics">Denotational semantics</h4>

<p>The three major denotational models of CSP are the <em>traces</em> model, the <em>stable failures</em> model, and the <em>failures/divergences</em> model. Semantic mappings from process expressions to each of these three models provide the denotational semantics for CSP.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>

<p>The <em>traces model</em> defines the meaning of a process expression as the set of sequences of events (traces) that the process can be observed to perform. For example,</p>

<p>:* 

<math display="inline" id="Communicating_sequential_processes:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝑡𝑟𝑎𝑐𝑒𝑠</mi>
    <mrow>
     <mo>(</mo>
     <mi>𝑆𝑇𝑂𝑃</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝑡𝑟𝑎𝑐𝑒𝑠</ci>
     <ci>𝑆𝑇𝑂𝑃</ci>
    </apply>
    <set>
     <list></list>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{traces}\left(\mathit{STOP}\right)=\left\{\langle\rangle\right\}
  </annotation>
 </semantics>
</math>

 since 

<math display="inline" id="Communicating_sequential_processes:46">
 <semantics>
  <mi>𝑆𝑇𝑂𝑃</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝑆𝑇𝑂𝑃</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{STOP}
  </annotation>
 </semantics>
</math>

 performs no events</p>

<p>:* 

<math display="inline" id="Communicating_sequential_processes:47">
 <semantics>
  <mrow>
   <mi>𝑡𝑟𝑎𝑐𝑒𝑠</mi>
   <mrow>
    <mo>(</mo>
    <mi>a</mi>
    <mo>→</mo>
    <mi>b</mi>
    <mo>→</mo>
    <mi>𝑆𝑇𝑂𝑃</mi>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>a</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">traces</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">STOP</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-⟨</ci>
      <ci>normal-⟩</ci>
     </cerror>
     <ci>normal-,</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-⟨</ci>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-⟩</ci>
     </cerror>
     <ci>normal-,</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-⟨</ci>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-⟩</ci>
     </cerror>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{traces}\left(a\rightarrow b\rightarrow\mathit{STOP}\right)=\left\{%
\langle\rangle,\langle a\rangle,\langle a,b\rangle\right\}
  </annotation>
 </semantics>
</math>

 since the process 

<math display="inline" id="Communicating_sequential_processes:48">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>a</mi>
    <mo>→</mo>
    <mi>b</mi>
    <mo>→</mo>
    <mi>𝑆𝑇𝑂𝑃</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>𝑆𝑇𝑂𝑃</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a\rightarrow b\rightarrow\mathit{STOP})
  </annotation>
 </semantics>
</math>

 can be observed to have performed no events, the event 

<math display="inline" id="Communicating_sequential_processes:49">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, or the sequence of events 

<math display="inline" id="Communicating_sequential_processes:50">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 followed by 

<math display="inline" id="Communicating_sequential_processes:51">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

</p>

<p>More formally, the meaning of a process 

<math display="inline" id="Communicating_sequential_processes:52">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 in the traces model is defined as 

<math display="inline" id="Communicating_sequential_processes:53">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝑡𝑟𝑎𝑐𝑒𝑠</mi>
    <mrow>
     <mo>(</mo>
     <mi>P</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>⊆</mo>
   <msup>
    <mi mathvariant="normal">Σ</mi>
    <mo>∗</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <ci>𝑡𝑟𝑎𝑐𝑒𝑠</ci>
     <ci>P</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <ci>normal-∗</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{traces}\left(P\right)\subseteq\Sigma^{\ast}
  </annotation>
 </semantics>
</math>

 such that:</p>
<ol>
<li>

<math display="inline" id="Communicating_sequential_processes:54">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>𝑡𝑟𝑎𝑐𝑒𝑠</mi>
    <mrow>
     <mo>(</mo>
     <mi>P</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list></list>
    <apply>
     <times></times>
     <ci>𝑡𝑟𝑎𝑐𝑒𝑠</ci>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\rangle\in\mathit{traces}\left(P\right)
  </annotation>
 </semantics>
</math>

 (i.e. 

<math display="inline" id="Communicating_sequential_processes:55">
 <semantics>
  <mrow>
   <mi>𝑡𝑟𝑎𝑐𝑒𝑠</mi>
   <mrow>
    <mo>(</mo>
    <mi>P</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝑡𝑟𝑎𝑐𝑒𝑠</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{traces}\left(P\right)
  </annotation>
 </semantics>
</math>

 contains the empty sequence)</li>
<li>

<math display="inline" id="Communicating_sequential_processes:56">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mn>1</mn>
   </msub>
   <mo>⌢</mo>
   <msub>
    <mi>s</mi>
    <mn>2</mn>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mi>𝑡𝑟𝑎𝑐𝑒𝑠</mi>
    <mrow>
     <mo>(</mo>
     <mi>P</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>⟹</mo>
   <msub>
    <mi>s</mi>
    <mn>1</mn>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mi>𝑡𝑟𝑎𝑐𝑒𝑠</mi>
    <mrow>
     <mo>(</mo>
     <mi>P</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-⌢</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>𝑡𝑟𝑎𝑐𝑒𝑠</ci>
      <ci>P</ci>
     </apply>
    </apply>
    <apply>
     <implies></implies>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>𝑡𝑟𝑎𝑐𝑒𝑠</ci>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{1}\smallfrown s_{2}\in\mathit{traces}\left(P\right)\implies s_{1}\in\mathit%
{traces}\left(P\right)
  </annotation>
 </semantics>
</math>

 (i.e. 

<math display="inline" id="Communicating_sequential_processes:57">
 <semantics>
  <mrow>
   <mi>𝑡𝑟𝑎𝑐𝑒𝑠</mi>
   <mrow>
    <mo>(</mo>
    <mi>P</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝑡𝑟𝑎𝑐𝑒𝑠</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{traces}\left(P\right)
  </annotation>
 </semantics>
</math>

 is prefix-closed)</li>
</ol>

<p>where 

<math display="inline" id="Communicating_sequential_processes:58">
 <semantics>
  <msup>
   <mi mathvariant="normal">Σ</mi>
   <mo>∗</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Σ</ci>
    <ci>normal-∗</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{\ast}
  </annotation>
 </semantics>
</math>

 is the set of all possible finite sequences of events.</p>

<p>The <em>stable failures model</em> extends the traces model with refusal sets, which are sets of events 

<math display="inline" id="Communicating_sequential_processes:59">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>⊆</mo>
   <mi mathvariant="normal">Σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>X</ci>
    <ci>normal-Σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\subseteq\Sigma
  </annotation>
 </semantics>
</math>

 that a process can refuse to perform. A <em>failure</em> is a pair 

<math display="inline" id="Communicating_sequential_processes:60">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mi>s</mi>
   <mo>,</mo>
   <mi>X</mi>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>s</ci>
    <ci>X</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(s,X\right)
  </annotation>
 </semantics>
</math>

, consisting of a trace 

<math display="inline" id="Communicating_sequential_processes:61">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

, and a refusal set 

<math display="inline" id="Communicating_sequential_processes:62">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 which identifies the events that a process may refuse once it has executed the trace 

<math display="inline" id="Communicating_sequential_processes:63">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

. The observed behavior of a process in the stable failures model is described by the pair 

<math display="inline" id="Communicating_sequential_processes:64">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mrow>
    <mi>𝑡𝑟𝑎𝑐𝑒𝑠</mi>
    <mrow>
     <mo>(</mo>
     <mi>P</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>𝑓𝑎𝑖𝑙𝑢𝑟𝑒𝑠</mi>
    <mrow>
     <mo>(</mo>
     <mi>P</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <times></times>
     <ci>𝑡𝑟𝑎𝑐𝑒𝑠</ci>
     <ci>P</ci>
    </apply>
    <apply>
     <times></times>
     <ci>𝑓𝑎𝑖𝑙𝑢𝑟𝑒𝑠</ci>
     <ci>P</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\mathit{traces}\left(P\right),\mathit{failures}\left(P\right)\right)
  </annotation>
 </semantics>
</math>

. For example,</p>

<p>:* 

<math display="inline" id="Communicating_sequential_processes:65">
 <semantics>
  <mrow>
   <mi>𝑓𝑎𝑖𝑙𝑢𝑟𝑒𝑠</mi>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>(</mo>
     <mi>a</mi>
     <mo>→</mo>
     <mi>𝑆𝑇𝑂𝑃</mi>
     <mo>)</mo>
    </mrow>
    <mi mathvariant="normal">□</mi>
    <mrow>
     <mo>(</mo>
     <mi>b</mi>
     <mo>→</mo>
     <mi>𝑆𝑇𝑂𝑃</mi>
     <mo>)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">∅</mi>
     <mo>)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>a</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>{</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo>}</mo>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>b</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>{</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo>}</mo>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">failures</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">STOP</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">□</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">STOP</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-⟨</ci>
       <ci>normal-⟩</ci>
      </cerror>
      <ci>normal-,</ci>
      <emptyset></emptyset>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-⟨</ci>
       <csymbol cd="unknown">a</csymbol>
       <ci>normal-⟩</ci>
      </cerror>
      <ci>normal-,</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-{</ci>
       <csymbol cd="unknown">a</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">b</csymbol>
       <ci>normal-}</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-⟨</ci>
       <csymbol cd="unknown">b</csymbol>
       <ci>normal-⟩</ci>
      </cerror>
      <ci>normal-,</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-{</ci>
       <csymbol cd="unknown">a</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">b</csymbol>
       <ci>normal-}</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{failures}\left(\left(a\rightarrow\mathit{STOP}\right)\Box\left(b%
\rightarrow\mathit{STOP}\right)\right)=\left\{\left(\langle\rangle,\emptyset%
\right),\left(\langle a\rangle,\left\{a,b\right\}\right),\left(\langle b%
\rangle,\left\{a,b\right\}\right)\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>:* 

<math display="inline" id="Communicating_sequential_processes:66">
 <semantics>
  <mrow>
   <mi>𝑓𝑎𝑖𝑙𝑢𝑟𝑒𝑠</mi>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>(</mo>
     <mi>a</mi>
     <mo>→</mo>
     <mi>𝑆𝑇𝑂𝑃</mi>
     <mo>)</mo>
    </mrow>
    <mo>⊓</mo>
    <mrow>
     <mo>(</mo>
     <mi>b</mi>
     <mo>→</mo>
     <mi>𝑆𝑇𝑂𝑃</mi>
     <mo>)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>{</mo>
      <mi>a</mi>
      <mo>}</mo>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>{</mo>
      <mi>b</mi>
      <mo>}</mo>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>a</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>{</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo>}</mo>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>b</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>{</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo>}</mo>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">failures</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">STOP</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="latexml">square-intersection</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">STOP</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-⟨</ci>
       <ci>normal-⟩</ci>
      </cerror>
      <ci>normal-,</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-{</ci>
       <csymbol cd="unknown">a</csymbol>
       <ci>normal-}</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-⟨</ci>
       <ci>normal-⟩</ci>
      </cerror>
      <ci>normal-,</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-{</ci>
       <csymbol cd="unknown">b</csymbol>
       <ci>normal-}</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-⟨</ci>
       <csymbol cd="unknown">a</csymbol>
       <ci>normal-⟩</ci>
      </cerror>
      <ci>normal-,</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-{</ci>
       <csymbol cd="unknown">a</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">b</csymbol>
       <ci>normal-}</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-⟨</ci>
       <csymbol cd="unknown">b</csymbol>
       <ci>normal-⟩</ci>
      </cerror>
      <ci>normal-,</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-{</ci>
       <csymbol cd="unknown">a</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">b</csymbol>
       <ci>normal-}</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{failures}\left(\left(a\rightarrow\mathit{STOP}\right)\sqcap\left(b%
\rightarrow\mathit{STOP}\right)\right)=\left\{\left(\langle\rangle,\left\{a%
\right\}\right),\left(\langle\rangle,\left\{b\right\}\right),\left(\langle a%
\rangle,\left\{a,b\right\}\right),\left(\langle b\rangle,\left\{a,b\right\}%
\right)\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>The <em>failures/divergence model</em> further extends the failures model to handle <a href="divergence_(computer_science)" title="wikilink">divergence</a>. The semantics of a process in the failures/divergences model is a pair 

<math display="inline" id="Communicating_sequential_processes:67">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mrow>
    <msub>
     <mi>𝑓𝑎𝑖𝑙𝑢𝑟𝑒𝑠</mi>
     <mo>⟂</mo>
    </msub>
    <mrow>
     <mo>(</mo>
     <mi>P</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>𝑑𝑖𝑣𝑒𝑟𝑔𝑒𝑛𝑐𝑒𝑠</mi>
    <mrow>
     <mo>(</mo>
     <mi>P</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝑓𝑎𝑖𝑙𝑢𝑟𝑒𝑠</ci>
      <csymbol cd="latexml">perpendicular-to</csymbol>
     </apply>
     <ci>P</ci>
    </apply>
    <apply>
     <times></times>
     <ci>𝑑𝑖𝑣𝑒𝑟𝑔𝑒𝑛𝑐𝑒𝑠</ci>
     <ci>P</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\mathit{failures}_{\perp}\left(P\right),\mathit{divergences}\left(P%
\right)\right)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Communicating_sequential_processes:68">
 <semantics>
  <mrow>
   <mi>𝑑𝑖𝑣𝑒𝑟𝑔𝑒𝑛𝑐𝑒𝑠</mi>
   <mrow>
    <mo>(</mo>
    <mi>P</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝑑𝑖𝑣𝑒𝑟𝑔𝑒𝑛𝑐𝑒𝑠</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{divergences}\left(P\right)
  </annotation>
 </semantics>
</math>

 is defined as the set of all traces that can lead to divergent behavior and 

<math display="inline" id="Communicating_sequential_processes:69">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝑓𝑎𝑖𝑙𝑢𝑟𝑒𝑠</mi>
     <mo>⟂</mo>
    </msub>
    <mrow>
     <mo>(</mo>
     <mi>P</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>𝑓𝑎𝑖𝑙𝑢𝑟𝑒𝑠</mi>
     <mrow>
      <mo>(</mo>
      <mi>P</mi>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>∪</mo>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mo>(</mo>
      <mi>s</mi>
      <mo>,</mo>
      <mi>X</mi>
      <mo>)</mo>
     </mrow>
     <mo>∣</mo>
     <mrow>
      <mi>s</mi>
      <mo>∈</mo>
      <mrow>
       <mi>𝑑𝑖𝑣𝑒𝑟𝑔𝑒𝑛𝑐𝑒𝑠</mi>
       <mrow>
        <mo>(</mo>
        <mi>P</mi>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝑓𝑎𝑖𝑙𝑢𝑟𝑒𝑠</ci>
      <csymbol cd="latexml">perpendicular-to</csymbol>
     </apply>
     <ci>P</ci>
    </apply>
    <apply>
     <union></union>
     <apply>
      <times></times>
      <ci>𝑓𝑎𝑖𝑙𝑢𝑟𝑒𝑠</ci>
      <ci>P</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <interval closure="open">
       <ci>s</ci>
       <ci>X</ci>
      </interval>
      <apply>
       <in></in>
       <ci>s</ci>
       <apply>
        <times></times>
        <ci>𝑑𝑖𝑣𝑒𝑟𝑔𝑒𝑛𝑐𝑒𝑠</ci>
        <ci>P</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{failures}_{\perp}\left(P\right)=\mathit{failures}\left(P\right)\cup%
\left\{\left(s,X\right)\mid s\in\mathit{divergences}\left(P\right)\right\}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="tools">Tools</h2>

<p>Over the years, a number of tools for analyzing and understanding systems described using CSP have been produced. Early tool implementations used a variety of machine-readable syntaxes for CSP, making input files written for different tools incompatible. However, most CSP tools have now standardized on the machine-readable dialect of CSP devised by Bryan Scattergood, sometimes referred to as CSP<sub><em>M</em></sub>.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> The CSP<sub><em>M</em></sub> dialect of CSP possesses a formally defined <a href="operational_semantics" title="wikilink">operational semantics</a>, which includes an embedded <a href="functional_programming_language" title="wikilink">functional programming language</a>.</p>

<p>The most well-known CSP tool is probably <em>Failures/Divergence Refinement 2</em> (<em><a class="uri" href="FDR2" title="wikilink">FDR2</a></em>), which is a commercial product developed by Formal Systems (Europe) Ltd. FDR2 is often described as a <a href="model_checker" title="wikilink">model checker</a>, but is technically a <em>refinement</em> checker, in that it converts two CSP process expressions into <a href="Labelled_transition_system" title="wikilink">Labelled Transition Systems</a> (LTSs), and then determines whether one of the processes is a refinement of the other within some specified semantic model (traces, failures, or failures/divergence).<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> FDR2 applies various state-space compression algorithms to the process LTSs in order to reduce the size of the state-space that must be explored during a refinement check.</p>

<p>The <em>Adelaide Refinement Checker</em> (<em>ARC</em>) <a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> is a CSP refinement checker developed by the Formal Modelling and Verification Group at <a href="The_University_of_Adelaide" title="wikilink">The University of Adelaide</a>. ARC differs from FDR2 in that it internally represents CSP processes as <a href="Binary_decision_diagram" title="wikilink">Ordered Binary Decision Diagrams</a> (OBDDs), which alleviates the state explosion problem of explicit LTS representations without requiring the use of state-space compression algorithms such as those used in FDR2.</p>

<p>The <em>ProB</em> project,<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> which is hosted by the Institut für Informatik, Heinrich-Heine-Universität Düsseldorf, was originally created to support analysis of specifications constructed in the <a href="B_method" title="wikilink">B method</a>. However, it also includes support for analysis of CSP processes both through refinement checking, and <a href="Linear_Temporal_Logic" title="wikilink">LTL</a> model-checking. ProB can also be used to verify properties of combined CSP and B specifications.</p>

<p>The <em>Process Analysis Toolkit</em> (PAT) <a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a><a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> is a CSP analysis tool developed in the School of Computing at the <a href="National_University_of_Singapore" title="wikilink">National University of Singapore</a>. PAT is able to perform refinement checking, LTL model-checking, and simulation of CSP and Timed CSP processes. The PAT process language extends CSP with support for mutable shared variables, asynchronous message passing, and a variety of fairness and quantitative time related process constructs such as <code>deadline</code> and <code>waituntil</code>. The underlying design principle of the PAT process language is to combine a high-level specification language with procedural programs (e.g. an event in PAT may be a sequential program or even an external C# library call) for greater expressiveness. Mutable shared variables and asynchronous channels provide a convenient <a href="syntactic_sugar" title="wikilink">syntactic sugar</a> for well-known process modelling patterns used in standard CSP. The PAT syntax is similar, but not identical, to CSP<sub><em>M</em></sub>.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> The principal differences between the PAT syntax and standard CSP<sub><em>M</em></sub> are the use of semicolons to terminate process expressions, the inclusion of syntactic sugar for variables and assignments, and the use of slightly different syntax for internal choice and parallel composition.</p>

<p><em>CSPsim</em><a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> is a lazy simulator. It does not model check CSP, but is useful for exploring very large (potentially infinite) systems.</p>
<h2 id="related-formalisms">Related formalisms</h2>

<p>Several other specification languages and formalisms have been derived from, or inspired by, the classic untimed CSP, including:</p>
<ul>
<li><a href="http://citeseer.comp.nus.edu.sg/61363.html">Timed CSP</a>, which incorporates timing information for reasoning about real-time systems</li>
<li><a href="http://dx.doi.org/10.1007/BF01178564">Receptive Process Theory</a>, a specialization of CSP that assumes an asynchronous (i.e. <a href="non-blocking_algorithm" title="wikilink">nonblocking</a>) send operation</li>
<li><a href="http://www.wotug.org/paperdb/show_pap.php?f=1#=394">CSPP</a></li>
<li><a href="http://www.wotug.org/paperdb/show_pap.php?f=1#=395">HCSP</a></li>
<li><a href="Wright_(ADL)" title="wikilink">Wright</a>, an architecture description language</li>
<li><a href="http://www.comp.nus.edu.sg/~dongjs/tcoz.html">TCOZ</a>, an integration of Timed CSP and <a href="Object_Z" title="wikilink">Object Z</a></li>
<li><a href="http://www.cs.york.ac.uk/circus/">Circus</a>, an integration of CSP and <a href="Z_specification_language" title="wikilink">Z</a> based on the <a href="Unifying_Theories_of_Programming" title="wikilink">Unifying Theories of Programming</a></li>
<li><a href="http://www.compass-research.eu/approach.html">CML</a> (COMPASS Modelling Language), a combination of <a href="http://www.cs.york.ac.uk/circus/">Circus</a> and <a href="VDM_specification_language" title="wikilink">VDM</a> developed for the modelling of <a href="System_of_systems" title="wikilink">Systems of Systems</a> (SoS)</li>
<li><a href="http://www.cs.swan.ac.uk/~csmarkus/Papers/cspcasl.ps">CspCASL</a>, an extension of <a href="Common_Algebraic_Specification_Language" title="wikilink">CASL</a> that integrates CSP</li>
<li><a href="Language_Of_Temporal_Ordering_Specification" title="wikilink">LOTOS</a>, an international standard<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> that incorporates features of CSP and <a href="Calculus_of_Communicating_Systems" title="wikilink">CCS</a>.</li>
</ul>
<h2 id="comparison-with-the-actor-model">Comparison with the Actor Model</h2>

<p>In as much as it is concerned with concurrent processes that exchange messages, the <a href="Actor_model" title="wikilink">Actor model</a> is broadly similar to CSP. However, the two models make some fundamentally different choices with regard to the primitives they provide:</p>
<ul>
<li>CSP processes are anonymous, while actors have identities.</li>
</ul>
<ul>
<li>CSP message-passing fundamentally involves a rendezvous between the processes involved in sending and receiving the message, i.e. the sender cannot transmit a message until the receiver is ready to accept it. In contrast, message-passing in actor systems is fundamentally asynchronous, i.e. message transmission and reception do not have to happen at same time, and senders may transmit messages before receivers are ready to accept them. These approaches may be considered duals of each other, in the sense that rendezvous-based systems can be used to construct buffered communications that behave as asynchronous messaging systems, while asynchronous systems can be used to construct rendezvous-style communications by using a message/acknowledgement protocol to synchronize senders and receivers.</li>
</ul>
<ul>
<li>CSP uses explicit channels for message passing, whereas actor systems transmit messages to named destination actors. These approaches may also be considered duals of each other, in the sense that processes receiving through a single channel effectively have an identity corresponding to that channel, while the name-based coupling between actors may be broken by constructing actors that behave as channels.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Occam_programming_language" title="wikilink">occam</a> was the first language implementing a CSP model.</li>
<li><a href="Ease_programming_language" title="wikilink">Ease programming language</a> combines the process constructs of CSP with logically shared data structures.</li>
<li><a class="uri" href="JCSP" title="wikilink">JCSP</a> is a blending of CSP and <a href="Occam_programming_language" title="wikilink">occam</a> concepts in a <a href="Java_(programming_language)" title="wikilink">Java</a> thread support API.</li>
<li><a href="XC_Programming_Language" title="wikilink">XC</a> is a language developed by <a class="uri" href="XMOS" title="wikilink">XMOS</a> which was heavily influenced by CSP and occam</li>
<li><a href="Limbo_(programming_language)" title="wikilink">Limbo</a> is a language that implements concurrency inside the <a href="Inferno_(operating_system)" title="wikilink">Inferno</a> operating system, in a style inspired by CSP.</li>
<li><a href="Plan_9_from_Bell_Labs" title="wikilink">Plan 9 from Bell Labs</a> and <a href="Plan_9_from_User_Space" title="wikilink">Plan 9 from User Space</a> include the libthread library which allows the use of a CSP-inspired concurrency model from <a href="C_(programming_language)" title="wikilink">C</a>.</li>
<li><a class="uri" href="VerilogCSP" title="wikilink">VerilogCSP</a> is a set of <a href="Macro_(computer_science)" title="wikilink">macros</a> added to <a href="Verilog_HDL" title="wikilink">Verilog HDL</a> to support communicating sequential processes channel communications.</li>
<li><a class="uri" href="SystemVerilogCSP" title="wikilink">SystemVerilogCSP</a><a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> is a package for <a class="uri" href="SystemVerilog" title="wikilink">SystemVerilog</a> that enables abstract CSP-like communication actions in <a class="uri" href="SystemVerilog" title="wikilink">SystemVerilog</a>.</li>
<li><a href="Trace_monoid" title="wikilink">Trace monoid</a> and <a href="history_monoid" title="wikilink">history monoid</a>, the mathematical formalism of which CSP is an example.</li>
<li><a href="Trace_theory" title="wikilink">Trace theory</a>, the general theory of traces.</li>
<li><a href="Go_(programming_language)" title="wikilink">Go</a> is a programming language by <a class="uri" href="Google" title="wikilink">Google</a> incorporating ideas from CSP.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a><a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></li>
<li><a href="https://github.com/clojure/core.async/">Clojure's core.async</a> is a library for the Clojure programming language based on CSP principles.</li>
<li><a href="Joyce_(programming_language)" title="wikilink">Joyce</a> is a programming language based on the principles of CSP, developed by <a href="Brinch_Hansen" title="wikilink">Brinch Hansen</a> around 1989.</li>
<li><a class="uri" href="SuperPascal" title="wikilink">SuperPascal</a> is a programming language also developed by <a href="Brinch_Hansen" title="wikilink">Brinch Hansen</a>, influenced by CSP and his earlier work with <a href="Joyce_(programming_language)" title="wikilink">Joyce</a>.</li>
<li><a href="Ada_(programming_language)" title="wikilink">Ada</a> implements features of CSP such as the rendezvous.</li>
<li><a href="Haskell_(programming_language)" title="wikilink">Haskell</a> MVars are a rendezvous mechanism for synchronizing threads.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></li>
<li><a class="uri" href="DirectShow" title="wikilink">DirectShow</a> is the video framework inside <a class="uri" href="DirectX" title="wikilink">DirectX</a>, it uses the CSP concepts to implement the audio and video filters.</li>
<li><a class="uri" href="OpenComRTOS" title="wikilink">OpenComRTOS</a> is a formally developed network-centric distributed <a class="uri" href="RTOS" title="wikilink">RTOS</a> based on a pragmatic superset of CSP.</li>
<li><a href="Input/output_automaton" title="wikilink">Input/output automaton</a></li>
<li><a href="http://jwhanlon.com/docs/thesis.pdf">Sire</a> programming language (submitted thesis by James W. Hanlon, 2014)</li>
<li><a href="http://cml.cs.uchicago.edu">Concurrent ML</a> is a concurrent extension of Standard ML.</li>
<li><a href="https://github.com/Hopac/Hopac">Hopac</a> is a Concurrent ML style concurrent programming library for F#.</li>
<li><a href="https://github.com/rssh/scala-gopher">scala-gopher</a> is an implementation of CSP in scala</li>
<li><a href="http://www.cs.kent.ac.uk/projects/ofa/c++csp/">C++CSP2</a> is an implementation of CSP in C++</li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>
<ul>
<li>This book has been updated by <a href="Jim_Davies_(computer_scientist)" title="wikilink">Jim Davies</a> at the <a href="Oxford_University_Computing_Laboratory" title="wikilink">Oxford University Computing Laboratory</a> and the new edition is available for download as a PDF file at the <a href="http://www.usingcsp.com/">Using CSP</a> website.</li>
</ul></li>
</ul>
<ul>
<li>
<ul>
<li>Some links relating to this book are available <a href="http://web.comlab.ox.ac.uk/oucl/publications/books/concurrency/">here</a>. The full text is available for download as a <a href="http://web.comlab.ox.ac.uk/oucl/work/bill.roscoe/publications/68b.ps">PS</a> or <a href="http://web.comlab.ox.ac.uk/oucl/work/bill.roscoe/publications/68b.pdf">PDF</a> file from Bill Roscoe's <a href="http://web.comlab.ox.ac.uk/oucl/work/bill.roscoe/pubs.html">list</a> of academic publications.</li>
</ul></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.usingcsp.com/">A PDF version of Hoare's CSP book</a> - Copyright restriction apply, see the page text before downloading.</li>
<li><a href="http://www.wotug.org/">WoTUG</a>, a User Group for CSP and occam style systems, contains some information about CSP and useful links.</li>
<li>[<a class="uri" href="http://citeseerx.ist.psu.edu/search?q=communicating+sequential+processes&amp;submit">http://citeseerx.ist.psu.edu/search?q=communicating+sequential+processes&amp;submit;</a>;=Search&amp;sort;=rlv&amp;t;=doc CSP Citations from CiteSeer]</li>
<li><a href="https://github.com/loyso/LuaCSP">LuaCSP</a>, a framework that allows you to create CSP Occam-like Lua-based programming language embeddable in your application.</li>
</ul>

<p>"</p>

<p><a href="Category:1978_introductions" title="wikilink">Category:1978 introductions</a> <a href="Category:1978_in_computer_science" title="wikilink">Category:1978 in computer science</a> <a href="Category:Process_calculi" title="wikilink">Category:Process calculi</a> <a href="Category:Concurrent_computing" title="wikilink">Category:Concurrent computing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2">, INMOS document 72 occ 45 03<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="Language_Of_Temporal_Ordering_Specification" title="wikilink">ISO 8807, Language of Temporal Ordering Specification</a><a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32"></li>
<li id="fn33"><a href="http://www.youtube.com/watch?v=3DtUzH3zoFo">Origins of Go concurrency style</a>. Talk by Rob Pike at OSCON's Emerging Languages Camp 2010.<a href="#fnref33">↩</a></li>
<li id="fn34"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Concurrent-MVar.html">1</a>. Control.Concurrent.MVar<a href="#fnref34">↩</a></li>
</ol>
</section>


