<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1556">Fluent calculus</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Fluent calculus</h1>
<hr/>

<p>The <strong>fluent calculus</strong> is a formalism for expressing dynamical domains in <a href="first-order_logic" title="wikilink">first-order logic</a>. It is a variant of the <a href="situation_calculus" title="wikilink">situation calculus</a>; the main difference is that situations are considered representations of states. A binary function symbol 

<math display="inline" id="Fluent_calculus:0">
 <semantics>
  <mo>∘</mo>
  <annotation-xml encoding="MathML-Content">
   <compose></compose>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \circ
  </annotation>
 </semantics>
</math>

 is used to concatenate the terms that represent facts that hold in a situation. For example, that the box is on the table in the situation 

<math display="inline" id="Fluent_calculus:1">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 is represented by the formula 

<math display="inline" id="Fluent_calculus:2">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mi>t</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>s</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>o</mi>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>b</mi>
        <mi>o</mi>
        <mi>x</mi>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>t</mi>
        <mi>a</mi>
        <mi>b</mi>
        <mi>l</mi>
        <mi>e</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∘</mo>
     <mi>t</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <exists></exists>
     <ci>t</ci>
    </apply>
    <apply>
     <eq></eq>
     <ci>s</ci>
     <apply>
      <compose></compose>
      <apply>
       <times></times>
       <ci>o</ci>
       <ci>n</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <ci>b</ci>
         <ci>o</ci>
         <ci>x</ci>
        </apply>
        <apply>
         <times></times>
         <ci>t</ci>
         <ci>a</ci>
         <ci>b</ci>
         <ci>l</ci>
         <ci>e</ci>
        </apply>
       </interval>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists t.s=on(box,table)\circ t
  </annotation>
 </semantics>
</math>

. The <a href="frame_problem" title="wikilink">frame problem</a> is solved by asserting that the situation after the execution of an action is identical to the one before but for the conditions changed by the action. For example, the action of moving the box from the table to the floor is formalized as:</p>

<p>

<math display="block" id="Fluent_calculus:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>S</mi>
      <mi>t</mi>
      <mi>a</mi>
      <mi>t</mi>
      <mi>e</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>D</mi>
        <mi>o</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>m</mi>
          <mi>o</mi>
          <mi>v</mi>
          <mi>e</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>b</mi>
            <mi>o</mi>
            <mi>x</mi>
           </mrow>
           <mo>,</mo>
           <mrow>
            <mi>t</mi>
            <mi>a</mi>
            <mi>b</mi>
            <mi>l</mi>
            <mi>e</mi>
           </mrow>
           <mo>,</mo>
           <mrow>
            <mi>f</mi>
            <mi>l</mi>
            <mi>o</mi>
            <mi>o</mi>
            <mi>r</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>,</mo>
         <mi>s</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∘</mo>
     <mi>o</mi>
    </mrow>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mi>o</mi>
      <mi>x</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>t</mi>
      <mi>a</mi>
      <mi>b</mi>
      <mi>l</mi>
      <mi>e</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>S</mi>
      <mi>t</mi>
      <mi>a</mi>
      <mi>t</mi>
      <mi>e</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∘</mo>
     <mi>o</mi>
    </mrow>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mi>o</mi>
      <mi>x</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>f</mi>
      <mi>l</mi>
      <mi>o</mi>
      <mi>o</mi>
      <mi>r</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <compose></compose>
      <apply>
       <times></times>
       <ci>S</ci>
       <ci>t</ci>
       <ci>a</ci>
       <ci>t</ci>
       <ci>e</ci>
       <apply>
        <times></times>
        <ci>D</ci>
        <ci>o</ci>
        <interval closure="open">
         <apply>
          <times></times>
          <ci>m</ci>
          <ci>o</ci>
          <ci>v</ci>
          <ci>e</ci>
          <vector>
           <apply>
            <times></times>
            <ci>b</ci>
            <ci>o</ci>
            <ci>x</ci>
           </apply>
           <apply>
            <times></times>
            <ci>t</ci>
            <ci>a</ci>
            <ci>b</ci>
            <ci>l</ci>
            <ci>e</ci>
           </apply>
           <apply>
            <times></times>
            <ci>f</ci>
            <ci>l</ci>
            <ci>o</ci>
            <ci>o</ci>
            <ci>r</ci>
           </apply>
          </vector>
         </apply>
         <ci>s</ci>
        </interval>
       </apply>
      </apply>
      <ci>o</ci>
     </apply>
     <ci>n</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>b</ci>
       <ci>o</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>t</ci>
       <ci>a</ci>
       <ci>b</ci>
       <ci>l</ci>
       <ci>e</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <compose></compose>
      <apply>
       <times></times>
       <ci>S</ci>
       <ci>t</ci>
       <ci>a</ci>
       <ci>t</ci>
       <ci>e</ci>
       <ci>s</ci>
      </apply>
      <ci>o</ci>
     </apply>
     <ci>n</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>b</ci>
       <ci>o</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>l</ci>
       <ci>o</ci>
       <ci>o</ci>
       <ci>r</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   State(Do(move(box,table,floor),s))\circ on(box,table)=State(s)\circ on(box,floor)
  </annotation>
 </semantics>
</math>

</p>

<p>This formula states that the state after the move is added the term 

<math display="inline" id="Fluent_calculus:4">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>b</mi>
     <mi>o</mi>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>f</mi>
     <mi>l</mi>
     <mi>o</mi>
     <mi>o</mi>
     <mi>r</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <ci>n</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>o</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>l</ci>
      <ci>o</ci>
      <ci>o</ci>
      <ci>r</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   on(box,floor)
  </annotation>
 </semantics>
</math>

 and removed the term 

<math display="inline" id="Fluent_calculus:5">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>b</mi>
     <mi>o</mi>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>t</mi>
     <mi>a</mi>
     <mi>b</mi>
     <mi>l</mi>
     <mi>e</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <ci>n</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>o</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>t</ci>
      <ci>a</ci>
      <ci>b</ci>
      <ci>l</ci>
      <ci>e</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   on(box,table)
  </annotation>
 </semantics>
</math>

. Axioms specifying that 

<math display="inline" id="Fluent_calculus:6">
 <semantics>
  <mo>∘</mo>
  <annotation-xml encoding="MathML-Content">
   <compose></compose>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \circ
  </annotation>
 </semantics>
</math>

 is commutative and non-idempotent are necessary for such axioms to work.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Fluent_(artificial_intelligence)" title="wikilink">Fluent (artificial intelligence)</a></li>
<li><a href="Frame_problem" title="wikilink">Frame problem</a></li>
<li><a href="Situation_calculus" title="wikilink">Situation calculus</a></li>
<li><a href="Event_calculus" title="wikilink">Event calculus</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>M. Thielscher (1998). <a href="http://www.ep.liu.se/ej/etai/1998/006">Introduction to the fluent calculus</a>. <em><a href="Electronic_Transactions_on_Artificial_Intelligence" title="wikilink">Electronic Transactions on Artificial Intelligence</a></em>, 2(3–4):179–192.</li>
<li>M. Thielscher (2005). Reasoning Robots - The Art and Science of Programming Robotic Agents. <em>Volume 33 of Applied Logic Series.</em> Springer, Dordrecht.</li>
</ul>

<p>"</p>

<p><a href="Category:Logical_calculi" title="wikilink">Category:Logical calculi</a></p>
</body>
</html>
