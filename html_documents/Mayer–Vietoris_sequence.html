<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="483">Mayer–Vietoris sequence</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Mayer–Vietoris sequence</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, particularly <a href="algebraic_topology" title="wikilink">algebraic topology</a> and <a href="homology_theory" title="wikilink">homology theory</a>, the <strong>Mayer–Vietoris sequence</strong> is an <a href="algebra" title="wikilink">algebraic</a> tool to help compute <a href="algebraic_invariant" title="wikilink">algebraic invariants</a> of <a href="topological_space" title="wikilink">topological spaces</a>, known as their <a href="Homology_group" title="wikilink">homology</a> and <a href="cohomology_group" title="wikilink">cohomology groups</a>. The result is due to two <a href="Austria" title="wikilink">Austrian</a> mathematicians, <a href="Walther_Mayer" title="wikilink">Walther Mayer</a> and <a href="Leopold_Vietoris" title="wikilink">Leopold Vietoris</a>. The method consists of splitting a space into <a href="Subspace_topology" title="wikilink">subspaces</a>, for which the homology or cohomology groups may be easier to compute. The sequence relates the (co)homology groups of the space to the (co)homology groups of the subspaces. It is a <a href="Natural_(category_theory)" title="wikilink">natural</a> <a href="long_exact_sequence" title="wikilink">long exact sequence</a>, whose entries are the (co)homology groups of the whole space, the <a href="direct_sum_of_abelian_groups" title="wikilink">direct sum</a> of the (co)homology groups of the subspaces, and the (co)homology groups of the <a href="intersection_(set_theory)" title="wikilink">intersection</a> of the subspaces.</p>

<p>The Mayer–Vietoris sequence holds for a variety of <a href="cohomology_theory" title="wikilink">cohomology</a> and <a href="homology_theory" title="wikilink">homology theories</a>, including <a href="singular_homology" title="wikilink">singular homology</a> and <a href="singular_cohomology" title="wikilink">singular cohomology</a>. In general, the sequence holds for those theories satisfying the <a href="Eilenberg–Steenrod_axioms" title="wikilink">Eilenberg–Steenrod axioms</a>, and it has variations for both <a href="Reduced_homology" title="wikilink">reduced</a> and <a href="Relative_homology" title="wikilink">relative</a> (co)homology. Because the (co)homology of most spaces cannot be computed directly from their definitions, one uses tools such as the Mayer–Vietoris sequence in the hope of obtaining partial information. Many spaces encountered in <a class="uri" href="topology" title="wikilink">topology</a> are constructed by piecing together very simple patches. Carefully choosing the two covering subspaces so that, together with their intersection, they have simpler (co)homology than that of the whole space may allow a complete deduction of the (co)homology of the space. In that respect, the Mayer–Vietoris sequence is analogous to the <a href="Seifert–van_Kampen_theorem" title="wikilink">Seifert–van Kampen theorem</a> for the <a href="fundamental_group" title="wikilink">fundamental group</a>, and a precise relation exists for homology of dimension one.</p>
<h2 id="background-motivation-and-history">Background, motivation, and history</h2>
<figure><b>(Figure)</b>
<figcaption>Right|thumb|Leopold Vietoris on his 110th birthday</figcaption>
</figure>

<p>Like the <a href="fundamental_group" title="wikilink">fundamental group</a> or the higher <a href="homotopy_group" title="wikilink">homotopy groups</a> of a space, homology groups are important topological invariants. Although some (co)homology theories are computable using tools of <a href="linear_algebra" title="wikilink">linear algebra</a>, many other important (co)homology theories, especially singular (co)homology, are not computable directly from their definition for nontrivial spaces. For singular (co)homology, the singular (co)chains and (co)cycles groups are often too big to handle directly. More subtle and indirect approaches become necessary. The Mayer–Vietoris sequence is such an approach, giving partial information about the (co)homology groups of any space by relating it to the (co)homology groups of two of its subspaces and their intersection.</p>

<p>The most natural and convenient way to express the relation involves the algebraic concept of <a href="exact_sequence" title="wikilink">exact sequences</a>: sequences of <a href="Object_(category_theory)" title="wikilink">objects</a> (in this case <a href="Group_(mathematics)" title="wikilink">groups</a>) and <a href="morphism" title="wikilink">morphisms</a> (in this case <a href="group_homomorphism" title="wikilink">group homomorphisms</a>) between them such that the <a href="Image_(mathematics)" title="wikilink">image</a> of one morphism equals the <a href="Kernel_(algebra)" title="wikilink">kernel</a> of the next. In general, this does not allow (co)homology groups of a space to be completely computed. However, because many important spaces encountered in topology are <a href="topological_manifold" title="wikilink">topological manifolds</a>, <a href="simplicial_complex" title="wikilink">simplicial complexes</a>, or <a href="CW_complex" title="wikilink">CW complexes</a>, which are constructed by piecing together very simple patches, a theorem such as that of Mayer and Vietoris is potentially of broad and deep applicability.</p>

<p>Mayer was introduced to topology by his colleague Vietoris when attending his lectures in 1926 and 1927 at a local university in <a class="uri" href="Vienna" title="wikilink">Vienna</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> He was told about the conjectured result and a way to its solution, and solved the question for the <a href="Betti_number" title="wikilink">Betti numbers</a> in 1929.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> He applied his results to the <a class="uri" href="torus" title="wikilink">torus</a> considered as the union of two cylinders.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Vietoris later proved the full result for the homology groups in 1930 but did not express it as an exact sequence.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The concept of an exact sequence only appeared in print in the 1952 book <em>Foundations of Algebraic Topology</em> by <a href="Samuel_Eilenberg" title="wikilink">Samuel Eilenberg</a> and <a href="Norman_Steenrod" title="wikilink">Norman Steenrod</a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> where the results of Mayer and Vietoris were expressed in the modern form.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> {{-}}</p>
<h2 id="basic-versions-for-singular-homology">Basic versions for singular homology</h2>

<p>Let <em>X</em> be a <a href="topological_space" title="wikilink">topological space</a> and <em>A</em>, <em>B</em> be two subspaces whose <a href="Interior_(topology)" title="wikilink">interiors</a> cover <em>X</em>. (The interiors of <em>A</em> and <em>B</em> need not be disjoint.) The Mayer–Vietoris sequence in <a href="singular_homology" title="wikilink">singular homology</a> for the triad (<em>X</em>, <em>A</em>, <em>B</em>) is a <a href="long_exact_sequence" title="wikilink">long exact sequence</a> relating the singular homology groups (with coefficient group the integers <strong>Z</strong>) of the spaces <em>X</em>, <em>A</em>, <em>B</em>, and the <a href="intersection_(set_theory)" title="wikilink">intersection</a> <em>A</em>∩<em>B</em>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> There is an unreduced and a reduced version.</p>
<h3 id="unreduced-version">Unreduced version</h3>

<p>For unreduced homology, the Mayer–Vietoris sequence states that the following sequence is exact:<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><br/>


<math display="inline" id="Mayer–Vietoris_sequence:0">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi mathvariant="normal">⋯</mi>
      <mo>→</mo>
      <mrow>
       <msub>
        <mi>H</mi>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi></mi>
      <mpadded width="+1.7pt">
       <mover accent="true">
        <mo>→</mo>
        <msub>
         <mo>∂</mo>
         <mo>*</mo>
        </msub>
       </mover>
      </mpadded>
      <mrow>
       <msub>
        <mi>H</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>A</mi>
         <mo>∩</mo>
         <mi>B</mi>
        </mrow>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mpadded width="+1.7pt">
       <mover accent="true">
        <mo>→</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>i</mi>
          <mo>*</mo>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>j</mi>
          <mo>*</mo>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mover>
      </mpadded>
      <mrow>
       <mrow>
        <msub>
         <mi>H</mi>
         <mi>n</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>A</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⊕</mo>
       <mrow>
        <msub>
         <mi>H</mi>
         <mi>n</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>B</mi>
         <mo rspace="4.2pt" stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mpadded width="+1.7pt">
       <mover accent="true">
        <mo>→</mo>
        <mrow>
         <msub>
          <mi>k</mi>
          <mo>*</mo>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>l</mi>
          <mo>*</mo>
         </msub>
        </mrow>
       </mover>
      </mpadded>
      <mrow>
       <msub>
        <mi>H</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mover accent="true">
       <mo>→</mo>
       <msub>
        <mo>∂</mo>
        <mo>*</mo>
       </msub>
      </mover>
      <mi></mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mi></mi>
      <mpadded lspace="10pt" width="+11.7pt">
       <mover accent="true">
        <mo>→</mo>
        <msub>
         <mo>∂</mo>
         <mo>*</mo>
        </msub>
       </mover>
      </mpadded>
      <mrow>
       <msub>
        <mi>H</mi>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>A</mi>
         <mo>∩</mo>
         <mi>B</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>→</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo>→</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>H</mi>
         <mn>0</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>A</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⊕</mo>
       <mrow>
        <msub>
         <mi>H</mi>
         <mn>0</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>B</mi>
         <mo rspace="4.2pt" stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mpadded width="+1.7pt">
       <mover accent="true">
        <mo>→</mo>
        <mrow>
         <msub>
          <mi>k</mi>
          <mo>*</mo>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>l</mi>
          <mo>*</mo>
         </msub>
        </mrow>
       </mover>
      </mpadded>
      <mrow>
       <msub>
        <mi>H</mi>
        <mn>0</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>→</mo>
      <mn>0.</mn>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <ci>normal-→</ci>
      <ci>normal-⋯</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>X</ci>
      </apply>
     </apply>
     <apply>
      <and></and>
      <apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <partialdiff></partialdiff>
         <times></times>
        </apply>
        <ci>normal-→</ci>
       </apply>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <intersect></intersect>
         <ci>A</ci>
         <ci>B</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>i</ci>
          <times></times>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>j</ci>
          <times></times>
         </apply>
        </interval>
        <ci>normal-→</ci>
       </apply>
       <share href="#.cmml">
       </share>
       <apply>
        <csymbol cd="latexml">direct-sum</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>H</ci>
          <ci>n</ci>
         </apply>
         <ci>A</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>H</ci>
          <ci>n</ci>
         </apply>
         <ci>B</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>k</ci>
          <times></times>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>l</ci>
          <times></times>
         </apply>
        </apply>
        <ci>normal-→</ci>
       </apply>
       <share href="#.cmml">
       </share>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <ci>n</ci>
        </apply>
        <ci>X</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <partialdiff></partialdiff>
         <times></times>
        </apply>
        <ci>normal-→</ci>
       </apply>
       <share href="#.cmml">
       </share>
       <csymbol cd="latexml">absent</csymbol>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <and></and>
      <apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <partialdiff></partialdiff>
         <times></times>
        </apply>
        <ci>normal-→</ci>
       </apply>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <intersect></intersect>
         <ci>A</ci>
         <ci>B</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <ci>normal-→</ci>
       <share href="#.cmml">
       </share>
       <ci>normal-⋯</ci>
      </apply>
      <apply>
       <ci>normal-→</ci>
       <share href="#.cmml">
       </share>
       <apply>
        <csymbol cd="latexml">direct-sum</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>H</ci>
          <cn type="integer">0</cn>
         </apply>
         <ci>A</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>H</ci>
          <cn type="integer">0</cn>
         </apply>
         <ci>B</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>k</ci>
          <times></times>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>l</ci>
          <times></times>
         </apply>
        </apply>
        <ci>normal-→</ci>
       </apply>
       <share href="#.cmml">
       </share>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>X</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-→</ci>
       <share href="#.cmml">
       </share>
       <cn type="float">0.</cn>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{aligned}\displaystyle\cdots\rightarrow H_{n+1}(X)&\displaystyle%
\xrightarrow{\partial_{*}}\,H_{n}(A\cap B)\,\xrightarrow{(i_{*},j_{*})}\,H_{n}%
(A)\oplus H_{n}(B)\,\xrightarrow{k_{*}-l_{*}}\,H_{n}(X)\xrightarrow{\partial_{%
*}}\\
&\displaystyle\quad\xrightarrow{\partial_{*}}\,H_{n-1}(A\cap B)\rightarrow%
\cdots\rightarrow H_{0}(A)\oplus H_{0}(B)\,\xrightarrow{k_{*}-l_{*}}\,H_{0}(X)%
\rightarrow\,0.\end{aligned}
  </annotation>
 </semantics>
</math>

</p>

<p>Here the maps <em>i</em> : <em>A</em>∩<em>B</em> ↪ <em>A</em>, <em>j</em> : <em>A</em>∩<em>B</em> ↪ <em>B</em>, <em>k</em> : <em>A</em> ↪ <em>X</em>, and <em>l</em> : <em>B</em> ↪ <em>X</em> are <a href="inclusion_map" title="wikilink">inclusion maps</a> and 

<math display="inline" id="Mayer–Vietoris_sequence:1">
 <semantics>
  <mo>⊕</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">direct-sum</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \oplus
  </annotation>
 </semantics>
</math>

 denotes the <a href="direct_sum_of_abelian_groups" title="wikilink">direct sum of abelian groups</a>.</p>
<h3 id="boundary-map">Boundary map</h3>

<p> The boundary maps ∂<sub>*</sub> lowering the dimension may be made explicit as follows.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> An element in <em>H</em><sub>n</sub>(<em>X</em>) is the homology class of an <em>n</em>-cycle <em>x</em> which, by <a href="barycentric_subdivision" title="wikilink">barycentric subdivision</a> for example, can be written as the sum of two <em>n</em>-chains <em>u</em> and <em>v</em> whose images lie wholly in <em>A</em> and <em>B</em>, respectively. Thus ∂<em>x</em> = ∂(<em>u</em> + <em>v</em>) = 0 so that ∂<em>u</em> = −∂<em>v</em>. This implies that the images of both these boundary (<em>n</em> − 1)-cycles are contained in the intersection <em>A</em>∩<em>B</em>. Then ∂<sub>*</sub>([<em>x</em>]) is the class of ∂<em>u</em> in <em>H</em><sub>n−1</sub>(<em>A</em>∩<em>B</em>). Choosing another decomposition <em>x</em> = <em>u′</em> + <em>v′</em> does not affect [∂<em>u</em>], since ∂<em>u</em> + ∂<em>v</em> = ∂<em>x</em> = ∂<em>u′</em> + ∂<em>v′</em>, which implies ∂<em>u</em> − ∂<em>u′</em> = ∂(<em>v′</em> − <em>v</em>), and therefore ∂<em>u</em> and ∂<em>u′</em> lie in the same Homology class; nor does choosing a different representative <em>x′</em>, since then ∂<em>x′</em> = ∂<em>x</em> = 0. Notice that the maps in the Mayer–Vietoris sequence depend on choosing an order for <em>A</em> and <em>B</em>. In particular, the boundary map changes sign if <em>A</em> and <em>B</em> are swapped.</p>
<h3 id="reduced-version">Reduced version</h3>

<p>For <a href="reduced_homology" title="wikilink">reduced homology</a> there is also a Mayer–Vietoris sequence, under the assumption that <em>A</em> and <em>B</em> have <a class="uri" href="non-empty" title="wikilink">non-empty</a> intersection.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> The sequence is identical for positive dimensions and ends as:</p>

<p><br/>


<math display="inline" id="Mayer–Vietoris_sequence:2">
 <semantics>
  <mrow>
   <mi mathvariant="normal">⋯</mi>
   <mo>→</mo>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>H</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∩</mo>
      <mi>B</mi>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mpadded width="+1.7pt">
    <mover accent="true">
     <mo>→</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>i</mi>
       <mo>*</mo>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>j</mi>
       <mo>*</mo>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mover>
   </mpadded>
   <mrow>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>H</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mn>0</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊕</mo>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>H</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mn>0</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mpadded width="+1.7pt">
    <mover accent="true">
     <mo>→</mo>
     <mrow>
      <msub>
       <mi>k</mi>
       <mo>*</mo>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>l</mi>
       <mo>*</mo>
      </msub>
     </mrow>
    </mover>
   </mpadded>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>H</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>H</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <intersect></intersect>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <times></times>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>j</ci>
        <times></times>
       </apply>
      </interval>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-~</ci>
         <ci>H</ci>
        </apply>
        <cn type="integer">0</cn>
       </apply>
       <ci>A</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-~</ci>
         <ci>H</ci>
        </apply>
        <cn type="integer">0</cn>
       </apply>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <times></times>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>l</ci>
        <times></times>
       </apply>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>H</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdots\rightarrow\tilde{H}_{0}(A\cap B)\,\xrightarrow{(i_{*},j_{*})}\,\tilde{H%
}_{0}(A)\oplus\tilde{H}_{0}(B)\,\xrightarrow{k_{*}-l_{*}}\,\tilde{H}_{0}(X)%
\rightarrow\,0.
  </annotation>
 </semantics>
</math>

</p>
<h3 id="analogy-with-the-seifertvan-kampen-theorem">Analogy with the Seifert–van Kampen theorem</h3>

<p>There is an analogy between the Mayer–Vietoris sequence (especially for homology groups of dimension 1) and the <a href="Seifert–van_Kampen_theorem" title="wikilink">Seifert–van Kampen theorem</a>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> Whenever <em>A</em>∩<em>B</em> is <a class="uri" href="path-connected" title="wikilink">path-connected</a> the reduced Mayer–Vietoris sequence yields the isomorphism</p>

<p>

<math display="block" id="Mayer–Vietoris_sequence:3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≅</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>H</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>A</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⊕</mo>
       <mrow>
        <msub>
         <mi>H</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>B</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>/</mo>
     <mtext>Ker</mtext>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>k</mi>
       <mo>*</mo>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>l</mi>
       <mo>*</mo>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="latexml">direct-sum</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>A</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>B</ci>
       </apply>
      </apply>
      <mtext>Ker</mtext>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <times></times>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}(X)\cong(H_{1}(A)\oplus H_{1}(B))/\text{Ker}(k_{*}-l_{*})
  </annotation>
 </semantics>
</math>

</p>

<p>where, by exactness,</p>

<p>

<math display="block" id="Mayer–Vietoris_sequence:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mtext>Ker</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>k</mi>
        <mo>*</mo>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>l</mi>
        <mo>*</mo>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≅</mo>
    <mrow>
     <mtext>Im</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>i</mi>
       <mo>*</mo>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>j</mi>
       <mo>*</mo>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <mtext>Ker</mtext>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <times></times>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <mtext>Im</mtext>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>i</ci>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>j</ci>
       <times></times>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Ker}(k_{*}-l_{*})\cong\text{Im}(i_{*},j_{*}).
  </annotation>
 </semantics>
</math>

</p>

<p>This is precisely the <a href="Commutator_subgroup#Abelianization" title="wikilink">abelianized</a> statement of the Seifert–van Kampen theorem. Compare with the fact that <em>H</em><sub>1</sub>(<em>X</em>) is the abelianization of the <a href="fundamental_group" title="wikilink">fundamental group</a> π<sub>1</sub>(<em>X</em>) when <em>X</em> is path-connected.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="basic-applications">Basic applications</h2>
<h3 id="k-sphere"><em>k</em>-sphere</h3>

<p> To completely compute the homology of the <a href="n-sphere" title="wikilink"><em>k</em>-sphere</a> <em>X</em> = <em>S</em><sup><em>k</em></sup>, let <em>A</em> and <em>B</em> be two hemispheres of <em>X</em> with intersection <a href="homotopy_equivalent" title="wikilink">homotopy equivalent</a> to a (<em>k</em> − 1)-dimensional equatorial sphere. Since the <em>k</em>-dimensional hemispheres are <a class="uri" href="homeomorphic" title="wikilink">homeomorphic</a> to <em>k</em>-discs, which are <a class="uri" href="contractible" title="wikilink">contractible</a>, the homology groups for <em>A</em> and <em>B</em> are <a href="Trivial_group" title="wikilink">trivial</a>. The Mayer–Vietoris sequence for <a href="reduced_homology" title="wikilink">reduced homology</a> groups then yields</p>
<dl>
<dd><br/>


<math display="inline" id="Mayer–Vietoris_sequence:5">
 <semantics>
  <mrow>
   <mi mathvariant="normal">⋯</mi>
   <mo>→</mo>
   <mn>0</mn>
   <mo>→</mo>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>H</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo>(</mo>
     <msup>
      <mi>S</mi>
      <mi>k</mi>
     </msup>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mpadded width="+1.7pt">
    <mover accent="true">
     <mo>→</mo>
     <msub>
      <mo>∂</mo>
      <mo>*</mo>
     </msub>
    </mover>
   </mpadded>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>H</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo>(</mo>
     <msup>
      <mi>S</mi>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mn>0</mn>
   <mo>→</mo>
   <mpadded width="-1.7pt">
    <mi mathvariant="normal">⋯</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <ci>normal-⋯</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>H</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <partialdiff></partialdiff>
       <times></times>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>H</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdots\rightarrow 0\rightarrow\tilde{H}_{n}\left(S^{k}\right)\xrightarrow{%
\partial_{*}}\,\tilde{H}_{n-1}\left(S^{k-1}\right)\rightarrow 0\rightarrow\cdots\!
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>Exactness immediately implies that the map ∂<sub>*</sub> is an isomorphism. Using the <a href="reduced_homology" title="wikilink">reduced homology</a> of the <a class="uri" href="0-sphere" title="wikilink">0-sphere</a> (two points) as a <a href="Mathematical_induction" title="wikilink">base case</a>, it follows<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<dl>
<dd><br/>
<math>\tilde{H}_n\left(S^k\right)\cong\delta_{kn}\,\mathbb{Z}=\left\{\begin{matrix}
</math></dd>
</dl>

<p>\mathbb{Z} &amp; \mbox{if } n=k \\ 0 &amp; \mbox{if } n \ne k \end{matrix}\right.</p>

<p>where δ is the <a href="Kronecker_delta" title="wikilink">Kronecker delta</a>. Such a complete understanding of the homology groups for spheres is in stark contrast with current knowledge of <a href="homotopy_groups_of_spheres" title="wikilink">homotopy groups of spheres</a>, especially for the case <em>n</em> &gt; <em>k</em> about which little is known.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> {{-}}</p>
<h3 id="klein-bottle">Klein bottle</h3>

<p> A slightly more difficult application of the Mayer–Vietoris sequence is the calculation of the homology groups of the <a href="Klein_bottle" title="wikilink">Klein bottle</a> <em>X</em>. One uses the decomposition of <em>X</em> as the union of two <a href="Möbius_strip" title="wikilink">Möbius strips</a> <em>A</em> and <em>B</em> <a href="Quotient_space_(topology)" title="wikilink">glued</a> along their boundary circle (see illustration on the right). Then <em>A</em>, <em>B</em> and their intersection <em>A</em>∩<em>B</em> are <a href="Homotopy#Homotopy_equivalence_and_null-homotopy" title="wikilink">homotopy equivalent</a> to circles, so the nontrivial part of the sequence yields<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<dl>
<dd><br/>


<math display="inline" id="Mayer–Vietoris_sequence:6">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="4.2pt">→</mo>
   <mpadded width="+5pt">
    <mi>ℤ</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mover accent="true">
     <mo>→</mo>
     <mo>𝛼</mo>
    </mover>
   </mpadded>
   <mrow>
    <mi>ℤ</mi>
    <mo>⊕</mo>
    <mi>ℤ</mi>
   </mrow>
   <mo rspace="4.2pt">→</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mpadded width="-1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>ℤ</ci>
    </apply>
    <apply>
     <apply>
      <ci>α</ci>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>ℤ</ci>
      <ci>ℤ</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\rightarrow H_{2}(X)\rightarrow\,\mathbb{Z}\ \xrightarrow{\alpha}\ \mathbb{Z}%
\oplus\mathbb{Z}\rightarrow\,H_{1}(X)\rightarrow 0\!
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>and the trivial part implies vanishing homology for dimensions greater than 2. The central map α sends 1 to (2, −2) since the boundary circle of a Möbius band wraps twice around the core circle. In particular α is <a href="Injective_function" title="wikilink">injective</a> so homology of dimension 2 also vanishes. Finally, choosing (1, 0) and (1, −1) as a basis for <strong>Z</strong><sup>2</sup>, it follows</p>
<dl>
<dd><br/>
<math>\tilde{H}_n\left(X\right)\cong\delta_{1n}\,(\mathbb{Z}\oplus\mathbb{Z}_2)=\left\{\begin{matrix}
</math></dd>
</dl>

<p>\mathbb{Z}\oplus\mathbb{Z}_2 &amp; \mbox{if } n=1\\ 0 &amp; \mbox{if } n\ne1 \end{matrix}\right.  {{-}}</p>
<h3 id="wedge-sums">Wedge sums</h3>

<p> Let <em>X</em> be the <a href="wedge_sum" title="wikilink">wedge sum</a> of two spaces <em>K</em> and <em>L</em>, and suppose furthermore that the identified <a class="uri" href="basepoint" title="wikilink">basepoint</a> is a <a href="deformation_retract" title="wikilink">deformation retract</a> of <a href="Neighbourhood_(mathematics)" title="wikilink">open neighborhoods</a> <em>U</em> ⊂ <em>K</em> and <em>V</em> ⊂ <em>L</em>. Letting <em>A</em> = <em>K</em>∪<em>V</em> and <em>B</em> = <em>U</em>∪<em>L</em> it follows that <em>A</em>∪<em>B</em> = <em>X</em> and <em>A</em>∩<em>B</em> = <em>U</em>∪<em>V</em>, which is <a class="uri" href="contractible" title="wikilink">contractible</a> by construction. The reduced version of the sequence then yields (by exactness)<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>

<p>

<math display="block" id="Mayer–Vietoris_sequence:7">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>H</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>K</mi>
      <mo>∨</mo>
      <mi>L</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≅</mo>
   <mrow>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>H</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>K</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊕</mo>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>H</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>L</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-~</ci>
       <ci>H</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <or></or>
      <ci>K</ci>
      <ci>L</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>H</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <ci>K</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>H</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <ci>L</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{H}_{n}(K\vee L)\cong\tilde{H}_{n}(K)\oplus\tilde{H}_{n}(L)
  </annotation>
 </semantics>
</math>

 for all dimensions <em>n</em>. The illustration on the right shows <em>X</em> as the sum of two 2-spheres <em>K</em> and <em>L</em>. For this specific case, using the result <a href="Mayer–Vietoris_sequence#k-sphere" title="wikilink">from above</a> for 2-spheres, one has</p>

<p>

<math display="block" id="Mayer–Vietoris_sequence:8">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>H</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo>(</mo>
    <msup>
     <mi>S</mi>
     <mn>2</mn>
    </msup>
    <mo>∨</mo>
    <msup>
     <mi>S</mi>
     <mn>2</mn>
    </msup>
    <mo>)</mo>
   </mrow>
   <mo>≅</mo>
   <mpadded width="+1.7pt">
    <msub>
     <mi>δ</mi>
     <mrow>
      <mn>2</mn>
      <mi>n</mi>
     </mrow>
    </msub>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ℤ</mi>
    <mo>⊕</mo>
    <mi>ℤ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>ℤ</mi>
        <mo>⊕</mo>
        <mi>ℤ</mi>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>n</mi>
        </mrow>
        <mo>=</mo>
        <mn>2</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>n</mi>
        </mrow>
        <mo>≠</mo>
        <mn>2</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>H</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <cn type="integer">2</cn>
     </apply>
     <or></or>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Z</csymbol>
     <csymbol cd="latexml">direct-sum</csymbol>
     <csymbol cd="unknown">Z</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="latexml">direct-sum</csymbol>
        <ci>ℤ</ci>
        <ci>ℤ</ci>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <mtext>if</mtext>
         <ci>n</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <apply>
        <neq></neq>
        <apply>
         <times></times>
         <mtext>if</mtext>
         <ci>n</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </matrixrow>
     </matrix>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{H}_{n}\left(S^{2}\vee S^{2}\right)\cong\delta_{2n}\,(\mathbb{Z}\oplus%
\mathbb{Z})=\left\{\begin{matrix}\mathbb{Z}\oplus\mathbb{Z}&\mbox{if }n=2\\
0&\mbox{if }n\neq 2\end{matrix}\right.
  </annotation>
 </semantics>
</math>

 {{-}}</p>
<h3 id="suspensions">Suspensions</h3>

<p> If <em>X</em> is the <a href="Suspension_(topology)" title="wikilink">suspension</a> <em>SY</em> of a space <em>Y</em>, let <em>A</em> and <em>B</em> be the <a href="Complement_(set_theory)" title="wikilink">complements</a> in <em>X</em> of the top and bottom 'vertices' of the double cone, respectively. Then <em>X</em> is the union <em>A</em>∪<em>B</em>, with <em>A</em> and <em>B</em> contractible. Also, the intersection <em>A</em>∩<em>B</em> is homotopy equivalent to <em>Y</em>. Hence the Mayer–Vietoris sequence yields, for all <em>n</em>,<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>

<math display="block" id="Mayer–Vietoris_sequence:9">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>H</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>S</mi>
      <mi>Y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≅</mo>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>H</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-~</ci>
       <ci>H</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>Y</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-~</ci>
       <ci>H</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{H}_{n}(SY)\cong\tilde{H}_{n-1}(Y)
  </annotation>
 </semantics>
</math>

</p>

<p>The illustration on the right shows the 1-sphere <em>X</em> as the suspension of the 0-sphere <em>Y</em>. Noting in general that the <em>k</em>-sphere is the suspension of the (<em>k</em> − 1)-sphere, it is easy to derive the homology groups of the <em>k</em>-sphere by induction, <a href="Mayer–Vietoris_sequence#k-sphere" title="wikilink">as above</a>. {{-}}</p>
<h2 id="further-discussion">Further discussion</h2>
<h3 id="relative-form">Relative form</h3>

<p>A <a href="relative_homology" title="wikilink">relative</a> form of the Mayer–Vietoris sequence also exists. If <em>Y</em> ⊂ <em>X</em> and is the union of <em>C</em> ⊂ <em>A</em> and <em>D</em> ⊂ <em>B</em>, then the exact sequence is:<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><br/>


<math display="inline" id="Mayer–Vietoris_sequence:10">
 <semantics>
  <mrow>
   <mi mathvariant="normal">⋯</mi>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∩</mo>
      <mi>B</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>C</mi>
      <mo>∩</mo>
      <mi>D</mi>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mpadded width="+1.7pt">
    <mover accent="true">
     <mo>→</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>i</mi>
       <mo>*</mo>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>j</mi>
       <mo>*</mo>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mover>
   </mpadded>
   <mrow>
    <mrow>
     <msub>
      <mi>H</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo>,</mo>
      <mi>C</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊕</mo>
    <mrow>
     <msub>
      <mi>H</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo>,</mo>
      <mi>D</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mpadded width="+1.7pt">
    <mover accent="true">
     <mo>→</mo>
     <mrow>
      <msub>
       <mi>k</mi>
       <mo>*</mo>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>l</mi>
       <mo>*</mo>
      </msub>
     </mrow>
    </mover>
   </mpadded>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Y</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mpadded width="+1.7pt">
    <mover accent="true">
     <mo>→</mo>
     <msub>
      <mo>∂</mo>
      <mo>*</mo>
     </msub>
    </mover>
   </mpadded>
   <mrow>
    <msub>
     <mi>H</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∩</mo>
      <mi>B</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>C</mi>
      <mo>∩</mo>
      <mi>D</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mi mathvariant="normal">⋯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>n</ci>
      </apply>
      <interval closure="open">
       <apply>
        <intersect></intersect>
        <ci>A</ci>
        <ci>B</ci>
       </apply>
       <apply>
        <intersect></intersect>
        <ci>C</ci>
        <ci>D</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <times></times>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>j</ci>
        <times></times>
       </apply>
      </interval>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <ci>n</ci>
       </apply>
       <interval closure="open">
        <ci>A</ci>
        <ci>C</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <ci>n</ci>
       </apply>
       <interval closure="open">
        <ci>B</ci>
        <ci>D</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <times></times>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>l</ci>
        <times></times>
       </apply>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>n</ci>
      </apply>
      <interval closure="open">
       <ci>X</ci>
       <ci>Y</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <partialdiff></partialdiff>
       <times></times>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <interval closure="open">
       <apply>
        <intersect></intersect>
        <ci>A</ci>
        <ci>B</ci>
       </apply>
       <apply>
        <intersect></intersect>
        <ci>C</ci>
        <ci>D</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdots\rightarrow H_{n}(A\cap B,C\cap D)\,\xrightarrow{(i_{*},j_{*})}\,H_{n}(A%
,C)\oplus H_{n}(B,D)\,\xrightarrow{k_{*}-l_{*}}\,H_{n}(X,Y)\,\xrightarrow{%
\partial_{*}}\,H_{n-1}(A\cap B,C\cap D)\rightarrow\cdots
  </annotation>
 </semantics>
</math>

</p>
<h3 id="naturality">Naturality</h3>

<p>The homology groups are <a href="Natural_(category_theory)" title="wikilink">natural</a> in the sense that if <em>ƒ</em> is a <a href="Continuous_function_(topology)" title="wikilink">continuous</a> map from <em>X</em><sub>1</sub> to <em>X</em><sub>2</sub>, then there is a canonical <a href="pushforward_(homology)" title="wikilink">pushforward</a> map <em>ƒ</em><sub>∗</sub> of homology groups <em>ƒ</em><sub>∗</sub> : <em>H</em><sub><em>k</em></sub>(<em>X</em><sub>1</sub>) → <em>H</em><sub><em>k</em></sub>(<em>X</em><sub>2</sub>), such that the composition of pushforwards is the pushforward of a composition: that is, 

<math display="inline" id="Mayer–Vietoris_sequence:11">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>g</mi>
      <mo>∘</mo>
      <mi>h</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>g</mi>
     <mo>*</mo>
    </msub>
    <mo>∘</mo>
    <msub>
     <mi>h</mi>
     <mo>*</mo>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <compose></compose>
      <ci>g</ci>
      <ci>h</ci>
     </apply>
     <times></times>
    </apply>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (g\circ h)_{*}=g_{*}\circ h_{*}
  </annotation>
 </semantics>
</math>

. The Mayer–Vietoris sequence is also natural in the sense that if <em>X</em><sub>1</sub> = <em>A</em><sub>1</sub>∪<em>B</em><sub>1</sub> to <em>X</em><sub>2</sub> = <em>A</em><sub>2</sub>∪<em>B</em><sub>2</sub> and the mapping <em>ƒ</em> satisfies <em>ƒ</em>(<em>A</em><sub>1</sub>) ⊂ <em>A</em><sub>2</sub> and <em>ƒ</em>(<em>B</em><sub>1</sub>) ⊂ <em>B</em><sub>2</sub>, then the connecting morphism ∂<sub>∗</sub> of the Mayer–Vietoris sequence commutes with <em>ƒ</em><sub>∗</sub>.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> That is,<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> the following diagram <a href="Commutative_diagram" title="wikilink">commutes</a> (the horizontal maps are the usual ones): </p>
<h3 id="cohomological-versions">Cohomological versions</h3>

<p>The Mayer–Vietoris long exact sequence for <a href="singular_cohomology" title="wikilink">singular cohomology</a> groups with coefficient <a href="group_(mathematics)" title="wikilink">group</a> <em>G</em> is <a href="Duality_(mathematics)" title="wikilink">dual</a> to the homological version. It is the following:<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a><br/>


<math display="inline" id="Mayer–Vietoris_sequence:12">
 <semantics>
  <mrow>
   <mi mathvariant="normal">⋯</mi>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mi>n</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>;</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>H</mi>
      <mi>n</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo>;</mo>
      <mi>G</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊕</mo>
    <mrow>
     <msup>
      <mi>H</mi>
      <mi>n</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo>;</mo>
      <mi>G</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mi>n</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∩</mo>
      <mi>B</mi>
     </mrow>
     <mo>;</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>;</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mi mathvariant="normal">⋯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <ci>n</ci>
      </apply>
      <list>
       <ci>X</ci>
       <ci>G</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>H</ci>
        <ci>n</ci>
       </apply>
       <list>
        <ci>A</ci>
        <ci>G</ci>
       </list>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>H</ci>
        <ci>n</ci>
       </apply>
       <list>
        <ci>B</ci>
        <ci>G</ci>
       </list>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <ci>n</ci>
      </apply>
      <list>
       <apply>
        <intersect></intersect>
        <ci>A</ci>
        <ci>B</ci>
       </apply>
       <ci>G</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <list>
       <ci>X</ci>
       <ci>G</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdots\rightarrow H^{n}(X;G)\rightarrow H^{n}(A;G)\oplus H^{n}(B;G)\rightarrow
H%
^{n}(A\cap B;G)\rightarrow H^{n+1}(X;G)\rightarrow\cdots
  </annotation>
 </semantics>
</math>

</p>

<p>where the dimension preserving maps are restriction maps induced from inclusions, and the (co-)boundary maps are defined in a similar fashion to the homological version. There is also a relative formulation.</p>

<p>As an important special case when <em>G</em> is the group of <a href="real_number" title="wikilink">real numbers</a> <strong>R</strong> and the underlying topological space has the additional structure of a <a href="smooth_manifold" title="wikilink">smooth manifold</a>, the Mayer–Vietoris sequence for <a href="de_Rham_cohomology" title="wikilink">de Rham cohomology</a> is</p>

<p><br/>


<math display="inline" id="Mayer–Vietoris_sequence:13">
 <semantics>
  <mrow>
   <mi mathvariant="normal">⋯</mi>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>H</mi>
     <mi>n</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mpadded width="+1.7pt">
    <mover accent="true">
     <mo>→</mo>
     <mo>𝜌</mo>
    </mover>
   </mpadded>
   <mrow>
    <mrow>
     <msup>
      <mi>H</mi>
      <mi>n</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>U</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊕</mo>
    <mrow>
     <msup>
      <mi>H</mi>
      <mi>n</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>V</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mpadded width="+1.7pt">
    <mover accent="true">
     <mo>→</mo>
     <mo>Δ</mo>
    </mover>
   </mpadded>
   <mrow>
    <msup>
     <mi>H</mi>
     <mi>n</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>U</mi>
      <mo>∩</mo>
      <mi>V</mi>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mpadded width="+1.7pt">
    <mover accent="true">
     <mo>→</mo>
     <msup>
      <mi>d</mi>
      <mo>*</mo>
     </msup>
    </mover>
   </mpadded>
   <mrow>
    <msup>
     <mi>H</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mi mathvariant="normal">⋯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <ci>n</ci>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <ci>ρ</ci>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>H</ci>
        <ci>n</ci>
       </apply>
       <ci>U</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>H</ci>
        <ci>n</ci>
       </apply>
       <ci>V</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <ci>normal-Δ</ci>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <intersect></intersect>
       <ci>U</ci>
       <ci>V</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>d</ci>
       <times></times>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdots\rightarrow H^{n}(X)\,\xrightarrow{\rho}\,H^{n}(U)\oplus H^{n}(V)\,%
\xrightarrow{\Delta}\,H^{n}(U\cap V)\,\xrightarrow{d^{*}}\,H^{n+1}(X)\rightarrow\cdots
  </annotation>
 </semantics>
</math>

</p>

<p>where {<em>U</em>, <em>V</em>} is an <a href="open_cover" title="wikilink">open cover</a> of <em>X</em>, <em>ρ</em> denotes the restriction map, and Δ is the difference. The map <em>d*</em> is defined similarly as the map <em>∂</em><sub>*</sub> from above. It can be briefly described as follows. For a cohomology class [<em>ω</em>] represented by <a href="closed_and_exact_differential_forms" title="wikilink">closed form</a> <em>ω</em> in <em>U</em>∩<em>V</em>, express <em>ω</em> as a difference of forms <em>ω<sub>U</sub></em> - <em>ω<sub>V</sub></em> via a <a href="partition_of_unity" title="wikilink">partition of unity</a> subordinate to the open cover {<em>U</em>, <em>V</em>}, for example. The exterior derivative <em>dω<sub>U</sub></em> and <em>dω<sub>V</sub></em> agree on <em>U</em>∩<em>V</em> and therefore together define an <em>n</em> + 1 form <em>σ</em> on <em>X</em>. One then has <em>d*</em>([<em>ω</em>]) = [<em>σ</em>].</p>
<h3 id="derivation">Derivation</h3>

<p>Consider the <a href="Homological_algebra#Functoriality" title="wikilink">long exact sequence associated to</a> the <a href="short_exact_sequence" title="wikilink">short exact sequences</a> of <a href="chain_group" title="wikilink">chain groups</a> (constituent groups of <a href="chain_complex" title="wikilink">chain complexes</a>)</p>

<p>

<math display="block" id="Mayer–Vietoris_sequence:14">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>C</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∩</mo>
      <mi>B</mi>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mpadded width="+1.7pt">
    <mover accent="true">
     <mo>→</mo>
     <mo>𝛼</mo>
    </mover>
   </mpadded>
   <mrow>
    <mrow>
     <msub>
      <mi>C</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊕</mo>
    <mrow>
     <msub>
      <mi>C</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mpadded width="+1.7pt">
    <mover accent="true">
     <mo>→</mo>
     <mo>𝛽</mo>
    </mover>
   </mpadded>
   <mrow>
    <msub>
     <mi>C</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>+</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <intersect></intersect>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <ci>α</ci>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>n</ci>
       </apply>
       <ci>A</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>n</ci>
       </apply>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <ci>β</ci>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\rightarrow C_{n}(A\cap B)\,\xrightarrow{\alpha}\,C_{n}(A)\oplus C_{n}(B)\,%
\xrightarrow{\beta}\,C_{n}(A+B)\rightarrow 0
  </annotation>
 </semantics>
</math>

</p>

<p>where α(<em>x</em>) = (<em>x</em>, −<em>x</em>), β(<em>x</em>, <em>y</em>) = <em>x</em> + <em>y</em>, and <em>C</em><sub><em>n</em></sub>(<em>A</em> + <em>B</em>) is the chain group consisting of sums of chains in <em>A</em> and chains in <em>B</em>.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> It is a fact that the singular <em>n</em>-simplices of <em>X</em> whose images are contained in either <em>A</em> or <em>B</em> generate all of the homology group <em>H</em><sub><em>n</em></sub>(<em>X</em>).<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> In other words, <em>H</em><sub><em>n</em></sub>(<em>A</em> + <em>B</em>) is isomorphic to <em>H</em><sub><em>n</em></sub>(<em>X</em>). This gives the Mayer–Vietoris sequence for singular homology.</p>

<p>The same computation applied to the short exact sequences of vector spaces of <a href="differential_form" title="wikilink">differential forms</a></p>

<p>

<math display="block" id="Mayer–Vietoris_sequence:15">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi mathvariant="normal">Ω</mi>
     <mi>n</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mrow>
     <msup>
      <mi mathvariant="normal">Ω</mi>
      <mi>n</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>U</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊕</mo>
    <mrow>
     <msup>
      <mi mathvariant="normal">Ω</mi>
      <mi>n</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>V</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi mathvariant="normal">Ω</mi>
     <mi>n</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>U</mi>
      <mo>∩</mo>
      <mi>V</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Ω</ci>
       <ci>n</ci>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-Ω</ci>
        <ci>n</ci>
       </apply>
       <ci>U</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-Ω</ci>
        <ci>n</ci>
       </apply>
       <ci>V</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Ω</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <intersect></intersect>
       <ci>U</ci>
       <ci>V</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\rightarrow\Omega^{n}(X)\rightarrow\Omega^{n}(U)\oplus\Omega^{n}(V)%
\rightarrow\Omega^{n}(U\cap V)\rightarrow 0
  </annotation>
 </semantics>
</math>

</p>

<p>yields the Mayer–Vietoris sequence for de Rham cohomology.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>

<p>From a formal point of view, the Mayer–Vietoris sequence can be derived from the <a href="Eilenberg–Steenrod_axioms" title="wikilink">Eilenberg–Steenrod axioms</a> for <a href="homology_theory" title="wikilink">homology theories</a> using the <a href="long_exact_sequence_in_homology" title="wikilink">long exact sequence in homology</a>.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>
<h3 id="other-homology-theories">Other homology theories</h3>

<p>The derivation of the Mayer–Vietoris sequence from the Eilenberg–Steenrod axioms does not require the <a href="dimension_axiom" title="wikilink">dimension axiom</a>,<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> so in addition to existing in <a href="List_of_cohomology_theories#Ordinary_homology_theories" title="wikilink">ordinary cohomology theories</a>, it holds in <a href="extraordinary_cohomology_theories" title="wikilink">extraordinary cohomology theories</a> (such as <a href="topological_K-theory" title="wikilink">topological K-theory</a> and <a class="uri" href="cobordism" title="wikilink">cobordism</a>).</p>
<h3 id="sheaf-cohomology">Sheaf cohomology</h3>

<p>From the point of view of <a href="sheaf_cohomology" title="wikilink">sheaf cohomology</a>, the Mayer–Vietoris sequence is related to <a href="Čech_cohomology" title="wikilink">Čech cohomology</a>. Specifically, it arises from the <a href="Spectral_sequence" title="wikilink">degeneration</a> of the <a href="spectral_sequence" title="wikilink">spectral sequence</a> that relates Čech cohomology to sheaf cohomology (sometimes called the <a href="Mayer–Vietoris_spectral_sequence" title="wikilink">Mayer–Vietoris spectral sequence</a>) in the case where the open cover used to compute the Čech cohomology consists of two open sets.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> This spectral sequence exists in arbitrary <a href="Topos" title="wikilink">topoi</a>.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Excision_theorem" title="wikilink">Excision theorem</a></li>
<li><a href="Zig-zag_lemma" title="wikilink">Zig-zag lemma</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>. </p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li>

<p>. </p></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Homology_theory" title="wikilink">Category:Homology theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"> (SGA 4.V.3)<a href="#fnref30">↩</a></li>
</ol>
</section>
</body>
</html>
