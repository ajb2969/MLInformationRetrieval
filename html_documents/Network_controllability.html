<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1612">Network controllability</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Network controllability</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Controlling a simple network.</figcaption>
</figure>

<p><strong>Network Controllability</strong> is concerned about the structural <a class="uri" href="controllability" title="wikilink">controllability</a> of a <a href="Graph_(mathematics)" title="wikilink">network</a>. Controllability describes our ability to guide a dynamical system from any initial state to any desired final state in finite time, with a suitable choice of inputs. This definition agrees well with our intuitive notion of control. The controllability of general directed and weighted complex networks has recently been the subject of intense study by a number of groups, worldwide.</p>
<h2 id="background">Background</h2>

<p>Consider the canonical linear time-invariant dynamics on a complex network 

<math display="inline" id="Network_controllability:0">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>ùêó</mi>
     <mo>Àô</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>ùêÄ</mi>
      <mo>‚ãÖ</mo>
      <mi>ùêó</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mi>ùêÅ</mi>
      <mo>‚ãÖ</mo>
      <mi>ùêÆ</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-Àô</ci>
      <ci>ùêó</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-‚ãÖ</ci>
       <ci>ùêÄ</ci>
       <ci>ùêó</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-‚ãÖ</ci>
       <ci>ùêÅ</ci>
       <ci>ùêÆ</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\mathbf{X}}(t)=\mathbf{A}\cdot\mathbf{X}(t)+\mathbf{B}\cdot\mathbf{u}(t)
  </annotation>
 </semantics>
</math>

 where the vector 

<math display="inline" id="Network_controllability:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>ùêó</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">‚ãØ</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>N</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ùêó</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <vector>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>t</ci>
      </apply>
      <ci>normal-‚ãØ</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>N</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </vector>
     <ci>normal-T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{X}(t)=(x_{1}(t),\cdots,x_{N}(t))^{\mathrm{T}}
  </annotation>
 </semantics>
</math>

 captures the state of a system of 

<math display="inline" id="Network_controllability:2">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 nodes at time 

<math display="inline" id="Network_controllability:3">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>


. The 

<math display="inline" id="Network_controllability:4">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>√ó</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\times N
  </annotation>
 </semantics>
</math>

 matrix 

<math display="inline" id="Network_controllability:5">
 <semantics>
  <mi>ùêÄ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêÄ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

 describes the system's wiring diagram and the interaction strength between the components. The 

<math display="inline" id="Network_controllability:6">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>√ó</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\times M
  </annotation>
 </semantics>
</math>

 matrix 

<math display="inline" id="Network_controllability:7">
 <semantics>
  <mi>ùêÅ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêÅ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{B}
  </annotation>
 </semantics>
</math>

 identifies the nodes controlled by an outside controller. The system is controlled through the time dependent input vector 

<math display="inline" id="Network_controllability:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>ùêÆ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>u</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">‚ãØ</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>u</mi>
       <mi>M</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ùêÆ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <vector>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>t</ci>
      </apply>
      <ci>normal-‚ãØ</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>M</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </vector>
     <ci>normal-T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}(t)=(u_{1}(t),\cdots,u_{M}(t))^{\mathrm{T}}
  </annotation>
 </semantics>
</math>


 that the controller imposes on the system. To identify the <em>minimum</em> number of driver nodes, denoted by 

<math display="inline" id="Network_controllability:9">
 <semantics>
  <msub>
   <mi>N</mi>
   <mi mathvariant="normal">D</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <ci>normal-D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{\mathrm{D}}
  </annotation>
 </semantics>
</math>

, whose control is sufficient to fully control the system's dynamics, Liu et al.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> attempted to combine the tools from structural control theory, graph theory and statistical physics. They showed<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> that the minimum number of inputs or driver nodes needed to maintain full control of the network is determined by the 'maximum matching‚Äô in the network, that is, the maximum set of links that do not share start or end nodes. They tried<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> to develop an analytical framework, based on the in-out degree distribution, which predicts 

<math display="inline" id="Network_controllability:10">
 <semantics>
  <mrow>
   <msub>
    <mi>n</mi>
    <mi mathvariant="normal">D</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>N</mi>
     <mi mathvariant="normal">D</mi>
    </msub>
    <mo>/</mo>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>normal-D</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>normal-D</ci>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{\mathrm{D}}=N_{\mathrm{D}}/N
  </annotation>
 </semantics>
</math>

 for scale-free and Erd≈ës‚ÄìR√©nyi Graphs. It is however notable, that their formulation<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> would predict same values of 

<math display="inline" id="Network_controllability:11">
 <semantics>
  <msub>
   <mi>n</mi>
   <mi mathvariant="normal">D</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <ci>normal-D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {n_{\mathrm{D}}}
  </annotation>
 </semantics>
</math>

 for a chain graph and for a weak densely connected graph. Obviously, both these graphs have very different in and out degree distributions. A recent unpublished work,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> questions whether <a href="Degree_(graph_theory)" title="wikilink">degree</a>, which is a purely local measure in networks, would completely describe controllability and whether even slightly distant nodes would have no role in deciding network controllability. Indeed, for many real-word networks, namely, food webs, neuronal and metabolic networks, the mismatch in values of 

<math display="inline" id="Network_controllability:12">
 <semantics>
  <mmultiscripts>
   <mi>n</mi>
   <mi mathvariant="normal">D</mi>
   <none></none>
   <none></none>
   <mrow>
    <mi>r</mi>
    <mi>e</mi>
    <mi>a</mi>
    <mi>l</mi>
   </mrow>
  </mmultiscripts>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>normal-D</ci>
    </apply>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>e</ci>
     <ci>a</ci>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {n_{\mathrm{D}}}^{real}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Network_controllability:13">
 <semantics>
  <mmultiscripts>
   <mi>n</mi>
   <mi mathvariant="normal">D</mi>
   <none></none>
   <none></none>
   <mrow>
    <mi>rand</mi>
    <mi mathvariant="normal">_</mi>
    <mi>degree</mi>
   </mrow>
  </mmultiscripts>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>normal-D</ci>
    </apply>
    <apply>
     <times></times>
     <ci>rand</ci>
     <ci>normal-_</ci>
     <ci>degree</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {n_{\mathrm{D}}}^{\mathrm{rand\_degree}}
  </annotation>
 </semantics>
</math>


 calculated by Liu et al.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> is notable. It is obvious that if controllability is decided mainly by degree, why are 

<math display="inline" id="Network_controllability:14">
 <semantics>
  <mmultiscripts>
   <mi>n</mi>
   <mi mathvariant="normal">D</mi>
   <none></none>
   <none></none>
   <mrow>
    <mi>r</mi>
    <mi>e</mi>
    <mi>a</mi>
    <mi>l</mi>
   </mrow>
  </mmultiscripts>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>normal-D</ci>
    </apply>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>e</ci>
     <ci>a</ci>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {n_{\mathrm{D}}}^{real}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Network_controllability:15">
 <semantics>
  <mmultiscripts>
   <mi>n</mi>
   <mi mathvariant="normal">D</mi>
   <none></none>
   <none></none>
   <mrow>
    <mi>rand</mi>
    <mi mathvariant="normal">_</mi>
    <mi>degree</mi>
   </mrow>
  </mmultiscripts>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>normal-D</ci>
    </apply>
    <apply>
     <times></times>
     <ci>rand</ci>
     <ci>normal-_</ci>
     <ci>degree</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {n_{\mathrm{D}}}^{\mathrm{rand\_degree}}
  </annotation>
 </semantics>
</math>

 so different for many real world networks? They argued <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> (arXiv:1203.5161v1), that this might be due to the effect of degree correlations. However, it has been shown<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> that network controllability can be altered only by using <a href="betweenness_centrality" title="wikilink">betweenness centrality</a> and <a href="closeness_centrality" title="wikilink">closeness centrality</a>, without using <a href="degree_(graph_theory)" title="wikilink">degree (graph theory)</a> or degree correlations at all.</p>
<figure><b>(Figure)</b>
<embed src="YYL2.pdf" title='A schematic digram shows the control of a directed network. For a given directed network (Fig. a), one calculates its maximum matching: a largest set of edges without common heads or tails. The maximum matching will compose of a set of vertex-disjoint directed paths and directed cycles (see red edges in Fig.b). If a node is a head of a matching edge, then this node is matched (green nodes in Fig.b). Otherwise, it is unmatched (white nodes in Fig.b). Those unmatched nodes are the nodes one needs to control, i.e. the driver nodes. By injecting signals to those driver nodes, one gets a set of directed path with starting points being the inputs (see Fig.c). Those paths are called "stems". The resulting digraph is called U-rooted factorial connection. By "grafting" the directed cycles to those "stems", one gets "buds". The resulting digraph is called the cacti (see Fig.d). According to the structural controllability theorem, since there is a cacti structure spanning the controlled network (see Fig.e), the system is controllable. The cacti structure (Fig.d) underlying the controlled network (Fig.e) is the "skeleton" for maintaining controllability.'></embed><figcaption>A schematic digram shows the control of a directed network. For a given directed network (Fig. a), one calculates its maximum matching: a largest set of edges without common heads or tails. The maximum matching will compose of a set of vertex-disjoint directed paths and directed cycles (see red edges in Fig.b). If a node is a head of a matching edge, then this node is matched (green nodes in Fig.b). Otherwise, it is unmatched (white nodes in Fig.b). Those unmatched nodes are the nodes one needs to control, i.e. the driver nodes. By injecting signals to those driver nodes, one gets a set of directed path with starting points being the inputs (see Fig.c). Those paths are called "stems". The resulting digraph is called U-rooted factorial connection. By "grafting" the directed cycles to those "stems", one gets "buds". The resulting digraph is called the cacti (see Fig.d). According to the structural controllability theorem,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> since there is a cacti structure spanning the controlled network (see Fig.e), the system is controllable. The cacti structure (Fig.d) underlying the controlled network (Fig.e) is the "skeleton" for maintaining controllability.</figcaption>
</figure>
<h3 id="structural-controllability">Structural Controllability</h3>

<p>The concept of the structural properties was first introduced by Lin (1974)<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> and then extended by Shields and Pearson (1976)<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> and alternatively derived by Glover and Silverman (1976).<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> The main question is whether the lack of controllability or observability are generic with respect to the variable system parameters. In the framework of structural control the system parameters are either independent free variables or fixed zeros. This is consistent for models of physical systems since parameter values are never known exactly, with the exception of zero values which express the absence of interactions or connections.</p>
<h3 id="maximum-matching">Maximum Matching</h3>

<p>In graph theory, a <a href="matching_(graph_theory)" title="wikilink">matching</a> is a set of edges without common vertices. Liu et al.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> extended this definition to directed graph, where a matching is a set of directed edges that do not share start or end vertices. It is easy to check that a matching of a directed graph composes of a set of vertex-disjoint simple paths and cycles. The maximum matching of a directed network can be efficiently calculated by working in the bipartite representation using the classical <a href="Hopcroft‚ÄìKarp_algorithm" title="wikilink">Hopcroft‚ÄìKarp algorithm</a>, which runs in O(<em>E</em>‚àöN) time in the worst case. For undirected graph, analytical solutions of the size and number of maximum matchings have been studied using the <a href="cavity_method" title="wikilink">cavity method</a> developed in statistical physics.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Liu et al.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> extended the calculations for directed graph.</p>

<p>By calculating the maximum matchings of a wide range of real networks, Liu et al.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> asserted that the number of driver nodes is determined mainly by the networks degree distribution 

<math display="inline" id="Network_controllability:16">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>k</mi>
     <mi>in</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>k</mi>
     <mi>out</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <ci>in</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <ci>out</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(k_{\mathrm{in}},k_{\mathrm{out}})
  </annotation>
 </semantics>
</math>

. They also calculated the average number of driver nodes for a network ensemble with arbitrary degree distribution using the <a href="cavity_method" title="wikilink">cavity method</a>. It is interesting that for a chain graph and a weak densely connected graph, both of which have very different in and out degree distributions; the formulation of Liu et al.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> would predict same values of 

<math display="inline" id="Network_controllability:17">
 <semantics>
  <msub>
   <mi>n</mi>
   <mi mathvariant="normal">D</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <ci>normal-D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {n_{\mathrm{D}}}
  </annotation>
 </semantics>
</math>

. Also, for many real-word networks, namely, food webs, neuronal and metabolic networks, the mismatch in values of 

<math display="inline" id="Network_controllability:18">
 <semantics>
  <mmultiscripts>
   <mi>n</mi>
   <mi mathvariant="normal">D</mi>
   <none></none>
   <none></none>
   <mrow>
    <mi>r</mi>
    <mi>e</mi>
    <mi>a</mi>
    <mi>l</mi>
   </mrow>
  </mmultiscripts>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>normal-D</ci>
    </apply>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>e</ci>
     <ci>a</ci>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {n_{\mathrm{D}}}^{real}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Network_controllability:19">
 <semantics>
  <mmultiscripts>
   <mi>n</mi>
   <mi mathvariant="normal">D</mi>
   <none></none>
   <none></none>
   <mrow>
    <mi>rand</mi>
    <mi mathvariant="normal">_</mi>
    <mi>degree</mi>
   </mrow>
  </mmultiscripts>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>normal-D</ci>
    </apply>
    <apply>
     <times></times>
     <ci>rand</ci>
     <ci>normal-_</ci>
     <ci>degree</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {n_{\mathrm{D}}}^{\mathrm{rand\_degree}}
  </annotation>
 </semantics>
</math>

 calculated by Liu et al.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> is notable. If controllability is decided purely by degree, why are 

<math display="inline" id="Network_controllability:20">
 <semantics>
  <mmultiscripts>
   <mi>n</mi>
   <mi mathvariant="normal">D</mi>
   <none></none>
   <none></none>
   <mrow>
    <mi>r</mi>
    <mi>e</mi>
    <mi>a</mi>
    <mi>l</mi>
   </mrow>
  </mmultiscripts>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>normal-D</ci>
    </apply>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>e</ci>
     <ci>a</ci>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {n_{\mathrm{D}}}^{real}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Network_controllability:21">
 <semantics>
  <mmultiscripts>
   <mi>n</mi>
   <mi mathvariant="normal">D</mi>
   <none></none>
   <none></none>
   <mrow>
    <mi>rand</mi>
    <mi mathvariant="normal">_</mi>
    <mi>degree</mi>
   </mrow>
  </mmultiscripts>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>normal-D</ci>
    </apply>
    <apply>
     <times></times>
     <ci>rand</ci>
     <ci>normal-_</ci>
     <ci>degree</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {n_{\mathrm{D}}}^{\mathrm{rand\_degree}}
  </annotation>
 </semantics>
</math>

 so different for many real world networks? It remains open to scrutiny whether ''control robustness" in networks is influenced more by using <a href="betweenness_centrality" title="wikilink">betweenness centrality</a> and <a href="closeness_centrality" title="wikilink">closeness centrality</a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> over <a href="degree_(graph_theory)" title="wikilink">degree (graph theory)</a> based metrics.</p>

<p>While sparser graphs are more difficult to control,<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> it would obviously be interesting to find whether <a href="betweenness_centrality" title="wikilink">betweenness centrality</a> and <a href="closeness_centrality" title="wikilink">closeness centrality</a><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> or degree heterogeneity<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> plays a more important role in deciding controllability of sparse graphs with almost similar degree distributions.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Controllability_Gramian" title="wikilink">Controllability Gramian</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://barabasilab.neu.edu/projects/controllability/">The network controllability project website</a></li>
<li><a href="http://www.youtube.com/watch?v=9-q2qpOJfkg">The video showing network controllability</a></li>
</ul>

<p>"</p>

<p><a href="Category:Articles_created_via_the_Article_Wizard" title="wikilink">Category:Articles created via the Article Wizard</a> <a href="Category:Network_theory" title="wikilink">Category:Network theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Y.-Y. Liu, J.-J. Slotine, A.-L. Barab√°si, <em>Nature</em> <strong>473</strong> (2011).<a href="#fnref1">‚Ü©</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5">SJ Banerjee and S Roy, ARXIV:1209.3737<a href="#fnref5">‚Ü©</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10">C.-T. Lin, <em>IEEE Trans. Auto. Contr.</em> <strong>19</strong> (1974).<a href="#fnref10">‚Ü©</a></li>
<li id="fn11">R. W. Shields and J. B. Pearson, <em>IEEE Trans. Auto. Contr.</em> <strong>21</strong> (1976).<a href="#fnref11">‚Ü©</a></li>
<li id="fn12">K. Glover and L. M. Silverman, <em>IEEE Trans. Auto. Contr.</em> <strong>21</strong> (1976).<a href="#fnref12">‚Ü©</a></li>
<li id="fn13"></li>
<li id="fn14">L. Zdeborova and M. Mezard, <em>J. Stat. Mech.</em> <strong>05</strong> (2006).<a href="#fnref14">‚Ü©</a></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
</ol>
</section>
</body>
</html>
