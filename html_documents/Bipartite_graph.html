<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1379">Bipartite graph</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Bipartite graph</h1>
<hr/>

<p>  In the <a href="mathematics" title="wikilink">mathematical</a> field of <a href="graph_theory" title="wikilink">graph theory</a>, a <strong>bipartite graph</strong> (or <strong>bigraph</strong>) is a <a href="graph_(mathematics)" title="wikilink">graph</a> whose <a href="vertex_(graph_theory)" title="wikilink">vertices</a> can be divided into two <a href="disjoint_sets" title="wikilink">disjoint sets</a> 

<math display="inline" id="Bipartite_graph:0">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bipartite_graph:1">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 (that is, 

<math display="inline" id="Bipartite_graph:2">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bipartite_graph:3">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 are each <a href="Independent_set_(graph_theory)" title="wikilink">independent sets</a>) such that every <a href="edge_(graph_theory)" title="wikilink">edge</a> connects a vertex in 

<math display="inline" id="Bipartite_graph:4">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 to one in 

<math display="inline" id="Bipartite_graph:5">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

. Vertex set 

<math display="inline" id="Bipartite_graph:6">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bipartite_graph:7">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 are often denoted as <em>partite sets</em>. Equivalently, a bipartite graph is a graph that does not contain any odd-length <a href="cycle_(graph_theory)" title="wikilink">cycles</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>The two sets 

<math display="inline" id="Bipartite_graph:8">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bipartite_graph:9">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 may be thought of as a <a href="graph_coloring" title="wikilink">coloring</a> of the graph with two colors: if one colors all nodes in 

<math display="inline" id="Bipartite_graph:10">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 blue, and all nodes in 

<math display="inline" id="Bipartite_graph:11">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 green, each edge has endpoints of differing colors, as is required in the graph coloring problem.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> In contrast, such a coloring is impossible in the case of a non-bipartite graph, such as a <a href="Gallery_of_named_graphs" title="wikilink">triangle</a>: after one node is colored blue and another green, the third vertex of the triangle is connected to vertices of both colors, preventing it from being assigned either color.</p>

<p>One often writes 

<math display="inline" id="Bipartite_graph:12">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>U</mi>
    <mo>,</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <vector>
     <ci>U</ci>
     <ci>V</ci>
     <ci>E</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(U,V,E)
  </annotation>
 </semantics>
</math>

 to denote a bipartite graph whose partition has the parts 

<math display="inline" id="Bipartite_graph:13">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bipartite_graph:14">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Bipartite_graph:15">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 denoting the edges of the graph. If a bipartite graph is not <a href="connected_graph" title="wikilink">connected</a>, it may have more than one bipartition;<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> in this case, the 

<math display="inline" id="Bipartite_graph:16">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>U</mi>
   <mo>,</mo>
   <mi>V</mi>
   <mo>,</mo>
   <mi>E</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>U</ci>
    <ci>V</ci>
    <ci>E</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (U,V,E)
  </annotation>
 </semantics>
</math>

 notation is helpful in specifying one particular bipartition that may be of importance in an application. If 

<math display="inline" id="Bipartite_graph:17">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>U</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>V</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <ci>U</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |U|=|V|
  </annotation>
 </semantics>
</math>

, that is, if the two subsets have equal <a class="uri" href="cardinality" title="wikilink">cardinality</a>, then 

<math display="inline" id="Bipartite_graph:18">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is called a <em>balanced</em> bipartite graph.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> If all vertices on the same side of the bipartition have the same <a href="Degree_(graph_theory)" title="wikilink">degree</a>, then 

<math display="inline" id="Bipartite_graph:19">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is called <a href="biregular_graph" title="wikilink">biregular</a>.</p>
<h2 id="examples">Examples</h2>

<p>When modelling relations between two different classes of objects, bipartite graphs very often arise naturally. For instance, a graph of football players and clubs, with an edge between a player and a club if the player has played for that club, is a natural example of an <em>affiliation network</em>, a type of bipartite graph used in <a href="social_network_analysis" title="wikilink">social network analysis</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>Another example where bipartite graphs appear naturally is in the (<a class="uri" href="NP-complete" title="wikilink">NP-complete</a>) railway optimization problem, in which the input is a schedule of trains and their stops, and the goal is to find a set of train stations as small as possible such that every train visits at least one of the chosen stations. This problem can be modeled as a <a href="dominating_set" title="wikilink">dominating set</a> problem in a bipartite graph that has a vertex for each train and each station and an edge for each pair of a station and a train that stops at that station.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>A third example is in the academic field of numismatics. Ancient coins are made using two positive impressions of the design (the obverse and reverse). The charts numismatists produce to represent the production of coins are bipartite graphs. <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>More abstract examples include the following:</p>
<ul>
<li>Every <a href="tree_(graph_theory)" title="wikilink">tree</a> is bipartite.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></li>
<li><a href="Cycle_graph" title="wikilink">Cycle graphs</a> with an even number of vertices are bipartite.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></li>
<li>Every <a href="planar_graph" title="wikilink">planar graph</a> whose <a href="Glossary_of_graph_theory#Genus" title="wikilink">faces</a> all have even length is bipartite.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Special cases of this are <a href="grid_graph" title="wikilink">grid graphs</a> and <a href="squaregraph" title="wikilink">squaregraphs</a>, in which every inner face consists of 4 edges and every inner vertex has four or more neighbors.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></li>
<li>The <a href="complete_bipartite_graph" title="wikilink">complete bipartite graph</a> on <em>m</em> and <em>n</em> vertices, denoted by <em>K<sub>n,m</sub></em> is the bipartite graph <em>G = (U, V, E)</em>, where <em>U</em> and <em>V</em> are disjoint sets of size <em>m</em> and <em>n</em>, respectively, and <em>E</em> connects every vertex in <em>U</em> with all vertices in <em>V</em>. It follows that <em>K<sub>m,n</sub></em> has <em>mn</em> edges.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Closely related to the complete bipartite graphs are the <a href="crown_graph" title="wikilink">crown graphs</a>, formed from complete bipartite graphs by removing the edges of a <a href="perfect_matching" title="wikilink">perfect matching</a>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></li>
<li><a href="Hypercube_graph" title="wikilink">Hypercube graphs</a>, <a href="partial_cube" title="wikilink">partial cubes</a>, and <a href="median_graph" title="wikilink">median graphs</a> are bipartite. In these graphs, the vertices may be labeled by <a href="bitvector" title="wikilink">bitvectors</a>, in such a way that two vertices are adjacent if and only if the corresponding bitvectors differ in a single position. A bipartition may be formed by separating the vertices whose bitvectors have an even number of ones from the vertices with an odd number of ones. Trees and squaregraphs form examples of median graphs, and every median graph is a partial cube.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></li>
</ul>
<h2 id="properties">Properties</h2>
<h3 id="characterization">Characterization</h3>

<p>Bipartite graphs may be characterized in several different ways:</p>
<ul>
<li>A graph is bipartite <a href="if_and_only_if" title="wikilink">if and only if</a> it does not contain an <a href="odd_cycle" title="wikilink">odd cycle</a>.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></li>
<li>A graph is bipartite if and only if it is 2-colorable, (i.e. its <a href="chromatic_number" title="wikilink">chromatic number</a> is less than or equal to 2).<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></li>
<li>The <a href="Spectral_graph_theory" title="wikilink">spectrum</a> of a graph is symmetric if and only if it's a bipartite graph.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></li>
</ul>
<h3 id="königs-theorem-and-perfect-graphs">König's theorem and perfect graphs</h3>

<p>In bipartite graphs, the size of <a href="minimum_vertex_cover" title="wikilink">minimum vertex cover</a> is equal to the size of the <a href="maximum_matching" title="wikilink">maximum matching</a>; this is <a href="König's_theorem_(graph_theory)" title="wikilink">König's theorem</a>.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> An alternative and equivalent form of this theorem is that the size of the <a href="maximum_independent_set" title="wikilink">maximum independent set</a> plus the size of the maximum matching is equal to the number of vertices. In any graph without <a href="isolated_vertex" title="wikilink">isolated vertices</a> the size of the <a href="minimum_edge_cover" title="wikilink">minimum edge cover</a> plus the size of a maximum matching equals the number of vertices.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> Combining this equality with König's theorem leads to the facts that, in bipartite graphs, the size of the minimum edge cover is equal to the size of the maximum independent set, and the size of the minimum edge cover plus the size of the minimum vertex cover is equal to the number of vertices.</p>

<p>Another class of related results concerns <a href="perfect_graph" title="wikilink">perfect graphs</a>: every bipartite graph, the <a href="complement_(graph_theory)" title="wikilink">complement</a> of every bipartite graph, the <a href="line_graph" title="wikilink">line graph</a> of every bipartite graph, and the complement of the line graph of every bipartite graph, are all perfect. Perfection of bipartite graphs is easy to see (their <a href="chromatic_number" title="wikilink">chromatic number</a> is two and their <a href="maximum_clique" title="wikilink">maximum clique</a> size is also two) but perfection of the <a href="complement_(graph_theory)" title="wikilink">complements</a> of bipartite graphs is less trivial, and is another restatement of König's theorem. This was one of the results that motivated the initial definition of perfect graphs.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> Perfection of the complements of line graphs of perfect graphs is yet another restatement of König's theorem, and perfection of the line graphs themselves is a restatement of an earlier theorem of König, that every bipartite graph has an <a href="edge_coloring" title="wikilink">edge coloring</a> using a number of colors equal to its maximum degree.</p>

<p>According to the <a href="strong_perfect_graph_theorem" title="wikilink">strong perfect graph theorem</a>, the perfect graphs have a <a href="forbidden_graph_characterization" title="wikilink">forbidden graph characterization</a> resembling that of bipartite graphs: a graph is bipartite if and only if it has no odd cycle as a subgraph, and a graph is perfect if and only if it has no odd cycle or its <a href="complement_(graph_theory)" title="wikilink">complement</a> as an <a href="induced_subgraph" title="wikilink">induced subgraph</a>. The bipartite graphs, line graphs of bipartite graphs, and their complements form four out of the five basic classes of perfect graphs used in the proof of the strong perfect graph theorem.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<h3 id="degree">Degree</h3>

<p>For a vertex, the number of adjacent vertices is called the <a href="degree_(graph_theory)" title="wikilink">degree</a> of the vertex and is denoted 

<math display="inline" id="Bipartite_graph:20">
 <semantics>
  <mrow>
   <mi>deg</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">degree</csymbol>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \deg(v)
  </annotation>
 </semantics>
</math>

. The <em>degree sum formula</em> for a bipartite graph states that</p>

<p>

<math display="block" id="Bipartite_graph:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>v</mi>
       <mo>∈</mo>
       <mi>V</mi>
      </mrow>
     </munder>
     <mrow>
      <mi>deg</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>u</mi>
       <mo>∈</mo>
       <mi>U</mi>
      </mrow>
     </munder>
     <mrow>
      <mi>deg</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>E</mi>
     <mo rspace="4.2pt" stretchy="false">|</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>v</ci>
        <ci>V</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">degree</csymbol>
       <ci>v</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>u</ci>
        <ci>U</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">degree</csymbol>
       <ci>u</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <abs></abs>
      <ci>E</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{v\in V}\deg(v)=\sum_{u\in U}\deg(u)=|E|\,.
  </annotation>
 </semantics>
</math>

</p>

<p>The degree sequence of a bipartite graph is the pair of lists each containing the degrees of the two partite sets 

<math display="inline" id="Bipartite_graph:22">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bipartite_graph:23">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

. For example, the complete bipartite graph <em>K</em><sub>3,5</sub> has degree sequence 

<math display="inline" id="Bipartite_graph:24">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>5</mn>
    <mo>,</mo>
    <mn>5</mn>
    <mo>,</mo>
    <mn>5</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>3</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <vector>
     <cn type="integer">5</cn>
     <cn type="integer">5</cn>
     <cn type="integer">5</cn>
    </vector>
    <vector>
     <cn type="integer">3</cn>
     <cn type="integer">3</cn>
     <cn type="integer">3</cn>
     <cn type="integer">3</cn>
     <cn type="integer">3</cn>
    </vector>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (5,5,5),(3,3,3,3,3)
  </annotation>
 </semantics>
</math>

. Isomorphic bipartite graphs have the same degree sequence. However, the degree sequence does not, in general, uniquely identify a bipartite graph; in some cases, non-isomorphic bipartite graphs may have the same degree sequence.</p>

<p>The <a href="bipartite_realization_problem" title="wikilink">bipartite realization problem</a> is the problem of finding a simple bipartite graph with the degree sequence being two given lists of natural numbers. (Trailing zeros may be ignored since they are trivially realized by adding an appropriate number of isolated vertices to the digraph.)</p>
<h3 id="relation-to-hypergraphs-and-directed-graphs">Relation to hypergraphs and directed graphs</h3>

<p>The <a href="Adjacency_matrix_of_a_bipartite_graph" title="wikilink">biadjacency matrix</a> of a bipartite graph 

<math display="inline" id="Bipartite_graph:25">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>U</mi>
   <mo>,</mo>
   <mi>V</mi>
   <mo>,</mo>
   <mi>E</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>U</ci>
    <ci>V</ci>
    <ci>E</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (U,V,E)
  </annotation>
 </semantics>
</math>

 is a <a href="Logical_matrix" title="wikilink">

<math display="inline" id="Bipartite_graph:26">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0,1)
  </annotation>
 </semantics>
</math>

-matrix</a> of size 

<math display="inline" id="Bipartite_graph:27">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>U</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>×</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>V</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <abs></abs>
     <ci>U</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |U|\times|V|
  </annotation>
 </semantics>
</math>

 that has a one for each pair of adjacent vertices and a zero for nonadjacent vertices.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> Biadjacency matrices may be used to describe equivalences between bipartite graphs, hypergraphs, and directed graphs.</p>

<p>A <a class="uri" href="hypergraph" title="wikilink">hypergraph</a> is a combinatorial structure that, like an undirected graph, has vertices and edges, but in which the edges may be arbitrary sets of vertices rather than having to have exactly two endpoints. A bipartite graph 

<math display="inline" id="Bipartite_graph:28">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>U</mi>
   <mo>,</mo>
   <mi>V</mi>
   <mo>,</mo>
   <mi>E</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>U</ci>
    <ci>V</ci>
    <ci>E</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (U,V,E)
  </annotation>
 </semantics>
</math>

 may be used to model a hypergraph in which 

<math display="inline" id="Bipartite_graph:29">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 is the set of vertices of the hypergraph, 

<math display="inline" id="Bipartite_graph:30">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is the set of hyperedges, and 

<math display="inline" id="Bipartite_graph:31">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 contains an edge from a hypergraph vertex 

<math display="inline" id="Bipartite_graph:32">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 to a hypergraph edge 

<math display="inline" id="Bipartite_graph:33">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 exactly when 

<math display="inline" id="Bipartite_graph:34">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 is one of the endpoints of 

<math display="inline" id="Bipartite_graph:35">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

. Under this correspondence, the biadjacency matrices of bipartite graphs are exactly the <a href="incidence_matrix" title="wikilink">incidence matrices</a> of the corresponding hypergraphs. As a special case of this correspondence between bipartite graphs and hypergraphs, any <a class="uri" href="multigraph" title="wikilink">multigraph</a> (a graph in which there may be two or more edges between the same two vertices) may be interpreted as a hypergraph in which some hyperedges have equal sets of endpoints, and represented by a bipartite graph that does not have multiple adjacencies and in which the vertices on one side of the bipartition all have <a href="degree_(graph_theory)" title="wikilink">degree</a> two.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>

<p>A similar reinterpretation of adjacency matrices may be used to show a one-to-one correspondence between <a href="directed_graph" title="wikilink">directed graphs</a> (on a given number of labeled vertices, allowing self-loops) and balanced bipartite graphs, with the same number of vertices on both sides of the bipartition. For, the adjacency matrix of a directed graph with 

<math display="inline" id="Bipartite_graph:36">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 vertices can be any 

<math display="inline" id="Bipartite_graph:37">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0,1)
  </annotation>
 </semantics>
</math>

-matrix of size 

<math display="inline" id="Bipartite_graph:38">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times n
  </annotation>
 </semantics>
</math>

, which can then be reinterpreted as the adjacency matrix of a bipartite graph with 

<math display="inline" id="Bipartite_graph:39">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 vertices on each side of its bipartition.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> In this construction, the bipartite graph is the <a href="bipartite_double_cover" title="wikilink">bipartite double cover</a> of the directed graph.</p>
<h2 id="algorithms">Algorithms</h2>
<h3 id="testing-bipartiteness">Testing bipartiteness</h3>

<p>It is possible to test whether a graph is bipartite, and to return either a two-coloring (if it is bipartite) or an odd cycle (if it is not) in <a href="linear_time" title="wikilink">linear time</a>, using <a href="depth-first_search" title="wikilink">depth-first search</a>. The main idea is to assign to each vertex the color that differs from the color of its parent in the depth-first search tree, assigning colors in a <a href="preorder_traversal" title="wikilink">preorder traversal</a> of the depth-first-search tree. This will necessarily provide a two-coloring of the <a href="spanning_tree" title="wikilink">spanning tree</a> consisting of the edges connecting vertices to their parents, but it may not properly color some of the non-tree edges. In a depth-first search tree, one of the two endpoints of every non-tree edge is an ancestor of the other endpoint, and when the depth first search discovers an edge of this type it should check that these two vertices have different colors. If they do not, then the path in the tree from ancestor to descendant, together with the miscolored edge, form an odd cycle, which is returned from the algorithm together with the result that the graph is not bipartite. However, if the algorithm terminates without detecting an odd cycle of this type, then every edge must be properly colored, and the algorithm returns the coloring together with the result that the graph is bipartite.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>

<p>Alternatively, a similar procedure may be used with <a href="breadth-first_search" title="wikilink">breadth-first search</a> in place of depth-first search. Again, each node is given the opposite color to its parent in the search tree, in breadth-first order. If, when a vertex is colored, there exists an edge connecting it to a previously-colored vertex with the same color, then this edge together with the paths in the breadth-first search tree connecting its two endpoints to their <a href="lowest_common_ancestor" title="wikilink">lowest common ancestor</a> forms an odd cycle. If the algorithm terminates without finding an odd cycle in this way, then it must have found a proper coloring, and can safely conclude that the graph is bipartite.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>

<p>For the <a href="intersection_graph" title="wikilink">intersection graphs</a> of 

<math display="inline" id="Bipartite_graph:40">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 <a href="line_segment" title="wikilink">line segments</a> or other simple shapes in the <a href="Euclidean_plane" title="wikilink">Euclidean plane</a>, it is possible to test whether the graph is bipartite and return either a two-coloring or an odd cycle in time 

<math display="inline" id="Bipartite_graph:41">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n\log n)
  </annotation>
 </semantics>
</math>

, even though the graph itself may have as many as 

<math display="inline" id="Bipartite_graph:42">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(n^{2})
  </annotation>
 </semantics>
</math>

 edges.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></p>
<h3 id="odd-cycle-transversal">Odd cycle transversal</h3>

<p> <strong>Odd cycle transversal</strong> is an <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> <a href="algorithm" title="wikilink">algorithmic</a> problem that asks, given a graph <em>G</em> = (<em>V</em>,<em>E</em>) and a number <em>k</em>, whether there exists a set of <em>k</em> vertices whose removal from <em>G</em> would cause the resulting graph to be bipartite.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> The problem is <a href="Parameterized_complexity" title="wikilink">fixed-parameter tractable</a>, meaning that there is an algorithm whose running time can be bounded by a polynomial function of the size of the graph multiplied by a larger function of <em>k</em>.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> More specifically, the time for this algorithm is <em>O</em>(3<sup><em>k</em></sup> <em>mn</em>), although this was not stated in that paper.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> The result by Reed et al. was obtained using a completely new method, which later was called <a href="iterative_compression" title="wikilink">iterative compression</a> and turned out to be an extremely useful algorithmic tool, especially in the field of fixed-parameter tractability. This tool is now considered one of the fundamental tools for parameterized algorithmics.</p>

<p>The name <em>odd cycle transversal</em> comes from the fact that a graph is bipartite if and only if it has no odd <a href="Cycle_(graph_theory)" title="wikilink">cycles</a>. Hence, to delete vertices from a graph in order to obtain a bipartite graph, one needs to "hit all odd cycle", or find a so-called odd cycle <a href="Transversal_(combinatorics)" title="wikilink">transversal</a> set. In the illustration, one can observe that every odd cycle in the graph contains the blue (the bottommost) vertices, hence removing those vertices kills all odd cycles and leaves a bipartite graph.</p>

<p>The <em>edge bipartization</em> problem is the algorithmic problem of deleting as few edges as possible to make a graph bipartite and is also an important problem in graph modification algorithmics. This problem is also <a href="fixed-parameter_tractable" title="wikilink">fixed-parameter tractable</a>, and can be solved in time <em>O</em>(2<sup><em>k</em></sup> <em>m</em><sup>2</sup>),<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> where <em>k</em> is the number of edges to delete and <em>m</em> is the number of edges in the input graph.</p>
<h3 id="matching">Matching</h3>

<p>A <a href="Matching_(graph_theory)" title="wikilink">matching</a> in a graph is a subset of its edges, no two of which share an endpoint. <a href="Polynomial_time" title="wikilink">Polynomial time</a> algorithms are known for many algorithmic problems on matchings, including <a href="maximum_matching" title="wikilink">maximum matching</a> (finding a matching that uses as many edges as possible), <a href="maximum_weight_matching" title="wikilink">maximum weight matching</a>, and <a href="stable_marriage" title="wikilink">stable marriage</a>.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> In many cases, matching problems are simpler to solve on bipartite graphs than on non-bipartite graphs,<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> and many matching algorithms such as the <a href="Hopcroft–Karp_algorithm" title="wikilink">Hopcroft–Karp algorithm</a> for maximum cardinality matching<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> work correctly only on bipartite inputs.</p>

<p>As a simple example, suppose that a set 

<math display="inline" id="Bipartite_graph:43">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 of people are all seeking jobs from among a set of 

<math display="inline" id="Bipartite_graph:44">
 <semantics>
  <mi>J</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>J</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J
  </annotation>
 </semantics>
</math>

 jobs, with not all people suitable for all jobs. This situation can be modeled as a bipartite graph 

<math display="inline" id="Bipartite_graph:45">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>P</mi>
   <mo>,</mo>
   <mi>J</mi>
   <mo>,</mo>
   <mi>E</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>P</ci>
    <ci>J</ci>
    <ci>E</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P,J,E)
  </annotation>
 </semantics>
</math>

 where an edge connects each job-seeker with each suitable job.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> A <a href="perfect_matching" title="wikilink">perfect matching</a> describes a way of simultaneously satisfying all job-seekers and filling all jobs; <a href="Hall's_marriage_theorem" title="wikilink">Hall's marriage theorem</a> provides a characterization of the bipartite graphs which allow perfect matchings. The <a href="National_Resident_Matching_Program" title="wikilink">National Resident Matching Program</a> applies graph matching methods to solve this problem for <a href="Medical_education_in_the_United_States" title="wikilink">U.S. medical student</a> job-seekers and <a href="Residency_(medicine)" title="wikilink">hospital residency</a> jobs.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a></p>

<p>The <a href="Dulmage–Mendelsohn_decomposition" title="wikilink">Dulmage–Mendelsohn decomposition</a> is a structural decomposition of bipartite graphs that is useful in finding maximum matchings.<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a></p>
<h2 id="additional-applications">Additional applications</h2>

<p>Bipartite graphs are extensively used in modern <a href="coding_theory" title="wikilink">coding theory</a>, especially to decode <a href="codeword" title="wikilink">codewords</a> received from the channel. <a href="Factor_graph" title="wikilink">Factor graphs</a> and <a href="Tanner_graph" title="wikilink">Tanner graphs</a> are examples of this. A Tanner graph is a bipartite graph in which the vertices on one side of the bipartition represent digits of a codeword, and the vertices on the other side represent combinations of digits that are expected to sum to zero in a codeword without errors.<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> A factor graph is a closely related <a href="belief_network" title="wikilink">belief network</a> used for probabilistic decoding of <a class="uri" href="LDPC" title="wikilink">LDPC</a> and <a href="turbo_codes" title="wikilink">turbo codes</a>.<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a></p>

<p>In computer science, a <a href="Petri_net" title="wikilink">Petri net</a> is a mathematical modeling tool used in analysis and simulations of concurrent systems. A system is modeled as a bipartite directed graph with two sets of nodes: A set of "place" nodes that contain resources, and a set of "event" nodes which generate and/or consume resources. There are additional constraints on the nodes and edges that constrain the behavior of the system. Petri nets utilize the properties of bipartite directed graphs and other properties to allow mathematical proofs of the behavior of systems while also allowing easy implementation of simulations of the system.<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a></p>

<p>In <a href="projective_geometry" title="wikilink">projective geometry</a>, <a href="Levi_graph" title="wikilink">Levi graphs</a> are a form of bipartite graph used to model the incidences between points and lines in a <a href="configuration_(geometry)" title="wikilink">configuration</a>. Corresponding to the geometric property of points and lines that every two lines meet in at most one point and every two points be connected with a single line, Levi graphs necessarily do not contain any cycles of length four, so their <a href="girth_(graph_theory)" title="wikilink">girth</a> must be six or more.<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Bipartite_dimension" title="wikilink">Bipartite dimension</a>, the minimum number of complete bipartite graphs whose union is the given graph</li>
<li><a href="Bipartite_double_cover" title="wikilink">Bipartite double cover</a>, a way of transforming any graph into a bipartite graph by doubling its vertices</li>
<li><a href="Bipartite_matroid" title="wikilink">Bipartite matroid</a>, a class of matroids that includes the <a href="graphic_matroid" title="wikilink">graphic matroids</a> of bipartite graphs</li>
<li><a href="Bipartite_network_projection" title="wikilink">Bipartite network projection</a>, a weighting technique for compressing information about bipartite networks</li>
<li><a href="Convex_bipartite_graph" title="wikilink">Convex bipartite graph</a>, a bipartite graph whose vertices can be ordered so that the vertex neighborhoods are contiguous</li>
<li><a href="Multipartite_graph" title="wikilink">Multipartite graph</a>, a generalization of bipartite graphs to more than two subsets of vertices</li>
<li><a href="Quasi-bipartite_graph" title="wikilink">Quasi-bipartite graph</a>, a type of Steiner tree problem instance in which the terminals form an independent set, allowing approximation algorithms that generalize those for bipartite graphs</li>
<li><a href="Split_graph" title="wikilink">Split graph</a>, a graph in which the vertices can be partitioned into two subsets, one of which is independent and the other of which is a clique</li>
<li><a href="Zarankiewicz_problem" title="wikilink">Zarankiewicz problem</a> on the maximum number of edges in a bipartite graph with forbidden subgraphs</li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://www.graphclasses.org/">Information System on Graph Classes and their Inclusions</a>: <a href="http://www.graphclasses.org/classes/gc_69.html">bipartite graph</a></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Graph_families" title="wikilink">Category:Graph families</a> <a href="Category:Perfect_graphs" title="wikilink">Category:Perfect graphs</a> <a href="Category:Parity_(mathematics)" title="wikilink">Category:Parity (mathematics)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4">.<a href="#fnref4">↩</a></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6">, p. 7.<a href="#fnref6">↩</a></li>
<li id="fn7">.<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12">. This result has sometimes been called the "two color theorem"; Soifer credits it to a famous 1879 paper of <a href="Alfred_Kempe" title="wikilink">Alfred Kempe</a> containing a false proof of the <a href="four_color_theorem" title="wikilink">four color theorem</a>.<a href="#fnref12">↩</a></li>
<li id="fn13">.<a href="#fnref13">↩</a></li>
<li id="fn14">, p. 11.<a href="#fnref14">↩</a></li>
<li id="fn15">.<a href="#fnref15">↩</a></li>
<li id="fn16">. See especially Chapter 5, "Partial Cubes", pp. 127–181.<a href="#fnref16">↩</a></li>
<li id="fn17">, Theorem 2.1.3, p. 8. Asratian et al. attribute this characterization to a 1916 paper by <a href="Dénes_Kőnig" title="wikilink">Dénes Kőnig</a>. For infinite graphs, this result requires the <a href="axiom_of_choice" title="wikilink">axiom of choice</a>.<a href="#fnref17">↩</a></li>
<li id="fn18"></li>
<li id="fn19">.<a href="#fnref19">↩</a></li>
<li id="fn20">.<a href="#fnref20">↩</a></li>
<li id="fn21">.<a href="#fnref21">↩</a></li>
<li id="fn22">.<a href="#fnref22">↩</a></li>
<li id="fn23">.<a href="#fnref23">↩</a></li>
<li id="fn24">.<a href="#fnref24">↩</a></li>
<li id="fn25">, p. 17.<a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27">. Brualdi et al. credit the idea for this equivalence to .<a href="#fnref27">↩</a></li>
<li id="fn28">.<a href="#fnref28">↩</a></li>
<li id="fn29">.<a href="#fnref29">↩</a></li>
<li id="fn30">.<a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32">.<a href="#fnref32">↩</a></li>
<li id="fn33">.<a href="#fnref33">↩</a></li>
<li id="fn34"><a href="#fnref34">↩</a></li>
<li id="fn35">.<a href="#fnref35">↩</a></li>
<li id="fn36">, p. 463: "Nonbipartite matching problems are more difficult to solve because they do not reduce to standard network flow problems."<a href="#fnref36">↩</a></li>
<li id="fn37"><mtpl></mtpl>.<a href="#fnref37">↩</a></li>
<li id="fn38">, Application 12.1 Bipartite Personnel Assignment, pp. 463–464.<a href="#fnref38">↩</a></li>
<li id="fn39">.<a href="#fnref39">↩</a></li>
<li id="fn40">.<a href="#fnref40">↩</a></li>
<li id="fn41">.<a href="#fnref41">↩</a></li>
<li id="fn42">, p. 686.<a href="#fnref42">↩</a></li>
<li id="fn43">.<a href="#fnref43">↩</a></li>
<li id="fn44">.<a href="#fnref44">↩</a></li>
</ol>
</section>
</body>
</html>
