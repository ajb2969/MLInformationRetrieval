<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1011">Chirp spectrum</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Chirp spectrum</h1>
<hr/>

<p>The spectrum of a <a class="uri" href="chirp" title="wikilink">chirp</a> pulse describes its characteristics in terms of its frequency components. This frequency-domain representation is an alternative to the more familiar time-domain waveform, and the two versions are mathematically related by the <a href="Fourier_transform" title="wikilink">Fourier transform</a>.<br/>
The spectrum is of particular interest when pulses are subject to <a href="signal_processing" title="wikilink">signal processing</a>. For example, when a chirp pulse is compressed by its <a href="matched_filter" title="wikilink">matched filter</a>, the resulting waveform contains not only a main narrow pulse but, also, a variety of unwanted artifacts many of which are directly attributable to features in the chirp's spectral characteristics.<br/>
The simplest way to derive the spectrum of a chirp, now computers are widely available, is to sample the time-domain waveform at a frequency well above the <a href="Nyquist_limit" title="wikilink">Nyquist limit</a> and call up an <a class="uri" href="FFT" title="wikilink">FFT</a> algorithm to obtain the desired result. As this approach was not an option for the early designers, they resorted to analytic analysis, where possible, or to graphical or approximation methods, otherwise. These early methods still remain helpful, however, as they give additional insight into the behavior and properties of chirps.</p>
<h2 id="the-fourier-transform-of-a-chirp-pulse">The Fourier transform of a chirp pulse</h2>

<p>A general expression for an oscillatory waveform, centered on frequency <mtpl></mtpl> is</p>

<p>

<math display="inline" id="Chirp_spectrum:0">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>j</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ω</mi>
      <mn>0</mn>
     </msub>
     <mo>.</mo>
     <mi>t</mi>
     <mo>+</mo>
     <mi>θ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">a</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">j</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-.</ci>
      <csymbol cd="unknown">t</csymbol>
      <plus></plus>
      <csymbol cd="unknown">θ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">t</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(t)=a(t).exp[j(\omega_{0}.t+\theta(t))]
  </annotation>
 </semantics>
</math>

</p>

<p>where a(t) and <mtpl></mtpl>(t) give the amplitude and phase variations of the waveform s, with time.<br/>
The frequency spectrum of this waveform is obtained by calculating the <a href="Fourier_Transform" title="wikilink">Fourier Transform</a> of s(t), i.e.</p>

<p>

<math display="inline" id="Chirp_spectrum:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mi>s</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>e</mi>
    <mi>x</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>j</mi>
       <mi>ω</mi>
       <mi>t</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mi>t</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>e</mi>
    <mi>x</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>j</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>ω</mi>
          <mn>0</mn>
         </msub>
         <mi>t</mi>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>θ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>e</mi>
    <mi>x</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>j</mi>
       <mi>ω</mi>
       <mi>t</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>d</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>ω</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
     <ci>p</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>ω</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
     <ci>p</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>j</ci>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <cn type="integer">0</cn>
         </apply>
         <ci>t</ci>
        </apply>
        <apply>
         <times></times>
         <ci>θ</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
     <ci>p</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>ω</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\omega)=\int_{-\infty}^{\infty}s(t).exp(-j\omega t).dt=\int_{-\infty}^{%
\infty}a(t).exp[j(\omega_{0}t+\theta(t))].exp(-j\omega t).dt
  </annotation>
 </semantics>
</math>

<br/>
 so<br/>


<math display="inline" id="Chirp_spectrum:2">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ω</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mo>-</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>j</mi>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>ω</mi>
       <mn>0</mn>
      </msub>
      <mo>-</mo>
      <mi>ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>.</mo>
     <mi>t</mi>
     <mo>+</mo>
     <mi>θ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>}</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>.</mo>
   <mi>d</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ω</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <minus></minus>
       <infinity></infinity>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <csymbol cd="unknown">a</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">j</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <cn type="integer">0</cn>
       </apply>
       <minus></minus>
       <csymbol cd="unknown">ω</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-.</ci>
      <csymbol cd="unknown">t</csymbol>
      <plus></plus>
      <csymbol cd="unknown">θ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">t</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">t</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\omega)=\int_{-\infty}^{\infty}a(t).exp[j\left\{(\omega_{0}-\omega).t+\theta%
(t)\right\}].dt
  </annotation>
 </semantics>
</math>

</p>

<p>In a few special cases, the integral can be solved to give an <a href="analytical_expression" title="wikilink">analytical expression</a>, but often the characteristics of a(t) and <mtpl></mtpl>(t) are such that the integral can only be evaluated by an <a href="approximation_algorithm" title="wikilink">approximation algorithm</a> or by <a href="numerical_integration" title="wikilink">numerical integration</a>.</p>
<h3 id="the-linear-chirp">The linear chirp</h3>

<p>In the special case where a(t) is constrained to be a flat topped pulse with its instantaneous frequency varying as a linear function of time, then an analytical solution is possible.<br/>
For convenience, the pulse is considered to have unit amplitude and be of duration T, with the amplitude and phase defined over the time interval -T/2 to +T/2. The total frequency sweep is <mtpl></mtpl>F, varying in a linear manner from -<mtpl></mtpl>F/2 to +<mtpl></mtpl>F/2 in the defined time interval.<br/>
When the frequency is a linear function of time, the phase is a <a href="quadratic_function" title="wikilink">quadratic function</a>, and s(t) can be written</p>

<p>

<math display="inline" id="Chirp_spectrum:3">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1.</mn>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>j</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ω</mi>
      <mn>0</mn>
     </msub>
     <mo>.</mo>
     <mi>t</mi>
     <mo>+</mo>
     <mfrac>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi mathvariant="normal">Ω</mi>
      </mrow>
      <mrow>
       <mn>2.</mn>
       <mi>T</mi>
      </mrow>
     </mfrac>
     <mo>.</mo>
     <msup>
      <mi>t</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>w</mi>
   <mi>h</mi>
   <mi>e</mi>
   <mi>r</mi>
   <mi>e</mi>
   <mi mathvariant="normal">Δ</mi>
   <mi mathvariant="normal">Ω</mi>
   <mo>=</mo>
   <mn>2</mn>
   <mi>π</mi>
   <mo>.</mo>
   <mi mathvariant="normal">Δ</mi>
   <mi>F</mi>
   <mi>a</mi>
   <mi>n</mi>
   <mi>d</mi>
   <mfrac>
    <mrow>
     <mo>-</mo>
     <mi>T</mi>
    </mrow>
    <mn>2</mn>
   </mfrac>
   <mo><</mo>
   <mi>t</mi>
   <mo><</mo>
   <mfrac>
    <mi>T</mi>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="float">1.</cn>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">j</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-.</ci>
      <csymbol cd="unknown">t</csymbol>
      <plus></plus>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>normal-Ω</ci>
       </apply>
       <apply>
        <times></times>
        <cn type="float">2.</cn>
        <ci>T</ci>
       </apply>
      </apply>
      <ci>normal-.</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <ci>italic-</ci>
    <csymbol cd="unknown">w</csymbol>
    <csymbol cd="unknown">h</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <ci></ci>
    <csymbol cd="unknown">Δ</csymbol>
    <csymbol cd="unknown">Ω</csymbol>
    <eq></eq>
    <cn type="integer">2</cn>
    <csymbol cd="unknown">π</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">Δ</csymbol>
    <csymbol cd="unknown">F</csymbol>
    <ci>italic-</ci>
    <csymbol cd="unknown">a</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <ci></ci>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <ci>T</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <lt></lt>
    <csymbol cd="unknown">t</csymbol>
    <lt></lt>
    <apply>
     <divide></divide>
     <ci>T</ci>
     <cn type="integer">2</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(t)=1.exp[j(\omega_{0}.t+\frac{\Delta\Omega}{2.T}.t^{2})]\qquad where\quad%
\Delta\Omega=2\pi.\Delta F\qquad and\quad\frac{-T}{2}<t<\frac{T}{2}
  </annotation>
 </semantics>
</math>

</p>

<p>The spectrum of this linear FM signal is<br/>


<math display="inline" id="Chirp_spectrum:4">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ω</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>T</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </mrow>
    <mrow>
     <mi>T</mi>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </msubsup>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mrow>
    <mo>[</mo>
    <mi>j</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ω</mi>
      <mn>0</mn>
     </msub>
     <mo>.</mo>
     <mi>t</mi>
     <mo>+</mo>
     <mfrac>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi mathvariant="normal">Ω</mi>
      </mrow>
      <mrow>
       <mn>2.</mn>
       <mi>T</mi>
      </mrow>
     </mfrac>
     <mo>.</mo>
     <msup>
      <mi>t</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>]</mo>
   </mrow>
   <mo>.</mo>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>-</mo>
    <mi>j</mi>
    <mi>ω</mi>
    <mo>.</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mi>d</mi>
   <mi>t</mi>
   <mo>=</mo>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>T</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </mrow>
    <mrow>
     <mi>T</mi>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </msubsup>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mrow>
    <mo>[</mo>
    <mi>j</mi>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>ω</mi>
       <mn>0</mn>
      </msub>
      <mo>-</mo>
      <mi>ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>.</mo>
     <mi>t</mi>
     <mo>+</mo>
     <mfrac>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi mathvariant="normal">Ω</mi>
      </mrow>
      <mrow>
       <mn>2.</mn>
       <mi>T</mi>
      </mrow>
     </mfrac>
     <mo>.</mo>
     <msup>
      <mi>t</mi>
      <mn>2</mn>
     </msup>
     <mo>}</mo>
    </mrow>
    <mo>]</mo>
   </mrow>
   <mo>.</mo>
   <mi>d</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ω</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <ci>T</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <ci>T</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">j</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-.</ci>
      <csymbol cd="unknown">t</csymbol>
      <plus></plus>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>normal-Ω</ci>
       </apply>
       <apply>
        <times></times>
        <cn type="float">2.</cn>
        <ci>T</ci>
       </apply>
      </apply>
      <ci>normal-.</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <minus></minus>
     <csymbol cd="unknown">j</csymbol>
     <csymbol cd="unknown">ω</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <ci>T</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <ci>T</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">j</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <cn type="integer">0</cn>
       </apply>
       <minus></minus>
       <csymbol cd="unknown">ω</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-.</ci>
      <csymbol cd="unknown">t</csymbol>
      <plus></plus>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>normal-Ω</ci>
       </apply>
       <apply>
        <times></times>
        <cn type="float">2.</cn>
        <ci>T</ci>
       </apply>
      </apply>
      <ci>normal-.</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">t</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\omega)=\int_{-T/2}^{T/2}exp\left[j(\omega_{0}.t+\frac{\Delta\Omega}{2.T}.t^%
{2})\right].exp(-j\omega.t).dt=\int_{-T/2}^{T/2}exp\left[j\left\{(\omega_{0}-%
\omega).t+\frac{\Delta\Omega}{2.T}.t^{2}\right\}\right].dt
  </annotation>
 </semantics>
</math>

</p>

<p>By <a href="Completing_the_square" title="wikilink">Completing the square</a> and recourse to the <a href="Fresnel_integrals" title="wikilink">Fresnel integrals</a> C(X) and S(X),<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> defined by<br/>


<math display="inline" id="Chirp_spectrum:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mn>0</mn>
      <mi>X</mi>
     </msubsup>
     <mrow>
      <mi>c</mi>
      <mi>o</mi>
      <mi>s</mi>
      <mfrac>
       <mrow>
        <mi>π</mi>
        <mo>.</mo>
        <msup>
         <mi>y</mi>
         <mn>2</mn>
        </msup>
       </mrow>
       <mn>2</mn>
      </mfrac>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>d</mi>
      <mi>y</mi>
     </mrow>
     <mrow>
      <mi>a</mi>
      <mi>n</mi>
      <mi>d</mi>
     </mrow>
     <mrow>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mn>0</mn>
      <mi>X</mi>
     </msubsup>
     <mrow>
      <mi>s</mi>
      <mi>i</mi>
      <mi>n</mi>
      <mfrac>
       <mrow>
        <mi>π</mi>
        <mo>.</mo>
        <msup>
         <mi>y</mi>
         <mn>2</mn>
        </msup>
       </mrow>
       <mn>2</mn>
      </mfrac>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>d</mi>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <cn type="integer">0</cn>
       </apply>
       <ci>X</ci>
      </apply>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>o</ci>
       <ci>s</ci>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">formulae-sequence</csymbol>
         <ci>π</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>y</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>n</ci>
       <ci>d</ci>
      </apply>
      <apply>
       <times></times>
       <ci>S</ci>
       <ci>X</ci>
      </apply>
     </list>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <cn type="integer">0</cn>
       </apply>
       <ci>X</ci>
      </apply>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>i</ci>
       <ci>n</ci>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">formulae-sequence</csymbol>
         <ci>π</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>y</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(X)=\int_{0}^{X}cos\frac{\pi.y^{2}}{2}.dy\qquad and\qquad S(X)=\int_{0}^{X}%
sin\frac{\pi.y^{2}}{2}.dy
  </annotation>
 </semantics>
</math>

</p>

<p>the expression can be evaluated<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> to give<br/>


<math display="inline" id="Chirp_spectrum:6">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ω</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mrow>
       <mi>π</mi>
       <mo>.</mo>
       <mi>T</mi>
      </mrow>
      <mrow>
       <mn>2.</mn>
       <mi mathvariant="normal">Δ</mi>
       <mi mathvariant="normal">Ω</mi>
      </mrow>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </msqrt>
   <mo>.</mo>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mrow>
    <mo>[</mo>
    <mo>-</mo>
    <mi>j</mi>
    <mrow>
     <mo>(</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ω</mi>
       <mo>-</mo>
       <msub>
        <mi>ω</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>.</mo>
     <mfrac>
      <mi>T</mi>
      <mrow>
       <mn>2.</mn>
       <mi mathvariant="normal">Δ</mi>
       <mi mathvariant="normal">Ω</mi>
      </mrow>
     </mfrac>
     <mo>)</mo>
    </mrow>
    <mo>]</mo>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>X</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mi>j</mi>
    <mo>.</mo>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>X</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>X</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mi>j</mi>
    <mo>.</mo>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>X</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ω</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <root></root>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <ci>π</ci>
       <ci>T</ci>
      </apply>
      <apply>
       <times></times>
       <cn type="float">2.</cn>
       <ci>normal-Δ</ci>
       <ci>normal-Ω</ci>
      </apply>
     </apply>
    </apply>
    <ci>normal-.</ci>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <minus></minus>
     <csymbol cd="unknown">j</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">ω</csymbol>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-.</ci>
      <apply>
       <divide></divide>
       <ci>T</ci>
       <apply>
        <times></times>
        <cn type="float">2.</cn>
        <ci>normal-Δ</ci>
        <ci>normal-Ω</ci>
       </apply>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">C</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <plus></plus>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">S</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <plus></plus>
     <csymbol cd="unknown">C</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <plus></plus>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">S</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\omega)=\sqrt{\left(\frac{\pi.T}{2.\Delta\Omega}\right)}.exp\left[-j\left((%
\omega-\omega_{0})^{2}.\frac{T}{2.\Delta\Omega}\right)\right].[C(X_{1})+j.S(X_%
{1})+C(X_{2})+j.S(X_{2})]
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Chirp_spectrum:7">
 <semantics>
  <msub>
   <mi>X</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Chirp_spectrum:8">
 <semantics>
  <msub>
   <mi>X</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{2}
  </annotation>
 </semantics>
</math>

 are given by 

<math display="inline" id="Chirp_spectrum:9">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mpadded lspace="10pt" width="+10pt">
      <mi>X</mi>
     </mpadded>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mfrac>
        <mrow>
         <mi mathvariant="normal">Δ</mi>
         <mi mathvariant="normal">Ω</mi>
        </mrow>
        <mn>2</mn>
       </mfrac>
       <mo>+</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>ω</mi>
         <mo>-</mo>
         <msub>
          <mi>ω</mi>
          <mn>0</mn>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <msqrt>
       <mfrac>
        <mrow>
         <mi>π</mi>
         <mo>.</mo>
         <mi mathvariant="normal">Ω</mi>
        </mrow>
        <mi>T</mi>
       </mfrac>
      </msqrt>
     </mfrac>
     <mrow>
      <mi>a</mi>
      <mi>n</mi>
      <mi>d</mi>
     </mrow>
    </mrow>
   </mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mfrac>
       <mrow>
        <mi mathvariant="normal">Δ</mi>
        <mi mathvariant="normal">Ω</mi>
       </mrow>
       <mn>2</mn>
      </mfrac>
      <mo>+</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>ω</mi>
        <mo>+</mo>
        <msub>
         <mi>ω</mi>
         <mn>0</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <msqrt>
      <mfrac>
       <mrow>
        <mi>π</mi>
        <mo>.</mo>
        <mi mathvariant="normal">Ω</mi>
       </mrow>
       <mi>T</mi>
      </mfrac>
     </msqrt>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <list>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>normal-Δ</ci>
          <ci>normal-Ω</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>ω</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <root></root>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">formulae-sequence</csymbol>
          <ci>π</ci>
          <ci>normal-Ω</ci>
         </apply>
         <ci>T</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>n</ci>
       <ci>d</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>normal-Δ</ci>
         <ci>normal-Ω</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <plus></plus>
        <ci>ω</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <root></root>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">formulae-sequence</csymbol>
         <ci>π</ci>
         <ci>normal-Ω</ci>
        </apply>
        <ci>T</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \quad X_{1}=\frac{\frac{\Delta\Omega}{2}+(\omega-\omega_{0})}{\sqrt{\frac{\pi.%
\Omega}{T}}}\quad and\quad X_{2}=\frac{\frac{\Delta\Omega}{2}+(\omega+\omega_{%
0})}{\sqrt{\frac{\pi.\Omega}{T}}}
  </annotation>
 </semantics>
</math>

</p>

<p>The linear FM spectrum can be considered to have three major components, namely<br/>
an Amplitude Term, 

<math display="inline" id="Chirp_spectrum:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ω</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>=</mo>
    <msqrt>
     <mfrac>
      <mrow>
       <mi>π</mi>
       <mo>.</mo>
       <mi>T</mi>
      </mrow>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi mathvariant="normal">Ω</mi>
      </mrow>
     </mfrac>
    </msqrt>
   </mrow>
   <mo>.</mo>
   <msup>
    <mrow>
     <mo>[</mo>
     <mrow>
      <msup>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mrow>
          <mi>C</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>X</mi>
            <mn>1</mn>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>+</mo>
         <mrow>
          <mi>C</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>X</mi>
            <mn>2</mn>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mo>+</mo>
      <msup>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mrow>
          <mi>S</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>X</mi>
            <mn>1</mn>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>+</mo>
         <mrow>
          <mi>S</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>X</mi>
            <mn>2</mn>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>]</mo>
    </mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>S</ci>
       <ci>ω</ci>
      </apply>
     </apply>
     <apply>
      <root></root>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <ci>π</ci>
        <ci>T</ci>
       </apply>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>normal-Ω</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <ci>C</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>X</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>C</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>X</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <ci>S</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>X</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>S</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>X</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |S(\omega)|=\sqrt{\frac{\pi.T}{\Delta\Omega}}.\left[\left(C(X_{1})+C(X_{2})%
\right)^{2}+\left(S(X_{1})+S(X_{2})\right)^{2}\right]^{\frac{1}{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>a Square Law Phase term, 

<math display="inline" id="Chirp_spectrum:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo lspace="12.5pt">-</mo>
     <mrow>
      <msub>
       <mi mathvariant="normal">Φ</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ω</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>ω</mi>
       <mo>-</mo>
       <msub>
        <mi>ω</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>.</mo>
   <mfrac>
    <mi>T</mi>
    <mrow>
     <mn>2.</mn>
     <mi mathvariant="normal">Δ</mi>
     <mi mathvariant="normal">Ω</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Φ</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>ω</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <ci>T</ci>
     <apply>
      <times></times>
      <cn type="float">2.</cn>
      <ci>normal-Δ</ci>
      <ci>normal-Ω</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \quad-\Phi_{1}(\omega)=(\omega-\omega_{0})^{2}.\frac{T}{2.\Delta\Omega}
  </annotation>
 </semantics>
</math>

</p>

<p>and a Residual Phase Term 

<math display="inline" id="Chirp_spectrum:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mpadded lspace="10pt" width="+10pt">
      <mi mathvariant="normal">Φ</mi>
     </mpadded>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <mi>r</mi>
    <mi>c</mi>
    <mi>t</mi>
    <mi>a</mi>
    <mi>n</mi>
    <mrow>
     <mo>[</mo>
     <mfrac>
      <mrow>
       <mrow>
        <mi>S</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>X</mi>
          <mn>1</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>S</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>X</mi>
          <mn>2</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mrow>
       <mrow>
        <mi>C</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>X</mi>
          <mn>1</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>C</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>X</mi>
          <mn>2</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mfrac>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Φ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>ω</ci>
    </apply>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>r</ci>
     <ci>c</ci>
     <ci>t</ci>
     <ci>a</ci>
     <ci>n</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>S</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>S</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>C</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>C</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \quad\Phi_{2}(\omega)=arctan\left[\frac{S(X_{1})+S(X_{2})}{C(X_{1})+C(X_{2})}\right]
  </annotation>
 </semantics>
</math>

<br/>
The ratio 

<math display="inline" id="Chirp_spectrum:13">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>X</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>X</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>C</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>X</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>C</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>X</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>S</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>S</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>C</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>C</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left[\frac{S(X_{1})+S(X_{2})}{C(X_{1})+C(X_{2})}\right]
  </annotation>
 </semantics>
</math>


 is approximately unity over a large part of frequency range of interest so <mtpl></mtpl> approximates to a constant phase angle <mtpl></mtpl>/4 there.<br/>
If a frequency scaling term n is introduced, where 

<math display="inline" id="Chirp_spectrum:14">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mn>2.</mn>
    <mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>ω</mi>
       <mo>-</mo>
       <msub>
        <mi>ω</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mi mathvariant="normal">Ω</mi>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <times></times>
     <cn type="float">2.</cn>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>normal-Ω</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=2.\frac{(\omega-\omega_{0})}{\Delta\Omega}
  </annotation>
 </semantics>
</math>

, then the expressions for the Fresnel arguments become 

<math display="inline" id="Chirp_spectrum:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mfrac>
     <msqrt>
      <mrow>
       <mi>T</mi>
       <mo>.</mo>
       <mrow>
        <mi mathvariant="normal">Δ</mi>
        <mi>F</mi>
       </mrow>
      </mrow>
     </msqrt>
     <msqrt>
      <mn>2</mn>
     </msqrt>
    </mfrac>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <root></root>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <ci>T</ci>
        <apply>
         <times></times>
         <ci>normal-Δ</ci>
         <ci>F</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1}=\frac{\sqrt{T.\Delta F}}{\sqrt{2}}.(1+n)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Chirp_spectrum:16">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo>=</mo>
    <mfrac>
     <msqrt>
      <mrow>
       <mi>T</mi>
       <mo>.</mo>
       <mrow>
        <mi mathvariant="normal">Δ</mi>
        <mi>F</mi>
       </mrow>
      </mrow>
     </msqrt>
     <msqrt>
      <mn>2</mn>
     </msqrt>
    </mfrac>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <root></root>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <ci>T</ci>
        <apply>
         <times></times>
         <ci>normal-Δ</ci>
         <ci>F</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{2}=\frac{\sqrt{T.\Delta F}}{\sqrt{2}}.(1-n)
  </annotation>
 </semantics>
</math>

 The spectra are now functions of the product T.<mtpl></mtpl>F, independent of any particular values of center frequency and bandwidth. This product, T.<mtpl></mtpl>F, is often referred to as the time-bandwidth product of the chirp.</p>

<p>Tables of the Fresnel integrals have been published,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> together with mathematical routines with which to compute the integrals manually or by means of a computer program. In addition, a number of mathematical software programs, such as <a class="uri" href="Mathcad" title="wikilink">Mathcad</a>, <a class="uri" href="MATLAB" title="wikilink">MATLAB</a> and <a class="uri" href="Mathematica" title="wikilink">Mathematica</a> have built-in routines to evaluate the integrals, either as standard functions or in extension packages.</p>

<p>Some plots of the power spectrum |S(<mtpl></mtpl>)|<sup>2</sup> as a function of frequency are shown, for time-bandwidth products of 25, 100, 250 and 1000. When the product is small, the Fresnel ripples are very much in evidence, but the spectrum does tend to a more rectangular profile for larger values.<br/>
<br/>
<br/>
In the case of the plots of residual phase, <mtpl></mtpl>2(<mtpl></mtpl>), the profiles tend to be very similar over a wide range of time-bandwidth products. Two examples, for TxB = 100 and 250 are shown below. They have a phase angle close to a value of <mtpl></mtpl>/4 within the chirp range 

<math display="inline" id="Chirp_spectrum:17">
 <semantics>
  <mrow>
   <msub>
    <mi>ω</mi>
    <mn>0</mn>
   </msub>
   <mo>±</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi mathvariant="normal">Ω</mi>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">plus-or-minus</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>normal-Ω</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{0}\pm\Delta\Omega/2
  </annotation>
 </semantics>
</math>

 and they only start to change significantly for frequencies beyond this range.<br/>
<br/>
Consequently, for frequencies within the sweep range of the chirp, it is the square-law phase term <mtpl></mtpl>1(<mtpl></mtpl>) and its group delay function ( = -d<mtpl></mtpl>1/d(<mtpl></mtpl>) ) that are of most interest. There is a plot of the group delay shown below. Both this function and the phase <mtpl></mtpl>1(<mtpl></mtpl>) are independent of the value of the time-bandwidth product. As expected, the group delay is a linear function with a duration T secs, over a frequency sweep of <mtpl></mtpl><mtpl></mtpl> rads.</p>
<figure><b>(Figure)</b>
<figcaption>Group Delay of Linear Chirp.png</figcaption>
</figure>

<p>The residual phase term adds only minor perturbations to this characteristic within the frequency range 

<math display="inline" id="Chirp_spectrum:18">
 <semantics>
  <mrow>
   <msub>
    <mi>ω</mi>
    <mn>0</mn>
   </msub>
   <mo>±</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi mathvariant="normal">Ω</mi>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">plus-or-minus</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>normal-Ω</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{0}\pm\Delta\Omega/2
  </annotation>
 </semantics>
</math>


. At frequencies outside this range, <mtpl></mtpl>2(<mtpl></mtpl>) deviates rapidly from <mtpl></mtpl>/4, and so the total phase will deviate seriously from a square law there. Fortunately, the energy content of the chirp spectrum is very small at these frequencies (as is demonstrated in a later section).</p>
<h3 id="non-linear-chirps">Non-linear chirps</h3>

<p>When the Frequency-Time characteristic is non-linear, the Fourier integral is difficult to evaluate. In such cases, it is possible to resort to an approximation method such as the <a href="stationary_phase_approximation" title="wikilink">stationary phase approximation</a>, or to use numerical methods.</p>
<h4 id="the-stationary-phase-method">The stationary phase method</h4>

<p>Often (as in radar applications) a(t) is a slowly varying function of time and the phase <mtpl></mtpl>(t) is oscillatory and varies rapidly, over the range of integration. With such waveforms, the stationary phase approximation can be used to investigate the spectrum.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> The method relies on the fact that the major contributions to the Fourier integral come from the region where the rate of change of phase is minimal, i.e. when</p>

<p>

<math display="inline" id="Chirp_spectrum:19">
 <semantics>
  <mrow>
   <mfrac>
    <mi>d</mi>
    <mrow>
     <mi>d</mi>
     <mi>t</mi>
    </mrow>
   </mfrac>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ω</mi>
      <mn>0</mn>
     </msub>
     <mo>-</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>t</mi>
    <mo>+</mo>
    <mi>θ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
   <mo stretchy="false">]</mo>
   <mi>o</mi>
   <mi>r</mi>
   <mo stretchy="false">(</mo>
   <mi>ω</mi>
   <mo>-</mo>
   <msub>
    <mi>ω</mi>
    <mn>0</mn>
   </msub>
   <mo stretchy="false">)</mo>
   <mo>-</mo>
   <mi>θ</mi>
   <msup>
    <mi></mi>
    <mo>′</mo>
   </msup>
   <mo stretchy="false">(</mo>
   <mi>t</mi>
   <mo stretchy="false">)</mo>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <divide></divide>
     <ci>d</ci>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <cn type="integer">0</cn>
      </apply>
      <minus></minus>
      <csymbol cd="unknown">ω</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">t</csymbol>
     <plus></plus>
     <csymbol cd="unknown">θ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">0</cn>
    <ci>normal-]</ci>
    <ci>italic-</ci>
    <csymbol cd="unknown">o</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <ci>italic-</ci>
    <ci>normal-(</ci>
    <csymbol cd="unknown">ω</csymbol>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-)</ci>
    <minus></minus>
    <csymbol cd="unknown">θ</csymbol>
    <apply>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-(</ci>
    <csymbol cd="unknown">t</csymbol>
    <ci>normal-)</ci>
    <eq></eq>
    <cn type="integer">0</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{d}{dt}[(\omega_{0}-\omega)t+\theta(t)]=0]\qquad or\qquad(\omega-\omega_{%
0})-\theta^{\prime}(t)=0
  </annotation>
 </semantics>
</math>

</p>

<p>Unless <mtpl></mtpl>(t) is a constant, the point in time t<sub>s</sub> at which the phase is stationary will vary according to the instantaneous frequency <mtpl></mtpl>.<br/>
Expressing the difference between (<mtpl></mtpl>-<mtpl></mtpl>).t and <mtpl></mtpl>(t) as a <a href="Taylor_series" title="wikilink">Taylor series</a> about the time t<sub>s</sub>, but discarding all but the first three terms (of which the second term is zero, here), the Fourier integral can be written, approximately, as</p>

<p>

<math display="inline" id="Chirp_spectrum:20">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ω</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≊</mo>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mi>s</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <msub>
      <mi>t</mi>
      <mi>s</mi>
     </msub>
     <mo>-</mo>
     <mi>δ</mi>
    </mrow>
    <mrow>
     <msub>
      <mi>t</mi>
      <mi>s</mi>
     </msub>
     <mo>+</mo>
     <mi>δ</mi>
    </mrow>
   </msubsup>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mrow>
    <mo>[</mo>
    <mo>-</mo>
    <mi>j</mi>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>ω</mi>
       <mi>s</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>ω</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>.</mo>
     <mi>t</mi>
     <mo>-</mo>
     <mi>θ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>t</mi>
       <mi>s</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <msup>
        <mi>θ</mi>
        <mi>′′</mi>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>t</mi>
         <mi>s</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mn>2</mn>
     </mfrac>
     <mo>.</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>-</mo>
       <msub>
        <mi>t</mi>
        <mi>s</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>}</mo>
    </mrow>
    <mo>]</mo>
   </mrow>
   <mo>.</mo>
   <mi>d</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ω</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">approximately-equals-or-equals</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>s</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>s</ci>
       </apply>
       <ci>δ</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>s</ci>
      </apply>
      <ci>δ</ci>
     </apply>
    </apply>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <minus></minus>
     <csymbol cd="unknown">j</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>s</ci>
       </apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-.</ci>
      <csymbol cd="unknown">t</csymbol>
      <minus></minus>
      <csymbol cd="unknown">θ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>s</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>θ</ci>
         <ci>′′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <ci>s</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-.</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">t</csymbol>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <ci>s</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">t</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\omega)\approxeq a(t_{s})\int_{t_{s}-\delta}^{t_{s}+\delta}exp\left[-j\left%
\{(\omega_{s}-\omega_{0}).t-\theta(t_{s})-\frac{\theta^{\prime\prime}(t_{s})}{%
2}.(t-t_{s})^{2}\right\}\right].dt
  </annotation>
 </semantics>
</math>

</p>

<p>In this equation t<sub>s</sub> represents a constant time point, so terms depending on t<sub>s</sub> alone may be taken outside the integral. The expression simplifies to<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><br/>


<math display="inline" id="Chirp_spectrum:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≊</mo>
    <msqrt>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
     </mrow>
    </msqrt>
   </mrow>
   <mo>.</mo>
   <mfrac>
    <mrow>
     <mi>a</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>t</mi>
       <mi>s</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <msqrt>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <msup>
        <mi>θ</mi>
        <mi>′′</mi>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
    </msqrt>
   </mfrac>
   <mo>.</mo>
   <mrow>
    <mi>e</mi>
    <mi>x</mi>
    <mi>p</mi>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mi>j</mi>
      <mrow>
       <mo>{</mo>
       <mrow>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mi>ω</mi>
            <mn>0</mn>
           </msub>
           <mo>-</mo>
           <msub>
            <mi>ω</mi>
            <mi>s</mi>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>t</mi>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>θ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>t</mi>
           <mi>s</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mfrac>
         <mi>π</mi>
         <mn>4</mn>
        </mfrac>
       </mrow>
       <mo>}</mo>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">approximately-equals-or-equals</csymbol>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>ω</ci>
     </apply>
     <apply>
      <root></root>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <root></root>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>θ</ci>
         <ci>′′</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
     <ci>p</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>j</ci>
       <set>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <apply>
           <minus></minus>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>ω</ci>
            <cn type="integer">0</cn>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>ω</ci>
            <ci>s</ci>
           </apply>
          </apply>
          <ci>t</ci>
         </apply>
         <apply>
          <times></times>
          <ci>θ</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>t</ci>
           <ci>s</ci>
          </apply>
         </apply>
         <apply>
          <divide></divide>
          <ci>π</ci>
          <cn type="integer">4</cn>
         </apply>
        </apply>
       </set>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\omega)\approxeq\sqrt{2\pi}.\frac{a(t_{s})}{\sqrt{|\theta^{\prime\prime}(t)|%
}}.exp\left[j\left\{(\omega_{0}-\omega_{s})t+\theta(t_{s})+\frac{\pi}{4}\right%
\}\right]
  </annotation>
 </semantics>
</math>

<br/>
so<br/>


<math display="inline" id="Chirp_spectrum:22">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>S</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>ω</mi>
         <mi>t</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>≊</mo>
    <mrow>
     <mn>2</mn>
     <mi>π</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mfrac>
    <mrow>
     <msup>
      <mi>a</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <msup>
       <mi>θ</mi>
       <mi>′′</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">approximately-equals-or-equals</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <ci>S</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>π</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>θ</ci>
        <ci>′′</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |S(\omega_{t})|^{2}\approxeq 2\pi.\frac{a^{2}(t)}{|\theta^{\prime\prime}(t)|}
  </annotation>
 </semantics>
</math>

</p>

<p>where <mtpl></mtpl> is used to indicate the dependence of the frequency variable on t.<br/>
This is a very useful expression linking, as it does, the spectrum profile to the amplitude and phase characteristics of the chirp.</p>

<p>To carry out the inverse process, i.e. to find the time domain function s(t) given frequency domain data, the inverse Fourier transform is derived.</p>

<p>

<math display="inline" id="Chirp_spectrum:23">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mn>2</mn>
     <mi>π</mi>
    </mrow>
   </mfrac>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mo>-</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <mo stretchy="false">|</mo>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ω</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mo>.</mo>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>j</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mi>ω</mi>
     <mo>.</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>.</mo>
   <mi>d</mi>
   <mi>ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>π</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <minus></minus>
       <infinity></infinity>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">S</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ω</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-|</ci>
    <ci>normal-.</ci>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">j</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">Φ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">ω</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <plus></plus>
      <csymbol cd="unknown">ω</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">ω</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(t)=\frac{1}{2\pi}\int_{-\infty}^{\infty}|S(\omega)|.exp[j(\Phi(\omega)+%
\omega.t)].d\omega
  </annotation>
 </semantics>
</math>


</p>

<p>where <mtpl></mtpl>(x) is the phase function of the spectrum. The stationary phase points for this integrand are located at</p>

<p>

<math display="inline" id="Chirp_spectrum:24">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi mathvariant="normal">Φ</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Φ</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>ω</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi^{\prime}(\omega)=-t
  </annotation>
 </semantics>
</math>

</p>

<p>and the corollary relationship, equivalent to that derived for the spectrum, can be obtained by the stationary phase method, and is</p>

<p>

<math display="inline" id="Chirp_spectrum:25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>a</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>t</mi>
       <mi>ω</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≊</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
   <mfrac>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>S</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ω</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <msup>
       <mi mathvariant="normal">Φ</mi>
       <mi>′′</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ω</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">approximately-equals-or-equals</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>ω</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>ω</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-Φ</ci>
        <ci>′′</ci>
       </apply>
       <ci>ω</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{2}(t_{\omega})\approxeq\frac{1}{2\pi}.\frac{|S(\omega)|^{2}}{|\Phi^{\prime%
\prime}(\omega)|}
  </annotation>
 </semantics>
</math>

</p>

<p>In effect, stationary phase analysis gives the following (approximate) Fourier pair relationships:<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><br/>


<math display="inline" id="Chirp_spectrum:26">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>j</mi>
    <mi>θ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≊</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mn>2</mn>
     <mi>π</mi>
    </mrow>
   </mfrac>
   <mo>.</mo>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mo>-</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ω</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mo>.</mo>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>j</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mi>ω</mi>
     <mo>.</mo>
     <mi>t</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>.</mo>
   <mi>d</mi>
   <mi>ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">j</csymbol>
     <csymbol cd="unknown">θ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="latexml">approximately-equals-or-equals</csymbol>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>π</ci>
     </apply>
    </apply>
    <ci>normal-.</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <minus></minus>
       <infinity></infinity>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <csymbol cd="unknown">S</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ω</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-|</ci>
    <ci>normal-.</ci>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">j</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <csymbol cd="unknown">Φ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">ω</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <plus></plus>
      <csymbol cd="unknown">ω</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">ω</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(t).exp[j\theta(t)]\approxeq\frac{1}{2\pi}.\int_{-\infty}^{\infty}S(\omega)|.%
exp[j\{\Phi(\omega)+\omega.t\}].d\omega
  </annotation>
 </semantics>
</math>

<br/>
and<br/>


<math display="inline" id="Chirp_spectrum:27">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mi>e</mi>
     <mi>x</mi>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>j</mi>
       <mi mathvariant="normal">Φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ω</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>≊</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>e</mi>
    <mi>x</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>j</mi>
       <mrow>
        <mo stretchy="false">{</mo>
        <mrow>
         <mrow>
          <mi>ω</mi>
          <mi>t</mi>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mi>θ</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo stretchy="false">}</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>d</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>ω</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">approximately-equals-or-equals</csymbol>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>x</ci>
      <ci>p</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>j</ci>
        <ci>normal-Φ</ci>
        <ci>ω</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
     <ci>p</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>j</ci>
        <set>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <ci>ω</ci>
           <ci>t</ci>
          </apply>
          <apply>
           <times></times>
           <ci>θ</ci>
           <ci>t</ci>
          </apply>
         </apply>
        </set>
       </apply>
      </apply>
     </apply>
     <ci>d</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |S(\omega)|.exp[j\Phi(\omega)]\approxeq\int_{-\infty}^{\infty}a(t).exp[-j\{%
\omega t-\theta(t)\}]dt
  </annotation>
 </semantics>
</math>

</p>

<p>Consequently, approximate expressions for a(t) and <mtpl></mtpl>(t) can be obtained when the spectrum, including its phase function <mtpl></mtpl>(<mtpl></mtpl>) is given and, similarly, approximate expressions for |S(<mtpl></mtpl>| and <mtpl></mtpl>(<mtpl></mtpl>) can be obtained when the signal characteristics are given. Several examples of the procedure are given in the literature<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>Although the relationships are only approximate, their accuracy improves as the time-bandwidth product increases. In cases where the signal envelope and spectrum modulus are defined by smoothly varying <a href="Gaussian_function" title="wikilink">Gaussian function</a> then a T.<mtpl></mtpl>F product as low as 15 will give acceptable results, but if both a(t) and |S(<mtpl></mtpl>)| are defined by rectangular functions, then the product T.<mtpl></mtpl>F needs to be much greater, typically over 100.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h5 id="examples-of-the-stationary-phase-method">Examples of the stationary phase method</h5>

<p>Typically, in the radar case, a(t) is a constant over the duration of the signal and, for convenience, is assumed here to be unity. So the phase and amplitude characteristics, in the frequency domain, are related by</p>

<p>

<math display="inline" id="Chirp_spectrum:28">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi mathvariant="normal">Φ</mi>
      <mi>′′</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>±</mo>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ω</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Φ</ci>
       <ci>′′</ci>
      </apply>
      <ci>ω</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">plus-or-minus</csymbol>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>S</ci>
       <ci>ω</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi^{\prime\prime}(\omega)=\pm\frac{1}{2\pi}.|S(\omega)|^{2}
  </annotation>
 </semantics>
</math>


</p>

<p>There are two solutions for <mtpl></mtpl>(<mtpl></mtpl>), which are complex conjugates of each other. The two filters with these characteristics can be used as the transmitter and receiver filters of a radar system and are interchangeable.<br/>
The <a href="group_delay" title="wikilink">group delay</a> characteristic D(<mtpl></mtpl>), (where D(<mtpl></mtpl>)=-d<mtpl></mtpl>/d<mtpl></mtpl>), is</p>

<p>

<math display="inline" id="Chirp_spectrum:29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <msup>
       <mi mathvariant="normal">Φ</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ω</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mn>0</mn>
       <mi mathvariant="normal">∞</mi>
      </msubsup>
      <mrow>
       <msup>
        <mi mathvariant="normal">Φ</mi>
        <mi>′′</mi>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ω</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mi>ω</mi>
    </mrow>
    <mo>+</mo>
    <mi>K</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>D</ci>
       <ci>ω</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-Φ</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>ω</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <minus></minus>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <int></int>
          <cn type="integer">0</cn>
         </apply>
         <infinity></infinity>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>normal-Φ</ci>
          <ci>′′</ci>
         </apply>
         <ci>ω</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>ω</ci>
     </apply>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(\omega)=-\Phi^{\prime}(\omega)=-\int_{0}^{\infty}\Phi^{\prime\prime}(\omega)%
.d\omega+K
  </annotation>
 </semantics>
</math>

<br/>
so<br/>


<math display="inline" id="Chirp_spectrum:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>±</mo>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mn>0</mn>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>S</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ω</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mi>ω</mi>
    </mrow>
    <mo>+</mo>
    <mi>K</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>D</ci>
      <ci>ω</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">plus-or-minus</csymbol>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>ω</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>ω</ci>
     </apply>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(\omega)=\pm\frac{1}{2\pi}.\int_{0}^{\infty}|S(\omega)|^{2}.d\omega+K
  </annotation>
 </semantics>
</math>

</p>

<p>So in the case of a rectangular time envelope, the dispersive delay characteristic is given by the integral of the square of the envelope.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> If the positive sign is taken, then the group delay increases with increasing frequency and vice versa. The result is only approximate, but is more accurate for large values of the time bandwidth product.<br/>
Consider, as an example, the case of a spectrum that is uniform over the range -<mtpl></mtpl>/2 to <mtpl></mtpl>/2, then</p>

<p>

<math display="inline" id="Chirp_spectrum:31">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>S</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ω</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <mrow>
     <mi>A</mi>
     <mrow>
      <mi>f</mi>
      <mi>o</mi>
      <mi>r</mi>
     </mrow>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>ω</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo><</mo>
    <mfrac>
     <msub>
      <mi>ω</mi>
      <mrow>
       <mi>m</mi>
       <mi>a</mi>
       <mi>x</mi>
      </mrow>
     </msub>
     <mn>2</mn>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>ω</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <list>
      <ci>A</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>o</ci>
       <ci>r</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <lt></lt>
     <apply>
      <abs></abs>
      <ci>ω</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>a</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |S(\omega)|^{2}=A\qquad for\qquad|\omega|<\frac{\omega_{max}}{2}
  </annotation>
 </semantics>
</math>

<br/>
so<br/>


<math display="inline" id="Chirp_spectrum:32">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo largeop="true" symmetric="true">∫</mo>
    <mi>A</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>d</mi>
      <mi>ω</mi>
     </mrow>
     <mo>+</mo>
     <mi>K</mi>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mi>A</mi>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>ω</mi>
    <mo>+</mo>
    <mi>K</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>D</ci>
      <ci>ω</ci>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <int></int>
     <ci>A</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>ω</ci>
      </apply>
      <ci>K</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>A</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>ω</ci>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(\omega)=\frac{1}{2\pi}.\int A.d\omega+K=\frac{A}{2\pi}.\omega+K
  </annotation>
 </semantics>
</math>

</p>

<p>Put D(-<mtpl></mtpl>/2) = 0 and D(<mtpl></mtpl>/2 = T, where T is the pulse duration, then K = T/2 and A = (2<var>π</var>T)/<var>ω</var><sub>max</sub><br/>
so, finally<br/>


<math display="inline" id="Chirp_spectrum:33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>T</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo>[</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mo>+</mo>
     <mfrac>
      <mi>ω</mi>
      <msub>
       <mi>ω</mi>
       <mrow>
        <mi>m</mi>
        <mi>a</mi>
        <mi>x</mi>
       </mrow>
      </msub>
     </mfrac>
    </mrow>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>D</ci>
      <ci>ω</ci>
     </apply>
     <ci>T</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <divide></divide>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>a</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(\omega)=T.\left[\frac{1}{2}+\frac{\omega}{\omega_{max}}\right]
  </annotation>
 </semantics>
</math>


</p>

<p>As expected, a flat topped frequency spectrum corresponds to a linear frequency sweep.</p>

<p>The linear chirp is just one special case which, in any case, can be calculated more precisely by the methods of the earlier section. The particular usefulness of the stationary phase method lies in its ability to provide results when the frequency sweep is non linear. In such cases the spectral response can be shaped to meet some desired design criteria, for example, low side-lobes when a chirp is compressed. One such family of spectral functions that has been studied<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> is given by</p>

<p>

<math display="inline" id="Chirp_spectrum:34">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>S</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ω</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <msub>
     <mi>A</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>c</mi>
      <mi>o</mi>
      <msup>
       <mi>s</mi>
       <mi>n</mi>
      </msup>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mrow>
         <mi>π</mi>
         <mi>ω</mi>
        </mrow>
        <msub>
         <mi>ω</mi>
         <mrow>
          <mi>m</mi>
          <mi>a</mi>
          <mi>x</mi>
         </mrow>
        </msub>
       </mfrac>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>w</mi>
      <mi>h</mi>
      <mi>e</mi>
      <mi>r</mi>
      <mi>e</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>ω</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
    <mo><</mo>
    <mfrac>
     <msub>
      <mi>ω</mi>
      <mrow>
       <mi>m</mi>
       <mi>a</mi>
       <mi>x</mi>
      </mrow>
     </msub>
     <mn>2</mn>
    </mfrac>
   </mrow>
   <mrow>
    <mi>a</mi>
    <mi>n</mi>
    <mpadded width="+5pt">
     <mi>d</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>n</mi>
    </mpadded>
    <mi>i</mi>
    <mpadded width="+5pt">
     <mi>s</mi>
    </mpadded>
    <mi>a</mi>
    <mpadded width="+5pt">
     <mi>n</mi>
    </mpadded>
    <mi>i</mi>
    <mi>n</mi>
    <mi>t</mi>
    <mi>e</mi>
    <mi>g</mi>
    <mi>e</mi>
    <mi>r</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>ω</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <list>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>o</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>π</ci>
         <ci>ω</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <apply>
          <times></times>
          <ci>m</ci>
          <ci>a</ci>
          <ci>x</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>w</ci>
       <ci>h</ci>
       <ci>e</ci>
       <ci>r</ci>
       <ci>e</ci>
      </apply>
      <apply>
       <abs></abs>
       <ci>ω</ci>
      </apply>
     </list>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>a</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>n</ci>
     <ci>d</ci>
     <ci>n</ci>
     <ci>i</ci>
     <ci>s</ci>
     <ci>a</ci>
     <ci>n</ci>
     <ci>i</ci>
     <ci>n</ci>
     <ci>t</ci>
     <ci>e</ci>
     <ci>g</ci>
     <ci>e</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |S(\omega)|^{2}=A_{n}.cos^{n}\left(\frac{\pi\omega}{\omega_{max}}\right)\qquad
where%
\qquad|\omega|<\frac{\omega_{max}}{2}\qquad and\ n\ is\ an\ integer
  </annotation>
 </semantics>
</math>

</p>

<p>It is possible to find the group delay characteristics of these functions in a similar manner to that carried out above and the results for n = 1 to 4 have been calculated.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a><br/>
Although these cosine functions are amenable to mathematical manipulation, they are rarely chosen to define the spectral characteristics of a chirp, in practice, because when compressed they give broad main pulses with high side-lobe levels. A better characteristic (among many)<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> is the Hamming function, given by</p>

<p>

<math display="inline" id="Chirp_spectrum:35">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>S</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ω</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <mi>A</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mn>0.54</mn>
      <mo>+</mo>
      <mrow>
       <mn>0.46.</mn>
       <mi>c</mi>
       <mi>o</mi>
       <mi>s</mi>
       <mrow>
        <mo>(</mo>
        <mfrac>
         <mrow>
          <mn>2</mn>
          <mi>π</mi>
          <mi>ω</mi>
         </mrow>
         <msub>
          <mi>ω</mi>
          <mrow>
           <mi>m</mi>
           <mi>a</mi>
           <mi>x</mi>
          </mrow>
         </msub>
        </mfrac>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
    <mo>=</mo>
    <mi>A</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo>[</mo>
    <mrow>
     <mn>0.08</mn>
     <mo>+</mo>
     <mrow>
      <mn>0.92.</mn>
      <mi>c</mi>
      <mi>o</mi>
      <msup>
       <mi>s</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mrow>
         <mi>π</mi>
         <mi>ω</mi>
        </mrow>
        <msub>
         <mi>ω</mi>
         <mrow>
          <mi>m</mi>
          <mi>a</mi>
          <mi>x</mi>
         </mrow>
        </msub>
       </mfrac>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>ω</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <ci>A</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <plus></plus>
       <cn type="float">0.54</cn>
       <apply>
        <times></times>
        <cn type="float">0.46.</cn>
        <ci>c</ci>
        <ci>o</ci>
        <ci>s</ci>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>π</ci>
          <ci>ω</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <apply>
           <times></times>
           <ci>m</ci>
           <ci>a</ci>
           <ci>x</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>A</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <plus></plus>
      <cn type="float">0.08</cn>
      <apply>
       <times></times>
       <cn type="float">0.92.</cn>
       <ci>c</ci>
       <ci>o</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>π</ci>
         <ci>ω</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <apply>
          <times></times>
          <ci>m</ci>
          <ci>a</ci>
          <ci>x</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |S(\omega)|^{2}=A.\left[0.54+0.46.cos\left(\frac{2\pi\omega}{\omega_{max}}%
\right)\right]=A.\left[0.08+0.92.cos^{2}\left(\frac{\pi\omega}{\omega_{max}}%
\right)\right]
  </annotation>
 </semantics>
</math>

</p>

<p> A plot of this characteristic is shown, plotted over the range -<mtpl></mtpl>/2 to <mtpl></mtpl>/2.</p>

<p>Applying the equations given above, the group delay characteristic which achieves this spectral shape can be obtained. It is</p>

<p>

<math display="inline" id="Chirp_spectrum:36">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mi>H</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ω</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>T</mi>
   <mo>.</mo>
   <mrow>
    <mo>[</mo>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mo>+</mo>
    <mfrac>
     <mi>ω</mi>
     <msub>
      <mi>ω</mi>
      <mrow>
       <mi>m</mi>
       <mi>a</mi>
       <mi>x</mi>
      </mrow>
     </msub>
    </mfrac>
    <mo>+</mo>
    <mfrac>
     <mn>1.7037</mn>
     <mrow>
      <mn>4</mn>
      <mi>π</mi>
     </mrow>
    </mfrac>
    <mo>.</mo>
    <mi>s</mi>
    <mi>i</mi>
    <mi>n</mi>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
       <mi>ω</mi>
      </mrow>
      <msub>
       <mi>ω</mi>
       <mrow>
        <mi>m</mi>
        <mi>a</mi>
        <mi>x</mi>
       </mrow>
      </msub>
     </mfrac>
     <mo>)</mo>
    </mrow>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>H</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ω</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">T</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>a</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <cn type="float">1.7037</cn>
      <apply>
       <times></times>
       <cn type="integer">4</cn>
       <ci>π</ci>
      </apply>
     </apply>
     <ci>normal-.</ci>
     <csymbol cd="unknown">s</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <ci>ω</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>a</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{H}(\omega)=T.\left[\frac{1}{2}+\frac{\omega}{\omega_{max}}+\frac{1.7037}{4%
\pi}.sin\left(\frac{2\pi\omega}{\omega_{max}}\right)\right]
  </annotation>
 </semantics>
</math>

</p>

<p>Now because the principle of stationary phase shows that there is a direct relationship between elapsed time and the instantaneous signal delay then, for the Hamming window, t/T can be related to <mtpl></mtpl>/<mtpl></mtpl> by</p>

<p>

<math display="inline" id="Chirp_spectrum:37">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mi>t</mi>
     <mi>T</mi>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mo>+</mo>
     <mfrac>
      <mi>ω</mi>
      <msub>
       <mi>ω</mi>
       <mrow>
        <mi>m</mi>
        <mi>a</mi>
        <mi>x</mi>
       </mrow>
      </msub>
     </mfrac>
     <mo>+</mo>
     <mfrac>
      <mn>1.7037</mn>
      <mrow>
       <mn>4</mn>
       <mi>π</mi>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>s</mi>
    <mi>i</mi>
    <mi>n</mi>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
       <mi>ω</mi>
      </mrow>
      <msub>
       <mi>ω</mi>
       <mrow>
        <mi>m</mi>
        <mi>a</mi>
        <mi>x</mi>
       </mrow>
      </msub>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <ci>t</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <divide></divide>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>a</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="float">1.7037</cn>
       <apply>
        <times></times>
        <cn type="integer">4</cn>
        <ci>π</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>i</ci>
     <ci>n</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>ω</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>a</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{t}{T}=\frac{1}{2}+\frac{\omega}{\omega_{max}}+\frac{1.7037}{4\pi}.sin%
\left(\frac{2\pi\omega}{\omega_{max}}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>This characteristic which is time as a function of frequency is shown here. Inverting the plot gives the more usual (and more useful) plot of frequency as a function of time, which is also shown. <br/>
Other spectral shapes can be investigated in the same way and the results, although approximate, are surprisingly accurate, especially when the time bandwidth product of the pulse is high.</p>

<p>The stationary phase method does not predict or deal with Fresnell ripples, so it is unable to offer any means by which these ripples can be minimized. As an example, the figure below shows a chirp spectrum with T.<mtpl></mtpl>F =250 obtained for a non-linear chirp aiming to match the Hamming window, using the methods described above. The figure shows that the spectral profile matches the Hamming characteristic quite well, but Fresnell ripples, not predicted by the method, are very much in evidence.<br/>
</p>
<h4 id="numerical-methods">Numerical methods</h4>
<h5 id="sampling">Sampling</h5>

<p>Whenever a Fourier integral cannot be evaluated by analytical means, an approximate solution is usually possible by <a href="numerical_analysis" title="wikilink">numerical analysis</a>. Such a procedure requires the function to be <a href="sample_(signal)" title="wikilink">sampled</a>, usually at equi-spaced intervals in time.<br/>
One consequence of sampling is that the resultant spectrum is periodic in the frequency domain. In addition to the (desired) baseband spectrum, additional versions of the spectrum occur, centered on multiples of the sampling frequency. To ensure that there is no overlapping of frequency data (i.e. no <a class="uri" href="aliasing" title="wikilink">aliasing</a>) the <a href="Nyquist–Shannon_sampling_theorem" title="wikilink">Nyquist</a> sampling theorem must be satisfied. In practice, a sampling rate substantially higher than that dictated by the sampling theorem is advisable<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>
<h5 id="spectrum-of-a-sampled-signal---the-fourier-transform-of-a-discrete-time-signal">Spectrum of a sampled Signal - the Fourier transform of a discrete time signal</h5>

<p>A straightforward way to approximate an integral, such as a Fourier integral, is to use the standard '<a href="rectangle_rule" title="wikilink">rectangle rule</a>' for numerical integration. The method assumes the signal value taken at a sample instant remains constant for one sampling interval, until the next sample is taken. This procedure is sometimes referred to as a 'box-car generator', or a zero order sample and hold.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a><a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> If the time interval between samples is W, then s<sub>n</sub> = s(nW), and the desired integral is obtained, approximately, by summing the rectangular areas.<br/>
The result so obtained is the convolution of a rectangular pulse with step size W with the impulses located at the sampling instants with weights equal to the sample values.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> In consequence, the spectrum of interest will have superimposed upon it the frequency response of the sample and hold,<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a><a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> and the spectrum of the sampled singnal Ss is given by:<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> 

<math display="inline" id="Chirp_spectrum:38">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ω</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>W</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>s</mi>
        <mi>i</mi>
        <mi>n</mi>
        <mi>ω</mi>
        <mi>W</mi>
       </mrow>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>ω</mi>
      <mi>W</mi>
     </mrow>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </mfrac>
   <mo>.</mo>
   <mo>[</mo>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mrow>
      <mo>-</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <msub>
    <mi>s</mi>
    <mi>n</mi>
   </msub>
   <mo>.</mo>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>-</mo>
    <mi>j</mi>
    <mi>n</mi>
    <mi>ω</mi>
    <mi>W</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ω</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>W</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>s</ci>
        <ci>i</ci>
        <ci>n</ci>
        <ci>ω</ci>
        <ci>W</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>ω</ci>
       <ci>W</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>normal-.</ci>
    <ci>normal-[</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>n</ci>
    </apply>
    <ci>normal-.</ci>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <minus></minus>
     <csymbol cd="unknown">j</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <csymbol cd="unknown">ω</csymbol>
     <csymbol cd="unknown">W</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-]</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ss(\omega))=\frac{W(sin\omega W/2)}{\omega W/2}.\left[\sum_{n=-\infty}^{\infty%
}s_{n}.exp(-jn\omega W)\right]
  </annotation>
 </semantics>
</math>


</p>

<p>The first part of the expression, i.e. the 'sin(x)/x' part, is the frequency response of the sample and hold. Its amplitude decreases with frequency and it falls to 63% of its peak value at half the sampling frequency and it is zero at multiples of that frequency (since f<sub>s</sub> =1/W).<br/>
The second term in the equation is called the Fourier transform of the discrete signal s<sub>n</sub>.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a><a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> It is a continuous function over all <mtpl></mtpl> and involves an infinite number of summations. In practice the summation process can be truncated to a finite number of samples, N, possibly because the waveform is periodic or zero outside the range of samples. Furthermore, because the same spectrum is endlessly repeated, it is possible to confine interest to spectral data within the range -<mtpl></mtpl>/2 to +<mtpl></mtpl>/2.</p>

<p>As an example, an exponential chirp (with its top frequency well below the Nyquist limit) is sampled at 256 points, as shown.<br/>
 The sampled spectrum, Ss(<mtpl></mtpl>) of this waveform, calculated using the equation given above, is shown. To simplify the plot, only the results at positive frequencies have been displayed. The influence of the frequency spectrum of the zero order hold circuit is clearly seen in the diagram.<br/>
 The baseband portion of the spectrum is shown in more detail in the next figure and the response shows a distinct slope, being significantly lower at the higher frequencies.<br/>
<br/>
Although the characteristic of the zero order hold has a small influence on this result, the slope is mainly due to the properties of the chirp. The waveform sweeps relatively quickly over the high frequencies and spends more time sweeping the low frequencies, consequently there is less energy content at the high frequencies with more at the lower ones. (A linear chirp, on the other hand, has a nominally flat spectrum because its frequencies are swept at the same rate, as shown in some earlier plots).</p>
<h5 id="the-discrete-fourier-transform">The discrete Fourier transform</h5>

<p>If we limit interest in the output spectrum to a finite number of discrete data points (= N), at frequencies <mtpl></mtpl> given by<br/>


<math display="inline" id="Chirp_spectrum:39">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ω</mi>
     <mi>m</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
       <mi>m</mi>
      </mrow>
      <mrow>
       <mi>N</mi>
       <mi>W</mi>
      </mrow>
     </mfrac>
     <mrow>
      <mi>f</mi>
      <mi>o</mi>
      <mi>r</mi>
     </mrow>
    </mrow>
   </mrow>
   <mrow>
    <mi>m</mi>
    <mo>=</mo>
    <mrow>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">…</mi>
       <mi>N</mi>
      </mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>m</ci>
     </apply>
     <list>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <times></times>
        <ci>N</ci>
        <ci>W</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>o</ci>
       <ci>r</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <ci>m</ci>
     <list>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>normal-…</ci>
        <ci>N</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{m}=\frac{2\pi m}{NW}\qquad for\qquad m=0,1,2,...N-1
  </annotation>
 </semantics>
</math>

</p>

<p>then the formula for calculating the <a href="discrete_Fourier_transform" title="wikilink">discrete Fourier transform</a> is</p>

<p>

<math display="inline" id="Chirp_spectrum:40">
 <semantics>
  <mrow>
   <mi>S</mi>
   <msub>
    <mi>s</mi>
    <mi>m</mi>
   </msub>
   <mo>=</mo>
   <mi>S</mi>
   <mi>s</mi>
   <mrow>
    <mo>(</mo>
    <mi>j</mi>
    <mfrac>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
      <mi>m</mi>
     </mrow>
     <mrow>
      <mi>N</mi>
      <mi>W</mi>
     </mrow>
    </mfrac>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <msub>
    <mi>s</mi>
    <mi>n</mi>
   </msub>
   <mo>.</mo>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>-</mo>
    <mi>j</mi>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
       <mi>m</mi>
       <mi>n</mi>
      </mrow>
      <mi>N</mi>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>m</ci>
    </apply>
    <ci></ci>
    <eq></eq>
    <csymbol cd="unknown">S</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">j</csymbol>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <ci>N</ci>
       <ci>W</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci></ci>
    <eq></eq>
    <ci></ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>n</ci>
    </apply>
    <ci>normal-.</ci>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <minus></minus>
     <csymbol cd="unknown">j</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <ci>m</ci>
        <ci>n</ci>
       </apply>
       <ci>N</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ss_{m}\quad=Ss\left(j\frac{2\pi m}{NW}\right)\quad=\quad\sum_{n=0}^{N-1}s_{n}.%
exp(-j\left(\frac{2\pi mn}{N}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>The calculations can be carried out by means of a straightforward computer algorithm,<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> but this is not very efficient in computer usage. Consequently, more efficient algorithms have been developed, especially <a href="Fast_Fourier_Transforms" title="wikilink">Fast Fourier Transforms</a> (FFT). Computer programs which implement the FFT are widely available in the literature<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a><a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a><a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> and in proprietary CAD programs such as <a class="uri" href="Mathcad" title="wikilink">Mathcad</a>, <a class="uri" href="MATLAB" title="wikilink">MATLAB</a>, and <a class="uri" href="Mathematica" title="wikilink">Mathematica</a>.<br/>
In the following example a linear chirp with time bandwidth product of 25 is sampled at 128 points (i.e. N = 128). In the figure samples of the real part of the waveform are shown - note that these are samples in the time domain. The FFT process assumes the waveform is cyclic, so these 128 data points can be considered to be part of an endlessly repeating sequence in time.<br/>
 By calculating the N-point FFT of this data, the discrete spectrum of the sequence is obtained. The magnitude of this spectrum is shown in the attached figure, where these data points are samples in frequency. The data is cyclic so, in the plot, the zero frequency point is at n = 0 and also at n = 128 (i.e. both points are the same frequency). The point n = 64 corresponds to +fs/2 (and also to -fs/2).  To display the spectrum in more detail (but not necessarily with more resolution<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a>), the time sequence can be extended by zero padding.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a><a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a><a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> For example, extending the 128 point time sequence with zeros to give N = 4096 results in that part of the spectrum originally presented in 16 samples, now being presented in 512 samples, as shown.<br/>
</p>
<h3 id="the-spectral-spread-of-a-chirp">The spectral spread of a chirp</h3>

<p>There is very little spectral content beyond the sweep frequency range of a chirp pulse and this is especially true for waveforms where the time-bandwidth product is large. The full line on the graph of the adjacent figure shows results for linear chirps. It shows, for example, that only about 2% of the total power resides at frequencies outside the sweep range <mtpl></mtpl>F when the time-bandwidth is 100, and it is less than 1/2% when T.<mtpl></mtpl>F is 500.<br/>
In the case of a non-linear chirp, or a linear chirp shaped by amplitude weighting, the fraction of power outside <mtpl></mtpl>F is even lower, as is shown on the graph, where the dashed line is for spectra with Hamming profiles.<br/>
This low spectral spread is particularly significant when baseband signals are to be digitized since it permits a sampling frequency to be chosen which is only slightly higher than twice the maximum frequency excursion of the chirp.</p>
<figure><b>(Figure)</b>
<figcaption>Fraction of Power Outside Sweep Range.png</figcaption>
</figure>
<h3 id="reducing-spectral-ripple">Reducing Spectral Ripple</h3>

<p>The Fresnel ripples on a chirp spectrum are very obtrusive, especially when time-bandwidth products are low (under 50, say) and their presence leads to high time sidelobe levels when chirps are subject to <a href="pulse_compression" title="wikilink">pulse compression</a> as in <a class="uri" href="radar" title="wikilink">radar</a> and <a class="uri" href="sonar" title="wikilink">sonar</a> systems. They arise because of the sudden discontinuities in the chirp waveform at the commencement and termination of the pulse.<br/>
Although there are a number of procedures that can be applied to reduce the ripple levels, they are not all equally effective. Furthermore, some of the methods require amplitude shaping, or amplitude modulation, of the chirp pulse and this makes those methods unsuitable when, for example, the chirp pulses are to be transmitted by a power amplifier operating in a near-limiting condition. For such systems only the methods using frequency (or phase) pre-distortion are appropriate.</p>
<h4 id="introducing-rise-and-fall-times-of-finite-duration">Introducing Rise and Fall Times of Finite Duration</h4>

<p>If the transitions at the start and end of the chirp are made less sudden (or more 'rounded'), then a reduction in ripple amplitude is achieved.<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a><a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a><a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a> The durations of the two transition regions need only be a small fraction of the pulse duration, and suggested values are between 2/<mtpl></mtpl>F and 3/<mtpl></mtpl>F <a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> but, as expected, when the time-bandwidth product of the pulse is small, longer transition periods are needed. The actual profiles of these rise and fall regions of a pulse do not seem to be critical and may be provided, for example, by band limiting filters in analogue implementations and a linear slope in digital ones.<br/>
 Two examples show the spectra of linear chirps with finite rise-times. The first is for a chirp with time-bandwidth of 250, where the rise and fall times are 4% of the total pulse duration and the second is for a chirp with time-bandwidth of 25, where the rise and fall times are 10% of the total. These two spectra show a marked reduction in ripple amplitude compared to the spectra of unmodified linear chirps shown earlier.<br/>
</p>
<h4 id="applying-phase-or-frequency-distortion-to-the-chirp-pulse">Applying Phase or Frequency Distortion to the Chirp Pulse</h4>

<p>A analogous technique can be applied to the frequency characteristic of the chirp waveform by adding linear FM distortion segments (quadratic phase modulation distortion) to the frequency characteristic of the chirp, as shown. The method is effective because amplitude and phase distortions having functional similarity can produce similar effects when the distortion factors are small.<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a><a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a><br/>
 Suggested values for these distortion regions, to give good results are:<br/>


<math display="inline" id="Chirp_spectrum:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <msub>
      <mi>f</mi>
      <mi>p</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mn>0.75</mn>
      <mi mathvariant="normal">Δ</mi>
      <mi>F</mi>
     </mrow>
     <mrow>
      <mi>a</mi>
      <mi>n</mi>
      <mi>d</mi>
     </mrow>
    </mrow>
   </mrow>
   <mrow>
    <mi>δ</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
     <mi>F</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <list>
      <apply>
       <times></times>
       <cn type="float">0.75</cn>
       <ci>normal-Δ</ci>
       <ci>F</ci>
      </apply>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>n</ci>
       <ci>d</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <ci>δ</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>normal-Δ</ci>
      </apply>
      <ci>F</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta f_{p}=0.75\Delta F\qquad and\qquad\delta=1/\Delta F
  </annotation>
 </semantics>
</math>

</p>

<p>Later work<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a> proposed slightly different values, namely:<br/>


<math display="inline" id="Chirp_spectrum:42">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <msub>
      <mi>f</mi>
      <mi>p</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mn>0.73</mn>
      <mi mathvariant="normal">Δ</mi>
      <mi>F</mi>
     </mrow>
     <mrow>
      <mi>a</mi>
      <mi>n</mi>
      <mi>d</mi>
     </mrow>
    </mrow>
   </mrow>
   <mrow>
    <mi>δ</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mn>0.86</mn>
      <mo>/</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
     <mi>F</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <list>
      <apply>
       <times></times>
       <cn type="float">0.73</cn>
       <ci>normal-Δ</ci>
       <ci>F</ci>
      </apply>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>n</ci>
       <ci>d</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <ci>δ</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="float">0.86</cn>
       <ci>normal-Δ</ci>
      </apply>
      <ci>F</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta f_{p}=0.73\Delta F\qquad and\qquad\delta=0.86/\Delta F
  </annotation>
 </semantics>
</math>

<br/>
but the outcome can doubtless be improved by optimizing values for each particular situation.<br/>
Two plots show the effects of frequency pre-correction and can be compared to the results in the earlier sections.<br/>
 The ripple reduction achieved by frequency pre-correction, although significant, is seen to be less successful than that achieved by the amplitude modulation methods of the previous section. However, it has been suggested<a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a> that by implementing cubic (rather than quadratic) phase pre-correction, comparable results can be achieved.</p>
<h4 id="deriving-a-waveform-from-a-target-frequency-spectrum">Deriving a Waveform from a Target Frequency Spectrum</h4>

<p>This method uses an inverse Fourier transform in order to derive a waveform which has a spectrum with the phase characteristic of a chosen chirp but a new amplitude profile which is rectangular and ripple free. The method is very effective but, unfortunately, the waveform that is so derived has a semi-infinite time duration. If, for convenience, the newly derived waveform is truncated to a practical length, then some ripple is reintroduced onto the spectrum.<br/>
As an example, a linear chirp waveform with a time bandwidth of 25 is shown together with its spectrum magnitude (shown by a full line) which, as demonstrated earlier, has a large ripple component. It is possible to find, by means of an inverse FFT, a chirp waveform which, in the frequency domain, has the same phase characteristic as before, but with the rectangular magnitude characteristic shown by the dashed line on the plot. The chirp waveform resulting from this process has a very long time duration, but when it is truncated to say, a length 2T, then the spectrum acquires some ripple once more, as shown.<br/>
</p>
<h4 id="applying-window-functions">Applying Window Functions</h4>

<p>There are many applications in which a spectrum with a rectangular magnitude profile is not ideal. For example, when a chirp waveform is compressed by means of its matched filter, then the resultant waveform approximates to the <a class="uri" href="sinc" title="wikilink">sinc</a> function and, consequently, has annoyingly high sidelobes. Often, to improve the characteristics of the pulse and lower the sidelobe levels, its spectrum is modified, typically to a bell-shaped profile. Similar problems arise in <a href="digital_signal_processing" title="wikilink">digital signal processing</a> where the spectral shaping is provided by a <a href="window_function" title="wikilink">window function</a>, a process sometimes called <a class="uri" href="apodization" title="wikilink">apodization</a>. In the case of an antenna array, similar profiling by "weighting functions" is used to reduce the spatial sidelobes of the radiation pattern.<br/>
Although spectral shaping of a chirp could be applied in the frequency domain, better results are obtained if the shaping is carried out in the time domain.<a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a><a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a><br/>
Examples of this process are shown for linear chirps with time-bandwidth products of 250 and 25. They have been shaped by a 3-term Blackman-Harris window<a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a> given by<br/>


<math display="inline" id="Chirp_spectrum:43">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>U</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ω</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>0.42323</mn>
     <mo>-</mo>
     <mrow>
      <mn>0.49755</mn>
      <mi>c</mi>
      <mi>o</mi>
      <mi>s</mi>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mrow>
         <mn>2</mn>
         <mi>π</mi>
         <mi>ω</mi>
        </mrow>
        <msub>
         <mi>ω</mi>
         <mrow>
          <mi>m</mi>
          <mi>a</mi>
          <mi>x</mi>
         </mrow>
        </msub>
       </mfrac>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>0.07922</mn>
     <mi>c</mi>
     <mi>o</mi>
     <mi>s</mi>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <mn>4</mn>
        <mi>π</mi>
        <mi>ω</mi>
       </mrow>
       <msub>
        <mi>ω</mi>
        <mrow>
         <mi>m</mi>
         <mi>a</mi>
         <mi>x</mi>
        </mrow>
       </msub>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>U</ci>
       <ci>ω</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <cn type="float">0.42323</cn>
      <apply>
       <times></times>
       <cn type="float">0.49755</cn>
       <ci>c</ci>
       <ci>o</ci>
       <ci>s</ci>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>π</ci>
         <ci>ω</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <apply>
          <times></times>
          <ci>m</ci>
          <ci>a</ci>
          <ci>x</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="float">0.07922</cn>
      <ci>c</ci>
      <ci>o</ci>
      <ci>s</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <cn type="integer">4</cn>
        <ci>π</ci>
        <ci>ω</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>a</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |U(\omega)|^{2}=0.42323-0.49755cos\left(\frac{2\pi\omega}{\omega_{max}}\right)%
+0.07922cos\left(\frac{4\pi\omega}{\omega_{max}}\right)
  </annotation>
 </semantics>
</math>


<br/>
The spectra, now bell-shaped, are seen to be free of ripples.   Non-linear chirps can be devised that have a bell shaped spectrum, such as the Blackman-Harris window just discussed, and consequently will exhibit reduced ripple compared to the linear chirp. By means of the stationary phase method described earlier, an approximate relationship between time and frequency can be obtained and is:<br/>


<math display="inline" id="Chirp_spectrum:44">
 <semantics>
  <mrow>
   <mfrac>
    <mi>t</mi>
    <mi>T</mi>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mo>+</mo>
    <mfrac>
     <mi>ω</mi>
     <msub>
      <mi>ω</mi>
      <mrow>
       <mi>m</mi>
       <mi>a</mi>
       <mi>x</mi>
      </mrow>
     </msub>
    </mfrac>
    <mo>+</mo>
    <mrow>
     <mn>0.1871</mn>
     <mi>s</mi>
     <mi>i</mi>
     <mi>n</mi>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <mn>2</mn>
        <mi>π</mi>
        <mi>ω</mi>
       </mrow>
       <msub>
        <mi>ω</mi>
        <mrow>
         <mi>m</mi>
         <mi>a</mi>
         <mi>x</mi>
        </mrow>
       </msub>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>0.014895</mn>
     <mi>s</mi>
     <mi>i</mi>
     <mi>n</mi>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <mn>4</mn>
        <mi>π</mi>
        <mi>ω</mi>
       </mrow>
       <msub>
        <mi>ω</mi>
        <mrow>
         <mi>m</mi>
         <mi>a</mi>
         <mi>x</mi>
        </mrow>
       </msub>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>t</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <divide></divide>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>a</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="float">0.1871</cn>
      <ci>s</ci>
      <ci>i</ci>
      <ci>n</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <ci>ω</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>a</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="float">0.014895</cn>
      <ci>s</ci>
      <ci>i</ci>
      <ci>n</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <cn type="integer">4</cn>
        <ci>π</ci>
        <ci>ω</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>a</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{t}{T}=\frac{1}{2}+\frac{\omega}{\omega_{max}}+0.1871sin\left(\frac{2\pi%
\omega}{\omega_{max}}\right)+0.014895sin\left(\frac{4\pi\omega}{\omega_{max}}\right)
  </annotation>
 </semantics>
</math>

<br/>
 Rearranging the equation, a plot of frequency against time can be plotted, as shown.</p>

<p>As examples, plots of the spectral magnitudes of non-linear chirps with spectral profiles of Blackman-Harris windows and with time-bandwidth products of 250 and 25 are shown below. As can be seen, there is some ripple reduction, but the disappointing performance can be attributed to the fact that these chirps, although they have reduced energy content in their outer frequency regions, they still have amplitude profiles with fast rise and fall times.<br/>
</p>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Pulse_compression" title="wikilink">Pulse compression</a>, a process which uses frequency or phase coded waveforms to improve the signal to noise of received signals.</li>
<li><a href="Chirp_compression" title="wikilink">Chirp compression</a>, a compression process for chirps only.</li>
</ul>

<p>"</p>

<p><a href="Category:Signal_processing" title="wikilink">Category:Signal processing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Jahnke E. and Emde F., "Tables of functions", Dover Publications N.Y. 1945<a href="#fnref1">↩</a></li>
<li id="fn2">Abramowitz M. and Stegun I.A.,"Handbook of Mathematical Functions", Nat. Bur. Standards 1964, reprinted by Dover Publications N.Y. 1965 (9th ed.1972)<a href="#fnref2">↩</a></li>
<li id="fn3">Klauder J.R., Price A.C., Darlington S. and Albersheim W.J., The Theory and Design of Chirp Radars", The Bell system Technical Journal, Vol.39, July 1960 (pp.745-809)<a href="#fnref3">↩</a></li>
<li id="fn4">Chin J.E. and Cook C.E., The Mathematics of Pulse compression", Sperry Eng. Review, Vol.12, Oct 1959. (pp.11-16)<a href="#fnref4">↩</a></li>
<li id="fn5">Cook C.E., Pulse Compression - Key to More Efficient Radar Transmission",Proc.IRE, March 1960 (p.312)<a href="#fnref5">↩</a></li>
<li id="fn6">Cook C.E. and Bernfeld M., "Radar Signals - An Introduction to Theory and Application", Academic Press 1967,1987, reprinted by Artech House 1993.<a href="#fnref6">↩</a></li>
<li id="fn7">Varhney L.R. and Thomas D.,"Sidelobe Reduction for Matched Filter range Processing", IEEE Radar Conference 2003<a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11">Fowle E.N., "The design of FM pulse compression signals", IEEE Trans. IT-10, 1964, (pp.61-67)<a href="#fnref11">↩</a></li>
<li id="fn12">Key E.L., Fowle E.N., Haggarty R.D.., "A method of pulse compression employing nonlinear frequency modulation", M.I.T. Lincon Lab., Lexington, Mass., Tech. Rep. 207, 1959.<a href="#fnref12">↩</a></li>
<li id="fn13">Key E.L., Fowle E.N., Haggarty R.D.., "A Method of Designing Signals of Large Time-Bandwidth Product", Proc. IRE Int. Con. Rec. Pt.4, March 1961 (pp.146-154)<a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24">Harris F.J., "On the Use of Windows for Harmonic Analysis with the Discrete Fourier Transform", Proc. IEEE Vol.66, Jan 1978<a href="#fnref24">↩</a></li>
<li id="fn25">Burrus C.S. and Parks T.W., "DFT/FFT and Convolution Algorithms", Wiley &amp; Sons, Interscience 1985.<a href="#fnref25">↩</a></li>
<li id="fn26">Tou J.T., "Digital and Sampled-data Control Systems", McGraw-Hill N.Y. 1959<a href="#fnref26">↩</a></li>
<li id="fn27">Ragazzini J.R. and Franklin G.F., "Sampled-Data Control Systems", McGraw-Hill N.Y. 1958<a href="#fnref27">↩</a></li>
<li id="fn28"></li>
<li id="fn29"></li>
<li id="fn30"></li>
<li id="fn31"></li>
<li id="fn32"></li>
<li id="fn33">Stearns S.D. and Hush D.R., "Digital signal Analysis", Prentice-Hall, 1990 (p.61)<a href="#fnref33">↩</a></li>
<li id="fn34"></li>
<li id="fn35"></li>
<li id="fn36"></li>
<li id="fn37">Harris F.J. "Fast Fourier Transforms", San Diego State Univ. Cal. 1984<a href="#fnref37">↩</a></li>
<li id="fn38">Anon, "Zero Padding does not buy Spectral Resolution" National Instruments 2006, <a class="uri" href="http://www.ni.comwhite-paper/4880/en/">http://www.ni.comwhite-paper/4880/en/</a><a href="#fnref38">↩</a></li>
<li id="fn39"></li>
<li id="fn40">Harris F.J. "Signal Processing with Ones and Zeros and the FFT", San Diego State Univ., Cal. 1984<a href="#fnref40">↩</a></li>
<li id="fn41">Lyons R., "How to Interpolate in the Time Domain by Zero-Padding in the Frequency Domain", <a class="uri" href="http://www.dspguru.com/dsp/how-to-interpolate-in-time-domain-by-zero-padding-inthe-frequency-domain">http://www.dspguru.com/dsp/how-to-interpolate-in-time-domain-by-zero-padding-inthe-frequency-domain</a><a href="#fnref41">↩</a></li>
<li id="fn42"></li>
<li id="fn43">Cook C.E. &amp; Paolillo J., "A Pulse Compression Predistortion Function for Efficient Sidelobe Reduction in a High-Power Radar", Proc. IEEE Vol.52, April 1964 (pp.377-384)<a href="#fnref43">↩</a></li>
<li id="fn44">Kowatsch M. and Stocker H.R., "Effect of Fresnel ripples on sidelobe suppression in low time-bandwidth product linear FM pulse compression", IEE Proc. Vol. 129, Pf. F, No.1 Feb 1982<a href="#fnref44">↩</a></li>
<li id="fn45"></li>
<li id="fn46"></li>
<li id="fn47">Wheeler H.A., "The Interpretation of Amplitude and Phase Distortion in Terms of Paired Echoes", Proc. IRE, June 1939<a href="#fnref47">↩</a></li>
<li id="fn48">Solal M., "High Performance SAW Delay Lines for Low Time Bandwidth Using Periodically Sampled Transducers", Ultrasonics Symposium, IEEE, Nov. 1988.<a href="#fnref48">↩</a></li>
<li id="fn49"></li>
<li id="fn50">Judd G.W., "Technique for Realizing Low Time Sidelobe Levels in Small Compression Ratio Chirp Waveforms", Proc. IEEE Ultrasonics Symposium, 1973, pp.478-483<a href="#fnref50">↩</a></li>
<li id="fn51">McCue J.J.G., "A Note on the Hamming Weighting of Linear-FM Pulses", Proc. IEEE, Vol. 67, No. 11, Nov 1979, pp.1575-1577.<a href="#fnref51">↩</a></li>
<li id="fn52"></li>
</ol>
</section>
</body>
</html>
