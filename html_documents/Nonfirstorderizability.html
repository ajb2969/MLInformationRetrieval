<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1882">Nonfirstorderizability</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Nonfirstorderizability</h1>
<hr/>

<p>In <a href="formal_logic" title="wikilink">formal logic</a>, <strong>nonfirstorderizability</strong> is the inability of an expression to be adequately captured in particular theories in <a href="first-order_logic" title="wikilink">first-order logic</a>. Nonfirstorderizable sentences are sometimes presented as evidence that first-order logic is not adequate to capture the nuances of meaning in natural language.</p>

<p>The term was coined by <a href="George_Boolos" title="wikilink">George Boolos</a> in his well-known paper "To Be is to Be a Value of a Variable (or to Be Some Values of Some Variables)." Boolos argued that such sentences call for <a href="second-order_logic" title="wikilink">second-order</a> symbolization, which can be interpreted as plural quantification over the same domain as first-order quantifiers use, without postulation of distinct "second-order objects" (<a class="uri" href="properties" title="wikilink">properties</a>, sets, etc.).</p>

<p>A standard example, known as the <em><a href="Peter_Geach" title="wikilink">Geach</a>–<a href="David_Kaplan_(philosopher)" title="wikilink">Kaplan</a> sentence</em>, is:</p>
<dl>
<dd>Some critics admire only one another.
</dd>
</dl>

<p>If <em>Axy</em> is understood to mean "<em>x</em> admires <em>y</em>," and the <a href="universe_of_discourse" title="wikilink">universe of discourse</a> is the set of all critics, then a reasonable translation of the sentence into second order logic is:</p>

<p>

<math display="block" id="Nonfirstorderizability:0">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∃</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mi>x</mi>
     <mo>∧</mo>
     <mi>X</mi>
     <mi>y</mi>
     <mo>∧</mo>
     <mi>A</mi>
     <mi>x</mi>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mo>∃</mo>
    <mi>x</mi>
    <mi mathvariant="normal">¬</mi>
    <mi>X</mi>
    <mi>x</mi>
    <mo>∧</mo>
    <mo>∀</mo>
    <mpadded width="+1.7pt">
     <mi>x</mi>
    </mpadded>
    <mo>∀</mo>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mi>x</mi>
     <mo>∧</mo>
     <mi>A</mi>
     <mi>x</mi>
     <mi>y</mi>
     <mo>→</mo>
     <mi>X</mi>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <exists></exists>
    <csymbol cd="unknown">X</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">y</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">X</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <and></and>
      <csymbol cd="unknown">X</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <and></and>
      <csymbol cd="unknown">A</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <exists></exists>
     <csymbol cd="unknown">x</csymbol>
     <not></not>
     <csymbol cd="unknown">X</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <and></and>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">X</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <and></and>
      <csymbol cd="unknown">A</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">X</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists X(\exists x,y(Xx\land Xy\land Axy)\land\exists x\neg Xx\land\forall x%
\,\forall y(Xx\land Axy\rightarrow Xy))
  </annotation>
 </semantics>
</math>

</p>

<p>That this formula has no first-order equivalent can be seen as follows. Substitute the formula (<em>y</em> = <em>x</em> + 1 v <em>x</em> = <em>y</em> + 1) for <em>Axy</em>. The result,</p>

<p>

<math display="block" id="Nonfirstorderizability:1">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∃</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mi>x</mi>
     <mo>∧</mo>
     <mi>X</mi>
     <mi>y</mi>
     <mo>∧</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo>=</mo>
      <mi>x</mi>
      <mo>+</mo>
      <mn>1</mn>
      <mo>∨</mo>
      <mi>x</mi>
      <mo>=</mo>
      <mi>y</mi>
      <mo>+</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mo>∃</mo>
    <mi>x</mi>
    <mi mathvariant="normal">¬</mi>
    <mi>X</mi>
    <mi>x</mi>
    <mo>∧</mo>
    <mo>∀</mo>
    <mpadded width="+1.7pt">
     <mi>x</mi>
    </mpadded>
    <mo>∀</mo>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mi>x</mi>
     <mo>∧</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo>=</mo>
      <mi>x</mi>
      <mo>+</mo>
      <mn>1</mn>
      <mo>∨</mo>
      <mi>x</mi>
      <mo>=</mo>
      <mi>y</mi>
      <mo>+</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>→</mo>
     <mi>X</mi>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <exists></exists>
    <csymbol cd="unknown">X</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">y</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">X</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <and></and>
      <csymbol cd="unknown">X</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <and></and>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <eq></eq>
       <csymbol cd="unknown">x</csymbol>
       <plus></plus>
       <cn type="integer">1</cn>
       <or></or>
       <csymbol cd="unknown">x</csymbol>
       <eq></eq>
       <csymbol cd="unknown">y</csymbol>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <exists></exists>
     <csymbol cd="unknown">x</csymbol>
     <not></not>
     <csymbol cd="unknown">X</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <and></and>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">X</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <and></and>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <eq></eq>
       <csymbol cd="unknown">x</csymbol>
       <plus></plus>
       <cn type="integer">1</cn>
       <or></or>
       <csymbol cd="unknown">x</csymbol>
       <eq></eq>
       <csymbol cd="unknown">y</csymbol>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <csymbol cd="unknown">X</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists X(\exists x,y(Xx\land Xy\land(y=x+1\lor x=y+1))\land\exists x\neg Xx%
\land\forall x\,\forall y(Xx\land(y=x+1\lor x=y+1)\rightarrow Xy))
  </annotation>
 </semantics>
</math>

</p>

<p>states that there is a nonempty set which is closed under the predecessor and successor operations and yet does not contain all numbers. Thus, it is true in all <a href="Non-standard_model_of_arithmetic" title="wikilink">nonstandard models of arithmetic</a> but false in the standard model. Since no first-order sentence has this property, the result follows.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Plural_quantification" title="wikilink">Plural quantification</a></li>
<li><a href="Reification_(linguistics)" title="wikilink">Reification (linguistics)</a></li>
<li><a href="Branching_quantifier" title="wikilink">Branching quantifier</a></li>
<li><a href="Generalized_quantifier" title="wikilink">Generalized quantifier</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>

<p>Reprinted in </p></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Logic" title="wikilink">Category:Logic</a></p>
</body>
</html>
