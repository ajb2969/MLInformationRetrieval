<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1935">Bialgebra</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Bialgebra</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <strong>bialgebra</strong> over a <a href="Field_(mathematics)" title="wikilink">field</a> <em>K</em> is a <a href="vector_space" title="wikilink">vector space</a> over <em>K</em> which is both a <a href="unital_algebra" title="wikilink">unital</a> <a href="associative_algebra" title="wikilink">associative algebra</a> and a <a class="uri" href="coalgebra" title="wikilink">coalgebra</a>. The algebraic and coalgebraic structures are made compatible with a few more axioms. Specifically, the <a class="uri" href="comultiplication" title="wikilink">comultiplication</a> and the <a class="uri" href="counit" title="wikilink">counit</a> are both unital algebra <a class="uri" href="homomorphisms" title="wikilink">homomorphisms</a>, or equivalently, the multiplication and the unit of the algebra both are <a href="Coalgebra#Further_concepts_and_facts" title="wikilink">coalgebra morphisms</a>. (These statements are equivalent since they are expressed by the same <a href="commutative_diagram" title="wikilink">commutative diagrams</a>.)</p>

<p>Similar bialgebras are related by bialgebra homomorphisms. A bialgebra homomorphism is a <a href="linear_map" title="wikilink">linear map</a> that is both an algebra and a coalgebra homomorphism.</p>

<p>As reflected in the symmetry of the commutative diagrams, the definition of bialgebra is <a href="Dual_(category_theory)" title="wikilink">self-dual</a>, so if one can define a <a href="Dual_space" title="wikilink">dual</a> of <em>B</em> (which is always possible if <em>B</em> is finite-dimensional), then it is automatically a bialgebra.</p>
<h2 id="formal-definition">Formal definition</h2>

<p><strong>(<em>B</em>, ∇, η, Δ, ε)</strong> is a <strong>bialgebra</strong> over <em>K</em> if it has the following properties:</p>
<ul>
<li><em>B</em> is a vector space over <em>K</em>;</li>
<li>there are <em>K</em>-<a href="linear_map" title="wikilink">linear maps</a> (multiplication) ∇: <em>B</em> ⊗ <em>B</em> → <em>B</em> (equivalent to <em>K</em>-<a href="multilinear_map" title="wikilink">multilinear map</a> ∇: <em>B</em> × <em>B</em> → <em>B</em>) and (unit) η: <em>K</em> → <em>B</em>, such that (<em>B</em>, ∇, η) is a unital associative <a href="Algebra_over_a_field" title="wikilink">algebra</a>;</li>
<li>there are <em>K</em>-linear maps (comultiplication) Δ: <em>B</em> → <em>B</em> ⊗ <em>B</em> and (counit) ε: <em>B</em> → <em>K</em>, such that (<em>B</em>, Δ, ε) is a (counital coassociative) <a class="uri" href="coalgebra" title="wikilink">coalgebra</a>;</li>
<li>compatibility conditions expressed by the following <a href="commutative_diagram" title="wikilink">commutative diagrams</a>:</li>
</ul>
<ol>
<li>Multiplication ∇ and comultiplication Δ<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>
<dl>
<dd><dl>
<dd>
</dd>
</dl>
</dd>
<dd>where τ: <em>B</em> ⊗ <em>B</em> → <em>B</em> ⊗ <em>B</em> is the <a href="linear_map" title="wikilink">linear map</a> defined by τ(<em>x</em> ⊗ <em>y</em>) = <em>y</em> ⊗ <em>x</em> for all <em>x</em> and <em>y</em> in <em>B</em>,
</dd>
</dl></li>
<li>Multiplication ∇ and counit ε
<dl>
<dd><dl>
<dd>
</dd>
</dl>
</dd>
</dl></li>
<li>Comultiplication Δ and unit η<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a>
<dl>
<dd><dl>
<dd>
</dd>
</dl>
</dd>
</dl></li>
<li>Unit η and counit ε
<dl>
<dd><dl>
<dd>
</dd>
</dl>
</dd>
</dl></li>
</ol>
<h2 id="coassociativity-and-counit">Coassociativity and counit</h2>

<p>The <a href="multilinear_map" title="wikilink"><em>K</em>-linear map</a> Δ: <em>B</em> → <em>B</em> ⊗ <em>B</em> is <a href="coalgebra" title="wikilink">coassociative</a> if 

<math display="inline" id="Bialgebra:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>id</mi>
       <mi>B</mi>
      </msub>
      <mo>⊗</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mi mathvariant="normal">Δ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mo>⊗</mo>
      <msub>
       <mi>id</mi>
       <mi>B</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mi mathvariant="normal">Δ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>id</ci>
       <ci>B</ci>
      </apply>
      <ci>normal-Δ</ci>
     </apply>
     <ci>normal-Δ</ci>
    </apply>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>normal-Δ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>id</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <ci>normal-Δ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathrm{id}_{B}\otimes\Delta)\circ\Delta=(\Delta\otimes\mathrm{id}_{B})\circ\Delta
  </annotation>
 </semantics>
</math>

.</p>

<p>The <em>K</em>-linear map ε: <em>B</em> → <em>K</em> is a counit if 

<math display="inline" id="Bialgebra:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>id</mi>
       <mi>B</mi>
      </msub>
      <mo>⊗</mo>
      <mi>ϵ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mi mathvariant="normal">Δ</mi>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>id</mi>
    <mi>B</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ϵ</mi>
      <mo>⊗</mo>
      <msub>
       <mi>id</mi>
       <mi>B</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mi mathvariant="normal">Δ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <compose></compose>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>id</ci>
        <ci>B</ci>
       </apply>
       <ci>ϵ</ci>
      </apply>
      <ci>normal-Δ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>id</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <compose></compose>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>ϵ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>id</ci>
        <ci>B</ci>
       </apply>
      </apply>
      <ci>normal-Δ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathrm{id}_{B}\otimes\epsilon)\circ\Delta=\mathrm{id}_{B}=(\epsilon\otimes%
\mathrm{id}_{B})\circ\Delta
  </annotation>
 </semantics>
</math>

.</p>

<p>Coassociativy and counit are expressed by the <a href="commutative_diagram" title="wikilink">commutativity</a> of the following two diagrams with <em>B</em> in place of <em>C</em> (they are the duals of the diagrams expressing associativity and unit of an algebra):</p>
<figure><b>(Figure)</b>
<figcaption>coalg.png</figcaption>
</figure>
<h2 id="compatibility-conditions">Compatibility conditions</h2>

<p>The four commutative diagrams can be read either as "comultiplication and counit are <a href="homomorphism" title="wikilink">homomorphisms</a> of algebras" or, equivalently, "multiplication and unit are <a href="homomorphism" title="wikilink">homomorphisms</a> of coalgebras".</p>

<p>These statements are meaningful once we explain the natural structures of algebra and coalgebra in all the vector spaces involved besides <em>B</em>: (<em>K</em>, ∇<sub>0</sub>, η<sub>0</sub>) is a unital associative algebra in an obvious way and (<em>B</em> ⊗ <em>B</em>, ∇<sub>2</sub>, η<sub>2</sub>) is a unital associative algebra with unit and multiplication</p>

<p>

<math display="block" id="Bialgebra:2">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>η</mi>
     <mn>2</mn>
    </msub>
    <mo>:=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>η</mi>
      <mo>⊗</mo>
      <mi>η</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>K</mi>
     <mo>⊗</mo>
     <mi>K</mi>
    </mrow>
    <mo>≡</mo>
    <mi>K</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mo>⊗</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>η</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>η</ci>
      <ci>η</ci>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <equivalent></equivalent>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>K</ci>
       <ci>K</ci>
      </apply>
      <ci>K</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>B</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta_{2}:=(\eta\otimes\eta):K\otimes K\equiv K\to(B\otimes B)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Bialgebra:3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>∇</mo>
     <mn>2</mn>
    </msub>
    <mo>:=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>∇</mo>
       <mo>⊗</mo>
       <mo>∇</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∘</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mrow>
         <mi>i</mi>
         <mi>d</mi>
        </mrow>
        <mo>⊗</mo>
        <mi>τ</mi>
        <mo>⊗</mo>
        <mi>i</mi>
       </mrow>
       <mi>d</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>B</mi>
       <mo>⊗</mo>
       <mi>B</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⊗</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>B</mi>
       <mo>⊗</mo>
       <mi>B</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mo>⊗</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-∇</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <compose></compose>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>normal-∇</ci>
       <ci>normal-∇</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>d</ci>
        </apply>
        <ci>τ</ci>
        <ci>i</ci>
       </apply>
       <ci>d</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>B</ci>
       <ci>B</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>B</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>B</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla_{2}:=(\nabla\otimes\nabla)\circ(id\otimes\tau\otimes id):(B\otimes B)%
\otimes(B\otimes B)\to(B\otimes B)
  </annotation>
 </semantics>
</math>

,</p>

<p>so that 

<math display="inline" id="Bialgebra:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>∇</mo>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo>⊗</mo>
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>⊗</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>y</mi>
         <mn>1</mn>
        </msub>
        <mo>⊗</mo>
        <msub>
         <mi>y</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>∇</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>⊗</mo>
       <msub>
        <mi>y</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊗</mo>
    <mrow>
     <mo>∇</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
       <mo>⊗</mo>
       <msub>
        <mi>y</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-∇</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <ci>normal-∇</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>normal-∇</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla_{2}((x_{1}\otimes x_{2})\otimes(y_{1}\otimes y_{2}))=\nabla(x_{1}%
\otimes y_{1})\otimes\nabla(x_{2}\otimes y_{2})
  </annotation>
 </semantics>
</math>

 or, omitting ∇ and writing multiplication as juxtaposition, 

<math display="inline" id="Bialgebra:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>⊗</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mo>⊗</mo>
      <msub>
       <mi>y</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>⊗</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <msub>
     <mi>y</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1}\otimes x_{2})(y_{1}\otimes y_{2})=x_{1}y_{1}\otimes x_{2}y_{2}
  </annotation>
 </semantics>
</math>

;</p>

<p>similarly, (<em>K</em>, Δ<sub>0</sub>, ε<sub>0</sub>) is a coalgebra in an obvious way and <em>B</em> ⊗ <em>B</em> is a coalgebra with counit and comultiplication</p>

<p>

<math display="block" id="Bialgebra:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ϵ</mi>
     <mn>2</mn>
    </msub>
    <mo>:=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ϵ</mi>
      <mo>⊗</mo>
      <mi>ϵ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mo>⊗</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>K</mi>
     <mo>⊗</mo>
     <mi>K</mi>
    </mrow>
    <mo>≡</mo>
    <mi>K</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϵ</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>ϵ</ci>
      <ci>ϵ</ci>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>B</ci>
       <ci>B</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>K</ci>
       <ci>K</ci>
      </apply>
     </apply>
     <apply>
      <equivalent></equivalent>
      <share href="#.cmml">
      </share>
      <ci>K</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{2}:=(\epsilon\otimes\epsilon):(B\otimes B)\to K\otimes K\equiv K
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Bialgebra:7">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Δ</mi>
     <mn>2</mn>
    </msub>
    <mo>:=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mrow>
         <mi>i</mi>
         <mi>d</mi>
        </mrow>
        <mo>⊗</mo>
        <mi>τ</mi>
        <mo>⊗</mo>
        <mi>i</mi>
       </mrow>
       <mi>d</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∘</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mo>⊗</mo>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mo>⊗</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>B</mi>
       <mo>⊗</mo>
       <mi>B</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⊗</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>B</mi>
       <mo>⊗</mo>
       <mi>B</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Δ</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <compose></compose>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>d</ci>
        </apply>
        <ci>τ</ci>
        <ci>i</ci>
       </apply>
       <ci>d</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>normal-Δ</ci>
       <ci>normal-Δ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>B</ci>
      <ci>B</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>B</ci>
       <ci>B</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>B</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{2}:=(id\otimes\tau\otimes id)\circ(\Delta\otimes\Delta):(B\otimes B)%
\to(B\otimes B)\otimes(B\otimes B)
  </annotation>
 </semantics>
</math>

.</p>

<p>Then, diagrams 1 and 3 say that Δ: <em>B</em> → <em>B</em> ⊗ <em>B</em> is a homomorphism of unital (associative) algebras (<em>B</em>, ∇, η) and (<em>B</em> ⊗ <em>B</em>, ∇<sub>2</sub>, η<sub>2</sub>)</p>

<p>

<math display="block" id="Bialgebra:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mo>∘</mo>
     <mo>∇</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo>∇</mo>
      <mn>2</mn>
     </msub>
     <mo>∘</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mo>⊗</mo>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mo>⊗</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mo>⊗</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <eq></eq>
     <apply>
      <compose></compose>
      <ci>normal-Δ</ci>
      <ci>normal-∇</ci>
     </apply>
     <apply>
      <compose></compose>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-∇</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>normal-Δ</ci>
       <ci>normal-Δ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>B</ci>
      <ci>B</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>B</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta\circ\nabla=\nabla_{2}\circ(\Delta\otimes\Delta):(B\otimes B)\to(B%
\otimes B)
  </annotation>
 </semantics>
</math>

, or simply Δ(<em>xy</em>) = Δ(<em>x</em>) Δ(<em>y</em>),</p>

<p>

<math display="block" id="Bialgebra:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mo>∘</mo>
     <mi>η</mi>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>η</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>K</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mo>⊗</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <eq></eq>
     <apply>
      <compose></compose>
      <ci>normal-Δ</ci>
      <ci>η</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>η</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>K</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>B</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta\circ\eta=\eta_{2}:K\to(B\otimes B)
  </annotation>
 </semantics>
</math>

, or simply Δ(1<sub><em>B</em></sub>) = 1<sub><em>B</em> ⊗ <em>B</em></sub>;</p>

<p>diagrams 2 and 4 say that ε: <em>B</em> → <em>K</em> is a homomorphism of unital (associative) algebras (<em>B</em>, ∇, η) and (<em>K</em>, ∇<sub>0</sub>, η<sub>0</sub>):</p>

<p>

<math display="block" id="Bialgebra:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ϵ</mi>
     <mo>∘</mo>
     <mo>∇</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo>∇</mo>
      <mn>0</mn>
     </msub>
     <mo>∘</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>ϵ</mi>
       <mo>⊗</mo>
       <mi>ϵ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mo>⊗</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>K</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <eq></eq>
     <apply>
      <compose></compose>
      <ci>ϵ</ci>
      <ci>normal-∇</ci>
     </apply>
     <apply>
      <compose></compose>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-∇</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>ϵ</ci>
       <ci>ϵ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>B</ci>
      <ci>B</ci>
     </apply>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon\circ\nabla=\nabla_{0}\circ(\epsilon\otimes\epsilon):(B\otimes B)\to K
  </annotation>
 </semantics>
</math>

, or simply ε(<em>xy</em>) = ε(<em>x</em>) ε(<em>y</em>)</p>

<p>

<math display="block" id="Bialgebra:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ϵ</mi>
     <mo>∘</mo>
     <mi>η</mi>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>η</mi>
     <mn>0</mn>
    </msub>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>K</mi>
    <mo>→</mo>
    <mi>K</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <eq></eq>
     <apply>
      <compose></compose>
      <ci>ϵ</ci>
      <ci>η</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>η</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>K</ci>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon\circ\eta=\eta_{0}:K\to K
  </annotation>
 </semantics>
</math>

, or simply ε(1<sub><em>B</em></sub>) = 1<sub><em>K</em></sub>.</p>

<p>Equivalently, diagrams 1 and 2 say that ∇: <em>B</em> ⊗ <em>B</em> → <em>B</em> is a homomorphism of (counital coassociative) coalgebras (<em>B</em> ⊗ <em>B</em>, Δ<sub>2</sub>, ε<sub>2</sub>) and (<em>B</em>, Δ, ε):</p>

<p>

<math display="block" id="Bialgebra:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo>∇</mo>
       <mo>⊗</mo>
       <mo>∇</mo>
      </mrow>
      <mo>∘</mo>
      <msub>
       <mi mathvariant="normal">Δ</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mo>∘</mo>
      <mo>∇</mo>
     </mrow>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>B</mi>
       <mo>⊗</mo>
       <mi>B</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>→</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>B</mi>
       <mo>⊗</mo>
       <mi>B</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <eq></eq>
     <apply>
      <compose></compose>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>normal-∇</ci>
       <ci>normal-∇</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Δ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <compose></compose>
      <ci>normal-Δ</ci>
      <ci>normal-∇</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>B</ci>
      <ci>B</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>B</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla\otimes\nabla\circ\Delta_{2}=\Delta\circ\nabla:(B\otimes B)\to(B\otimes B),
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Bialgebra:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ϵ</mi>
     <mo>∘</mo>
     <mo>∇</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo>∇</mo>
      <mn>0</mn>
     </msub>
     <mo>∘</mo>
     <msub>
      <mi>ϵ</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>B</mi>
      <mo>⊗</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>K</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <eq></eq>
     <apply>
      <compose></compose>
      <ci>ϵ</ci>
      <ci>normal-∇</ci>
     </apply>
     <apply>
      <compose></compose>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-∇</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϵ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>B</ci>
      <ci>B</ci>
     </apply>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon\circ\nabla=\nabla_{0}\circ\epsilon_{2}:(B\otimes B)\to K
  </annotation>
 </semantics>
</math>

;</p>

<p>diagrams 3 and 4 say that η: <em>K</em> → <em>B</em> is a homomorphism of (counital coassociative) coalgebras (<em>K</em>, Δ<sub>0</sub>, ε<sub>0</sub>) and (<em>B</em>, Δ, ε):</p>

<p>

<math display="block" id="Bialgebra:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mo>∘</mo>
      <mi>η</mi>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msub>
       <mi>η</mi>
       <mn>2</mn>
      </msub>
      <mo>∘</mo>
      <msub>
       <mi mathvariant="normal">Δ</mi>
       <mn>0</mn>
      </msub>
     </mrow>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mi>K</mi>
     <mo>→</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>B</mi>
       <mo>⊗</mo>
       <mi>B</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <eq></eq>
     <apply>
      <compose></compose>
      <ci>normal-Δ</ci>
      <ci>η</ci>
     </apply>
     <apply>
      <compose></compose>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>η</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Δ</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>K</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>B</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta\circ\eta=\eta_{2}\circ\Delta_{0}:K\to(B\otimes B),
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Bialgebra:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ϵ</mi>
     <mo>∘</mo>
     <mi>η</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>η</mi>
      <mn>0</mn>
     </msub>
     <mo>∘</mo>
     <msub>
      <mi>ϵ</mi>
      <mn>0</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>K</mi>
    <mo>→</mo>
    <mi>K</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <eq></eq>
     <apply>
      <compose></compose>
      <ci>ϵ</ci>
      <ci>η</ci>
     </apply>
     <apply>
      <compose></compose>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>η</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϵ</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>K</ci>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon\circ\eta=\eta_{0}\circ\epsilon_{0}:K\to K
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="examples">Examples</h2>

<p>A simple example of a bialgebra is the set of functions from a <a href="group_(mathematics)" title="wikilink">group</a> <em>G</em> to 

<math display="inline" id="Bialgebra:16">
 <semantics>
  <mi>ℝ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℝ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}
  </annotation>
 </semantics>
</math>

, which we may represent as a vector space 

<math display="inline" id="Bialgebra:17">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>G</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{G}
  </annotation>
 </semantics>
</math>

 consisting of linear combinations of standard basis vectors <strong>e</strong><sub><em>g</em></sub> for each <em>g</em> ∈ <em>G</em>, which may represent a <a href="probability_distribution" title="wikilink">probability distribution</a> over <em>G</em> in the case of vectors whose coefficients are all non-negative and sum to 1. An example of suitable comultiplication operators and counits which yield a counital coalgebra are</p>

<p>

<math display="block" id="Bialgebra:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>𝐞</mi>
       <mi>g</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>𝐞</mi>
      <mi>g</mi>
     </msub>
     <mo>⊗</mo>
     <mpadded width="+1.7pt">
      <msub>
       <mi>𝐞</mi>
       <mi>g</mi>
      </msub>
     </mpadded>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐞</ci>
      <ci>g</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐞</ci>
      <ci>g</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐞</ci>
      <ci>g</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(\mathbf{e}_{g})=\mathbf{e}_{g}\otimes\mathbf{e}_{g}\,,
  </annotation>
 </semantics>
</math>

 which represents making a copy of a <a href="random_variable" title="wikilink">random variable</a> (which we extend to all 

<math display="inline" id="Bialgebra:19">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>G</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{G}
  </annotation>
 </semantics>
</math>

 by linearity), and</p>

<p>

<math display="block" id="Bialgebra:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ε</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>𝐞</mi>
       <mi>g</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mpadded width="+1.7pt">
     <mn>1</mn>
    </mpadded>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ε</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐞</ci>
      <ci>g</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon(\mathbf{e}_{g})=1\,,
  </annotation>
 </semantics>
</math>

 (again extended linearly to all of 

<math display="inline" id="Bialgebra:21">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>G</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{G}
  </annotation>
 </semantics>
</math>

) which represents "tracing out" a random variable — <em>i.e.,</em> forgetting the value of a random variable (represented by a single tensor factor) to obtain a <a href="marginal_distribution" title="wikilink">marginal distribution</a> on the remaining variables (the remaining tensor factors). Given the interpretation of (Δ,ε) in terms of probability distributions as above, the bialgebra consistency conditions amount to constraints on (∇,η) as follows:</p>
<ol>
<li>η is an operator preparing a normalized probability distribution which is independent of all other random variables;</li>
<li>The product ∇ maps a probability distribution on two variables to a probability distribution on one variable;</li>
<li>Copying a random variable in the distribution given by η is equivalent to having two independent random variables in the distribution η;</li>
<li>Taking the product of two random variables, and preparing a copy of the resulting random variable, has the same distribution as preparing copies of each random variable independently of one another, and multiplying them together in pairs.</li>
</ol>

<p>A pair (∇,η) which satisfy these constraints are the <a class="uri" href="convolution" title="wikilink">convolution</a> operator</p>

<p>

<math display="block" id="Bialgebra:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∇</mo>
     <mrow>
      <mo maxsize="120%" minsize="120%">(</mo>
      <mrow>
       <msub>
        <mi>𝐞</mi>
        <mi>g</mi>
       </msub>
       <mo>⊗</mo>
       <msub>
        <mi>𝐞</mi>
        <mi>h</mi>
       </msub>
      </mrow>
      <mo maxsize="120%" minsize="120%">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mpadded width="+1.7pt">
     <msub>
      <mi>𝐞</mi>
      <mrow>
       <mi>g</mi>
       <mi>h</mi>
      </mrow>
     </msub>
    </mpadded>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-∇</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐞</ci>
       <ci>g</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐞</ci>
       <ci>h</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐞</ci>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>h</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla\bigl(\mathbf{e}_{g}\otimes\mathbf{e}_{h}\bigr)=\mathbf{e}_{gh}\,,
  </annotation>
 </semantics>
</math>

 again extended to all 

<math display="inline" id="Bialgebra:23">
 <semantics>
  <mrow>
   <msup>
    <mi>ℝ</mi>
    <mi>G</mi>
   </msup>
   <mo>⊗</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>G</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>G</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{G}\otimes\mathbb{R}^{G}
  </annotation>
 </semantics>
</math>

 by linearity; this produces a normalized probability distribution from a distribution on two random variables, and has as a unit the delta-distribution 

<math display="inline" id="Bialgebra:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>η</mi>
    <mo>=</mo>
    <mpadded width="+2.8pt">
     <msub>
      <mi>𝐞</mi>
      <mi>i</mi>
     </msub>
    </mpadded>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>η</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐞</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta=\mathbf{e}_{i}\;,
  </annotation>
 </semantics>
</math>

 where <em>i</em> ∈ <em>G</em> denotes the identity element of the group <em>G</em>.</p>

<p>Other examples of bialgebras include the <a href="Hopf_algebra" title="wikilink">Hopf algebras</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Similar structures with different compatibility between the product and comultiplication, or different types of multiplication and comultiplication, include <a href="Lie_bialgebra" title="wikilink">Lie bialgebras</a> and <a href="Frobenius_algebra" title="wikilink">Frobenius algebras</a>. Additional examples are given in the article on <a href="coalgebra" title="wikilink">coalgebras</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Quasi-bialgebra" title="wikilink">Quasi-bialgebra</a></li>
<li><a href="Frobenius_algebra" title="wikilink">Frobenius algebra</a></li>
<li><a href="Hopf_algebra" title="wikilink">Hopf algebra</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Bialgebras" title="wikilink">Category:Bialgebras</a> <a class="uri" href="Category:Coalgebras" title="wikilink">Category:Coalgebras</a> <a href="Category:Monoidal_categories" title="wikilink">Category:Monoidal categories</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
