<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1043">Reflexive operator algebra</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Reflexive operator algebra</h1>
<hr/>

<p>In <a href="functional_analysis" title="wikilink">functional analysis</a>, a <strong>reflexive <a href="operator_algebra" title="wikilink">operator algebra</a></strong> <em>A</em> is an operator algebra that has enough <a href="invariant_subspace" title="wikilink">invariant subspaces</a> to characterize it. Formally, <em>A</em> is reflexive if it is equal to the algebra of <a href="bounded_operator" title="wikilink">bounded operators</a> which leave <a href="Invariant_(mathematics)" title="wikilink">invariant</a> each <a href="Linear_subspace" title="wikilink">subspace</a> left invariant by every operator in <em>A</em>.</p>

<p>This should not be confused with a <a href="reflexive_space" title="wikilink">reflexive space</a>.</p>
<h2 id="examples">Examples</h2>

<p><a href="Nest_algebra" title="wikilink">Nest algebras</a> are examples of reflexive operator algebras. In finite dimensions, these are simply algebras of all matrices of a given size whose nonzero entries lie in an upper-triangular pattern.</p>

<p>In fact if we fix any pattern of entries in an <em>n</em> by <em>n</em> matrix containing the diagonal, then the set of all <em>n</em> by <em>n</em> matrices whose nonzero entries lie in this pattern forms a reflexive algebra.</p>

<p>An example of an algebra which is <em>not</em> reflexive is the set of 2 by 2 matrices</p>

<p>

<math display="block" id="Reflexive_operator_algebra:0">
 <semantics>
  <mrow>
   <mrow>
    <mo>{</mo>
    <mpadded width="+5pt">
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mi>a</mi>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mi>b</mi>
          <mo>;</mo>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mi>a</mi>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mpadded>
    <mo rspace="7.5pt">:</mo>
    <mrow>
     <mrow>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
     </mrow>
     <mo>‚àà</mo>
     <mi>‚ÑÇ</mi>
    </mrow>
    <mo>}</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <matrix>
     <matrixrow>
      <ci>a</ci>
      <ci>b</ci>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <ci>a</ci>
     </matrixrow>
    </matrix>
    <apply>
     <in></in>
     <list>
      <ci>a</ci>
      <ci>b</ci>
     </list>
     <ci>‚ÑÇ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{\begin{pmatrix}a&b;\\
0&a\end{pmatrix}\ :\ a,b\in\mathbb{C}\right\}.
  </annotation>
 </semantics>
</math>

</p>

<p>This algebra is smaller than the Nest algebra</p>

<p>

<math display="block" id="Reflexive_operator_algebra:1">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mpadded width="+5pt">
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mi>a</mi>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mi>b</mi>
         <mo>;</mo>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mi>c</mi>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mpadded>
   <mo rspace="7.5pt">:</mo>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo>,</mo>
     <mi>c</mi>
    </mrow>
    <mo>‚àà</mo>
    <mi>‚ÑÇ</mi>
   </mrow>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <matrix>
     <matrixrow>
      <ci>a</ci>
      <ci>b</ci>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <ci>c</ci>
     </matrixrow>
    </matrix>
    <apply>
     <in></in>
     <list>
      <ci>a</ci>
      <ci>b</ci>
      <ci>c</ci>
     </list>
     <ci>‚ÑÇ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{\begin{pmatrix}a&b;\\
0&c\end{pmatrix}\ :\ a,b,c\in\mathbb{C}\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>but has the same invariant subspaces, so it is not reflexive.</p>

<p>If <em>T</em> is a fixed <em>n</em> by <em>n</em> matrix then the set of all polynomials in <em>T</em> and the identity operator forms a unital operator algebra. A theorem of Deddens and Fillmore states that this algebra is reflexive if and only if the largest two blocks in the <a href="Jordan_normal_form" title="wikilink">Jordan normal form</a> of <em>T</em> differ in size by at most one. For example, the algebra</p>

<p>

<math display="block" id="Reflexive_operator_algebra:2">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mpadded width="+5pt">
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mi>a</mi>
       </mtd>
       <mtd columnalign="center">
        <mi>b</mi>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mi>a</mi>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mi>a</mi>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mpadded>
   <mo rspace="7.5pt">:</mo>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
    </mrow>
    <mo>‚àà</mo>
    <mi>‚ÑÇ</mi>
   </mrow>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <matrix>
     <matrixrow>
      <ci>a</ci>
      <ci>b</ci>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <ci>a</ci>
     </matrixrow>
    </matrix>
    <apply>
     <in></in>
     <list>
      <ci>a</ci>
      <ci>b</ci>
     </list>
     <ci>‚ÑÇ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{\begin{pmatrix}a&b&0\\
0&a&0\\
0&0&a\end{pmatrix}\ :\ a,b\in\mathbb{C}\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>which is equal to the set of all polynomials in</p>

<p>

<math display="block" id="Reflexive_operator_algebra:3">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=\begin{pmatrix}0&1&0\\
0&0&0\\
0&0&0\end{pmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>and the identity is reflexive.</p>
<h2 id="hyper-reflexivity">Hyper-reflexivity</h2>

<p>Let 

<math display="inline" id="Reflexive_operator_algebra:4">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíú</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíú</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 be a weak*-closed operator algebra contained in <em>B(H)</em>, the set of all bounded operators on a <a href="Hilbert_space" title="wikilink">Hilbert space</a> <em>H</em> and for <em>T</em> any operator in <em>B(H)</em>, let</p>

<p>

<math display="block" id="Reflexive_operator_algebra:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>Œ≤</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo>,</mo>
     <mi class="ltx_font_mathcaligraphic">ùíú</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo movablelimits="false">sup</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo>‚à•</mo>
      <mrow>
       <msup>
        <mi>P</mi>
        <mo>‚üÇ</mo>
       </msup>
       <mi>T</mi>
       <mi>P</mi>
      </mrow>
      <mo rspace="7.5pt">‚à•</mo>
     </mrow>
     <mo rspace="7.5pt">:</mo>
     <mrow>
      <mrow>
       <mi>P</mi>
       <mtext>is a projection and</mtext>
       <msup>
        <mi>P</mi>
        <mo>‚üÇ</mo>
       </msup>
       <mi class="ltx_font_mathcaligraphic">ùíú</mi>
       <mi>P</mi>
      </mrow>
      <mo>=</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Œ≤</ci>
     <interval closure="open">
      <ci>T</ci>
      <ci>ùíú</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">supremum</csymbol>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>P</ci>
         <csymbol cd="latexml">perpendicular-to</csymbol>
        </apply>
        <ci>T</ci>
        <ci>P</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <ci>P</ci>
        <mtext>is a projection and</mtext>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>P</ci>
         <csymbol cd="latexml">perpendicular-to</csymbol>
        </apply>
        <ci>ùíú</ci>
        <ci>P</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta(T,\mathcal{A})=\sup\{\|P^{\perp}TP\|\ :\ P\mbox{ is a projection and }P^%
{\perp}\mathcal{A}P=(0)\}
  </annotation>
 </semantics>
</math>

.</p>

<p>Observe that <em>P</em> is a projection involved in this supremum precisely if the range of <em>P</em> is an invariant subspace of 

<math display="inline" id="Reflexive_operator_algebra:6">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíú</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíú</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

.</p>

<p>The algebra 

<math display="inline" id="Reflexive_operator_algebra:7">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíú</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíú</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 is reflexive if and only if for every <em>T</em> in <em>B(H)</em>:</p>

<p>

<math display="block" id="Reflexive_operator_algebra:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>Œ≤</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo>,</mo>
     <mi class="ltx_font_mathcaligraphic">ùíú</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mtext>implies that</mtext>
    <mi>T</mi>
    <mtext>is in</mtext>
    <mi class="ltx_font_mathcaligraphic">ùíú</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Œ≤</ci>
     <interval closure="open">
      <ci>T</ci>
      <ci>ùíú</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">0</cn>
     <mtext>implies that</mtext>
     <ci>T</ci>
     <mtext>is in</mtext>
     <ci>ùíú</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta(T,\mathcal{A})=0\mbox{ implies that }T\mbox{ is in }\mathcal{A}
  </annotation>
 </semantics>
</math>

.</p>

<p>We note that for any <em>T</em> in <em>B(H)</em> the following inequality is satisfied:</p>

<p>

<math display="block" id="Reflexive_operator_algebra:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>Œ≤</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo>,</mo>
     <mi class="ltx_font_mathcaligraphic">ùíú</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚â§</mo>
   <mrow>
    <mtext>dist</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo>,</mo>
     <mi class="ltx_font_mathcaligraphic">ùíú</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>Œ≤</ci>
     <interval closure="open">
      <ci>T</ci>
      <ci>ùíú</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <mtext>dist</mtext>
     <interval closure="open">
      <ci>T</ci>
      <ci>ùíú</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta(T,\mathcal{A})\leq\mbox{dist}(T,\mathcal{A})
  </annotation>
 </semantics>
</math>

.</p>

<p>Here 

<math display="inline" id="Reflexive_operator_algebra:10">
 <semantics>
  <mrow>
   <mtext>dist</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo>,</mo>
    <mi class="ltx_font_mathcaligraphic">ùíú</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>dist</mtext>
    <interval closure="open">
     <ci>T</ci>
     <ci>ùíú</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{dist}(T,\mathcal{A})
  </annotation>
 </semantics>
</math>

 is the distance of <em>T</em> from the algebra, namely the smallest norm of an operator <em>T-A</em> where A runs over the algebra. We call 

<math display="inline" id="Reflexive_operator_algebra:11">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíú</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíú</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 <strong>hyperreflexive</strong> if there is a constant <em>K</em> such that for every operator <em>T</em> in <em>B(H)</em>,</p>

<p>

<math display="block" id="Reflexive_operator_algebra:12">
 <semantics>
  <mrow>
   <mrow>
    <mtext>dist</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo>,</mo>
     <mi class="ltx_font_mathcaligraphic">ùíú</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚â§</mo>
   <mrow>
    <mi>K</mi>
    <mi>Œ≤</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo>,</mo>
     <mi class="ltx_font_mathcaligraphic">ùíú</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <mtext>dist</mtext>
     <interval closure="open">
      <ci>T</ci>
      <ci>ùíú</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>Œ≤</ci>
     <interval closure="open">
      <ci>T</ci>
      <ci>ùíú</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{dist}(T,\mathcal{A})\leq K\beta(T,\mathcal{A})
  </annotation>
 </semantics>
</math>

.</p>

<p>The smallest such <em>K</em> is called the <strong>distance constant</strong> for 

<math display="inline" id="Reflexive_operator_algebra:13">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíú</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíú</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

. A hyper-reflexive operator algebra is automatically reflexive.</p>

<p>In the case of a reflexive algebra of matrices with nonzero entries specified by a given pattern, the problem of finding the distance constant can be rephrased as a matrix-filling problem: if we fill the entries in the complement of the pattern with arbitrary entries, what choice of entries in the pattern gives the smallest operator norm?</p>
<h2 id="examples-1">Examples</h2>
<ul>
<li>Every finite-dimensional reflexive algebra is hyper-reflexive. However, there are examples of infinite-dimensional reflexive operator algebras which are not hyper-reflexive.</li>
</ul>
<ul>
<li>The distance constant for a one-dimensional algebra is 1.</li>
</ul>
<ul>
<li>Nest algebras are hyper-reflexive with distance constant 1.</li>
</ul>
<ul>
<li>Many <a href="von_Neumann_algebra" title="wikilink">von Neumann algebras</a> are hyper-reflexive, but it is not known if they all are.</li>
</ul>
<ul>
<li>A <a href="type_I_von_Neumann_algebra" title="wikilink">type I von Neumann algebra</a> is hyper-reflexive with distance constant at most 2.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Invariant_subspace" title="wikilink">Invariant subspace</a></li>
<li><a href="subspace_lattice" title="wikilink">subspace lattice</a></li>
<li><a href="reflexive_subspace_lattice" title="wikilink">reflexive subspace lattice</a></li>
<li><a href="nest_algebra" title="wikilink">nest algebra</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>William Arveson, <em>Ten lectures on operator algebras</em>, ISBN 0-8218-0705-6</li>
<li>H. Radjavi and P. Rosenthal, <em>Invariant Subspaces</em>, ISBN 0-486-42822-2</li>
</ul>

<p>"</p>

<p><a href="Category:Operator_theory" title="wikilink">Category:Operator theory</a> <a href="Category:Operator_algebras" title="wikilink">Category:Operator algebras</a> <a href="Category:Invariant_subspaces" title="wikilink">Category:Invariant subspaces</a></p>
</body>
</html>
