<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="825">Zemor's decoding algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Zemor's decoding algorithm</h1>
<hr/>

<p>In <a href="coding_theory" title="wikilink">coding theory</a>, <strong>Zemor's algorithm</strong>, designed and developed by Gilles Zemor,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> is a recursive low-complexity approach to code construction. It is an improvement over the algorithm of <a href="Michael_Sipser" title="wikilink">Sipser</a> and <a href="Daniel_Spielman" title="wikilink">Spielman</a>.</p>

<p>Zemor considered a typical class of Sipser–Spielman construction of <a href="expander_code" title="wikilink">expander codes</a>, where the underlying graph is <a href="bipartite_graph" title="wikilink">bipartite graph</a>. Sipser and Spielman introduced a constructive family of asymptotically good linear-error codes together with a simple parallel algorithm that will always remove a constant fraction of errors. The article is based on Dr. Venkatesan Guruswami's course notes <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="code-construction">Code construction</h2>

<p>Zemor's algorithm is based on a type of <a href="expander_graphs" title="wikilink">expander graphs</a> called <a href="Tanner_graph" title="wikilink">Tanner graph</a>. The construction of code was first proposed by Tanner.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The codes are based on <a href="double_cover" title="wikilink">double cover</a> 

<math display="inline" id="Zemor's_decoding_algorithm:0">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

, regular expander 

<math display="inline" id="Zemor's_decoding_algorithm:1">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>


, which is a bipartite graph. 

<math display="inline" id="Zemor's_decoding_algorithm:2">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 =

<math display="inline" id="Zemor's_decoding_algorithm:3">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mi>V</mi>
   <mo>,</mo>
   <mi>E</mi>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>V</ci>
    <ci>E</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(V,E\right)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Zemor's_decoding_algorithm:4">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is the set of vertices and 

<math display="inline" id="Zemor's_decoding_algorithm:5">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 is the set of edges and 

<math display="inline" id="Zemor's_decoding_algorithm:6">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>


 = 

<math display="inline" id="Zemor's_decoding_algorithm:7">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Zemor's_decoding_algorithm:8">
 <semantics>
  <mo>∪</mo>
  <annotation-xml encoding="MathML-Content">
   <union></union>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cup
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Zemor's_decoding_algorithm:9">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Zemor's_decoding_algorithm:10">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Zemor's_decoding_algorithm:11">
 <semantics>
  <mo>∩</mo>
  <annotation-xml encoding="MathML-Content">
   <intersect></intersect>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cap
  </annotation>
 </semantics>
</math>


 

<math display="inline" id="Zemor's_decoding_algorithm:12">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 = 

<math display="inline" id="Zemor's_decoding_algorithm:13">
 <semantics>
  <mi mathvariant="normal">∅</mi>
  <annotation-xml encoding="MathML-Content">
   <emptyset></emptyset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \emptyset
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Zemor's_decoding_algorithm:14">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Zemor's_decoding_algorithm:15">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 denotes the set of 2 vertices. Let 

<math display="inline" id="Zemor's_decoding_algorithm:16">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


 be the number of vertices in each group, <em>i.e</em>, 

<math display="inline" id="Zemor's_decoding_algorithm:17">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>B</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <abs></abs>
      <ci>A</ci>
     </apply>
     <apply>
      <abs></abs>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|=|B|=n
  </annotation>
 </semantics>
</math>

. The edge set 

<math display="inline" id="Zemor's_decoding_algorithm:18">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 be of size 

<math display="inline" id="Zemor's_decoding_algorithm:19">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 =

<math display="inline" id="Zemor's_decoding_algorithm:20">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   nd
  </annotation>
 </semantics>
</math>

 and every edge in 

<math display="inline" id="Zemor's_decoding_algorithm:21">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>


 has one endpoint in both 

<math display="inline" id="Zemor's_decoding_algorithm:22">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Zemor's_decoding_algorithm:23">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Zemor's_decoding_algorithm:24">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(v)
  </annotation>
 </semantics>
</math>

 denotes the set of edges containing 

<math display="inline" id="Zemor's_decoding_algorithm:25">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

.</p>

<p>Assume an ordering on 

<math display="inline" id="Zemor's_decoding_algorithm:26">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>


, therefore ordering will be done on every edges of 

<math display="inline" id="Zemor's_decoding_algorithm:27">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(v)
  </annotation>
 </semantics>
</math>

 for every 

<math display="inline" id="Zemor's_decoding_algorithm:28">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in V
  </annotation>
 </semantics>
</math>

. Let <a href="finite_field" title="wikilink">finite field</a> 

<math display="inline" id="Zemor's_decoding_algorithm:29">
 <semantics>
  <mrow>
   <mi>𝔽</mi>
   <mo>=</mo>
   <mrow>
    <mi>G</mi>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝔽</ci>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>F</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{F}=GF(2)
  </annotation>
 </semantics>
</math>

, and for a word 

<math display="inline" id="Zemor's_decoding_algorithm:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>e</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>e</mi>
    <mo>∈</mo>
    <mi>E</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>e</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>e</ci>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=(x_{e}),e\in E
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Zemor's_decoding_algorithm:31">
 <semantics>
  <msup>
   <mi>𝔽</mi>
   <mi>N</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝔽</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{F}^{N}
  </annotation>
 </semantics>
</math>


, let the subword of the word will be indexed by 

<math display="inline" id="Zemor's_decoding_algorithm:32">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(v)
  </annotation>
 </semantics>
</math>

. Let that word be denoted by 

<math display="inline" id="Zemor's_decoding_algorithm:33">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>v</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x)_{v}
  </annotation>
 </semantics>
</math>

. The subset of vertices 

<math display="inline" id="Zemor's_decoding_algorithm:34">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Zemor's_decoding_algorithm:35">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 induces every word 

<math display="inline" id="Zemor's_decoding_algorithm:36">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mi>𝔽</mi>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝔽</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\mathbb{F}^{N}
  </annotation>
 </semantics>
</math>


 a partition into 

<math display="inline" id="Zemor's_decoding_algorithm:37">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 non-overlapping sub-words 

<math display="inline" id="Zemor's_decoding_algorithm:38">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo>(</mo>
     <mi>x</mi>
     <mo>)</mo>
    </mrow>
    <mi>v</mi>
   </msub>
   <mo>∈</mo>
   <msup>
    <mi>𝔽</mi>
    <mi>d</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝔽</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(x\right)_{v}\in\mathbb{F}^{d}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Zemor's_decoding_algorithm:39">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 ranges over the elements of 

<math display="inline" id="Zemor's_decoding_algorithm:40">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. For constructing a code 

<math display="inline" id="Zemor's_decoding_algorithm:41">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>


, consider a linear subcode 

<math display="inline" id="Zemor's_decoding_algorithm:42">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>o</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>o</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{o}
  </annotation>
 </semantics>
</math>

, which is a 

<math display="inline" id="Zemor's_decoding_algorithm:43">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>d</mi>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>r</mi>
     <mi>o</mi>
    </msub>
    <mi>d</mi>
   </mrow>
   <mo>,</mo>
   <mi>δ</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>d</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>o</ci>
     </apply>
     <ci>d</ci>
    </apply>
    <ci>δ</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [d,r_{o}d,\delta]
  </annotation>
 </semantics>
</math>

 code, where 

<math display="inline" id="Zemor's_decoding_algorithm:44">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

, the size of the alphabet is 

<math display="inline" id="Zemor's_decoding_algorithm:45">
 <semantics>
  <mn>2</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">2</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2
  </annotation>
 </semantics>
</math>

. For any vertex 

<math display="inline" id="Zemor's_decoding_algorithm:46">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in V
  </annotation>
 </semantics>
</math>


, let 

<math display="inline" id="Zemor's_decoding_algorithm:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>d</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>v</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>d</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(1),v(2),\ldots,v(d)
  </annotation>
 </semantics>
</math>

 be some ordering of the 

<math display="inline" id="Zemor's_decoding_algorithm:48">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 vertices of 

<math display="inline" id="Zemor's_decoding_algorithm:49">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 adjacent to 

<math display="inline" id="Zemor's_decoding_algorithm:50">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

. In this code, each bit 

<math display="inline" id="Zemor's_decoding_algorithm:51">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{e}
  </annotation>
 </semantics>
</math>


 is linked with an edge 

<math display="inline" id="Zemor's_decoding_algorithm:52">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Zemor's_decoding_algorithm:53">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

.</p>

<p>We can define the code 

<math display="inline" id="Zemor's_decoding_algorithm:54">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 to be the set of binary vectors 

<math display="inline" id="Zemor's_decoding_algorithm:55">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>N</mi>
    </msub>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>N</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=\left(x_{1},x_{2},\ldots,x_{N}\right)
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Zemor's_decoding_algorithm:56">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
   <mi>N</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{0,1\}^{N}
  </annotation>
 </semantics>
</math>


 such that, for every vertex 

<math display="inline" id="Zemor's_decoding_algorithm:57">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Zemor's_decoding_algorithm:58">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Zemor's_decoding_algorithm:59">
 <semantics>
  <mrow>
   <mo>(</mo>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>v</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>v</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>v</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>d</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>v</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>v</ci>
      <ci>d</ci>
     </apply>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(x_{v(1)},x_{v(2)},\ldots,x_{v(d)}\right)
  </annotation>
 </semantics>
</math>

 is a code word of 

<math display="inline" id="Zemor's_decoding_algorithm:60">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>o</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>o</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{o}
  </annotation>
 </semantics>
</math>

. In this case, we can consider a special case when every vertex of 

<math display="inline" id="Zemor's_decoding_algorithm:61">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>


 is adjacent to exactly 

<math display="inline" id="Zemor's_decoding_algorithm:62">
 <semantics>
  <mn>2</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">2</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2
  </annotation>
 </semantics>
</math>

 vertices of 

<math display="inline" id="Zemor's_decoding_algorithm:63">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

. It means that 

<math display="inline" id="Zemor's_decoding_algorithm:64">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Zemor's_decoding_algorithm:65">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 make up, respectively, the vertex set and edge set of 

<math display="inline" id="Zemor's_decoding_algorithm:66">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>


 regular graph 

<math display="inline" id="Zemor's_decoding_algorithm:67">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

.</p>

<p>Let us call the code 

<math display="inline" id="Zemor's_decoding_algorithm:68">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 constructed in this way as 

<math display="inline" id="Zemor's_decoding_algorithm:69">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mi>G</mi>
   <mo>,</mo>
   <msub>
    <mi>C</mi>
    <mi>o</mi>
   </msub>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>o</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(G,C_{o}\right)
  </annotation>
 </semantics>
</math>

 code. For a given graph 

<math display="inline" id="Zemor's_decoding_algorithm:70">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 and a given code 

<math display="inline" id="Zemor's_decoding_algorithm:71">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>o</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>o</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{o}
  </annotation>
 </semantics>
</math>


, there are several 

<math display="inline" id="Zemor's_decoding_algorithm:72">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mi>G</mi>
   <mo>,</mo>
   <msub>
    <mi>C</mi>
    <mi>o</mi>
   </msub>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>G</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>o</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(G,C_{o}\right)
  </annotation>
 </semantics>
</math>

 codes as there are different ways of ordering edges incident to a given vertex 

<math display="inline" id="Zemor's_decoding_algorithm:73">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

, i.e., 

<math display="inline" id="Zemor's_decoding_algorithm:74">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>d</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>v</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>d</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(1),v(2),\ldots,v(d)
  </annotation>
 </semantics>
</math>

. In fact our code 

<math display="inline" id="Zemor's_decoding_algorithm:75">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 consist of all codewords such that 

<math display="inline" id="Zemor's_decoding_algorithm:76">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>v</mi>
   </msub>
   <mo>∈</mo>
   <msub>
    <mi>C</mi>
    <mi>o</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>o</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{v}\in C_{o}
  </annotation>
 </semantics>
</math>


 for all 

<math display="inline" id="Zemor's_decoding_algorithm:77">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mrow>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <list>
     <ci>A</ci>
     <ci>B</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in A,B
  </annotation>
 </semantics>
</math>

. The code 

<math display="inline" id="Zemor's_decoding_algorithm:78">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is linear 

<math display="inline" id="Zemor's_decoding_algorithm:79">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>N</mi>
   <mo>,</mo>
   <mi>K</mi>
   <mo>,</mo>
   <mi>D</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>N</ci>
    <ci>K</ci>
    <ci>D</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [N,K,D]
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Zemor's_decoding_algorithm:80">
 <semantics>
  <mi>𝔽</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔽</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{F}
  </annotation>
 </semantics>
</math>

 as it is generated from a subcode 

<math display="inline" id="Zemor's_decoding_algorithm:81">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>o</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>o</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{o}
  </annotation>
 </semantics>
</math>


, which is linear. The code 

<math display="inline" id="Zemor's_decoding_algorithm:82">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is defined as 

<math display="inline" id="Zemor's_decoding_algorithm:83">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>c</mi>
     <mo>∈</mo>
     <msup>
      <mi>𝔽</mi>
      <mi>N</mi>
     </msup>
    </mrow>
    <mo>:</mo>
    <mrow>
     <msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>v</mi>
     </msub>
     <mo>∈</mo>
     <msub>
      <mi>C</mi>
      <mi>o</mi>
     </msub>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>c</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝔽</ci>
       <ci>N</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>v</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>o</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=\{c\in\mathbb{F}^{N}:(c)_{v}\in C_{o}\}
  </annotation>
 </semantics>
</math>

 for every 

<math display="inline" id="Zemor's_decoding_algorithm:84">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in V
  </annotation>
 </semantics>
</math>

.</p>

<p><a href="File:Zemor_Decoding.jpg" title="wikilink">thumb|upright=2.0|alt=A |Graph G and code C</a></p>

<p>In this figure, 

<math display="inline" id="Zemor's_decoding_algorithm:85">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>v</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>e</mi>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>e</mi>
      <mn>2</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>e</mi>
      <mn>3</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>e</mi>
      <mn>4</mn>
     </mrow>
    </msub>
    <mo>)</mo>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi>C</mi>
    <mi>o</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>v</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>e</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>e</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>e</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>e</ci>
        <cn type="integer">4</cn>
       </apply>
      </apply>
     </vector>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>o</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x)_{v}=\left(x_{e1},x_{e2},x_{e3},x_{e4}\right)\in C_{o}
  </annotation>
 </semantics>
</math>

. It shows the graph 

<math display="inline" id="Zemor's_decoding_algorithm:86">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>


 and code 

<math display="inline" id="Zemor's_decoding_algorithm:87">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

.</p>

<p>In matrix 

<math display="inline" id="Zemor's_decoding_algorithm:88">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, let 

<math display="inline" id="Zemor's_decoding_algorithm:89">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 is equal to the second largest <a href="eigen_value" title="wikilink">eigen value</a> of <a href="adjacency_matrix" title="wikilink">adjacency matrix</a> of 

<math display="inline" id="Zemor's_decoding_algorithm:90">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

. Here the largest eigen value is 

<math display="inline" id="Zemor's_decoding_algorithm:91">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>


. Two important claims are made:</p>
<h3 id="claim-1">Claim 1</h3>

<p><strong>

<math display="inline" id="Zemor's_decoding_algorithm:92">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mstyle displaystyle="true">
     <mfrac>
      <mi>K</mi>
      <mi>N</mi>
     </mfrac>
    </mstyle>
    <mo>)</mo>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <msub>
      <mi>r</mi>
      <mi>o</mi>
     </msub>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <divide></divide>
     <ci>K</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>o</ci>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\dfrac{K}{N}\right)\geq 2r_{o}-1
  </annotation>
 </semantics>
</math>

</strong><br/>
<em>. Let 

<math display="inline" id="Zemor's_decoding_algorithm:93">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 be the rate of a linear code constructed from a bipartite graph whose digit nodes have degree 

<math display="inline" id="Zemor's_decoding_algorithm:94">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 and whose subcode nodes have degree 

<math display="inline" id="Zemor's_decoding_algorithm:95">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. If a single linear code with parameters 

<math display="inline" id="Zemor's_decoding_algorithm:96">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mi>n</mi>
   <mo>,</mo>
   <mi>k</mi>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>n</ci>
    <ci>k</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(n,k\right)
  </annotation>
 </semantics>
</math>


 and rate 

<math display="inline" id="Zemor's_decoding_algorithm:97">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mstyle displaystyle="true">
     <mfrac>
      <mi>k</mi>
      <mi>n</mi>
     </mfrac>
    </mstyle>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <apply>
     <divide></divide>
     <ci>k</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=\left(\dfrac{k}{n}\right)
  </annotation>
 </semantics>
</math>

 is associated with each of the subcode nodes, then 

<math display="inline" id="Zemor's_decoding_algorithm:98">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>≥</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>r</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mi>m</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>k</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>r</ci>
      </apply>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\geq 1-\left(1-r\right)m
  </annotation>
 </semantics>
</math>

</em>.</p>
<h4 id="proof">Proof</h4>

<p>Let 

<math display="inline" id="Zemor's_decoding_algorithm:99">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 be the rate of the linear code, which is equal to 

<math display="inline" id="Zemor's_decoding_algorithm:100">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>/</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>K</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K/N
  </annotation>
 </semantics>
</math>

 Let there are 

<math display="inline" id="Zemor's_decoding_algorithm:101">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>


 subcode nodes in the graph. If the degree of the subcode is 

<math display="inline" id="Zemor's_decoding_algorithm:102">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, then the code must have 

<math display="inline" id="Zemor's_decoding_algorithm:103">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mstyle displaystyle="true">
     <mfrac>
      <mi>n</mi>
      <mi>m</mi>
     </mfrac>
    </mstyle>
    <mo>)</mo>
   </mrow>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <ci>m</ci>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\dfrac{n}{m}\right)S
  </annotation>
 </semantics>
</math>

 digits, as each digit node is connected to 

<math display="inline" id="Zemor's_decoding_algorithm:104">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 of the 

<math display="inline" id="Zemor's_decoding_algorithm:105">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mi>n</mi>
    <mo>)</mo>
   </mrow>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(n\right)S
  </annotation>
 </semantics>
</math>

 edges in the graph. Each subcode node contributes 

<math display="inline" id="Zemor's_decoding_algorithm:106">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mi>k</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n-k)
  </annotation>
 </semantics>
</math>


 equations to parity check matrix for a total of 

<math display="inline" id="Zemor's_decoding_algorithm:107">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mi>k</mi>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <ci>k</ci>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(n-k\right)S
  </annotation>
 </semantics>
</math>

. These equations may not be linearly independent. Therefore, 

<math display="inline" id="Zemor's_decoding_algorithm:108">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mstyle displaystyle="true">
     <mfrac>
      <mi>K</mi>
      <mi>N</mi>
     </mfrac>
    </mstyle>
    <mo>)</mo>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mo>(</mo>
    <mstyle displaystyle="true">
     <mfrac>
      <mrow>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mstyle displaystyle="true">
          <mfrac>
           <mi>n</mi>
           <mi>m</mi>
          </mfrac>
         </mstyle>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>S</mi>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mi>k</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>S</mi>
       </mrow>
      </mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mstyle displaystyle="true">
         <mfrac>
          <mi>n</mi>
          <mi>m</mi>
         </mfrac>
        </mstyle>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>S</mi>
      </mrow>
     </mfrac>
    </mstyle>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <divide></divide>
     <ci>K</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>n</ci>
        <ci>m</ci>
       </apply>
       <ci>S</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <ci>m</ci>
      </apply>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\dfrac{K}{N}\right)\geq\left(\dfrac{(\dfrac{n}{m})S-(n-k)S}{(\dfrac{n}{m%
})S}\right)
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Zemor's_decoding_algorithm:109">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≥</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mi>m</mi>
     <mrow>
      <mo>(</mo>
      <mstyle displaystyle="true">
       <mfrac>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mi>k</mi>
        </mrow>
        <mi>n</mi>
       </mfrac>
      </mstyle>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>m</ci>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \geq 1-m\left(\dfrac{n-k}{n}\right)
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Zemor's_decoding_algorithm:110">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≥</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mi>m</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>r</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>m</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>r</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \geq 1-m\left(1-r\right)
  </annotation>
 </semantics>
</math>

, Since the value of 

<math display="inline" id="Zemor's_decoding_algorithm:111">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>


,i.e., the digit node of this bipartite graph is 

<math display="inline" id="Zemor's_decoding_algorithm:112">
 <semantics>
  <mn>2</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">2</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2
  </annotation>
 </semantics>
</math>

 and here 

<math display="inline" id="Zemor's_decoding_algorithm:113">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <msub>
    <mi>r</mi>
    <mi>o</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>o</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=r_{o}
  </annotation>
 </semantics>
</math>

, we can write as:<br/>


<math display="inline" id="Zemor's_decoding_algorithm:114">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mstyle displaystyle="true">
     <mfrac>
      <mi>K</mi>
      <mi>N</mi>
     </mfrac>
    </mstyle>
    <mo>)</mo>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <msub>
      <mi>r</mi>
      <mi>o</mi>
     </msub>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <divide></divide>
     <ci>K</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>o</ci>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\dfrac{K}{N}\right)\geq 2r_{o}-1
  </annotation>
 </semantics>
</math>

</p>
<h3 id="claim-2">Claim 2</h3>

<p>

<math display="block" id="Zemor's_decoding_algorithm:115">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>≥</mo>
   <mi>N</mi>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>δ</mi>
       <mo>-</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mstyle displaystyle="true">
         <mfrac>
          <mi>λ</mi>
          <mi>d</mi>
         </mfrac>
        </mstyle>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mstyle displaystyle="true">
        <mfrac>
         <mi>λ</mi>
         <mi>d</mi>
        </mfrac>
       </mstyle>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>)</mo>
   <msup>
    <mi></mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <geq></geq>
    <csymbol cd="unknown">N</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>δ</ci>
       <apply>
        <divide></divide>
        <ci>λ</ci>
        <ci>d</ci>
       </apply>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <cn type="integer">1</cn>
       <minus></minus>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <divide></divide>
         <ci>λ</ci>
         <ci>d</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
    <apply>
     <cn type="integer">2</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D\geq N\left(\dfrac{(\delta-(\dfrac{\lambda}{d}))}{(1-(\dfrac{\lambda}{d})})%
\right)^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Zemor's_decoding_algorithm:116">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mi>N</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msup>
       <mi>δ</mi>
       <mn>2</mn>
      </msup>
      <mo>-</mo>
      <mrow>
       <mi>O</mi>
       <mrow>
        <mo>(</mo>
        <mfrac>
         <mi>λ</mi>
         <mi>d</mi>
        </mfrac>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <ci>N</ci>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>δ</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <ci>O</ci>
       <apply>
        <divide></divide>
        <ci>λ</ci>
        <ci>d</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =N\left(\delta^{2}-O\left(\dfrac{\lambda}{d}\right)\right)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Zemor's_decoding_algorithm:117">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <csymbol cd="latexml">absent</csymbol>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow(1)
  </annotation>
 </semantics>
</math>

</p>

<p>''If 

<math display="inline" id="Zemor's_decoding_algorithm:118">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is linear code of rate 

<math display="inline" id="Zemor's_decoding_algorithm:119">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

, block code length 

<math display="inline" id="Zemor's_decoding_algorithm:120">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

, and minimum relative distance 

<math display="inline" id="Zemor's_decoding_algorithm:121">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>


, and if 

<math display="inline" id="Zemor's_decoding_algorithm:122">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is the edge vertex incidence graph of a 

<math display="inline" id="Zemor's_decoding_algorithm:123">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 – regular graph with second largest eigen value 

<math display="inline" id="Zemor's_decoding_algorithm:124">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

, then the code 

<math display="inline" id="Zemor's_decoding_algorithm:125">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>,</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <interval closure="open">
     <ci>B</ci>
     <ci>S</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(B,S)
  </annotation>
 </semantics>
</math>

 has rate at least 

<math display="inline" id="Zemor's_decoding_algorithm:126">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <msub>
     <mi>r</mi>
     <mi>o</mi>
    </msub>
   </mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>o</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2r_{o}-1
  </annotation>
 </semantics>
</math>


 and minimum relative distance at least 

<math display="inline" id="Zemor's_decoding_algorithm:127">
 <semantics>
  <msup>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>(</mo>
     <mstyle displaystyle="true">
      <mfrac>
       <mrow>
        <mi>δ</mi>
        <mo>-</mo>
        <mrow>
         <mo>(</mo>
         <mstyle displaystyle="true">
          <mfrac>
           <mi>λ</mi>
           <mi>d</mi>
          </mfrac>
         </mstyle>
         <mo>)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <mo>(</mo>
         <mstyle displaystyle="true">
          <mfrac>
           <mi>λ</mi>
           <mi>d</mi>
          </mfrac>
         </mstyle>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mfrac>
     </mstyle>
     <mo>)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <ci>δ</ci>
      <apply>
       <divide></divide>
       <ci>λ</ci>
       <ci>d</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <divide></divide>
       <ci>λ</ci>
       <ci>d</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\left(\dfrac{\delta-\left(\dfrac{\lambda}{d}\right)}{1-\left(\dfrac{%
\lambda}{d}\right)}\right)\right)^{2}
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="proof-1">Proof</h4>

<p>Let 

<math display="inline" id="Zemor's_decoding_algorithm:128">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 be derived from the 

<math display="inline" id="Zemor's_decoding_algorithm:129">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 regular graph 

<math display="inline" id="Zemor's_decoding_algorithm:130">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

. So, the number of variables of 

<math display="inline" id="Zemor's_decoding_algorithm:131">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>,</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <interval closure="open">
     <ci>B</ci>
     <ci>S</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(B,S)
  </annotation>
 </semantics>
</math>


 is 

<math display="inline" id="Zemor's_decoding_algorithm:132">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mi>d</mi>
      <mi>n</mi>
     </mrow>
     <mn>2</mn>
    </mfrac>
   </mstyle>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>n</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\dfrac{dn}{2}\right)
  </annotation>
 </semantics>
</math>

 and the number of constraints is 

<math display="inline" id="Zemor's_decoding_algorithm:133">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. According to Alon - Chung,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> if 

<math display="inline" id="Zemor's_decoding_algorithm:134">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is a subset of vertices of 

<math display="inline" id="Zemor's_decoding_algorithm:135">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 of size 

<math display="inline" id="Zemor's_decoding_algorithm:136">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>γ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma n
  </annotation>
 </semantics>
</math>


, then the number of edges contained in the subgraph is induced by 

<math display="inline" id="Zemor's_decoding_algorithm:137">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Zemor's_decoding_algorithm:138">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is at most 

<math display="inline" id="Zemor's_decoding_algorithm:139">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mstyle displaystyle="true">
     <mfrac>
      <mrow>
       <mi>d</mi>
       <mi>n</mi>
      </mrow>
      <mn>2</mn>
     </mfrac>
    </mstyle>
    <mo>)</mo>
   </mrow>
   <mrow>
    <mo>(</mo>
    <mrow>
     <msup>
      <mi>γ</mi>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mstyle displaystyle="true">
        <mfrac>
         <mi>λ</mi>
         <mi>d</mi>
        </mfrac>
       </mstyle>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>γ</mi>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>γ</mi>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>n</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>γ</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>λ</ci>
       <ci>d</ci>
      </apply>
      <ci>γ</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>γ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\dfrac{dn}{2}\right)\left(\gamma^{2}+(\dfrac{\lambda}{d})\gamma\left(1-%
\gamma\right)\right)
  </annotation>
 </semantics>
</math>

.</p>

<p>As a result, any set of 

<math display="inline" id="Zemor's_decoding_algorithm:140">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mstyle displaystyle="true">
     <mfrac>
      <mrow>
       <mi>d</mi>
       <mi>n</mi>
      </mrow>
      <mn>2</mn>
     </mfrac>
    </mstyle>
    <mo>)</mo>
   </mrow>
   <mrow>
    <mo>(</mo>
    <mrow>
     <msup>
      <mi>γ</mi>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo>(</mo>
       <mstyle displaystyle="true">
        <mfrac>
         <mi>λ</mi>
         <mi>d</mi>
        </mfrac>
       </mstyle>
       <mo>)</mo>
      </mrow>
      <mi>γ</mi>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>γ</mi>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>n</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>γ</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>λ</ci>
       <ci>d</ci>
      </apply>
      <ci>γ</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>γ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\dfrac{dn}{2}\right)\left(\gamma^{2}+\left(\dfrac{\lambda}{d}\right)%
\gamma\left(1-\gamma\right)\right)
  </annotation>
 </semantics>
</math>

 variables will be having at least 

<math display="inline" id="Zemor's_decoding_algorithm:141">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>γ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma n
  </annotation>
 </semantics>
</math>


 constraints as neighbours. So the average number of variables per constraint is 

<math display="block" id="Zemor's_decoding_algorithm:142">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mstyle displaystyle="true">
       <mfrac>
        <mrow>
         <mn>2</mn>
         <mi>n</mi>
         <mi>d</mi>
        </mrow>
        <mn>2</mn>
       </mfrac>
      </mstyle>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mi>γ</mi>
        <mn>2</mn>
       </msup>
       <mo>+</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mstyle displaystyle="true">
          <mfrac>
           <mi>λ</mi>
           <mi>d</mi>
          </mfrac>
         </mstyle>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>γ</mi>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mi>γ</mi>
         </mrow>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>γ</mi>
     <mi>n</mi>
    </mrow>
   </mfrac>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>n</ci>
       <ci>d</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>γ</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>λ</ci>
        <ci>d</ci>
       </apply>
       <ci>γ</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>γ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>γ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\dfrac{(\dfrac{2nd}{2})\left(\gamma^{2}+(\dfrac{\lambda}{d})\gamma\left(%
1-\gamma\right)\right)}{\gamma n}\right)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Zemor's_decoding_algorithm:143">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>γ</mi>
      <mo>+</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mstyle displaystyle="true">
         <mfrac>
          <mi>λ</mi>
          <mi>d</mi>
         </mfrac>
        </mstyle>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mi>γ</mi>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <ci>d</ci>
     <apply>
      <plus></plus>
      <ci>γ</ci>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>λ</ci>
        <ci>d</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>γ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =d\left(\gamma+(\dfrac{\lambda}{d})\left(1-\gamma\right)\right)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Zemor's_decoding_algorithm:144">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <csymbol cd="latexml">absent</csymbol>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow(2)
  </annotation>
 </semantics>
</math>

</p>

<p>So if 

<math display="inline" id="Zemor's_decoding_algorithm:145">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>γ</mi>
      <mo>+</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mstyle displaystyle="true">
         <mfrac>
          <mi>λ</mi>
          <mi>d</mi>
         </mfrac>
        </mstyle>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mi>γ</mi>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mi>γ</mi>
    <mi>d</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>d</ci>
     <apply>
      <plus></plus>
      <ci>γ</ci>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>λ</ci>
        <ci>d</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>γ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>γ</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\left(\gamma+(\dfrac{\lambda}{d})\left(1-\gamma\right)\right)<\gamma d
  </annotation>
 </semantics>
</math>

, then a word of relative weight 

<math display="inline" id="Zemor's_decoding_algorithm:146">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mrow>
    <msup>
     <mi>γ</mi>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mstyle displaystyle="true">
       <mfrac>
        <mi>λ</mi>
        <mi>d</mi>
       </mfrac>
      </mstyle>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>γ</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>γ</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>γ</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>λ</ci>
      <ci>d</ci>
     </apply>
     <ci>γ</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>γ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\gamma^{2}+(\dfrac{\lambda}{d})\gamma\left(1-\gamma\right)\right)
  </annotation>
 </semantics>
</math>


, cannot be a codeword of 

<math display="inline" id="Zemor's_decoding_algorithm:147">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>,</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <interval closure="open">
     <ci>B</ci>
     <ci>S</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(B,S)
  </annotation>
 </semantics>
</math>

. The inequality 

<math display="inline" id="Zemor's_decoding_algorithm:148">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>2</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">2</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (2)
  </annotation>
 </semantics>
</math>

 is satisfied for 

<math display="inline" id="Zemor's_decoding_algorithm:149">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo><</mo>
   <mrow>
    <mo>(</mo>
    <mstyle displaystyle="true">
     <mfrac>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mstyle displaystyle="true">
         <mfrac>
          <mi>λ</mi>
          <mi>d</mi>
         </mfrac>
        </mstyle>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>δ</mi>
       <mo>-</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mstyle displaystyle="true">
         <mfrac>
          <mi>λ</mi>
          <mi>d</mi>
         </mfrac>
        </mstyle>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mstyle>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>γ</ci>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <divide></divide>
       <ci>λ</ci>
       <ci>d</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>δ</ci>
      <apply>
       <divide></divide>
       <ci>λ</ci>
       <ci>d</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma<\left(\dfrac{1-(\dfrac{\lambda}{d})}{\delta-(\dfrac{\lambda}{d})}\right)
  </annotation>
 </semantics>
</math>

. Therefore, 

<math display="inline" id="Zemor's_decoding_algorithm:150">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>,</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <interval closure="open">
     <ci>B</ci>
     <ci>S</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(B,S)
  </annotation>
 </semantics>
</math>

 cannot have a non zero codeword of relative weight 

<math display="inline" id="Zemor's_decoding_algorithm:151">
 <semantics>
  <msup>
   <mrow>
    <mo>(</mo>
    <mstyle displaystyle="true">
     <mfrac>
      <mrow>
       <mi>δ</mi>
       <mo>-</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mstyle displaystyle="true">
         <mfrac>
          <mi>λ</mi>
          <mi>d</mi>
         </mfrac>
        </mstyle>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mstyle displaystyle="true">
         <mfrac>
          <mi>λ</mi>
          <mi>d</mi>
         </mfrac>
        </mstyle>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mstyle>
    <mo>)</mo>
   </mrow>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <ci>δ</ci>
      <apply>
       <divide></divide>
       <ci>λ</ci>
       <ci>d</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <divide></divide>
       <ci>λ</ci>
       <ci>d</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\dfrac{\delta-(\dfrac{\lambda}{d})}{1-(\dfrac{\lambda}{d})}\right)^{2}
  </annotation>
 </semantics>
</math>


 or less.</p>

<p>In matrix 

<math display="inline" id="Zemor's_decoding_algorithm:152">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, we can assume that 

<math display="inline" id="Zemor's_decoding_algorithm:153">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>/</mo>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>λ</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda/d
  </annotation>
 </semantics>
</math>

 is bounded away from 

<math display="inline" id="Zemor's_decoding_algorithm:154">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

. For those values of 

<math display="inline" id="Zemor's_decoding_algorithm:155">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 in which 

<math display="inline" id="Zemor's_decoding_algorithm:156">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>d</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d-1
  </annotation>
 </semantics>
</math>


 is odd prime, there are explicit constructions of sequences of 

<math display="inline" id="Zemor's_decoding_algorithm:157">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 - regular bipartite graphs with arbitrarily large number of vertices such that each graph 

<math display="inline" id="Zemor's_decoding_algorithm:158">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 in the sequence is a <a href="Ramanujan_graph" title="wikilink">Ramanujan graph</a>. It is called Ramanujan graph as it satisfies the inequality 

<math display="inline" id="Zemor's_decoding_algorithm:159">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mn>2</mn>
    <msqrt>
     <mrow>
      <mi>d</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>G</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <root></root>
      <apply>
       <minus></minus>
       <ci>d</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda(G)\leq 2\sqrt{d-1}
  </annotation>
 </semantics>
</math>

. Certain expansion properties are visible in graph 

<math display="inline" id="Zemor's_decoding_algorithm:160">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 as the separation between the eigen values 

<math display="inline" id="Zemor's_decoding_algorithm:161">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Zemor's_decoding_algorithm:162">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

. If the graph 

<math display="inline" id="Zemor's_decoding_algorithm:163">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is Ramanujan graph, then that expression 

<math display="inline" id="Zemor's_decoding_algorithm:164">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1)
  </annotation>
 </semantics>
</math>

 will become 

<math display="inline" id="Zemor's_decoding_algorithm:165">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 eventually as 

<math display="inline" id="Zemor's_decoding_algorithm:166">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>


 becomes large.</p>
<h2 id="zemors-algorithm">Zemor's algorithm</h2>

<p>The iterative decoding algorithm written below alternates between the vertices 

<math display="inline" id="Zemor's_decoding_algorithm:167">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Zemor's_decoding_algorithm:168">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Zemor's_decoding_algorithm:169">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 and corrects the codeword of 

<math display="inline" id="Zemor's_decoding_algorithm:170">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>o</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>o</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{o}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Zemor's_decoding_algorithm:171">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>


 and then it switches to correct the codeword 

<math display="inline" id="Zemor's_decoding_algorithm:172">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>o</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>o</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{o}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Zemor's_decoding_algorithm:173">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

. Here edges associated with a vertex on one side of a graph are not incident to other vertex on that side. In fact, it doesn't matter in which order, the set of nodes 

<math display="inline" id="Zemor's_decoding_algorithm:174">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Zemor's_decoding_algorithm:175">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 are processed. The vertex processing can also be done in parallel.</p>

<p>The decoder 

<math display="inline" id="Zemor's_decoding_algorithm:176">
 <semantics>
  <mrow>
   <mi>𝔻</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>𝔽</mi>
     <mi>d</mi>
    </msup>
    <mo>→</mo>
    <msub>
     <mi>C</mi>
     <mi>o</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>𝔻</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝔽</ci>
      <ci>d</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>o</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{D}:\mathbb{F}^{d}\rightarrow C_{o}
  </annotation>
 </semantics>
</math>


stands for a decoder for 

<math display="inline" id="Zemor's_decoding_algorithm:177">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>o</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>o</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{o}
  </annotation>
 </semantics>
</math>

 that recovers correctly with any codewords with less than 

<math display="inline" id="Zemor's_decoding_algorithm:178">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mstyle displaystyle="true">
    <mfrac>
     <mi>d</mi>
     <mn>2</mn>
    </mfrac>
   </mstyle>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>d</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\dfrac{d}{2}\right)
  </annotation>
 </semantics>
</math>

 errors.</p>
<h3 id="decoder-algorithm">Decoder algorithm</h3>

<p>Received word 

<math display="block" id="Zemor's_decoding_algorithm:179">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>w</mi>
      <mi>e</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>e</mi>
    <mo>∈</mo>
    <mi>E</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>w</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>e</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>e</ci>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w=(w_{e}),e\in E
  </annotation>
 </semantics>
</math>

<br/>
<code>
<math>z \leftarrow w</math><br>
For  <math>t \leftarrow 1</math> to <math>m</math> do         //<math>m</math> is the number of iterations<br>
{ if (<math>t</math> is odd)                                       // Here the algorithm will alternate between its two vertex sets.<br>
<math>X \leftarrow A</math><br>
else  <math>X \leftarrow B</math> <br>  
Iteration <math>t</math>: For every <math>v \in X</math>, let <math>(z)_v \leftarrow \mathbb{D}((z)_v)</math> // Decoding <math>z_v</math> to its nearest codeword.<br>
}<br>
</br></br></br></br></br></br></br></code> Output

<math display="block" id="Zemor's_decoding_algorithm:180">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

</p>
<h3 id="explanation-of-the-algorithm">Explanation of the algorithm</h3>

<p>Since 

<math display="inline" id="Zemor's_decoding_algorithm:181">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>


 is bipartite, the set 

<math display="inline" id="Zemor's_decoding_algorithm:182">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 of vertices induces the partition of the edge set 

<math display="inline" id="Zemor's_decoding_algorithm:183">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 = 

<math display="inline" id="Zemor's_decoding_algorithm:184">
 <semantics>
  <mrow>
   <msub>
    <mo>∪</mo>
    <mrow>
     <mi>v</mi>
     <mo>∈</mo>
     <mi>A</mi>
    </mrow>
   </msub>
   <msub>
    <mi>E</mi>
    <mi>v</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <union></union>
     <apply>
      <in></in>
      <ci>v</ci>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cup_{v\in A}E_{v}
  </annotation>
 </semantics>
</math>

 . The set 

<math display="inline" id="Zemor's_decoding_algorithm:185">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 induces another partition, 

<math display="inline" id="Zemor's_decoding_algorithm:186">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>


 = 

<math display="inline" id="Zemor's_decoding_algorithm:187">
 <semantics>
  <mrow>
   <msub>
    <mo>∪</mo>
    <mrow>
     <mi>v</mi>
     <mo>∈</mo>
     <mi>B</mi>
    </mrow>
   </msub>
   <msub>
    <mi>E</mi>
    <mi>v</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <union></union>
     <apply>
      <in></in>
      <ci>v</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cup_{v\in B}E_{v}
  </annotation>
 </semantics>
</math>

 .</p>

<p>Let 

<math display="inline" id="Zemor's_decoding_algorithm:188">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>w</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\in\{0,1\}^{N}
  </annotation>
 </semantics>
</math>

 be the received vector, and recall that 

<math display="inline" id="Zemor's_decoding_algorithm:189">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mrow>
    <mi>d</mi>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=dn
  </annotation>
 </semantics>
</math>

. The first iteration of the algorithm consists of applying the complete decoding for the code induced by 

<math display="inline" id="Zemor's_decoding_algorithm:190">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>v</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{v}
  </annotation>
 </semantics>
</math>

 for every 

<math display="inline" id="Zemor's_decoding_algorithm:191">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in A
  </annotation>
 </semantics>
</math>


 . This means that for replacing, for every 

<math display="inline" id="Zemor's_decoding_algorithm:192">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in A
  </annotation>
 </semantics>
</math>

, the vector 

<math display="inline" id="Zemor's_decoding_algorithm:193">
 <semantics>
  <mrow>
   <mo>(</mo>
   <msub>
    <mi>w</mi>
    <mrow>
     <mi>v</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>w</mi>
    <mrow>
     <mi>v</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>w</mi>
    <mrow>
     <mi>v</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>d</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <apply>
      <times></times>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <apply>
      <times></times>
      <ci>v</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <apply>
      <times></times>
      <ci>v</ci>
      <ci>d</ci>
     </apply>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(w_{v(1)},w_{v(2)},\ldots,w_{v(d)}\right)
  </annotation>
 </semantics>
</math>

 by one of the closest codewords of 

<math display="inline" id="Zemor's_decoding_algorithm:194">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>o</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>o</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{o}
  </annotation>
 </semantics>
</math>

. Since the subsets of edges 

<math display="inline" id="Zemor's_decoding_algorithm:195">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>v</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{v}
  </annotation>
 </semantics>
</math>

 are disjoint for 

<math display="inline" id="Zemor's_decoding_algorithm:196">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in A
  </annotation>
 </semantics>
</math>


, the decoding of these 

<math display="inline" id="Zemor's_decoding_algorithm:197">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 subvectors of 

<math display="inline" id="Zemor's_decoding_algorithm:198">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 may be done in parallel.</p>

<p>The iteration will yield a new vector 

<math display="inline" id="Zemor's_decoding_algorithm:199">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

. The next iteration consists of applying the preceding procedure to 

<math display="inline" id="Zemor's_decoding_algorithm:200">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 but with 

<math display="inline" id="Zemor's_decoding_algorithm:201">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>


 replaced by 

<math display="inline" id="Zemor's_decoding_algorithm:202">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

. In other words, it consists of decoding all the subvectors induced by the vertices of 

<math display="inline" id="Zemor's_decoding_algorithm:203">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

. The coming iterations repeat those two steps alternately applying parallel decoding to the subvectors induced by the vertices of 

<math display="inline" id="Zemor's_decoding_algorithm:204">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and to the subvectors induced by the vertices of 

<math display="inline" id="Zemor's_decoding_algorithm:205">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

.<br/>
<strong>Note:</strong> [If 

<math display="inline" id="Zemor's_decoding_algorithm:206">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>d</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=n
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Zemor's_decoding_algorithm:207">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is the complete bipartite graph, then 

<math display="inline" id="Zemor's_decoding_algorithm:208">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is a product code of 

<math display="inline" id="Zemor's_decoding_algorithm:209">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>o</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>o</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{o}
  </annotation>
 </semantics>
</math>

 with itself and the above algorithm reduces to the natural hard iterative decoding of product codes].</p>

<p>Here, the number of iterations, 

<math display="inline" id="Zemor's_decoding_algorithm:210">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Zemor's_decoding_algorithm:211">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>2</mn>
        <mo>-</mo>
        <mi>α</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mstyle>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
    <apply>
     <log></log>
     <apply>
      <minus></minus>
      <cn type="integer">2</cn>
      <ci>α</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\dfrac{(\log{n})}{\log(2-\alpha)}\right)
  </annotation>
 </semantics>
</math>


. In general, the above algorithm can correct a code word whose Hamming weight is no more than 

<math display="inline" id="Zemor's_decoding_algorithm:212">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mstyle displaystyle="true">
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
    </mstyle>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mi>α</mi>
   <mi>N</mi>
   <mi>δ</mi>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mstyle displaystyle="true">
      <mfrac>
       <mi>δ</mi>
       <mn>2</mn>
      </mfrac>
     </mstyle>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mstyle displaystyle="true">
      <mfrac>
       <mi>λ</mi>
       <mi>d</mi>
      </mfrac>
     </mstyle>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mstyle displaystyle="true">
      <mfrac>
       <mn>1</mn>
       <mn>4</mn>
      </mfrac>
     </mstyle>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>.</mo>
    <mi>α</mi>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>δ</mi>
      <mn>2</mn>
     </msup>
     <mo>-</mo>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mstyle displaystyle="true">
       <mfrac>
        <mi>λ</mi>
        <mi>d</mi>
       </mfrac>
      </mstyle>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">α</csymbol>
    <csymbol cd="unknown">N</csymbol>
    <csymbol cd="unknown">δ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <divide></divide>
       <ci>δ</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <minus></minus>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <divide></divide>
       <ci>λ</ci>
       <ci>d</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">4</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-.</ci>
     <csymbol cd="unknown">α</csymbol>
     <csymbol cd="unknown">N</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>δ</ci>
       <cn type="integer">2</cn>
      </apply>
      <minus></minus>
      <csymbol cd="unknown">O</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <divide></divide>
        <ci>λ</ci>
        <ci>d</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\dfrac{1}{2}).\alpha N\delta\left((\dfrac{\delta}{2})-(\dfrac{\lambda}{d})%
\right)=\left((\dfrac{1}{4}).\alpha N(\delta^{2}-O(\dfrac{\lambda}{d})\right)
  </annotation>
 </semantics>
</math>

 for values of 

<math display="inline" id="Zemor's_decoding_algorithm:213">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo><</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>α</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha<1
  </annotation>
 </semantics>
</math>

. Here, the decoding algorithm is implemented as a circuit of size 

<math display="inline" id="Zemor's_decoding_algorithm:214">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mrow>
      <mi>log</mi>
      <mi>N</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <apply>
      <log></log>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(N\log{N})
  </annotation>
 </semantics>
</math>

 and depth 

<math display="inline" id="Zemor's_decoding_algorithm:215">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>N</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log{N})
  </annotation>
 </semantics>
</math>

 that returns the codeword given that error vector has weight less than 

<math display="inline" id="Zemor's_decoding_algorithm:216">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <mi>N</mi>
    <msup>
     <mi>δ</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>ϵ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>/</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>α</ci>
     <ci>N</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>δ</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>ϵ</ci>
     </apply>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha N\delta^{2}(1-\epsilon)/4
  </annotation>
 </semantics>
</math>


 .</p>
<h3 id="theorem">Theorem</h3>

<p><em>If 

<math display="inline" id="Zemor's_decoding_algorithm:217">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is a Ramanujan graph of sufficiently high degree, for any 

<math display="inline" id="Zemor's_decoding_algorithm:218">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo><</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>α</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha<1
  </annotation>
 </semantics>
</math>

, the decoding algorithm can correct 

<math display="inline" id="Zemor's_decoding_algorithm:219">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mstyle displaystyle="true">
     <mfrac>
      <mrow>
       <mi>α</mi>
       <msubsup>
        <mi>δ</mi>
        <mi>o</mi>
        <mn>2</mn>
       </msubsup>
      </mrow>
      <mn>4</mn>
     </mfrac>
    </mstyle>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>-</mo>
    <mo>∈</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>α</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>δ</ci>
         <ci>o</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">4</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <minus></minus>
     <in></in>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">N</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\dfrac{\alpha\delta_{o}^{2}}{4})(1-\in)N
  </annotation>
 </semantics>
</math>

 errors, in 

<math display="inline" id="Zemor's_decoding_algorithm:220">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log{n})
  </annotation>
 </semantics>
</math>

 rounds ( where the big- 

<math display="inline" id="Zemor's_decoding_algorithm:221">
 <semantics>
  <mi>O</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>O</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O
  </annotation>
 </semantics>
</math>


 notation hides a dependence on 

<math display="inline" id="Zemor's_decoding_algorithm:222">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

). This can be implemented in linear time on a single processor; on 

<math display="inline" id="Zemor's_decoding_algorithm:223">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 processors each round can be implemented in constant time.</em></p>
<h4 id="proof-2">Proof</h4>

<p>Since the decoding algorithm is insensitive to the value of the edges and by linearity, we can assume that the transmitted codeword is the all zeros - vector. Let the received codeword be 

<math display="inline" id="Zemor's_decoding_algorithm:224">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

. The set of edges which has an incorrect value while decoding is considered. Here by incorrect value, we mean 

<math display="inline" id="Zemor's_decoding_algorithm:225">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 in any of the bits. Let 

<math display="inline" id="Zemor's_decoding_algorithm:226">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>=</mo>
   <msup>
    <mi>w</mi>
    <mn>0</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>w</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>w</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w=w^{0}
  </annotation>
 </semantics>
</math>


 be the initial value of the codeword, 

<math display="inline" id="Zemor's_decoding_algorithm:227">
 <semantics>
  <mrow>
   <msup>
    <mi>w</mi>
    <mn>1</mn>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>w</mi>
    <mn>2</mn>
   </msup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mi>w</mi>
    <mi>t</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>w</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>w</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>w</ci>
     <ci>t</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{1},w^{2},\ldots,w^{t}
  </annotation>
 </semantics>
</math>

 be the values after first, second . . . 

<math display="inline" id="Zemor's_decoding_algorithm:228">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 stages of decoding. Here, 

<math display="inline" id="Zemor's_decoding_algorithm:229">
 <semantics>
  <mrow>
   <msup>
    <mi>X</mi>
    <mi>i</mi>
   </msup>
   <mo>=</mo>
   <mi>e</mi>
   <mo>∈</mo>
   <mi>E</mi>
   <mo stretchy="false">|</mo>
   <msubsup>
    <mi>x</mi>
    <mi>e</mi>
    <mi>i</mi>
   </msubsup>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">e</csymbol>
    <in></in>
    <csymbol cd="unknown">E</csymbol>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>e</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{i}={e\in E|x_{e}^{i}=1}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Zemor's_decoding_algorithm:230">
 <semantics>
  <mrow>
   <msup>
    <mi>S</mi>
    <mi>i</mi>
   </msup>
   <mo>=</mo>
   <mi>v</mi>
   <mo>∈</mo>
   <msup>
    <mi>V</mi>
    <mi>i</mi>
   </msup>
   <mo stretchy="false">|</mo>
   <msub>
    <mi>E</mi>
    <mi>v</mi>
   </msub>
   <mo>∩</mo>
   <msup>
    <mi>X</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mo>=</mo>
   <mi mathvariant="normal">∅</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">v</csymbol>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>v</ci>
    </apply>
    <intersect></intersect>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <factorial></factorial>
    <eq></eq>
    <emptyset></emptyset>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{i}={v\in V^{i}|E_{v}\cap X^{i+1}!=\emptyset}
  </annotation>
 </semantics>
</math>

. Here 

<math display="inline" id="Zemor's_decoding_algorithm:231">
 <semantics>
  <msup>
   <mi>S</mi>
   <mi>i</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>S</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{i}
  </annotation>
 </semantics>
</math>


 corresponds to those set of vertices that was not able to successfully decode their codeword in the 

<math display="inline" id="Zemor's_decoding_algorithm:232">
 <semantics>
  <msup>
   <mi>i</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>i</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i^{th}
  </annotation>
 </semantics>
</math>

 round. From the above algorithm 

<math display="inline" id="Zemor's_decoding_algorithm:233">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>S</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mstyle displaystyle="true">
      <mfrac>
       <mn>1</mn>
       <mrow>
        <mn>2</mn>
        <mo>-</mo>
        <mi>α</mi>
       </mrow>
      </mfrac>
     </mstyle>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <msub>
      <mi>S</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
       <ci>α</ci>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |S_{i+1}|<=(\dfrac{1}{2-\alpha})|S_{i}|
  </annotation>
 </semantics>
</math>

is a decreasing sequence. In fact, 

<math display="inline" id="Zemor's_decoding_algorithm:234">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo><</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>α</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha<1
  </annotation>
 </semantics>
</math>

. As we are assuming, 

<math display="inline" id="Zemor's_decoding_algorithm:235">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <msub>
      <mi>S</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>n</mi>
    <mrow>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mstyle displaystyle="true">
       <mfrac>
        <mn>1</mn>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mn>2</mn>
           <mo>-</mo>
           <mi>α</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>i</mi>
        </msup>
       </mfrac>
      </mstyle>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <sum></sum>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <sum></sum>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <minus></minus>
          <cn type="integer">2</cn>
          <ci>α</ci>
         </apply>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum|S_{i}|=n\sum(\dfrac{1}{(2-\alpha)^{i}})=O(n)
  </annotation>
 </semantics>
</math>

, the above equation is in a <a href="geometric_series" title="wikilink">geometric decreasing sequence</a>. So, when 

<math display="inline" id="Zemor's_decoding_algorithm:236">
 <semantics>
  <msup>
   <mi>i</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>i</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i^{th}
  </annotation>
 </semantics>
</math>


 rounds are necessary. Furthermore, 

<math display="inline" id="Zemor's_decoding_algorithm:237">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <msub>
      <mi>S</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(|S_{i}|)
  </annotation>
 </semantics>
</math>

, and if we implement the 

<math display="inline" id="Zemor's_decoding_algorithm:238">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 round in 

<math display="inline" id="Zemor's_decoding_algorithm:239">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>2</mn>
        <mo>-</mo>
        <mi>α</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <apply>
     <divide></divide>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
     <apply>
      <log></log>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
       <ci>α</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [(\log{n})/(\log(2-\alpha))]
  </annotation>
 </semantics>
</math>

 time, then the total sequential running time will be linear.</p>
<h2 id="drawbacks-of-zemors-algorithm">Drawbacks of Zemor's algorithm</h2>
<ol>
<li>It is lengthy process as the number of iterations <span class="LaTeX">$m$</span> in decoder algorithm takes is <span class="LaTeX">$[(\log{ n})/(\log(2-\alpha))]$</span></li>
<li>Zemor's decoding algorithm finds it difficult to decode erasures. A detailed way of how we can improve the algorithm is</li>
</ol>

<p>given in.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Expander_code" title="wikilink">Expander codes</a></li>
<li><a href="Tanner_graph" title="wikilink">Tanner graph</a></li>
<li><a href="Linear_time_encoding_and_decoding_of_error-correcting_codes" title="wikilink">Linear time encoding and decoding of error-correcting codes</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Coding_theory" title="wikilink">Category:Coding theory</a> <a href="Category:Error_detection_and_correction" title="wikilink">Category:Error detection and correction</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.math.u-bordeaux1.fr/~zemor/">Gilles Zemor</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a class="uri" href="http://www.cs.washington.edu/education/courses/cse590vg/03wi/scribes/1-27.ps">http://www.cs.washington.edu/education/courses/cse590vg/03wi/scribes/1-27.ps</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a class="uri" href="http://www.cs.washington.edu/education/courses/cse533/06au/lecnotes/lecture14.pdf">http://www.cs.washington.edu/education/courses/cse533/06au/lecnotes/lecture14.pdf</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a class="uri" href="http://math.ucsd.edu/~fan/mypaps/fanpap/93tolerant.pdf">http://math.ucsd.edu/~fan/mypaps/fanpap/93tolerant.pdf</a><a href="#fnref4">↩</a></li>
<li id="fn5"><a class="uri" href="http://www.cs.technion.ac.il/~vitalys/Papers/GMD-expander/GMD-decode-expander.ps">http://www.cs.technion.ac.il/~vitalys/Papers/GMD-expander/GMD-decode-expander.ps</a><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
