<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="160">Graph rewriting</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Graph rewriting</h1>
<hr/>

<p><strong>Graph transformation</strong>, or <strong>graph rewriting</strong>, concerns the technique of creating a new <a href="graph_(mathematics)" title="wikilink">graph</a> out of an original graph algorithmically. It has numerous applications, ranging from <a href="software_engineering" title="wikilink">software engineering</a> (<a href="software_construction" title="wikilink">software construction</a> and also <a href="Formal_verification" title="wikilink">software verification</a>) to layout <a href="algorithm" title="wikilink">algorithms</a> and picture generation.</p>

<p>Graph transformations can be used as a computation abstraction. The basic idea is that the state of a computation can be represented as a graph, further steps in that computation can then be represented as transformation rules on that graph. Such rules consist of an original graph, which is to be matched to a subgraph in the complete state, and a replacing graph, which will replace the matched subgraph.</p>

<p>Formally, a <a href="graph_(mathematics)" title="wikilink">graph</a> <a class="uri" href="rewriting" title="wikilink">rewriting</a> system usually consists of a set of graph rewrite rules of the form 

<math display="inline" id="Graph_rewriting:0">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>→</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>L</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\rightarrow R
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Graph_rewriting:1">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 being called pattern graph (or left-hand side) and 

<math display="inline" id="Graph_rewriting:2">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 being called replacement graph (or right-hand side of the rule). A graph rewrite rule is applied to the host graph by searching for an occurrence of the pattern graph (<a href="pattern_matching" title="wikilink">pattern matching</a>, thus solving the <a href="subgraph_isomorphism_problem" title="wikilink">subgraph isomorphism problem</a>) and by replacing the found occurrence by an instance of the replacement graph. Rewrite rules can be further regulated in the case of <a href="labeled_graph" title="wikilink">labeled graphs</a>, such as in string-regulated graph grammars.</p>

<p>Sometimes <strong>graph grammar</strong> is used as a synonym for <strong>graph rewriting system</strong>, especially in the context of <a href="formal_language" title="wikilink">formal languages</a>; the different wording is used to emphasize the goal of constructions, like the enumeration of all graphs from some starting graph, i.e. the generation of a graph language – instead of simply transforming a given state (host graph) into a new state.</p>
<h2 id="graph-rewriting-approaches">Graph rewriting approaches</h2>
<h3 id="algebraic-approach">Algebraic approach</h3>

<p>The <strong>algebraic approach</strong> to graph rewriting is based upon <a href="category_theory" title="wikilink">category theory</a>. The algebraic approach is further divided into sub-approaches, the most common of which are the <strong><a href="Double_pushout_graph_rewriting" title="wikilink">double-pushout (DPO) approach</a></strong> and the <strong>single-pushout (SPO) approach</strong>. Other sub-approaches include the <em>sesqui-pushout</em> and the <em>pullback</em> approach''.</p>

<p>From the perspective of the DPO approach a graph rewriting rule is a pair of <a href="morphism" title="wikilink">morphisms</a> in the category of graphs with <em>total</em> <a href="graph_morphism" title="wikilink">graph morphisms</a> as arrows

<math display="block" id="Graph_rewriting:3">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>L</mi>
    <mo>←</mo>
    <mi>K</mi>
    <mo>→</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">L</csymbol>
     <ci>normal-←</ci>
     <csymbol cd="unknown">K</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=(L\leftarrow K\rightarrow R)
  </annotation>
 </semantics>
</math>

 (or 

<math display="inline" id="Graph_rewriting:4">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>⊇</mo>
   <mi>K</mi>
   <mo>⊆</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">superset-of-or-equals</csymbol>
     <ci>L</ci>
     <ci>K</ci>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\supseteq K\subseteq R
  </annotation>
 </semantics>
</math>

) where 

<math display="inline" id="Graph_rewriting:5">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>→</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>K</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\rightarrow L
  </annotation>
 </semantics>
</math>

 is <a class="uri" href="injective" title="wikilink">injective</a>. The graph K is called <em>invariant</em> or sometimes the <em>gluing graph</em>. A <strong><a class="uri" href="rewriting" title="wikilink">rewriting</a> step</strong> or <em>application</em> of a rule r to a <em>host graph</em> G is defined by two <a href="pushout_(category_theory)" title="wikilink">pushout</a> diagrams both originating in the same <a class="uri" href="morphism" title="wikilink">morphism</a> 

<math display="inline" id="Graph_rewriting:6">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>:</mo>
   <mrow>
    <mi>K</mi>
    <mo>→</mo>
    <mi>G</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>k</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>K</ci>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\colon K\rightarrow G
  </annotation>
 </semantics>
</math>

 (this is where the name <em>double</em>-pushout comes from). Another <a href="graph_morphism" title="wikilink">graph morphism</a> 

<math display="inline" id="Graph_rewriting:7">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>:</mo>
   <mrow>
    <mi>L</mi>
    <mo>→</mo>
    <mi>G</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>m</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>L</ci>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\colon L\rightarrow G
  </annotation>
 </semantics>
</math>

 models an occurrence of L in G and is called a <strong><a href="Pattern_matching" title="wikilink">match</a></strong>. Practical understanding of this is that 

<math display="inline" id="Graph_rewriting:8">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>


 is a subgraph that is matched from 

<math display="inline" id="Graph_rewriting:9">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 (see <a href="subgraph_isomorphism_problem" title="wikilink">subgraph isomorphism problem</a>), and after a match is found, 

<math display="inline" id="Graph_rewriting:10">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is replaced with 

<math display="inline" id="Graph_rewriting:11">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 in host graph 

<math display="inline" id="Graph_rewriting:12">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Graph_rewriting:13">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>


 serves as an interface, containing the nodes and edges which are preserved when applying the rule. The graph 

<math display="inline" id="Graph_rewriting:14">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 is needed to attach the pattern being matched to its context: if it is empty, the match can only designate a whole connected component of the graph 

<math display="inline" id="Graph_rewriting:15">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

.</p>

<p>In contrast a graph rewriting rule of the SPO approach is a single <a class="uri" href="morphism" title="wikilink">morphism</a> in the category <a href="labeled_multigraph" title="wikilink">labeled multigraphs</a> with <em>partial</em> <a href="graph_morphism" title="wikilink">graph morphisms</a> as arrows

<math display="block" id="Graph_rewriting:16">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>:</mo>
   <mrow>
    <mi>L</mi>
    <mo>→</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>r</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>L</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\colon L\rightarrow R
  </annotation>
 </semantics>
</math>

. Thus a rewriting step is defined by a single <a href="Pushout_(category_theory)" title="wikilink">pushout</a> diagram. Practical understanding of this is similar to the DPO approach. The difference is, that there is no interface between the host graph G and the graph G' being the result of the rewriting step.</p>

<p>There is also another algebraic-like approach to graph rewriting, based mainly on Boolean algebra and an algebra of matrices, called <strong>matrix graph grammars</strong>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h3 id="determinate-graph-rewriting">Determinate graph rewriting</h3>

<p>Yet another approach to graph rewriting, known as <em>determinate</em> graph rewriting, came out of <a class="uri" href="logic" title="wikilink">logic</a> and <a href="database_theory" title="wikilink">database theory</a>. In this approach, graphs are treated as database instances, and rewriting operations as a mechanism for defining queries and views; therefore, all rewriting is required to yield unique results (<a href="up_to_isomorphism" title="wikilink">up to isomorphism</a>), and this is achieved by applying any rewriting rule concurrently throughout the graph, wherever it applies, in such a way that the result is indeed uniquely defined.</p>
<h3 id="term-graph-rewriting">Term graph rewriting</h3>

<p>Another approach to graph rewriting is <a href="term_graph" title="wikilink">term graph</a> rewriting, which involves the processing or transformation of <a href="term_graph" title="wikilink">term graphs</a> (also known as <em>abstract semantic graphs</em>) by a set of syntactic rewrite rules.</p>

<p>Term graphs are a prominent topic in programming language research since term graph rewriting rules are capable of formally expressing a compiler's <a href="operational_semantics" title="wikilink">operational semantics</a>. Term graphs are also used as abstract machines capable of modelling chemical and biological computations as well as graphical calculi such as concurrency models. Term graphs can perform automated verification and logical programming since they are well-suited to representing quantified statements in first order logic. Symbolic programming software is another application for term graphs, which are capable of representing and performing computation with abstract algebraic structures such as groups, fields and rings.</p>

<p>The TERMGRAPH conference <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> focuses entirely on research into term graph rewriting and its applications.</p>
<h2 id="implementations-and-applications">Implementations and applications</h2>
<figure><b>(Figure)</b>
<figcaption>Example for graph rewrite rule (optimization from compiler construction: multiplication with 2 replaced by addition)</figcaption>
</figure>

<p>Graphs are an expressive, visual and mathematically precise formalism for modelling of objects (entities) linked by relations; objects are represented by nodes and relations between them by edges. Nodes and edges are commonly typed and attributed. Computations are described in this model by changes in the relations between the entities or by attribute changes of the graph elements. They are encoded in graph rewrite/graph transformation rules and executed by graph rewrite systems/graph transformation tools.</p>
<ul>
<li>Tools that are application domain neutral:
<ul>
<li><a href="GrGen" title="wikilink">GrGen.NET</a>, the graph rewrite generator, a graph transformation tool emitting <a href="C_Sharp_(programming_language)" title="wikilink">C#</a>-code or .NET-assemblies</li>
<li><a href="http://user.cs.tu-berlin.de/~gragra/agg">AGG</a>, the attributed graph grammar system (<a href="Java_(programming_language)" title="wikilink">Java</a>)</li>
<li><a href="http://www.cs.york.ac.uk/plasma/wiki/index.php?title=GP_%28Graph_Programs%29">GP (Graph Programs)</a> is a programming language for computing on graphs by the directed application of graph transformation rules.</li>
<li><a href="http://homepages.laas.fr/khalil/GMTE/">GMTE</a>, the Graph Matching and Transformation Engine for graph matching and transformation. It is an implementation of an extension of Messmer’s algorithm using <a class="uri" href="C++" title="wikilink">C++</a>.</li>
<li><a href="http://groove.cs.utwente.nl/">GROOVE</a>, a Java-based tool set for editing graphs and graph transformation rules, exploring the state spaces of graph grammars, and model checking those state spaces; can also be used as a graph transformation engine.</li>
</ul></li>
<li>Tools that solve <a href="software_engineering" title="wikilink">software engineering</a> tasks (mainly <a href="Model-driven_architecture" title="wikilink">MDA</a>) with graph rewriting:
<ul>
<li><a href="http://emoflon.org/">eMoflon</a>, an EMF-compliant model-transformation tool with support for <a href="Story-driven_modeling" title="wikilink">Story-Driven Modeling</a> and Triple Graph Grammars</li>
<li><a class="uri" href="GReAT" title="wikilink">GReAT</a></li>
<li><a class="uri" href="VIATRA" title="wikilink">VIATRA</a></li>
<li><a href="Graph_Database" title="wikilink">Graph databases</a> often support dynamic rewriting of graphs</li>
<li><a href="http://gremlin.tinkerpop.com">Gremlin</a>, a graph-based programming language (see <a href="http://github.com/tinkerpop/gremlin/wiki/Graph-Rewriting">Graph Rewriting</a>)</li>
<li><a href="http://www.se.rwth-aachen.de/tikiwiki/tiki-index.php%3Fpage=Research%3A+Progres.html">PROGRES</a>, an integrated environment and very high level language for PROgrammed Graph REwriting Systems</li>
<li><a href="http://www.fujaba.de/">Fujaba</a> uses Story driven modelling, a graph rewrite language based on PROGRES</li>
<li><a href="http://www.emorf.org">EMorF</a> and <a href="http://www.eclipse.org/modeling/emft/henshin">Henshin</a>, graph rewriting systems based on <a href="Eclipse_Modeling_Framework" title="wikilink">EMF</a>, supporting in-place <a href="model_transformation" title="wikilink">model transformation</a> and model to model transformation</li>
</ul></li>
<li>Mechanical engineering tools
<ul>
<li><a href="http://www.graphsynth.com">GraphSynth</a> is an interpreter and UI environment for creating unrestricted graph grammars as well as testing and searching the resultant language variant. It saves graphs and graph grammar rules as <a class="uri" href="XML" title="wikilink">XML</a> files and is written in <a href="C_Sharp_(programming_language)" title="wikilink">C#</a>.</li>
<li><a href="https://www.soley-technology.com/en/pr-soley-studio">Soley Studio</a>, is an <a href="integrated_development_environment" title="wikilink">integrated development environment</a> for graph transformation systems. Its main application focus is data analytics in the field of engineering.</li>
</ul></li>
<li>Biology applications
<ul>
<li><a href="http://opus.kobv.de/btu/volltexte/2009/593/pdf/thesis.pdf">Functional-structural plant modeling with a graph grammar based language</a></li>
<li><a href="http://dx.doi.org/10.1016/j.tcs.2011.07.004">Multicellular development modeling with string-regulated graph grammars</a></li>
</ul></li>
<li>Artificial Intelligence/Natural Language Processing
<ul>
<li><a class="uri" href="OpenCog" title="wikilink">OpenCog</a> provides a basic pattern matcher (on <a href="hypergraph" title="wikilink">hypergraphs</a>) which is used to implement various AI algorithms.</li>
<li><a href="http://wiki.opencog.org/w/RelEx">RelEx</a> is an English-language parser that employs graph re-writing to convert a <a href="link_grammar" title="wikilink">link parse</a> into a <a href="dependency_grammar" title="wikilink">dependency parse</a>.</li>
</ul></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Category_theory" title="wikilink">Category theory</a></li>
<li><a href="Graph_theory" title="wikilink">Graph theory</a></li>
<li><a href="Shape_grammar" title="wikilink">Shape grammar</a></li>
<li><a href="Formal_grammar" title="wikilink">Formal grammar</a></li>
<li><a href="Term_graph" title="wikilink">Term graph</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>Heckel, R. (2006). <em>Graph transformation in a nutshell</em>. <a href="http://www.elsevier.com/locate/entcs">Electronic Notes in Theoretical Computer Science</a> 148 (1 SPEC. ISS.), pp. 187–198.</li>
<li>König, Barbara (2004). <em>Analysis and Verification of Systems with Dynamically Evolving Structure</em>. <a href="http://www.fmi.uni-stuttgart.de/szs/publications/koenigba/habilschrift.pdf">Habilitation thesis, Universität Stuttgart</a>, pp. 65–180.</li>
<li>Lobo, D. et al. (2011). <em>Graph grammars with string-regulated rewriting</em>. <a href="http://dx.doi.org/10.1016/j.tcs.2011.07.004">Theoretical Computer Science</a>, 412(43), pp. 6101-6111.</li>
</ul>

<p>"</p>

<p><a href="Category:Graph_rewriting" title="wikilink">Category:Graph rewriting</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"> covers this approach in detail.<a href="#fnref1">↩</a></li>
<li id="fn2">This topic is expanded at <a href="http://www.mat2gra.info/">mat2gra.info</a>.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
