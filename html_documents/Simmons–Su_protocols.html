<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1220">Simmons–Su protocols</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Simmons–Su protocols</h1>
<hr/>

<p>The <strong>Simmons–Su protocols</strong> are several protocols for <a href="envy-free_division" title="wikilink">envy-free division</a>. They are based on <a href="Sperner's_lemma" title="wikilink">Sperner's lemma</a>. The merits of these protocols is that they put few restrictions on the preferences of the partners, and ask the partners only simple queries such as "which piece do you prefer?".</p>

<p>Protocols were developed for solving several related problems:</p>
<h2 id="cake-cutting">Cake cutting</h2>

<p>In this problem, a <a href="fair_cake-cutting" title="wikilink">cake</a> (a heterogeneous divisible resource) has to be divided among <em>n</em> partners with different preferences over parts of the cake. The cake has to be divided to <em>n</em> pieces such that: (a) each partner receives a single connected piece, and (b) each partner believes that his piece is (weakly) better than all other pieces. A protocol for solving this problem was developed by <a href="Forest_Simmons" title="wikilink">Forest Simmons</a> in 1980, in a correspondence with <a href="Michael_Starbird" title="wikilink">Michael Starbird</a>. It was first publicized by <a href="Francis_Su" title="wikilink">Francis Su</a> in 1999.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Given a cut-set (i.e. a certain partition of the cake to <em>n</em> pieces), we say that a partner <em>prefers</em> a given piece if he believes that this piece is weakly better than all other pieces. "Weakly" means that the partner may be indifferent between the piece and one or more other pieces, so he may (in case of ties) "prefer" more than one piece.</p>

<p>The protocol makes the following assumptions on the preferences of the partners:</p>
<ol>
<li><em>Independence on other partners</em>: The preference depends on the partner and the entire cut-set, but not on choices made by the other partners.</li>
<li><em>Hungry partners</em>: Partners never prefer an empty piece.</li>
<li><em><a href="Topologically_closed" title="wikilink">Topologically closed</a> preference sets</em>: Any piece that is preferred for a convergent sequence of cut-sets, is preferred at the limiting cut-set. So for example, if a partner prefers the first piece in all cut-sets where the first cut is done at <em>x</em> &gt; 0.2 and prefers the second piece in all cut-sets where the first cut is at <em>x</em> &lt; 0.2, then at the cut-set where the first cut is at <em>x</em> = 0.2 that partner prefers both pieces equally.</li>
</ol>

<p>The closedness condition rules out the existence of single points of cake with positive desirability. </p>

<p>These assumptions are very mild: in contrast to other protocols for <a href="fair_cake-cutting" title="wikilink">fair cake-cutting</a>, the utility functions are <em>not</em> required to be additive or monotonous.</p>

<p>The protocol considers 1-dimensional cut-sets. For example, the cake may be the 1-dimensional interval [0,1] and each piece is an interval; or, the cake may be a rectangle cut along its longer side so that each piece is a rectangle. Every cut-set can be represented by <em>n</em> numbers <em>x</em><sub><em>i</em></sub>, <em>i</em> = 1, ..., <em>n</em>, where <em>x<sub>i</sub></em> is the length of the <em>i</em>th piece. We assume that the total length of the cake is 1, so <em>x</em><sub>1</sub> + ... + <em>x</em><sub><em>n</em></sub> = 1. The space of possible partitions is thus an (<em>n</em> − 1)-dimensional simplex with <em>n</em> vertices in <strong>R</strong><sup><em>n</em></sup>. The protocol works on this simplex in the following way:</p>
<ol>
<li>Triangulate the simplex-of-partitions to smaller simplices of any desired size.</li>
<li>Assign each vertex of the triangulation to one partner, such that each sub-simplex has <em>n</em> different labels.</li>
<li>For each vertex of the triangulation, ask its owner: “Which piece would you choose if the cake were cut with the cut-set represented by this point?”. Label that vertex by the number of the piece that is desired.</li>
</ol>

<p>The generated labeling satisfies the requirements of <a href="Sperner's_lemma#Two-dimensional_case" title="wikilink">Sperner's lemma coloring</a>:</p>
<ul>
<li>Each vertex of the original simplex corresponds to a cut-set in which one piece contains the entire cake and all other pieces are empty. By the "hungry partners" assumption, the owner of that vertex must prefer that piece. Hence the labels of the vertices of the large simplex are all different.</li>
<li>Each side/face of the original simplex corresponds to the cut-sets in which some pieces are empty, and the non-empty pieces correspond to the vertices of that side. By the "hungry partners" assumption, the owners must prefer only non-empty pieces, so the triangulation vertices on these sides can have only one of the labels that appear in the corresponding vertices.</li>
</ul>

<p>Hence, by Sperner's lemma there must be at least one sub-simplex in which the labels are all different. In step #2 we assigned each vertex of this sub-simplex to a different partner. Hence we have found <em>n</em> very similar cut-sets in which different partners prefer different pieces of cake.</p>

<p>We can now triangulate the sub-simplex to a finer mesh of sub-sub-simplices and repeat the process. We get a sequence of smaller and smaller simplices which converge to a single point. This point corresponds to a single cut-set. By the "Preference sets are closed" assumption, in this cut-set each partner prefers a different piece. This is an envy-free partition!</p>

<p>The existence of an envy-free partition has been proved before,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> but Simmons' proof also yields a constructive approximation algorithm. For example, assume that a certain land-estate has to be divided, and the partners agree that a difference of plus or minus 1 centimeter is irrelevant to them. Then the original simplex can be triangulated to simpliecs with side length less than 1 cm. Then every point in the sub-simplex in which all labels are different corresponds to an (approximate) envy-free partition.</p>

<p>In contrast to other envy-free protocols, which may assign each partner a large number of crumbs, Simmons' protocol gives each partner a single connected piece. Moreover, if the original cake is rectangular then each piece is a rectangle.</p>

<p>Several years after this algorithm has been published, it was proved that envy-free partitions with connected pieces cannot be found by finite protocols.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Hence, an approximation algorithm is the best that we can hope for in finite time. Currently, Simmons' algorithm is the only approximation algorithm for envy-free cake-cutting with connected pieces.</p>

<p>Simmons' algorithm is one of the few fair division algorithms which have been implemented and put online.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>One nice thing about the algorithm is that the queries it asks the partners are very simple: they just have to decide, in each partition, which piece they prefer. This is in contrast to other algorithm, which ask numerical queries such as "cut a piece with a value of 1/3" etc.</p>
<h3 id="run-time-complexity">Run-time complexity</h3>

<p>While an envy-free division with connected pieces can be approximated to any precision using the above protocol, the approximation might take a long time. In particular:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<ul>
<li>When the utility functions are accessible only through oracles, the number of queries for achieving an envy of less than ϵ is 

<math display="inline" id="Simmons–Su_protocols:0">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mfrac>
     <mn>1</mn>
     <msup>
      <mi>ϵ</mi>
      <mi>n</mi>
     </msup>
    </mfrac>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ϵ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(\frac{1}{\epsilon^{n}})
  </annotation>
 </semantics>
</math>

.</li>
<li>When the utility functions are given explicitly by polynomial-time algorithms, the envy-free cake-cutting problem has the same complexity as finding a <a href="Brouwer_fixed-point" title="wikilink">Brouwer fixed-point</a>, i.e. <a class="uri" href="PPAD" title="wikilink">PPAD</a>-complete.</li>
</ul>
<h2 id="rental-harmony">Rental Harmony</h2>

<p>In this problem, <em>n</em> housemates have decided to rent an <em>n</em>-bedroom house for rent fixed by the homeowner. Each housemate may have different preferences — one may prefer a large room, another may prefer a room with a view, etc. The following two problems should be solved simultaneously: (a) Assign a room to each partner, (b) Determine the rent that each partner should pay, such that the sum of payments equals to the total rent. The assignment should be <em>envy-free</em> in that every partner weakly prefers his parcel of room+rent over the other parcels, i.e. no partner would like to take another room at the rent assigned to that room. A protocol for solving this problem was developed by <a href="Francis_Su" title="wikilink">Francis Su</a> in 1999.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Given a pricing scheme (an assignment of rent to rooms), we say that a partner <em>prefers</em> a given room if he believes that the parcel of room+rent is weakly better than all other parcels. The protocol makes the following assumptions on the preferences of the partners:</p>
<ol>
<li><em>Good house</em>: In any partition of the rent, each person finds at least one room+rent parcel acceptable. the preference depends on the partner, the rooms and the rents, but not on choices made by others.</li>
<li><em>Miserly partners</em>: every partner prefers a free room (a room with a rent of 0).</li>
<li><em><a href="Topologically_closed" title="wikilink">Topologically closed</a> preference sets</em>: A partner who prefers a room for a convergent sequence of prices, prefers that room at the limiting price.</li>
</ol>

<p>Normalize the total rent to 1. Then each pricing scheme is a point in an (<em>n</em> − 1)-dimensional simplex with <em>n</em> vertices in <em>R</em>'<sup><em>n</em></sup>. Su's protocol operates on a dualized version of this simplex in a similar way to the cake-cutting protocol: for every vertex of a triangulation of the dual simplex, which corresponds to a certain price scheme, it asks the owning partner "which room do you prefer in that pricing scheme?". This results in a Sperner coloring of the dual simplex, and thus there exists a small sub-simplex which corresponds an approximate envy-free assignment of rooms and rents.</p>

<p><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> and <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> provide popularized explanations of the Rental Harmony protocol.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> and <a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> provide on-line implementations.</p>

<p>The "Miserly partners" condition can be weakened in the following way: each partner never chooses the most expensive room if there is a free room available. This does not require the person to choose the free room. In particular, this will hold if a person always prefers a free room to a room costing at least 1/(<em>n</em> − 1) of the total rent.</p>
<h2 id="chore-division">Chore division</h2>

<p>In this problem, there is a chore that has to be divided among <em>n</em> partners, e.g., lawn-mowing in a large area.</p>

<p>The Rental Harmony protocol can be used to achieve approximate envy-free assignment of chores by simply thinking of the rent payments as chores and ignoring the rooms. Divisibility of chores can be achieved by dividing the time spent on them.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h2 id="multi-cake-cutting">Multi-cake cutting</h2>

<p>In this problem, two or more cakes have to be divided simultaneously among two or more partners, giving each partner a single piece from each cake. Of course, if the preferences are independent (i.e. the utility from an allocation is the sum of utilities from the allocated piece in each cake), then the problem can be solved by one-cake division methods – simply do an envy-free partition on each cake separately. The question becomes interesting when the partners have linked preferences over the cakes, in which the portion of one cake that partner prefers is influenced by the portion of another cake allocated to him. For example, if the "cakes" are the times of work-shifts in two consecutive days, a typical employee may prefer to have the same shift every day (e.g. morning-morning or evening-evening) then to have different shifts.</p>

<p>A solution to this problem for the case of 2 partners and 2 or 3 cakes was published in 2009.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> If the number of cakes is <em>m</em>, and each cake is divided to <em>k</em> pieces, then the space of partitions can be represented by an <em>n</em>-vertex <em>d</em>-dimensional <a class="uri" href="polytope" title="wikilink">polytope</a>, where <em>d</em>=<em>m</em>(<em>k</em> − 1) and <em>n</em> = <em>k</em><sup><em>m</em></sup>. A <a href="Sperner's_lemma#Generalizations" title="wikilink">generalization of Sperner's lemma to polytopes</a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> guarantees that, if this polytope is trianguated and labeled in an appropriate manner, there are at least <em>n</em> − <em>d</em> sub-simplices with a full labeling; each of these simplices corresponds to an (approximate) envy-free allocation in which each partner receives a different combination of pieces. However, the combinations might overlap: one partner might get the "morning" and "evening" shifts while another partner might get "evening" and "evening". Although these are different selections, they are incompatible. section 4 of <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> proves that an envy-free division to two partners with disjoint pieces might be impossible if <em>m</em> = <em>k</em> = 2, but is always possible if <em>m</em> = 2 and <em>k</em> = 3 (i.e. at least one cake is divided to three pieces, each partner receives a single piece from each cake, and at least one piece is discarded). Similar results are proved for three cakes.</p>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Fair_division_protocols" title="wikilink">Category:Fair division protocols</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">An implementation by Francis Su, Elisha Peterson and Patrick Winograd is available at: <a class="uri" href="https://www.math.hmc.edu/~su/fairdivision/">https://www.math.hmc.edu/~su/fairdivision/</a><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a class="uri" href="https://www.math.hmc.edu/~su/fairdivision/">https://www.math.hmc.edu/~su/fairdivision/</a><a href="#fnref9">↩</a></li>
<li id="fn10"><a class="uri" href="http://www.nytimes.com/interactive/2014/science/rent-division-calculator.html">http://www.nytimes.com/interactive/2014/science/rent-division-calculator.html</a><a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"></li>
</ol>
</section>
</body>
</html>
