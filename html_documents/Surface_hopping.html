<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="880">Surface hopping</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Surface hopping</h1>
<hr/>

<p><strong>Surface hopping</strong> is a semi-classical technique that incorporates <a href="Quantum_mechanics" title="wikilink">quantum</a> mechanical effects into <a href="molecular_dynamics" title="wikilink">molecular dynamics</a> simulations.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Traditional approaches propagate the dynamics only on one surface. However, quantum mechanics predicts that the dynamics happen on all the surfaces simultaneously. Surface hopping incorporates the effect of other surfaces by allowing for 'hops' between the surfaces, subject to certain criteria. This method is particularly useful when the <a href="Born-Oppenheimer_approximation" title="wikilink">Born-Oppenheimer approximation</a> breaks down in certain regions, particularly <a href="conical_intersection" title="wikilink">conical intersections</a> and <a href="avoided_crossing" title="wikilink">avoided crossings</a>.</p>
<h2 id="motivation">Motivation</h2>

<p>Molecular dynamics simulations numerically solve the classical equations of motion. These simulations, though, ignore the effects of <a href="zero-point_energy" title="wikilink">zero-point energy</a>, <a href="quantum_interference" title="wikilink">quantum interference</a>, and <a href="quantum_tunneling" title="wikilink">quantum tunneling</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Solving the time-dependent <a href="Schrödinger_equation" title="wikilink">Schrödinger equation</a> numerically incorporates all these effects, but is computationally unfeasible when the system has many degrees of freedom. To tackle this issue, one approach is the mean field or Ehrenfest method, where the molecular dynamics is run on the average potential energy surface given by a linear combination of the adiabatic states. This was applied successfully for some applications, but has some important limitations. When the difference between the adiabatic states is large, then the dynamics must be primarily driven by only one surface, and not an average potential. In addition, this method also violates the principle of microscopic reversibility.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Surface hopping accounts for these limitations by propagating an ensemble of trajectories, each one of them on a single adiabatic surface at any given time. The trajectories are allowed to 'hop' between various adiabatic states at certain times such that the <a href="probability_amplitude" title="wikilink">quantum amplitudes</a> for the adiabatic states follow the time dependent Schrödinger equation. The probability of these hops are dependent on the coupling between the states, and is generally significant only in the regions where the difference between adiabatic energies is small.</p>
<h2 id="theory-behind-the-method">Theory behind the method</h2>

<p>The formulation described here is in the adiabatic representation for simplicity.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> It can easily be generalized to a different representation. The coordinates of the system is divided into two categories: quantum (

<math display="inline" id="Surface_hopping:0">
 <semantics>
  <mi>𝐪</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐪</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{q}
  </annotation>
 </semantics>
</math>

) and classical (

<math display="inline" id="Surface_hopping:1">
 <semantics>
  <mi>𝐑</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}
  </annotation>
 </semantics>
</math>

). The <a href="Hamiltonian_(quantum_mechanics)" title="wikilink">Hamiltonian</a> of the quantum <a href="Degrees_of_freedom_(mechanics)" title="wikilink">degrees of freedom</a> with <a class="uri" href="mass" title="wikilink">mass</a> 

<math display="inline" id="Surface_hopping:2">
 <semantics>
  <msub>
   <mi>m</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i}
  </annotation>
 </semantics>
</math>

 is defined as:</p>

<p>

<math display="block" id="Surface_hopping:3">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <msup>
        <mi mathvariant="normal">ℏ</mi>
        <mn>2</mn>
       </msup>
       <mrow>
        <mn>2</mn>
        <msub>
         <mi>m</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mfrac>
      <msubsup>
       <mo>∇</mo>
       <msub>
        <mi>q</mi>
        <mi>i</mi>
       </msub>
       <mn>2</mn>
      </msubsup>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐪</mi>
      <mo>,</mo>
      <mi>𝐑</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <csymbol cd="latexml">Planck-constant-over-2-pi</csymbol>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-∇</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>q</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>V</ci>
      <interval closure="open">
       <ci>𝐪</ci>
       <ci>𝐑</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=\sum_{i}-\frac{\hbar^{2}}{2m_{i}}\nabla_{q_{i}}^{2}+V(\mathbf{q},\mathbf{R})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Surface_hopping:4">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 describes the <a href="scalar_potential" title="wikilink">potential</a> for the whole system. The <a class="uri" href="eigenvalues" title="wikilink">eigenvalues</a> of 

<math display="inline" id="Surface_hopping:5">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 as a function of 

<math display="inline" id="Surface_hopping:6">
 <semantics>
  <mi>𝐑</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}
  </annotation>
 </semantics>
</math>

 are called the adiabatic surfaces 

<math display="block" id="Surface_hopping:7">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐪</mi>
    <mo>;</mo>
    <mi>𝐑</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>i</ci>
    </apply>
    <list>
     <ci>𝐪</ci>
     <ci>𝐑</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{i}(\mathbf{q};\mathbf{R})
  </annotation>
 </semantics>
</math>

. Typically, 

<math display="inline" id="Surface_hopping:8">
 <semantics>
  <mi>𝐪</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐪</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{q}
  </annotation>
 </semantics>
</math>

 corresponds to the electronic degree of freedom, light atoms such as <a class="uri" href="hydrogen" title="wikilink">hydrogen</a>, or high frequency <a class="uri" href="vibrations" title="wikilink">vibrations</a> such as O-H stretch. The <a class="uri" href="forces" title="wikilink">forces</a> in the molecular dynamics simulations are derived only from one adiabatic surface, and are given by:</p>

<p>

<math display="inline" id="Surface_hopping:9">
 <semantics>
  <msub>
   <mi>𝐅</mi>
   <mi>𝐑</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐅</ci>
    <ci>𝐑</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\mathbf{F}_{\mathbf{R}}
  </annotation>
 </semantics>
</math>


 where i represents the chosen adiabatic surface. The last equation is derived using <a href="Hellmann-Feynman_theorem" title="wikilink">Hellmann-Feynman theorem</a>. The <a href="Bra-ket_notation" title="wikilink">brackets</a> denote the <a class="uri" href="integral" title="wikilink">integral</a> is done only over the quantum degrees of freedom. Choosing only one adiabatic surface is an excellent approximation if the difference between the adiabatic surfaces is large for energetically accessible regions of 

<math display="inline" id="Surface_hopping:10">
 <semantics>
  <mi>𝐑</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}
  </annotation>
 </semantics>
</math>


. When this is not the case, the effect of the other states become important. This effect is incorporated in the surface hopping algorithm by considering the <a class="uri" href="wavefunction" title="wikilink">wavefunction</a> of the quantum degrees of freedom at time t as an expansion in the adiabatic basis:</p>

<p>

<math display="block" id="Surface_hopping:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>ψ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐪</mi>
     <mo>;</mo>
     <mi>𝐑</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>n</mi>
    </munder>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>ϕ</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐪</mi>
      <mo>;</mo>
      <mi>𝐑</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ψ</ci>
     <list>
      <ci>𝐪</ci>
      <ci>𝐑</ci>
      <ci>t</ci>
     </list>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>n</ci>
      </apply>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <ci>n</ci>
      </apply>
      <list>
       <ci>𝐪</ci>
       <ci>𝐑</ci>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi(\mathbf{q};\mathbf{R},t)=\sum_{n}c_{n}(t)\phi_{n}(\mathbf{q};\mathbf{R})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Surface_hopping:12">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>n</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{n}(t)
  </annotation>
 </semantics>
</math>

 are the expansion coefficients. Substituting the above equation into the time dependent Schrödinger equation gives</p>

<p>

<math display="block" id="Surface_hopping:13">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mi mathvariant="normal">ℏ</mi>
   <mover accent="true">
    <msub>
     <mi>c</mi>
     <mi>j</mi>
    </msub>
    <mo>˙</mo>
   </mover>
   <mo>=</mo>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mi>n</mi>
   </munder>
   <msub>
    <mi>c</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>V</mi>
     <mrow>
      <mi>j</mi>
      <mi>n</mi>
     </mrow>
    </msub>
    <mo>-</mo>
    <mi>i</mi>
    <mi mathvariant="normal">ℏ</mi>
    <mover accent="true">
     <mi>𝐑</mi>
     <mo>˙</mo>
    </mover>
    <mo>.</mo>
    <msub>
     <mi>𝐝</mi>
     <mrow>
      <mi>j</mi>
      <mi>n</mi>
     </mrow>
    </msub>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <csymbol cd="latexml">Planck-constant-over-2-pi</csymbol>
    <apply>
     <ci>normal-˙</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>n</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <minus></minus>
     <csymbol cd="unknown">i</csymbol>
     <csymbol cd="latexml">Planck-constant-over-2-pi</csymbol>
     <apply>
      <ci>normal-˙</ci>
      <ci>𝐑</ci>
     </apply>
     <ci>normal-.</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐝</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\hbar\dot{c_{j}}=\sum_{n}c_{n}\left(V_{jn}-i\hbar\dot{\mathbf{R}}.\mathbf{d}_%
{jn}\right)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Surface_hopping:14">
 <semantics>
  <msub>
   <mi>V</mi>
   <mrow>
    <mi>j</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <apply>
     <times></times>
     <ci>j</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{jn}
  </annotation>
 </semantics>
</math>

 and the <a href="vibronic_coupling" title="wikilink">nonadiabatic coupling vector</a> 

<math display="inline" id="Surface_hopping:15">
 <semantics>
  <msub>
   <mi>𝐝</mi>
   <mrow>
    <mi>j</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐝</ci>
    <apply>
     <times></times>
     <ci>j</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{d}_{jn}
  </annotation>
 </semantics>
</math>


 are given by</p>

<p>

<math display="inline" id="Surface_hopping:16">
 <semantics>
  <msub>
   <mi>V</mi>
   <mrow>
    <mi>j</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <apply>
     <times></times>
     <ci>j</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle V_{jn}
  </annotation>
 </semantics>
</math>


 The adiabatic surface can switch at any given time t based on how the quantum probabilities 

<math display="inline" id="Surface_hopping:17">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>j</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |c_{j}(t)|^{2}
  </annotation>
 </semantics>
</math>

 are changing with time. The rate of change of 

<math display="inline" id="Surface_hopping:18">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>j</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |c_{j}(t)|^{2}
  </annotation>
 </semantics>
</math>

 is given by:</p>

<p>

<math display="block" id="Surface_hopping:19">
 <semantics>
  <mrow>
   <mover accent="true">
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <msub>
        <mi>c</mi>
        <mi>j</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>˙</mo>
   </mover>
   <mo>=</mo>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mi>n</mi>
   </munder>
   <mfrac>
    <mn>2</mn>
    <mi mathvariant="normal">ℏ</mi>
   </mfrac>
   <mi>I</mi>
   <mi>m</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>n</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <msub>
     <mi>V</mi>
     <mrow>
      <mi>j</mi>
      <mi>n</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>-</mo>
   <mn>2</mn>
   <mi>R</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>n</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mover accent="true">
     <mi>𝐑</mi>
     <mo>˙</mo>
    </mover>
    <mo>.</mo>
    <msub>
     <mi>𝐝</mi>
     <mrow>
      <mi>j</mi>
      <mi>n</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <ci>normal-˙</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>c</ci>
         <ci>j</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>n</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <csymbol cd="latexml">Planck-constant-over-2-pi</csymbol>
    </apply>
    <csymbol cd="unknown">I</csymbol>
    <csymbol cd="unknown">m</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <minus></minus>
    <cn type="integer">2</cn>
    <csymbol cd="unknown">R</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-˙</ci>
      <ci>𝐑</ci>
     </apply>
     <ci>normal-.</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐝</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{|c_{j}(t)|^{2}}=\sum_{n}\frac{2}{\hbar}Im(a_{nj}V_{jn})-2Re(a_{nj}\dot{%
\mathbf{R}}.\mathbf{d}_{jn})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Surface_hopping:20">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>n</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>c</mi>
     <mi>n</mi>
    </msub>
    <msubsup>
     <mi>c</mi>
     <mi>j</mi>
     <mo>*</mo>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>j</ci>
      </apply>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{nj}=c_{n}c_{j}^{*}
  </annotation>
 </semantics>
</math>

. For a small time interval dt, the fractional change in 

<math display="inline" id="Surface_hopping:21">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>j</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |c_{j}(t)|^{2}
  </annotation>
 </semantics>
</math>

 is given by</p>

<p>

<math display="block" id="Surface_hopping:22">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <msub>
         <mi>c</mi>
         <mi>j</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>t</mi>
          <mo>+</mo>
          <mrow>
           <mi>d</mi>
           <mi>t</mi>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>-</mo>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <msub>
         <mi>c</mi>
         <mi>j</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <msub>
        <mi>c</mi>
        <mi>j</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mfrac>
   <mo>≈</mo>
   <mfrac>
    <mrow>
     <mi>d</mi>
     <mi>t</mi>
    </mrow>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>j</mi>
      <mi>j</mi>
     </mrow>
    </msub>
   </mfrac>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mi>n</mi>
   </munder>
   <mfrac>
    <mn>2</mn>
    <mi mathvariant="normal">ℏ</mi>
   </mfrac>
   <mi>I</mi>
   <mi>m</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>n</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <msub>
     <mi>V</mi>
     <mrow>
      <mi>j</mi>
      <mi>n</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>-</mo>
   <mn>2</mn>
   <mi>R</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>n</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mover accent="true">
     <mi>𝐑</mi>
     <mo>˙</mo>
    </mover>
    <mo>.</mo>
    <msub>
     <mi>𝐝</mi>
     <mrow>
      <mi>j</mi>
      <mi>n</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <ci>j</ci>
         </apply>
         <apply>
          <plus></plus>
          <ci>t</ci>
          <apply>
           <times></times>
           <ci>d</ci>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <ci>j</ci>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>c</ci>
         <ci>j</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <approx></approx>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>n</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <csymbol cd="latexml">Planck-constant-over-2-pi</csymbol>
    </apply>
    <csymbol cd="unknown">I</csymbol>
    <csymbol cd="unknown">m</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <minus></minus>
    <cn type="integer">2</cn>
    <csymbol cd="unknown">R</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-˙</ci>
      <ci>𝐑</ci>
     </apply>
     <ci>normal-.</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐝</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{|c_{j}(t+dt)|^{2}-|c_{j}(t)|^{2}}{|c_{j}(t)|^{2}}\approx\frac{dt}{a_{jj}%
}\sum_{n}\frac{2}{\hbar}Im(a_{nj}V_{jn})-2Re(a_{nj}\dot{\mathbf{R}}.\mathbf{d}%
_{jn})
  </annotation>
 </semantics>
</math>

. This gives the net change in flux of population from state 

<math display="inline" id="Surface_hopping:23">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

. Based on this, the probability of hopping from state j to n is proposed to be</p>

<p>

<math display="block" id="Surface_hopping:24">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mrow>
     <mi>j</mi>
     <mo>→</mo>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>d</mi>
     <mi>t</mi>
    </mrow>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>j</mi>
      <mi>j</mi>
     </mrow>
    </msub>
   </mfrac>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mn>2</mn>
     <mi mathvariant="normal">ℏ</mi>
    </mfrac>
    <mi>I</mi>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>n</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <msub>
      <mi>V</mi>
      <mrow>
       <mi>j</mi>
       <mi>n</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>-</mo>
    <mn>2</mn>
    <mi>R</mi>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>n</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <mover accent="true">
      <mi>𝐑</mi>
      <mo>˙</mo>
     </mover>
     <mo>.</mo>
     <msub>
      <mi>𝐝</mi>
      <mrow>
       <mi>j</mi>
       <mi>n</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>j</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <csymbol cd="latexml">Planck-constant-over-2-pi</csymbol>
     </apply>
     <csymbol cd="unknown">I</csymbol>
     <csymbol cd="unknown">m</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <apply>
        <times></times>
        <ci>j</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <minus></minus>
     <cn type="integer">2</cn>
     <csymbol cd="unknown">R</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-˙</ci>
       <ci>𝐑</ci>
      </apply>
      <ci>normal-.</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐝</ci>
       <apply>
        <times></times>
        <ci>j</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{j\to n}=\frac{dt}{a_{jj}}\left(\frac{2}{\hbar}Im(a_{nj}V_{jn})-2Re(a_{nj}%
\dot{\mathbf{R}}.\mathbf{d}_{jn})\right)
  </annotation>
 </semantics>
</math>

. This criteria is known as the "fewest switching" algorithm, as it minimizes the number of hops required to maintain the population in various adiabatic states.</p>

<p>Whenever a hop takes place, the velocity is adjusted to maintain <a href="conservation_of_energy" title="wikilink">conservation of energy</a>. To compute the direction of the change in velocity, the nuclear forces in the transition is</p>

<p>

<math display="inline" id="Surface_hopping:25">
 <semantics>
  <mrow>
   <mo><</mo>
   <msub>
    <mi>ϕ</mi>
    <mi>j</mi>
   </msub>
   <mo fence="true" stretchy="false">|</mo>
   <mrow>
    <msub>
     <mo>∇</mo>
     <mi>𝐑</mi>
    </msub>
    <mi>H</mi>
   </mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>ϕ</mi>
    <mi>n</mi>
   </msub>
   <mo>></mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">quantum-operator-product</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-∇</ci>
      <ci>𝐑</ci>
     </apply>
     <ci>H</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle<\phi_{j}|\nabla_{\mathbf{R}}H|\phi_{n}>
  </annotation>
 </semantics>
</math>


 where 

<math display="inline" id="Surface_hopping:26">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo><</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>j</mi>
    </msub>
    <mo fence="true" stretchy="false">|</mo>
    <mi>H</mi>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>j</mi>
    </msub>
    <mo>></mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">quantum-operator-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>j</ci>
     </apply>
     <ci>H</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{j}=<\phi_{j}|H|\phi_{j}>
  </annotation>
 </semantics>
</math>

 is the eigen value. For the last equality, 

<math display="inline" id="Surface_hopping:27">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mrow>
     <mi>j</mi>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <msub>
     <mi>d</mi>
     <mrow>
      <mi>n</mi>
      <mi>j</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{jn}=-d_{nj}
  </annotation>
 </semantics>
</math>

 is used. This shows that the nuclear forces acting during the hop are in the direction of the nonadiabatic coupling vector 

<math display="inline" id="Surface_hopping:28">
 <semantics>
  <msub>
   <mi>𝐝</mi>
   <mrow>
    <mi>j</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐝</ci>
    <apply>
     <times></times>
     <ci>j</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{d}_{jn}
  </annotation>
 </semantics>
</math>

. Hence 

<math display="inline" id="Surface_hopping:29">
 <semantics>
  <msub>
   <mi>𝐝</mi>
   <mrow>
    <mi>j</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐝</ci>
    <apply>
     <times></times>
     <ci>j</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{d}_{jn}
  </annotation>
 </semantics>
</math>

 is a reasonable choice for the direction along which velocity should be changed.</p>
<h3 id="frustrated-hops">Frustrated Hops</h3>

<p>If the velocity reduction required to conserve energy while making a hop is greater than the component of the velocity to be adjusted, then the hop is known as frustrated. In other words, a hop is frustrated if the system does not have enough energy to make the hop. Several approaches have been suggested to deal with these frustrated hops. The simplest of these is to ignore these hops. <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Another suggestion is not to change the adiabatic state, but reverse the direction of the component of the velocity along the nonadiabatic coupling vector.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Yet another approach is to allow the hop to happen if an allowed hopping point is reachable within <a href="Quantum_fluctuation" title="wikilink">uncertainty time</a> 

<math display="inline" id="Surface_hopping:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mi>t</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">ℏ</mi>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>E</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>δ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <csymbol cd="latexml">Planck-constant-over-2-pi</csymbol>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-Δ</ci>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta t=\hbar/2\Delta E
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Surface_hopping:31">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta E
  </annotation>
 </semantics>
</math>

 is the extra energy that the system needed to make the hop possible.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h3 id="decoherence-time">Decoherence Time</h3>

<p>Surface hopping can develop nonphysical coherence between the quantum coefficients over large time. To eliminate this, the quantum coefficient is set to 1 for the current state (and zero for the rest of the states) after a predefined time has elapsed after the trajectory crosses the region where hopping has high probabilities. <a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h2 id="outline-of-the-algorithm">Outline of the algorithm</h2>

<p>The state of the system at any time 

<math display="inline" id="Surface_hopping:32">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is given by the <a href="phase_space" title="wikilink">phase space</a> of all the classical particles, the quantum amplitudes, and the adiabatic state. The simulation broadly consists of the following steps:</p>

<p>Step 1. Initialize the state of the system. The classical positions and velocities are chosen based on the <a href="Statistical_ensemble_(mathematical_physics)" title="wikilink">ensemble</a> required.</p>

<p>Step 2. Compute forces using Hellmann-Feynman theorem, and integrate the <a href="equations_of_motion" title="wikilink">equations of motion</a> by time step 

<math display="inline" id="Surface_hopping:33">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta t
  </annotation>
 </semantics>
</math>

 to obtain the classical phase space at time 

<math display="inline" id="Surface_hopping:34">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>+</mo>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>t</ci>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t+\Delta t
  </annotation>
 </semantics>
</math>

.</p>

<p>Step 3. Integrate the Schrödinger equation to evolve quantum amplitudes from time 

<math display="inline" id="Surface_hopping:35">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Surface_hopping:36">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>+</mo>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>t</ci>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t+\Delta t
  </annotation>
 </semantics>
</math>

 in increments of 

<math display="inline" id="Surface_hopping:37">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>δ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta t
  </annotation>
 </semantics>
</math>

. This time step 

<math display="inline" id="Surface_hopping:38">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>δ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta t
  </annotation>
 </semantics>
</math>

 is typically much smaller than 

<math display="inline" id="Surface_hopping:39">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta t
  </annotation>
 </semantics>
</math>

.</p>

<p>Step 4. Compute probability of hopping from current state to all other states. Generate a random number, and determine whether a switch should take place. If a switch does occur, change velocities to conserve energy. Go back to step 2, till trajectories have been evolved for the desired time.</p>
<h2 id="applications">Applications</h2>

<p>The method has been applied successfully to understand dynamics of systems that include tunneling, conical intersections and <a href="electron_excitation" title="wikilink">electronic excitation</a>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> <a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="limitations">Limitations</h2>

<p>Most of the critique of the surface hopping method comes from the separation of classical and quantum degrees of freedom. This ignores the <a href="quantum_entanglement" title="wikilink">entanglement</a> between these degrees of freedom. Moreover, this method is computationally feasible only for a limited number of quantum degrees of freedom. In addition, the trajectories must have enough energy to be able to reach the regions where probability of hopping is large.</p>
<h2 id="see-also">See Also</h2>
<ul>
<li><a href="Molecular_Dynamics" title="wikilink">Molecular Dynamics</a></li>
<li><a href="Computational_Chemistry" title="wikilink">Computational Chemistry</a></li>
<li><a href="Quantum_Chemistry" title="wikilink">Quantum Chemistry</a></li>
<li><a href="PIMD" title="wikilink">Path Integral Molecular Dynamics</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External Links</h2>
<ul>
<li><a href="http://www.newtonx.org">Newton-X: A package for Newtonian dynamics close to the crossing seam.</a></li>
<li><a href="http://www.youtube.com/user/mbarbatti">Movie examples of surface hopping.</a></li>
</ul>

<p>"</p>

<p><a href="Category:Quantum_mechanics" title="wikilink">Category:Quantum mechanics</a> <a href="Category:Molecular_dynamics" title="wikilink">Category:Molecular dynamics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
</ol>
</section>
</body>
</html>
