<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1763">Data validation and reconciliation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Data validation and reconciliation</h1>
<hr/>

<p><strong>Industrial process data validation and reconciliation</strong>, or more briefly, <strong>data validation and reconciliation (DVR)</strong>, is a technology that uses process information and mathematical methods in order to automatically correct measurements in industrial processes. The use of DVR allows for extracting accurate and reliable information about the state of industry processes from raw measurement data and produces a single consistent set of data representing the most likely process operation.</p>
<h2 id="models-data-and-measurement-errors">Models, data and measurement errors</h2>

<p>Industrial processes, for example chemical or thermodynamic processes in chemical plants, refineries, oil or gas production sites, or power plants, are often represented by two fundamental means:</p>
<ol>
<li>Models that express the general structure of the processes,</li>
<li>Data that reflects the state of the processes at a given point in time.</li>
</ol>

<p>Models can have different levels of detail, for example one can incorporate simple mass or compound conservation balances, or more advanced thermodynamic models including energy conservation laws. Mathematically the model can be expressed by a <a href="nonlinear_system" title="wikilink">nonlinear system of equations</a> 

<math display="inline" id="Data_validation_and_reconciliation:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>y</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(y)=0\,
  </annotation>
 </semantics>
</math>

 in the variables 

<math display="inline" id="Data_validation_and_reconciliation:1">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=(y_{1},\ldots,y_{n})
  </annotation>
 </semantics>
</math>

, which incorporates all the above-mentioned system constraints (for example the mass or heat balances around a unit). A variable could be the temperature or the pressure at a certain place in the plant.</p>
<h3 id="error-types">Error types</h3>

<p><a class="uri" href="File:Normal_no_bias.jpg|Normally">File:Normal_no_bias.jpg|Normally</a> distributed measurements without bias. <a class="uri" href="File:Normal_with_bias.jpg|Normally">File:Normal_with_bias.jpg|Normally</a> distributed measurements with bias.</p>

<p>Data originates typically from <a class="uri" href="measurements" title="wikilink">measurements</a> taken at different places throughout the industrial site, for example temperature, pressure, volumetric flow rate measurements etc. To understand the basic principles of DVR, it is important to first recognize that plant measurements are never 100% correct, i.e. raw measurement 

<math display="inline" id="Data_validation_and_reconciliation:2">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>y</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\,
  </annotation>
 </semantics>
</math>

 is not a solution of the nonlinear system 

<math display="inline" id="Data_validation_and_reconciliation:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>y</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(y)=0\,\!
  </annotation>
 </semantics>
</math>

. When using measurements without correction to generate plant balances, it is common to have incoherencies. <a href="Observational_error" title="wikilink">Measurement errors</a> can be categorized into two basic types:</p>
<ol>
<li><a href="random_error" title="wikilink">random errors</a> due to intrinsic <a class="uri" href="sensor" title="wikilink">sensor</a> <a class="uri" href="accuracy" title="wikilink">accuracy</a> and</li>
<li><a href="systematic_errors" title="wikilink">systematic errors</a> (or gross errors) due to sensor <a class="uri" href="calibration" title="wikilink">calibration</a> or faulty data transmission.</li>
</ol>

<p><a href="Random_error" title="wikilink">Random errors</a> means that the measurement 

<math display="inline" id="Data_validation_and_reconciliation:4">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\,\!
  </annotation>
 </semantics>
</math>

 is a <a href="random_variable" title="wikilink">random variable</a> with <a class="uri" href="mean" title="wikilink">mean</a> 

<math display="inline" id="Data_validation_and_reconciliation:5">
 <semantics>
  <msup>
   <mi>y</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>y</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{*}\,\!
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Data_validation_and_reconciliation:6">
 <semantics>
  <msup>
   <mi>y</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>y</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{*}\,\!
  </annotation>
 </semantics>
</math>

 is the true value that is typically not known. A <a href="systematic_error" title="wikilink">systematic error</a> on the other hand is characterized by a measurement 

<math display="inline" id="Data_validation_and_reconciliation:7">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\,\!
  </annotation>
 </semantics>
</math>

 which is a random variable with <a class="uri" href="mean" title="wikilink">mean</a> 

<math display="inline" id="Data_validation_and_reconciliation:8">
 <semantics>
  <mover accent="true">
   <mi>y</mi>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{y}\,\!
  </annotation>
 </semantics>
</math>

, which is not equal to the true value 

<math display="inline" id="Data_validation_and_reconciliation:9">
 <semantics>
  <mpadded width="+1.7pt">
   <msup>
    <mi>y</mi>
    <mo>*</mo>
   </msup>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>y</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{*}\,
  </annotation>
 </semantics>
</math>

. For ease in deriving and implementing an optimal estimation solution, and based on arguments that errors are the sum of many factors (so that the <a href="Central_limit_theorem" title="wikilink">Central limit theorem</a> has some effect), data reconciliation assumes these errors are <a href="normal_distribution" title="wikilink">normally distributed</a>.</p>

<p>Other sources of errors when calculating plant balances include process faults such as leaks, unmodeled heat losses, incorrect physical properties or other physical parameters used in equations, and incorrect structure such as unmodeled bypass lines. Other errors include unmodeled plant dynamics such as holdup changes, and other instabilities in plant operations that violate steady state (algebraic) models. Additional dynamic errors arise when measurements and samples are not taken at the same time, especially lab analyses.</p>

<p>The normal practice of using time averages for the data input partly reduces the dynamic problems. However, that does not completely resolve timing inconsistencies for infrequently-sampled data like lab analyses.</p>

<p>This use of average values, like a <a href="moving_average" title="wikilink">moving average</a>, acts as a <a href="low-pass_filter" title="wikilink">low-pass filter</a>, so high frequency noise is mostly eliminated. The result is that, in practice, data reconciliation is mainly making adjustments to correct systematic errors like biases.</p>
<h3 id="necessity-of-removing-measurement-errors">Necessity of removing measurement errors</h3>

<p>ISA-95 is the international standard for the integration of enterprise and control systems<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It asserts that:</p>
<blockquote>

<p>Data reconciliation is a serious issue for enterprise-control integration. The data have to be valid to be useful for the enterprise system. The data must often be determined from physical measurements that have associated error factors. This must usually be converted into exact values for the enterprise system. This conversion may require manual, or intelligent reconciliation of the converted values [...].</p>

<p>Systems must be set up to ensure that accurate data are sent to production and from production. Inadvertent operator or clerical errors may result in too much production, too little production, the wrong production, incorrect inventory, or missing inventory.</p>
</blockquote>
<h2 id="history">History</h2>

<p>DVR has become more and more important due to industrial processes that are becoming more and more complex. DVR started in the early 1960s with applications aiming at closing <a href="mass_balance" title="wikilink">material balances</a> in production processes where raw measurements were available for all <a href="variable_(mathematics)" title="wikilink">variables</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> At the same time the problem of <a href="systematic_error" title="wikilink">gross error</a> identification and elimination has been presented.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> In the late 1960s and 1970s unmeasured variables were taken into account in the data reconciliation process.,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> DVR also became more mature by considering general nonlinear equation systems coming from thermodynamic models.,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> ,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Quasi steady state dynamics for filtering and simultaneous parameter estimation over time were introduced in 1977 by Stanley and Mah.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Dynamic DVR was formulated as a nonlinear optimization problem by Liebman et al. in 1992.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="data-reconciliation">Data reconciliation</h2>

<p>Data reconciliation is a technique that targets at correcting measurement errors that are due to measurement noise, i.e. <a href="random_error" title="wikilink">random errors</a>. From a statistical point of view the main assumption is that no <a href="systematic_errors" title="wikilink">systematic errors</a> exist in the set of measurements, since they may bias the reconciliation results and reduce the robustness of the reconciliation.</p>

<p>Given 

<math display="inline" id="Data_validation_and_reconciliation:10">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 measurements 

<math display="inline" id="Data_validation_and_reconciliation:11">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}
  </annotation>
 </semantics>
</math>

, data reconciliation can mathematically be expressed as an <a href="optimization_problem" title="wikilink">optimization problem</a> of the following form:</p>

<p>

<math display="inline" id="Data_validation_and_reconciliation:12">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="right">
     <munder>
      <mi>min</mi>
      <mrow>
       <mi>x</mi>
       <mo>,</mo>
       <msup>
        <mi>y</mi>
        <mo>*</mo>
       </msup>
      </mrow>
     </munder>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mstyle displaystyle="true">
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>n</mi>
       </munderover>
      </mstyle>
      <msup>
       <mrow>
        <mo>(</mo>
        <mstyle displaystyle="true">
         <mfrac>
          <mrow>
           <msubsup>
            <mi>y</mi>
            <mi>i</mi>
            <mo>*</mo>
           </msubsup>
           <mo>-</mo>
           <msub>
            <mi>y</mi>
            <mi>i</mi>
           </msub>
          </mrow>
          <msub>
           <mi>σ</mi>
           <mi>i</mi>
          </msub>
         </mfrac>
        </mstyle>
        <mo>)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mtext>subject to</mtext>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi>F</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <msup>
         <mi>y</mi>
         <mo>*</mo>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <msub>
       <mi>y</mi>
       <mi>min</mi>
      </msub>
      <mo>≤</mo>
      <msup>
       <mi>y</mi>
       <mo>*</mo>
      </msup>
      <mo>≤</mo>
      <msub>
       <mi>y</mi>
       <mi>max</mi>
      </msub>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <msub>
        <mi>x</mi>
        <mi>min</mi>
       </msub>
       <mo>≤</mo>
       <mi>x</mi>
       <mo>≤</mo>
       <msub>
        <mi>x</mi>
        <mi>max</mi>
       </msub>
      </mrow>
      <mo>,</mo>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <list>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <times></times>
       </apply>
      </list>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>i</ci>
          </apply>
          <times></times>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <mtext>subject to</mtext>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>F</ci>
       <interval closure="open">
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>y</ci>
         <times></times>
        </apply>
       </interval>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <and></and>
      <apply>
       <leq></leq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <min></min>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <times></times>
       </apply>
      </apply>
      <apply>
       <leq></leq>
       <share href="#.cmml">
       </share>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <max></max>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <and></and>
      <apply>
       <leq></leq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <min></min>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <leq></leq>
       <share href="#.cmml">
       </share>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <max></max>
       </apply>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{aligned}\displaystyle\min_{x,y^{*}}&\displaystyle\sum_{i=1}^{n}\left(%
\frac{y_{i}^{*}-y_{i}}{\sigma_{i}}\right)^{2}\\
\displaystyle\text{subject to }&\displaystyle F(x,y^{*})=0\\
&\displaystyle y_{\min}\leq y^{*}\leq y_{\max}\\
&\displaystyle x_{\min}\leq x\leq x_{\max},\end{aligned}\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Data_validation_and_reconciliation:13">
 <semantics>
  <msubsup>
   <mi>y</mi>
   <mi>i</mi>
   <mo>*</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}^{*}\,\!
  </annotation>
 </semantics>
</math>

 is the reconciled value of the 

<math display="inline" id="Data_validation_and_reconciliation:14">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th measurement (

<math display="inline" id="Data_validation_and_reconciliation:15">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,\ldots,n\,\!
  </annotation>
 </semantics>
</math>

), 

<math display="inline" id="Data_validation_and_reconciliation:16">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}\,\!
  </annotation>
 </semantics>
</math>

 is the measured value of the 

<math display="inline" id="Data_validation_and_reconciliation:17">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th measurement (

<math display="inline" id="Data_validation_and_reconciliation:18">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,\ldots,n\,\!
  </annotation>
 </semantics>
</math>

), 

<math display="inline" id="Data_validation_and_reconciliation:19">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}\,\!
  </annotation>
 </semantics>
</math>

 is the 

<math display="inline" id="Data_validation_and_reconciliation:20">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

-th unmeasured variable (

<math display="inline" id="Data_validation_and_reconciliation:21">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>j</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>m</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j=1,\ldots,m\,\!
  </annotation>
 </semantics>
</math>

), and 

<math display="inline" id="Data_validation_and_reconciliation:22">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{i}\,\!
  </annotation>
 </semantics>
</math>

 is the standard deviation of the 

<math display="inline" id="Data_validation_and_reconciliation:23">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th measurement (

<math display="inline" id="Data_validation_and_reconciliation:24">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,\ldots,n\,\!
  </annotation>
 </semantics>
</math>

), 

<math display="inline" id="Data_validation_and_reconciliation:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <msup>
      <mi>y</mi>
      <mo>*</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <times></times>
      </apply>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x,y^{*})=0\,\!
  </annotation>
 </semantics>
</math>

 are the 

<math display="inline" id="Data_validation_and_reconciliation:26">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 process equality constraints and 

<math display="inline" id="Data_validation_and_reconciliation:27">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>min</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>max</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mi>min</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mi>max</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <min></min>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <max></max>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <min></min>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <max></max>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{\min},x_{\max},y_{\min},y_{\max}\,\!
  </annotation>
 </semantics>
</math>

 are the bounds on the measured and unmeasured variables.</p>

<p>The term 

<math display="inline" id="Data_validation_and_reconciliation:28">
 <semantics>
  <msup>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mrow>
      <msubsup>
       <mi>y</mi>
       <mi>i</mi>
       <mo>*</mo>
      </msubsup>
      <mo>-</mo>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <msub>
      <mi>σ</mi>
      <mi>i</mi>
     </msub>
    </mfrac>
    <mo>)</mo>
   </mrow>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\frac{y_{i}^{*}-y_{i}}{\sigma_{i}}\right)^{2}\,\!
  </annotation>
 </semantics>
</math>

 is called the <em>penalty</em> of measurement <em>i</em>. The objective function is the sum of the penalties, which will be denoted in the following by 

<math display="inline" id="Data_validation_and_reconciliation:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>y</mi>
      <mo>*</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <msup>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <msubsup>
         <mi>y</mi>
         <mi>i</mi>
         <mo>*</mo>
        </msubsup>
        <mo>-</mo>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <msub>
        <mi>σ</mi>
        <mi>i</mi>
       </msub>
      </mfrac>
      <mo>)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <times></times>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
         <times></times>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(y^{*})=\sum_{i=1}^{n}\left(\frac{y_{i}^{*}-y_{i}}{\sigma_{i}}\right)^{2}
  </annotation>
 </semantics>
</math>

.</p>

<p>In other words, one wants to minimize the overall correction (measured in the least squares term) that is needed in order to satisfy the <a href="constraint_(mathematics)" title="wikilink">system constraints</a>. Additionally, each least squares term is weighted by the <a href="standard_deviation" title="wikilink">standard deviation</a> of the corresponding measurement.</p>
<h3 id="redundancy">Redundancy</h3>

<p><a class="uri" href="File:sensor_red.jpg|Sensor">File:sensor_red.jpg|Sensor</a> redundancy arising from multiple sensors of the same quantity at the same time at the same place. <a class="uri" href="File:topological_red.jpg|Topological">File:topological_red.jpg|Topological</a> redundancy arising from model information, using the mass conservation constraint 

<math display="inline" id="Data_validation_and_reconciliation:30">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mrow>
    <mi>b</mi>
    <mo>+</mo>
    <mi>c</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <apply>
     <plus></plus>
     <ci>b</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=b+c\,\!
  </annotation>
 </semantics>
</math>

, for example one can calculate 

<math display="inline" id="Data_validation_and_reconciliation:31">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\,\!
  </annotation>
 </semantics>
</math>

, when 

<math display="inline" id="Data_validation_and_reconciliation:32">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Data_validation_and_reconciliation:33">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\,\!
  </annotation>
 </semantics>
</math>

 are known.</p>

<p>Data reconciliation relies strongly on the concept of redundancy to correct the measurements as little as possible in order to satisfy the process constraints. Here, redundancy is defined differently from <a href="Redundancy_(information_theory)" title="wikilink">redundancy in information theory</a>. Instead, redundancy arises from combining sensor data with the model (algebraic constraints), sometimes more specifically called "spatial redundancy",<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> "analytical redundancy", or "topological redundancy".</p>

<p>Redundancy can be due to <a href="redundancy_(engineering)" title="wikilink">sensor redundancy</a>, where sensors are duplicated in order to have more than one measurement of the same quantity. Redundancy also arises when a single variable can be estimated in several independent ways from separate sets of measurements at a given time or time averaging period, using the algebraic constraints.</p>

<p>Redundancy is linked to the concept of <a class="uri" href="observability" title="wikilink">observability</a>. A variable (or system) is observable if the models and sensor measurements can be used to uniquely determine its value (system state). A sensor is redundant if its removal causes no loss of observability. Rigorous definitions of observability, calculability, and redundancy, along with criteria for determining it, were established by Stanley and Mah,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> for these cases with set constraints such as algebraic equations and inequalities. Next, we illustrate some special cases:</p>

<p>Topological redundancy is intimately linked with the <a href="degrees_of_freedom_(physics_and_chemistry)" title="wikilink">degrees of freedom</a> (

<math display="inline" id="Data_validation_and_reconciliation:34">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>o</mi>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>o</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   dof\,\!
  </annotation>
 </semantics>
</math>

) of a mathematical system,<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> i.e. the minimum number of pieces of information (i.e. measurements) that are required in order to calculate all of the system variables. For instance, in the example above the flow conservation requires that 

<math display="inline" id="Data_validation_and_reconciliation:35">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mrow>
    <mi>b</mi>
    <mo>+</mo>
    <mpadded width="+1.7pt">
     <mi>c</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <apply>
     <plus></plus>
     <ci>b</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=b+c\,
  </annotation>
 </semantics>
</math>

. One needs to know the value of two of the 3 variables in order to calculate the third one. The degrees of freedom for the model in that case is equal to 2. At least 2 measurements are needed to estimate all the variables, and 3 would be needed for redundancy.</p>

<p>When speaking about topological redundancy we have to distinguish between measured and unmeasured variables. In the following let us denote by 

<math display="inline" id="Data_validation_and_reconciliation:36">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,\!
  </annotation>
 </semantics>
</math>

 the unmeasured variables and 

<math display="inline" id="Data_validation_and_reconciliation:37">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\,\!
  </annotation>
 </semantics>
</math>

 the measured variables. Then the system of the process constraints becomes 

<math display="inline" id="Data_validation_and_reconciliation:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x,y)=0\,\!
  </annotation>
 </semantics>
</math>

, which is a nonlinear system in 

<math display="inline" id="Data_validation_and_reconciliation:39">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\,\!
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Data_validation_and_reconciliation:40">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,\!
  </annotation>
 </semantics>
</math>

. If the system 

<math display="inline" id="Data_validation_and_reconciliation:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x,y)=0\,\!
  </annotation>
 </semantics>
</math>

 is calculable with the 

<math display="inline" id="Data_validation_and_reconciliation:42">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>n</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\,
  </annotation>
 </semantics>
</math>

 measurements given, then the level of topological redundancy is defined as 

<math display="inline" id="Data_validation_and_reconciliation:43">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mi>e</mi>
    <mi>d</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mrow>
     <mi>d</mi>
     <mi>o</mi>
     <mi>f</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>e</ci>
     <ci>d</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>o</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   red=n-dof\,\!
  </annotation>
 </semantics>
</math>

, i.e. the number of additional measurements that are at hand on top of those measurements which are required in order to just calculate the system. Another way of viewing the level of redundancy is to use the definition of 

<math display="inline" id="Data_validation_and_reconciliation:44">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>o</mi>
   <mpadded width="+1.7pt">
    <mi>f</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>o</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   dof\,
  </annotation>
 </semantics>
</math>

, which is the difference between the number of variables (measured and unmeasured) and the number of equations. Then one gets</p>

<p>

<math display="inline" id="Data_validation_and_reconciliation:45">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>r</mi>
     <mi>e</mi>
     <mi>d</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mrow>
      <mi>d</mi>
      <mi>o</mi>
      <mi>f</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mi>m</mi>
       </mrow>
       <mo>-</mo>
       <mi>p</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>p</mi>
     <mo>-</mo>
     <mi>m</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>e</ci>
      <ci>d</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>o</ci>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <ci>m</ci>
       </apply>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <ci>p</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle red=n-dof=n-(n+m-p)=p-m,
  </annotation>
 </semantics>
</math>


</p>

<p>i.e. the redundancy is the difference between the number of equations 

<math display="inline" id="Data_validation_and_reconciliation:46">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>p</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,
  </annotation>
 </semantics>
</math>

 and the number of unmeasured variables 

<math display="inline" id="Data_validation_and_reconciliation:47">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>m</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\,
  </annotation>
 </semantics>
</math>

. The level of total redundancy is the sum of sensor redundancy and topological redundancy. We speak of positive redundancy if the system is calculable and the total redundancy is positive. One can see that the level of topological redundancy merely depends on the number of equations (the more equations the higher the redundancy) and the number of unmeasured variables (the more unmeasured variables, the lower the redundancy) and not on the number of measured variables.</p>

<p>Simple counts of variables, equations, and measurements are inadequate for many systems, breaking down for several reasons: (a) Portions of a system might have redundancy, while others do not, and some portions might not even be possible to calculate, and (b) Nonlinearities can lead to different conclusions at different operating points. As an example, consider the following system with 4 streams and 2 units.</p>
<h4 id="example-of-calculable-and-non-calculable-systems">Example of calculable and non-calculable systems</h4>

<p><a class="uri" href="File:calculable_system.jpg|Calculable">File:calculable_system.jpg|Calculable</a> system, from 

<math display="inline" id="Data_validation_and_reconciliation:48">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\,\!
  </annotation>
 </semantics>
</math>

 one can compute 

<math display="inline" id="Data_validation_and_reconciliation:49">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\,\!
  </annotation>
 </semantics>
</math>


, and knowing 

<math display="inline" id="Data_validation_and_reconciliation:50">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 yields 

<math display="inline" id="Data_validation_and_reconciliation:51">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\,\!
  </annotation>
 </semantics>
</math>

. <a class="uri" href="File:uncalculable_system.jpg|non-calculable">File:uncalculable_system.jpg|non-calculable</a> system, knowing 

<math display="inline" id="Data_validation_and_reconciliation:52">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\,\!
  </annotation>
 </semantics>
</math>

 does not give information about 

<math display="inline" id="Data_validation_and_reconciliation:53">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Data_validation_and_reconciliation:54">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\,\!
  </annotation>
 </semantics>
</math>


.</p>

<p>We incorporate only flow conservation constraints and obtain 

<math display="inline" id="Data_validation_and_reconciliation:55">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>+</mo>
    <mi>b</mi>
   </mrow>
   <mo>=</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a+b=c\,\!
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Data_validation_and_reconciliation:56">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=d\,\!
  </annotation>
 </semantics>
</math>

. It is possible that the system 

<math display="inline" id="Data_validation_and_reconciliation:57">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x,y)=0\,\!
  </annotation>
 </semantics>
</math>

 is not calculable, even though 

<math display="inline" id="Data_validation_and_reconciliation:58">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mo>-</mo>
    <mi>m</mi>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <minus></minus>
     <ci>p</ci>
     <ci>m</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p-m\geq 0\,\!
  </annotation>
 </semantics>
</math>

.</p>

<p>If we have measurements for 

<math display="inline" id="Data_validation_and_reconciliation:59">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\,\!
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Data_validation_and_reconciliation:60">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\,\!
  </annotation>
 </semantics>
</math>

, but not for 

<math display="inline" id="Data_validation_and_reconciliation:61">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Data_validation_and_reconciliation:62">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\,\!
  </annotation>
 </semantics>
</math>

, then the system cannot be calculated (knowing 

<math display="inline" id="Data_validation_and_reconciliation:63">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\,\!
  </annotation>
 </semantics>
</math>

 does not give information about 

<math display="inline" id="Data_validation_and_reconciliation:64">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Data_validation_and_reconciliation:65">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\,\!
  </annotation>
 </semantics>
</math>

). On the other hand, if 

<math display="inline" id="Data_validation_and_reconciliation:66">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Data_validation_and_reconciliation:67">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\,\!
  </annotation>
 </semantics>
</math>

 are known, but not 

<math display="inline" id="Data_validation_and_reconciliation:68">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\,\!
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Data_validation_and_reconciliation:69">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\,\!
  </annotation>
 </semantics>
</math>


, then the system can be calculated.</p>

<p>In 1981, observability and redundancy criteria were proven for these sorts of flow networks involving only mass and energy balance constraints.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> After combining all the plant inputs and outputs into an "environment node", loss of observability corresponds to cycles of unmeasured streams. That is seen in the second case above, where streams a and b are in a cycle of unmeasured streams. Redundancy classification follows, by testing for a path of unmeasured streams, since that would lead to an unmeasured cycle if the measurement was removed. Measurements c and d are redundant in the second case above, even though part of the system is unobservable.</p>
<h3 id="benefits">Benefits</h3>

<p>Redundancy can be used as a source of information to cross-check and correct the measurements 

<math display="inline" id="Data_validation_and_reconciliation:70">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\,\!
  </annotation>
 </semantics>
</math>

 and increase their accuracy and precision: on the one hand they reconciled Further, the data reconciliation problem presented above also includes unmeasured variables 

<math display="inline" id="Data_validation_and_reconciliation:71">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,\!
  </annotation>
 </semantics>
</math>

. Based on information redundancy, estimates for these unmeasured variables can be calculated along with their accuracies. In industrial processes these unmeasured variables that data reconciliation provides are referred to as <a href="soft_sensor" title="wikilink">soft sensors</a> or virtual sensors, where hardware sensors are not installed.</p>
<h2 id="data-validation">Data validation</h2>

<p>Data validation denotes all validation and verification actions before and after the reconciliation step.</p>
<h3 id="data-filtering">Data filtering</h3>

<p>Data filtering denotes the process of treating measured data such that the values become meaningful and lie within the range of expected values. Data filtering is necessary before the reconciliation process in order to increase robustness of the reconciliation step. There are several ways of data filtering, for example taking the <a class="uri" href="average" title="wikilink">average</a> of several measured values over a well-defined time period.</p>
<h3 id="result-validation">Result validation</h3>

<p>Result validation is the set of validation or verification actions taken after the reconciliation process and it takes into account measured and unmeasured variables as well as reconciled values. Result validation covers, but is not limited to, penalty analysis for determining the reliability of the reconciliation, or bound checks to ensure that the reconciled values lie in a certain range, e.g. the temperature has to be within some reasonable bounds.</p>
<h3 id="gross-error-detection">Gross error detection</h3>

<p>Result validation may include statistical tests to validate the reliability of the reconciled values, by checking whether <a href="systematic_error" title="wikilink">gross errors</a> exist in the set of measured values. These tests can be for example</p>
<ul>
<li>the chi square test (global test)</li>
<li>the individual test.</li>
</ul>

<p>If no gross errors exist in the set of measured values, then each penalty term in the objective function is a <a href="normal_distribution" title="wikilink">random variable</a> that is normally distributed with mean equal to 0 and variance equal to 1. By consequence, the objective function is a random variable which follows a <a href="chi-square_distribution" title="wikilink">chi-square distribution</a>, since it is the sum of the square of normally distributed random variables. Comparing the value of the objective function 

<math display="inline" id="Data_validation_and_reconciliation:72">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>y</mi>
     <mo>*</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(y^{*})\,\!
  </annotation>
 </semantics>
</math>

 with a given <a class="uri" href="percentile" title="wikilink">percentile</a> 

<math display="inline" id="Data_validation_and_reconciliation:73">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>P</mi>
    <mi>α</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{\alpha}\,
  </annotation>
 </semantics>
</math>

 of the probability density function of a chi-square distribution (e.g. the 95th percentile for a 95% confidence) gives an indication of whether a gross error exists: If 

<math display="inline" id="Data_validation_and_reconciliation:74">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>y</mi>
      <mo>*</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <msub>
    <mi>P</mi>
    <mn>95</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <times></times>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">95</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(y^{*})\leq P_{95}
  </annotation>
 </semantics>
</math>


, then no gross errors exist with 95% probability. The chi square test gives only a rough indication about the existence of gross errors, and it is easy to conduct: one only has to compare the value of the objective function with the critical value of the chi square distribution.</p>

<p>The individual test compares each penalty term in the objective function with the critical values of the normal distribution. If the 

<math display="inline" id="Data_validation_and_reconciliation:75">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th penalty term is outside the 95% confidence interval of the normal distribution, then there is reason to believe that this measurement has a gross error.</p>
<h2 id="advanced-data-validation-and-reconciliation">Advanced data validation and reconciliation</h2>

<p>Advanced data validation and reconciliation (DVR) is an integrated approach of combining data reconciliation and data validation techniques, which is characterized by</p>
<ul>
<li>complex models incorporating besides mass balances also thermodynamics, momentum balances, equilibria constraints, hydrodynamics etc.</li>
<li>gross error remediation techniques to ensure meaningfulness of the reconciled values,</li>
<li>robust algorithms for solving the reconciliation problem.</li>
</ul>
<h3 id="thermodynamic-models">Thermodynamic models</h3>

<p>Simple models include mass balances only. When adding thermodynamic constraints such as <a href="First_law_of_thermodynamics" title="wikilink">heat balances</a> to the model, its scope and the level of <a href="Data_redundancy" title="wikilink">redundancy</a> increases. Indeed, as we have seen above, the level of redundancy is defined as 

<math display="inline" id="Data_validation_and_reconciliation:76">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>-</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>p</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p-m
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Data_validation_and_reconciliation:77">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is the number of equations. Including energy balances means adding equations to the system, which results in a higher level of redundancy (provided that enough measurements are available, or equivalently, not too many variables are unmeasured).</p>
<h3 id="gross-error-remediation">Gross error remediation</h3>

<p><a href="image:scheme_reconciliation.jpg" title="wikilink">thumb|350px|The workflow of an advanced data validation and reconciliation process.</a> Gross errors are measurement systematic errors that may <a class="uri" href="bias" title="wikilink">bias</a> the reconciliation results. Therefore it is important to identify and eliminate these gross errors from the reconciliation process. After the reconciliation <a href="statistical_tests" title="wikilink">statistical tests</a> can be applied that indicate whether or not a gross error does exist somewhere in the set of measurements. These techniques of gross error remediation are based on two concepts:</p>
<ul>
<li>gross error elimination</li>
<li>gross error relaxation.</li>
</ul>

<p>Gross error elimination determines one measurement that is biased by a systematic error and discards this measurement from the data set. The determination of the measurement to be discarded is based on different kinds of penalty terms that express how much the measured values deviate from the reconciled values. Once the gross errors are detected they are discarded from the measurements and the reconciliation can be done without these faulty measurements that spoil the reconciliation process. If needed, the elimination is repeated until no gross error exists in the set of measurements.</p>

<p>Gross error relaxation targets at relaxing the estimate for the uncertainty of suspicious measurements so that the reconciled value is in the 95% confidence interval. Relaxation typically finds application when it is not possible to determine which measurement around one unit is responsible for the gross error (equivalence of gross errors). Then measurement uncertainties of the measurements involved are increased.</p>

<p>It is important to note that the remediation of gross errors reduces the quality of the reconciliation, either the redundancy decreases (elimination) or the uncertainty of the measured. Therefore it can only be applied when the initial level of redundancy is high enough to ensure that the data reconciliation can still be done (see Section 2,<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a>).</p>
<h3 id="workflow">Workflow</h3>

<p>Advanced DVR solutions offer an integration of the techniques mentioned above:</p>
<ol>
<li>data acquisition from data historian, data base or manual inputs</li>
<li>data validation and filtering of raw measurements</li>
<li>data reconciliation of filtered measurements</li>
<li>result verification
<ul>
<li>range check</li>
<li>gross error remediation (and go back to step 3)</li>
</ul></li>
<li>result storage (raw measurements together with reconciled values)</li>
</ol>

<p>The result of an advanced DVR procedure is a coherent set of validated and reconciled process data.</p>
<h2 id="applications">Applications</h2>

<p>DVR finds application mainly in industry sectors where either measurements are not accurate or even non-existing, like for example in the <a href="upstream_(fossil-fuel_industry)" title="wikilink">upstream sector</a> where <a href="flow_measurement" title="wikilink">flow meters</a> are difficult or expensive to position (see <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a>); or where accurate data is of high importance, for example for security reasons in <a href="nuclear_power_plants" title="wikilink">nuclear power plants</a> (see <a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a>). Another field of application is <a href="Performance_test_(assessment)" title="wikilink">performance and process monitoring</a> (see <a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a>) in oil refining or in the chemical industry.</p>

<p>As DVR enables to calculate estimates even for unmeasured variables in a reliable way, the German Engineering Society (VDI Gesellschaft Energie und Umwelt) has accepted the technology of DVR as a means to replace expensive sensors in the nuclear power industry (see VDI norm 2048,<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a>).</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Process_simulation" title="wikilink">Process simulation</a></li>
<li><a href="Pinch_analysis" title="wikilink">Pinch analysis</a></li>
<li><a href="Industrial_processes" title="wikilink">Industrial processes</a></li>
<li><a href="Chemical_engineering" title="wikilink">Chemical engineering</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Alexander, Dave, Tannar, Dave &amp; Wasik, Larry "Mill Information System uses Dynamic Data Reconciliation for Accurate Energy Accounting" TAPPI Fall Conference 2007.<a href="http://www.tappi.org/Downloads/Conference-Papers/2007/07EPE/07epe87.aspx">1</a></li>
<li>Rankin, J. &amp; Wasik, L. "Dynamic Data Reconciliation of Batch Pulping Processes (for On-Line Prediction)" PAPTAC Spring Conference 2009.</li>
<li>S. Narasimhan, C. Jordache, <em>Data reconciliation and gross error detection: an intelligent use of process data</em>, Golf Publishing Company, Houston, 2000.</li>
<li>V. Veverka, F. Madron, 'Material and Energy Balancing in the Process Industries'', Elsevier Science BV, Amsterdam, 1997.</li>
<li>J. Romagnoli, M.C. Sanchez, <em>Data processing and reconciliation for chemical process operations</em>, Academic Press, 2000.</li>
</ul>
<h2 id="external-links">External links</h2>

<p>Some research groups working on data reconciliation:</p>
<ul>
<li><a href="http://www.aurelsystems.com/">Chemical Process Simulation Software Tools &amp; Services , Vancouver, Canada</a></li>
<li><a href="http://www.ou.edu/class/che-design/">Process and product design – Plant operations, University of Oklahoma, USA</a></li>
<li><a href="http://www.che.iitm.ac.in/~naras/research.htm">Indian Institute of Technology Madras, India</a></li>
<li><a href="http://www.lassc.ulg.ac.be/">Laboratory for Analysis and Synthesis of Chemical Systems, University of Liege, Belgium</a></li>
<li><a href="http://leni.epfl.ch/">Industrial Energy Systems Laboratory, Lausanne, Switzerland</a></li>
</ul>

<p>White papers:</p>
<ul>
<li><a href="http://www.aurelsystems.com/papers.htm">Mill Information System uses Dynamic Data Reconciliation for Accurate Energy Accounting</a></li>
<li><a href="http://www.aurelsystems.com/papers.htm">Dynamic Data Reconciliation of Batch Pulping Processes (for On-Line Prediction)</a></li>
<li><a href="http://gregstanleyandassociates.com/whitepapers/DataRec/datarec.htm">Data Reconciliation, Observability, and Redundancy papers</a></li>
</ul>

<p>"</p>

<p><a href="Category:Data_management" title="wikilink">Category:Data management</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.isa-95.com/">"ISA-95: the international standard for the integration of enterprise and control systems"</a>. isa-95.com.<a href="#fnref1">↩</a></li>
<li id="fn2">D.R. Kuehn, H. Davidson, <em>Computer Control II. Mathematics of Control</em>, Chem. Eng. Process 57: 44–47, 1961.<a href="#fnref2">↩</a></li>
<li id="fn3">V. Vaclavek, <em>Studies on System Engineering I. On the Application of the Calculus of the Observations of Calculations of Chemical Engineering Balances</em>, Coll. Czech Chem. Commun 34: 3653, 1968.<a href="#fnref3">↩</a></li>
<li id="fn4">V. Vaclavek, M. Loucka, <em>Selection of Measurements Necessary to Achieve Multicomponent Mass Balances in Chemical Plant</em>, Chem. Eng. Sci. 31: 1199–1205, 1976.<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="http://gregstanleyandassociates.com/ReconciliationRectificationProcessData-1976.pdf">R.S.H. Mah, G.M. Stanley, D.W. Downing, <em>Reconciliation and Rectification of Process Flow and Inventory Data</em>, Ind. &amp; Eng. Chem. Proc. Des. Dev. 15: 175–183, 1976.</a><a href="#fnref5">↩</a></li>
<li id="fn6">J.C. Knepper, J.W. Gorman, <em>Statistical Analysis of Constrained Data Sets</em>, AiChE Journal 26: 260–164, 1961.<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="http://gregstanleyandassociates.com/AIChEJ-1977-EstimationInProcessNetworks.pdf">G.M. Stanley and R.S.H. Mah, <em>Estimation of Flows and Temperatures in Process Networks</em>, AIChE Journal 23: 642–650, 1977.</a><a href="#fnref7">↩</a></li>
<li id="fn8">P. Joris, B. Kalitventzeff, <em>Process measurements analysis and validation</em>, Proc. CEF’87: Use Comput. Chem. Eng., Italy, 41–46, 1987.<a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10">M.J. Liebman, T.F. Edgar, L.S. Lasdon, <em>Efficient Data Reconciliation and Estimation for Dynamic Processes Using Nonlinear Programming Techniques</em>, Computers Chem. Eng. 16: 963–986, 1992.<a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"><a href="http://gregstanleyandassociates.com/whitepapers/DataRec/CES-1981a-ObservabilityRedundancy.pdf">Stanley G.M. and Mah, R.S.H., "Observability and Redundancy in Process Data Estimation, Chem. Engng. Sci. 36, 259 (1981)</a><a href="#fnref12">↩</a></li>
<li id="fn13">VDI-Gesellschaft Energie und Umwelt, "Guidelines - VDI 2048 Blatt 1 - Uncertainties of measurements at acceptance tests for energy conversion and power plants - Fundamentals", <em><a href="http://www.vdi.de/401.0.html">Association of German Engineers</a></em>, 2000.<a href="#fnref13">↩</a></li>
<li id="fn14"><a href="http://gregstanleyandassociates.com/whitepapers/DataRec/CES-1981b-ObservabilityRedundancyProcessNetworks.pdf">Stanley G.M., and Mah R.S.H., "Observability and Redundancy Classification in Process Networks", Chem. Engng. Sci. 36, 1941 (1981)</a><a href="#fnref14">↩</a></li>
<li id="fn15"></li>
<li id="fn16">P. Delava, E. Maréchal, B. Vrielynck, B. Kalitventzeff (1999), <em>Modelling of a Crude Oil Distillation Unit in Term of Data Reconciliation with ASTM or TBP Curves as Direct Input – Application : Crude Oil Preheating Train</em>, Proceedings of ESCAPE-9 conference, Budapest, May 31-June 2, 1999, supplementary volume, p. 17-20.<a href="#fnref16">↩</a></li>
<li id="fn17">M. Langenstein, J. Jansky, B. Laipple (2004), <em>Finding Megawatts in nuclear power plants with process data validation</em>, Proceedings of ICONE12, Arlington, USA, April 25–29, 2004.<a href="#fnref17">↩</a></li>
<li id="fn18">Th. Amand, G. Heyen, B. Kalitventzeff, <em>Plant Monitoring and Fault Detection: Synergy between Data Reconciliation and Principal Component Analysis</em>, Comp. and Chem, Eng. 25, p. 501-507, 2001.<a href="#fnref18">↩</a></li>
<li id="fn19"></li>
</ol>
</section>
</body>
</html>
