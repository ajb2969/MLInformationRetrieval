<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1772">Matched filter</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Matched filter</h1>
<hr>In [[signal processing]], a '''matched filter''' (originally known as a '''North filter'''<ref>After D.O. North who first introduced the concept: {{cite journal|title = An analysis of the factors which determine signal/noise discrimination in pulsed carrier systems|author = North, D. O. |journal


<p><code>= RCA Labs., Princeton, NJ, Rep. PTR-6C|year = 1963}}) is obtained by </code><a href="cross-correlation" title="wikilink"><code>correlating</code></a><code> a known </code><a href="signal_(electrical_engineering)" title="wikilink"><code>signal</code></a><code>, or </code><em><code>template</code></em><code>, with an unknown signal to detect the presence of the template in the unknown signal. This is equivalent to </code><a href="convolution" title="wikilink"><code>convolving</code></a><code> the unknown signal with a </code><a href="complex_conjugate" title="wikilink"><code>conjugated</code></a><code> time-reversed version of the template. The matched filter is the optimal </code><a href="linear_filter" title="wikilink"><code>linear</code> <code>filter</code></a><code> for maximizing the </code><a href="signal_to_noise_ratio" title="wikilink"><code>signal</code> <code>to</code> <code>noise</code> <code>ratio</code></a><code> (SNR) in the presence of additive </code><a href="stochastic_process" title="wikilink"><code>stochastic</code></a><code> </code><a href="noise_(signal_processing)" title="wikilink"><code>noise</code></a><code>. Matched filters are commonly used in </code><a href="radar" title="wikilink"><code>radar</code></a><code>, in which a known signal is sent out, and the reflected signal is examined for common elements of the out-going signal. </code><a href="Pulse_compression" title="wikilink"><code>Pulse</code> <code>compression</code></a><code> is an example of matched filtering. It is so called  because impulse response is matched to input pulse signals.  Two-dimensional matched filters are commonly used in </code><a href="image_processing" title="wikilink"><code>image</code> <code>processing</code></a><code>, e.g., to improve SNR for X-ray.</code></p>

<p>Matched filtering is a demodulation technique with LTI filters to maximize SNR.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="derivation-of-the-matched-filter-impulse-response">Derivation of the matched filter impulse response</h2>

<p>The following section derives the matched filter for a <a href="discrete-time_system" title="wikilink">discrete-time system</a>. The derivation for a <a href="continuous-time" title="wikilink">continuous-time system</a> is similar, with summations replaced with integrals.</p>

<p>The matched filter is the linear filter, 

<math display="inline" id="Matched_filter:0">
<semantics>
<mi>h</mi>
<annotation-xml encoding="MathML-Content">
<ci>h</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   h
  </annotation>
</semantics>
</math>

, that maximizes the output <a href="signal-to-noise_ratio" title="wikilink">signal-to-noise ratio</a>.</p>

<p>
<math display="block" id="Matched_filter:1">
<semantics>
<mrow>
<mrow>
<mrow>
<mpadded lspace="5pt" width="+5pt">
<mi>y</mi>
</mpadded>
<mrow>
<mo stretchy="false">[</mo>
<mi>n</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</mrow>
<mi mathvariant="normal">∞</mi>
</munderover>
<mrow>
<mi>h</mi>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
<mi>x</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>k</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>y</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>n</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>k</ci>
<apply>
<minus></minus>
<infinity></infinity>
</apply>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<times></times>
<ci>h</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<minus></minus>
<ci>n</ci>
<ci>k</ci>
</apply>
</apply>
<ci>x</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ y[n]=\sum_{k=-\infty}^{\infty}h[n-k]x[k].
  </annotation>
</semantics>
</math>
</p>

<p>Though we most often express filters as the <a href="impulse_response" title="wikilink">impulse response</a> of convolution systems, as above (see <a href="LTI_system_theory" title="wikilink">LTI system theory</a>), it is easiest to think of the matched filter in the context of the <a href="inner_product" title="wikilink">inner product</a>, which we will see shortly.</p>

<p>We can derive the linear filter that maximizes output signal-to-noise ratio by invoking a geometric argument. The intuition behind the matched filter relies on correlating the received signal (a vector) with a filter (another vector) that is parallel with the signal, maximizing the inner product. This enhances the signal. When we consider the additive stochastic noise, we have the additional challenge of minimizing the output due to noise by choosing a filter that is orthogonal to the noise.</p>

<p>Let us formally define the problem. We seek a filter, 

<math display="inline" id="Matched_filter:2">
<semantics>
<mi>h</mi>
<annotation-xml encoding="MathML-Content">
<ci>h</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   h
  </annotation>
</semantics>
</math>

, such that we maximize the output signal-to-noise ratio, where the output is the inner product of the filter and the observed signal 

<math display="inline" id="Matched_filter:3">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>


.</p>

<p>Our observed signal consists of the desirable signal 

<math display="inline" id="Matched_filter:4">
<semantics>
<mi>s</mi>
<annotation-xml encoding="MathML-Content">
<ci>s</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   s
  </annotation>
</semantics>
</math>

 and additive noise 

<math display="inline" id="Matched_filter:5">
<semantics>
<mi>v</mi>
<annotation-xml encoding="MathML-Content">
<ci>v</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   v
  </annotation>
</semantics>
</math>

:</p>

<p>
<math display="block" id="Matched_filter:6">
<semantics>
<mrow>
<mrow>
<mpadded lspace="5pt" width="+5pt">
<mi>x</mi>
</mpadded>
<mo>=</mo>
<mrow>
<mi>s</mi>
<mo>+</mo>
<mi>v</mi>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>x</ci>
<apply>
<plus></plus>
<ci>s</ci>
<ci>v</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ x=s+v.\,
  </annotation>
</semantics>
</math>
</p>

<p>Let us define the covariance matrix of the noise, reminding ourselves that this matrix has <a href="Hermitian_matrix" title="wikilink">Hermitian symmetry</a>, a property that will become useful in the derivation:</p>

<p>
<math display="block" id="Matched_filter:7">
<semantics>
<mrow>
<msub>
<mpadded lspace="5pt" width="+5pt">
<mi>R</mi>
</mpadded>
<mi>v</mi>
</msub>
<mo>=</mo>
<mrow>
<mi>E</mi>
<mrow>
<mo stretchy="false">{</mo>
<mrow>
<mi>v</mi>
<msup>
<mi>v</mi>
<mi mathvariant="normal">H</mi>
</msup>
</mrow>
<mo rspace="4.2pt" stretchy="false">}</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<times></times>
<ci>E</ci>
<set>
<apply>
<times></times>
<ci>v</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>v</ci>
<ci>normal-H</ci>
</apply>
</apply>
</set>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ R_{v}=E\{vv^{\mathrm{H}}\}\,
  </annotation>
</semantics>
</math>
</p>

<p>where 

<math display="inline" id="Matched_filter:8">
<semantics>
<msup>
<mi>v</mi>
<mi mathvariant="normal">H</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>v</ci>
<ci>normal-H</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   v^{\mathrm{H}}
  </annotation>
</semantics>
</math>


 denotes the <a href="conjugate_transpose" title="wikilink">conjugate transpose</a> of 

<math display="inline" id="Matched_filter:9">
<semantics>
<mi>v</mi>
<annotation-xml encoding="MathML-Content">
<ci>v</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   v
  </annotation>
</semantics>
</math>

, and 

<math display="inline" id="Matched_filter:10">
<semantics>
<mi>E</mi>
<annotation-xml encoding="MathML-Content">
<ci>E</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   E
  </annotation>
</semantics>
</math>

 denotes <a href="Expected_value" title="wikilink">expectation</a>. Let us call our output, 

<math display="inline" id="Matched_filter:11">
<semantics>
<mi>y</mi>
<annotation-xml encoding="MathML-Content">
<ci>y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   y
  </annotation>
</semantics>
</math>

, the inner product of our filter and the observed signal such that</p>

<p>
<math display="block" id="Matched_filter:12">
<semantics>
<mrow>
<mrow>
<mpadded lspace="5pt" width="+5pt">
<mi>y</mi>
</mpadded>
<mo>=</mo>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</mrow>
<mi mathvariant="normal">∞</mi>
</munderover>
<mrow>
<msup>
<mi>h</mi>
<mo>*</mo>
</msup>
<mrow>
<mo stretchy="false">[</mo>
<mi>k</mi>
<mo stretchy="false">]</mo>
</mrow>
<mi>x</mi>
<mrow>
<mo stretchy="false">[</mo>
<mi>k</mi>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msup>
<mi>h</mi>
<mi mathvariant="normal">H</mi>
</msup>
<mi>x</mi>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<msup>
<mi>h</mi>
<mi mathvariant="normal">H</mi>
</msup>
<mi>s</mi>
</mrow>
<mo>+</mo>
<mrow>
<msup>
<mi>h</mi>
<mi mathvariant="normal">H</mi>
</msup>
<mi>v</mi>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mi>y</mi>
<mi>s</mi>
</msub>
<mo>+</mo>
<msub>
<mi>y</mi>
<mi>v</mi>
</msub>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<ci>y</ci>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>k</ci>
<apply>
<minus></minus>
<infinity></infinity>
</apply>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<times></times>
</apply>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>k</ci>
</apply>
<ci>x</ci>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<ci>normal-H</ci>
</apply>
<ci>x</ci>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<ci>normal-H</ci>
</apply>
<ci>s</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<ci>normal-H</ci>
</apply>
<ci>v</ci>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>s</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>v</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ y=\sum_{k=-\infty}^{\infty}h^{*}[k]x[k]=h^{\mathrm{H}}x=h^{\mathrm{H}}s+h^{%
\mathrm{H}}v=y_{s}+y_{v}.
  </annotation>
</semantics>
</math>
</p>

<p>We now define the signal-to-noise ratio, which is our objective function, to be the ratio of the power of the output due to the desired signal to the power of the output due to the noise:</p>

<p>
<math display="block" id="Matched_filter:13">
<semantics>
<mrow>
<mrow>
<mi>SNR</mi>
<mo>=</mo>
<mfrac>
<msup>
<mrow>
<mo stretchy="false">|</mo>
<msub>
<mi>y</mi>
<mi>s</mi>
</msub>
<mo stretchy="false">|</mo>
</mrow>
<mn>2</mn>
</msup>
<mrow>
<mi>E</mi>
<mrow>
<mo stretchy="false">{</mo>
<msup>
<mrow>
<mo stretchy="false">|</mo>
<msub>
<mi>y</mi>
<mi>v</mi>
</msub>
<mo stretchy="false">|</mo>
</mrow>
<mn>2</mn>
</msup>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
</mfrac>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>SNR</ci>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>s</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<ci>E</ci>
<set>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>v</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</set>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{SNR}=\frac{|y_{s}|^{2}}{E\{|y_{v}|^{2}\}}.
  </annotation>
</semantics>
</math>
</p>

<p>We rewrite the above:</p>

<p>
<math display="block" id="Matched_filter:14">
<semantics>
<mrow>
<mrow>
<mi>SNR</mi>
<mo>=</mo>
<mfrac>
<msup>
<mrow>
<mo stretchy="false">|</mo>
<mrow>
<msup>
<mi>h</mi>
<mi mathvariant="normal">H</mi>
</msup>
<mi>s</mi>
</mrow>
<mo stretchy="false">|</mo>
</mrow>
<mn>2</mn>
</msup>
<mrow>
<mi>E</mi>
<mrow>
<mo stretchy="false">{</mo>
<msup>
<mrow>
<mo stretchy="false">|</mo>
<mrow>
<msup>
<mi>h</mi>
<mi mathvariant="normal">H</mi>
</msup>
<mi>v</mi>
</mrow>
<mo stretchy="false">|</mo>
</mrow>
<mn>2</mn>
</msup>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
</mfrac>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>SNR</ci>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<ci>normal-H</ci>
</apply>
<ci>s</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<ci>E</ci>
<set>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<ci>normal-H</ci>
</apply>
<ci>v</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</set>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{SNR}=\frac{|h^{\mathrm{H}}s|^{2}}{E\{|h^{\mathrm{H}}v|^{2}\}}.
  </annotation>
</semantics>
</math>
</p>

<p>We wish to maximize this quantity by choosing 

<math display="inline" id="Matched_filter:15">
<semantics>
<mi>h</mi>
<annotation-xml encoding="MathML-Content">
<ci>h</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   h
  </annotation>
</semantics>
</math>

. Expanding the denominator of our objective function, we have</p>

<p>
<math display="block" id="Matched_filter:16">
<semantics>
<mrow>
<mrow>
<mrow>
<mpadded lspace="5pt" width="+5pt">
<mi>E</mi>
</mpadded>
<mrow>
<mo stretchy="false">{</mo>
<msup>
<mrow>
<mo stretchy="false">|</mo>
<mrow>
<msup>
<mi>h</mi>
<mi mathvariant="normal">H</mi>
</msup>
<mi>v</mi>
</mrow>
<mo stretchy="false">|</mo>
</mrow>
<mn>2</mn>
</msup>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>E</mi>
<mrow>
<mo stretchy="false">{</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msup>
<mi>h</mi>
<mi mathvariant="normal">H</mi>
</msup>
<mi>v</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msup>
<mi>h</mi>
<mi mathvariant="normal">H</mi>
</msup>
<mi>v</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">H</mi>
</msup>
</mrow>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msup>
<mi>h</mi>
<mi mathvariant="normal">H</mi>
</msup>
<mi>E</mi>
<mrow>
<mo stretchy="false">{</mo>
<mrow>
<mi>v</mi>
<msup>
<mi>v</mi>
<mi mathvariant="normal">H</mi>
</msup>
</mrow>
<mo stretchy="false">}</mo>
</mrow>
<mi>h</mi>
</mrow>
<mo>=</mo>
<mrow>
<msup>
<mi>h</mi>
<mi mathvariant="normal">H</mi>
</msup>
<msub>
<mi>R</mi>
<mi>v</mi>
</msub>
<mi>h</mi>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<ci>E</ci>
<set>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<ci>normal-H</ci>
</apply>
<ci>v</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</set>
</apply>
<apply>
<times></times>
<ci>E</ci>
<set>
<apply>
<times></times>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<ci>normal-H</ci>
</apply>
<ci>v</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<ci>normal-H</ci>
</apply>
<ci>v</ci>
</apply>
<ci>normal-H</ci>
</apply>
</apply>
</set>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<ci>normal-H</ci>
</apply>
<ci>E</ci>
<set>
<apply>
<times></times>
<ci>v</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>v</ci>
<ci>normal-H</ci>
</apply>
</apply>
</set>
<ci>h</ci>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<ci>normal-H</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<ci>h</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ E\{|h^{\mathrm{H}}v|^{2}\}=E\{(h^{\mathrm{H}}v){(h^{\mathrm{H}}v)}^{\mathrm{%
H}}\}=h^{\mathrm{H}}E\{vv^{\mathrm{H}}\}h=h^{\mathrm{H}}R_{v}h.\,
  </annotation>
</semantics>
</math>
</p>

<p>Now, our 

<math display="inline" id="Matched_filter:17">
<semantics>
<mi>SNR</mi>
<annotation-xml encoding="MathML-Content">
<ci>SNR</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{SNR}
  </annotation>
</semantics>
</math>

 becomes</p>

<p>
<math display="block" id="Matched_filter:18">
<semantics>
<mrow>
<mrow>
<mi>SNR</mi>
<mo>=</mo>
<mfrac>
<msup>
<mrow>
<mo stretchy="false">|</mo>
<mrow>
<msup>
<mi>h</mi>
<mi mathvariant="normal">H</mi>
</msup>
<mi>s</mi>
</mrow>
<mo stretchy="false">|</mo>
</mrow>
<mn>2</mn>
</msup>
<mrow>
<msup>
<mi>h</mi>
<mi mathvariant="normal">H</mi>
</msup>
<msub>
<mi>R</mi>
<mi>v</mi>
</msub>
<mi>h</mi>
</mrow>
</mfrac>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>SNR</ci>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<ci>normal-H</ci>
</apply>
<ci>s</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<ci>normal-H</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<ci>h</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{SNR}=\frac{|h^{\mathrm{H}}s|^{2}}{h^{\mathrm{H}}R_{v}h}.
  </annotation>
</semantics>
</math>
</p>

<p>We will rewrite this expression with some matrix manipulation. The reason for this seemingly counterproductive measure will become evident shortly. Exploiting the Hermitian symmetry of the covariance matrix 

<math display="inline" id="Matched_filter:19">
<semantics>
<msub>
<mi>R</mi>
<mi>v</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   R_{v}
  </annotation>
</semantics>
</math>

, we can write</p>

<p>
<math display="block" id="Matched_filter:20">
<semantics>
<mrow>
<mrow>
<mi>SNR</mi>
<mo>=</mo>
<mfrac>
<msup>
<mrow>
<mo stretchy="false">|</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</msubsup>
<mi>h</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">H</mi>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">|</mo>
</mrow>
<mn>2</mn>
</msup>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</msubsup>
<mi>h</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">H</mi>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</msubsup>
<mi>h</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>SNR</ci>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>h</ci>
</apply>
<ci>normal-H</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<ci>s</ci>
</apply>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>h</ci>
</apply>
<ci>normal-H</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>h</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{SNR}=\frac{|{(R_{v}^{1/2}h)}^{\mathrm{H}}(R_{v}^{-1/2}s)|^{2}}{{(R_{v}%
^{1/2}h)}^{\mathrm{H}}(R_{v}^{1/2}h)},
  </annotation>
</semantics>
</math>
</p>

<p>We would like to find an upper bound on this expression. To do so, we first recognize a form of the <a href="Cauchy-Schwarz_inequality" title="wikilink">Cauchy-Schwarz inequality</a>:</p>

<p>
<math display="block" id="Matched_filter:21">
<semantics>
<mrow>
<mrow>
<msup>
<mrow>
<mo lspace="7.5pt" stretchy="false">|</mo>
<mrow>
<msup>
<mi>a</mi>
<mi mathvariant="normal">H</mi>
</msup>
<mi>b</mi>
</mrow>
<mo stretchy="false">|</mo>
</mrow>
<mn>2</mn>
</msup>
<mo>≤</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msup>
<mi>a</mi>
<mi mathvariant="normal">H</mi>
</msup>
<mi>a</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msup>
<mi>b</mi>
<mi mathvariant="normal">H</mi>
</msup>
<mi>b</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<leq></leq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>a</ci>
<ci>normal-H</ci>
</apply>
<ci>b</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>a</ci>
<ci>normal-H</ci>
</apply>
<ci>a</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>b</ci>
<ci>normal-H</ci>
</apply>
<ci>b</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ |a^{\mathrm{H}}b|^{2}\leq(a^{\mathrm{H}}a)(b^{\mathrm{H}}b),\,
  </annotation>
</semantics>
</math>
</p>

<p>which is to say that the square of the inner product of two vectors can only be as large as the product of the individual inner products of the vectors. This concept returns to the intuition behind the matched filter: this upper bound is achieved when the two vectors 

<math display="inline" id="Matched_filter:22">
<semantics>
<mi>a</mi>
<annotation-xml encoding="MathML-Content">
<ci>a</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   a
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Matched_filter:23">
<semantics>
<mi>b</mi>
<annotation-xml encoding="MathML-Content">
<ci>b</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   b
  </annotation>
</semantics>
</math>

 are parallel. We resume our derivation by expressing the upper bound on our 

<math display="inline" id="Matched_filter:24">
<semantics>
<mi>SNR</mi>
<annotation-xml encoding="MathML-Content">
<ci>SNR</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{SNR}
  </annotation>
</semantics>
</math>

 in light of the geometric inequality above:</p>

<p>
<math display="block" id="Matched_filter:25">
<semantics>
<mrow>
<mrow>
<mi>SNR</mi>
<mo>=</mo>
<mfrac>
<msup>
<mrow>
<mo stretchy="false">|</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</msubsup>
<mi>h</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">H</mi>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">|</mo>
</mrow>
<mn>2</mn>
</msup>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</msubsup>
<mi>h</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">H</mi>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</msubsup>
<mi>h</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
<mo>≤</mo>
<mfrac>
<mrow>
<mrow>
<mo>[</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</msubsup>
<mi>h</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">H</mi>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</msubsup>
<mi>h</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>]</mo>
</mrow>
<mrow>
<mo>[</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">H</mi>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>]</mo>
</mrow>
</mrow>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</msubsup>
<mi>h</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">H</mi>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</msubsup>
<mi>h</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<ci>SNR</ci>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>h</ci>
</apply>
<ci>normal-H</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<ci>s</ci>
</apply>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>h</ci>
</apply>
<ci>normal-H</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>h</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<leq></leq>
<share href="#.cmml">
</share>
<apply>
<divide></divide>
<apply>
<times></times>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>h</ci>
</apply>
<ci>normal-H</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>h</ci>
</apply>
</apply>
</apply>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<ci>s</ci>
</apply>
<ci>normal-H</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<ci>s</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>h</ci>
</apply>
<ci>normal-H</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>h</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{SNR}=\frac{|{(R_{v}^{1/2}h)}^{\mathrm{H}}(R_{v}^{-1/2}s)|^{2}}{{(R_{v}%
^{1/2}h)}^{\mathrm{H}}(R_{v}^{1/2}h)}\leq\frac{\left[{(R_{v}^{1/2}h)}^{\mathrm%
{H}}(R_{v}^{1/2}h)\right]\left[{(R_{v}^{-1/2}s)}^{\mathrm{H}}(R_{v}^{-1/2}s)%
\right]}{{(R_{v}^{1/2}h)}^{\mathrm{H}}(R_{v}^{1/2}h)}.
  </annotation>
</semantics>
</math>
</p>

<p>Our valiant matrix manipulation has now paid off. We see that the expression for our upper bound can be greatly simplified:</p>

<p>
<math display="block" id="Matched_filter:26">
<semantics>
<mrow>
<mrow>
<mi>SNR</mi>
<mo>=</mo>
<mfrac>
<msup>
<mrow>
<mo stretchy="false">|</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</msubsup>
<mi>h</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">H</mi>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">|</mo>
</mrow>
<mn>2</mn>
</msup>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</msubsup>
<mi>h</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">H</mi>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</msubsup>
<mi>h</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
<mo>≤</mo>
<mrow>
<msup>
<mi>s</mi>
<mi mathvariant="normal">H</mi>
</msup>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<ci>SNR</ci>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>h</ci>
</apply>
<ci>normal-H</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<ci>s</ci>
</apply>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>h</ci>
</apply>
<ci>normal-H</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>h</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<leq></leq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>s</ci>
<ci>normal-H</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>s</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{SNR}=\frac{|{(R_{v}^{1/2}h)}^{\mathrm{H}}(R_{v}^{-1/2}s)|^{2}}{{(R_{v}%
^{1/2}h)}^{\mathrm{H}}(R_{v}^{1/2}h)}\leq s^{\mathrm{H}}R_{v}^{-1}s.
  </annotation>
</semantics>
</math>
</p>

<p>We can achieve this upper bound if we choose,</p>

<p>
<math display="block" id="Matched_filter:27">
<semantics>
<mrow>
<mrow>
<msubsup>
<mpadded lspace="5pt" width="+5pt">
<mi>R</mi>
</mpadded>
<mi>v</mi>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</msubsup>
<mi>h</mi>
</mrow>
<mo>=</mo>
<mrow>
<mi>α</mi>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>h</ci>
</apply>
<apply>
<times></times>
<ci>α</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<ci>s</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ R_{v}^{1/2}h=\alpha R_{v}^{-1/2}s
  </annotation>
</semantics>
</math>
</p>

<p>where 

<math display="inline" id="Matched_filter:28">
<semantics>
<mi>α</mi>
<annotation-xml encoding="MathML-Content">
<ci>α</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \alpha
  </annotation>
</semantics>
</math>

 is an arbitrary real number. To verify this, we plug into our expression for the output 

<math display="inline" id="Matched_filter:29">
<semantics>
<mi>SNR</mi>
<annotation-xml encoding="MathML-Content">
<ci>SNR</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{SNR}
  </annotation>
</semantics>
</math>

:</p>

<p>
<math display="block" id="Matched_filter:30">
<semantics>
<mrow>
<mrow>
<mi>SNR</mi>
<mo>=</mo>
<mfrac>
<msup>
<mrow>
<mo stretchy="false">|</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</msubsup>
<mi>h</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">H</mi>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">|</mo>
</mrow>
<mn>2</mn>
</msup>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</msubsup>
<mi>h</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">H</mi>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</msubsup>
<mi>h</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
<mo>=</mo>
<mfrac>
<mrow>
<msup>
<mi>α</mi>
<mn>2</mn>
</msup>
<msup>
<mrow>
<mo stretchy="false">|</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">H</mi>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">|</mo>
</mrow>
<mn>2</mn>
</msup>
</mrow>
<mrow>
<msup>
<mi>α</mi>
<mn>2</mn>
</msup>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi mathvariant="normal">H</mi>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mn>2</mn>
</mrow>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
<mo>=</mo>
<mfrac>
<msup>
<mrow>
<mo stretchy="false">|</mo>
<mrow>
<msup>
<mi>s</mi>
<mi mathvariant="normal">H</mi>
</msup>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
<mo stretchy="false">|</mo>
</mrow>
<mn>2</mn>
</msup>
<mrow>
<msup>
<mi>s</mi>
<mi mathvariant="normal">H</mi>
</msup>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
</mfrac>
<mo>=</mo>
<mrow>
<msup>
<mi>s</mi>
<mi mathvariant="normal">H</mi>
</msup>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<ci>SNR</ci>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>h</ci>
</apply>
<ci>normal-H</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<ci>s</ci>
</apply>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>h</ci>
</apply>
<ci>normal-H</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>h</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<divide></divide>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>α</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<ci>s</ci>
</apply>
<ci>normal-H</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<ci>s</ci>
</apply>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>α</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<ci>s</ci>
</apply>
<ci>normal-H</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<ci>s</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>s</ci>
<ci>normal-H</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>s</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>s</ci>
<ci>normal-H</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>s</ci>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>s</ci>
<ci>normal-H</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>s</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{SNR}=\frac{|{(R_{v}^{1/2}h)}^{\mathrm{H}}(R_{v}^{-1/2}s)|^{2}}{{(R_{v}%
^{1/2}h)}^{\mathrm{H}}(R_{v}^{1/2}h)}=\frac{\alpha^{2}|{(R_{v}^{-1/2}s)}^{%
\mathrm{H}}(R_{v}^{-1/2}s)|^{2}}{\alpha^{2}{(R_{v}^{-1/2}s)}^{\mathrm{H}}(R_{v%
}^{-1/2}s)}=\frac{|s^{\mathrm{H}}R_{v}^{-1}s|^{2}}{s^{\mathrm{H}}R_{v}^{-1}s}=%
s^{\mathrm{H}}R_{v}^{-1}s.
  </annotation>
</semantics>
</math>
</p>

<p>Thus, our optimal matched filter is</p>

<p>
<math display="block" id="Matched_filter:31">
<semantics>
<mrow>
<mrow>
<mpadded lspace="5pt" width="+5pt">
<mi>h</mi>
</mpadded>
<mo>=</mo>
<mrow>
<mi>α</mi>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>h</ci>
<apply>
<times></times>
<ci>α</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>s</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ h=\alpha R_{v}^{-1}s.
  </annotation>
</semantics>
</math>
</p>

<p>We often choose to normalize the expected value of the power of the filter output due to the noise to unity. That is, we constrain</p>

<p>
<math display="block" id="Matched_filter:32">
<semantics>
<mrow>
<mrow>
<mpadded lspace="5pt" width="+5pt">
<mi>E</mi>
</mpadded>
<mrow>
<mo stretchy="false">{</mo>
<msup>
<mrow>
<mo stretchy="false">|</mo>
<msub>
<mi>y</mi>
<mi>v</mi>
</msub>
<mo stretchy="false">|</mo>
</mrow>
<mn>2</mn>
</msup>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
<mo>=</mo>
<mpadded width="+1.7pt">
<mn>1.</mn>
</mpadded>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>E</ci>
<set>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>v</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</set>
</apply>
<cn type="float">1.</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ E\{|y_{v}|^{2}\}=1.\,
  </annotation>
</semantics>
</math>
</p>

<p>This constraint implies a value of 

<math display="inline" id="Matched_filter:33">
<semantics>
<mi>α</mi>
<annotation-xml encoding="MathML-Content">
<ci>α</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \alpha
  </annotation>
</semantics>
</math>

, for which we can solve:</p>

<p>
<math display="block" id="Matched_filter:34">
<semantics>
<mrow>
<mrow>
<mrow>
<mpadded lspace="5pt" width="+5pt">
<mi>E</mi>
</mpadded>
<mrow>
<mo stretchy="false">{</mo>
<msup>
<mrow>
<mo stretchy="false">|</mo>
<msub>
<mi>y</mi>
<mi>v</mi>
</msub>
<mo stretchy="false">|</mo>
</mrow>
<mn>2</mn>
</msup>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msup>
<mi>α</mi>
<mn>2</mn>
</msup>
<msup>
<mi>s</mi>
<mi mathvariant="normal">H</mi>
</msup>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<ci>E</ci>
<set>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>v</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</set>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>α</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>s</ci>
<ci>normal-H</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>s</ci>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ E\{|y_{v}|^{2}\}=\alpha^{2}s^{\mathrm{H}}R_{v}^{-1}s=1,
  </annotation>
</semantics>
</math>
</p>

<p>yielding</p>

<p>
<math display="block" id="Matched_filter:35">
<semantics>
<mrow>
<mrow>
<mpadded lspace="5pt" width="+5pt">
<mi>α</mi>
</mpadded>
<mo>=</mo>
<mfrac>
<mn>1</mn>
<msqrt>
<mrow>
<msup>
<mi>s</mi>
<mi mathvariant="normal">H</mi>
</msup>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
</msqrt>
</mfrac>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>α</ci>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<root></root>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>s</ci>
<ci>normal-H</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>s</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ \alpha=\frac{1}{\sqrt{s^{\mathrm{H}}R_{v}^{-1}s}},
  </annotation>
</semantics>
</math>
</p>

<p>giving us our normalized filter,</p>

<p>
<math display="block" id="Matched_filter:36">
<semantics>
<mrow>
<mrow>
<mpadded lspace="5pt" width="+5pt">
<mi>h</mi>
</mpadded>
<mo>=</mo>
<mrow>
<mfrac>
<mn>1</mn>
<msqrt>
<mrow>
<msup>
<mi>s</mi>
<mi mathvariant="normal">H</mi>
</msup>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
</msqrt>
</mfrac>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>h</ci>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<root></root>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>s</ci>
<ci>normal-H</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>s</ci>
</apply>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>s</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ h=\frac{1}{\sqrt{s^{\mathrm{H}}R_{v}^{-1}s}}R_{v}^{-1}s.
  </annotation>
</semantics>
</math>
</p>

<p>If we care to write the impulse response of the filter for the convolution system, it is simply the complex conjugate time reversal of 

<math display="inline" id="Matched_filter:37">
<semantics>
<mi>h</mi>
<annotation-xml encoding="MathML-Content">
<ci>h</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   h
  </annotation>
</semantics>
</math>

.</p>

<p>Though we have derived the matched filter in discrete time, we can extend the concept to continuous-time systems if we replace 

<math display="inline" id="Matched_filter:38">
<semantics>
<msub>
<mi>R</mi>
<mi>v</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   R_{v}
  </annotation>
</semantics>
</math>

 with the continuous-time <a class="uri" href="autocorrelation" title="wikilink">autocorrelation</a> function of the noise, assuming a continuous signal 

<math display="inline" id="Matched_filter:39">
<semantics>
<mrow>
<mi>s</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>s</ci>
<ci>t</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   s(t)
  </annotation>
</semantics>
</math>

, continuous noise 

<math display="inline" id="Matched_filter:40">
<semantics>
<mrow>
<mi>v</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>v</ci>
<ci>t</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   v(t)
  </annotation>
</semantics>
</math>

, and a continuous filter 

<math display="inline" id="Matched_filter:41">
<semantics>
<mrow>
<mi>h</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>h</ci>
<ci>t</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   h(t)
  </annotation>
</semantics>
</math>

.</p>
<h2 id="alternative-derivation-of-the-matched-filter">Alternative derivation of the matched filter</h2>

<p>Alternatively, we may solve for the matched filter by solving our maximization problem with a Lagrangian. Again, the matched filter endeavors to maximize the output signal-to-noise ratio (

<math display="inline" id="Matched_filter:42">
<semantics>
<mi>SNR</mi>
<annotation-xml encoding="MathML-Content">
<ci>SNR</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{SNR}
  </annotation>
</semantics>
</math>

) of a filtered deterministic signal in stochastic additive noise. The observed sequence, again, is</p>

<p>
<math display="block" id="Matched_filter:43">
<semantics>
<mrow>
<mrow>
<mpadded lspace="5pt" width="+5pt">
<mi>x</mi>
</mpadded>
<mo>=</mo>
<mrow>
<mi>s</mi>
<mo>+</mo>
<mi>v</mi>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>x</ci>
<apply>
<plus></plus>
<ci>s</ci>
<ci>v</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ x=s+v,\,
  </annotation>
</semantics>
</math>
</p>

<p>with the noise covariance matrix,</p>

<p>
<math display="block" id="Matched_filter:44">
<semantics>
<mrow>
<mrow>
<msub>
<mpadded lspace="5pt" width="+5pt">
<mi>R</mi>
</mpadded>
<mi>v</mi>
</msub>
<mo>=</mo>
<mrow>
<mi>E</mi>
<mrow>
<mo stretchy="false">{</mo>
<mrow>
<mi>v</mi>
<msup>
<mi>v</mi>
<mi mathvariant="normal">H</mi>
</msup>
</mrow>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<times></times>
<ci>E</ci>
<set>
<apply>
<times></times>
<ci>v</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>v</ci>
<ci>normal-H</ci>
</apply>
</apply>
</set>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ R_{v}=E\{vv^{\mathrm{H}}\}.\,
  </annotation>
</semantics>
</math>
</p>

<p>The signal-to-noise ratio is</p>

<p>
<math display="block" id="Matched_filter:45">
<semantics>
<mrow>
<mrow>
<mi>SNR</mi>
<mo>=</mo>
<mfrac>
<msup>
<mrow>
<mo stretchy="false">|</mo>
<msub>
<mi>y</mi>
<mi>s</mi>
</msub>
<mo stretchy="false">|</mo>
</mrow>
<mn>2</mn>
</msup>
<mrow>
<mi>E</mi>
<mrow>
<mo stretchy="false">{</mo>
<msup>
<mrow>
<mo stretchy="false">|</mo>
<msub>
<mi>y</mi>
<mi>v</mi>
</msub>
<mo stretchy="false">|</mo>
</mrow>
<mn>2</mn>
</msup>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
</mfrac>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>SNR</ci>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>s</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<ci>E</ci>
<set>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>v</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</set>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{SNR}=\frac{|y_{s}|^{2}}{E\{|y_{v}|^{2}\}}.
  </annotation>
</semantics>
</math>
</p>

<p>Evaluating the expression in the numerator, we have</p>

<p>
<math display="block" id="Matched_filter:46">
<semantics>
<mrow>
<mrow>
<msup>
<mrow>
<mo lspace="7.5pt" stretchy="false">|</mo>
<msub>
<mi>y</mi>
<mi>s</mi>
</msub>
<mo stretchy="false">|</mo>
</mrow>
<mn>2</mn>
</msup>
<mo>=</mo>
<mrow>
<mmultiscripts>
<mi>y</mi>
<mi>s</mi>
<none></none>
<none></none>
<mi mathvariant="normal">H</mi>
</mmultiscripts>
<msub>
<mi>y</mi>
<mi>s</mi>
</msub>
</mrow>
<mo>=</mo>
<mrow>
<msup>
<mi>h</mi>
<mi mathvariant="normal">H</mi>
</msup>
<mi>s</mi>
<msup>
<mi>s</mi>
<mi mathvariant="normal">H</mi>
</msup>
<mi>h</mi>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>s</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>s</ci>
</apply>
<ci>normal-H</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>s</ci>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<ci>normal-H</ci>
</apply>
<ci>s</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>s</ci>
<ci>normal-H</ci>
</apply>
<ci>h</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ |y_{s}|^{2}={y_{s}}^{\mathrm{H}}y_{s}=h^{\mathrm{H}}ss^{\mathrm{H}}h.\,
  </annotation>
</semantics>
</math>
</p>

<p>and in the denominator,</p>

<p>
<math display="block" id="Matched_filter:47">
<semantics>
<mrow>
<mrow>
<mrow>
<mpadded lspace="5pt" width="+5pt">
<mi>E</mi>
</mpadded>
<mrow>
<mo stretchy="false">{</mo>
<msup>
<mrow>
<mo stretchy="false">|</mo>
<msub>
<mi>y</mi>
<mi>v</mi>
</msub>
<mo stretchy="false">|</mo>
</mrow>
<mn>2</mn>
</msup>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>E</mi>
<mrow>
<mo stretchy="false">{</mo>
<mrow>
<mmultiscripts>
<mi>y</mi>
<mi>v</mi>
<none></none>
<none></none>
<mi mathvariant="normal">H</mi>
</mmultiscripts>
<msub>
<mi>y</mi>
<mi>v</mi>
</msub>
</mrow>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>E</mi>
<mrow>
<mo stretchy="false">{</mo>
<mrow>
<msup>
<mi>h</mi>
<mi mathvariant="normal">H</mi>
</msup>
<mi>v</mi>
<msup>
<mi>v</mi>
<mi mathvariant="normal">H</mi>
</msup>
<mi>h</mi>
</mrow>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msup>
<mi>h</mi>
<mi mathvariant="normal">H</mi>
</msup>
<msub>
<mi>R</mi>
<mi>v</mi>
</msub>
<mi>h</mi>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<ci>E</ci>
<set>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>v</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</set>
</apply>
<apply>
<times></times>
<ci>E</ci>
<set>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>v</ci>
</apply>
<ci>normal-H</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>v</ci>
</apply>
</apply>
</set>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<ci>E</ci>
<set>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<ci>normal-H</ci>
</apply>
<ci>v</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>v</ci>
<ci>normal-H</ci>
</apply>
<ci>h</ci>
</apply>
</set>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<ci>normal-H</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<ci>h</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ E\{|y_{v}|^{2}\}=E\{{y_{v}}^{\mathrm{H}}y_{v}\}=E\{h^{\mathrm{H}}vv^{\mathrm%
{H}}h\}=h^{\mathrm{H}}R_{v}h.\,
  </annotation>
</semantics>
</math>
</p>

<p>The signal-to-noise ratio becomes</p>

<p>
<math display="block" id="Matched_filter:48">
<semantics>
<mrow>
<mrow>
<mi>SNR</mi>
<mo>=</mo>
<mfrac>
<mrow>
<msup>
<mi>h</mi>
<mi mathvariant="normal">H</mi>
</msup>
<mi>s</mi>
<msup>
<mi>s</mi>
<mi mathvariant="normal">H</mi>
</msup>
<mi>h</mi>
</mrow>
<mrow>
<msup>
<mi>h</mi>
<mi mathvariant="normal">H</mi>
</msup>
<msub>
<mi>R</mi>
<mi>v</mi>
</msub>
<mi>h</mi>
</mrow>
</mfrac>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>SNR</ci>
<apply>
<divide></divide>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<ci>normal-H</ci>
</apply>
<ci>s</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>s</ci>
<ci>normal-H</ci>
</apply>
<ci>h</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<ci>normal-H</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<ci>h</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{SNR}=\frac{h^{\mathrm{H}}ss^{\mathrm{H}}h}{h^{\mathrm{H}}R_{v}h}.
  </annotation>
</semantics>
</math>
</p>

<p>If we now constrain the denominator to be 1, the problem of maximizing 

<math display="inline" id="Matched_filter:49">
<semantics>
<mi>SNR</mi>
<annotation-xml encoding="MathML-Content">
<ci>SNR</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathrm{SNR}
  </annotation>
</semantics>
</math>

 is reduced to maximizing the numerator. We can then formulate the problem using a <a href="Lagrange_multipliers" title="wikilink">Lagrange multiplier</a>:</p>

<p>
<math display="block" id="Matched_filter:50">
<semantics>
<mrow>
<mrow>
<msup>
<mpadded lspace="5pt" width="+5pt">
<mi>h</mi>
</mpadded>
<mi mathvariant="normal">H</mi>
</msup>
<msub>
<mi>R</mi>
<mi>v</mi>
</msub>
<mi>h</mi>
</mrow>
<mo>=</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<ci>normal-H</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<ci>h</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ h^{\mathrm{H}}R_{v}h=1
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Matched_filter:51">
<semantics>
<mrow>
<mpadded lspace="5pt" width="+5pt">
<mi class="ltx_font_mathcaligraphic">ℒ</mi>
</mpadded>
<mo>=</mo>
<mrow>
<mrow>
<msup>
<mi>h</mi>
<mi mathvariant="normal">H</mi>
</msup>
<mi>s</mi>
<msup>
<mi>s</mi>
<mi mathvariant="normal">H</mi>
</msup>
<mi>h</mi>
</mrow>
<mo>+</mo>
<mrow>
<mi>λ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mrow>
<msup>
<mi>h</mi>
<mi mathvariant="normal">H</mi>
</msup>
<msub>
<mi>R</mi>
<mi>v</mi>
</msub>
<mi>h</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>ℒ</ci>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<ci>normal-H</ci>
</apply>
<ci>s</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>s</ci>
<ci>normal-H</ci>
</apply>
<ci>h</ci>
</apply>
<apply>
<times></times>
<ci>λ</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<ci>normal-H</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<ci>h</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ \mathcal{L}=h^{\mathrm{H}}ss^{\mathrm{H}}h+\lambda(1-h^{\mathrm{H}}R_{v}h)
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Matched_filter:52">
<semantics>
<mrow>
<mrow>
<msub>
<mo lspace="7.5pt">∇</mo>
<msup>
<mi>h</mi>
<mo>*</mo>
</msup>
</msub>
<mi class="ltx_font_mathcaligraphic">ℒ</mi>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mi>s</mi>
<msup>
<mi>s</mi>
<mi mathvariant="normal">H</mi>
</msup>
<mi>h</mi>
</mrow>
<mo>-</mo>
<mrow>
<mi>λ</mi>
<msub>
<mi>R</mi>
<mi>v</mi>
</msub>
<mi>h</mi>
</mrow>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>normal-∇</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<times></times>
</apply>
</apply>
<ci>ℒ</ci>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>s</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>s</ci>
<ci>normal-H</ci>
</apply>
<ci>h</ci>
</apply>
<apply>
<times></times>
<ci>λ</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<ci>h</ci>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<cn type="integer">0</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ \nabla_{h^{*}}\mathcal{L}=ss^{\mathrm{H}}h-\lambda R_{v}h=0
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Matched_filter:53">
<semantics>
<mrow>
<mrow>
<mrow>
<mo lspace="7.5pt" stretchy="false">(</mo>
<mrow>
<mi>s</mi>
<msup>
<mi>s</mi>
<mi mathvariant="normal">H</mi>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>h</mi>
</mrow>
<mo>=</mo>
<mrow>
<mi>λ</mi>
<msub>
<mi>R</mi>
<mi>v</mi>
</msub>
<mi>h</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<times></times>
<ci>s</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>s</ci>
<ci>normal-H</ci>
</apply>
</apply>
<ci>h</ci>
</apply>
<apply>
<times></times>
<ci>λ</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<ci>h</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ (ss^{\mathrm{H}})h=\lambda R_{v}h
  </annotation>
</semantics>
</math>
</p>

<p>which we recognize as a generalized eigenvalue problem</p>

<p>
<math display="block" id="Matched_filter:54">
<semantics>
<mrow>
<mrow>
<mrow>
<msup>
<mpadded lspace="5pt" width="+5pt">
<mi>h</mi>
</mpadded>
<mi mathvariant="normal">H</mi>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>s</mi>
<msup>
<mi>s</mi>
<mi mathvariant="normal">H</mi>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>h</mi>
</mrow>
<mo>=</mo>
<mrow>
<mi>λ</mi>
<msup>
<mi>h</mi>
<mi mathvariant="normal">H</mi>
</msup>
<msub>
<mi>R</mi>
<mi>v</mi>
</msub>
<mi>h</mi>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<ci>normal-H</ci>
</apply>
<apply>
<times></times>
<ci>s</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>s</ci>
<ci>normal-H</ci>
</apply>
</apply>
<ci>h</ci>
</apply>
<apply>
<times></times>
<ci>λ</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>h</ci>
<ci>normal-H</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<ci>h</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ h^{\mathrm{H}}(ss^{\mathrm{H}})h=\lambda h^{\mathrm{H}}R_{v}h.
  </annotation>
</semantics>
</math>
</p>

<p>Since 

<math display="inline" id="Matched_filter:55">
<semantics>
<mrow>
<mi>s</mi>
<msup>
<mi>s</mi>
<mi mathvariant="normal">H</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>s</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>s</ci>
<ci>normal-H</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   ss^{\mathrm{H}}
  </annotation>
</semantics>
</math>

 is of unit rank, it has only one nonzero eigenvalue. It can be shown that this eigenvalue equals</p>

<p>
<math display="block" id="Matched_filter:56">
<semantics>
<mrow>
<mrow>
<msub>
<mpadded lspace="5pt" width="+5pt">
<mi>λ</mi>
</mpadded>
<mi>max</mi>
</msub>
<mo>=</mo>
<mrow>
<msup>
<mi>s</mi>
<mi mathvariant="normal">H</mi>
</msup>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>λ</ci>
<max></max>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>s</ci>
<ci>normal-H</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>s</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ \lambda_{\max}=s^{\mathrm{H}}R_{v}^{-1}s,
  </annotation>
</semantics>
</math>
</p>

<p>yielding the following optimal matched filter</p>

<p>
<math display="block" id="Matched_filter:57">
<semantics>
<mrow>
<mrow>
<mpadded lspace="5pt" width="+5pt">
<mi>h</mi>
</mpadded>
<mo>=</mo>
<mrow>
<mfrac>
<mn>1</mn>
<msqrt>
<mrow>
<msup>
<mi>s</mi>
<mi mathvariant="normal">H</mi>
</msup>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
</msqrt>
</mfrac>
<msubsup>
<mi>R</mi>
<mi>v</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msubsup>
<mi>s</mi>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>h</ci>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<root></root>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>s</ci>
<ci>normal-H</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>s</ci>
</apply>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>s</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ h=\frac{1}{\sqrt{s^{\mathrm{H}}R_{v}^{-1}s}}R_{v}^{-1}s.
  </annotation>
</semantics>
</math>
</p>

<p>This is the same result found in the previous section.</p>
<h2 id="the-matched-filter-as-a-least-squares-estimator">The matched filter as a least squares estimator</h2>

<p>Matched filtering can also be interpreted as a least squares estimator for the optimal location and scaling of a given model or template. Once again, let the observed sequence be defined as</p>

<p>
<math display="block" id="Matched_filter:58">
<semantics>
<mrow>
<mrow>
<msub>
<mpadded lspace="5pt" width="+5pt">
<mi>x</mi>
</mpadded>
<mi>k</mi>
</msub>
<mo>=</mo>
<mrow>
<msub>
<mi>s</mi>
<mi>k</mi>
</msub>
<mo>+</mo>
<msub>
<mi>v</mi>
<mi>k</mi>
</msub>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>k</ci>
</apply>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>s</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>v</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ x_{k}=s_{k}+v_{k},\,
  </annotation>
</semantics>
</math>
</p>

<p>where 

<math display="inline" id="Matched_filter:59">
<semantics>
<msub>
<mi>v</mi>
<mi>k</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>v</ci>
<ci>k</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   v_{k}
  </annotation>
</semantics>
</math>

 is uncorrelated zero mean noise. The signal 

<math display="inline" id="Matched_filter:60">
<semantics>
<msub>
<mi>s</mi>
<mi>k</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>s</ci>
<ci>k</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   s_{k}
  </annotation>
</semantics>
</math>

 is assumed to be a scaled and shifted version of a known model sequence 

<math display="inline" id="Matched_filter:61">
<semantics>
<msub>
<mi>f</mi>
<mi>k</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<ci>k</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f_{k}
  </annotation>
</semantics>
</math>

:</p>

<p>
<math display="block" id="Matched_filter:62">
<semantics>
<mrow>
<msub>
<mpadded lspace="5pt" width="+5pt">
<mi>s</mi>
</mpadded>
<mi>k</mi>
</msub>
<mo>=</mo>
<mrow>
<msub>
<mi>μ</mi>
<mn>0</mn>
</msub>
<mo>⋅</mo>
<msub>
<mi>f</mi>
<mrow>
<mi>k</mi>
<mo>-</mo>
<msub>
<mi>j</mi>
<mn>0</mn>
</msub>
</mrow>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>s</ci>
<ci>k</ci>
</apply>
<apply>
<ci>normal-⋅</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>μ</ci>
<cn type="integer">0</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<apply>
<minus></minus>
<ci>k</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>j</ci>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ s_{k}=\mu_{0}\cdot f_{k-j_{0}}
  </annotation>
</semantics>
</math>
</p>

<p>We want to find optimal estimates 

<math display="inline" id="Matched_filter:63">
<semantics>
<msup>
<mi>j</mi>
<mo>*</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>j</ci>
<times></times>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   j^{*}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Matched_filter:64">
<semantics>
<msup>
<mi>μ</mi>
<mo>*</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>μ</ci>
<times></times>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mu^{*}
  </annotation>
</semantics>
</math>

 for the unknown shift 

<math display="inline" id="Matched_filter:65">
<semantics>
<msub>
<mi>j</mi>
<mn>0</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>j</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   j_{0}
  </annotation>
</semantics>
</math>

 and scaling 

<math display="inline" id="Matched_filter:66">
<semantics>
<msub>
<mi>μ</mi>
<mn>0</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>μ</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mu_{0}
  </annotation>
</semantics>
</math>

 by minimizing the least squares residual between the observed sequence 

<math display="inline" id="Matched_filter:67">
<semantics>
<msub>
<mi>x</mi>
<mi>k</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>k</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{k}
  </annotation>
</semantics>
</math>

 and a "probing sequence" 

<math display="inline" id="Matched_filter:68">
<semantics>
<msub>
<mi>h</mi>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>h</ci>
<apply>
<minus></minus>
<ci>j</ci>
<ci>k</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   h_{j-k}
  </annotation>
</semantics>
</math>

:</p>

<p>
<math display="block" id="Matched_filter:69">
<semantics>
<mrow>
<mrow>
<msup>
<mpadded lspace="5pt" width="+5pt">
<mi>j</mi>
</mpadded>
<mo>*</mo>
</msup>
<mo>,</mo>
<msup>
<mi>μ</mi>
<mo>*</mo>
</msup>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mi>arg</mi>
<munder>
<mi>min</mi>
<mrow>
<mi>j</mi>
<mo>,</mo>
<mi>μ</mi>
</mrow>
</munder>
</mrow>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mi>k</mi>
</munder>
<msup>
<mrow>
<mo>(</mo>
<mrow>
<msub>
<mi>x</mi>
<mi>k</mi>
</msub>
<mo>-</mo>
<mrow>
<mi>μ</mi>
<mo>⋅</mo>
<msub>
<mi>h</mi>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
</msub>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
<mn>2</mn>
</msup>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<list>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>j</ci>
<times></times>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>μ</ci>
<times></times>
</apply>
</list>
<apply>
<times></times>
<apply>
<arg></arg>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<min></min>
<list>
<ci>j</ci>
<ci>μ</ci>
</list>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>k</ci>
</apply>
<apply>
<ci>normal-⋅</ci>
<ci>μ</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>h</ci>
<apply>
<minus></minus>
<ci>j</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ j^{*},\mu^{*}=\arg\min_{j,\mu}\sum_{k}\left(x_{k}-\mu\cdot h_{j-k}\right)^{2}
  </annotation>
</semantics>
</math>
</p>

<p>The appropriate 

<math display="inline" id="Matched_filter:70">
<semantics>
<msub>
<mi>h</mi>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>h</ci>
<apply>
<minus></minus>
<ci>j</ci>
<ci>k</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   h_{j-k}
  </annotation>
</semantics>
</math>

 will later turn out to be the matched filter, but is as yet unspecified. Expanding 

<math display="inline" id="Matched_filter:71">
<semantics>
<msub>
<mi>x</mi>
<mi>k</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>k</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{k}
  </annotation>
</semantics>
</math>

 and the square within the sum yields</p>

<p>
<math display="block" id="Matched_filter:72">
<semantics>
<mrow>
<mrow>
<msup>
<mpadded lspace="5pt" width="+5pt">
<mi>j</mi>
</mpadded>
<mo>*</mo>
</msup>
<mo>,</mo>
<msup>
<mi>μ</mi>
<mo>*</mo>
</msup>
</mrow>
<mo>=</mo>
<mrow>
<mi>arg</mi>
<mrow>
<munder>
<mi>min</mi>
<mrow>
<mi>j</mi>
<mo>,</mo>
<mi>μ</mi>
</mrow>
</munder>
<mrow>
<mo>[</mo>
<mrow>
<mrow>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mi>k</mi>
</munder>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>s</mi>
<mi>k</mi>
</msub>
<mo>+</mo>
<msub>
<mi>v</mi>
<mi>k</mi>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
</mrow>
<mo>+</mo>
<mrow>
<msup>
<mi>μ</mi>
<mn>2</mn>
</msup>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mi>k</mi>
</munder>
<msubsup>
<mi>h</mi>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
<mn>2</mn>
</msubsup>
</mrow>
</mrow>
</mrow>
<mo>-</mo>
<mrow>
<mn>2</mn>
<mi>μ</mi>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mi>k</mi>
</munder>
<mrow>
<msub>
<mi>s</mi>
<mi>k</mi>
</msub>
<msub>
<mi>h</mi>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
</msub>
</mrow>
</mrow>
</mrow>
<mo>-</mo>
<mrow>
<mn>2</mn>
<mi>μ</mi>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mi>k</mi>
</munder>
<mrow>
<msub>
<mi>v</mi>
<mi>k</mi>
</msub>
<msub>
<mi>h</mi>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
</msub>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>]</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<list>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>j</ci>
<times></times>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>μ</ci>
<times></times>
</apply>
</list>
<apply>
<arg></arg>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<min></min>
<list>
<ci>j</ci>
<ci>μ</ci>
</list>
</apply>
<apply>
<minus></minus>
<apply>
<plus></plus>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>s</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>v</ci>
<ci>k</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>μ</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>h</ci>
<apply>
<minus></minus>
<ci>j</ci>
<ci>k</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>μ</ci>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>k</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>s</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>h</ci>
<apply>
<minus></minus>
<ci>j</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>μ</ci>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>k</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>v</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>h</ci>
<apply>
<minus></minus>
<ci>j</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ j^{*},\mu^{*}=\arg\min_{j,\mu}\left[\sum_{k}(s_{k}+v_{k})^{2}+\mu^{2}\sum_{k%
}h_{j-k}^{2}-2\mu\sum_{k}s_{k}h_{j-k}-2\mu\sum_{k}v_{k}h_{j-k}\right]
  </annotation>
</semantics>
</math>

.</p>

<p>The first term in brackets is a constant (since the observed signal is given) and has no influence on the optimal solution. The last term has constant expected value because the noise is uncorrelated and has zero mean. We can therefore drop both terms from the optimization. After reversing the sign, we obtain the equivalent optimization problem</p>

<p>
<math display="block" id="Matched_filter:73">
<semantics>
<mrow>
<mrow>
<msup>
<mpadded lspace="5pt" width="+5pt">
<mi>j</mi>
</mpadded>
<mo>*</mo>
</msup>
<mo>,</mo>
<msup>
<mi>μ</mi>
<mo>*</mo>
</msup>
</mrow>
<mo>=</mo>
<mrow>
<mi>arg</mi>
<mrow>
<munder>
<mi>max</mi>
<mrow>
<mi>j</mi>
<mo>,</mo>
<mi>μ</mi>
</mrow>
</munder>
<mrow>
<mo>[</mo>
<mrow>
<mrow>
<mn>2</mn>
<mi>μ</mi>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mi>k</mi>
</munder>
<mrow>
<msub>
<mi>s</mi>
<mi>k</mi>
</msub>
<msub>
<mi>h</mi>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
</msub>
</mrow>
</mrow>
</mrow>
<mo>-</mo>
<mrow>
<msup>
<mi>μ</mi>
<mn>2</mn>
</msup>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mi>k</mi>
</munder>
<msubsup>
<mi>h</mi>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
<mn>2</mn>
</msubsup>
</mrow>
</mrow>
</mrow>
<mo>]</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<list>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>j</ci>
<times></times>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>μ</ci>
<times></times>
</apply>
</list>
<apply>
<arg></arg>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<max></max>
<list>
<ci>j</ci>
<ci>μ</ci>
</list>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>μ</ci>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>k</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>s</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>h</ci>
<apply>
<minus></minus>
<ci>j</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>μ</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>h</ci>
<apply>
<minus></minus>
<ci>j</ci>
<ci>k</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ j^{*},\mu^{*}=\arg\max_{j,\mu}\left[2\mu\sum_{k}s_{k}h_{j-k}-\mu^{2}\sum_{k}%
h_{j-k}^{2}\right]
  </annotation>
</semantics>
</math>

.</p>

<p>Setting the derivative w.r.t. 

<math display="inline" id="Matched_filter:74">
<semantics>
<mi>μ</mi>
<annotation-xml encoding="MathML-Content">
<ci>μ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mu
  </annotation>
</semantics>
</math>

 to zero gives an analytic solution for 

<math display="inline" id="Matched_filter:75">
<semantics>
<msup>
<mi>μ</mi>
<mo>*</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>μ</ci>
<times></times>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mu^{*}
  </annotation>
</semantics>
</math>

:</p>

<p>
<math display="block" id="Matched_filter:76">
<semantics>
<mrow>
<msup>
<mpadded lspace="5pt" width="+5pt">
<mi>μ</mi>
</mpadded>
<mo>*</mo>
</msup>
<mo>=</mo>
<mfrac>
<mrow>
<msub>
<mo largeop="true" symmetric="true">∑</mo>
<mi>k</mi>
</msub>
<mrow>
<msub>
<mi>s</mi>
<mi>k</mi>
</msub>
<msub>
<mi>h</mi>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
</msub>
</mrow>
</mrow>
<mrow>
<msub>
<mo largeop="true" symmetric="true">∑</mo>
<mi>k</mi>
</msub>
<msubsup>
<mi>h</mi>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
<mn>2</mn>
</msubsup>
</mrow>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>μ</ci>
<times></times>
</apply>
<apply>
<divide></divide>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>k</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>s</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>h</ci>
<apply>
<minus></minus>
<ci>j</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>h</ci>
<apply>
<minus></minus>
<ci>j</ci>
<ci>k</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ \mu^{*}=\frac{\sum_{k}s_{k}h_{j-k}}{\sum_{k}h_{j-k}^{2}}
  </annotation>
</semantics>
</math>

.</p>

<p>Inserting this into our objective function yields a reduced maximization problem for just 

<math display="inline" id="Matched_filter:77">
<semantics>
<msup>
<mi>j</mi>
<mo>*</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>j</ci>
<times></times>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   j^{*}
  </annotation>
</semantics>
</math>

:</p>

<p>
<math display="block" id="Matched_filter:78">
<semantics>
<mrow>
<msup>
<mpadded lspace="5pt" width="+5pt">
<mi>j</mi>
</mpadded>
<mo>*</mo>
</msup>
<mo>=</mo>
<mrow>
<mi>arg</mi>
<mrow>
<munder>
<mi>max</mi>
<mi>j</mi>
</munder>
<mfrac>
<msup>
<mrow>
<mo>(</mo>
<mrow>
<msub>
<mo largeop="true" symmetric="true">∑</mo>
<mi>k</mi>
</msub>
<mrow>
<msub>
<mi>s</mi>
<mi>k</mi>
</msub>
<msub>
<mi>h</mi>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
</msub>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
<mn>2</mn>
</msup>
<mrow>
<msub>
<mo largeop="true" symmetric="true">∑</mo>
<mi>k</mi>
</msub>
<msubsup>
<mi>h</mi>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
<mn>2</mn>
</msubsup>
</mrow>
</mfrac>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>j</ci>
<times></times>
</apply>
<apply>
<arg></arg>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<max></max>
<ci>j</ci>
</apply>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>k</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>s</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>h</ci>
<apply>
<minus></minus>
<ci>j</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>h</ci>
<apply>
<minus></minus>
<ci>j</ci>
<ci>k</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ j^{*}=\arg\max_{j}\frac{\left(\sum_{k}s_{k}h_{j-k}\right)^{2}}{\sum_{k}h_{j-%
k}^{2}}
  </annotation>
</semantics>
</math>

.</p>

<p>The numerator can be upper-bounded by means of the <a href="Cauchy-Schwarz_inequality" title="wikilink">Cauchy-Schwarz inequality</a>:</p>

<p>
<math display="block" id="Matched_filter:79">
<semantics>
<mrow>
<mpadded lspace="5pt" width="+5pt">
<mfrac>
<msup>
<mrow>
<mo>(</mo>
<mrow>
<msub>
<mo largeop="true" symmetric="true">∑</mo>
<mi>k</mi>
</msub>
<mrow>
<msub>
<mi>s</mi>
<mi>k</mi>
</msub>
<msub>
<mi>h</mi>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
</msub>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
<mn>2</mn>
</msup>
<mrow>
<msub>
<mo largeop="true" symmetric="true">∑</mo>
<mi>k</mi>
</msub>
<msubsup>
<mi>h</mi>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
<mn>2</mn>
</msubsup>
</mrow>
</mfrac>
</mpadded>
<mo>≤</mo>
<mfrac>
<mrow>
<msub>
<mo largeop="true" symmetric="true">∑</mo>
<mi>k</mi>
</msub>
<mrow>
<msubsup>
<mi>s</mi>
<mi>k</mi>
<mn>2</mn>
</msubsup>
<mo>⋅</mo>
<mrow>
<msub>
<mo largeop="true" symmetric="true">∑</mo>
<mi>k</mi>
</msub>
<msubsup>
<mi>h</mi>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
<mn>2</mn>
</msubsup>
</mrow>
</mrow>
</mrow>
<mrow>
<msub>
<mo largeop="true" symmetric="true">∑</mo>
<mi>k</mi>
</msub>
<msubsup>
<mi>h</mi>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
<mn>2</mn>
</msubsup>
</mrow>
</mfrac>
<mo>=</mo>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mi>k</mi>
</munder>
<msubsup>
<mi>s</mi>
<mi>k</mi>
<mn>2</mn>
</msubsup>
</mrow>
<mo>=</mo>
<mi>const</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<leq></leq>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>k</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>s</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>h</ci>
<apply>
<minus></minus>
<ci>j</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>h</ci>
<apply>
<minus></minus>
<ci>j</ci>
<ci>k</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<apply>
<divide></divide>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>k</ci>
</apply>
<apply>
<ci>normal-⋅</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>s</ci>
<ci>k</ci>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>h</ci>
<apply>
<minus></minus>
<ci>j</ci>
<ci>k</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>h</ci>
<apply>
<minus></minus>
<ci>j</ci>
<ci>k</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>s</ci>
<ci>k</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<ci>const</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ \frac{\left(\sum_{k}s_{k}h_{j-k}\right)^{2}}{\sum_{k}h_{j-k}^{2}}\leq\frac{%
\sum_{k}s_{k}^{2}\cdot\sum_{k}h_{j-k}^{2}}{\sum_{k}h_{j-k}^{2}}=\sum_{k}s_{k}^%
{2}=\mathrm{const}
  </annotation>
</semantics>
</math>

.</p>

<p>The optimization problem assumes its maximum when equality holds in this expression. According to the properties of the Cauchy-Schwarz inequality, this is only possible when</p>

<p>
<math display="block" id="Matched_filter:80">
<semantics>
<mrow>
<msub>
<mpadded lspace="5pt" width="+5pt">
<mi>h</mi>
</mpadded>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
</msub>
<mo>=</mo>
<mrow>
<mi>ν</mi>
<mo>⋅</mo>
<msub>
<mi>s</mi>
<mi>k</mi>
</msub>
</mrow>
<mo>=</mo>
<mrow>
<mi>κ</mi>
<mo>⋅</mo>
<msub>
<mi>f</mi>
<mrow>
<mi>k</mi>
<mo>-</mo>
<msub>
<mi>j</mi>
<mn>0</mn>
</msub>
</mrow>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>h</ci>
<apply>
<minus></minus>
<ci>j</ci>
<ci>k</ci>
</apply>
</apply>
<apply>
<ci>normal-⋅</ci>
<ci>ν</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>s</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<ci>normal-⋅</ci>
<ci>κ</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<apply>
<minus></minus>
<ci>k</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>j</ci>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ h_{j-k}=\nu\cdot s_{k}=\kappa\cdot f_{k-j_{0}}
  </annotation>
</semantics>
</math>

.</p>

<p>for arbitrary non-zero constants 

<math display="inline" id="Matched_filter:81">
<semantics>
<mi>ν</mi>
<annotation-xml encoding="MathML-Content">
<ci>ν</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \nu
  </annotation>
</semantics>
</math>

 or 

<math display="inline" id="Matched_filter:82">
<semantics>
<mi>κ</mi>
<annotation-xml encoding="MathML-Content">
<ci>κ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \kappa
  </annotation>
</semantics>
</math>

, and the optimal solution is obtained at 

<math display="inline" id="Matched_filter:83">
<semantics>
<mrow>
<msup>
<mi>j</mi>
<mo>*</mo>
</msup>
<mo>=</mo>
<msub>
<mi>j</mi>
<mn>0</mn>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>j</ci>
<times></times>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>j</ci>
<cn type="integer">0</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   j^{*}=j_{0}
  </annotation>
</semantics>
</math>

 as desired. Thus, our "probing sequence" 

<math display="inline" id="Matched_filter:84">
<semantics>
<msub>
<mi>h</mi>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>h</ci>
<apply>
<minus></minus>
<ci>j</ci>
<ci>k</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   h_{j-k}
  </annotation>
</semantics>
</math>

 must be proportional to the signal model 

<math display="inline" id="Matched_filter:85">
<semantics>
<msub>
<mi>f</mi>
<mrow>
<mi>k</mi>
<mo>-</mo>
<msub>
<mi>j</mi>
<mn>0</mn>
</msub>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<apply>
<minus></minus>
<ci>k</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>j</ci>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f_{k-j_{0}}
  </annotation>
</semantics>
</math>

, and the convenient choice 

<math display="inline" id="Matched_filter:86">
<semantics>
<mrow>
<mi>κ</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>κ</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \kappa=1
  </annotation>
</semantics>
</math>

 yields the matched filter</p>

<p>
<math display="block" id="Matched_filter:87">
<semantics>
<mrow>
<msub>
<mpadded lspace="5pt" width="+5pt">
<mi>h</mi>
</mpadded>
<mi>k</mi>
</msub>
<mo>=</mo>
<msub>
<mi>f</mi>
<mrow>
<mo>-</mo>
<mi>k</mi>
</mrow>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>h</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<apply>
<minus></minus>
<ci>k</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ h_{k}=f_{-k}
  </annotation>
</semantics>
</math>

.</p>

<p>Note that the filter is the mirrored signal model. This ensures that the operation 

<math display="inline" id="Matched_filter:88">
<semantics>
<mrow>
<msub>
<mo largeop="true" symmetric="true">∑</mo>
<mi>k</mi>
</msub>
<mrow>
<msub>
<mi>x</mi>
<mi>k</mi>
</msub>
<msub>
<mi>h</mi>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>k</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>h</ci>
<apply>
<minus></minus>
<ci>j</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sum_{k}x_{k}h_{j-k}
  </annotation>
</semantics>
</math>

 to be applied in order to find the optimum is indeed the convolution between the observed sequence 

<math display="inline" id="Matched_filter:89">
<semantics>
<msub>
<mi>x</mi>
<mi>k</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>k</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{k}
  </annotation>
</semantics>
</math>

 and the matched filter 

<math display="inline" id="Matched_filter:90">
<semantics>
<msub>
<mi>h</mi>
<mi>k</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>h</ci>
<ci>k</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   h_{k}
  </annotation>
</semantics>
</math>

. The filtered sequence assumes its maximum at the position where the observed sequence 

<math display="inline" id="Matched_filter:91">
<semantics>
<msub>
<mi>x</mi>
<mi>k</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>k</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{k}
  </annotation>
</semantics>
</math>

 best matches (in a least-squares sense) the signal model 

<math display="inline" id="Matched_filter:92">
<semantics>
<msub>
<mi>f</mi>
<mi>k</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<ci>k</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f_{k}
  </annotation>
</semantics>
</math>

.</p>
<h2 id="frequency-domain-interpretation">Frequency-domain interpretation</h2>

<p>When viewed in the frequency domain, it is evident that the matched filter applies the greatest weighting to spectral components that have the greatest signal-to-noise ratio. Although in general this requires a non-flat frequency response, the associated distortion is not significant in situations such as <a class="uri" href="radar" title="wikilink">radar</a> and <a href="digital_communications" title="wikilink">digital communications</a>, where the original waveform is known and the objective is to detect the presence of this signal against the background noise.</p>
<h2 id="example-of-matched-filter-in-radar-and-sonar">Example of matched filter in radar and sonar</h2>

<p>Matched filters are often used in signal detection<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> (see <a href="detection_theory" title="wikilink">detection theory</a>). As an example, suppose that we wish to judge the distance of an object by reflecting a signal off it. We may choose to transmit a pure-tone sinusoid at 1 Hz. We assume that our received signal is an attenuated and phase-shifted form of the transmitted signal with added noise.</p>

<p>To judge the distance of the object, we correlate the received signal with a matched filter, which, in the case of <a href="white_noise" title="wikilink">white (uncorrelated) noise</a>, is another pure-tone 1-Hz sinusoid. When the output of the matched filter system exceeds a certain threshold, we conclude with high probability that the received signal has been reflected off the object. Using the speed of propagation and the time that we first observe the reflected signal, we can estimate the distance of the object. If we change the shape of the pulse in a specially-designed way, the signal-to-noise ratio and the distance resolution can be even improved after matched filtering: this is a technique known as <a href="pulse_compression" title="wikilink">pulse compression</a>.</p>

<p>Additionally, matched filters can be used in parameter estimation problems (see <a href="estimation_theory" title="wikilink">estimation theory</a>). To return to our previous example, we may desire to estimate the speed of the object, in addition to its position. To exploit the <a href="Doppler_effect" title="wikilink">Doppler effect</a>, we would like to estimate the frequency of the received signal. To do so, we may correlate the received signal with several matched filters of sinusoids at varying frequencies. The matched filter with the highest output will reveal, with high probability, the frequency of the reflected signal and help us determine the speed of the object. This method is, in fact, a simple version of the <a href="discrete_Fourier_transform" title="wikilink">discrete Fourier transform (DFT)</a>. The DFT takes an 

<math display="inline" id="Matched_filter:93">
<semantics>
<mi>N</mi>
<annotation-xml encoding="MathML-Content">
<ci>N</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   N
  </annotation>
</semantics>
</math>

-valued complex input and correlates it with 

<math display="inline" id="Matched_filter:94">
<semantics>
<mi>N</mi>
<annotation-xml encoding="MathML-Content">
<ci>N</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   N
  </annotation>
</semantics>
</math>

 matched filters, corresponding to complex exponentials at 

<math display="inline" id="Matched_filter:95">
<semantics>
<mi>N</mi>
<annotation-xml encoding="MathML-Content">
<ci>N</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   N
  </annotation>
</semantics>
</math>

 different frequencies, to yield 

<math display="inline" id="Matched_filter:96">
<semantics>
<mi>N</mi>
<annotation-xml encoding="MathML-Content">
<ci>N</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   N
  </annotation>
</semantics>
</math>

 complex-valued numbers corresponding to the relative amplitudes and phases of the sinusoidal components (see <a href="Moving_target_indication" title="wikilink">Moving target indication</a>).</p>
<h2 id="example-of-matched-filter-in-digital-communications">Example of matched filter in digital communications</h2>

<p>The matched filter is also used in communications. In the context of a communication system that sends binary messages from the transmitter to the receiver across a noisy channel, a matched filter can be used to detect the transmitted pulses in the noisy received signal.</p>
<figure><b>(Figure)</b>
<figcaption>Matched Filter Total System.jpg</figcaption>
</figure>

<p>Imagine we want to send the sequence "0101100100" coded in non polar <a class="uri" href="Non-return-to-zero" title="wikilink">Non-return-to-zero</a> (NRZ) through a certain channel.</p>

<p>Mathematically, a sequence in NRZ code can be described as a sequence of unit pulses or shifted <a href="rectangular_function" title="wikilink">rect functions</a>, each pulse being weighted by +1 if the bit is "1" and by 0 if the bit is "0". Formally, the scaling factor for the 

<math display="inline" id="Matched_filter:97">
<semantics>
<msup>
<mi>k</mi>
<mi>th</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>k</ci>
<ci>th</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   k^{\mathrm{th}}
  </annotation>
</semantics>
</math>

 bit is,</p>

<p>
<math display="block" id="Matched_filter:98">
<semantics>
<mrow>
<msub>
<mpadded lspace="5pt" width="+5pt">
<mi>a</mi>
</mpadded>
<mi>k</mi>
</msub>
<mo>=</mo>
<mrow>
<mo>{</mo>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="left">
<mrow>
<mn>1</mn>
<mo>,</mo>
</mrow>
</mtd>
<mtd columnalign="left">
<mrow>
<mrow>
<mtext>if bit</mtext>
<mi>k</mi>
<mtext>is 1</mtext>
</mrow>
<mo>,</mo>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="left">
<mrow>
<mn>0</mn>
<mo>,</mo>
</mrow>
</mtd>
<mtd columnalign="left">
<mrow>
<mrow>
<mtext>if bit</mtext>
<mi>k</mi>
<mtext>is 0</mtext>
</mrow>
<mo>.</mo>
</mrow>
</mtd>
</mtr>
</mtable>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>a</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="latexml">cases</csymbol>
<cn type="integer">1</cn>
<apply>
<times></times>
<mtext>if bit</mtext>
<ci>k</ci>
<mtext>is 1</mtext>
</apply>
<cn type="integer">0</cn>
<apply>
<times></times>
<mtext>if bit</mtext>
<ci>k</ci>
<mtext>is 0</mtext>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ a_{k}=\begin{cases}1,&amp;\mbox{if bit }k\mbox{ is 1},\\
0,&amp;\mbox{if bit }k\mbox{ is 0}.\end{cases}
  </annotation>
</semantics>
</math>
</p>

<p>We can represent our message, 

<math display="inline" id="Matched_filter:99">
<semantics>
<mrow>
<mi>M</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>M</ci>
<ci>t</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   M(t)
  </annotation>
</semantics>
</math>

, as the sum of shifted unit pulses:</p>

<p>
<math display="block" id="Matched_filter:100">
<semantics>
<mrow>
<mrow>
<mrow>
<mpadded lspace="5pt" width="+5pt">
<mi>M</mi>
</mpadded>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</mrow>
<mi mathvariant="normal">∞</mi>
</munderover>
<mrow>
<mrow>
<msub>
<mi>a</mi>
<mi>k</mi>
</msub>
<mo>×</mo>
<mi mathvariant="normal">Π</mi>
</mrow>
<mrow>
<mo>(</mo>
<mfrac>
<mrow>
<mi>t</mi>
<mo>-</mo>
<mrow>
<mi>k</mi>
<mi>T</mi>
</mrow>
</mrow>
<mi>T</mi>
</mfrac>
<mo>)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>M</ci>
<ci>t</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>k</ci>
<apply>
<minus></minus>
<infinity></infinity>
</apply>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<times></times>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>a</ci>
<ci>k</ci>
</apply>
<ci>normal-Π</ci>
</apply>
<apply>
<divide></divide>
<apply>
<minus></minus>
<ci>t</ci>
<apply>
<times></times>
<ci>k</ci>
<ci>T</ci>
</apply>
</apply>
<ci>T</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ M(t)=\sum_{k=-\infty}^{\infty}a_{k}\times\Pi\left(\frac{t-kT}{T}\right).
  </annotation>
</semantics>
</math>
</p>

<p>where 

<math display="inline" id="Matched_filter:101">
<semantics>
<mi>T</mi>
<annotation-xml encoding="MathML-Content">
<ci>T</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   T
  </annotation>
</semantics>
</math>

 is the time length of one bit.</p>

<p>Thus, the signal to be sent by the transmitter is</p>
<figure><b>(Figure)</b>
<figcaption>Original message.svg</figcaption>
</figure>

<p>If we model our noisy channel as an <a class="uri" href="AWGN" title="wikilink">AWGN</a> channel, white Gaussian noise is added to the signal. At the receiver end, for a Signal-to-noise ratio of 3dB, this may look like:</p>
<figure><b>(Figure)</b>
<figcaption>Received message.svg</figcaption>
</figure>

<p>A first glance will not reveal the original transmitted sequence. There is a high power of noise relative to the power of the desired signal (i.e., there is a low <a href="signal-to-noise_ratio" title="wikilink">signal-to-noise ratio</a>). If the receiver were to sample this signal at the correct moments, the resulting binary message would possibly belie the original transmitted one.</p>

<p>To increase our signal-to-noise ratio, we pass the received signal through a matched filter. In this case, the filter should be matched to an NRZ pulse (equivalent to a "1" coded in NRZ code). Precisely, the impulse response of the ideal matched filter, assuming white (uncorrelated) noise should be a time-reversed complex-conjugated scaled version of the signal that we are seeking. We choose</p>

<p>
<math display="block" id="Matched_filter:102">
<semantics>
<mrow>
<mrow>
<mrow>
<mpadded lspace="5pt" width="+5pt">
<mi>h</mi>
</mpadded>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi mathvariant="normal">Π</mi>
<mrow>
<mo>(</mo>
<mfrac>
<mi>t</mi>
<mi>T</mi>
</mfrac>
<mo>)</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>h</ci>
<ci>t</ci>
</apply>
<apply>
<times></times>
<ci>normal-Π</ci>
<apply>
<divide></divide>
<ci>t</ci>
<ci>T</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ h(t)=\Pi\left(\frac{t}{T}\right).
  </annotation>
</semantics>
</math>
</p>

<p>In this case, due to symmetry, the time-reversed complex conjugate of 

<math display="inline" id="Matched_filter:103">
<semantics>
<mrow>
<mi>h</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>h</ci>
<ci>t</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   h(t)
  </annotation>
</semantics>
</math>


 is in fact 

<math display="inline" id="Matched_filter:104">
<semantics>
<mrow>
<mi>h</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>h</ci>
<ci>t</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   h(t)
  </annotation>
</semantics>
</math>

, allowing us to call 

<math display="inline" id="Matched_filter:105">
<semantics>
<mrow>
<mi>h</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>h</ci>
<ci>t</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   h(t)
  </annotation>
</semantics>
</math>

 the impulse response of our matched filter convolution system.</p>

<p>After convolving with the correct matched filter, the resulting signal, 

<math display="inline" id="Matched_filter:106">
<semantics>
<mrow>
<msub>
<mi>M</mi>
<mi>filtered</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>filtered</ci>
</apply>
<ci>t</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   M_{\mathrm{filtered}}(t)
  </annotation>
</semantics>
</math>

 is,</p>

<p>
<math display="block" id="Matched_filter:107">
<semantics>
<mrow>
<mrow>
<msub>
<mpadded lspace="5pt" width="+5pt">
<mi>M</mi>
</mpadded>
<mi>filtered</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mrow>
<mi>M</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>*</mo>
<mi>h</mi>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>filtered</ci>
</apply>
<ci>t</ci>
</apply>
<apply>
<times></times>
<apply>
<times></times>
<apply>
<times></times>
<ci>M</ci>
<ci>t</ci>
</apply>
<ci>h</ci>
</apply>
<ci>t</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ M_{\mathrm{filtered}}(t)=M(t)*h(t)
  </annotation>
</semantics>
</math>
</p>

<p>where 

<math display="inline" id="Matched_filter:108">
<semantics>
<mo>*</mo>
<annotation-xml encoding="MathML-Content">
<times></times>
</annotation-xml>
<annotation encoding="application/x-tex">
   *
  </annotation>
</semantics>
</math>


 denotes convolution.</p>
<figure><b>(Figure)</b>
<figcaption>Filtered message.svg</figcaption>
</figure>

<p>Which can now be safely sampled by the receiver at the correct sampling instants, and compared to an appropriate threshold, resulting in a correct interpretation of the binary message.</p>
<figure><b>(Figure)</b>
<figcaption>Filtered message threshold.svg</figcaption>
</figure>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Channel_capacity" title="wikilink">Channel capacity</a></li>
<li><a href="Noisy_channel_coding_theorem" title="wikilink">Noisy channel coding theorem</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Melvin, Willian L. "A STAP Overview." <em>IEEE Aerospace and Electronic Systems Magazine</em> <strong>19</strong> (1) (January 2004): 19-35.</li>
<li>Turin, George L. "An introduction to matched filters." <em>IRE Transactions on Information Theory</em> <strong>6</strong> (3) (June 1960): 311- 329..</li>
</ul>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Estimation_theory" title="wikilink">Category:Estimation theory</a> <a href="Category:Telecommunication_theory" title="wikilink">Category:Telecommunication theory</a> <a href="Category:Signal_processing" title="wikilink">Category:Signal processing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a class="uri" href="http://cnx.org/content/m10141/latest/">http://cnx.org/content/m10141/latest/</a><a href="#fnref1">↩</a></li>
<li id="fn2">Woodward P.M. <em>Probability and Information Theory with Applications to Radar</em>, Norwood, MA: Artech House, 1980.<a href="#fnref2">↩</a></li>
</ol>
</section>
</ref></hr></body>
</html>
