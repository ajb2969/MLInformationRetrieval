<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="632">Karush–Kuhn–Tucker conditions</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Karush–Kuhn–Tucker conditions</h1>
<hr>In [[mathematical optimization]], the '''Karush–Kuhn–Tucker (KKT) conditions''' (also known as the '''Kuhn
<p>–Tucker conditions''') are first order <a href="necessary_and_sufficient_conditions" title="wikilink">necessary conditions</a> for a solution in <a href="nonlinear_programming" title="wikilink">nonlinear programming</a> to be <a href="Optimization_(mathematics)" title="wikilink">optimal</a>, provided that some <a href="#Regularity_conditions_(or_constraint_qualifications)" title="wikilink">regularity conditions</a> are satisfied. Allowing inequality constraints, the KKT approach to nonlinear programming generalizes the method of <a href="Lagrange_multipliers" title="wikilink">Lagrange multipliers</a>, which allows only equality constraints. The system of equations corresponding to the KKT conditions is usually not solved directly, except in the few special cases where a <a href="Closed-form_expression" title="wikilink">closed-form</a> solution can be derived analytically. In general, many optimization algorithms can be interpreted as methods for numerically solving the KKT system of equations.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The KKT conditions were originally named after <a href="Harold_W._Kuhn" title="wikilink">Harold W. Kuhn</a>, and <a href="Albert_W._Tucker" title="wikilink">Albert W. Tucker</a>, who first published the conditions in 1951.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Later scholars discovered that the necessary conditions for this problem had been stated by <a href="William_Karush" title="wikilink">William Karush</a> in his master's thesis in 1939.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="nonlinear-optimization-problem">Nonlinear optimization problem</h2>

<p>Consider the following nonlinear <a href="optimization_problem" title="wikilink">optimization problem</a>:</p>
<dl>
<dd>Maximize 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:0">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<dl>
<dd>subject to
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Karush–Kuhn–Tucker_conditions:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>g</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>h</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>i</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>j</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i}(x)\leq 0,h_{j}(x)=0
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where <em>x</em> is the optimization variable, 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:2">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is the <a href="objective_function" title="wikilink"><em>objective</em></a> or <em>cost</em> function, 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:3">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <msub>
     <mi>g</mi>
     <mi>i</mi>
    </msub>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <ci>i</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i}\ (i=1,\ldots,m)
  </annotation>
 </semantics>
</math>


 are the inequality <a href="Constraint_(mathematics)" title="wikilink">constraint</a> functions, and 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:4">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <msub>
     <mi>h</mi>
     <mi>j</mi>
    </msub>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>j</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>l</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>j</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">j</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">l</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{j}\ (j=1,\ldots,l)
  </annotation>
 </semantics>
</math>

 are the equality constraint functions. The numbers of inequality and equality constraints are denoted <em>m</em> and <em>l</em>, respectively.</p>
<h2 id="necessary-conditions">Necessary conditions</h2>

<p>Suppose that the <a href="objective_function" title="wikilink">objective function</a> 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:5">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ℝ</mi>
     <mi>n</mi>
    </msup>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>n</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\mathbb{R}^{n}\rightarrow\mathbb{R}
  </annotation>
 </semantics>
</math>

 and the constraint functions 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:6">
 <semantics>
  <mrow>
   <msub>
    <mi>g</mi>
    <mi>i</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ℝ</mi>
     <mi>n</mi>
    </msup>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>n</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i}:\,\!\mathbb{R}^{n}\rightarrow\mathbb{R}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:7">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>j</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ℝ</mi>
     <mi>n</mi>
    </msup>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>n</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{j}:\,\!\mathbb{R}^{n}\rightarrow\mathbb{R}
  </annotation>
 </semantics>
</math>

 are <a href="smooth_function" title="wikilink">continuously differentiable</a> at a point 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:8">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>


. If 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:9">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

 is a <a href="local_minimum" title="wikilink">local minimum</a> that satisfies some regularity conditions (see below), then there exist constants 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:10">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <msub>
     <mi>μ</mi>
     <mi>i</mi>
    </msub>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <ci>i</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{i}\ (i=1,\ldots,m)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:11">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <msub>
     <mi>λ</mi>
     <mi>j</mi>
    </msub>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>j</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>l</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>j</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">j</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">l</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{j}\ (j=1,\ldots,l)
  </annotation>
 </semantics>
</math>

, called KKT multipliers, such that</p>

<p><a href="File:Inequality_constraint_diagram.svg" title="wikilink">thumb|upright=2|Inequality constraint diagram for optimization problems</a></p>
<dl>
<dt>Stationarity</dt>
<dd>For maximizing f(x)

<math display="block" id="Karush–Kuhn–Tucker_conditions:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∇</mo>
      <mi>f</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>x</mi>
       <mo>*</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>m</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>μ</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo>∇</mo>
        <msub>
         <mi>g</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>x</mi>
         <mo>*</mo>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>l</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mi>j</mi>
       </msub>
       <mrow>
        <mo>∇</mo>
        <msub>
         <mi>h</mi>
         <mi>j</mi>
        </msub>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>x</mi>
         <mo>*</mo>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-∇</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <times></times>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <ci>normal-∇</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>l</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>j</ci>
       </apply>
       <apply>
        <ci>normal-∇</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla f(x^{*})=\sum_{i=1}^{m}\mu_{i}\nabla g_{i}(x^{*})+\sum_{j=1}^{l}\lambda%
_{j}\nabla h_{j}(x^{*}),
  </annotation>
 </semantics>
</math>


</dd>
<dd>For minimizing f(x)

<math display="block" id="Karush–Kuhn–Tucker_conditions:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mo>∇</mo>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>x</mi>
        <mo>*</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>m</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>μ</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo>∇</mo>
        <msub>
         <mi>g</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>x</mi>
         <mo>*</mo>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>l</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mi>j</mi>
       </msub>
       <mrow>
        <mo>∇</mo>
        <msub>
         <mi>h</mi>
         <mi>j</mi>
        </msub>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>x</mi>
         <mo>*</mo>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-∇</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <ci>normal-∇</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>l</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>j</ci>
       </apply>
       <apply>
        <ci>normal-∇</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\nabla f(x^{*})=\sum_{i=1}^{m}\mu_{i}\nabla g_{i}(x^{*})+\sum_{j=1}^{l}%
\lambda_{j}\nabla h_{j}(x^{*}),
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<dl>
<dt>Primal feasibility</dt>
<dd>

<math display="inline" id="Karush–Kuhn–Tucker_conditions:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>g</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>x</mi>
       <mo>*</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mtext>for all</mtext>
     <mi>i</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>m</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>for all</mtext>
      <ci>i</ci>
     </apply>
     <list>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>m</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i}(x^{*})\leq 0,\mbox{ for all }i=1,\ldots,m
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Karush–Kuhn–Tucker_conditions:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>h</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>x</mi>
       <mo>*</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mtext>for all</mtext>
     <mi>j</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>l</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>for all</mtext>
      <ci>j</ci>
     </apply>
     <list>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>l</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{j}(x^{*})=0,\mbox{ for all }j=1,\ldots,l\,\!
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<dl>
<dt>Dual feasibility</dt>
<dd>

<math display="inline" id="Karush–Kuhn–Tucker_conditions:16">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>μ</mi>
     <mi>i</mi>
    </msub>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mtext>for all</mtext>
     <mi>i</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>m</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <ci>i</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>for all</mtext>
      <ci>i</ci>
     </apply>
     <list>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>m</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{i}\geq 0,\mbox{ for all }i=1,\ldots,m
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<dl>
<dt>Complementary slackness</dt>
<dd>

<math display="inline" id="Karush–Kuhn–Tucker_conditions:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>μ</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>g</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>x</mi>
        <mo>*</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mpadded width="+2.8pt">
       <mtext>for all</mtext>
      </mpadded>
      <mi>i</mi>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mn>1</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mi>m</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>for all</mtext>
      <ci>i</ci>
     </apply>
     <list>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>m</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{i}g_{i}(x^{*})=0,\mbox{for all}\;i=1,\ldots,m.
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>In the particular case 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:18">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=0
  </annotation>
 </semantics>
</math>


, i.e., when there are no inequality constraints, the KKT conditions turn into the Lagrange conditions, and the KKT multipliers are called <a href="Lagrange_multipliers" title="wikilink">Lagrange multipliers</a>.</p>

<p>If some of the functions are non-differentiable, <a href="subderivative" title="wikilink">subdifferential</a> versions of Karush–Kuhn–Tucker (KKT) conditions are available.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="regularity-conditions-or-constraint-qualifications">Regularity conditions (or constraint qualifications)</h2>

<p>In order for a minimum point 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:19">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

 to satisfy the above KKT conditions, the problem should satisfy some regularity conditions; the most used ones are listed below:</p>
<ul>
<li><a href="Linearity_constraint_qualification" title="wikilink">Linearity constraint qualification</a>: If 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:20">
 <semantics>
  <msub>
   <mi>g</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:21">
 <semantics>
  <msub>
   <mi>h</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{j}
  </annotation>
 </semantics>
</math>

 are <a href="affine_function" title="wikilink">affine functions</a>, then no other condition is needed.</li>
<li><a href="Linear_independence_constraint_qualification" title="wikilink">Linear independence constraint qualification</a> (LICQ): the gradients of the active inequality constraints and the gradients of the equality constraints are <a href="Linear_independence" title="wikilink">linearly independent</a> at 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:22">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

.</li>
<li><a href="Mangasarian–Fromovitz_constraint_qualification" title="wikilink">Mangasarian–Fromovitz constraint qualification</a> (MFCQ): the gradients of the active inequality constraints and the gradients of the equality constraints are positive-linearly independent at 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:23">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>


.</li>
<li><a href="Constant_rank_theorem" title="wikilink">Constant rank constraint qualification</a> (CRCQ): for each subset of the gradients of the active inequality constraints and the gradients of the equality constraints the rank at a vicinity of 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:24">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

 is constant.</li>
<li><a href="Constant_positive_linear_dependence_constraint_qualification" title="wikilink">Constant positive linear dependence constraint qualification</a> (CPLD): for each subset of the gradients of the active inequality constraints and the gradients of the equality constraints, if it is positive-linear dependent at 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:25">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

 then it is positive-linear dependent at a vicinity of 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:26">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

.</li>
<li><a href="Quasi-normality_constraint_qualification" title="wikilink">Quasi-normality constraint qualification</a> (QNCQ): if the gradients of the active inequality constraints and the gradients of the equality constraints are positive-linearly dependent at 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:27">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

 with associated multipliers 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:28">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{i}
  </annotation>
 </semantics>
</math>


 for equalities and 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:29">
 <semantics>
  <msub>
   <mi>μ</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>μ</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{j}
  </annotation>
 </semantics>
</math>

 for inequalities, then there is no sequence 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:30">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>k</mi>
   </msub>
   <mo>→</mo>
   <msup>
    <mi>x</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}\to x^{*}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:31">
 <semantics>
  <mrow>
   <msub>
    <mi>λ</mi>
    <mi>i</mi>
   </msub>
   <mo>≠</mo>
   <mn>0</mn>
   <mo>⇒</mo>
   <mrow>
    <msub>
     <mi>λ</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>h</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <neq></neq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <ci>i</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{i}\neq 0\Rightarrow\lambda_{i}h_{i}(x_{k})>0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:32">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mi>j</mi>
   </msub>
   <mo>≠</mo>
   <mn>0</mn>
   <mo>⇒</mo>
   <mrow>
    <msub>
     <mi>μ</mi>
     <mi>j</mi>
    </msub>
    <msub>
     <mi>g</mi>
     <mi>j</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <neq></neq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <ci>j</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{j}\neq 0\Rightarrow\mu_{j}g_{j}(x_{k})>0
  </annotation>
 </semantics>
</math>

.</li>
<li><a href="Slater_condition" title="wikilink">Slater condition</a>: for a <a href="Convex_optimization" title="wikilink">convex problem</a>, there exists a point 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:33">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 such that 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)=0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:35">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>g</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>i</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i}(x)<0
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>(

<math display="inline" id="Karush–Kuhn–Tucker_conditions:36">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{1},\ldots,v_{n}
  </annotation>
 </semantics>
</math>

) is positive-linear dependent if there exists 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:37">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>≥</mo>
    <mrow>
     <mn>0</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mi>n</mi>
    </msub>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <list>
      <cn type="integer">0</cn>
      <ci>normal-…</ci>
     </list>
    </apply>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1}\geq 0,\ldots,a_{n}\geq 0
  </annotation>
 </semantics>
</math>

 not all zero such that 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:38">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>v</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>n</mi>
     </msub>
     <msub>
      <mi>v</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1}v_{1}+\cdots+a_{n}v_{n}=0
  </annotation>
 </semantics>
</math>


.</p>

<p>It can be shown that LICQ⇒MFCQ⇒CPLD⇒QNCQ, LICQ⇒CRCQ⇒CPLD⇒QNCQ (and the converses are not true), although MFCQ is not equivalent to CRCQ<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> . In practice weaker constraint qualifications are preferred since they provide stronger optimality conditions.</p>
<h2 id="sufficient-conditions">Sufficient conditions</h2>

<p>In some cases, the necessary conditions are also sufficient for optimality. In general, the necessary conditions are not sufficient for optimality and additional information is necessary, such as the Second Order Sufficient Conditions (SOSC). For smooth functions, SOSC involve the second derivatives, which explains its name.</p>

<p>The necessary conditions are sufficient for optimality if the objective function 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:39">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is a <a href="concave_function" title="wikilink">concave function</a>, the inequality constraints 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:40">
 <semantics>
  <msub>
   <mi>g</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{j}
  </annotation>
 </semantics>
</math>

 are continuously differentiable <a href="convex_function" title="wikilink">convex functions</a> and the equality constraints 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:41">
 <semantics>
  <msub>
   <mi>h</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{i}
  </annotation>
 </semantics>
</math>

 are <a href="affine_function" title="wikilink">affine functions</a>.</p>

<p>It was shown by Martin in 1985 that the broader class of functions in which KKT conditions guarantees global optimality are the so-called Type 1 <strong><a href="invex_function" title="wikilink">invex functions</a></strong>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h3 id="second-order-sufficient-conditions">Second Order Sufficient Conditions</h3>

<p>For smooth, <a href="Nonlinear_programming" title="wikilink">non-linear optimisation</a> problems, a second order sufficient condition is given as follows. Consider 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:42">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mo>*</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>λ</mi>
    <mo>*</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>ρ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <times></times>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>λ</ci>
     <times></times>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ρ</ci>
     <times></times>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*},\lambda^{*},\rho^{*}
  </annotation>
 </semantics>
</math>

 that find a local minimum using the Karush-Kuhn-Tucker conditions above. With 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:43">
 <semantics>
  <msup>
   <mi>ρ</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ρ</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho^{*}
  </annotation>
 </semantics>
</math>


 such that strict complementarity is held at 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:44">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

(<em>i.e. all 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:45">
 <semantics>
  <mrow>
   <msub>
    <mi>ρ</mi>
    <mi>i</mi>
   </msub>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ρ</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{\rho}_{i}>0
  </annotation>
 </semantics>
</math>

</em>), then for all 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:46">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>s</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\neq 0
  </annotation>
 </semantics>
</math>

 such that</p>

<p>

<math display="block" id="Karush–Kuhn–Tucker_conditions:47">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo>[</mo>
      <mfrac>
       <mrow>
        <mrow>
         <mo>∂</mo>
         <mi>g</mi>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <msup>
          <mi>x</mi>
          <mo>*</mo>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <mi>x</mi>
       </mrow>
      </mfrac>
      <mo>,</mo>
      <mfrac>
       <mrow>
        <mrow>
         <mo>∂</mo>
         <mi>h</mi>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <msup>
          <mi>x</mi>
          <mo>*</mo>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <mi>x</mi>
       </mrow>
      </mfrac>
      <mo>]</mo>
     </mrow>
     <mi>T</mi>
    </msup>
    <mi>s</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <interval closure="closed">
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <partialdiff></partialdiff>
          <ci>g</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <times></times>
         </apply>
        </apply>
        <apply>
         <partialdiff></partialdiff>
         <ci>x</ci>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <partialdiff></partialdiff>
          <ci>h</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <times></times>
         </apply>
        </apply>
        <apply>
         <partialdiff></partialdiff>
         <ci>x</ci>
        </apply>
       </apply>
      </interval>
      <ci>T</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left[\frac{\partial g(x^{*})}{\partial x},\frac{\partial h(x^{*})}{\partial x%
}\right]^{T}s=0
  </annotation>
 </semantics>
</math>

</p>

<p>the following equation must hold;</p>

<p>

<math display="block" id="Karush–Kuhn–Tucker_conditions:48">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <msubsup>
      <mo>∇</mo>
      <mrow>
       <mi>x</mi>
       <mi>x</mi>
      </mrow>
      <mn>2</mn>
     </msubsup>
     <mi>L</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mo>*</mo>
     </msup>
     <mo>,</mo>
     <msup>
      <mi>λ</mi>
      <mo>*</mo>
     </msup>
     <mo>,</mo>
     <msup>
      <mi>ρ</mi>
      <mo>*</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>s</mi>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-∇</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>L</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>λ</ci>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ρ</ci>
       <times></times>
      </apply>
     </vector>
     <ci>s</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime}\nabla^{2}_{xx}L(x^{*},\lambda^{*},\rho^{*})s>0
  </annotation>
 </semantics>
</math>

</p>

<p>If the above condition is strictly met, the function is a strict constrained local minimum.</p>
<h2 id="economics">Economics</h2>

<p>Often in <a href="mathematical_economics" title="wikilink">mathematical economics</a> the KKT approach is used in theoretical models in order to obtain qualitative results. For example, consider a firm that maximizes its sales revenue subject to a minimum profit constraint. Letting <em>Q</em> be the quantity of output produced (to be chosen), <em>R</em>(<em>Q</em>) be sales revenue with a positive first derivative and with a zero value at zero output, <em>C</em>(<em>Q</em>) be production costs with a positive first derivative and with a non-negative value at zero output, and 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:49">
 <semantics>
  <msub>
   <mi>G</mi>
   <mrow>
    <mi>m</mi>
    <mi>i</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{min}
  </annotation>
 </semantics>
</math>

 be the positive minimal acceptable level of <a href="Profit_(economics)" title="wikilink">profit</a>, then the problem is a meaningful one if the revenue function levels off so it eventually is less steep than the cost function. The problem expressed in the previously given minimization form is</p>
<dl>
<dd>Minimize 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:50">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -R(Q)
  </annotation>
 </semantics>
</math>


</dd>
<dd>subject to
</dd>
<dd>

<math display="inline" id="Karush–Kuhn–Tucker_conditions:51">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mrow>
     <mi>m</mi>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Q</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Q</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>i</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>Q</ci>
     </apply>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>Q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{min}\leq R(Q)-C(Q)
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Karush–Kuhn–Tucker_conditions:52">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>Q</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q\geq 0,
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>and the KKT conditions are</p>

<p>

<math display="block" id="Karush–Kuhn–Tucker_conditions:53">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mrow>
          <mtext>d</mtext>
          <mi>R</mi>
         </mrow>
         <mo>/</mo>
         <mtext>d</mtext>
        </mrow>
        <mi>Q</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mi>μ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>μ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mrow>
          <mtext>d</mtext>
          <mi>C</mi>
         </mrow>
         <mo>/</mo>
         <mtext>d</mtext>
        </mrow>
        <mi>Q</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <mtext>d</mtext>
         <ci>R</ci>
        </apply>
        <mtext>d</mtext>
       </apply>
       <ci>Q</ci>
      </apply>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>μ</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>μ</ci>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <mtext>d</mtext>
         <ci>C</ci>
        </apply>
        <mtext>d</mtext>
       </apply>
       <ci>Q</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\text{d}R/\text{d}Q)(1+\mu)-\mu(\text{d}C/\text{d}Q)\leq 0,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Karush–Kuhn–Tucker_conditions:54">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>Q</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q\geq 0,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Karush–Kuhn–Tucker_conditions:55">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <mrow>
            <mtext>d</mtext>
            <mi>R</mi>
           </mrow>
           <mo>/</mo>
           <mtext>d</mtext>
          </mrow>
          <mi>Q</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>+</mo>
          <mi>μ</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>μ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <mrow>
            <mtext>d</mtext>
            <mi>C</mi>
           </mrow>
           <mo>/</mo>
           <mtext>d</mtext>
          </mrow>
          <mi>Q</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <apply>
           <times></times>
           <mtext>d</mtext>
           <ci>R</ci>
          </apply>
          <mtext>d</mtext>
         </apply>
         <ci>Q</ci>
        </apply>
        <apply>
         <plus></plus>
         <cn type="integer">1</cn>
         <ci>μ</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>μ</ci>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <apply>
           <times></times>
           <mtext>d</mtext>
           <ci>C</ci>
          </apply>
          <mtext>d</mtext>
         </apply>
         <ci>Q</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q[(\text{d}R/\text{d}Q)(1+\mu)-\mu(\text{d}C/\text{d}Q)]=0,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Karush–Kuhn–Tucker_conditions:56">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Q</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>C</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Q</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <msub>
      <mi>G</mi>
      <mrow>
       <mi>m</mi>
       <mi>i</mi>
       <mi>n</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>Q</ci>
     </apply>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>Q</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>i</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(Q)-C(Q)-G_{min}\geq 0,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Karush–Kuhn–Tucker_conditions:57">
 <semantics>
  <mrow>
   <mrow>
    <mi>μ</mi>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>μ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu\geq 0,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Karush–Kuhn–Tucker_conditions:58">
 <semantics>
  <mrow>
   <mrow>
    <mi>μ</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <mi>R</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>Q</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>C</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>Q</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <msub>
       <mi>G</mi>
       <mrow>
        <mi>m</mi>
        <mi>i</mi>
        <mi>n</mi>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>μ</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>R</ci>
        <ci>Q</ci>
       </apply>
       <apply>
        <times></times>
        <ci>C</ci>
        <ci>Q</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>G</ci>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>i</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu[R(Q)-C(Q)-G_{min}]=0.
  </annotation>
 </semantics>
</math>

</p>

<p>Since <em>Q</em>=0 would violate the minimum profit constraint, we have <em>Q</em>&gt;0 and hence the third condition implies that the first condition holds with equality. Solving that equality gives</p>

<p>

<math display="block" id="Karush–Kuhn–Tucker_conditions:59">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mtext>d</mtext>
       <mi>R</mi>
      </mrow>
      <mo>/</mo>
      <mtext>d</mtext>
     </mrow>
     <mi>Q</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mi>μ</mi>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mi>μ</mi>
      </mrow>
     </mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mrow>
         <mtext>d</mtext>
         <mi>C</mi>
        </mrow>
        <mo>/</mo>
        <mtext>d</mtext>
       </mrow>
       <mi>Q</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <mtext>d</mtext>
       <ci>R</ci>
      </apply>
      <mtext>d</mtext>
     </apply>
     <ci>Q</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>μ</ci>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>μ</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <mtext>d</mtext>
        <ci>C</ci>
       </apply>
       <mtext>d</mtext>
      </apply>
      <ci>Q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{d}R/\text{d}Q=\frac{\mu}{1+\mu}(\text{d}C/\text{d}Q).
  </annotation>
 </semantics>
</math>

</p>

<p>Because it was given that 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:60">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mtext>d</mtext>
     <mi>R</mi>
    </mrow>
    <mo>/</mo>
    <mtext>d</mtext>
   </mrow>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <mtext>d</mtext>
      <ci>R</ci>
     </apply>
     <mtext>d</mtext>
    </apply>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{d}R/\text{d}Q
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:61">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mtext>d</mtext>
     <mi>C</mi>
    </mrow>
    <mo>/</mo>
    <mtext>d</mtext>
   </mrow>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <mtext>d</mtext>
      <ci>C</ci>
     </apply>
     <mtext>d</mtext>
    </apply>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{d}C/\text{d}Q
  </annotation>
 </semantics>
</math>

 are strictly positive, this inequality along with the non-negativity condition on 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:62">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 guarantees that 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:63">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>


 is positive and so the revenue-maximizing firm operates at a level of output at which <a href="marginal_revenue" title="wikilink">marginal revenue</a> 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:64">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mtext>d</mtext>
     <mi>R</mi>
    </mrow>
    <mo>/</mo>
    <mtext>d</mtext>
   </mrow>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <mtext>d</mtext>
      <ci>R</ci>
     </apply>
     <mtext>d</mtext>
    </apply>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{d}R/\text{d}Q
  </annotation>
 </semantics>
</math>

 is less than <a href="marginal_cost" title="wikilink">marginal cost</a> 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:65">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mtext>d</mtext>
     <mi>C</mi>
    </mrow>
    <mo>/</mo>
    <mtext>d</mtext>
   </mrow>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <mtext>d</mtext>
      <ci>C</ci>
     </apply>
     <mtext>d</mtext>
    </apply>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{d}C/\text{d}Q
  </annotation>
 </semantics>
</math>

 — a result that is of interest because it contrasts with the behavior of a <a href="profit_maximization" title="wikilink">profit maximizing</a> firm, which operates at a level at which they are equal.</p>
<h2 id="value-function">Value function</h2>

<p>If we reconsider the optimization problem as a maximization problem with constant inequality constraints,</p>

<p>

<math display="block" id="Karush–Kuhn–Tucker_conditions:66">
 <semantics>
  <mrow>
   <mpadded width="+2.8pt">
    <mtext>Maximize</mtext>
   </mpadded>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>Maximize</mtext>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Maximize }\;f(x)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Karush–Kuhn–Tucker_conditions:68">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>g</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>h</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>i</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>j</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i}(x)\leq a_{i},h_{j}(x)=0.
  </annotation>
 </semantics>
</math>


</p>
<dl>
<dd><dl>
<dd>

<math display="block" id="Karush–Kuhn–Tucker_conditions:69">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo movablelimits="false">sup</mo>
     <mi>x</mi>
    </munder>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">supremum</csymbol>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(a_{1},\ldots,a_{n})=\sup\limits_{x}f(x)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>The value function is defined as</p>

<p>

<math display="inline" id="Karush–Kuhn–Tucker_conditions:71">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>g</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>h</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>i</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>j</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i}(x)\leq a_{i},h_{j}(x)=0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Karush–Kuhn–Tucker_conditions:72">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>j</mi>
     <mo>∈</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mi>l</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>i</mi>
     <mo>∈</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mi>m</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <ci>j</ci>
     <set>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>l</ci>
     </set>
    </apply>
    <apply>
     <in></in>
     <ci>i</ci>
     <set>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>m</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j\in\{1,\ldots,l\},i\in\{1,\ldots,m\}.
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Karush–Kuhn–Tucker_conditions:73">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>a</mi>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>m</mi>
   </msup>
   <mo stretchy="false">|</mo>
   <mtext>for some</mtext>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>X</mi>
   <mo>,</mo>
   <msub>
    <mi>g</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≤</mo>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
   <mo>,</mo>
   <mi>i</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>m</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-{</ci>
    <csymbol cd="unknown">a</csymbol>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>m</ci>
    </apply>
    <ci>normal-|</ci>
    <mtext>for some</mtext>
    <csymbol cd="unknown">x</csymbol>
    <in></in>
    <csymbol cd="unknown">X</csymbol>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <ci>i</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-,</ci>
    <csymbol cd="unknown">i</csymbol>
    <in></in>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a\in\mathbb{R}^{m}|\text{for some }x\in X,g_{i}(x)\leq a_{i},i\in\{1,\ldots,%
m\}.
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Karush–Kuhn–Tucker_conditions:74">
 <semantics>
  <msub>
   <mi>μ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>μ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{i}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>(So the domain of <em>V</em> is 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:75">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}
  </annotation>
 </semantics>
</math>

)</p>

<p>Given this definition, each coefficient, 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:76">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}
  </annotation>
 </semantics>
</math>

, is the rate at which the value function increases as 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:77">
 <semantics>
  <msub>
   <mi>μ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>μ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{0}
  </annotation>
 </semantics>
</math>

 increases. Thus if each 

<math display="inline" id="Karush–Kuhn–Tucker_conditions:78">
 <semantics>
  <mrow>
   <mrow>
    <mo>∇</mo>
    <mi>f</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>x</mi>
     <mo>*</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-∇</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla f(x^{*})
  </annotation>
 </semantics>
</math>


 is interpreted as a resource constraint, the coefficients tell you how much increasing a resource will increase the optimum value of our function <em>f</em>. This interpretation is especially important in economics and is used, for instance, in <a href="utility_maximization_problem" title="wikilink">utility maximization problems</a>.</p>
<h2 id="generalizations">Generalizations</h2>

<p>With an extra constant multiplier 

<math display="block" id="Karush–Kuhn–Tucker_conditions:79">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>μ</mi>
       <mn>0</mn>
      </msub>
      <mrow>
       <mo>∇</mo>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>x</mi>
        <mo>*</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>m</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>μ</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo>∇</mo>
        <msub>
         <mi>g</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>x</mi>
         <mo>*</mo>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>l</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mi>j</mi>
       </msub>
       <mrow>
        <mo>∇</mo>
        <msub>
         <mi>h</mi>
         <mi>j</mi>
        </msub>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>x</mi>
         <mo>*</mo>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <ci>normal-∇</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <ci>normal-∇</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>l</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>j</ci>
       </apply>
       <apply>
        <ci>normal-∇</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{0}\nabla f(x^{*})+\sum_{i=1}^{m}\mu_{i}\nabla g_{i}(x^{*})+\sum_{j=1}^{l}%
\lambda_{j}\nabla h_{j}(x^{*})=0,
  </annotation>
 </semantics>
</math>

, which may be zero, in front of <span class="LaTeX">$\nabla f(x^*)$</span> the KKT stationarity conditions turn into</p>

<p><span class="LaTeX">$$\mu_0 \nabla f(x^*) + \sum_{i=1}^m \mu_i \nabla g_i(x^*) + \sum_{j=1}^l \lambda_j \nabla h_j(x^*) = 0,$$</span></p>

<p>which are called the <a href="Fritz_John_conditions" title="wikilink">Fritz John conditions</a>.</p>

<p>The KKT conditions belong to a wider class of the First Order Necessary Conditions (FONC), which allow for non-smooth functions using <a href="subderivative" title="wikilink">subderivatives</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Farkas'_lemma" title="wikilink">Farkas' lemma</a></li>
<li><a href="Big_M_method" title="wikilink">Big M method</a> - corresponding technique for <a href="linear_optimization" title="wikilink">linear optimization</a> problems</li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.onmyphd.com/?p=kkt.karush.kuhn.tucker">Karush–Kuhn–Tucker conditions with derivation and examples</a></li>
<li><a href="http://apmonitor.com/me575/index.php/Main/KuhnTucker">Examples and Tutorials on the KKT Conditions</a></li>
</ul>

<p><a href="de:Konvexe_Optimierung#Karush-Kuhn-Tucker-Bedingungen" title="wikilink">de:Konvexe Optimierung#Karush-Kuhn-Tucker-Bedingungen</a>"</p>

<p><a href="Category:Mathematical_optimization" title="wikilink">Category:Mathematical optimization</a> <a href="Category:Mathematical_and_quantitative_methods_(economics)" title="wikilink">Category:Mathematical and quantitative methods (economics)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"> <a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
</ol>
</section>
</hr></body>
</html>
