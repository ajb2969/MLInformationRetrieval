<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title offset="1944">Network motif</title>
   <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js">
    </script>
</head>
<body>
<h1>Network motif</h1>
<hr/>
<p>All networks, including <a href="biological_network" title="wikilink">biological networks</a>, social networks, technological networks (e.g., computer networks and electrical circuits) and more, can be represented as <a href="complex_network" title="wikilink">graphs</a>, which include a wide variety of subgraphs. One important local property of networks are so-called <strong>network motifs</strong>, which are defined as recurrent and <a href="statistically_significant" title="wikilink">statistically significant</a> sub-graphs or patterns.</p>
<p>Network motifs are sub-graphs that repeat themselves in a specific network or even among various networks. Each of these sub-graphs, defined by a particular pattern of interactions between vertices, may reflect a framework in which particular functions are achieved efficiently. Indeed, motifs are of notable importance largely because they may reflect functional properties. They have recently gathered much attention as a useful concept to uncover structural design principles of complex networks.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Although network motifs may provide a deep insight into the network’s functional abilities, their detection is computationally challenging.</p>
<h2 id="definition">Definition</h2>
<p>Let <span class="LaTeX">$G = (V, E)$</span> and <span class="LaTeX">$G′ = (E′, V′)$</span> be two graphs. Graph <span class="LaTeX">$G′$</span> is a <em>sub-graph</em> of graph <span class="LaTeX">$G$</span> (written as <span class="LaTeX">$G′ ⊆ G$</span>) if <span class="LaTeX">$V′ ⊆ V$</span> and <span class="LaTeX">$E′ ⊆ E ∩ (V′ × V′)$</span>. If <span class="LaTeX">$G′ ⊆ G$</span> and <span class="LaTeX">$G′$</span> contains all of the edges <span class="LaTeX">$‹u, v› ∈ E$</span> with <span class="LaTeX">$u, v ∈ V′$</span>, then <span class="LaTeX">$G′$</span> is an <em>induced sub-graph</em> of <span class="LaTeX">$G$</span>. We call <span class="LaTeX">$G′$</span> and <span class="LaTeX">$G$</span> isomorphic (written as <span class="LaTeX">$G′ ↔ G$</span>), if there exists a bijection (one-to-one) <span class="LaTeX">$f:V′ → V$</span> with <span class="LaTeX">$‹u, v› ∈ E′ ⇔ ‹f(u), f(v)› ∈ E$</span> for all <span class="LaTeX">$u, v ∈ V′$</span>. The mapping <span class="LaTeX">$f$</span> is called an isomorphism between <span class="LaTeX">$G$</span> and <span class="LaTeX">$G′$</span>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<p>When <span class="LaTeX">$G″ ⊂ G$</span> and there exist an isomorphism between the sub-graph <span class="LaTeX">$G″$</span> and a graph <span class="LaTeX">$G′$</span>, this mapping represents an <em>appearance</em> of <span class="LaTeX">$G′$</span> in <span class="LaTeX">$G$</span>. The number of appearances of graph <span class="LaTeX">$G′$</span> in <span class="LaTeX">$G$</span> is called the frequency <mtpl></mtpl> of <span class="LaTeX">$G′$</span> in <span class="LaTeX">$G$</span>. A graph is called <em>recurrent</em> (or <em>frequent</em>) in <span class="LaTeX">$G$</span>, when its <em>frequency</em> <mtpl></mtpl> is above a predefined threshold or cut-off value. We used terms <em>pattern</em> and <em>frequent sub-graph</em> in this review interchangeably. There is an ensemble <span class="LaTeX">$Ω(G)$</span> of random graphs corresponding to the null-model associated to <span class="LaTeX">$G$</span>. We should choose <span class="LaTeX">$N$</span> random graphs uniformly from <span class="LaTeX">$Ω(G)$</span> and calculate the frequency for a particular frequent sub-graph <span class="LaTeX">$G′$</span> in <span class="LaTeX">$G$</span>. If the frequency of <span class="LaTeX">$G′$</span> in <span class="LaTeX">$G$</span> is higher than its arithmetic mean frequency in <span class="LaTeX">$N$</span> random graphs <mtpl></mtpl>, where <span class="LaTeX">$1 ≤ i ≤ N$</span>, we call this recurrent pattern <em>significant</em> and hence treat <span class="LaTeX">$G′$</span> as a <em>network motif</em> for <span class="LaTeX">$G$</span>. For a small graph <span class="LaTeX">$G′$</span>, the network <span class="LaTeX">$G$</span> and a set of randomized networks <span class="LaTeX">$R(G) ⊆ Ω(R)$</span>, where <span class="LaTeX">$R(G) = N$</span>, the <em>Z-Score</em> that has been defined by the following formula:</p>
<p><span class="LaTeX">$Z(G^\prime) = \frac{F_G(G^\prime) - \mu_R(G^\prime)}{\sigma_R(G^\prime)}$</span></p>
<p>where <mtpl></mtpl> and <mtpl></mtpl> stand for mean and standard deviation frequency in set <span class="LaTeX">$R(G)$</span>, respectively.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The larger the <span class="LaTeX">$Z(G′)$</span>, the more significant is the sub-graph <span class="LaTeX">$G′$</span> as a motif. Alternatively, another measurement in statistical hypothesis testing that can be considered in motif detection is the P-Value, given as the probability of <mtpl></mtpl> (as its null-hypothesis), where <mtpl></mtpl> indicates the frequency of G' in a randomized network.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> A sub-graph with P-value less than a threshold (commonly 0.01 or 0.05) will be treated as a significant pattern. The P-value is defined as</p>
<p><span class="LaTeX">$P(G^\prime) = \frac{1}{N}\sum_{i=1}^N \delta(c(i)) ; c(i): F_R^i(G^\prime) \ge F_G(G^\prime)$</span></p>
<figure><b>(Figure)</b>
<figcaption><em>Different occurrences of a sub-graph in a graph</em>. (M1 – M4) are different occurrences of sub-graph (b) in graph (a). For frequency concept <mtpl></mtpl>, the set M1, M2, M3, M4 represent all matches, so <mtpl> 4}}</mtpl>. For <mtpl></mtpl>, one of the two set M1, M4 or M2, M3 are possible matches, <mtpl> 2}}</mtpl>. Finally, for frequency concept <mtpl></mtpl>, merely one of the matches (M1 to M4) is allowed, therefore <mtpl> 1}}</mtpl>. The frequency of these three frequency concepts decrease as the usage of network elements are restricted.</figcaption>
</figure>
<p>Where <span class="LaTeX">$N$</span> indicates number of randomized networks, <span class="LaTeX">$i$</span> is defined over an ensemble of randomized networks and the Kronecker delta function <span class="LaTeX">$δ(c(i))$</span> is one if the condition <span class="LaTeX">$c(i)$</span> holds. The concentration <a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> of a particular n-size sub-graph <span class="LaTeX">$G′$</span> in network <span class="LaTeX">$G$</span> refers to the ratio of the sub-graph appearance in the network to the total <em>n</em>-size non-isomorphic sub-graphs’ frequencies, which is formulated by</p>
<p><span class="LaTeX">$C_G(G^\prime) = \frac{F_G(G^\prime)}{\sum_i F_G(G_i)}$</span></p>
<p>where index <span class="LaTeX">$i$</span> is defined over the set of all non-isomorphic n-size graphs. Another statistical measurement is defined for evaluating network motifs, but it is rarely used in known algorithms. This measurement is introduced by Picard <em>et al.</em> in 2008 and used the Poisson distribution, rather than the Gaussian normal distribution that is implicitly being used above.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<p>In addition, three specific concepts of sub-graph frequency have been proposed.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> As figure illustrates, the first frequency concept <mtpl></mtpl> considers all matches of a graph in original network. This definition is similar to what we have introduced above. The second concept <mtpl></mtpl> is defined as the maximum number of edge-disjoint instances of a given graph in original network. And finally, the frequency concept <mtpl></mtpl> entails matches with disjoint edges and nodes. Therefore, the two concepts <mtpl></mtpl> and <mtpl></mtpl> restrict the usage of elements of the graph, and as can be inferred, the frequency of a sub-graph declines by imposing restrictions on network element usage. As a result, a network motif detection algorithm would pass over more candidate sub-graphs if we insist on frequency concepts <mtpl></mtpl> and <mtpl></mtpl>.</p>
<h2 id="history">History</h2>
<p>This idea was first presented in 2002 by <a href="Uri_Alon" title="wikilink">Uri Alon</a> and his group <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> when network motifs were discovered in the gene regulation (transcription) network of the bacteria <em><a href="Escherichia_coli" title="wikilink">E. coli</a></em> and then in a large set of natural networks. Since then, a considerable number of studies have been conducted on the subject. Some of these studies focus on the biological applications, while others focus on the computational theory of network motifs.</p>
<p>The biological studies endeavor to interpret the motifs detected for biological networks. For example, in work following,<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> the network motifs found in <em><a href="Escherichia_coli" title="wikilink">E. coli</a></em> were discovered in the transcription networks of other bacteria<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> as well as yeast<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> and higher organisms.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> A distinct set of network motifs were identified in other types of biological networks such as neuronal networks and protein interaction networks.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a><a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<p>The computational research has focused on improving existing motif detection tools to assist the biological investigations and allow larger networks to be analyzed. Several different algorithms have been provided so far, which are elaborated in the next section in chronological order.</p>
<p>Most recently, the acc-MOTIF tool to detect network motifs was released.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>
<h2 id="motif-discovery-algorithms">Motif Discovery Algorithms</h2>
<p>Various solutions have been proposed for the challenging problem of motif discovery. These algorithms can be classified under various paradigms such as exact counting methods, sampling methods, pattern growth methods and so on. However, motif discovery problem comprises two main steps: first, calculating the number of occurrences of a sub-graph and then, evaluating the sub-graph significance. The recurrence is significant if it is detectably far more than expected. Roughly speaking, the expected number of appearances of a sub-graph can be determined by a Null-model, which is defined by an ensemble of random networks with some of the same properties as the original network.</p>
<p>Here, a review on computational aspects of major algorithms is given and their related benefits and drawbacks from an algorithmic perspective are discussed.</p>
<h3 id="mfinder">mfinder</h3>
<p><em>mfinder</em>, the first motif-mining tool, implements two kinds of motif finding algorithms: a full enumeration and a sampling method. Until 2004, the only exact counting method for NM (network motif) detection was the brute-force one proposed by Milo <em>et al.</em>.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> This algorithm was successful for discovering small motifs, but using this method for finding even size 5 or 6 motifs was not computationally feasible. Hence, a new approach to this problem was needed.</p>
<p>Kashtan <em>et al.</em> <a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> presented the first sampling NM discovery algorithm, which was based on <em>edge sampling</em> throughout the network. This algorithm estimates concentrations of induced sub-graphs and can be utilized for motif discovery in directed or undirected networks. The sampling procedure of the algorithm starts from an arbitrary edge of the network that leads to a sub-graph of size two, and then expands the sub-graph by choosing a random edge that is incident to the current sub-graph. After that, it continues choosing random neighboring edges until a sub-graph of size n is obtained. Finally, the sampled sub-graph is expanded to include all of the edges that exist in the network between these n nodes. When an algorithm uses a sampling approach, taking unbiased samples is the most important issue that the algorithm might address. The sampling procedure, however, does not take samples uniformly and therefore Kashtan <em>et al.</em> proposed a weighting scheme that assigns different weights to the different sub-graphs within network.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> The underlying principle of weight allocation is exploiting the information of the sampling probability for each sub-graph, i.e. the probable sub-graphs will obtain comparatively less weights in comparison to the improbable sub-graphs; hence, the algorithm must calculate the sampling probability of each sub-graph that has been sampled. This weighting technique assists <em>mfinder</em> to determine sub-graph concentrations impartially.</p>
<p>In expanded to include sharp contrast to exhaustive search, the computational time of the algorithm surprisingly is asymptotically independent of the network size. An analysis of the computational time of the algorithm has shown that it takes <mtpl></mtpl> for each sample of a sub-graph of size <span class="LaTeX">$n$</span> from the network. On the other hand, there is no analysis in <a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> on the classification time of sampled sub-graphs that requires solving the <em>graph isomorphism</em> problem for each sub-graph sample. Additionally, an extra computational effort is imposed on the algorithm by the sub-graph weight calculation. But it is unavoidable to say that the algorithm may sample the same sub-graph multiple times – spending time without gathering any information.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> In conclusion, by taking the advantages of sampling, the algorithm performs more efficiently than an exhaustive search algorithm; however, it only determines sub-graphs concentrations approximately. This algorithm can find motifs up to size 6 because of its main implementation, and as result it gives the most significant motif, not all the others too. Also, it is necessary to mention that this tool has no option of visual presentation. The sampling algorithm is shown briefly:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><p>mfinder</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><strong>Definitions:</strong> <mtpl></mtpl>is the set of picked edges. <mtpl></mtpl> is the set of all nodes that are touched by the edges in <span class="LaTeX">$E$</span>.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Init <mtpl></mtpl> and <mtpl></mtpl> to be empty sets. 1. Pick a random edge <mtpl> (v<sub>i</sub>, v<sub>j</sub>)}}</mtpl>. Update }, } 2. Make a list <span class="LaTeX">$L$</span> of all neighbor edges of <mtpl></mtpl>. Omit from <span class="LaTeX">$L$</span> all edges between members of <mtpl></mtpl>. 3. Pick a random edge } from <span class="LaTeX">$L$</span>. Update }, }. 4. Repeat steps 2-3 until completing an <em>n</em>-node subgraph (until <mtpl>V<sub>s</sub>{{!}} {{=}} n}}</mtpl>). 5. Calculate the probability to sample the picked <em>n</em>-node subgraph.</p></td>
</tr>
</tbody>
</table>
<h3 id="fpf-mavisto">FPF (Mavisto)</h3>
<p>Schreiber and Schwöbbermeyer <a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> proposed an algorithm named <em>flexible pattern finder (FPF)</em> for extracting frequent sub-graphs of an input network and implemented it in a system named <em>Mavisto</em>.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> Their algorithm exploits the <em>downward closure</em> property which is applicable for frequency concepts <mtpl></mtpl> and <mtpl></mtpl>. The downward closure property asserts that the frequency for sub-graphs decrease monotonically by increasing the size of sub-graphs; however, this property does not hold necessarily for frequency concept <mtpl></mtpl>. FPF is based on a <em>pattern tree</em> (see figure) consisting of nodes that represents different graphs (or patterns), where the parent of each node is a sub-graph of its children nodes; in other words, the corresponding graph of each pattern tree’s node is expanded by adding a new edge to the graph of its parent node.</p>
<figure><b>(Figure)</b>
<figcaption><em>Illustration of the pattern tree in FPF algorithm</em>.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></figcaption>
</figure>
<p>At first, the FPF algorithm enumerates and maintains the information of all matches of a sub-graph located at the root of the pattern tree. Then, one-by-one it builds child nodes of the previous node in the pattern tree by adding one edge supported by a matching edge in the target graph, and tries to expand all of the previous information about matches to the new sub-graph (child node). In next step, it decides whether the frequency of the current pattern is lower than a predefined threshold or not. If it is lower and if downward closure holds, FPF can abandon that path and not traverse further in this part of the tree; as a result, unnecessary computation is avoided. This procedure is continued until there is no remaining path to traverse.</p>
<p>The advantage of the algorithm is that it does not consider infrequent sub-graphs and tries to finish the enumeration process as soon as possible; therefore, it only spends time for promising nodes in the pattern tree and discards all other nodes. As an added bonus, the pattern tree notion permits FPF to be implemented and executed in a parallel manner since it is possible to traverse each path of the pattern tree independently. However, FPF is most useful for frequency concepts <mtpl></mtpl> and <mtpl></mtpl>, because downward closure is not applicable to <mtpl></mtpl>. Nevertheless, the pattern tree is still practical for <mtpl></mtpl> if the algorithm runs in parallel. Another advantage of the algorithm is that the implementation of this algorithm has no limitation on motif size, which makes it more amenable to improvements. The pseudocode of FPF (Mavisto) is shown below:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><p>Mavisto</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><strong>Data:</strong> Graph <span class="LaTeX">$G$</span>, target pattern size <span class="LaTeX">$t$</span>, frequency concept <span class="LaTeX">$F$</span> <strong>Result:</strong> Set <span class="LaTeX">$R$</span> of patterns of size <span class="LaTeX">$t$</span> with maximum frequency.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$R ← φ$</span>, <mtpl></mtpl> <span class="LaTeX">$P ←$</span>start pattern <span class="LaTeX">$p1$</span> of size 1 <mtpl></mtpl>all matches of <mtpl></mtpl> in <span class="LaTeX">$G$</span> <strong>While</strong> <span class="LaTeX">$P ≠ φ$</span> <strong>do</strong> <mtpl></mtpl>select all patterns from <span class="LaTeX">$P$</span> with maximum size. <span class="LaTeX">$P ←$</span> select pattern with maximum frequency from <mtpl></mtpl> <mtpl> <em>ExtensionLoop</em>(G, p, M<sub>p</sub>)}}</mtpl> <strong>Foreach</strong> pattern <span class="LaTeX">$p ∈ E$</span> <strong>If</strong> <mtpl> F<sub>1</sub>}}</mtpl> <strong>then</strong> <mtpl></mtpl> <strong>Else</strong> <span class="LaTeX">$f ←$</span> <em>Maximum Independent set</em><mtpl></mtpl> <strong>End</strong> <strong>If</strong> <span class="LaTeX">$size (p) = t$</span> <strong>then</strong> <strong>If</strong> <mtpl> f<sub>max</sub>}}</mtpl> <strong>then</strong> } <strong>Else if</strong> <mtpl></mtpl> <strong>then</strong> }; <mtpl></mtpl> <strong>End</strong> <strong>Else</strong> <strong>If</strong> <mtpl> F<sub>1</sub>}}</mtpl> <strong>or</strong> <mtpl></mtpl> <strong>then</strong> } <strong>End</strong> <strong>End</strong> <strong>End</strong> <strong>End</strong></p></td>
</tr>
</tbody>
</table>
<h3 id="esu-fanmod">ESU (FANMOD)</h3>
<p>The sampling bias of Kashtan <em>et al.</em> <a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> provided great impetus for designing better algorithms for the NM discovery problem. Although Kashtan <em>et al.</em> tried to settle this drawback by means of a weighting scheme, this method imposed an undesired overhead on the running time as well a more complicated implementation. This tool is one of the most useful ones, as it supports visual options and also is an efficient algorithm with respect to time. But, it has a limitation on motif size as it does not allow searching for motifs of size 9 or higher because of the way the tool is implemented.</p>
<p>Wernicke <a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> introduced an algorithm named <em>RAND-ESU</em> that provides a significant improvement over <em>mfinder</em>.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> This algorithm, which is based on the exact enumeration algorithm <em>ESU</em>, has been implemented as an application called <em>FANMOD</em>.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> <em>RAND-ESU</em> is a NM discovery algorithm applicable for both directed and undirected networks, effectively exploits an unbiased node sampling throughout the network, and prevents overcounting sub-graphs more than once. Furthermore, <em>RAND-ESU</em> uses a novel analytical approach called <em>DIRECT</em> for determining sub-graph significance instead of using an ensemble of random networks as a Null-model. The <em>DIRECT</em> method estimates the sub-graph concentration without explicitly generating random networks.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> Empirically, the DIRECT method is more efficient in comparison with the random network ensemble in case of sub-graphs with a very low concentration; however, the classical Null-model is faster than the <em>DIRECT</em> method for highly concentrated sub-graphs.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a><a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> In the following, we detail the <em>ESU</em> algorithm and then we show how this exact algorithm can be modified efficiently to <em>RAND-ESU</em> that estimates sub-graphs concentrations.</p>
<p>The algorithms <em>ESU</em> and <em>RAND-ESU</em> are fairly simple, and hence easy to implement. <em>ESU</em> first finds the set of all induced sub-graphs of size <span class="LaTeX">$k$</span>, let <mtpl></mtpl> be this set. <em>ESU</em> can be implemented as a recursive function; the running of this function can be displayed as a tree-like structure of depth <span class="LaTeX">$k$</span>, called the ESU-Tree (see figure). Each of the ESU-Tree nodes indicate the status of the recursive function that entails two consecutive sets SUB and EXT. SUB refers to nodes in the target network that are adjacent and establish a partial sub-graph of size <span class="LaTeX">$| SUB | ≤ k$</span>. If <span class="LaTeX">$| SUB | = k$</span>, the algorithm has found an induced complete sub-graph, so <mtpl> SUB ∪ S<sub>k</sub>}}</mtpl>. However, if <span class="LaTeX">$| SUB | , the algorithm must expand SUB to achieve cardinality <span class="LaTeX">$k$</span>. This is done by the EXT set that contains all the nodes that satisfy two conditions: First, each of the nodes in EXT must be adjacent to at least one of the nodes in SUB; second, their numerical labels must be larger than the labels of SUB nodes. The first condition makes sure that the expansion of SUB nodes yields a connected graph and the second condition causes ESU-Tree leaves (see figure) to be distinct; as a result, it prevents overcounting. Note that, the EXT set is not a static set, so in each step it may expand by some new nodes that do not breach the two conditions. The next step of ESU involves classification of sub-graphs placed in the ESU-Tree leaves into non-isomorphic size-<span class="LaTeX">$k$</span> graph classes; consequently, ESU determines sub-graphs frequencies and concentrations. This stage has been implemented simply by employing McKay’s <em>nauty</em> algorithm,<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a><a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> which classifies each sub-graph by performing a graph isomorphism test. Therefore, ESU finds the set of all induced <span class="LaTeX">$k$</span>-size sub-graphs in a target graph by a recursive algorithm and then determines their frequency using an efficient tool.</span></p>
<p>How has the exact <em>ESU</em> been algorithm modified to <em>RAND-ESU</em> that estimates sub-graph concentrations? The procedure of implementing <em>RAND-ESU</em> is quite straightforward and is one of the main advantages of <em>FANMOD</em>. One can change the <em>ESU</em> algorithm to explore just a portion of the ESU-Tree leaves by applying a probability value <mtpl></mtpl> for each level of the ESU-Tree and oblige <em>ESU</em> to traverse each child node of a node in level <span class="LaTeX">$d-1$</span> with probability <mtpl></mtpl>. This new algorithm is called <em>RAND-ESU</em>. Evidently, when <mtpl> 1}}</mtpl> for all levels, <em>RAND-ESU</em> acts like <em>ESU</em>. For <mtpl> 0}}</mtpl> the algorithm finds nothing. Note that, this procedure ensures that the chances of visiting each leaf of the ESU-Tree are the same, resulting in <em>unbiased</em> sampling of sub-graphs through the network. The probability of visiting each leaf is <mtpl></mtpl> and this is identical for all of the ESU-Tree leaves; therefore, this method guarantees unbiased sampling of sub-graphs from the network. Nonetheless, determining the value of <mtpl></mtpl> for <span class="LaTeX">$1 ≤ d ≤ k$</span> is another issue that must be determined manually by an expert to get precise results of sub-graph concentrations.<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> While there is no lucid prescript for this matter, the Wernicke provides some general observations that may help in determining p_d values. In summary, <em>RAND-ESU</em> is a very fast algorithm for NM discovery in the case of induced sub-graphs supporting unbiased sampling method. Although, the main <em>ESU</em> algorithm and so the <em>FANMOD</em> tool is known for discovering induced sub-graphs, there is trivial modification to <em>ESU</em> which makes it possible for finding non-induced sub-graphs, too. The pseudo code of <em>ESU (FANMOD)</em> is shown below:</p>
<figure><b>(Figure)</b>
<figcaption>(a) <em>A target graph of size 5</em>, (b) <em>the ESU-tree of depth k that is associated to the extraction of sub-graphs of size 3 in the target graph</em>. Leaves correspond to set S3 or all of the size-3 induced sub-graphs of the target graph (a). Nodes in the ESU-tree include two adjoining sets, the first set contains adjacent nodes called SUB and the second set named EXT holds all nodes that are adjacent to at least one of the SUB nodes and where their numerical labels are larger than the SUB nodes labels. The EXT set is utilized by the algorithm to expand a SUB set until it reaches a desired sub-graph size that are placed at the lowest level of ESU-Tree (or its leaves).</figcaption>
</figure>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><p>Enumeration of ESU (FANMOD)</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><strong><em>EnumerateSubgraphs(G,k)</em></strong> <strong>Input:</strong> A graph <span class="LaTeX">$G = (V, E)$</span> and an integer <span class="LaTeX">$1 ≤ k ≤ | V |$</span>. <strong>Output:</strong> All size-<span class="LaTeX">$k$</span> subgraphs in <span class="LaTeX">$G$</span>. <strong>for each</strong> vertex <span class="LaTeX">$v ∈ V$</span> <strong>do</strong> } <strong>call</strong> <strong>endfor</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><strong><em>ExtendSubgraph(VSubgraph, VExtension, v)</em></strong> <strong>if</strong> <span class="LaTeX">$| VSubgraph | = k$</span> <strong>then</strong> output <span class="LaTeX">$G VSubgraph h$</span> and <strong>return</strong> <strong>while</strong> <span class="LaTeX">$VExtension ≠ ∅$</span> <strong>do</strong> Remove an arbitrarily chosen vertex <span class="LaTeX">$w$</span> from <span class="LaTeX">$VExtension$</span> } <strong>call</strong> <strong>return</strong></p></td>
</tr>
</tbody>
</table>
<h3 id="nemofinder">NeMoFinder</h3>
<p>Chen <em>et al.</em> <a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a> introduced a new NM discovery algorithm called <em>NeMoFinder</em>, which adapts the idea in <em>SPIN</em> <a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> to extract frequent trees and after that expands them into non-isomorphic graphs.<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a> <em>NeMoFinder</em> utilizes frequent size-n trees to partition the input network into a collection of size-<span class="LaTeX">$n$</span> graphs, afterward finding frequent size-n sub-graphs by expansion of frequent trees edge-by-edge until getting a complete size-<span class="LaTeX">$n$</span> graph <mtpl></mtpl>. The algorithm finds NMs in undirected networks and is not limited to extracting only induced sub-graphs. Furthermore, <em>NeMoFinder</em> is an exact enumeration algorithm and is not based on a sampling method. As Chen <em>et al.</em> claim, <em>NeMoFinder</em> is applicable for detecting relatively large NMs, for instance, finding NMs up to size-12 from the whole <em>S. cerevisiae</em> (yeast) PPI network as the authors claimed.<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a></p>
<p><em>NeMoFinder</em> consists of three main steps. First, finding frequent size-<span class="LaTeX">$n$</span> trees, then utilizing repeated size-n trees to divide the entire network into a collection of size-<span class="LaTeX">$n$</span> graphs, finally, performing sub-graph join operations to find frequent size-n sub-graphs.<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a> In the first step, the algorithm detects all non-isomorphic size-<span class="LaTeX">$n$</span> trees and mappings from a tree to the network. In the second step, the ranges of these mappings are employed to partition the network into size-n graphs. Up to this step, there is no distinction between <em>NeMoFinder</em> and an exact enumeration method. However, a large portion of non-isomorphic size-n graphs still remain. <em>NeMoFinder</em> exploits a heuristic to enumerate non-tree size-n graphs by the obtained information from the preceding steps. The main advantage of the algorithm is in the third step, which generates candidate sub-graphs from previously enumerated sub-graphs. This generation of new size-<span class="LaTeX">$n$</span> sub-graphs is done by joining each previous sub-graph with derivative sub-graphs from itself called <em>cousin sub-graphs</em>. These new sub-graphs contain one additional edge in comparison to the previous sub-graphs. However, there exist some problems in generating new sub-graphs: There is no clear method to derive cousins from a graph, joining a sub-graph with its cousins leads to redundancy in generating particular sub-graph more than once, and cousin determination is done by a canonical representation of the adjacency matrix which is not closed under join operation. <em>NeMoFinder</em> is an efficient network motif finding algorithm for motifs up to size 12 only for protein-protein interaction networks, which are presented as undirected graphs. And it is not able to work on directed networks which are so important in the field of complex and biological networks. The pseudocode of <em>NeMoFinder</em> is shown below:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><p>NeMoFinder</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><strong>Input:</strong> <span class="LaTeX">$G$</span> - PPI network; <span class="LaTeX">$N$</span> - Number of randomized networks; <span class="LaTeX">$K$</span> - Maximal network motif size; <span class="LaTeX">$F$</span> - Frequency threshold; <span class="LaTeX">$S$</span> - Uniqueness threshold; <strong>Output:</strong> <span class="LaTeX">$U$</span> - Repeated and unique network motif set; <span class="LaTeX">$D ← ∅$</span>; <strong>for</strong> motif-size <span class="LaTeX">$k$</span> <strong>from</strong> 3 <strong>to</strong> <span class="LaTeX">$K$</span> <strong>do</strong> <span class="LaTeX">$T ← FindRepeatedTrees (k)$</span>; <span class="LaTeX">$GDk ← GraphPartition (G, T)$</span> <span class="LaTeX">$D ← D ∪ T$</span>; <span class="LaTeX">$D′ ← T$</span>; <span class="LaTeX">$i ← k$</span>; <strong>while</strong> <span class="LaTeX">$D″ = ∅$</span> <strong>and</strong> <span class="LaTeX">$i ≤ k × (k - 1) / 2$</span> <strong>do</strong> <span class="LaTeX">$D′ ← FindRepeatedGraphs (k, i, D′)$</span>; <span class="LaTeX">$D ← D ∪ D′$</span>; <span class="LaTeX">$i ← i + 1$</span>; <strong>end while</strong> <strong>end for</strong> <strong>for</strong> counter <span class="LaTeX">$i$</span> <strong>from</strong> 1 <strong>to</strong> <span class="LaTeX">$N$</span> <strong>do</strong> <span class="LaTeX">$Grand ← RandomizedNetworkGeneration ()$</span>; <strong>for each</strong> <span class="LaTeX">$g ∈ D$</span> <strong>do</strong> <span class="LaTeX">$GetRandFrequency (g, Grand)$</span>; <strong>end for</strong> <strong>end for</strong> <span class="LaTeX">$U ← ∅$</span>; <strong>for each</strong> <span class="LaTeX">$g ∈ D$</span> <strong>do</strong> <span class="LaTeX">$s ← GetUniqunessValue (g)$</span>; <strong>if</strong> <span class="LaTeX">$s ≥ S$</span> <strong>then</strong> }; <strong>end if</strong> <strong>end for</strong> <strong>return</strong> <span class="LaTeX">$U$</span></p></td>
</tr>
</tbody>
</table>
<h3 id="grochow-kellis">Grochow-Kellis</h3>
<p>Grochow and Kellis <a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a> proposed an <em>exact</em> algorithm for enumerating sub-graph appearances. The algorithm is based on a <em>motif-centric</em> approach, which means that the frequency of a given sub-graph,called the <em>query graph</em>, is exhaustively determined by searching for all possible mappings from the query graph into the larger network. It is claimed <a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a> that a <em>motif-centric</em> method in comparison to <em>network-centric</em> methods has some beneficial features. First of all it avoids the increased complexity of sub-graph enumeration. Also, by using mapping instead of enumerating, it enables an improvement in the isomorphism test. To improve the performance of the algorithm, since it is an inefficient exact enumeration algorithm, the authors introduced a fast method which is called <em>symmetry-breaking conditions</em>. During straightforward sub-graph isomorphism tests, a sub-graph may be mapped to the same sub-graph of the query graph multiple times. In the Grochow-Kellis (GK) algorithm symmetry-breaking is used to avoid such multiple mappings. Here we introduce the GK algorithm and the symmetry-breaking condition which eliminates redundant isomorphism tests.</p>
<figure><b>(Figure)</b>
<figcaption>(a) <em>graph G</em>, (b) <em>illustration of all automorphisms of G that is showed in (a)</em>. From set AutG we can obtain a set of symmetry-breaking conditions of G given by SymG in (c). Only the first mapping in AutG satisfies the SynG conditions; as a result, by applying SymG in the Isomorphism Extension module the algorithm only enumerate each match-able sub-graph in the network to G once. Note that SynG is not necessarily a unique set for an arbitrary graph G.</figcaption>
</figure>
<p>The GK algorithm discovers the whole set of mappings of a given query graph to the network in two major steps. It starts with the computation of symmetry-breaking conditions of the query graph. Next, by means of a branch-and-bound method, the algorithm tries to find every possible mapping from the query graph to the network that meets the associated symmetry-breaking conditions. An example of the usage of symmetry-breaking conditions in GK algorithm is demonstrated in figure.</p>
<p>As it is mentioned above, the symmetry-breaking technique is a simple mechanism that precludes spending time finding a sub-graph more than once due to its symmetries.<a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a><a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a> Note that, computing symmetry-breaking conditions requires finding all automorphisms of a given query graph. Even though, there is no efficient (or polynomial time) algorithm for the graph automorphism problem, this problem can be tackled efficiently in practice by McKay’s tools.<a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a><a class="footnoteRef" href="#fn54" id="fnref54"><sup>54</sup></a> As it is claimed, using symmetry-breaking conditions in NM detection lead to save a great deal of running time. Moreover, it can be inferred from the results in <a class="footnoteRef" href="#fn55" id="fnref55"><sup>55</sup></a><a class="footnoteRef" href="#fn56" id="fnref56"><sup>56</sup></a> that using the symmetry-breaking conditions results in high efficiency particularly for directed networks in comparison to undirected networks. The symmetry-breaking conditions used in the GK algorithm are similar to the restriction which <em>ESU</em> algorithm applies to the labels in EXT and SUB sets. In conclusion, the GK algorithm computes the exact number of appearance of a given query graph in a large complex network and exploiting symmetry-breaking conditions improves the algorithm performance. Also, GK algorithm is one of the known algorithms having no limitation for motif size in implementation and potentially it can find motifs of any size.</p>
<h3 id="color-coding-approach">Color-Coding Approach</h3>
<p>Most algorithms in the field of NM discovery are used to find induced sub-graphs of a network. In 2008, Noga Alon <em>et al.</em> <a class="footnoteRef" href="#fn57" id="fnref57"><sup>57</sup></a> introduced an approach for finding non-induced sub-graphs too. Their technique works on undirected networks such as PPI ones. Also, it counts non-induced trees and bounded treewidth sub-graphs. This method is applied for sub-graphs of size up to 10.</p>
<p>This algorithm counts the number of non-induced occurrences of a tree <span class="LaTeX">$T$</span> with <span class="LaTeX">$k = O(logn)$</span> vertices in a network <span class="LaTeX">$G$</span> with <span class="LaTeX">$n$</span> vertices as follows:</p>
<p>1. <strong>Color coding.</strong> Color each vertex of input network G independently and uniformly at random with one of the <span class="LaTeX">$k$</span> colors.</p>
<p>2. <strong>Counting.</strong> Apply a dynamic programming routine to count the number of non-induced occurrences of <span class="LaTeX">$T$</span> in which each vertex has a unique color. For more details on this step, see.<a class="footnoteRef" href="#fn58" id="fnref58"><sup>58</sup></a></p>
<p>3. Repeat the above two steps <mtpl></mtpl> times and add up the number of occurrences of <span class="LaTeX">$T$</span> to get an estimate on the number of its occurrences in <span class="LaTeX">$G$</span>.</p>
<p>As available PPI networks are far from complete and error free, this approach is suitable for NM discovery for such networks. As Grochow-Kellis Algorithm and this one are the ones popular for non-induced sub-graphs, it is worth to mention that the algorithm introduced by Alon <em>et al.</em> is less time consuming than the Grochow-Kellis Algorithm.<a class="footnoteRef" href="#fn59" id="fnref59"><sup>59</sup></a></p>
<h3 id="moda">MODA</h3>
<p>Omidi <em>et al.</em> <a class="footnoteRef" href="#fn60" id="fnref60"><sup>60</sup></a> introduced a new algorithm for motif detection named <em>MODA</em> which is applicable for induced and non-induced NM discovery in undirected networks. It is based on the motif-centric approach discussed in the Grochow-Kellis algorithm section. It is very important to distinguish motif-centric algorithms such as MODA and GK algorithm because of their ability to work as query-finding algorithms. This feature allows such algorithms to be able to find a single motif query or a small number of motif queries (not all possible sub-graphs of a given size) with larger sizes. As the number of possible non-isomorphic sub-graphs increases exponentially with sub-graph size, for large size motifs (even larger than 10), the network-centric algorithms, those looking for all possible sub-graphs, face a problem. Although motif-centric algorithms also have problems in discovering all possible large size sub-graphs, but their ability to find small numbers of them is sometimes a significant property.</p>
<p>Using a hierarchical structure called an <em>expansion tree</em>, the <em>MODA</em> algorithm is able to extract NMs of a given size systematically and similar to <em>FPF</em> that avoids enumerating unpromising sub-graphs; <em>MODA</em> takes into consideration potential queries (or candidate sub-graphs) that would result in frequent sub-graphs. Despite the fact that <em>MODA</em> resembles <em>FPF</em> in using a tree like structure, the expansion tree is applicable merely for computing frequency concept <mtpl></mtpl>. As we will discuss next, the advantage of this algorithm is that it does not carry out the sub-graph isomorphism test for <em>non-tree</em> query graphs. Additionally, it utilizes a sampling method in order to speed up the running time of the algorithm.</p>
<p>Here is the main idea: by a simple criterion one can generalize a mapping of a k-size graph into the network to its same size supergraphs. For example, suppose there is mapping <span class="LaTeX">$f(G)$</span> of graph <span class="LaTeX">$G$</span> with <span class="LaTeX">$k$</span> nodes into the network and we have a same size graph <span class="LaTeX">$G′$</span> with one more edge <span class="LaTeX">$‹u, v›$</span>; <mtpl></mtpl> will map <span class="LaTeX">$G′$</span> into the network, if there is an edge <mtpl></mtpl> in the network. As a result, we can exploit the mapping set of a graph to determine the frequencies of its same order supergraphs simply in <span class="LaTeX">$O(1)$</span> time without carrying out sub-graph isomorphism testing. The algorithm starts ingeniously with minimally connected query graphs of size k and finds their mappings in the network via sub-graph isomorphism. After that, with conservation of the graph size, it expands previously considered query graphs edge-by-edge and computes the frequency of these expanded graphs as mentioned above. The expansion process continues until reaching a complete graph <mtpl></mtpl> (fully connected with <span class="LaTeX">${k(k-1)}/{2}$</span> edge).</p>
<p>As discussed above, the algorithm starts by computing sub-tree frequencies in the network and then expands sub-trees edge by edge. One way to implement this idea is called the expansion tree <mtpl></mtpl> for each <span class="LaTeX">$k$</span>. Figure shows the expansion tree for size-4 sub-graphs. <mtpl></mtpl> organizes the running process and provides query graphs in a hierarchical manner. Strictly speaking, the expansion tree <mtpl></mtpl> is simply a directed acyclic graph or DAG, with its root number <span class="LaTeX">$k$</span> indicating the graph size existing in the expansion tree and each of its other nodes containing the adjacency matrix of a distinct <span class="LaTeX">$k$</span>-size query graph. Nodes in the first level of <mtpl></mtpl> are all distinct <span class="LaTeX">$k$</span>-size trees and by traversing <mtpl></mtpl> in depth query graphs expand with one edge at each level. A query graph in a node is a sub-graph of the query graph in a node’s child with one edge difference. The longest path in <mtpl></mtpl> consists of <mtpl></mtpl> edges and is the path from the root to the leaf node holding the complete graph. Generating expansion trees can be done by a simple routine which is explained in.<a class="footnoteRef" href="#fn61" id="fnref61"><sup>61</sup></a></p>
<p><em>MODA</em> traverses <mtpl></mtpl> and when it extracts query trees from the first level of <mtpl></mtpl> it computes their mapping sets and saves these mappings for the next step. For non-tree queries from <mtpl></mtpl>, the algorithm extracts the mappings associated with the parent node in <mtpl></mtpl> and determines which of these mappings can support the current query graphs. The process will continue until the algorithm gets the complete query graph. The query tree mappings are extracted using the Grochow-Kellis algorithm. For computing the frequency of non-tree query graphs, the algorithm employs a simple routine that takes <span class="LaTeX">$O(1)$</span> steps. In addition, <em>MODA</em> exploits a sampling method where the sampling of each node in the network is linearly proportional to the node degree, the probability distribution is exactly similar to the well-known Barabási-Albert preferential attachment model in the field of complex networks.<a class="footnoteRef" href="#fn62" id="fnref62"><sup>62</sup></a> This approach generates approximations; however, the results are almost stable in different executions since sub-graphs aggregate around highly connected nodes.<a class="footnoteRef" href="#fn63" id="fnref63"><sup>63</sup></a> The pseudocode of <em>MODA</em> is shown below:</p>
<figure><b>(Figure)</b>
<figcaption><em>Illustration of the expansion tree T4 for 4-node query graphs</em>. At the first level, there are non-isomorphic k-size trees and at each level, an edge is added to the parent graph to form a child graph. In the second level, there is a graph with two alternative edges that is shown by a dashed red edge. In fact, this node represents two expanded graphs that are isomorphic.<a class="footnoteRef" href="#fn64" id="fnref64"><sup>64</sup></a></figcaption>
</figure>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><p>MODA</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><strong>Input:</strong> <span class="LaTeX">$G$</span>: Input graph, <span class="LaTeX">$k$</span>: sub-graph size, <span class="LaTeX">$Δ$</span>: threshold value <strong>Output:</strong> Frequent Subgraph List: List of all frequent <span class="LaTeX">$k$</span>-size sub-graphs <strong>Note:</strong> <mtpl></mtpl>: set of mappings from <span class="LaTeX">$G$</span> in the input graph <span class="LaTeX">$G$</span> <strong>fetch</strong> <mtpl></mtpl> <strong>do</strong> <mtpl> <em>Get-Next-BFS</em>(T<sub>k</sub>)}}</mtpl> // <span class="LaTeX">$G′$</span> is a query graph if <span class="LaTeX">$| E(G′) | = (k – 1)$</span> <strong>call</strong> <span class="LaTeX">$Mapping-Module (G′, G)$</span> <strong>else</strong> <strong>call</strong> <mtpl></mtpl> <strong>end if</strong> <strong>save</strong> <mtpl></mtpl> <strong>if</strong> <mtpl>F<sub>G</sub>{{!}} > Δ}}</mtpl> <strong>then</strong> add <span class="LaTeX">$G′$</span> into Frequent Subgraph List <strong>end if</strong> <strong>Until</strong> <span class="LaTeX">$| E(G ) ) | = (k – 1)/2)$</span> <strong>return</strong> Frequent Subgraph List</p></td>
</tr>
</tbody>
</table>
<h3 id="kavosh">Kavosh</h3>
<p>A recently introduced algorithm named <em>Kavosh</em> <a class="footnoteRef" href="#fn65" id="fnref65"><sup>65</sup></a> aims at improved main memory usage. <em>Kavosh</em> is usable to detect NM in both directed and undirected networks. The main idea of the enumeration is similar to the <em>GK</em> and <em>MODA</em> algorithms, which first find all <span class="LaTeX">$k$</span>-size sub-graphs that a particular node participated in, then remove the node, and subsequently repeat this process for the remaining nodes.<a class="footnoteRef" href="#fn66" id="fnref66"><sup>66</sup></a></p>
<p>For counting the sub-graphs of size <span class="LaTeX">$k$</span> that include a particular node, trees with maximum depth of k, rooted at this node and based on neighborhood relationship are implicitly built. Children of each node include both incoming and outgoing adjacent nodes. To descend the tree, a child is chosen at each level with the restriction that a particular child can be included only if it has not been included at any upper level. After having descended to the lowest level possible, the tree is again ascended and the process is repeated with the stipulation that nodes visited in earlier paths of a descendent are now considered unvisited nodes. A final restriction in building trees is that all children in a particular tree must have numerical labels larger than the label of the root of the tree. The restrictions on the labels of the children are similar to the conditions which <em>GK</em> and <em>ESU</em> algorithm use to avoid overcounting sub-graphs.</p>
<p>The protocol for extracting sub-graphs makes use of the compositions of an integer. For the extraction of sub-graphs of size <span class="LaTeX">$k$</span>, all possible compositions of the integer <span class="LaTeX">$k-1$</span> must be considered. The compositions of <span class="LaTeX">$k-1$</span> consist of all possible manners of expressing <span class="LaTeX">$k-1$</span> as a sum of positive integers. Summations in which the order of the summands differs are considered distinct. A composition can be expressed as <mtpl></mtpl> where <mtpl> k-1}}</mtpl>. To count sub-graphs based on the composition, <mtpl></mtpl> nodes are selected from the <span class="LaTeX">$i$</span>-th level of the tree to be nodes of the sub-graphs (<span class="LaTeX">$i = 2,3,…,m$</span>). The <span class="LaTeX">$k-1$</span> selected nodes along with the node at the root define a sub-graph within the network. After discovering a sub-graph involved as a match in the target network, in order to be able to evaluate the size of each class according to the target network, <em>Kavosh</em> employs the <em>nauty</em> algorithm <a class="footnoteRef" href="#fn67" id="fnref67"><sup>67</sup></a><a class="footnoteRef" href="#fn68" id="fnref68"><sup>68</sup></a> in the same way as <em>FANMOD</em>. The enumeration part of Kavosh algorithm is shown below:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><p>Enumeration of Kavosh</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><strong><em>Enumerate_Vertex(G, u, S, Remainder, i)</em></strong> <strong>Input:</strong> <span class="LaTeX">$G$</span>: Input graph<br/>
<span class="LaTeX">$u$</span>: Root vertex<br/>
<span class="LaTeX">$S$</span>: selection (} is an array of the set of all <mtpl></mtpl>)<br/>
<span class="LaTeX">$Remainder$</span>: number of remaining vertices to be selected<br/>
<span class="LaTeX">$i$</span>: Current depth of the tree.<br/>
<strong>Output:</strong> all <span class="LaTeX">$k$</span>-size sub-graphs of graph <span class="LaTeX">$G$</span> rooted in <span class="LaTeX">$u$</span>. <strong>if</strong> <span class="LaTeX">$Remainder = 0$</span> <strong>then</strong><br/>
<strong>return</strong><br/>
<strong>else</strong><br/>
<mtpl></mtpl><br/>
<mtpl>ValList{{!}}, Remainder)}}</mtpl><br/>
<strong>for</strong> <mtpl> 1}}</mtpl> <strong>to</strong> <mtpl></mtpl> <strong>do</strong><br/>
<mtpl></mtpl><br/>
(Make the first vertex combination selection according)<br/>
<strong>repeat</strong><br/>
<mtpl></mtpl><br/>
<mtpl></mtpl><br/>
<mtpl></mtpl><br/>
(Make the next vertex combination selection according)<br/>
<strong>until</strong> <span class="LaTeX">$C = NILL$</span><br/>
<strong>end for</strong><br/>
<strong>for each</strong> <span class="LaTeX">$v ∈ ValList$</span> <strong>do</strong><br/>
<span class="LaTeX">$Visited v v ← false e$</span><br/>
<strong>end for</strong><br/>
<strong>end if</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><strong>''Validate(G, Parents, u)</strong>''<br/>
<strong>Input:</strong> <span class="LaTeX">$G$</span>: input graph, <span class="LaTeX">$Parents$</span>: selected vertices of last layer, <span class="LaTeX">$u$</span>: Root vertex.<br/>
<strong>Output:</strong> Valid vertices of the current level. <span class="LaTeX">$ValList ← NILL$</span><br/>
<strong>for each</strong> <span class="LaTeX">$v ∈ Parents$</span> <strong>do</strong><br/>
<strong>for each</strong> <span class="LaTeX">$w ∈ Neighbor u u$</span> <strong>do</strong><br/>
<strong>if</strong> <span class="LaTeX">$label u u  <strong>AND NOT</strong> <span class="LaTeX">$Visited w w$</span> <strong>then</strong><br/>
<span class="LaTeX">$Visited w w ← true e$</span><br/>
<span class="LaTeX">$ValList = ValList + w$</span><br/>
<strong>end if</strong><br/>
<strong>end for</strong><br/>
<strong>end for</strong><br/>
<strong>return</strong> <span class="LaTeX">$ValList$</span><br/>
</span></p></td>
</tr>
</tbody>
</table>
<p>Recently a <em>Cytoscape</em> plugin called <em>CytoKavosh</em> <a class="footnoteRef" href="#fn69" id="fnref69"><sup>69</sup></a> is developed for this software. It is available via <em>Cytoscape</em> web page <a href="http://apps.cytoscape.org/apps/cytokavosh">1</a>.</p>
<h3 id="g-tries">G-Tries</h3>
<p>In 2010, Pedro Ribeiro and Fernando Silva proposed a novel data structure for storing a collection of sub-graphs, called a <em>g-trie</em>.<a class="footnoteRef" href="#fn70" id="fnref70"><sup>70</sup></a> This data structure, which is conceptually akin to a prefix tree, stores sub-graphs according to their structures and finds occurrences of each of these sub-graphs in a larger graph. One of the noticeable aspects of this data structure is that coming to the network motif discovery, the sub-graphs in the main network are needed to be evaluated. So, there is no need to find the ones in random network which are not in the main network. This can be one of the time-consuming parts in the algorithms in which all sub-graphs in random networks are derived.</p>
<p>A <em>g-trie</em> is a multiway tree that can store a collection of graphs. Each tree node contains information about a single graph vertex and its corresponding edges to ancestor nodes. A path from the root to a leaf corresponds to one single graph. Descendants of a g-trie node share a common sub-graph. Constructing a <em>g-trie</em> is well described in.<a class="footnoteRef" href="#fn71" id="fnref71"><sup>71</sup></a> After constructing a <em>g-trie</em>, the counting part takes place. The main idea in counting process is to backtrack by all possible sub-graphs, but at the same time do the isomorphism tests. This backtracking technique is essentially the same technique employed by other motif-centric approaches like <em>MODA</em> and <em>GK</em> algorithms. Taking advantage of common substructures in the sense that at a given time there is a partial isomorphic match for several different candidate sub-graphs.</p>
<p>Among the mentioned algorithms, <em>G-Tries</em> is the fastest. But, the excessive use of memory is the drawback of this algorithm, which might limit the size of discoverable motifs by a personal computer with average memory.</p>
<h3 id="comparison">Comparison</h3>
<p>Tables and figure below show the results of running the mentioned algorithms on different standard networks. These results are taken from the corresponding sources,<a class="footnoteRef" href="#fn72" id="fnref72"><sup>72</sup></a><a class="footnoteRef" href="#fn73" id="fnref73"><sup>73</sup></a><a class="footnoteRef" href="#fn74" id="fnref74"><sup>74</sup></a> thus they should be treated individually.</p>
<figure><b>(Figure)</b>
<figcaption><em>Runtimes of Grochow-Kellis, mfinder, FANMOD, FPF and MODA for subgraphs from three nodes up to nine nodes</em>.<a class="footnoteRef" href="#fn75" id="fnref75"><sup>75</sup></a></figcaption>
</figure>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Runtimes of Grochow-Kellis, FANMOD, and G-Trie for subgraphs from three nodes up to nine nodes on five different networks.<a class="footnoteRef" href="#fn76" id="fnref76"><sup>76</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Network</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>FANMOD</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Dolphins</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>6</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>7</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>8</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>9</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>Circuit</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>7</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>8</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Social</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>4</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>5</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>Yeast</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>4</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>5</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Power</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>4</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>5</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>6</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>7</p></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Runtimes of mfinder, FANMOD, Mavisto and Kavosh for subgraphs from three nodes up to ten nodes on three different networks.<a class="footnoteRef" href="#fn77" id="fnref77"><sup>77</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>Networks ↓</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>E. coli</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>FANMOD</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Mavisto</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>Mfinder</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Electronic</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>FANMOD</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Mavisto</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>Mfinder</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Social</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>FANMOD</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Mavisto</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>Mfinder</p></td>
</tr>
</tbody>
</table>
<h3 id="classification-of-algorithms">Classification of Algorithms</h3>
<p>As seen in the table, motif discovery algorithms can be divided into two general categories: those based on exact counting and those using statistical sampling and estimations instead. Because the second group does not count all the occurrences of a subgraph in the main network, the algorithms belonging to this group are faster, but they might yield in biased and unrealistic results.</p>
<p>In the next level, the exact counting algorithms can be classified to network-centric and subgraph-centric methods. The algorithms of the first class search the given network for all subgraphs of a given size, while the algorithms falling into the second class first generate different possible non-isomorphic graphs of the given size, and then explore the network for each generated subgraph separately. Each approach has its advantages and disadvantages which are discussed above.</p>
<p>On the other hand, estimation methods might utilize color-coding approach as described before. Other approaches used in this category usually skip some subgraphs during enumeration (e.g., as in FANMOD) and base their estimation on the enumerated subgraphs.</p>
<p>Furthermore, table indicates whether an algorithm can be used for directed or undirected networks as well as induced or non-induced subgraphs. For more information refer to the provided web links or lab addresses.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Classification of Motif Discovery Algorithms</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Counting Method</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>Exact</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><a href="http://theinf1.informatik.uni-jena.de/~wernicke/motifs/">ESU (FANMOD)</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><a href="http://lbb.ut.ac.ir/Download/LBBsoft/Kavosh/">Kavosh</a> (used in <a href="http://apps.cytoscape.org/apps/cytokavosh">CytoKavosh</a>)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><a href="http://www.dcc.fc.up.pt/gtries/">G-Tries</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>Subgraph-Centric</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><a href="https://www.msu.edu/~jinchen/">NeMoFinder</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><a href="http://people.cs.uchicago.edu/~joshuag/index.html">Grochow-Kellis</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><a href="http://lbb.ut.ac.ir/Download/LBBsoft/MODA/">MODA</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>Estimation / Sampling</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Other Approaches</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><a href="http://theinf1.informatik.uni-jena.de/~wernicke/motifs/">ESU (FANMOD)</a></p></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Addresses of Designers of Algorithms</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Algorithm</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><a href="http://www.weizmann.ac.il/mcb/UriAlon/">mfinder</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><a href="http://mavisto.ipk-gatersleben.de/">FPF (Mavisto)</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><a href="http://theinf1.informatik.uni-jena.de/~wernicke/motifs/">ESU (FANMOD)</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><a href="https://www.msu.edu/~jinchen/">NeMoFinder</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><a href="http://people.cs.uchicago.edu/~joshuag/index.html">Grochow-Kellis</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><a href="http://www.math.tau.ac.il/~nogaa/">N. Alon</a> <em>et al.</em>’s Algorithm</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><a href="http://lbb.ut.ac.ir/Download/LBBsoft/MODA/">MODA</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><a href="http://lbb.ut.ac.ir/Download/LBBsoft/Kavosh/">Kavosh</a> (used in <a href="http://apps.cytoscape.org/apps/cytokavosh">CytoKavosh</a>)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><a href="http://www.dcc.fc.up.pt/gtries/">G-Tries</a></p></td>
</tr>
</tbody>
</table>
<h2 id="well-established-motifs-and-their-functions">Well-Established Motifs and Their Functions</h2>
<p>Much experimental work has been devoted to understanding network motifs in <a href="gene_regulatory_networks" title="wikilink">gene regulatory networks</a>. These networks control which genes are expressed in the cell in response to biological signals. The network is defined such that genes are nodes, and directed edges represent the control of one gene by a transcription factor (regulatory protein that binds DNA) encoded by another gene. Thus, network motifs are patterns of genes regulating each other's transcription rate. When analyzing transcription networks, it is seen that the same network motifs appear again and again in diverse organisms from bacteria to human. The transcription network of <em><a href="Escherichia_coli" title="wikilink">E. coli</a></em> and yeast, for example, is made of three main motif families, that make up almost the entire network. The leading hypothesis is that the network motif were independently selected by evolutionary processes in a converging manner,<a class="footnoteRef" href="#fn78" id="fnref78"><sup>78</sup></a><a class="footnoteRef" href="#fn79" id="fnref79"><sup>79</sup></a> since the creation or elimination of regulatory interactions is fast on evolutionary time scale, relative to the rate at which genes change,<a class="footnoteRef" href="#fn80" id="fnref80"><sup>80</sup></a><a class="footnoteRef" href="#fn81" id="fnref81"><sup>81</sup></a><a class="footnoteRef" href="#fn82" id="fnref82"><sup>82</sup></a> Furthermore, experiments on the dynamics generated by network motifs in living cells indicate that they have characteristic dynamical functions. This suggests that the network motif serve as building blocks in gene regulatory networks that are beneficial to the organism.</p>
<p>The functions associated with common network motifs in transcription networks were explored and demonstrated by several research projects both theoretically and experimentally. Below are some of the most common network motifs and their associated function.</p>
<h3 id="negative-auto-regulation-nar">Negative auto-regulation (NAR)</h3>
<p> One of simplest and most abundant network motifs in <em><a href="Escherichia_coli" title="wikilink">E. coli</a></em> is negative auto-regulation in which a transcription factor (TF) represses its own transcription. This motif was shown to perform two important functions. The first function is response acceleration. NAR was shown to speed-up the response to signals both theoretically <a class="footnoteRef" href="#fn83" id="fnref83"><sup>83</sup></a> and experimentally. This was first shown in a synthetic transcription network<a class="footnoteRef" href="#fn84" id="fnref84"><sup>84</sup></a> and later on in the natural context in the SOS DNA repair system of E .coli.<a class="footnoteRef" href="#fn85" id="fnref85"><sup>85</sup></a> The second function is increased stability of the auto-regulated gene product concentration against stochastic noise, thus reducing variations in protein levels between different cells.<a class="footnoteRef" href="#fn86" id="fnref86"><sup>86</sup></a><a class="footnoteRef" href="#fn87" id="fnref87"><sup>87</sup></a></p>
<h3 id="positive-auto-regulation-par">Positive auto-regulation (PAR)</h3>
<p>Positive auto-regulation (PAR) occurs when a transcription factor enhances its own rate of production. Opposite to the NAR motif this motif slows the response time compared to simple regulation.<a class="footnoteRef" href="#fn88" id="fnref88"><sup>88</sup></a> In the case of a strong PAR the motif may lead to a bimodal distribution of protein levels in cell populations.<a class="footnoteRef" href="#fn89" id="fnref89"><sup>89</sup></a></p>
<h3 id="feed-forward-loops-ffl">Feed-forward loops (FFL)</h3>
<p> This motif is commonly found in many gene systems and organisms. The motif consists of three genes and three regulatory interactions. The target gene C is regulated by 2 TFs A and B and in addition TF B is also regulated by TF A . Since each of the regulatory interactions may either be positive or negative there are possibly eight types of FFL motifs.<a class="footnoteRef" href="#fn90" id="fnref90"><sup>90</sup></a> Two of those eight types: the coherent type 1 FFL (C1-FFL) (where all interactions are positive) and the incoherent type 1 FFL (I1-FFL) (A activates C and also activates B which represses C) are found much more frequently in the transcription network of <em><a href="Escherichia_coli" title="wikilink">E. coli</a></em> and yeast than the other six types.<a class="footnoteRef" href="#fn91" id="fnref91"><sup>91</sup></a><a class="footnoteRef" href="#fn92" id="fnref92"><sup>92</sup></a> In addition to the structure of the circuitry the way in which the signals from A and B are integrated by the C promoter should also be considered. In most of the cases the FFL is either an AND gate (A and B are required for C activation) or OR gate (either A or B are sufficient for C activation) but other input function are also possible.</p>
<h3 id="coherent-type-1-ffl-c1-ffl">Coherent type 1 FFL (C1-FFL)</h3>
<p>The C1-FFL with an AND gate was shown to have a function of a ‘sign-sensitive delay’ element and a persistence detector both theoretically <a class="footnoteRef" href="#fn93" id="fnref93"><sup>93</sup></a> and experimentally<a class="footnoteRef" href="#fn94" id="fnref94"><sup>94</sup></a> with the arabinose system of <em><a href="Escherichia_coli" title="wikilink">E. coli</a></em>. This means that this motif can provide pulse filtration in which short pulses of signal will not generate a response but persistent signals will generate a response after short delay. The shut off of the output when a persistent pulse is ended will be fast. The opposite behavior emerges in the case of a sum gate with fast response and delayed shut off as was demonstrated in the flagella system of <em><a href="Escherichia_coli" title="wikilink">E. coli</a></em>.<a class="footnoteRef" href="#fn95" id="fnref95"><sup>95</sup></a></p>
<h3 id="incoherent-type-1-ffl-i1-ffl">Incoherent type 1 FFL (I1-FFL)</h3>
<p>The I1-FFL is a pulse generator and response accelerator. The two signal pathways of the I1-FFL act in opposite directions where one pathway activates Z and the other represses it. When the repression is complete this leads to a pulse-like dynamics. It was also demonstrated experimentally that the I1-FFL can serve as response accelerator in a way which is similar to the NAR motif. The difference is that the I1-FFL can speed-up the response of any gene and not necessarily a transcription factor gene.<a class="footnoteRef" href="#fn96" id="fnref96"><sup>96</sup></a> Recently additional function was assigned to the I1-FFL network motif: it was shown both theoretically and experimentally that the I1-FFL can generate non-monotonic input function in both a synthetic <a class="footnoteRef" href="#fn97" id="fnref97"><sup>97</sup></a> and native systems.<a class="footnoteRef" href="#fn98" id="fnref98"><sup>98</sup></a></p>
<h3 id="multi-output-ffls">Multi-output FFLs</h3>
<p>In some cases the same regulators X and Y regulate several Z genes of the same system. By adjusting the strength of the interactions this motif was shown to determine the temporal order of gene activation. This was demonstrated experimentally in the flagella system of <em><a href="Escherichia_coli" title="wikilink">E. coli</a></em>.<a class="footnoteRef" href="#fn99" id="fnref99"><sup>99</sup></a></p>
<h3 id="single-input-modules-sim">Single-input modules (SIM)</h3>
<p>This motif occurs when a single regulator regulates a set of genes with no additional regulation. This is useful when the genes are cooperatively carrying out a specific function and therefore always need to be activated in a synchronized manner. By adjusting the strength of the interactions it can create temporal expression program of the genes it regulates.<a class="footnoteRef" href="#fn100" id="fnref100"><sup>100</sup></a></p>
<p>In the literature, Multiple-input modules (MIM) arose as a generalization of SIM. However, the precise definitions of SIM and MIM have been a source of inconsistency. There are attempts to provide orthogonal definitions for canonical motifs in biological networks and algorithms to enumerate them, especially SIM, MIM and Bi-Fan (2x2 MIM).<a class="footnoteRef" href="#fn101" id="fnref101"><sup>101</sup></a></p>
<h3 id="dense-overlapping-regulons-dor">Dense overlapping regulons (DOR)</h3>
<p>This motif occurs in the case that several regulators combinatorially control a set of genes with diverse regulatory combinations. This motif was found in <em><a href="Escherichia_coli" title="wikilink">E. coli</a></em> in various systems such as carbon utilization, anaerobic growth, stress response and others.<a class="footnoteRef" href="#fn102" id="fnref102"><sup>102</sup></a><a class="footnoteRef" href="#fn103" id="fnref103"><sup>103</sup></a> In order to better understand the function of this motif one has to obtain more information about the way the multiple inputs are integrated by the genes. Kaplan <em>et al.</em><a class="footnoteRef" href="#fn104" id="fnref104"><sup>104</sup></a> has mapped the input functions of the sugar utilization genes in <em><a href="Escherichia_coli" title="wikilink">E. coli</a></em>, showing diverse shapes.</p>
<h2 id="activity-motifs">Activity motifs</h2>
<p>An interesting generalization of the network-motifs, <strong>activity motifs</strong> are over occurring patterns that can be found when nodes and edges in the network are annotated with quantitative features. For instance, when edges in a metabolic pathways are annotated with the magnitude or timing of the corresponding gene expression, some patterns are over occurring <strong>given</strong> the underlying network structure.<a class="footnoteRef" href="#fn105" id="fnref105"><sup>105</sup></a></p>
<h2 id="criticism">Criticism</h2>
<p>An assumption (sometimes more sometimes less implicit) behind the preservation of a topological sub-structure is that it is of a particular functional importance. This assumption has recently been questioned. Some authors have argued that motifs, like <em>bi-fan motifs</em>, might show a variety depending on the network context, and therefore,<a class="footnoteRef" href="#fn106" id="fnref106"><sup>106</sup></a> structure of the motif does not necessarily determine function. Network structure certainly does not always indicate function; this is an idea that has been around for some time, for an example see the Sin operon.<a class="footnoteRef" href="#fn107" id="fnref107"><sup>107</sup></a></p>
<p>Most analyses of motif function are carried out looking at the motif operating in isolation. Recent research<a class="footnoteRef" href="#fn108" id="fnref108"><sup>108</sup></a> provides good evidence that network context, i.e. the connections of the motif to the rest of the network, is too important to draw inferences on function from local structure only — the cited paper also reviews the criticisms and alternative explanations for the observed data. An analysis of the impact of a single motif module on the global dynamics of a network is studied in.<a class="footnoteRef" href="#fn109" id="fnref109"><sup>109</sup></a> Yet another recent work suggests that certain topological features of biological networks naturally give rise to the common appearance of canonical motifs, thereby questioning whether frequencies of occurrences are reasonable evidence that the structures of motifs are selected for their functional contribution to the operation of networks.<a class="footnoteRef" href="#fn110" id="fnref110"><sup>110</sup></a></p>
<h2 id="see-also">See Also</h2>
<p><a href="Clique_(graph_theory)" title="wikilink">Clique (graph theory)</a></p>
<p><a href="Graphical_model" title="wikilink">Graphical model</a></p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.weizmann.ac.il/mcb/UriAlon/">Uri Alon's web page</a></li>
<li><a href="http://www.weizmann.ac.il/mcb/UriAlon/groupNetworkMotifSW.html">A software tool that can detect network motifs</a></li>
<li><a href="http://www.bio-physics.at/wiki/index.php?title=Network_Motifs">bio-physics-wiki NETWORK MOTIFS</a></li>
<li><a href="http://theinf1.informatik.uni-jena.de/~wernicke/motifs/">FANMOD: a tool for fast network motif detection</a></li>
<li><a href="http://mavisto.ipk-gatersleben.de/">MAVisto: network motif analysis and visualisation tool</a></li>
<li><a href="https://www.msu.edu/~jinchen/">NeMoFinder</a></li>
<li><a href="http://people.cs.uchicago.edu/~joshuag/index.html">Grochow-Kellis</a></li>
<li><a href="http://www.math.tau.ac.il/~nogaa/">Noga Alon's web page</a></li>
<li><a href="http://lbb.ut.ac.ir/Download/LBBsoft/MODA/">MODA</a></li>
<li><a href="http://lbb.ut.ac.ir/Download/LBBsoft/Kavosh/">Kavosh</a></li>
<li><a href="http://apps.cytoscape.org/apps/cytokavosh">CytoKavosh</a></li>
<li><a href="http://www.dcc.fc.up.pt/gtries/">G-Tries</a></li>
<li><a href="http://www.ft.unicamp.br/docentes/meira/accmotifs/">acc-MOTIF detection tool</a></li>
</ul>
<p>"</p>
<p><a href="Category:Gene_expression" title="wikilink">Category:Gene expression</a> <a class="uri" href="Category:Networks" title="wikilink">Category:Networks</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a class="uri" href="http://www.ft.unicamp.br/docentes/meira/accmotifs/">http://www.ft.unicamp.br/docentes/meira/accmotifs/</a><a href="#fnref25">↩</a></li>
<li id="fn26"></li>
<li id="fn27"></li>
<li id="fn28"></li>
<li id="fn29"></li>
<li id="fn30"></li>
<li id="fn31"></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"></li>
<li id="fn34"></li>
<li id="fn35"></li>
<li id="fn36"></li>
<li id="fn37"></li>
<li id="fn38"></li>
<li id="fn39"></li>
<li id="fn40"></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42"><a href="#fnref42">↩</a></li>
<li id="fn43"></li>
<li id="fn44"><a href="#fnref44">↩</a></li>
<li id="fn45"><a href="#fnref45">↩</a></li>
<li id="fn46"></li>
<li id="fn47"><a href="#fnref47">↩</a></li>
<li id="fn48"></li>
<li id="fn49"><a href="#fnref49">↩</a></li>
<li id="fn50"></li>
<li id="fn51"></li>
<li id="fn52"><a href="#fnref52">↩</a></li>
<li id="fn53"></li>
<li id="fn54"></li>
<li id="fn55"></li>
<li id="fn56"></li>
<li id="fn57"><a href="#fnref57">↩</a></li>
<li id="fn58"></li>
<li id="fn59"></li>
<li id="fn60"><a href="#fnref60">↩</a></li>
<li id="fn61"></li>
<li id="fn62"><a href="#fnref62">↩</a></li>
<li id="fn63"><a href="#fnref63">↩</a></li>
<li id="fn64"></li>
<li id="fn65"><a href="#fnref65">↩</a></li>
<li id="fn66"></li>
<li id="fn67"></li>
<li id="fn68"></li>
<li id="fn69"><a href="#fnref69">↩</a></li>
<li id="fn70"><a href="#fnref70">↩</a></li>
<li id="fn71"></li>
<li id="fn72"></li>
<li id="fn73"></li>
<li id="fn74"></li>
<li id="fn75"></li>
<li id="fn76"></li>
<li id="fn77"></li>
<li id="fn78"><a href="#fnref78">↩</a></li>
<li id="fn79"><a href="#fnref79">↩</a></li>
<li id="fn80"></li>
<li id="fn81"></li>
<li id="fn82"><a href="#fnref82">↩</a></li>
<li id="fn83"><a href="#fnref83">↩</a></li>
<li id="fn84"><a href="#fnref84">↩</a></li>
<li id="fn85"><a href="#fnref85">↩</a></li>
<li id="fn86"><a href="#fnref86">↩</a></li>
<li id="fn87"><a href="#fnref87">↩</a></li>
<li id="fn88"><a href="#fnref88">↩</a></li>
<li id="fn89"><a href="#fnref89">↩</a></li>
<li id="fn90"><a href="#fnref90">↩</a></li>
<li id="fn91"></li>
<li id="fn92"><a href="#fnref92">↩</a></li>
<li id="fn93"></li>
<li id="fn94"><a href="#fnref94">↩</a></li>
<li id="fn95"><a href="#fnref95">↩</a></li>
<li id="fn96"><a href="#fnref96">↩</a></li>
<li id="fn97"><a href="#fnref97">↩</a></li>
<li id="fn98"><a href="#fnref98">↩</a></li>
<li id="fn99"><a href="#fnref99">↩</a></li>
<li id="fn100"><a href="#fnref100">↩</a></li>
<li id="fn101"><a href="#fnref101">↩</a></li>
<li id="fn102"></li>
<li id="fn103"></li>
<li id="fn104"><a href="#fnref104">↩</a></li>
<li id="fn105"><a href="#fnref105">↩</a></li>
<li id="fn106"><a href="#fnref106">↩</a></li>
<li id="fn107"><a href="#fnref107">↩</a></li>
<li id="fn108"><a href="#fnref108">↩</a></li>
<li id="fn109"><a href="#fnref109">↩</a></li>
<li id="fn110"><a href="#fnref110">↩</a></li>
</ol>
</section>
</body>
</html>
