<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1080">Beeman's algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Beeman's algorithm</h1>
<hr/>

<p><strong>Beeman's algorithm</strong> is a method for <a href="numerical_quadrature" title="wikilink">numerically integrating</a> <a href="ordinary_differential_equation" title="wikilink">ordinary differential equations</a> of order 2, more specifically Newton's equations of motion 

<math display="inline" id="Beeman's_algorithm:0">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>x</mi>
    <mo>¨</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¨</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ddot{x}=A(x)
  </annotation>
 </semantics>
</math>

. It was designed to allow high numbers of particles in simulations of molecular dynamics. There is a direct or explicit and an implicit variant of the method. The direct variant was published by Schofield <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> in 1973 as a personal communication from Beeman. This is what is commonly known as <strong>Beeman's method</strong>. It is a variant of the <a href="Verlet_integration" title="wikilink">Verlet integration</a> method. It produces identical positions, but uses a different formula for the velocities. Beeman<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> in 1976 published a class of implicit (predictor-corrector) multi-step methods, where <strong>Beeman's method</strong> is the direct variant of the third order method in this class.</p>
<h2 id="equation">Equation</h2>

<p>The formula used to compute the positions at time 

<math display="inline" id="Beeman's_algorithm:1">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>+</mo>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>t</ci>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t+\Delta t
  </annotation>
 </semantics>
</math>

 in the full predictor-corrector<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> scheme is:</p>
<ul>
<li>Predict 

<math display="inline" id="Beeman's_algorithm:2">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>t</mi>
     <mo>+</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>t</ci>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t+\Delta t)
  </annotation>
 </semantics>
</math>

 from data at times 

<math display="inline" id="Beeman's_algorithm:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mtext>and</mtext>
    <mi>t</mi>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>t</ci>
     <mtext>and</mtext>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\text{ and }t-\Delta t
  </annotation>
 </semantics>
</math>

</li>
</ul>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>x(t+\Delta t) = x(t) + v(t) \Delta t</p>

<p><code> + \frac{1}{6}\Bigl( 4 a(t) - a(t - \Delta t)\Bigr)\Delta t^2</code><br/>
<code> + O( \Delta t^4)</code></p>

<p>.</p>
<ul>
<li>Correct position and velocities at time 

<math display="inline" id="Beeman's_algorithm:4">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>+</mo>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>t</ci>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t+\Delta t
  </annotation>
 </semantics>
</math>

 from data at times 

<math display="inline" id="Beeman's_algorithm:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mtext>and</mtext>
    <mi>t</mi>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>t</ci>
     <mtext>and</mtext>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\text{ and }t+\Delta t
  </annotation>
 </semantics>
</math>

 by repeated evaluation of the differential equation to get the acceleration 

<math display="inline" id="Beeman's_algorithm:6">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>t</mi>
     <mo>+</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <apply>
     <plus></plus>
     <ci>t</ci>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(t+\Delta t)
  </annotation>
 </semantics>
</math>

 and of the equations of the implicit system</li>
</ul>
<dl>
<dd><dl>
<dd><math>\begin{align}
</math></dd>
</dl>
</dd>
</dl>

<p>x(t+\Delta t) &amp;= x(t) + v(t) \Delta t</p>

<p><code>  + \frac{1}{6}\Bigl(a(t+\Delta t) + 2a(t)\Bigr)\Delta t^2 </code><br/>
<code>  + O(\Delta t^4);\\</code></p>

<p>v(t+\Delta t)\Delta t &amp;=x(t+\Delta t)-x(t)</p>

<p><code>  + \frac16 \Bigl(2a(t+\Delta t) + a(t)\Bigr)\Delta t^2</code><br/>
<code>  + O(\Delta t^4);</code></p>

<p>\end{align}</p>
<dl>
<dd>In tests it was found that this corrector step needs to be repeated at most twice. The values on the right are the old values of the last iterations, resulting in the new values on the left.
</dd>
</dl>

<p>Using only the predictor formula and the corrector for the velocities one obtains a direct or explicit method<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> which is a variant of the Verlet integration method:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>

<math display="inline" id="Beeman's_algorithm:7">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>t</mi>
     <mo>+</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>t</ci>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle x(t+\Delta t)
  </annotation>
 </semantics>
</math>


</p>

<p>This is the variant that is usually understood as <em>Beeman's method</em>.</p>

<p>Beeman<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> also proposed to alternatively replace the velocity update in the last equation by the second order <a href="Linear_multistep_method#Adams–Moulton_methods" title="wikilink">Adams–Moulton method</a>:</p>

<p>

<math display="block" id="Beeman's_algorithm:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>t</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>v</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>12</mn>
     </mfrac>
     <mrow>
      <mo maxsize="160%" minsize="160%">(</mo>
      <mrow>
       <mrow>
        <mrow>
         <mn>5</mn>
         <mi>a</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>t</mi>
           <mo>+</mo>
           <mrow>
            <mi mathvariant="normal">Δ</mi>
            <mi>t</mi>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mn>8</mn>
         <mi>a</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>a</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>t</mi>
          <mo>-</mo>
          <mrow>
           <mi mathvariant="normal">Δ</mi>
           <mi>t</mi>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo maxsize="160%" minsize="160%">)</mo>
     </mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>t</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <msup>
        <mi>t</mi>
        <mn>3</mn>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>v</ci>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>v</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">12</cn>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <cn type="integer">5</cn>
         <ci>a</ci>
         <apply>
          <plus></plus>
          <ci>t</ci>
          <apply>
           <times></times>
           <ci>normal-Δ</ci>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">8</cn>
         <ci>a</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <ci>t</ci>
         <apply>
          <times></times>
          <ci>normal-Δ</ci>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>normal-Δ</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>t</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(t+\Delta t)=v(t)+\frac{1}{12}\Bigl(5a(t+\Delta t)+8a(t)-a(t-\Delta t)\Bigr)%
\Delta t+O(\Delta t^{3})
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>
<ul>
<li>

<math display="inline" id="Beeman's_algorithm:9">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is present time (i.e.: independent variable)</li>
<li>

<math display="inline" id="Beeman's_algorithm:10">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta t
  </annotation>
 </semantics>
</math>

 is the time step size</li>
<li>

<math display="inline" id="Beeman's_algorithm:11">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t)
  </annotation>
 </semantics>
</math>

 is the position at time t</li>
<li>

<math display="inline" id="Beeman's_algorithm:12">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>v</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(t)
  </annotation>
 </semantics>
</math>

 is the velocity at time t</li>
<li>

<math display="inline" id="Beeman's_algorithm:13">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(t)
  </annotation>
 </semantics>
</math>

 is the acceleration at time t, computed as a function of 

<math display="inline" id="Beeman's_algorithm:14">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t)
  </annotation>
 </semantics>
</math>

</li>
<li>the last term is the error term, using the <a href="big_O_notation" title="wikilink">big O notation</a></li>
</ul>
<h2 id="predictor-corrector-modifications">Predictor-Corrector Modifications</h2>

<p>In systems where the forces are a function of velocity in addition to position, the above equations need to be modified into a predictor-corrector form whereby the velocities at time 

<math display="inline" id="Beeman's_algorithm:15">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>+</mo>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>t</ci>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t+\Delta t
  </annotation>
 </semantics>
</math>

 are predicted and the forces calculated, before producing a corrected form of the velocities.</p>

<p>An example is:</p>

<p>

<math display="block" id="Beeman's_algorithm:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mrow>
        <mi mathvariant="normal">Δ</mi>
        <mi>t</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mrow>
        <mi>x</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>v</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi mathvariant="normal">Δ</mi>
        <mi>t</mi>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mfrac>
         <mn>2</mn>
         <mn>3</mn>
        </mfrac>
        <mi>a</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi mathvariant="normal">Δ</mi>
        <msup>
         <mi>t</mi>
         <mn>2</mn>
        </msup>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mn>6</mn>
       </mfrac>
       <mi>a</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>t</mi>
         <mo>-</mo>
         <mrow>
          <mi mathvariant="normal">Δ</mi>
          <mi>t</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi mathvariant="normal">Δ</mi>
       <msup>
        <mi>t</mi>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi mathvariant="normal">Δ</mi>
        <msup>
         <mi>t</mi>
         <mn>4</mn>
        </msup>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <ci>v</ci>
        <ci>t</ci>
        <ci>normal-Δ</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">2</cn>
         <cn type="integer">3</cn>
        </apply>
        <ci>a</ci>
        <ci>t</ci>
        <ci>normal-Δ</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>t</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">6</cn>
       </apply>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <apply>
         <times></times>
         <ci>normal-Δ</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <ci>normal-Δ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>t</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>t</ci>
        <cn type="integer">4</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t+\Delta t)=x(t)+v(t)\Delta t+\frac{2}{3}a(t)\Delta t^{2}-\frac{1}{6}a(t-%
\Delta t)\Delta t^{2}+O(\Delta t^{4}).
  </annotation>
 </semantics>
</math>

</p>

<p>The velocities at time t =

<math display="inline" id="Beeman's_algorithm:17">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>+</mo>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>t</ci>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t+\Delta t
  </annotation>
 </semantics>
</math>

 are then calculated from the positions.</p>

<p>

<math display="block" id="Beeman's_algorithm:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>t</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>p</mi>
      <mi>r</mi>
      <mi>e</mi>
      <mi>d</mi>
      <mi>i</mi>
      <mi>c</mi>
      <mi>t</mi>
      <mi>e</mi>
      <mi>d</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mi>v</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <mn>3</mn>
        <mn>2</mn>
       </mfrac>
       <mi>a</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>t</mi>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mrow>
         <mi mathvariant="normal">Δ</mi>
         <mi>t</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi mathvariant="normal">Δ</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <msup>
        <mi>t</mi>
        <mn>3</mn>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>v</ci>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>r</ci>
      <ci>e</ci>
      <ci>d</ci>
      <ci>i</ci>
      <ci>c</ci>
      <ci>t</ci>
      <ci>e</ci>
      <ci>d</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>v</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">3</cn>
         <cn type="integer">2</cn>
        </apply>
        <ci>a</ci>
        <ci>t</ci>
        <ci>normal-Δ</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <apply>
         <times></times>
         <ci>normal-Δ</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <ci>normal-Δ</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>t</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(t+\Delta t)(predicted)=v(t)+\frac{3}{2}a(t)\Delta t-\frac{1}{2}a(t-\Delta t)%
\Delta t+O(\Delta t^{3})
  </annotation>
 </semantics>
</math>

</p>

<p>The accelerations at time t =

<math display="inline" id="Beeman's_algorithm:19">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>+</mo>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>t</ci>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t+\Delta t
  </annotation>
 </semantics>
</math>

 are then calculated from the positions and predicted velocities.</p>

<p>

<math display="block" id="Beeman's_algorithm:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>t</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>c</mi>
      <mi>o</mi>
      <mi>r</mi>
      <mi>r</mi>
      <mi>e</mi>
      <mi>c</mi>
      <mi>t</mi>
      <mi>e</mi>
      <mi>d</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mi>v</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <mn>5</mn>
        <mn>12</mn>
       </mfrac>
       <mi>a</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>t</mi>
         <mo>+</mo>
         <mrow>
          <mi mathvariant="normal">Δ</mi>
          <mi>t</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>t</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <mn>2</mn>
        <mn>3</mn>
       </mfrac>
       <mi>a</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>t</mi>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>12</mn>
      </mfrac>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mrow>
         <mi mathvariant="normal">Δ</mi>
         <mi>t</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi mathvariant="normal">Δ</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <msup>
        <mi>t</mi>
        <mn>3</mn>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>v</ci>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>o</ci>
      <ci>r</ci>
      <ci>r</ci>
      <ci>e</ci>
      <ci>c</ci>
      <ci>t</ci>
      <ci>e</ci>
      <ci>d</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>v</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">5</cn>
         <cn type="integer">12</cn>
        </apply>
        <ci>a</ci>
        <apply>
         <plus></plus>
         <ci>t</ci>
         <apply>
          <times></times>
          <ci>normal-Δ</ci>
          <ci>t</ci>
         </apply>
        </apply>
        <ci>normal-Δ</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">2</cn>
         <cn type="integer">3</cn>
        </apply>
        <ci>a</ci>
        <ci>t</ci>
        <ci>normal-Δ</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">12</cn>
       </apply>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <apply>
         <times></times>
         <ci>normal-Δ</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <ci>normal-Δ</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>t</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(t+\Delta t)(corrected)=v(t)+\frac{5}{12}a(t+\Delta t)\Delta t+\frac{2}{3}a(t%
)\Delta t-\frac{1}{12}a(t-\Delta t)\Delta t+O(\Delta t^{3})
  </annotation>
 </semantics>
</math>

</p>
<h2 id="error-term">Error term</h2>

<p>As shown above, the local error term is 

<math display="inline" id="Beeman's_algorithm:21">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <msup>
      <mi>t</mi>
      <mn>4</mn>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\Delta t^{4})
  </annotation>
 </semantics>
</math>

 for position and 

<math display="inline" id="Beeman's_algorithm:22">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <msup>
      <mi>t</mi>
      <mn>3</mn>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\Delta t^{3})
  </annotation>
 </semantics>
</math>

 velocity,resulting in a global error of 

<math display="inline" id="Beeman's_algorithm:23">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <msup>
      <mi>t</mi>
      <mn>3</mn>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\Delta t^{3})
  </annotation>
 </semantics>
</math>

. In comparison, Verlet is 

<math display="inline" id="Beeman's_algorithm:24">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <msup>
      <mi>t</mi>
      <mn>4</mn>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\Delta t^{4})
  </annotation>
 </semantics>
</math>

 for position and 

<math display="inline" id="Beeman's_algorithm:25">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <msup>
      <mi>t</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\Delta t^{2})
  </annotation>
 </semantics>
</math>

 for velocity. However, the more important global error is 

<math display="inline" id="Beeman's_algorithm:26">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <msup>
      <mi>t</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\Delta t^{2})
  </annotation>
 </semantics>
</math>

. In exchange for greater accuracy, Beeman's algorithm is moderately computationally more expensive.</p>
<h2 id="memory-requirements">Memory Requirements</h2>

<p>The simulation must keep track of position, velocity, acceleration and previous acceleration vectors per particle (though some clever work-arounds for storing the previous acceleration vector are possible), keeping its memory requirements on par with velocity Verlet and slightly more expensive than the original Verlet method.</p>
<h2 id="references">References</h2>
<references>

<p><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
</references>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_differential_equations" title="wikilink">Category:Numerical differential equations</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
</ol>
</section>
</body>
</html>
