<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="783">Maximum disjoint set</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Maximum disjoint set</h1>
<hr/>

<p>In <a href="computational_geometry" title="wikilink">computational geometry</a>, a <strong>maximum disjoint set (MDS)</strong> is a largest set of non-overlapping geometric shapes selected from a given set of candidate shapes.</p>

<p>Finding an MDS is important in applications such as <a href="automatic_label_placement" title="wikilink">automatic label placement</a>, <a class="uri" href="VLSI" title="wikilink">VLSI</a> circuit design, and cellular <a href="frequency_division_multiplexing" title="wikilink">frequency division multiplexing</a>.</p>

<p>Every set of non-overlapping shapes is an <a href="independent_set_(graph_theory)" title="wikilink">independent set</a> in the <a href="intersection_graph" title="wikilink">intersection graph</a> of the shapes. Therefore, the MDS problem is a special case of the <a href="maximum_independent_set" title="wikilink">maximum independent set</a> (MIS) problem. Both problems are <a href="NP_complete" title="wikilink">NP complete</a>, but finding a MDS may be easier than finding a MIS in two respects:</p>
<ul>
<li>For the general MIS problem, the best known exact algorithms are exponential. In some geometric intersection graphs, there are sub-exponential algorithms for finding a MDS.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></li>
<li>The general MIS problem is hard to approximate and doesn't even have a constant-factor approximation. In some geometric intersection graphs, there are <a href="polynomial-time_approximation_scheme" title="wikilink">polynomial-time approximation schemes</a> (PTAS) for finding a MDS.</li>
</ul>

<p>The MDS problem can be generalized by assigning a different weight to each shape and searching for a disjoint set with a maximum total weight.</p>

<p>In the following text, MDS(<em>C</em>) denotes the maximum disjoint set in a set <em>C</em>.</p>
<h2 id="greedy-algorithms">Greedy algorithms</h2>

<p>Given a set <em>C</em> of shapes, an approximation to MDS(<em>C</em>) can be found by the following <a href="greedy_algorithm" title="wikilink">greedy algorithm</a>:</p>
<ul>
<li>INITIALIZATION: Initialize an empty set, <em>S</em>.</li>
<li>SEARCH: For every shape <em>x</em> in <em>C</em>:
<ol>
<li>Calculate <em>N(x)</em> - the subset of all shapes in <em>C</em> that intersect <em>x</em> (including <em>x</em> itself).</li>
<li>Calculate the largest independent set in this subset: <em>MDS(N(x))</em>.</li>
<li>Select an <em>x</em> such that <em>|MDS(N(x))|</em> is minimized.</li>
</ol></li>
<li>Add <em>x</em> to <em>S</em>.</li>
<li>Remove <em>x</em> and <em>N(x)</em> from <em>C</em>.</li>
<li>If there are shapes in <em>C</em>, go back to Search.</li>
<li>END: return the set <em>S</em>.</li>
</ul>

<p>For every shape <em>x</em> that we add to <em>S</em>, we lose the shapes in <em>N(x)</em>, because they are intersected by <em>x</em> and thus cannot be added to <em>S</em> later on. However, some of these shapes themselves intersect each other, and thus in any case it is not possible that they all be in the optimal solution <em>MDS(S)</em>. The largest subset of shapes that <em>can</em> all be in the optimal solution is <em>MDS(N(x))</em>. Therefore, selecting an <em>x</em> that minimizes <em>|MDS(N(x))|</em> minimizes the loss from adding <em>x</em> to <em>S</em>.</p>

<p>In particular, if we can guarantee that there is an <em>x</em> for which <em>|MDS(N(x))|</em> is bounded by a constant (say, <em>M</em>), then this greedy algorithm yields a constant <em>M</em>-factor approximation, as we can guarantee that:</p>

<p>

<math display="inline" id="Maximum_disjoint_set:0">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>S</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≥</mo>
   <mfrac>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>M</mi>
      <mi>D</mi>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mi>M</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <abs></abs>
     <ci>S</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>M</ci>
       <ci>D</ci>
       <ci>S</ci>
       <ci>C</ci>
      </apply>
     </apply>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |S|\geq\frac{|MDS(C)|}{M}
  </annotation>
 </semantics>
</math>

</p>

<p>Such an upper bound <em>M</em> exists for several interesting cases:</p>
<h3 id="dimensional-intervals-exact-polynomial-algorithm">1-dimensional intervals: exact polynomial algorithm</h3>

<p> When <em>C</em> is a set of intervals on a line, <em>M</em>=1, and thus the greedy algorithm finds the exact MDS. To see this, assume w.l.o.g. that the intervals are vertical, and let <em>x</em> be the interval with the <em>highest bottom endpoint</em>. All other intervals intersected by <em>x</em> must cross its bottom endpoint. Therefore, all intervals in <em>N(x)</em> intersect each other, and <em>MDS(N(x))</em> has a size of at most 1 (see figure).</p>

<p>Therefore, in the 1-dimensional case, the MDS can be found exactly in time <em>O</em>(<em>n</em> log <em>n</em>):<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<ol>
<li>Sort the intervals in ascending order of their bottom endpoints (this takes time <em>O</em>(<em>n</em> log <em>n</em>)).</li>
<li>Add an interval with the highest bottom endpoint, and delete all intervals intersecting it.</li>
<li>Continue until no intervals remain.</li>
</ol>

<p>This algorithm is analogous to the <a href="earliest_deadline_first_scheduling" title="wikilink">earliest deadline first scheduling</a> solution to the <a href="interval_scheduling" title="wikilink">interval scheduling</a> problem.</p>

<p>In contrast to the 1-dimensional case, in 2 or more dimensions the MDS problem becomes NP-complete, and thus has either exact super-polynomial algorithms or approximate polynomial algorithms.</p>
<h3 id="fat-shapes-constant-factor-approximations">Fat shapes: constant-factor approximations</h3>

<p> When <em>C</em> is a set of unit disks, <em>M</em>=3,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> because the leftmost disk (the disk whose center has the smallest <em>x</em> coordinate) intersects at most 3 other disjoint disks (see figure). Therefore the greedy algorithm yields a 3-approximation, i.e., it finds a disjoint set with a size of at least <em>MDS(C)</em>/3.</p>

<p>Similarly, when <em>C</em> is a set of axis-parallel unit squares, <em>M</em>=2.</p>

<p> When <em>C</em> is a set of arbitrary-size disks, <em>M</em>=5, because the disk with the smallest radius intersects at most 5 other disjoint disks (see figure).</p>

<p>Similarly, when <em>C</em> is a set of arbitrary-size axis-parallel squares, <em>M</em>=4.</p>

<p>Other constants can be calculated for other <a href="regular_polygon" title="wikilink">regular polygons</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="divide-and-conquer-algorithms">Divide-and-conquer algorithms</h2>

<p>The most common approach to finding a MDS is divide-and-conquer. A typical algorithm in this approach looks like the following:</p>
<ol>
<li>Divide the given set of shapes into two or more subsets, such that the shapes in each subset cannot overlap the shapes in other subsets because of geometric considerations.</li>
<li>Recursively find the MDS in each subset separately.</li>
<li>Return the union of the MDSs from all subsets.</li>
</ol>

<p>The main challenge with this approach is to find a geometric way to divide the set into subsets. This may require to discard a small number of shapes that do not fit into any one of the subsets, as explained in the following subsections.</p>
<h3 id="axis-parallel-rectangles-logarithmic-factor-approximation">Axis-parallel rectangles: Logarithmic-factor approximation</h3>

<p>Let <em>C</em> be a set of <em>n</em> axis-parallel rectangles in the plane. The following algorithm finds a disjoint set with a size of at least 

<math display="inline" id="Maximum_disjoint_set:1">
 <semantics>
  <mfrac>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>M</mi>
     <mi>D</mi>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>C</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mrow>
    <mi>log</mi>
    <mi>n</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>D</ci>
      <ci>S</ci>
      <ci>C</ci>
     </apply>
    </apply>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{|MDS(C)|}{\log{n}}
  </annotation>
 </semantics>
</math>

 in time 

<math display="inline" id="Maximum_disjoint_set:2">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n\log{n})
  </annotation>
 </semantics>
</math>

:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<ul>
<li>INITIALIZATION: sort the horizontal edges of the given rectangles by their <em>y</em>-coordinate, and the vertical edges by their <em>x</em>-coordinate (this step takes time <em>O</em>(<em>n</em> log <em>n</em>)).</li>
<li>STOP CONDITION: If there are at most <em>n</em> ≤ 2 shapes, compute the MDS directly and return.</li>
<li>RECURSIVE PART:
<ol>
<li>Let 

<math display="inline" id="Maximum_disjoint_set:3">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>med</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>med</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{\mathrm{med}}
  </annotation>
 </semantics>
</math>

 be the median <em>x</em>-coordinate.</li>
<li>Partition the input rectangles into three groups according to their relation to the line 

<math display="inline" id="Maximum_disjoint_set:4">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mi>med</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>med</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=x_{\mathrm{med}}
  </annotation>
 </semantics>
</math>

: those entirely to its left (

<math display="inline" id="Maximum_disjoint_set:5">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>left</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>left</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{\mathrm{left}}
  </annotation>
 </semantics>
</math>

), those entirely to its right (

<math display="inline" id="Maximum_disjoint_set:6">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>right</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>right</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{\mathrm{right}}
  </annotation>
 </semantics>
</math>

), and those intersected by it (

<math display="inline" id="Maximum_disjoint_set:7">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>int</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>int</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{\mathrm{int}}
  </annotation>
 </semantics>
</math>

). By construction, the cardinalities of 

<math display="inline" id="Maximum_disjoint_set:8">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>left</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>left</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{\mathrm{left}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Maximum_disjoint_set:9">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>right</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>right</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{\mathrm{right}}
  </annotation>
 </semantics>
</math>

 are at most <em>n</em>/2.</li>
<li>Recursively compute an <em>approximate</em> MDS in 

<math display="inline" id="Maximum_disjoint_set:10">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>left</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>left</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{\mathrm{left}}
  </annotation>
 </semantics>
</math>

 (

<math display="inline" id="Maximum_disjoint_set:11">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>left</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>left</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{\mathrm{left}}
  </annotation>
 </semantics>
</math>

) and in 

<math display="inline" id="Maximum_disjoint_set:12">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>right</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>right</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{\mathrm{right}}
  </annotation>
 </semantics>
</math>

 (

<math display="inline" id="Maximum_disjoint_set:13">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>right</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>right</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{\mathrm{right}}
  </annotation>
 </semantics>
</math>

), and calculate their union. By construction, the rectangles in 

<math display="inline" id="Maximum_disjoint_set:14">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>left</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>left</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{\mathrm{left}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Maximum_disjoint_set:15">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>right</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>right</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{\mathrm{right}}
  </annotation>
 </semantics>
</math>

 are all disjoint, so 

<math display="inline" id="Maximum_disjoint_set:16">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mi>left</mi>
   </msub>
   <mo>∪</mo>
   <msub>
    <mi>M</mi>
    <mi>right</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>left</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>right</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{\mathrm{left}}\cup M_{\mathrm{right}}
  </annotation>
 </semantics>
</math>

 is a disjoint set.</li>
<li>Compute an <em>exact</em> MDS in 

<math display="inline" id="Maximum_disjoint_set:17">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>int</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>int</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{\mathrm{int}}
  </annotation>
 </semantics>
</math>

 (

<math display="inline" id="Maximum_disjoint_set:18">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>int</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>int</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{\mathrm{int}}
  </annotation>
 </semantics>
</math>

). Since all rectangles in 

<math display="inline" id="Maximum_disjoint_set:19">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>int</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>int</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{\mathrm{int}}
  </annotation>
 </semantics>
</math>

 intersect a single vertical line 

<math display="inline" id="Maximum_disjoint_set:20">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mi>med</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>med</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=x_{\mathrm{med}}
  </annotation>
 </semantics>
</math>

, this computation is equivalent to finding an MDS from a set of intervals, and can be solved exactly in time <em>O(n log n)</em> (see above).</li>
</ol></li>
<li>Return either 

<math display="inline" id="Maximum_disjoint_set:21">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mi>left</mi>
   </msub>
   <mo>∪</mo>
   <msub>
    <mi>M</mi>
    <mi>right</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>left</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>right</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{\mathrm{left}}\cup M_{\mathrm{right}}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Maximum_disjoint_set:22">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>int</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>int</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{\mathrm{int}}
  </annotation>
 </semantics>
</math>

 – whichever of them is larger.</li>
</ul>

<p>It is provable by induction that, at the last step, either 

<math display="inline" id="Maximum_disjoint_set:23">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mi>left</mi>
   </msub>
   <mo>∪</mo>
   <msub>
    <mi>M</mi>
    <mi>right</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>left</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>right</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{\mathrm{left}}\cup M_{\mathrm{right}}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Maximum_disjoint_set:24">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>int</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>int</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{\mathrm{int}}
  </annotation>
 </semantics>
</math>

 have a cardinality of at least 

<math display="inline" id="Maximum_disjoint_set:25">
 <semantics>
  <mfrac>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>M</mi>
     <mi>D</mi>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>C</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mrow>
    <mi>log</mi>
    <mi>n</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>D</ci>
      <ci>S</ci>
      <ci>C</ci>
     </apply>
    </apply>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{|MDS(C)|}{\log{n}}
  </annotation>
 </semantics>
</math>

.</p>

<p>The approximation factor has recently been reduced to 

<math display="inline" id="Maximum_disjoint_set:26">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log{\log{n}})
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> and generalized to the case in which rectangles have different weights.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="axis-parallel-rectangles-with-the-same-height-2-approximation">Axis-parallel rectangles with the same height: 2-approximation</h3>

<p>Let <em>C</em> be a set of <em>n</em> axis-parallel rectangles in the plane, all with the same height <em>H</em> but with varying lengths. The following algorithm finds a disjoint set with a size of at least |MDS(<em>C</em>)|/2 in time <em>O</em>(<em>n</em> log <em>n</em>):<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<ul>
<li>Draw <em>m</em> horizontal lines, such that:
<ol>
<li>The separation between two lines is strictly more than <em>H</em>.</li>
<li>Each line intersects at least one rectangle (hence <em>m</em> ≤ <em>n</em>).</li>
<li>Each rectangle is intersected by exactly one line.</li>
</ol></li>
<li>Since the height of all rectangles is <em>H</em>, it is not possible that a rectangle is intersected by more than one line. Therefore the lines partition the set of rectangles into <em>m</em> subsets (

<math display="inline" id="Maximum_disjoint_set:27">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>i</mi>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>R</mi>
    <mi>m</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>m</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{i},\ldots,R_{m}
  </annotation>
 </semantics>
</math>

) – each subset includes the rectangles intersected by a single line.</li>
<li>For each subset 

<math display="inline" id="Maximum_disjoint_set:28">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{i}
  </annotation>
 </semantics>
</math>

, compute an exact MDS 

<math display="inline" id="Maximum_disjoint_set:29">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{i}
  </annotation>
 </semantics>
</math>

 using the one-dimensional greedy algorithm (see above).</li>
<li>By construction, the rectangles in (

<math display="inline" id="Maximum_disjoint_set:30">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{i}
  </annotation>
 </semantics>
</math>

) can intersect only rectangles in 

<math display="inline" id="Maximum_disjoint_set:31">
 <semantics>
  <msub>
   <mi>R</mi>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{i+1}
  </annotation>
 </semantics>
</math>

 or in 

<math display="inline" id="Maximum_disjoint_set:32">
 <semantics>
  <msub>
   <mi>R</mi>
   <mrow>
    <mi>i</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <apply>
     <minus></minus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{i-1}
  </annotation>
 </semantics>
</math>

. Therefore, each of the following two unions is a disjoint sets:
<ul>
<li>Union of odd MDSs

<math display="block" id="Maximum_disjoint_set:33">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mn>1</mn>
   </msub>
   <mo>∪</mo>
   <msub>
    <mi>M</mi>
    <mn>3</mn>
   </msub>
   <mo>∪</mo>
   <mi mathvariant="normal">⋯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">3</cn>
    </apply>
    <ci>normal-⋯</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{1}\cup M_{3}\cup\cdots
  </annotation>
 </semantics>
</math>

</li>
<li>Union of even MDSs

<math display="block" id="Maximum_disjoint_set:34">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mn>2</mn>
   </msub>
   <mo>∪</mo>
   <msub>
    <mi>M</mi>
    <mn>4</mn>
   </msub>
   <mo>∪</mo>
   <mi mathvariant="normal">⋯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">4</cn>
    </apply>
    <ci>normal-⋯</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{2}\cup M_{4}\cup\cdots
  </annotation>
 </semantics>
</math>

</li>
</ul></li>
<li>Return the largest of these two unions. Its size must be at least |MDS|/2.</li>
</ul>
<h3 id="axis-parallel-rectangles-with-the-same-height-ptas">Axis-parallel rectangles with the same height: PTAS</h3>

<p>Let <em>C</em> be a set of <em>n</em> axis-parallel rectangles in the plane, all with the same height but with varying lengths. There is an algorithm that finds a disjoint set with a size of at least |MDS(<em>C</em>)|/(1 + 1/<em>k</em>) in time <em>O</em>(<em>n</em><sup>2<em>k</em>−1</sup>), for every constant <em>k</em> &gt; 1.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>The algorithm is an improvement of the above-mentioned 2-approximation, by combining <a href="dynamic_programming" title="wikilink">dynamic programming</a> with the shifting technique of.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>This algorithm can be generalized to <em>d</em> dimensions. If the labels have the same size in all dimensions except one, it is possible to find a similar approximation by applying <a href="dynamic_programming" title="wikilink">dynamic programming</a> along one of the dimensions. This also reduces the time to n^O(1/e).<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h3 id="fat-objects-with-identical-sizes-ptas">Fat objects with identical sizes: PTAS</h3>

<p>Let <em>C</em> be a set of <em>n</em> squares or circles of identical size. There is a <a href="polynomial-time_approximation_scheme" title="wikilink">polynomial-time approximation scheme</a> for finding an MDS using a simple shifted-grid strategy. It finds a solution within (1 − <em>e</em>) of the maximum in time <em>n</em><sup><em>O</em>(1/<em>e</em><sup>2</sup>)</sup> time and linear space.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> The strategy generalizes to any collection of <a href="fat_object" title="wikilink">fat objects</a> of roughly the same size (i.e., when the maximum-to-minimum size ratio is bounded by a constant).</p>
<h3 id="fat-objects-with-arbitrary-sizes-ptas">Fat objects with arbitrary sizes: PTAS</h3>

<p>Let <em>C</em> be a set of <em>n</em> <a href="fat_object" title="wikilink">fat objects</a> (e.g. squares or circles) of arbitrary sizes. There is a <a href="polynomial-time_approximation_scheme" title="wikilink">PTAS</a> for finding an MDS based on multi-level grid alignment. It has been discovered by two groups in approximately the same time, and described in two different ways.</p>

<p><strong>Version 1</strong> finds a disjoint set with a size of at least (1 − 1/<em>k</em>)<sup>2</sup> · |MDS(<em>C</em>)| in time <em>n</em><sup><em>O</em>(<em>k</em><sup>2</sup>)</sup>, for every constant <em>k</em> &gt; 1:<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>Scale the disks so that the smallest disk has diameter 1. Partition the disks to levels, based on the logarithm of their size. I.e., the <em>j</em>-th level contains all disks with diameter between (<em>k</em> + 1)<sup><em>j</em></sup> and (<em>k</em> + 1)<sup><em>j</em>+1</sup>, for <em>j</em> ≤ 0 (the smallest disk is in level 0).</p>

<p>For each level <em>j</em>, impose a grid on the plane that consists of lines that are (<em>k</em> + 1)<sup><em>j</em>+1</sup> apart from each other. By construction, every disk can intersect at most one horizontal line and one vertical line from its level.</p>

<p>For every <em>r</em>, <em>s</em> between 0 and <em>k</em>, define <em>D</em>(<em>r</em>,<em>s</em>) as the subset of disks that are not intersected by any horizontal line whose index modulo <em>k</em> is <em>r</em>, nor by any vertical line whose index modulu <em>k</em> is <em>s</em>. By the <a href="pigeonhole_principle" title="wikilink">pigeonhole principle</a>, there is at least one pair <em>(r,s)</em> such that 

<math display="inline" id="Maximum_disjoint_set:35">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>MDS</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>D</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>r</mi>
        <mo>,</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mfrac>
        <mn>1</mn>
        <mi>k</mi>
       </mfrac>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>MDS</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>MDS</ci>
      <apply>
       <times></times>
       <ci>D</ci>
       <interval closure="open">
        <ci>r</ci>
        <ci>s</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>k</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <abs></abs>
      <ci>MDS</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\mathrm{MDS}(D(r,s))|\geq(1-\frac{1}{k})^{2}\cdot|\mathrm{MDS}|
  </annotation>
 </semantics>
</math>

, i.e., we can find the MDS only in <em>D</em>(<em>r</em>,<em>s</em>) and miss only a small fraction of the disks in the optimal solution:</p>
<ul>
<li>For all <em>k</em><sup>2</sup> possible values of <em>r</em>,<em>s</em> (0 ≤ <em>r</em>,<em>s</em> &lt; <em>k</em>), calculate <em>D</em>(<em>r</em>,<em>s</em>) using <a href="dynamic_programming" title="wikilink">dynamic programming</a>.</li>
<li>Return the largest of these <em>k</em><sup>2</sup> sets.</li>
</ul>

<p> <strong>Version 2</strong> finds a disjoint set with a size of at least (1 − 2/<em>k</em>)·|MDS(<em>C</em>)| in time <em>n</em><sup><em>O</em>(<em>k</em>)</sup>, for every constant <em>k</em> &gt; 1.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>The algorithm uses shifted <a href="quadtree" title="wikilink">quadtrees</a>. The key concept of the algorithm is <em>alignment</em> to the quadtree grid. An object of size <em>r</em> is called <em>k-aligned</em> (where <em>k</em> ≥ 1 is a constant) if it is inside a quadtree cell of size at most <em>kr</em> (<em>R</em> ≤ <em>kr</em>).</p>

<p>By definition, a <em>k</em>-aligned object that intersects the boundary of a quatree cell of size <em>R</em> must have a size of at least <em>R</em>/<em>k</em> (<em>r</em> &gt; <em>R</em>/<em>k</em>). The boundary of a cell of size <em>R</em> can be covered by 4<em>k</em> squares of size <em>R</em>/<em>k</em>; hence the number of disjoint fat objects intersecting the boundary of that cell is at most 4<em>kc</em>, where <em>c</em> is a constant measuring the fatness of the objects.</p>

<p>Therefore, if all objects are fat and <em>k</em>-aligned, it is possible to find the exact maximum disjoint set in time <em>n</em><sup><em>O</em>(<em>kc</em>)</sup> using a divide-and-conquer algorithm. Start with a quadtree cell that contains all objects. Then recursively divide it to smaller quadtree cells, find the maximum in each smaller cell, and combine the results to get the maximum in the larger cell. Since the number of disjoint fat objects intersecting the boundary of every quadtree cell is bounded by 4<em>kc</em>, we can simply "guess" which objects intersect the boundary in the optimal solution, and then apply divide-and-conquer to the objects inside.</p>

<p>If <em>almost</em> all objects are <em>k</em>-aligned, we can just discard the objects that are not <em>k</em>-aligned, and find a maximum disjoint set of the remaining objects in time <em>n</em><sup><em>O</em>(<em>k</em>)</sup>. This results in a (1 − <em>e</em>) approximation, where e is the fraction of objects that are not <em>k</em>-aligned.</p>

<p>If most objects are not <em>k</em>-aligned, we can try to make them <em>k</em>-aligned by <em>shifting</em> the grid in multiples of (1/<em>k</em>,1/<em>k</em>). First, scale the objects such that they are all contained in the unit square. Then, consider <em>k</em> shifts of the grid: (0,0), (1/<em>k</em>,1/<em>k</em>), (2/<em>k</em>,2/<em>k</em>), ..., ((<em>k</em> − 1)/<em>k</em>,(<em>k</em> − 1)/<em>k</em>). I.e., for each <em>j</em> in {0,...,<em>k</em> − 1}, consider a shift of the grid in (j/k,j/k). It is possible to prove that every label will be 2<em>k</em>-aligned for at least <em>k</em> − 2 values of <em>j</em>. Now, for every <em>j</em>, discard the objects that are not <em>k</em>-aligned in the (<em>j</em>/<em>k</em>,<em>j</em>/<em>k</em>) shift, and find a maximum disjoint set of the remaining objects. Call that set <em>A</em>(<em>j</em>). Call the real maximum disjoint set is <em>A</em>*. Then:</p>

<p>

<math display="inline" id="Maximum_disjoint_set:36">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>j</mi>
     <mo>=</mo>
     <mrow>
      <mn>0</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mrow>
    </mrow>
   </msub>
   <mo stretchy="false">|</mo>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mo>≥</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo>-</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mi>A</mi>
   <mo>*</mo>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <eq></eq>
      <ci>j</ci>
      <list>
       <cn type="integer">0</cn>
       <ci>normal-…</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </list>
     </apply>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">A</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-|</ci>
    <geq></geq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">k</csymbol>
     <minus></minus>
     <cn type="integer">2</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-|</ci>
    <csymbol cd="unknown">A</csymbol>
    <times></times>
    <ci>normal-|</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{j=0,\ldots,k-1}{|A(j)|}\geq(k-2)|A*|
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore, the largest <em>A</em>(<em>j</em>) has a size of at least: (1 − 2/<em>k</em>)|<em>A</em>*|. The return value of the algorithm is the largest <em>A</em>(<em>j</em>); the approximation factor is (1 − 2/<em>k</em>), and the run time is <em>n</em><sup><em>O</em>(<em>k</em>)</sup>. We can make the approximation factor as small as we want, so this is a <a href="polynomial-time_approximation_scheme" title="wikilink">PTAS</a>.</p>

<p>Both versions can be generalized to <em>d</em> dimensions (with different approximation ratios) and to the weighted case.</p>
<h2 id="geometric-separator-algorithms">Geometric separator algorithms</h2>

<p>Several divide-and-conquer algorithms are based on a certain <a href="geometric_separator" title="wikilink">geometric separator</a> theorem. A geometric separator is a line or shape that separates a given set of shapes to two smaller subsets, such that the number of shapes lost during the division is relatively small. This allows both <a href="polynomial-time_approximation_scheme" title="wikilink">PTASs</a> and sub-exponential exact algorithms, as explained below.</p>
<h3 id="fat-objects-with-arbitrary-sizes-ptas-using-geometric-separators">Fat objects with arbitrary sizes: PTAS using geometric separators</h3>

<p>Let <em>C</em> be a set of <em>n</em> <a href="fat_object" title="wikilink">fat objects</a> of arbitrary sizes. The following algorithm finds a disjoint set with a size of at least (1 − <em>O</em>(√<em>b</em>))·|MDS(<em>C</em>)| in time <em>n</em><sup><em>O</em>(<em>b</em>)</sup>, for every constant <em>b</em> &gt; 1.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>The algorithm is based on the following geometric separator theorem, which can be proved similarly to <a href="Geometric_separator#Proof" title="wikilink">the proof of the existence of geometric separator for disjoint squares</a>:</p>
<dl>
<dd><dl>
<dd>For every set <em>C</em> of fat objects, there is a rectangle that partitions <em>C</em> into three subsets of objects – <em>C<sub>inside</sub></em>, <em>C<sub>outside</sub></em> and <em>C</em><sub>boundary</sub>, such that:
<ul>
<li>|MDS(<em>C</em><sub>inside</sub>)| ≤ <em>a</em>|MDS(<em>C</em>)|</li>
<li>|MDS(<em>C</em><sub>outside</sub>)| ≤ a|MDS(<em>C</em>)|</li>
<li>|MDS(<em>C</em><sub>boundary</sub>)| <em>c</em>√(|MDS(<em>C</em>)|)</li>
</ul>
</dd>
</dl>
</dd>
</dl>

<p>where <em>a</em> and <em>c</em> are constants. If we could calculate MDS(<em>C</em>) exactly, we could make the constant <em>a</em> as low as 2/3 by a proper selection of the separator rectangle. But since we can only approximate MDS(<em>C</em>) by a constant factor, the constant <em>a</em> must be larger. Fortunately, <em>a</em> remains a constant independent of |<em>C</em>|.</p>

<p>This separator theorem allows to build the following PTAS:</p>

<p>Select a constant <em>b</em>. Check all possible combinations of up to <em>b</em> + 1 labels.</p>
<ul>
<li>If |MDS(<em>C</em>)| has a size of at most <em>b</em> (i.e. all sets of <em>b</em> + 1 labels are not disjoint) then just return that MDS and exit. This step takes <em>n</em><sup><em>O</em>(<em>b</em>)</sup> time.</li>
<li>Otherwise, use a geometric separator to separate <em>C</em> to two subsets. Find the approximate MDS in <em>C</em><sub>inside</sub> and <em>C</em><sub>outside</sub> separately, and return their combination as the approximate MDS in <em>C</em>.</li>
</ul>

<p>Let <em>E</em>(<em>m</em>) be the error of the above algorithm when the optimal MDS size is MDS(<em>C</em>) = <em>m</em>. When <em>m</em> ≤ <em>b</em>, the error is 0 because the maximum disjoint set is calculated exactly; when <em>m</em> &gt; <em>b</em>, the error increases by at most <em>c</em>√<em>m</em> – the number of labels intersected by the separator. The worst case for the algorithm is when the split in each step is in the maximum possible ratio which is <em>a</em>:(1 − <em>a</em>). Therefore the error function satisfies the following recurrence relation:</p>

<p>

<math display="block" id="Maximum_disjoint_set:37">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>m</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mrow>
    <mrow>
     <mtext>if</mtext>
     <mi>m</mi>
    </mrow>
    <mo>≤</mo>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>m</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <mtext>if</mtext>
      <ci>m</ci>
     </apply>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(m)=0\ \ \ \ \text{ if }m\leq b
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Maximum_disjoint_set:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <mo>⋅</mo>
       <mi>m</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mi>a</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>⋅</mo>
       <mi>m</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mi>c</mi>
      <mo>⋅</mo>
      <msqrt>
       <mi>m</mi>
      </msqrt>
     </mrow>
     <mtext>if</mtext>
     <mi>m</mi>
    </mrow>
   </mrow>
   <mo>></mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <ci>normal-⋅</ci>
        <ci>a</ci>
        <ci>m</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <ci>a</ci>
        </apply>
        <ci>m</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <ci>c</ci>
        <apply>
         <root></root>
         <ci>m</ci>
        </apply>
       </apply>
       <mtext>if</mtext>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <share href="#.cmml">
     </share>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(m)=E(a\cdot m)+E((1-a)\cdot m)+c\cdot\sqrt{m}\text{ if }m>b
  </annotation>
 </semantics>
</math>

</p>

<p>The solution to this recurrence is:</p>

<p>

<math display="block" id="Maximum_disjoint_set:39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>m</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mfrac>
         <mn>0</mn>
         <mi>b</mi>
        </mfrac>
        <mo>+</mo>
        <mfrac>
         <mi>c</mi>
         <mrow>
          <msqrt>
           <mi>b</mi>
          </msqrt>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mrow>
             <msqrt>
              <mi>a</mi>
             </msqrt>
             <mo>+</mo>
             <msqrt>
              <mrow>
               <mn>1</mn>
               <mo>-</mo>
               <mi>a</mi>
              </mrow>
             </msqrt>
            </mrow>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mfrac>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>⋅</mo>
      <mi>m</mi>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <mi>c</mi>
       <mrow>
        <mrow>
         <msqrt>
          <mi>a</mi>
         </msqrt>
         <mo>+</mo>
         <msqrt>
          <mrow>
           <mn>1</mn>
           <mo>-</mo>
           <mi>a</mi>
          </mrow>
         </msqrt>
        </mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mfrac>
      <mo>⋅</mo>
      <msqrt>
       <mi>m</mi>
      </msqrt>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <plus></plus>
       <apply>
        <divide></divide>
        <cn type="integer">0</cn>
        <ci>b</ci>
       </apply>
       <apply>
        <divide></divide>
        <ci>c</ci>
        <apply>
         <times></times>
         <apply>
          <root></root>
          <ci>b</ci>
         </apply>
         <apply>
          <minus></minus>
          <apply>
           <plus></plus>
           <apply>
            <root></root>
            <ci>a</ci>
           </apply>
           <apply>
            <root></root>
            <apply>
             <minus></minus>
             <cn type="integer">1</cn>
             <ci>a</ci>
            </apply>
           </apply>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <divide></divide>
       <ci>c</ci>
       <apply>
        <minus></minus>
        <apply>
         <plus></plus>
         <apply>
          <root></root>
          <ci>a</ci>
         </apply>
         <apply>
          <root></root>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
           <ci>a</ci>
          </apply>
         </apply>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <root></root>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(m)=(\frac{0}{b}+\frac{c}{\sqrt{b}(\sqrt{a}+\sqrt{1-a}-1)})\cdot m-\frac{c}{%
\sqrt{a}+\sqrt{1-a}-1}\cdot\sqrt{m}.
  </annotation>
 </semantics>
</math>

</p>

<p>i.e., 

<math display="inline" id="Maximum_disjoint_set:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>m</mi>
      <mo>/</mo>
      <msqrt>
       <mi>b</mi>
      </msqrt>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <divide></divide>
      <ci>m</ci>
      <apply>
       <root></root>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(m)=O(m/\sqrt{b})
  </annotation>
 </semantics>
</math>

. We can make the approximation factor as small as we want by a proper selection of <em>b</em>.</p>

<p>This PTAS is more space-efficient than the PTAS based on quadtrees, and can handle a generalization where the objects may slide, but it cannot handle the weighted case.</p>
<h3 id="disks-with-a-bounded-size-ratio-exact-sub-exponential-algorithm">Disks with a bounded size-ratio: exact sub-exponential algorithm</h3>

<p>Let <em>C</em> be a set of <em>n</em> disks, such that the ratio between the largest radius and the smallest radius is at most <em>r</em>. The following algorithm finds MDS(<em>C</em>) exactly in time 

<math display="inline" id="Maximum_disjoint_set:41">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>r</mi>
      <mo>⋅</mo>
      <msqrt>
       <mi>n</mi>
      </msqrt>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <ci>normal-⋅</ci>
      <ci>r</ci>
      <apply>
       <root></root>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{O(r\cdot\sqrt{n})}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>The algorithm is based on a <a href="geometric_separator#Separators_that_are_width-bounded_strips_between_parallel_hyperplanes" title="wikilink">width-bounded geometric separator</a> on the set <em>Q</em> of the centers of all disks in <em>C</em>. This separator theorem allows to build the following exact algorithm:</p>
<ul>
<li>Find a separator line such that at most 2<em>n</em>/3 centers are to its right (<em>C</em><sub>right</sub>), at most 2<em>n</em>/3 centers are to its left (<em>C</em><sub>left</sub>), and at most <em>O</em>(√<em>n</em>) centers are at a distance of less than <em>r</em>/2 from the line (<em>C</em><sub>int</sub>).</li>
<li>Consider all possible non-overlapping subsets of <em>C</em><sub>int</sub>. There are at most 

<math display="inline" id="Maximum_disjoint_set:42">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>r</mi>
      <mo>⋅</mo>
      <msqrt>
       <mi>n</mi>
      </msqrt>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <ci>normal-⋅</ci>
      <ci>r</ci>
      <apply>
       <root></root>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{O(r\cdot\sqrt{n})}
  </annotation>
 </semantics>
</math>

 such subsets. For each such subset, recursively compute the MDS of <em>C</em><sub>left</sub> and the MDS of <em>C</em><sub>right</sub>, and return the largest combined set.</li>
</ul>

<p>The run time of this algorithm satisfies the following recurrence relation:</p>

<p>

<math display="block" id="Maximum_disjoint_set:43">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(1)=1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Maximum_disjoint_set:44">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>r</mi>
        <mo>⋅</mo>
        <msqrt>
         <mi>n</mi>
        </msqrt>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
    <mi>T</mi>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mrow>
       <mn>2</mn>
       <mi>n</mi>
      </mrow>
      <mn>3</mn>
     </mfrac>
     <mo>)</mo>
    </mrow>
    <mtext>if</mtext>
    <mi>n</mi>
   </mrow>
   <mo>></mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <times></times>
        <ci>O</ci>
        <apply>
         <ci>normal-⋅</ci>
         <ci>r</ci>
         <apply>
          <root></root>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>T</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>n</ci>
       </apply>
       <cn type="integer">3</cn>
      </apply>
      <mtext>if</mtext>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(n)=2^{O(r\cdot\sqrt{n})}T\left(\frac{2n}{3}\right)\text{ if }n>1
  </annotation>
 </semantics>
</math>

</p>

<p>The solution to this recurrence is:</p>

<p>

<math display="block" id="Maximum_disjoint_set:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>r</mi>
       <mo>⋅</mo>
       <msqrt>
        <mi>n</mi>
       </msqrt>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <ci>normal-⋅</ci>
       <ci>r</ci>
       <apply>
        <root></root>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(n)=2^{O(r\cdot\sqrt{n})}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="local-search-algorithms">Local search algorithms</h2>
<h3 id="pseudo-disks-a-ptas">Pseudo-disks: a PTAS</h3>

<p>A <em>pseudo-disks-set</em> is a set of objects in which the boundaries of every pair of objects intersect at most twice. (Note that this definition relates to a whole collection, and does not say anything about the shapes of the specific objects in the collection). A pseudo-disks-set has a bounded <a href="union_complexity" title="wikilink">union complexity</a>, i.e., the number of intersection points on the boundary of the union of all objects is linear in the number of objects.</p>

<p>Let <em>C</em> be a pseudo-disks-set with <em>n</em> objects. The following <a href="local_search_algorithm" title="wikilink">local search algorithm</a> finds a disjoint set of size at least 

<math display="inline" id="Maximum_disjoint_set:46">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mfrac>
        <mn>1</mn>
        <msqrt>
         <mi>b</mi>
        </msqrt>
       </mfrac>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⋅</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>M</mi>
     <mi>D</mi>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>C</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <root></root>
        <ci>b</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>D</ci>
      <ci>S</ci>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1-O(\frac{1}{\sqrt{b}}))\cdot|MDS(C)|
  </annotation>
 </semantics>
</math>

 in time 

<math display="inline" id="Maximum_disjoint_set:47">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mrow>
      <mi>b</mi>
      <mo>+</mo>
      <mn>3</mn>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <plus></plus>
      <ci>b</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{b+3})
  </annotation>
 </semantics>
</math>

, for every integer constant 

<math display="inline" id="Maximum_disjoint_set:48">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>b</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\geq 0
  </annotation>
 </semantics>
</math>

:<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<ul>
<li>INITIALIZATION: Initialize an empty set, 

<math display="inline" id="Maximum_disjoint_set:49">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

.</li>
<li>SEARCH: Loop over all the subsets of 

<math display="inline" id="Maximum_disjoint_set:50">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>-</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>C</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C-S
  </annotation>
 </semantics>
</math>

 whose size is between 1 and 

<math display="inline" id="Maximum_disjoint_set:51">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>b</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b+1
  </annotation>
 </semantics>
</math>

. For each such subset <em>X</em>:
<ul>
<li>Verify that <em>X</em> itself is independent (otherwise go to the next subset);</li>
<li>Calculate the set <em>Y</em> of objects in <em>S</em> that intersect <em>X</em>.</li>
<li>If 

<math display="inline" id="Maximum_disjoint_set:52">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>Y</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo><</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>X</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <ci>Y</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |Y|<|X|
  </annotation>
 </semantics>
</math>

, then remove <em>Y</em> from <em>S</em> and insert <em>X</em>

<math display="block" id="Maximum_disjoint_set:53">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>:=</mo>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mo>-</mo>
     <mi>Y</mi>
    </mrow>
    <mo>+</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>S</ci>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <ci>S</ci>
      <ci>Y</ci>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S:=S-Y+X
  </annotation>
 </semantics>
</math>

.</li>
</ul></li>
<li>END: return the set <em>S</em>.</li>
</ul>

<p>Every exchange in the search step increases the size of <em>S</em> by at least 1, and thus can happen at most <em>n</em> times.</p>

<p>The algorithm is very simple; the difficult part is to prove the approximation ratio.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>

<p>See also.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<h2 id="linear-programming-relaxation-algorithms">Linear programming relaxation algorithms</h2>
<h3 id="pseudo-disks-a-ptas-1">Pseudo-disks: a PTAS</h3>

<p>Let <em>C</em> be a pseudo-disks-set with <em>n</em> objects and union complexity <em>u</em>. Using <a href="linear_programming_relaxation" title="wikilink">linear programming relaxation</a>, it is possible to find a disjoint set of size at least 

<math display="inline" id="Maximum_disjoint_set:54">
 <semantics>
  <mrow>
   <mfrac>
    <mi>n</mi>
    <mi>u</mi>
   </mfrac>
   <mo>⋅</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>M</mi>
     <mi>D</mi>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>C</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <ci>u</ci>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>D</ci>
      <ci>S</ci>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{n}{u}\cdot|MDS(C)|
  </annotation>
 </semantics>
</math>

. This is possible either with a randomized algorithm that has a high probability of success and run time 

<math display="inline" id="Maximum_disjoint_set:55">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3})
  </annotation>
 </semantics>
</math>

, or a deterministic algorithm with a slower run time (but still polynomial). This algorithm can be generalized to the weighted case.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h2 id="other-classes-of-shapes-for-which-approximations-are-known">Other classes of shapes for which approximations are known</h2>
<ul>
<li>Line segments and curves with a bounded number of intersection points.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://sarielhp.org/p/08/w_indep/talk/w_indep_talk.pdf">Approximation Algorithms for Maximum Independent Set of Pseudo-Disks</a> - presentation by Sariel Har-Peled.</li>
<li><a href="https://github.com/erelsgl/rectangles">Javascript code for calculating exact maximum disjoint set of rectangles</a>.</li>
</ul>
<h2 id="notes">Notes</h2>

<p>"</p>

<p><a href="Category:Computational_geometry" title="wikilink">Category:Computational geometry</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">, <a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
</ol>
</section>
</body>
</html>
