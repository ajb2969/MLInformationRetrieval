<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1280">Recurrent neural network</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Recurrent neural network</h1>
<hr/>

<p>A <strong>recurrent neural network</strong> (<strong>RNN</strong>) is a class of <a href="artificial_neural_network" title="wikilink">artificial neural network</a> where connections between units form a <a href="directed_cycle" title="wikilink">directed cycle</a>. This creates an internal state of the network which allows it to exhibit dynamic temporal behavior. Unlike <a href="feedforward_neural_networks" title="wikilink">feedforward neural networks</a>, RNNs can use their internal memory to process arbitrary sequences of inputs. This makes them applicable to tasks such as unsegmented connected <a href="handwriting_recognition" title="wikilink">handwriting recognition</a>, where they have achieved the best known results.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="architectures">Architectures</h2>
<h3 id="fully-recurrent-network">Fully recurrent network</h3>

<p>This is the basic architecture developed in the 1980s: a network of neuron-like units, each with a directed connection to every other unit. Each unit has a time-varying real-valued activation. Each connection has a modifiable real-valued weight. Some of the nodes are called input nodes, some output nodes, the rest hidden nodes. Most architectures below are special cases.</p>

<p>For <a href="supervised_learning" title="wikilink">supervised learning</a> in discrete time settings, training sequences of real-valued input vectors become sequences of activations of the input nodes, one input vector at a time. At any given time step, each non-input unit computes its current activation as a nonlinear function of the weighted sum of the activations of all units from which it receives connections. There may be teacher-given target activations for some of the output units at certain time steps. For example, if the input sequence is a speech signal corresponding to a spoken digit, the final target output at the end of the sequence may be a label classifying the digit. For each sequence, its error is the sum of the deviations of all target signals from the corresponding activations computed by the network. For a training set of numerous sequences, the total error is the sum of the errors of all individual sequences. Algorithms for minimizing this error are mentioned in the section on training algorithms below.</p>

<p>In <a href="reinforcement_learning" title="wikilink">reinforcement learning</a> settings, there is no teacher providing target signals for the RNN, instead a <a href="fitness_function" title="wikilink">fitness function</a> or <a href="reward_function" title="wikilink">reward function</a> is occasionally used to evaluate the RNN's performance, which is influencing its input stream through output units connected to actuators affecting the environment. Again, compare the section on training algorithms below.</p>
<h3 id="hopfield-network">Hopfield network</h3>

<p>The <a href="Hopfield_network" title="wikilink">Hopfield network</a> is of historic interest although it is not a general RNN, as it is not designed to process sequences of patterns. Instead it requires stationary inputs. It is a RNN in which all connections are symmetric. Invented by <a href="John_Hopfield" title="wikilink">John Hopfield</a> in 1982, it guarantees that its dynamics will converge. If the connections are trained using <a href="Hebbian_learning" title="wikilink">Hebbian learning</a> then the Hopfield network can perform as robust <a href="content-addressable_memory" title="wikilink">content-addressable memory</a>, resistant to connection alteration.</p>

<p>A variation on the Hopfield network is the <a href="bidirectional_associative_memory" title="wikilink">bidirectional associative memory</a> (BAM). The BAM has two layers, either of which can be driven as an input, to recall an association and produce an output on the other layer.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h3 id="elman-networks-and-jordan-networks">Elman networks and Jordan networks</h3>
<figure><b>(Figure)</b>
<figcaption>Right|The Elman SRN</figcaption>
</figure>

<p>The following special case of the basic architecture above was employed by <a href="Jeff_Elman" title="wikilink">Jeff Elman</a>. A three-layer network is used (arranged vertically as <em>x</em>, <em>y</em>, and <em>z</em> in the illustration), with the addition of a set of "context units" (<em>u</em> in the illustration). There are connections from the middle (hidden) layer to these context units fixed with a weight of one.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> At each time step, the input is propagated in a standard feed-forward fashion, and then a learning rule is applied. The fixed back connections result in the context units always maintaining a copy of the previous values of the hidden units (since they propagate over the connections before the learning rule is applied). Thus the network can maintain a sort of state, allowing it to perform such tasks as sequence-prediction that are beyond the power of a standard multilayer perceptron.</p>

<p>Jordan networks, due to <a href="Michael_I._Jordan" title="wikilink">Michael I. Jordan</a>, are similar to Elman networks. The context units are however fed from the output layer instead of the hidden layer. The context units in a Jordan network are also referred to as the state layer, and have a recurrent connection to themselves with no other nodes on this connection.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Elman and Jordan networks are also known as "simple recurrent networks" (SRN).</p>
<h3 id="echo-state-network">Echo state network</h3>

<p>The <a href="echo_state_network" title="wikilink">echo state network</a> (ESN) is a recurrent neural network with a sparsely connected random hidden layer. The weights of output neurons are the only part of the network that can change and be trained. ESN are good at reproducing certain time series.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> A variant for <a href="Action_potential" title="wikilink">spiking neurons</a> is known as <a href="Liquid_state_machines" title="wikilink">Liquid state machines</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h3 id="long-short-term-memory-network">Long short term memory network</h3>

<p>The <a href="Long_short_term_memory" title="wikilink">Long short term memory</a> (LSTM) network, developed by <a href="Sepp_Hochreiter" title="wikilink">Hochreiter</a> &amp; <a href="Jürgen_Schmidhuber" title="wikilink">Schmidhuber</a> in 1997,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> is an artificial neural net structure that unlike traditional RNNs doesn't have the <a href="vanishing_gradient_problem" title="wikilink">vanishing gradient problem</a> (compare the section on training algorithms below). It works even when there are long delays, and it can handle signals that have a mix of low and high frequency components. LSTM RNN outperformed other methods in numerous applications such as language learning<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> and connected handwriting recognition.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h3 id="bi-directional-rnn">Bi-directional RNN</h3>

<p>Invented by Schuster &amp; Paliwal in 1997,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> bi-directional RNN or BRNN use a finite sequence to predict or label each element of the sequence based on both the past and the future context of the element. This is done by adding the outputs of two RNN, one processing the sequence from left to right, the other one from right to left. The combined outputs are the predictions of the teacher-given target signals. This technique proved to be especially useful when combined with LSTM RNN.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h3 id="continuous-time-rnn">Continuous-time RNN</h3>

<p>A continuous time recurrent neural network (CTRNN) is a <a href="Cognitive_model#Dynamical_systems" title="wikilink">dynamical systems</a> model of biological neural networks. A CTRNN uses a system of <a href="ordinary_differential_equations" title="wikilink">ordinary differential equations</a> to model the effects on a neuron of the incoming spike train. CTRNNs are more computationally efficient than directly simulating every spike in a network as they do not model neural activations at this level of detail .</p>

<p>For a neuron 

<math display="inline" id="Recurrent_neural_network:0">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 in the network with action potential 

<math display="inline" id="Recurrent_neural_network:1">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}
  </annotation>
 </semantics>
</math>


 the rate of change of activation is given by:</p>

<p>

<math display="block" id="Recurrent_neural_network:2">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>τ</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mover accent="true">
      <mi>y</mi>
      <mo>˙</mo>
     </mover>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>σ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>j</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>n</mi>
        </munderover>
        <mrow>
         <msub>
          <mi>w</mi>
          <mrow>
           <mi>j</mi>
           <mi>i</mi>
          </mrow>
         </msub>
         <msub>
          <mi>y</mi>
          <mi>j</mi>
         </msub>
        </mrow>
       </mrow>
       <mo>-</mo>
       <msub>
        <mi mathvariant="normal">Θ</mi>
        <mi>j</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>I</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-˙</ci>
       <ci>y</ci>
      </apply>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>σ</ci>
      <apply>
       <minus></minus>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>j</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>w</ci>
          <apply>
           <times></times>
           <ci>j</ci>
           <ci>i</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Θ</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>i</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{i}\dot{y}_{i}=-y_{i}+\sigma(\sum_{j=1}^{n}w_{ji}y_{j}-\Theta_{j})+I_{i}(t)
  </annotation>
 </semantics>
</math>

 Where:</p>
<ul>
<li>

<math display="inline" id="Recurrent_neural_network:3">
 <semantics>
  <msub>
   <mi>τ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>τ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{i}
  </annotation>
 </semantics>
</math>

 : Time constant of postsynaptic node</li>
<li>

<math display="inline" id="Recurrent_neural_network:4">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}
  </annotation>
 </semantics>
</math>

 : Activation of postsynaptic node</li>
<li>

<math display="inline" id="Recurrent_neural_network:5">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>y</mi>
    <mo>˙</mo>
   </mover>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-˙</ci>
     <ci>y</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{y}_{i}
  </annotation>
 </semantics>
</math>

 : Rate of change of activation of postsynaptic node</li>
<li>

<math display="inline" id="Recurrent_neural_network:6">
 <semantics>
  <mrow>
   <mi>w</mi>
   <msub>
    <mi></mi>
    <mrow>
     <mi>j</mi>
     <mi>i</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">w</csymbol>
    <apply>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w{}_{ji}
  </annotation>
 </semantics>
</math>


 : Weight of connection from pre to postsynaptic node</li>
<li>

<math display="inline" id="Recurrent_neural_network:7">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>σ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(x)
  </annotation>
 </semantics>
</math>

 : Sigmoid of x e.g. 

<math display="inline" id="Recurrent_neural_network:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <msup>
       <mi>e</mi>
       <mrow>
        <mo>-</mo>
        <mi>x</mi>
       </mrow>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(x)=1/(1+e^{-x})
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Recurrent_neural_network:9">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{j}
  </annotation>
 </semantics>
</math>

 : Activation of presynaptic node</li>
<li>

<math display="inline" id="Recurrent_neural_network:10">
 <semantics>
  <msub>
   <mi mathvariant="normal">Θ</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Θ</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta_{j}
  </annotation>
 </semantics>
</math>

 : Bias of presynaptic node</li>
<li>

<math display="inline" id="Recurrent_neural_network:11">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>i</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{i}(t)
  </annotation>
 </semantics>
</math>


 : Input (if any) to node</li>
</ul>

<p>CTRNNs have frequently been applied in the field of <a href="evolutionary_robotics" title="wikilink">evolutionary robotics</a>, where they have been used to address, for example, vision,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> co-operation<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> and minimally cognitive behaviour.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h3 id="hierarchical-rnn">Hierarchical RNN</h3>

<p>There are many instances of hierarchical RNN whose elements are connected in various ways to decompose hierarchical behavior into useful subprograms.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h3 id="recurrent-multilayer-perceptron">Recurrent multilayer perceptron</h3>

<p>Generally, a Recurrent Multi-Layer Perceptron (RMLP) consists of a series of cascaded subnetworks, each of which consists of multiple layers of nodes. Each of these subnetworks is entirely feed-forward except for the last layer, which can have feedback connections among itself. Each of these subnets is connected only by feed forward connections.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h3 id="second-order-recurrent-neural-network">Second Order Recurrent Neural Network</h3>

<p>Second order RNNs use higher order weights 

<math display="inline" id="Recurrent_neural_network:12">
 <semantics>
  <mrow>
   <mi>w</mi>
   <msub>
    <mi></mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
     <mi>k</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">w</csymbol>
    <apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w{}_{ijk}
  </annotation>
 </semantics>
</math>

 instead of the standard 

<math display="inline" id="Recurrent_neural_network:13">
 <semantics>
  <mrow>
   <mi>w</mi>
   <msub>
    <mi></mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">w</csymbol>
    <apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w{}_{ij}
  </annotation>
 </semantics>
</math>

 weights, and inputs and states can be a product. This allows a direct mapping to a <a href="finite_state_machine" title="wikilink">finite state machine</a> both in training and in representation<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> <a href="Long_short_term_memory" title="wikilink">Long short term memory</a> is an example of this.</p>
<h3 id="multiple-timescales-recurrent-neural-network-mtrnn-model">Multiple Timescales Recurrent Neural Network (MTRNN) Model</h3>

<p>MTRNN is a possible neural-based computational model that imitates to some extent, the activity of the brain.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> It has the ability to simulate the functional hierarchy of the brain through self-organization that not only depends on spatial connection between neurons, but also on distinct types of neuron activities, each with distinct time properties. With such varied neuronal activities, continuous sequences of any set of behaviors are segmented into reusable primitives, which in turn are flexibly integrated into diverse sequential behaviors. The biological approval of such a type of hierarchy has been discussed on the <a href="memory-prediction_framework" title="wikilink">memory-prediction</a> theory of brain function by <a href="Jeff_Hawkins" title="wikilink">Jeff Hawkins</a> in his book <em><a href="On_Intelligence" title="wikilink">On Intelligence</a></em>.</p>
<h3 id="pollacks-sequential-cascaded-networks">Pollack’s sequential cascaded networks</h3>
<h3 id="neural-turing-machines">Neural Turing Machines</h3>

<p>NTMs are a method of extending the capabilities of recurrent <a href="neural_networks" title="wikilink">neural networks</a> by coupling them to external <a class="uri" href="memory" title="wikilink">memory</a> resources, which they can interact with by <a href="attentional_processes" title="wikilink">attentional processes</a>. The combined system is analogous to a <a href="Turing_Machine" title="wikilink">Turing Machine</a> or <a href="Von_Neumann_architecture" title="wikilink">Von Neumann architecture</a> but is <a class="uri" href="differentiable" title="wikilink">differentiable</a> end-to-end, allowing it to be efficiently trained with <a href="gradient_descent" title="wikilink">gradient descent</a>.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>
<h3 id="bidirectional-associative-memory-bam">Bidirectional Associative Memory (BAM)</h3>

<p>First introduced by Kosko,<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> BAM neural networks store associative data as a vector. The bi-directionality comes from passing information through a matrix and its transpose. Typically, bipolar encoding is preferred to binary encoding of the associative pairs. Recently, stochastic BAM models using <a href="Markov_chain" title="wikilink">Markov</a> stepping were optimized for increased network stability and relevance to real-world applications.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>
<h2 id="training">Training</h2>
<h3 id="gradient-descent">Gradient descent</h3>

<p>To minimize total error, <a href="gradient_descent" title="wikilink">gradient descent</a> can be used to change each weight in proportion to the derivative of the error with respect to that weight, provided the non-linear <a href="activation_function" title="wikilink">activation functions</a> are <a class="uri" href="differentiable" title="wikilink">differentiable</a>. Various methods for doing so were developed in the 1980s and early 1990s by <a href="Paul_Werbos" title="wikilink">Paul Werbos</a>, <a href="Ronald_J._Williams" title="wikilink">Ronald J. Williams</a>, Tony Robinson, <a href="Jürgen_Schmidhuber" title="wikilink">Jürgen Schmidhuber</a>, <a href="Sepp_Hochreiter" title="wikilink">Sepp Hochreiter</a>, <a href="Barak_Pearlmutter" title="wikilink">Barak Pearlmutter</a>, and others.</p>

<p>The standard method is called "<a href="backpropagation_through_time" title="wikilink">backpropagation through time</a>" or BPTT, and is a generalization of back-propagation for feed-forward networks,<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a><a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> and like that method, is an instance of <a href="Automatic_differentiation" title="wikilink">Automatic differentiation</a> in the reverse accumulation mode or <a href="Pontryagin's_minimum_principle" title="wikilink">Pontryagin's minimum principle</a>. A more computationally expensive online variant is called "<a href="Real-Time_Recurrent_Learning" title="wikilink">Real-Time Recurrent Learning</a>" or RTRL,<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a><a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> which is an instance of <a href="Automatic_differentiation" title="wikilink">Automatic differentiation</a> in the forward accumulation mode with stacked tangent vectors. Unlike BPTT this algorithm is <em>local in time but not local in space</em>.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a><a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>

<p>There also is an online hybrid between BPTT and RTRL with intermediate complexity,<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a><a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> and there are variants for continuous time.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> A major problem with gradient descent for standard RNN architectures is that error gradients vanish exponentially quickly with the size of the time lag between important events.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> <a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> The <a href="Long_short_term_memory" title="wikilink">Long short term memory</a> architecture together with a BPTT/RTRL hybrid learning method was introduced in an attempt to overcome these problems.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p>
<h3 id="hessian-free-optimisation">Hessian Free Optimisation</h3>

<p>Successful training on complex tasks has been achieved by employing Hessian Free Optimisation. The speedup compared with previous training methods now makes RNN applications feasible.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></p>
<h3 id="global-optimization-methods">Global optimization methods</h3>

<p>Training the weights in a neural network can be modeled as a non-linear <a href="global_optimization" title="wikilink">global optimization</a> problem. A target function can be formed to evaluate the fitness or error of a particular weight vector as follows: First, the weights in the network are set according to the weight vector. Next, the network is evaluated against the training sequence. Typically, the sum-squared-difference between the predictions and the target values specified in the training sequence is used to represent the error of the current weight vector. Arbitrary global optimization techniques may then be used to minimize this target function.</p>

<p>The most common <a href="global_optimization" title="wikilink">global optimization</a> method for training RNNs is <a href="genetic_algorithm" title="wikilink">genetic algorithms</a>, especially in unstructured networks.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a><a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a><a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a></p>

<p>Initially, the genetic algorithm is encoded with the neural network weights in a predefined manner where one gene in the chromosome represents one weight link, henceforth; the whole network is represented as a single chromosome. The fitness function is evaluated as follows: 1) each weight encoded in the chromosome is assigned to the respective weight link of the network ; 2) the training set of examples is then presented to the network which propagates the input signals forward ; 3) the mean-squared-error is returned to the fitness function ; 4) this function will then drive the genetic selection process.</p>

<p>There are many chromosomes that make up the population; therefore, many different neural networks are evolved until a stopping criterion is satisfied. A common stopping scheme is: 1) when the neural network has learnt a certain percentage of the training data or 2) when the minimum value of the mean-squared-error is satisfied or 3) when the maximum number of training generations has been reached. The stopping criterion is evaluated by the fitness function as it gets the reciprocal of the mean-squared-error from each neural network during training. Therefore, the goal of the genetic algorithm is to maximize the fitness function, hence, reduce the mean-squared-error.</p>

<p>Other global (and/or evolutionary) optimization techniques may be used to seek a good set of weights such as <a href="Simulated_annealing" title="wikilink">Simulated annealing</a> or <a href="Particle_swarm_optimization" title="wikilink">Particle swarm optimization</a>.</p>
<h2 id="related-fields-and-models">Related fields and models</h2>

<p>RNNs may behave <a href="chaos_theory" title="wikilink">chaotically</a>. In such cases, <a href="dynamical_systems_theory" title="wikilink">dynamical systems theory</a> may be used for analysis.</p>

<p>Recurrent neural networks are in fact <a href="recursive_neural_network" title="wikilink">recursive neural networks</a> with a particular structure: that of a linear chain. Whereas recursive neural networks operate on any hierarchical structure, combining child representations into parent representations, recurrent neural networks operate on the linear progression of time, combining the previous time step and a hidden representation into the representation for the current time step.</p>

<p>In particular, recurrent neural networks can appear as nonlinear versions of <a href="finite_impulse_response" title="wikilink">finite impulse response</a> and <a href="infinite_impulse_response" title="wikilink">infinite impulse response</a> filters and also as a <a href="nonlinear_autoregressive_exogenous_model" title="wikilink">nonlinear autoregressive exogenous model</a> (NARX)<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a></p>
<h2 id="issues-with-recurrent-neural-networks">Issues with recurrent neural networks</h2>

<p>Most RNNs used to have scaling issues. In particular, RNNs could not be easily trained for large numbers of neuron units nor for large numbers of inputs units. Recent advances in training techniques have greatly increased the capabilities of recurrent neural networks . Successful training has been mostly in time series problems with few inputs and in chemical process control.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://rnnsharp.codeplex.com/">RNNSharp</a> CRFs based on recurrent neural networks (<a href="C_Sharp_(programming_language)" title="wikilink">C#</a>, <a href=".NET_Framework" title="wikilink">.NET</a>)</li>
<li><a href="http://www.idsia.ch/~juergen/rnn.html">Recurrent Neural Networks</a> with over 60 RNN papers by <a href="Jürgen_Schmidhuber" title="wikilink">Jürgen Schmidhuber</a>'s group at <a class="uri" href="IDSIA" title="wikilink">IDSIA</a></li>
<li><a href="http://jsalatas.ictpro.gr/weka">Elman Neural Network implementation for WEKA</a></li>
<li><a href="http://deeplearning4j.org/recurrentnetwork">Recurrent Neural Nets &amp; LSTMs in Java</a></li>
<li><a href="http://jiwonkim.org/awesome-rnn">AwesomeRNN - A list of RNN resources</a></li>
</ul>

<p><a href="ru:Рекуррентная_нейронная_сеть" title="wikilink">ru:Рекуррентная нейронная сеть</a>"</p>

<p><a href="Category:Artificial_intelligence" title="wikilink">Category:Artificial intelligence</a> <a href="Category:Artificial_neural_networks" title="wikilink">Category:Artificial neural networks</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">A. Graves, M. Liwicki, S. Fernandez, R. Bertolami, H. Bunke, J. Schmidhuber. A Novel Connectionist System for Improved Unconstrained Handwriting Recognition. IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 31, no. 5, 2009.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">Cruse, Holk; <a href="http://www.brains-minds-media.org/archive/615/bmm615.pdf"><em>Neural Networks as Cybernetic Systems</em></a>, 2nd and revised edition<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5">H. Jaeger. Harnessing nonlinearity: Predicting chaotic systems and saving energy in wireless communication. Science, 304:78–80, 2004.<a href="#fnref5">↩</a></li>
<li id="fn6">W. Maass, T. Natschläger, and H. Markram. A fresh look at real-time computation in generic recurrent neural circuits. Technical report, Institute for Theoretical Computer Science, TU Graz, 2002.<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="Sepp_Hochreiter" title="wikilink">Hochreiter, Sepp</a>; and <a href="Jürgen_Schmidhuber" title="wikilink">Schmidhuber, Jürgen</a>; <em>Long Short-Term Memory</em>, Neural Computation, 9(8):1735–1780, 1997<a href="#fnref7">↩</a></li>
<li id="fn8">Gers, Felix A.; and Schmidhuber, Jürgen; <em>LSTM Recurrent Networks Learn Simple Context Free and Context Sensitive Languages</em>, IEEE Transactions on Neural Networks, 12(6):1333–1340, 2001<a href="#fnref8">↩</a></li>
<li id="fn9">Graves, Alex; and Schmidhuber, Jürgen; <em>Offline Handwriting Recognition with Multidimensional Recurrent Neural Networks</em>, in Bengio, Yoshua; Schuurmans, Dale; Lafferty, John; Williams, Chris K. I.; and Culotta, Aron (eds.), <em>Advances in Neural Information Processing Systems 22 (NIPS'22), December 7th–10th, 2009, Vancouver, BC</em>, Neural Information Processing Systems (NIPS) Foundation, 2009, pp. 545–552<a href="#fnref9">↩</a></li>
<li id="fn10">Bidirectional recurrent neural networks. IEEE Transactions on Signal Processing, 45:2673–81, November 1997.<a href="#fnref10">↩</a></li>
<li id="fn11">A. Graves and <a href="Jürgen_Schmidhuber" title="wikilink">J. Schmidhuber</a>. Framewise phoneme classification with bidirectional LSTM and other neural network architectures. Neural Networks, 18:602–610, 2005.<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="Jürgen_Schmidhuber" title="wikilink">J. Schmidhuber</a>. Learning complex, extended sequences using the principle of history compression. Neural Computation, 4(2):234-242, 1992<a href="#fnref15">↩</a></li>
<li id="fn16">R.W. Paine, J. Tani, "How hierarchical control self-organizes in artificial adaptive systems," Adaptive Behavior, 13(3), 211-225, 2005.<a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18">C.L. Giles, C.B. Miller, D. Chen, H.H. Chen, G.Z. Sun, Y.C. Lee, "Learning and Extracting Finite State Automata with Second-Order Recurrent Neural Networks," Neural Computation, 4(3), p. 393, 1992.<a href="#fnref18">↩</a></li>
<li id="fn19">C.W. Omlin, C.L. Giles, "Constructing Deterministic Finite-State Automata in Recurrent Neural Networks," Journal of the ACM, 45(6), 937-972, 1996.<a href="#fnref19">↩</a></li>
<li id="fn20">Y. Yamashita, J. Tani, "Emergence of functional hierarchy in a multiple timescale neural network model: a humanoid robot experiment," PLoS Computational Biology, 4(11), e1000220, 211-225, 2008. <a class="uri" href="http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1000220">http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1000220</a><a href="#fnref20">↩</a></li>
<li id="fn21"><a class="uri" href="http://arxiv.org/pdf/1410.5401v2.pdf">http://arxiv.org/pdf/1410.5401v2.pdf</a><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24">P. J. Werbos. Generalization of backpropagation with application to a recurrent gas market model. Neural Networks, 1, 1988.<a href="#fnref24">↩</a></li>
<li id="fn25">David E. Rumelhart; Geoffrey E. Hinton; Ronald J. Williams. Learning Internal Representations by Error Propagation.<a href="#fnref25">↩</a></li>
<li id="fn26">A. J. Robinson and F. Fallside. The utility driven dynamic error propagation network. Technical Report CUED/F-INFENG/TR.1, Cambridge University Engineering Department, 1987.<a href="#fnref26">↩</a></li>
<li id="fn27">R. J. Williams and D. Zipser. Gradient-based learning algorithms for recurrent networks and their computational complexity. In Back-propagation: Theory, Architectures and Applications. Hillsdale, NJ: Erlbaum, 1994.<a href="#fnref27">↩</a></li>
<li id="fn28"><a href="Jürgen_Schmidhuber" title="wikilink">J. Schmidhuber</a>. A local learning algorithm for dynamic feedforward and recurrent networks. Connection Science, 1(4):403–412, 1989.<a href="#fnref28">↩</a></li>
<li id="fn29">Neural and Adaptive Systems: Fundamentals through Simulation. J.C. Principe, N.R. Euliano, W.C. Lefebvre<a href="#fnref29">↩</a></li>
<li id="fn30"><a href="Jürgen_Schmidhuber" title="wikilink">J. Schmidhuber</a>. A fixed size storage O(n3) time complexity learning algorithm for fully recurrent continually running networks. Neural Computation, 4(2):243–248, 1992.<a href="#fnref30">↩</a></li>
<li id="fn31">R. J. Williams. Complexity of exact gradient computation algorithms for recurrent neural networks. Technical Report Technical Report NU-CCS-89-27, Boston: Northeastern University, College of Computer Science, 1989.<a href="#fnref31">↩</a></li>
<li id="fn32">B. A. Pearlmutter. Learning state space trajectories in recurrent neural networks. Neural Computation, 1(2):263–269, 1989.<a href="#fnref32">↩</a></li>
<li id="fn33"><a href="Sepp_Hochreiter" title="wikilink">S. Hochreiter</a>. Untersuchungen zu dynamischen neuronalen Netzen. Diploma thesis, Institut f. Informatik, Technische Univ. Munich, 1991.<a href="#fnref33">↩</a></li>
<li id="fn34"><a href="Sepp_Hochreiter" title="wikilink">S. Hochreiter</a>, Y. Bengio, P. Frasconi, and <a href="Jürgen_Schmidhuber" title="wikilink">J. Schmidhuber</a>. Gradient flow in recurrent nets: the difficulty of learning long-term dependencies. In S. C. Kremer and J. F. Kolen, editors, A Field Guide to Dynamical Recurrent Neural Networks. IEEE Press, 2001.<a href="#fnref34">↩</a></li>
<li id="fn35"></li>
<li id="fn36">Martens, James, and Ilya Sutskever. "<a href="http://www.cs.utoronto.ca/~ilya/pubs/2012/HF_for_dnns_and_rnns.pdf">Training deep and recurrent networks with hessian-free optimization</a>." In Neural Networks: Tricks of the Trade, pp. 479-535. Springer Berlin Heidelberg, 2012.<a href="#fnref36">↩</a></li>
<li id="fn37">F. J. Gomez and R. Miikkulainen. Solving non-Markovian control tasks with neuroevolution. Proc. IJCAI 99, Denver, CO, 1999. Morgan Kaufmann.<a href="#fnref37">↩</a></li>
<li id="fn38"><a href="http://arimaa.com/arimaa/about/Thesis/">Applying Genetic Algorithms to Recurrent Neural Networks for Learning Network Parameters and Architecture. O. Syed, Y. Takefuji</a><a href="#fnref38">↩</a></li>
<li id="fn39">F. Gomez, <a href="Jürgen_Schmidhuber" title="wikilink">J. Schmidhuber</a>, R. Miikkulainen. Accelerated Neural Evolution through Cooperatively Coevolved Synapses. Journal of Machine Learning Research (JMLR), 9:937-965, 2008.<a href="#fnref39">↩</a></li>
<li id="fn40">Hava T. Siegelmann, Bill G. Horne, C. Lee Giles, "Computational capabilities of recurrent NARX neural networks," IEEE Transactions on Systems, Man, and Cybernetics, Part B 27(2): 208-215 (1997).<a href="#fnref40">↩</a></li>
</ol>
</section>
</body>
</html>
