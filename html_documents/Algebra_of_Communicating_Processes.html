<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="432">Algebra of Communicating Processes</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Algebra of Communicating Processes</h1>
<hr>The '''Algebra of Communicating Processes''' (ACP) is an [[Universal algebra|algebraic]] approach to reasoning about [[concurrent systems]]. It is a member of the family of mathematical theories of concurrency known as process algebras or [[process calculi]]. ACP was initially developed by [[Ja

<p>n Bergstra]] and <a href="Jan_Willem_Klop" title="wikilink">Jan Willem Klop</a> in 1982,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> as part of an effort to investigate the solutions of unguarded recursive equations. More so than the other seminal process calculi (<a href="Calculus_of_Communicating_Systems" title="wikilink">CCS</a> and <a href="Communicating_sequential_processes" title="wikilink">CSP</a>), the development of ACP focused on the <a href="Universal_algebra" title="wikilink">algebra</a> of processes, and sought to create an abstract, generalized axiomatic system for processes,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and in fact the term <em>process algebra</em> was coined during the research that led to ACP.</p>
<h2 id="informal-description">Informal description</h2>

<p>ACP is fundamentally an algebra, in the sense of <a href="universal_algebra" title="wikilink">universal algebra</a>. This algebra provides a way to describe systems in terms of algebraic process expressions that define compositions of other processes, or of certain primitive elements.</p>
<h3 id="primitives">Primitives</h3>

<p>ACP uses instantaneous, <em><a href="atomic_actions" title="wikilink">atomic actions</a></em> (

<math display="inline" id="Algebra_of_Communicating_Processes:0">
<semantics>
<mrow>
<mi>a</mi>
<mo>,</mo>
<mi>b</mi>
<mo>,</mo>
<mi>c</mi>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<ci>a</ci>
<ci>b</ci>
<ci>c</ci>
<ci>normal-…</ci>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathit{a,b,c,...}
  </annotation>
</semantics>
</math>

) as its primitives. Some actions have special meaning, such as the action 

<math display="inline" id="Algebra_of_Communicating_Processes:1">
<semantics>
<mi>δ</mi>
<annotation-xml encoding="MathML-Content">
<ci>δ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \delta
  </annotation>
</semantics>
</math>

, which represents <a class="uri" href="deadlock" title="wikilink">deadlock</a> or stagnation, and the action 

<math display="inline" id="Algebra_of_Communicating_Processes:2">
<semantics>
<mi>τ</mi>
<annotation-xml encoding="MathML-Content">
<ci>τ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \tau
  </annotation>
</semantics>
</math>

, which represents a <em>silent action</em> (abstracted actions that have no specific identity).</p>
<h3 id="algebraic-operators">Algebraic operators</h3>

<p>Actions can be combined to form <em>processes</em> using a variety of operators. These operators can be roughly categorized as providing a <em>basic process algebra</em>, <em>concurrency</em>, and <em>communication</em>.</p>
<ul>
<li><strong>Choice and sequencing</strong> — the most fundamental of algebraic operators are the <em>alternative</em> operator (

<math display="inline" id="Algebra_of_Communicating_Processes:3">
<semantics>
<mo>+</mo>
<annotation-xml encoding="MathML-Content">
<plus></plus>
</annotation-xml>
<annotation encoding="application/x-tex">
   +
  </annotation>
</semantics>
</math>

), which provides a choice between actions, and the <em>sequencing operator</em> (

<math display="inline" id="Algebra_of_Communicating_Processes:4">
<semantics>
<mo>⋅</mo>
<annotation-xml encoding="MathML-Content">
<ci>normal-⋅</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \cdot
  </annotation>
</semantics>
</math>

), which specifies an ordering on actions. So, for example, the process</li>
</ul>

<p>
<math display="block" id="Algebra_of_Communicating_Processes:5">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>a</mi>
<mo>+</mo>
<mi>b</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>⋅</mo>
<mi>c</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-⋅</ci>
<apply>
<plus></plus>
<ci>a</ci>
<ci>b</ci>
</apply>
<ci>c</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (a+b)\cdot c
  </annotation>
</semantics>
</math>
</p>
<dl>
<dd>first chooses to perform either 

<math display="inline" id="Algebra_of_Communicating_Processes:6">
<semantics>
<mi>a</mi>
<annotation-xml encoding="MathML-Content">
<ci>a</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathit{a}
  </annotation>
</semantics>
</math>

 or 

<math display="inline" id="Algebra_of_Communicating_Processes:7">
<semantics>
<mi>b</mi>
<annotation-xml encoding="MathML-Content">
<ci>b</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathit{b}
  </annotation>
</semantics>
</math>

, and then performs action 

<math display="inline" id="Algebra_of_Communicating_Processes:8">
<semantics>
<mi>c</mi>
<annotation-xml encoding="MathML-Content">
<ci>c</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathit{c}
  </annotation>
</semantics>
</math>

. How the choice between 

<math display="inline" id="Algebra_of_Communicating_Processes:9">
<semantics>
<mi>a</mi>
<annotation-xml encoding="MathML-Content">
<ci>a</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathit{a}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Algebra_of_Communicating_Processes:10">
<semantics>
<mi>b</mi>
<annotation-xml encoding="MathML-Content">
<ci>b</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathit{b}
  </annotation>
</semantics>
</math>

 is made does not matter and is left unspecified. Note that alternative composition is commutative but sequential composition is not (because time flows forward).
</dd>
</dl>
<ul>
<li><strong>Concurrency</strong> — to allow the description of concurrency, ACP provides the <em>merge</em> and <em>left-merge</em> operators. The merge operator, 

<math display="inline" id="Algebra_of_Communicating_Processes:11">
<semantics>
<mrow>
<mo stretchy="false">|</mo>
<mo stretchy="false">|</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-|</ci>
<ci>normal-|</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   ||
  </annotation>
</semantics>
</math>

, represents the parallel composition of two processes, the individual actions of which are interleaved. The left-merge operator, 

<math display="inline" id="Algebra_of_Communicating_Processes:12">
<semantics>
<mrow>
<mo stretchy="false">|</mo>
<mo stretchy="false">⌊</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-|</ci>
<ci>normal-⌊</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   |\lfloor
  </annotation>
</semantics>
</math>

, is an auxiliary operator with similar semantics to the merge, but a commitment to always choose its initial step from the left-hand process. As an example, the process</li>
</ul>

<p>
<math display="block" id="Algebra_of_Communicating_Processes:13">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mo>⋅</mo>
<mi>b</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">|</mo>
<mo stretchy="false">|</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>c</mi>
<mo>⋅</mo>
<mi>d</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">a</csymbol>
<ci>normal-⋅</ci>
<csymbol cd="unknown">b</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-|</ci>
<ci>normal-|</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">c</csymbol>
<ci>normal-⋅</ci>
<csymbol cd="unknown">d</csymbol>
<ci>normal-)</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   (a\cdot b)||(c\cdot d)
  </annotation>
</semantics>
</math>
</p>
<dl>
<dd>may perform the actions 

<math display="inline" id="Algebra_of_Communicating_Processes:14">
<semantics>
<mrow>
<mi>a</mi>
<mo>,</mo>
<mi>b</mi>
<mo>,</mo>
<mi>c</mi>
<mo>,</mo>
<mi>d</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<ci>a</ci>
<ci>b</ci>
<ci>c</ci>
<ci>d</ci>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   a,b,c,d
  </annotation>
</semantics>
</math>

 in any of the sequences 

<math display="inline" id="Algebra_of_Communicating_Processes:15">
<semantics>
<mrow>
<mrow>
<mi>a</mi>
<mi>b</mi>
<mi>c</mi>
<mi>d</mi>
</mrow>
<mo>,</mo>
<mrow>
<mi>a</mi>
<mi>c</mi>
<mi>b</mi>
<mi>d</mi>
</mrow>
<mo>,</mo>
<mrow>
<mi>a</mi>
<mi>c</mi>
<mi>d</mi>
<mi>b</mi>
</mrow>
<mo>,</mo>
<mrow>
<mi>c</mi>
<mi>a</mi>
<mi>b</mi>
<mi>d</mi>
</mrow>
<mo>,</mo>
<mrow>
<mi>c</mi>
<mi>a</mi>
<mi>d</mi>
<mi>b</mi>
</mrow>
<mo>,</mo>
<mrow>
<mi>c</mi>
<mi>d</mi>
<mi>a</mi>
<mi>b</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<times></times>
<ci>a</ci>
<ci>b</ci>
<ci>c</ci>
<ci>d</ci>
</apply>
<apply>
<times></times>
<ci>a</ci>
<ci>c</ci>
<ci>b</ci>
<ci>d</ci>
</apply>
<apply>
<times></times>
<ci>a</ci>
<ci>c</ci>
<ci>d</ci>
<ci>b</ci>
</apply>
<apply>
<times></times>
<ci>c</ci>
<ci>a</ci>
<ci>b</ci>
<ci>d</ci>
</apply>
<apply>
<times></times>
<ci>c</ci>
<ci>a</ci>
<ci>d</ci>
<ci>b</ci>
</apply>
<apply>
<times></times>
<ci>c</ci>
<ci>d</ci>
<ci>a</ci>
<ci>b</ci>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   abcd,acbd,acdb,cabd,cadb,cdab
  </annotation>
</semantics>
</math>

. On the other hand, the process
</dd>
</dl>

<p>
<math display="block" id="Algebra_of_Communicating_Processes:16">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mo>⋅</mo>
<mi>b</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">|</mo>
<mrow>
<mo stretchy="false">⌊</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>c</mi>
<mo>⋅</mo>
<mi>d</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">a</csymbol>
<ci>normal-⋅</ci>
<csymbol cd="unknown">b</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-|</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-⌊</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">c</csymbol>
<ci>normal-⋅</ci>
<csymbol cd="unknown">d</csymbol>
<ci>normal-)</ci>
</cerror>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   (a\cdot b)|\lfloor(c\cdot d)
  </annotation>
</semantics>
</math>
</p>
<dl>
<dd>may only perform the sequences 

<math display="inline" id="Algebra_of_Communicating_Processes:17">
<semantics>
<mrow>
<mrow>
<mi>a</mi>
<mi>b</mi>
<mi>c</mi>
<mi>d</mi>
</mrow>
<mo>,</mo>
<mrow>
<mi>a</mi>
<mi>c</mi>
<mi>b</mi>
<mi>d</mi>
</mrow>
<mo>,</mo>
<mrow>
<mi>a</mi>
<mi>c</mi>
<mi>d</mi>
<mi>b</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<times></times>
<ci>a</ci>
<ci>b</ci>
<ci>c</ci>
<ci>d</ci>
</apply>
<apply>
<times></times>
<ci>a</ci>
<ci>c</ci>
<ci>b</ci>
<ci>d</ci>
</apply>
<apply>
<times></times>
<ci>a</ci>
<ci>c</ci>
<ci>d</ci>
<ci>b</ci>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   abcd,acbd,acdb
  </annotation>
</semantics>
</math>

 since the left-merge operators ensures that the action 

<math display="inline" id="Algebra_of_Communicating_Processes:18">
<semantics>
<mi>a</mi>
<annotation-xml encoding="MathML-Content">
<ci>a</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathit{a}
  </annotation>
</semantics>
</math>

 occurs first.
</dd>
</dl>
<ul>
<li><strong>Communication</strong> — interaction (or communication) between processes is represented using the binary communications operator, 

<math display="inline" id="Algebra_of_Communicating_Processes:19">
<semantics>
<mo stretchy="false">|</mo>
<annotation-xml encoding="MathML-Content">
<ci>normal-|</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   |
  </annotation>
</semantics>
</math>

. For example, the actions 

<math display="inline" id="Algebra_of_Communicating_Processes:20">
<semantics>
<mrow>
<mi>r</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>d</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>r</ci>
<ci>d</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   r(d)
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Algebra_of_Communicating_Processes:21">
<semantics>
<mrow>
<mi>w</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>d</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>w</ci>
<ci>d</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   w(d)
  </annotation>
</semantics>
</math>

 might be interpreted as the reading and writing of a data item 

<math display="inline" id="Algebra_of_Communicating_Processes:22">
<semantics>
<mrow>
<mi>d</mi>
<mo>∈</mo>
<mi>D</mi>
<mo>=</mo>
<mrow>
<mo stretchy="false">{</mo>
<mn>1</mn>
<mo>,</mo>
<mn>2</mn>
<mo>,</mo>
<mn>3</mn>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo stretchy="false">}</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<in></in>
<ci>d</ci>
<ci>D</ci>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<set>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
<cn type="integer">3</cn>
<ci>normal-…</ci>
</set>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   d\in D=\{1,2,3,\ldots\}
  </annotation>
</semantics>
</math>

, respectively. Then the process</li>
</ul>

<p>
<math display="block" id="Algebra_of_Communicating_Processes:23">
<semantics>
<mrow>
<mrow>
<mo>(</mo>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>d</mi>
<mo>∈</mo>
<mi>D</mi>
</mrow>
</munder>
<mi>r</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>d</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>⋅</mo>
<mi>y</mi>
<mo>)</mo>
</mrow>
<mo stretchy="false">|</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>w</mi>
<mrow>
<mo stretchy="false">(</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
<mo>⋅</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<in></in>
<ci>d</ci>
<ci>D</ci>
</apply>
</apply>
<csymbol cd="unknown">r</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">d</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-⋅</ci>
<csymbol cd="unknown">y</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-|</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">w</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<cn type="integer">1</cn>
<ci>normal-)</ci>
</cerror>
<ci>normal-⋅</ci>
<csymbol cd="unknown">z</csymbol>
<ci>normal-)</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \left(\sum_{d\in D}r(d)\cdot y\right)|(w(1)\cdot z)
  </annotation>
</semantics>
</math>
</p>
<dl>
<dd>will communicate the value 

<math display="inline" id="Algebra_of_Communicating_Processes:24">
<semantics>
<mn>1</mn>
<annotation-xml encoding="MathML-Content">
<cn type="integer">1</cn>
</annotation-xml>
<annotation encoding="application/x-tex">
   1
  </annotation>
</semantics>
</math>

 from the right component process to the left component process (<em>i.e.</em> the identifier 

<math display="inline" id="Algebra_of_Communicating_Processes:25">
<semantics>
<mi>d</mi>
<annotation-xml encoding="MathML-Content">
<ci>d</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathit{d}
  </annotation>
</semantics>
</math>

 is bound to the value 

<math display="inline" id="Algebra_of_Communicating_Processes:26">
<semantics>
<mn>1</mn>
<annotation-xml encoding="MathML-Content">
<cn type="integer">1</cn>
</annotation-xml>
<annotation encoding="application/x-tex">
   1
  </annotation>
</semantics>
</math>

, and free instances of 

<math display="inline" id="Algebra_of_Communicating_Processes:27">
<semantics>
<mi>d</mi>
<annotation-xml encoding="MathML-Content">
<ci>d</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathit{d}
  </annotation>
</semantics>
</math>

 in the process 

<math display="inline" id="Algebra_of_Communicating_Processes:28">
<semantics>
<mi>y</mi>
<annotation-xml encoding="MathML-Content">
<ci>y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathit{y}
  </annotation>
</semantics>
</math>

 take on that value), and then behave as the merge of 

<math display="inline" id="Algebra_of_Communicating_Processes:29">
<semantics>
<mi>y</mi>
<annotation-xml encoding="MathML-Content">
<ci>y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathit{y}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Algebra_of_Communicating_Processes:30">
<semantics>
<mi>z</mi>
<annotation-xml encoding="MathML-Content">
<ci>z</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathit{z}
  </annotation>
</semantics>
</math>

.
</dd>
</dl>
<ul>
<li><strong>Abstraction</strong> — the abstraction operator, 

<math display="inline" id="Algebra_of_Communicating_Processes:31">
<semantics>
<msub>
<mi>τ</mi>
<mi>I</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>τ</ci>
<ci>I</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \tau_{I}
  </annotation>
</semantics>
</math>

, provides a way to "hide" certain actions, and treat them as events that are internal to the systems being modelled. Abstracted actions are converted to the <em>silent step</em> action 

<math display="inline" id="Algebra_of_Communicating_Processes:32">
<semantics>
<mi>τ</mi>
<annotation-xml encoding="MathML-Content">
<ci>τ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \tau
  </annotation>
</semantics>
</math>

. In some cases, these silent steps can also be removed from the process expression as part of the abstraction process. For example,</li>
</ul>

<p>
<math display="block" id="Algebra_of_Communicating_Processes:33">
<semantics>
<mrow>
<mrow>
<msub>
<mi>τ</mi>
<mrow>
<mo stretchy="false">{</mo>
<mi>c</mi>
<mo stretchy="false">}</mo>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>a</mi>
<mo>+</mo>
<mi>b</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>⋅</mo>
<mi>c</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>a</mi>
<mo>+</mo>
<mi>b</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>⋅</mo>
<mi>τ</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>τ</ci>
<set>
<ci>c</ci>
</set>
</apply>
<apply>
<ci>normal-⋅</ci>
<apply>
<plus></plus>
<ci>a</ci>
<ci>b</ci>
</apply>
<ci>c</ci>
</apply>
</apply>
<apply>
<ci>normal-⋅</ci>
<apply>
<plus></plus>
<ci>a</ci>
<ci>b</ci>
</apply>
<ci>τ</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \tau_{\{c\}}((a+b)\cdot c)=(a+b)\cdot\tau
  </annotation>
</semantics>
</math>
</p>
<dl>
<dd>which, in this case, can be reduced to
</dd>
</dl>

<p>
<math display="block" id="Algebra_of_Communicating_Processes:34">
<semantics>
<mrow>
<mi>a</mi>
<mo>+</mo>
<mi>b</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<plus></plus>
<ci>a</ci>
<ci>b</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   a+b
  </annotation>
</semantics>
</math>
</p>
<dl>
<dd>since the event 

<math display="inline" id="Algebra_of_Communicating_Processes:35">
<semantics>
<mi>c</mi>
<annotation-xml encoding="MathML-Content">
<ci>c</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathit{c}
  </annotation>
</semantics>
</math>

 is no longer observable and has no observable effects.
</dd>
</dl>
<h2 id="formal-definition">Formal definition</h2>

<p>ACP fundamentally adopts an axiomatic, algebraic approach to the formal definition of its various operators. The axioms presented below comprise the full axiomatic system for ACP<sub>
<math display="inline" id="Algebra_of_Communicating_Processes:36">
<semantics>
<mi>τ</mi>
<annotation-xml encoding="MathML-Content">
<ci>τ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \tau
  </annotation>
</semantics>
</math>
</sub> (ACP with abstraction).</p>
<h3 id="basic-process-algebra">Basic process algebra</h3>

<p>Using the alternative and sequential composition operators, ACP defines a <em>basic process algebra</em> which satisfies the axioms<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>
<math display="block" id="Algebra_of_Communicating_Processes:37">
<semantics>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="center">
<mrow>
<mi>x</mi>
<mo>+</mo>
<mi>y</mi>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mi>y</mi>
<mo>+</mo>
<mi>x</mi>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>+</mo>
<mi>y</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>+</mo>
<mi>z</mi>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mi>x</mi>
<mo>+</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>y</mi>
<mo>+</mo>
<mi>z</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mi>x</mi>
<mo>+</mo>
<mi>x</mi>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mi>x</mi>
<mo>;</mo>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>+</mo>
<mi>y</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>⋅</mo>
<mi>z</mi>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>⋅</mo>
<mi>z</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>+</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>y</mi>
<mo>⋅</mo>
<mi>z</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>⋅</mo>
<mi>y</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>⋅</mo>
<mi>z</mi>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mi>x</mi>
<mo>⋅</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>y</mi>
<mo>⋅</mo>
<mi>z</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mtd>
</mtr>
</mtable>
<annotation-xml encoding="MathML-Content">
<matrix>
<matrixrow>
<apply>
<plus></plus>
<ci>x</ci>
<ci>y</ci>
</apply>
<eq></eq>
<apply>
<plus></plus>
<ci>y</ci>
<ci>x</ci>
</apply>
</matrixrow>
<matrixrow>
<apply>
<plus></plus>
<apply>
<plus></plus>
<ci>x</ci>
<ci>y</ci>
</apply>
<ci>z</ci>
</apply>
<eq></eq>
<apply>
<plus></plus>
<ci>x</ci>
<apply>
<plus></plus>
<ci>y</ci>
<ci>z</ci>
</apply>
</apply>
</matrixrow>
<matrixrow>
<apply>
<plus></plus>
<ci>x</ci>
<ci>x</ci>
</apply>
<eq></eq>
<ci>x</ci>
</matrixrow>
<matrixrow>
<apply>
<ci>normal-⋅</ci>
<apply>
<plus></plus>
<ci>x</ci>
<ci>y</ci>
</apply>
<ci>z</ci>
</apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<ci>normal-⋅</ci>
<ci>x</ci>
<ci>z</ci>
</apply>
<apply>
<ci>normal-⋅</ci>
<ci>y</ci>
<ci>z</ci>
</apply>
</apply>
</matrixrow>
<matrixrow>
<apply>
<ci>normal-⋅</ci>
<apply>
<ci>normal-⋅</ci>
<ci>x</ci>
<ci>y</ci>
</apply>
<ci>z</ci>
</apply>
<eq></eq>
<apply>
<ci>normal-⋅</ci>
<ci>x</ci>
<apply>
<ci>normal-⋅</ci>
<ci>y</ci>
<ci>z</ci>
</apply>
</apply>
</matrixrow>
</matrix>
</annotation-xml>
<annotation encoding="application/x-tex">
   \begin{matrix}x+y&amp;=&amp;y;+x\\
(x+y)+z&amp;=&amp;x;+(y+z)\\
x+x&amp;=&amp;x;\\
(x+y)\cdot z&amp;=&amp;(x\cdot z)+(y\cdot z)\\
(x\cdot y)\cdot z&amp;=&amp;x;\cdot(y\cdot z)\end{matrix}
  </annotation>
</semantics>
</math>
</p>
<h3 id="deadlock">Deadlock</h3>

<p>Beyond the basic algebra, two additional axioms define the relationships between the alternative and sequencing operators, and the <em>deadlock</em> action, 

<math display="inline" id="Algebra_of_Communicating_Processes:38">
<semantics>
<mi>δ</mi>
<annotation-xml encoding="MathML-Content">
<ci>δ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \delta
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Algebra_of_Communicating_Processes:39">
<semantics>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="center">
<mrow>
<mi>δ</mi>
<mo>+</mo>
<mi>x</mi>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mi>x</mi>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mi>δ</mi>
<mo>⋅</mo>
<mi>x</mi>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mi>δ</mi>
</mtd>
</mtr>
</mtable>
<annotation-xml encoding="MathML-Content">
<matrix>
<matrixrow>
<apply>
<plus></plus>
<ci>δ</ci>
<ci>x</ci>
</apply>
<eq></eq>
<ci>x</ci>
</matrixrow>
<matrixrow>
<apply>
<ci>normal-⋅</ci>
<ci>δ</ci>
<ci>x</ci>
</apply>
<eq></eq>
<ci>δ</ci>
</matrixrow>
</matrix>
</annotation-xml>
<annotation encoding="application/x-tex">
   \begin{matrix}\delta+x&amp;=&amp;x;\\
\delta\cdot x&amp;=&amp;\delta\end{matrix}
  </annotation>
</semantics>
</math>
</p>
<h3 id="concurrency-and-interaction">Concurrency and interaction</h3>

<p>The axioms associated with the merge, left-merge, and communication operators are<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>
<math display="block" id="Algebra_of_Communicating_Processes:40">
<semantics>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="center">
<mrow>
<mi>x</mi>
<mo stretchy="false">|</mo>
<mo stretchy="false">|</mo>
<mi>y</mi>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mi>x</mi>
<mo stretchy="false">|</mo>
<mrow>
<mo stretchy="false">⌊</mo>
<mi>y</mi>
<mo>+</mo>
<mi>y</mi>
<mo stretchy="false">|</mo>
<mrow>
<mo stretchy="false">⌊</mo>
<mi>x</mi>
<mo>+</mo>
<mi>x</mi>
<mo stretchy="false">|</mo>
<mi>y</mi>
</mrow>
</mrow>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mi>a</mi>
<mo>⋅</mo>
<mi>x</mi>
<mo stretchy="false">|</mo>
<mrow>
<mo stretchy="false">⌊</mo>
<mi>y</mi>
</mrow>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mi>a</mi>
<mo>⋅</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">|</mo>
<mo stretchy="false">|</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mi>a</mi>
<mo stretchy="false">|</mo>
<mrow>
<mo stretchy="false">⌊</mo>
<mi>y</mi>
</mrow>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mi>a</mi>
<mo>⋅</mo>
<mi>y</mi>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>+</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">|</mo>
<mrow>
<mo stretchy="false">⌊</mo>
<mi>z</mi>
</mrow>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">|</mo>
<mrow>
<mo stretchy="false">⌊</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>+</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">|</mo>
<mrow>
<mo stretchy="false">⌊</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mi>a</mi>
<mo>⋅</mo>
<mi>x</mi>
<mo stretchy="false">|</mo>
<mi>b</mi>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mo stretchy="false">|</mo>
<mi>b</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>⋅</mo>
<mi>x</mi>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mi>a</mi>
<mo stretchy="false">|</mo>
<mi>b</mi>
<mo>⋅</mo>
<mi>x</mi>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mo stretchy="false">|</mo>
<mi>b</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>⋅</mo>
<mi>x</mi>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mi>a</mi>
<mo>⋅</mo>
<mi>x</mi>
<mo stretchy="false">|</mo>
<mi>b</mi>
<mo>⋅</mo>
<mi>y</mi>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mo stretchy="false">|</mo>
<mi>b</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>⋅</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">|</mo>
<mo stretchy="false">|</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>+</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">|</mo>
<mi>z</mi>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mi>x</mi>
<mrow>
<mo stretchy="false">|</mo>
<mrow>
<mi>z</mi>
<mo>+</mo>
<mi>y</mi>
</mrow>
<mo stretchy="false">|</mo>
</mrow>
<mi>z</mi>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mi>x</mi>
<mo stretchy="false">|</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo>+</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mi>x</mi>
<mrow>
<mo stretchy="false">|</mo>
<mrow>
<mi>y</mi>
<mo>+</mo>
<mi>x</mi>
</mrow>
<mo stretchy="false">|</mo>
</mrow>
<mi>z</mi>
</mrow>
</mtd>
</mtr>
</mtable>
<annotation-xml encoding="MathML-Content">
<matrix>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">x</csymbol>
<ci>normal-|</ci>
<ci>normal-|</ci>
<csymbol cd="unknown">y</csymbol>
</cerror>
<eq></eq>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">x</csymbol>
<ci>normal-|</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-⌊</ci>
<csymbol cd="unknown">y</csymbol>
<plus></plus>
<csymbol cd="unknown">y</csymbol>
<ci>normal-|</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-⌊</ci>
<csymbol cd="unknown">x</csymbol>
<plus></plus>
<csymbol cd="unknown">x</csymbol>
<ci>normal-|</ci>
<csymbol cd="unknown">y</csymbol>
</cerror>
</cerror>
</cerror>
</matrixrow>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">a</csymbol>
<ci>normal-⋅</ci>
<csymbol cd="unknown">x</csymbol>
<ci>normal-|</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-⌊</ci>
<csymbol cd="unknown">y</csymbol>
</cerror>
</cerror>
<eq></eq>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">a</csymbol>
<ci>normal-⋅</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">x</csymbol>
<ci>normal-|</ci>
<ci>normal-|</ci>
<csymbol cd="unknown">y</csymbol>
<ci>normal-)</ci>
</cerror>
</cerror>
</matrixrow>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">a</csymbol>
<ci>normal-|</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-⌊</ci>
<csymbol cd="unknown">y</csymbol>
</cerror>
</cerror>
<eq></eq>
<apply>
<ci>normal-⋅</ci>
<ci>a</ci>
<ci>y</ci>
</apply>
</matrixrow>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">x</csymbol>
<plus></plus>
<csymbol cd="unknown">y</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-|</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-⌊</ci>
<csymbol cd="unknown">z</csymbol>
</cerror>
</cerror>
<eq></eq>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">x</csymbol>
<ci>normal-|</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-⌊</ci>
<csymbol cd="unknown">z</csymbol>
<ci>normal-)</ci>
</cerror>
<plus></plus>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">y</csymbol>
<ci>normal-|</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-⌊</ci>
<csymbol cd="unknown">z</csymbol>
<ci>normal-)</ci>
</cerror>
</cerror>
</cerror>
</matrixrow>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">a</csymbol>
<ci>normal-⋅</ci>
<csymbol cd="unknown">x</csymbol>
<ci>normal-|</ci>
<csymbol cd="unknown">b</csymbol>
</cerror>
<eq></eq>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">a</csymbol>
<ci>normal-|</ci>
<csymbol cd="unknown">b</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-⋅</ci>
<csymbol cd="unknown">x</csymbol>
</cerror>
</matrixrow>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">a</csymbol>
<ci>normal-|</ci>
<csymbol cd="unknown">b</csymbol>
<ci>normal-⋅</ci>
<csymbol cd="unknown">x</csymbol>
</cerror>
<eq></eq>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">a</csymbol>
<ci>normal-|</ci>
<csymbol cd="unknown">b</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-⋅</ci>
<csymbol cd="unknown">x</csymbol>
</cerror>
</matrixrow>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">a</csymbol>
<ci>normal-⋅</ci>
<csymbol cd="unknown">x</csymbol>
<ci>normal-|</ci>
<csymbol cd="unknown">b</csymbol>
<ci>normal-⋅</ci>
<csymbol cd="unknown">y</csymbol>
</cerror>
<eq></eq>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">a</csymbol>
<ci>normal-|</ci>
<csymbol cd="unknown">b</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-⋅</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">x</csymbol>
<ci>normal-|</ci>
<ci>normal-|</ci>
<csymbol cd="unknown">y</csymbol>
<ci>normal-)</ci>
</cerror>
</cerror>
</matrixrow>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">x</csymbol>
<plus></plus>
<csymbol cd="unknown">y</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-|</ci>
<csymbol cd="unknown">z</csymbol>
</cerror>
<eq></eq>
<apply>
<times></times>
<ci>x</ci>
<apply>
<abs></abs>
<apply>
<plus></plus>
<ci>z</ci>
<ci>y</ci>
</apply>
</apply>
<ci>z</ci>
</apply>
</matrixrow>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">x</csymbol>
<ci>normal-|</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">y</csymbol>
<plus></plus>
<csymbol cd="unknown">z</csymbol>
<ci>normal-)</ci>
</cerror>
</cerror>
<eq></eq>
<apply>
<times></times>
<ci>x</ci>
<apply>
<abs></abs>
<apply>
<plus></plus>
<ci>y</ci>
<ci>x</ci>
</apply>
</apply>
<ci>z</ci>
</apply>
</matrixrow>
</matrix>
</annotation-xml>
<annotation encoding="application/x-tex">
   \begin{matrix}x||y&amp;=&amp;x;|\lfloor y+y|\lfloor x+x|y\\
a\cdot x|\lfloor y&amp;=&amp;a;\cdot(x||y)\\
a|\lfloor y&amp;=&amp;a;\cdot y\\
(x+y)|\lfloor z&amp;=&amp;(x|\lfloor z)+(y|\lfloor z)\\
a\cdot x|b&amp;=&amp;(a|b)\cdot x\\
a|b\cdot x&amp;=&amp;(a|b)\cdot x\\
a\cdot x|b\cdot y&amp;=&amp;(a|b)\cdot(x||y)\\
(x+y)|z&amp;=&amp;x;|z+y|z\\
x|(y+z)&amp;=&amp;x;|y+x|z\end{matrix}
  </annotation>
</semantics>
</math>
</p>

<p>When the communications operator is applied to actions alone, rather than processes, it is interpreted as a binary function from actions to actions, 

<math display="inline" id="Algebra_of_Communicating_Processes:41">
<semantics>
<mrow>
<mo stretchy="false">|</mo>
<mo>:</mo>
<mi>A</mi>
<mo>×</mo>
<mi>A</mi>
<mo>→</mo>
<mi>A</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-|</ci>
<ci>normal-:</ci>
<csymbol cd="unknown">A</csymbol>
<times></times>
<csymbol cd="unknown">A</csymbol>
<ci>normal-→</ci>
<csymbol cd="unknown">A</csymbol>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   |:A\times A\rightarrow A
  </annotation>
</semantics>
</math>

. The definition of this function defines the possible interactions between processes — those pairs of actions that do not constitute interactions are mapped to the deadlock action, 

<math display="inline" id="Algebra_of_Communicating_Processes:42">
<semantics>
<mi>δ</mi>
<annotation-xml encoding="MathML-Content">
<ci>δ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \delta
  </annotation>
</semantics>
</math>

, while permitted interaction pairs are mapped to corresponding single actions representing the occurrence of an interaction. For example, the communications function might specify that</p>

<p>
<math display="block" id="Algebra_of_Communicating_Processes:43">
<semantics>
<mrow>
<mi>a</mi>
<mo stretchy="false">|</mo>
<mi>a</mi>
<mo>→</mo>
<mi>c</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">a</csymbol>
<ci>normal-|</ci>
<csymbol cd="unknown">a</csymbol>
<ci>normal-→</ci>
<csymbol cd="unknown">c</csymbol>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   a|a\rightarrow c
  </annotation>
</semantics>
</math>

 which indicates that a successful interaction 

<math display="inline" id="Algebra_of_Communicating_Processes:44">
<semantics>
<mrow>
<mi>a</mi>
<mo stretchy="false">|</mo>
<mi>a</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">a</csymbol>
<ci>normal-|</ci>
<csymbol cd="unknown">a</csymbol>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   a|a
  </annotation>
</semantics>
</math>

 will be reduced to the action 

<math display="inline" id="Algebra_of_Communicating_Processes:45">
<semantics>
<mi>c</mi>
<annotation-xml encoding="MathML-Content">
<ci>c</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   c
  </annotation>
</semantics>
</math>

. ACP also includes an encapsulation operator, 

<math display="inline" id="Algebra_of_Communicating_Processes:46">
<semantics>
<msub>
<mo>∂</mo>
<mi>H</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<partialdiff></partialdiff>
<ci>H</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \partial_{H}
  </annotation>
</semantics>
</math>

 for some 

<math display="inline" id="Algebra_of_Communicating_Processes:47">
<semantics>
<mrow>
<mi>H</mi>
<mo>⊆</mo>
<mi>A</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<subset></subset>
<ci>H</ci>
<ci>A</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H\subseteq A
  </annotation>
</semantics>
</math>

, which is used to convert unsuccessful communication attempts (i.e. elements of 

<math display="inline" id="Algebra_of_Communicating_Processes:48">
<semantics>
<mi>H</mi>
<annotation-xml encoding="MathML-Content">
<ci>H</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   H
  </annotation>
</semantics>
</math>

 that have not been reduced via the communication function) to the deadlock action. The axioms associated with the communications function and encapsulation operator are<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>
<math display="block" id="Algebra_of_Communicating_Processes:49">
<semantics>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="center">
<mrow>
<mi>a</mi>
<mo stretchy="false">|</mo>
<mi>b</mi>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mi>b</mi>
<mo stretchy="false">|</mo>
<mi>a</mi>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mo stretchy="false">|</mo>
<mi>b</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">|</mo>
<mi>c</mi>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mi>a</mi>
<mo stretchy="false">|</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>b</mi>
<mo stretchy="false">|</mo>
<mi>c</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mi>a</mi>
<mo stretchy="false">|</mo>
<mi>δ</mi>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mi>δ</mi>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<msub>
<mo>∂</mo>
<mi>H</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mrow>
<mi>a</mi>
<mtext>if</mtext>
<mi>a</mi>
</mrow>
<mo>∉</mo>
<mi>H</mi>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<msub>
<mo>∂</mo>
<mi>H</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mrow>
<mi>δ</mi>
<mtext>if</mtext>
<mi>a</mi>
</mrow>
<mo>∈</mo>
<mi>H</mi>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<msub>
<mo>∂</mo>
<mi>H</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>+</mo>
<mi>y</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mrow>
<msub>
<mo>∂</mo>
<mi>H</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<msub>
<mo>∂</mo>
<mi>H</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<msub>
<mo>∂</mo>
<mi>H</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>⋅</mo>
<mi>y</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mrow>
<msub>
<mo>∂</mo>
<mi>H</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>⋅</mo>
<mrow>
<msub>
<mo>∂</mo>
<mi>H</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mtd>
</mtr>
</mtable>
<annotation-xml encoding="MathML-Content">
<matrix>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">a</csymbol>
<ci>normal-|</ci>
<csymbol cd="unknown">b</csymbol>
</cerror>
<eq></eq>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">b</csymbol>
<ci>normal-|</ci>
<csymbol cd="unknown">a</csymbol>
</cerror>
</matrixrow>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">a</csymbol>
<ci>normal-|</ci>
<csymbol cd="unknown">b</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-|</ci>
<csymbol cd="unknown">c</csymbol>
</cerror>
<eq></eq>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">a</csymbol>
<ci>normal-|</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">b</csymbol>
<ci>normal-|</ci>
<csymbol cd="unknown">c</csymbol>
<ci>normal-)</ci>
</cerror>
</cerror>
</matrixrow>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">a</csymbol>
<ci>normal-|</ci>
<csymbol cd="unknown">δ</csymbol>
</cerror>
<eq></eq>
<ci>δ</ci>
</matrixrow>
<matrixrow>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<partialdiff></partialdiff>
<ci>H</ci>
</apply>
<ci>a</ci>
</apply>
<eq></eq>
<apply>
<notin></notin>
<apply>
<times></times>
<ci>a</ci>
<mtext>if</mtext>
<ci>a</ci>
</apply>
<ci>H</ci>
</apply>
</matrixrow>
<matrixrow>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<partialdiff></partialdiff>
<ci>H</ci>
</apply>
<ci>a</ci>
</apply>
<eq></eq>
<apply>
<in></in>
<apply>
<times></times>
<ci>δ</ci>
<mtext>if</mtext>
<ci>a</ci>
</apply>
<ci>H</ci>
</apply>
</matrixrow>
<matrixrow>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<partialdiff></partialdiff>
<ci>H</ci>
</apply>
<apply>
<plus></plus>
<ci>x</ci>
<ci>y</ci>
</apply>
</apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<partialdiff></partialdiff>
<ci>H</ci>
</apply>
<ci>x</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<partialdiff></partialdiff>
<ci>H</ci>
</apply>
<ci>y</ci>
</apply>
</apply>
</matrixrow>
<matrixrow>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<partialdiff></partialdiff>
<ci>H</ci>
</apply>
<apply>
<ci>normal-⋅</ci>
<ci>x</ci>
<ci>y</ci>
</apply>
</apply>
<eq></eq>
<apply>
<ci>normal-⋅</ci>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<partialdiff></partialdiff>
<ci>H</ci>
</apply>
<ci>x</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<partialdiff></partialdiff>
<ci>H</ci>
</apply>
<ci>y</ci>
</apply>
</apply>
</matrixrow>
</matrix>
</annotation-xml>
<annotation encoding="application/x-tex">
   \begin{matrix}a|b&amp;=&amp;b;|a\\
(a|b)|c&amp;=&amp;a;|(b|c)\\
a|\delta&amp;=&amp;\delta\\
\partial_{H}(a)&amp;=&amp;a;\mbox{ if }a\notin H\\
\partial_{H}(a)&amp;=&amp;\delta\mbox{ if }a\in H\\
\partial_{H}(x+y)&amp;=&amp;\partial_{H}(x)+\partial_{H}(y)\\
\partial_{H}(x\cdot y)&amp;=&amp;\partial_{H}(x)\cdot\partial_{H}(y)\\
\end{matrix}
  </annotation>
</semantics>
</math>
</p>
<h3 id="abstraction">Abstraction</h3>

<p>The axioms associated with the abstraction operator are<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>
<math display="block" id="Algebra_of_Communicating_Processes:50">
<semantics>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="center">
<mrow>
<msub>
<mi>τ</mi>
<mi>I</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>τ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mi>τ</mi>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<msub>
<mi>τ</mi>
<mi>I</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mrow>
<mi>a</mi>
<mtext>if</mtext>
<mi>a</mi>
</mrow>
<mo>∉</mo>
<mi>I</mi>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<msub>
<mi>τ</mi>
<mi>I</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>a</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mrow>
<mi>τ</mi>
<mtext>if</mtext>
<mi>a</mi>
</mrow>
<mo>∈</mo>
<mi>I</mi>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<msub>
<mi>τ</mi>
<mi>I</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>+</mo>
<mi>y</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mrow>
<msub>
<mi>τ</mi>
<mi>I</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<msub>
<mi>τ</mi>
<mi>I</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<msub>
<mi>τ</mi>
<mi>I</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>⋅</mo>
<mi>y</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mrow>
<mrow>
<msub>
<mi>τ</mi>
<mi>I</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>⋅</mo>
<msub>
<mi>τ</mi>
<mi>I</mi>
</msub>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<msub>
<mo>∂</mo>
<mi>H</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>τ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mi>τ</mi>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mi>x</mi>
<mo>⋅</mo>
<mi>τ</mi>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mi>x</mi>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mi>τ</mi>
<mo>⋅</mo>
<mi>x</mi>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mrow>
<mi>τ</mi>
<mo>⋅</mo>
<mi>x</mi>
</mrow>
<mo>+</mo>
<mi>x</mi>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mi>a</mi>
<mo>⋅</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mi>τ</mi>
<mo>⋅</mo>
<mi>x</mi>
</mrow>
<mo>+</mo>
<mi>y</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mrow>
<mi>a</mi>
<mo>⋅</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mi>τ</mi>
<mo>⋅</mo>
<mi>x</mi>
</mrow>
<mo>+</mo>
<mi>y</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<mi>a</mi>
<mo>⋅</mo>
<mi>x</mi>
</mrow>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mi>τ</mi>
<mo>⋅</mo>
<mi>x</mi>
<mo stretchy="false">|</mo>
<mrow>
<mo stretchy="false">⌊</mo>
<mi>y</mi>
</mrow>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mi>τ</mi>
<mo>⋅</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">|</mo>
<mo stretchy="false">|</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mi>τ</mi>
<mo stretchy="false">|</mo>
<mrow>
<mo stretchy="false">⌊</mo>
<mi>x</mi>
</mrow>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mi>τ</mi>
<mo>⋅</mo>
<mi>x</mi>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mi>τ</mi>
<mo stretchy="false">|</mo>
<mi>x</mi>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mi>δ</mi>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mi>x</mi>
<mo stretchy="false">|</mo>
<mi>τ</mi>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mi>δ</mi>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mi>τ</mi>
<mo>⋅</mo>
<mi>x</mi>
<mo stretchy="false">|</mo>
<mi>y</mi>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mi>x</mi>
<mo stretchy="false">|</mo>
<mi>y</mi>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="center">
<mrow>
<mi>x</mi>
<mo stretchy="false">|</mo>
<mi>τ</mi>
<mo>⋅</mo>
<mi>y</mi>
</mrow>
</mtd>
<mtd columnalign="center">
<mo>=</mo>
</mtd>
<mtd columnalign="center">
<mrow>
<mi>x</mi>
<mo stretchy="false">|</mo>
<mi>y</mi>
</mrow>
</mtd>
</mtr>
</mtable>
<annotation-xml encoding="MathML-Content">
<matrix>
<matrixrow>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>τ</ci>
<ci>I</ci>
</apply>
<ci>τ</ci>
</apply>
<eq></eq>
<ci>τ</ci>
</matrixrow>
<matrixrow>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>τ</ci>
<ci>I</ci>
</apply>
<ci>a</ci>
</apply>
<eq></eq>
<apply>
<notin></notin>
<apply>
<times></times>
<ci>a</ci>
<mtext>if</mtext>
<ci>a</ci>
</apply>
<ci>I</ci>
</apply>
</matrixrow>
<matrixrow>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>τ</ci>
<ci>I</ci>
</apply>
<ci>a</ci>
</apply>
<eq></eq>
<apply>
<in></in>
<apply>
<times></times>
<ci>τ</ci>
<mtext>if</mtext>
<ci>a</ci>
</apply>
<ci>I</ci>
</apply>
</matrixrow>
<matrixrow>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>τ</ci>
<ci>I</ci>
</apply>
<apply>
<plus></plus>
<ci>x</ci>
<ci>y</ci>
</apply>
</apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>τ</ci>
<ci>I</ci>
</apply>
<ci>x</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>τ</ci>
<ci>I</ci>
</apply>
<ci>y</ci>
</apply>
</apply>
</matrixrow>
<matrixrow>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>τ</ci>
<ci>I</ci>
</apply>
<apply>
<ci>normal-⋅</ci>
<ci>x</ci>
<ci>y</ci>
</apply>
</apply>
<eq></eq>
<apply>
<times></times>
<apply>
<ci>normal-⋅</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>τ</ci>
<ci>I</ci>
</apply>
<ci>x</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>τ</ci>
<ci>I</ci>
</apply>
</apply>
<ci>y</ci>
</apply>
</matrixrow>
<matrixrow>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<partialdiff></partialdiff>
<ci>H</ci>
</apply>
<ci>τ</ci>
</apply>
<eq></eq>
<ci>τ</ci>
</matrixrow>
<matrixrow>
<apply>
<ci>normal-⋅</ci>
<ci>x</ci>
<ci>τ</ci>
</apply>
<eq></eq>
<ci>x</ci>
</matrixrow>
<matrixrow>
<apply>
<ci>normal-⋅</ci>
<ci>τ</ci>
<ci>x</ci>
</apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<ci>normal-⋅</ci>
<ci>τ</ci>
<ci>x</ci>
</apply>
<ci>x</ci>
</apply>
</matrixrow>
<matrixrow>
<apply>
<ci>normal-⋅</ci>
<ci>a</ci>
<apply>
<plus></plus>
<apply>
<ci>normal-⋅</ci>
<ci>τ</ci>
<ci>x</ci>
</apply>
<ci>y</ci>
</apply>
</apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<ci>normal-⋅</ci>
<ci>a</ci>
<apply>
<plus></plus>
<apply>
<ci>normal-⋅</ci>
<ci>τ</ci>
<ci>x</ci>
</apply>
<ci>y</ci>
</apply>
</apply>
<apply>
<ci>normal-⋅</ci>
<ci>a</ci>
<ci>x</ci>
</apply>
</apply>
</matrixrow>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">τ</csymbol>
<ci>normal-⋅</ci>
<csymbol cd="unknown">x</csymbol>
<ci>normal-|</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-⌊</ci>
<csymbol cd="unknown">y</csymbol>
</cerror>
</cerror>
<eq></eq>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">τ</csymbol>
<ci>normal-⋅</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">x</csymbol>
<ci>normal-|</ci>
<ci>normal-|</ci>
<csymbol cd="unknown">y</csymbol>
<ci>normal-)</ci>
</cerror>
</cerror>
</matrixrow>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">τ</csymbol>
<ci>normal-|</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-⌊</ci>
<csymbol cd="unknown">x</csymbol>
</cerror>
</cerror>
<eq></eq>
<apply>
<ci>normal-⋅</ci>
<ci>τ</ci>
<ci>x</ci>
</apply>
</matrixrow>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">τ</csymbol>
<ci>normal-|</ci>
<csymbol cd="unknown">x</csymbol>
</cerror>
<eq></eq>
<ci>δ</ci>
</matrixrow>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">x</csymbol>
<ci>normal-|</ci>
<csymbol cd="unknown">τ</csymbol>
</cerror>
<eq></eq>
<ci>δ</ci>
</matrixrow>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">τ</csymbol>
<ci>normal-⋅</ci>
<csymbol cd="unknown">x</csymbol>
<ci>normal-|</ci>
<csymbol cd="unknown">y</csymbol>
</cerror>
<eq></eq>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">x</csymbol>
<ci>normal-|</ci>
<csymbol cd="unknown">y</csymbol>
</cerror>
</matrixrow>
<matrixrow>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">x</csymbol>
<ci>normal-|</ci>
<csymbol cd="unknown">τ</csymbol>
<ci>normal-⋅</ci>
<csymbol cd="unknown">y</csymbol>
</cerror>
<eq></eq>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">x</csymbol>
<ci>normal-|</ci>
<csymbol cd="unknown">y</csymbol>
</cerror>
</matrixrow>
</matrix>
</annotation-xml>
<annotation encoding="application/x-tex">
   \begin{matrix}\tau_{I}(\tau)&amp;=&amp;\tau\\
\tau_{I}(a)&amp;=&amp;a;\mbox{ if }a\notin I\\
\tau_{I}(a)&amp;=&amp;\tau\mbox{ if }a\in I\\
\tau_{I}(x+y)&amp;=&amp;\tau_{I}(x)+\tau_{I}(y)\\
\tau_{I}(x\cdot y)&amp;=&amp;\tau_{I}(x)\cdot\tau_{I}(y)\\
\partial_{H}(\tau)&amp;=&amp;\tau\\
x\cdot\tau&amp;=&amp;x;\\
\tau\cdot x&amp;=&amp;\tau\cdot x+x\\
a\cdot(\tau\cdot x+y)&amp;=&amp;a;\cdot(\tau\cdot x+y)+a\cdot x\\
\tau\cdot x|\lfloor y&amp;=&amp;\tau\cdot(x||y)\\
\tau|\lfloor x&amp;=&amp;\tau\cdot x\\
\tau|x&amp;=&amp;\delta\\
x|\tau&amp;=&amp;\delta\\
\tau\cdot x|y&amp;=&amp;x;|y\\
x|\tau\cdot y&amp;=&amp;x;|y\end{matrix}
  </annotation>
</semantics>
</math>
</p>

<p>Note that the action <em>a</em> in the above list may take the value δ (but of course, δ cannot belong to the abstraction set <em>I</em>).</p>
<h2 id="related-formalisms">Related formalisms</h2>

<p>ACP has served as the basis or inspiration for several other formalisms that can be used to describe and analyze concurrent systems, including:</p>
<ul>
<li><a href="http://staff.science.uva.nl/~psf/">PSF</a></li>
</ul>
<ul>
<li><a href="http://homepages.cwi.nl/~mcrl/">μCRL</a></li>
</ul>
<ul>
<li><a class="uri" href="mCRL2" title="wikilink">mCRL2</a></li>
</ul>
<ul>
<li><a href="Hybrid_Process_Algebra" title="wikilink">HyPA</a> — a process algebra for hybrid systems</li>
</ul>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">J.C.M. Baeten, <a href="http://alexandria.tue.nl/extra1/wskrap/publichtml/200402.pdf"><em>A brief history of process algebra</em></a>, Rapport CSR 04-02, Vakgroep Informatica, Technische Universiteit Eindhoven, 2004<a href="#fnref1">↩</a></li>
<li id="fn2">Bas Luttik, <a href="http://www.win.tue.nl/~luttik/Papers/AlgProc_essay.pdf"><em>What is algebraic in process theory</em></a>, <a href="http://www.cs.auc.dk/~luca/BICI/PA-05/">Algebraic Process Calculi: The First Twenty Five Years and Beyond</a>, Bertinoro, Italy, August 1, 2005<a href="#fnref2">↩</a></li>
<li id="fn3">J.A. Bergstra and J.W. Klop, <a href="http://www.cs.vu.nl/~jwk/ACPL-TAU.PDF"><em>ACP<sub>τ</sub>: A Universal Axiom System for Process Specification</em></a>, CWI Quarterly 15, pp. 3-23, 1987<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
</ol>
</section>
</hr></body>
</html>
