<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1540">Bubble sort</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Bubble sort</h1>
<hr/>

<p><strong>Bubble sort</strong>, sometimes referred to as <strong>sinking sort</strong>, is a simple <a href="sorting_algorithm" title="wikilink">sorting algorithm</a> that repeatedly steps through the list to be sorted, compares each pair of adjacent items and <a href="Swap_(computer_science)" title="wikilink">swaps</a> them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. The algorithm, which is a <a href="comparison_sort" title="wikilink">comparison sort</a>, is named for the way smaller elements "bubble" to the top of the list. Although the algorithm is simple, it is too slow and impractical for most problems even when compared to <a href="insertion_sort" title="wikilink">insertion sort</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It can be practical if the input is usually in sort order but may occasionally have some out-of-order elements nearly in position.</p>
<h2 id="analysis">Analysis</h2>
<figure><b>(Figure)</b>
<figcaption>An example of bubble sort. Starting from the beginning of the list, compare every adjacent pair, swap their position if they are not in the right order (the latter one is smaller than the former one). After each <a class="uri" href="iteration" title="wikilink">iteration</a>, one less element (the last one) is needed to be compared until there are no more elements left to be compared.</figcaption>
</figure>
<h3 id="performance">Performance</h3>

<p>Bubble sort has worst-case and average complexity both <em><a href="big_o_notation" title="wikilink">О</a></em>(<em>n</em><sup>2</sup>), where <em>n</em> is the number of items being sorted. There exist many sorting algorithms with substantially better worst-case or average complexity of <em>O</em>(<em>n</em> log <em>n</em>). Even other <em>О</em>(<em>n</em><sup>2</sup>) sorting algorithms, such as <a href="insertion_sort" title="wikilink">insertion sort</a>, tend to have better performance than bubble sort. Therefore, bubble sort is not a practical sorting algorithm when <em>n</em> is large.</p>

<p>The only significant advantage that bubble sort has over most other implementations, even <a class="uri" href="quicksort" title="wikilink">quicksort</a>, but not <a href="insertion_sort" title="wikilink">insertion sort</a>, is that the ability to detect that the list is sorted is efficiently built into the algorithm. When the list is already sorted (best-case), the complexity of bubble sort is only <em>O</em>(<em>n</em>). By contrast, most other algorithms, even those with better <a href="average-case_complexity" title="wikilink">average-case complexity</a>, perform their entire sorting process on the set and thus are more complex. However, not only does <a href="insertion_sort" title="wikilink">insertion sort</a> have this mechanism too, but it also performs better on a list that is substantially sorted (having a small number of <a href="inversion_(discrete_mathematics)" title="wikilink">inversions</a>).</p>

<p>Bubble sort should be avoided in the case of large collections. It will not be efficient in the case of a reverse-ordered collection.</p>
<h3 id="rabbits-and-turtles">Rabbits and turtles</h3>

<p>The positions of the elements in bubble sort will play a large part in determining its performance. Large elements at the beginning of the list do not pose a problem, as they are quickly swapped. Small elements towards the end, however, move to the beginning extremely slowly. This has led to these types of elements being named rabbits and turtles, respectively.</p>

<p>Various efforts have been made to eliminate turtles to improve upon the speed of bubble sort. <a href="Cocktail_sort" title="wikilink">Cocktail sort</a> is a bi-directional bubble sort that goes from beginning to end, and then reverses itself, going end to beginning. It can move turtles fairly well, but it retains <em><a href="Big_O_notation" title="wikilink">O(n<sup>2</sup>)</a></em> worst-case complexity. <a href="Comb_sort" title="wikilink">Comb sort</a> compares elements separated by large gaps, and can move turtles extremely quickly before proceeding to smaller and smaller gaps to smooth out the list. Its average speed is comparable to faster algorithms like <a class="uri" href="quicksort" title="wikilink">quicksort</a>.</p>
<h3 id="step-by-step-example">Step-by-step example</h3>

<p>Let us take the array of numbers "5 1 4 2 8", and sort the array from lowest number to greatest number using bubble sort. In each step, elements written in <strong>bold</strong> are being compared. Three passes will be required.</p>

<p><strong>First Pass:</strong><br/>
( <strong>5</strong> <strong>1</strong> 4 2 8 ) 

<math display="inline" id="Bubble_sort:0">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>

 ( <strong>1</strong> <strong>5</strong> 4 2 8 ), Here, algorithm compares the first two elements, and swaps since 5 &gt; 1.<br/>
( 1 <strong>5</strong> <strong>4</strong> 2 8 ) 

<math display="inline" id="Bubble_sort:1">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>

 ( 1 <strong>4</strong> <strong>5</strong> 2 8 ), Swap since 5 &gt; 4<br/>
( 1 4 <strong>5</strong> <strong>2</strong> 8 ) 

<math display="inline" id="Bubble_sort:2">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>

 ( 1 4 <strong>2</strong> <strong>5</strong> 8 ), Swap since 5 &gt; 2<br/>
( 1 4 2 <strong>5</strong> <strong>8</strong> ) 

<math display="inline" id="Bubble_sort:3">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>

 ( 1 4 2 <strong>5</strong> <strong>8</strong> ), Now, since these elements are already in order (8 &gt; 5), algorithm does not swap them.<br/>
<strong>Second Pass:</strong><br/>
( <strong>1</strong> <strong>4</strong> 2 5 8 ) 

<math display="inline" id="Bubble_sort:4">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>

 ( <strong>1</strong> <strong>4</strong> 2 5 8 )<br/>
( 1 <strong>4</strong> <strong>2</strong> 5 8 ) 

<math display="inline" id="Bubble_sort:5">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>

 ( 1 <strong>2</strong> <strong>4</strong> 5 8 ), Swap since 4 &gt; 2<br/>
( 1 2 <strong>4</strong> <strong>5</strong> 8 ) 

<math display="inline" id="Bubble_sort:6">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>

 ( 1 2 <strong>4</strong> <strong>5</strong> 8 )<br/>
( 1 2 4 <strong>5</strong> <strong>8</strong> ) 

<math display="inline" id="Bubble_sort:7">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>

 ( 1 2 4 <strong>5</strong> <strong>8</strong> )<br/>
Now, the array is already sorted, but the algorithm does not know if it is completed. The algorithm needs one <strong>whole</strong> pass without <strong>any</strong> swap to know it is sorted.<br/>
<strong>Third Pass:</strong><br/>
( <strong>1</strong> <strong>2</strong> 4 5 8 ) 

<math display="inline" id="Bubble_sort:8">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>

 ( <strong>1</strong> <strong>2</strong> 4 5 8 )<br/>
( 1 <strong>2</strong> <strong>4</strong> 5 8 ) 

<math display="inline" id="Bubble_sort:9">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>

 ( 1 <strong>2</strong> <strong>4</strong> 5 8 )<br/>
( 1 2 <strong>4</strong> <strong>5</strong> 8 ) 

<math display="inline" id="Bubble_sort:10">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>

 ( 1 2 <strong>4</strong> <strong>5</strong> 8 )<br/>
( 1 2 4 <strong>5</strong> <strong>8</strong> ) 

<math display="inline" id="Bubble_sort:11">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>

 ( 1 2 4 <strong>5</strong> <strong>8</strong> )<br/>
</p>
<h2 id="implementation">Implementation</h2>
<h3 id="pseudocode-implementation">Pseudocode implementation</h3>

<p>The algorithm can be expressed as (0-based array):</p>
<pre class="pli"><code>procedure bubbleSort( A : list of sortable items )
   n = length(A)
   repeat 
     swapped = false
     for i = 1 to n-1 inclusive do
       /* if this pair is out of order */
       if A[i-1] &gt; A[i] then
         /* swap them and remember something changed */
         swap( A[i-1], A[i] )
         swapped = true
       end if
     end for
   until not swapped
end procedure</code></pre>
<h3 id="optimizing-bubble-sort">Optimizing bubble sort</h3>

<p>The bubble sort algorithm can be easily optimized by observing that the n-th pass finds the n-th largest element and puts it into its final place. So, the inner loop can avoid looking at the last n-1 items when running for the n-th time:</p>
<pre class="pli"><code>procedure bubbleSort( A : list of sortable items )
    n = length(A)
    repeat
       swapped = false
       for i = 1 to n-1 inclusive do
          if A[i-1] &gt; A[i] then
             swap(A[i-1], A[i])
             swapped = true
          end if
       end for
       n = n - 1
    until not swapped
end procedure</code></pre>

<p>More generally, it can happen that more than one element is placed in their final position on a single pass. In particular, after every pass, all elements after the last swap are sorted, and do not need to be checked again. This allows us to skip over a lot of the elements, resulting in about a worst case 50% improvement in comparison count (though no improvement in swap counts), and adds very little complexity because the new code subsumes the "swapped" variable:</p>

<p>To accomplish this in <a class="uri" href="pseudocode" title="wikilink">pseudocode</a> we write the following:</p>
<pre class="pli"><code>procedure bubbleSort( A : list of sortable items )
    n = length(A)
    repeat
       newn = 0
       for i = 1 to n-1 inclusive do
          if A[i-1] &gt; A[i] then
             swap(A[i-1], A[i])
             newn = i
          end if
       end for
       n = newn
    until n = 0
end procedure</code></pre>

<p>Alternate modifications, such as the <a href="cocktail_shaker_sort" title="wikilink">cocktail shaker sort</a> attempt to improve on the bubble sort performance while keeping the same idea of repeatedly comparing and swapping adjacent items.</p>
<h2 id="in-practice">In practice</h2>

<p> Although bubble sort is one of the simplest sorting algorithms to understand and implement, its <em><a href="Big_O_notation" title="wikilink">O(n<sup>2</sup>)</a></em> complexity means that its efficiency decreases dramatically on lists of more than a small number of elements. Even among simple <em>O(n<sup>2</sup>)</em> sorting algorithms, algorithms like insertion sort are usually considerably more efficient.</p>

<p>Due to its simplicity, bubble sort is often used to introduce the concept of an algorithm, or a sorting algorithm, to introductory <a href="computer_science" title="wikilink">computer science</a> students. However, some researchers such as <a href="Owen_Astrachan" title="wikilink">Owen Astrachan</a> have gone to great lengths to disparage bubble sort and its continued popularity in computer science education, recommending that it no longer even be taught.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>The <a href="Jargon_File" title="wikilink">Jargon File</a>, which famously calls <a class="uri" href="bogosort" title="wikilink">bogosort</a> "the archetypical [sic] perversely awful algorithm", also calls bubble sort "the generic <strong>bad</strong> algorithm".<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a href="Donald_Knuth" title="wikilink">Donald Knuth</a>, in his famous book <em><a href="The_Art_of_Computer_Programming" title="wikilink">The Art of Computer Programming</a></em>, concluded that "the bubble sort seems to have nothing to recommend it, except a catchy name and the fact that it leads to some interesting theoretical problems", some of which he then discusses.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Bubble sort is <a href="Big_O_notation" title="wikilink">asymptotically</a> equivalent in running time to insertion sort in the worst case, but the two algorithms differ greatly in the number of swaps necessary. Experimental results such as those of Astrachan have also shown that insertion sort performs considerably better even on random lists. For these reasons many modern algorithm textbooks avoid using the bubble sort algorithm in favor of insertion sort.</p>

<p>Bubble sort also interacts poorly with modern CPU hardware. It requires at least twice as many writes as insertion sort, twice as many cache misses, and asymptotically more <a href="Branch_predictor" title="wikilink">branch mispredictions</a>. Experiments by Astrachan sorting strings in Java show bubble sort to be roughly one-fifth as fast as an insertion sort and 70% as fast as a <a href="selection_sort" title="wikilink">selection sort</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>In computer graphics it is popular for its capability to detect a very small error (like swap of just two elements) in almost-sorted arrays and fix it with just linear complexity (2n). For example, it is used in a polygon filling algorithm, where bounding lines are sorted by their x coordinate at a specific scan line (a line parallel to x axis) and with incrementing y their order changes (two elements are swapped) only at intersections of two lines. Bubble sort is a stable sort algorithm, like insertion sort.</p>
<h2 id="variations">Variations</h2>
<ul>
<li><a href="Odd-even_sort" title="wikilink">Odd-even sort</a> is a parallel version of bubble sort, for message passing systems.</li>
<li><a href="Cocktail_sort" title="wikilink">Cocktail sort</a> is another parallel version of the bubble sort</li>
<li>In some cases, the sort works from right to left (the opposite direction), which is more appropriate for partially sorted lists, or lists with unsorted items added to the end.</li>
</ul>
<h2 id="debate-over-name">Debate over name</h2>

<p>Bubble sort has been occasionally referred to as a "sinking sort".<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>For example, in Donald Knuth's <em>The Art of Computer Programming</em>, Volume 3: <em>Sorting and Searching</em> he states in section 5.2.1 'Sorting by Insertion', that [the value] "settles to its proper level" this method of sorting has often been called the <em>sifting</em> or <em>sinking</em> technique. Furthermore the <em>larger</em> values might be regarded as <em>heavier</em> and therefore be seen to progressively <em>sink</em> to the <em>bottom</em> of the list.</p>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li><a href="Thomas_H._Cormen" title="wikilink">Thomas H. Cormen</a>, <a href="Charles_E._Leiserson" title="wikilink">Charles E. Leiserson</a>, <a href="Ronald_L._Rivest" title="wikilink">Ronald L. Rivest</a>, and <a href="Clifford_Stein" title="wikilink">Clifford Stein</a>. <em><a href="Introduction_to_Algorithms" title="wikilink">Introduction to Algorithms</a></em>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Problem 2-2, pg.40.</li>
<li><a href="https://www.cs.tcd.ie/publications/tech-reports/reports.05/TCD-CS-2005-57.pdf">Sorting in the Presence of Branch Prediction and Caches</a></li>
<li>Fundamentals of Data Structures by Ellis Horowitz, <a href="Sartaj_Sahni" title="wikilink">Sartaj Sahni</a> and Susan Anderson-Freed ISBN 81-7371-605-6</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>

<p>– graphical demonstration and discussion of bubble sort</p></li>
<li>

<p>(Java applet animation)</p></li>
<li>

<p>Table (statistics) of the number of permutations of [n] that need k pair-swaps during the sorting.</p></li>
</ul>

<p><a class="uri" href="no:Sorteringsalgoritme#Boblesortering" title="wikilink">no:Sorteringsalgoritme#Boblesortering</a>"</p>

<p><a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a> <a href="Category:Sorting_algorithms" title="wikilink">Category:Sorting algorithms</a> <a href="Category:Comparison_sorts" title="wikilink">Category:Comparison sorts</a> <a href="Category:Stable_sorts" title="wikilink">Category:Stable sorts</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"><a class="uri" href="http://www.jargon.net/jargonfile/b/bogo-sort.html">http://www.jargon.net/jargonfile/b/bogo-sort.html</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="Donald_Knuth" title="wikilink">Donald Knuth</a>. <em><a href="The_Art_of_Computer_Programming" title="wikilink">The Art of Computer Programming</a></em>, Volume 3: <em>Sorting and Searching</em>, Second Edition. Addison-Wesley, 1998. ISBN 0-201-89685-0. Pages 106–110 of section 5.2.2: Sorting by Exchanging. "[A]lthough the techniques used in the calculations [to analyze the bubble sort] are instructive, the results are disappointing since they tell us that the bubble sort isn't really very good at all. Compared to straight insertion [...], bubble sorting requires a more complicated program and takes about twice as long!" (Quote from the first edition, 1973.)<a href="#fnref4">↩</a></li>
<li id="fn5">Owen Astrachan. Bubble Sort: An Archaeological Algorithmic Analysis. SIGCSE 2003 Hannan Akhtar . <a href="http://www.cs.duke.edu/~ola/papers/bubble.pdf">(pdf)</a><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
