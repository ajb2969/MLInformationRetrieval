<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1276">Separation logic</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Separation logic</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, <strong>separation logic</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> is an extension of <a href="Hoare_logic" title="wikilink">Hoare logic</a>, a way of reasoning about programs. It was developed by <a href="John_C._Reynolds" title="wikilink">John C. Reynolds</a>, <a href="Peter_O'Hearn" title="wikilink">Peter O'Hearn</a>, Samin Ishtiaq and Hongseok Yang,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> drawing upon early work by <a href="Rod_Burstall" title="wikilink">Rod Burstall</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The assertion language of separation logic is a special case of the <a href="logic_of_bunched_implications" title="wikilink">logic of bunched implications</a> (BI).<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>Separation logic facilitates reasoning about:</p>
<ul>
<li>programs that manipulate pointer data structures ‚Äî including <a href="information_hiding" title="wikilink">information hiding</a> in the presence of pointers;</li>
<li><em>"transfer of ownership"</em> (avoidance of semantic frame <a href="axiom" title="wikilink">axioms</a>); and</li>
<li>virtual separation (modular reasoning) between concurrent modules.</li>
</ul>

<p>Separation logic supports the developing field of research described by <a href="Peter_O'Hearn" title="wikilink">Peter O'Hearn</a> and others as <em>local reasoning</em>, whereby specifications and proofs of a program component mention only the portion of memory used by the component, and not the entire global state of the system. Applications include automated <a href="program_verification" title="wikilink">program verification</a> (where an <a class="uri" href="algorithm" title="wikilink">algorithm</a> checks the validity of another algorithm) and automated <a class="uri" href="parallelization" title="wikilink">parallelization</a> of software.</p>
<h2 id="assertions-operators-and-semantics">Assertions: Operators and semantics</h2>

<p>Separation logic assertions describe "states" consisting of a <em>store</em> and a <em>heap</em>, roughly corresponding to the state of <a href="stack-based_memory_allocation" title="wikilink">local (or <em>stack-allocated</em>) variables</a> and <a href="dynamic_memory_allocation" title="wikilink"><em>dynamically-allocated</em> objects</a> in common programming languages such as <a href="C_(programming_language)" title="wikilink">C</a> and <a href="Java_(programming_language)" title="wikilink">Java</a>. A store 

<math display="inline" id="Separation_logic:0">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 is a <a href="function_(mathematics)" title="wikilink">function</a> mapping variables to values. A heap 

<math display="inline" id="Separation_logic:1">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 is a <a href="partial_function" title="wikilink">partial function</a> mapping memory addresses to values. Two heaps 

<math display="inline" id="Separation_logic:2">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Separation_logic:3">
 <semantics>
  <msup>
   <mi>h</mi>
   <mo>‚Ä≤</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>h</ci>
    <ci>normal-‚Ä≤</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h^{\prime}
  </annotation>
 </semantics>
</math>

 are <em>disjoint</em> (denoted 

<math display="inline" id="Separation_logic:4">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <mi>h</mi>
   </mpadded>
   <mo rspace="4.2pt">‚ä•</mo>
   <msup>
    <mi>h</mi>
    <mo>‚Ä≤</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">bottom</csymbol>
    <ci>h</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>h</ci>
     <ci>normal-‚Ä≤</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h\,\bot\,h^{\prime}
  </annotation>
 </semantics>
</math>

) if their domains do not overlap (i.e., if for every memory address 

<math display="inline" id="Separation_logic:5">
 <semantics>
  <mi mathvariant="normal">‚Ñì</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-‚Ñì</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

, at least one of 

<math display="inline" id="Separation_logic:6">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">‚Ñì</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>normal-‚Ñì</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(\ell)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Separation_logic:7">
 <semantics>
  <mrow>
   <msup>
    <mi>h</mi>
    <mo>‚Ä≤</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">‚Ñì</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>h</ci>
     <ci>normal-‚Ä≤</ci>
    </apply>
    <ci>normal-‚Ñì</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h^{\prime}(\ell)
  </annotation>
 </semantics>
</math>

 is undefined).</p>

<p>The logic allows to prove judgements of the form 

<math display="inline" id="Separation_logic:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mo>,</mo>
    <mi>h</mi>
   </mrow>
   <mo>‚äß</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <list>
     <ci>s</ci>
     <ci>h</ci>
    </list>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s,h\models P
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Separation_logic:9">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 is a store, 

<math display="inline" id="Separation_logic:10">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 is a heap, and 

<math display="inline" id="Separation_logic:11">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is an <em>assertion</em> over the given store and heap. Separation logic assertions (denoted as 

<math display="inline" id="Separation_logic:12">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Separation_logic:13">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Separation_logic:14">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

) contain the standard boolean connectives and, in addition, 

<math display="inline" id="Separation_logic:15">
 <semantics>
  <mi>ùêûùê¶ùê©</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêûùê¶ùê©</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{e}\mathbf{m}\mathbf{p}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Separation_logic:16">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>‚Ü¶</mo>
   <msup>
    <mi>e</mi>
    <mo>‚Ä≤</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>e</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <ci>normal-‚Ä≤</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e\mapsto e^{\prime}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Separation_logic:17">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>‚àó</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-‚àó</ci>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\ast Q
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Separation_logic:18">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo rspace="0pt">-</mo>
   <mo rspace="4.2pt">‚àó</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <minus></minus>
    <ci>normal-‚àó</ci>
    <csymbol cd="unknown">Q</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P{-\!\!\ast}\,Q
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Separation_logic:19">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Separation_logic:20">
 <semantics>
  <msup>
   <mi>e</mi>
   <mo>‚Ä≤</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>e</ci>
    <ci>normal-‚Ä≤</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{\prime}
  </annotation>
 </semantics>
</math>

 are expressions.</p>
<ul>
<li>The constant 

<math display="inline" id="Separation_logic:21">
 <semantics>
  <mi>ùêûùê¶ùê©</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêûùê¶ùê©</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{e}\mathbf{m}\mathbf{p}
  </annotation>
 </semantics>
</math>

 asserts that the heap is <em>empty</em>, i.e., 

<math display="inline" id="Separation_logic:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mo>,</mo>
    <mi>h</mi>
   </mrow>
   <mo>‚äß</mo>
   <mi>ùêûùê¶ùê©</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <list>
     <ci>s</ci>
     <ci>h</ci>
    </list>
    <ci>ùêûùê¶ùê©</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s,h\models\mathbf{e}\mathbf{m}\mathbf{p}
  </annotation>
 </semantics>
</math>

 when 

<math display="inline" id="Separation_logic:23">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 is undefined for all addresses.</li>
<li>The binary operator 

<math display="inline" id="Separation_logic:24">
 <semantics>
  <mo>‚Ü¶</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">maps-to</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mapsto
  </annotation>
 </semantics>
</math>

 takes an address and a value and asserts that the heap is defined at exactly one location, mapping the given address to the given value. I.e., 

<math display="inline" id="Separation_logic:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mo>,</mo>
    <mi>h</mi>
   </mrow>
   <mo>‚äß</mo>
   <mi>e</mi>
   <mo>‚Ü¶</mo>
   <msup>
    <mi>e</mi>
    <mo>‚Ä≤</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">models</csymbol>
     <list>
      <ci>s</ci>
      <ci>h</ci>
     </list>
     <ci>e</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <ci>normal-‚Ä≤</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s,h\models e\mapsto e^{\prime}
  </annotation>
 </semantics>
</math>

 when 

<math display="inline" id="Separation_logic:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mrow>
       <mo rspace="0.8pt" stretchy="false">[</mo>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>e</mi>
        <mo rspace="0.8pt" stretchy="false">]</mo>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
      <mi>s</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo rspace="0.8pt" stretchy="false">[</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <msup>
       <mi>e</mi>
       <mo>‚Ä≤</mo>
      </msup>
      <mo rspace="0.8pt" stretchy="false">]</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>s</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>e</ci>
       </apply>
      </apply>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <ci>normal-‚Ä≤</ci>
       </apply>
      </apply>
     </apply>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h([\![e]\!]_{s})=[\![e^{\prime}]\!]_{s}
  </annotation>
 </semantics>
</math>

 (where 

<math display="inline" id="Separation_logic:27">
 <semantics>
  <msub>
   <mrow>
    <mo rspace="0.8pt" stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>e</mi>
     <mo rspace="0.8pt" stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>e</ci>
     </apply>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\![e]\!]_{s}
  </annotation>
 </semantics>
</math>

 denotes the value of expression 

<math display="inline" id="Separation_logic:28">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 evaluated in store 

<math display="inline" id="Separation_logic:29">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

) and 

<math display="inline" id="Separation_logic:30">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 is otherwise undefined.</li>
<li>The binary operator 

<math display="inline" id="Separation_logic:31">
 <semantics>
  <mo>‚àó</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-‚àó</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ast
  </annotation>
 </semantics>
</math>

 (pronounced <em>star</em> or <em>separating conjunction</em>) asserts that the heap can be split into two <em>disjoint</em> parts where its two arguments hold, respectively. I.e., 

<math display="inline" id="Separation_logic:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mo>,</mo>
    <mi>h</mi>
   </mrow>
   <mo>‚äß</mo>
   <mrow>
    <mi>P</mi>
    <mo>‚àó</mo>
    <mi>Q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <list>
     <ci>s</ci>
     <ci>h</ci>
    </list>
    <apply>
     <ci>normal-‚àó</ci>
     <ci>P</ci>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s,h\models P\ast Q
  </annotation>
 </semantics>
</math>

 when there exist 

<math display="inline" id="Separation_logic:33">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>h</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1},h_{2}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Separation_logic:34">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <msub>
     <mi>h</mi>
     <mn>1</mn>
    </msub>
   </mpadded>
   <mo rspace="4.2pt">‚ä•</mo>
   <msub>
    <mi>h</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">bottom</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1}\,\bot\,h_{2}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Separation_logic:35">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>h</mi>
     <mn>1</mn>
    </msub>
    <mo>‚à™</mo>
    <msub>
     <mi>h</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>h</ci>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h=h_{1}\cup h_{2}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Separation_logic:36">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mo>,</mo>
    <msub>
     <mi>h</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>‚äß</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <list>
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s,h_{1}\models P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Separation_logic:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mo>,</mo>
    <msub>
     <mi>h</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>‚äß</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <list>
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <cn type="integer">2</cn>
     </apply>
    </list>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s,h_{2}\models Q
  </annotation>
 </semantics>
</math>

.</li>
<li>The binary operator 

<math display="inline" id="Separation_logic:38">
 <semantics>
  <mrow>
   <mo rspace="0pt">-</mo>
   <mo>‚àó</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <minus></minus>
    <ci>normal-‚àó</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\!\!\ast
  </annotation>
 </semantics>
</math>

 (pronounced <em>magic wand</em> or <em>separating implication</em>) asserts that extending the heap with a disjoint part that satisfies its first argument results in a heap that satisfies its second argument. I.e,. 

<math display="inline" id="Separation_logic:39">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>,</mo>
   <mi>h</mi>
   <mo>‚äß</mo>
   <mi>P</mi>
   <mo rspace="0pt">-</mo>
   <mo rspace="4.2pt">‚àó</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">h</csymbol>
    <csymbol cd="latexml">models</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <minus></minus>
    <ci>normal-‚àó</ci>
    <csymbol cd="unknown">Q</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s,h\models P-\!\!\ast\,Q
  </annotation>
 </semantics>
</math>

 when for every heap 

<math display="inline" id="Separation_logic:40">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <msup>
     <mi>h</mi>
     <mo>‚Ä≤</mo>
    </msup>
   </mpadded>
   <mo rspace="4.2pt">‚ä•</mo>
   <mi>h</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">bottom</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>h</ci>
     <ci>normal-‚Ä≤</ci>
    </apply>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h^{\prime}\,\bot\,h
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Separation_logic:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mo>,</mo>
    <msup>
     <mi>h</mi>
     <mo>‚Ä≤</mo>
    </msup>
   </mrow>
   <mo>‚äß</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <list>
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>h</ci>
      <ci>normal-‚Ä≤</ci>
     </apply>
    </list>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s,h^{\prime}\models P
  </annotation>
 </semantics>
</math>

, also 

<math display="inline" id="Separation_logic:42">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mo>,</mo>
    <mrow>
     <mi>h</mi>
     <mo>‚à™</mo>
     <msup>
      <mi>h</mi>
      <mo>‚Ä≤</mo>
     </msup>
    </mrow>
   </mrow>
   <mo>‚äß</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <list>
     <ci>s</ci>
     <apply>
      <union></union>
      <ci>h</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <ci>normal-‚Ä≤</ci>
      </apply>
     </apply>
    </list>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s,h\cup h^{\prime}\models Q
  </annotation>
 </semantics>
</math>

 holds.</li>
</ul>

<p>The operators 

<math display="inline" id="Separation_logic:43">
 <semantics>
  <mo>‚àó</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-‚àó</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ast
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Separation_logic:44">
 <semantics>
  <mrow>
   <mo rspace="0pt">-</mo>
   <mo>‚àó</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <minus></minus>
    <ci>normal-‚àó</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\!\!\ast
  </annotation>
 </semantics>
</math>

 share some properties with the classical <a href="Logical_Conjunction" title="wikilink">conjunction</a> and <a href="Entailment" title="wikilink">implication</a> operators. They can be combined using an inference rule similar to <a href="modus_ponens" title="wikilink">modus ponens</a></p>

<p>

<math display="block" id="Separation_logic:45">
 <semantics>
  <mfrac>
   <mrow>
    <mi>s</mi>
    <mo>,</mo>
    <mi>h</mi>
    <mo>‚äß</mo>
    <mi>P</mi>
    <mo>‚àó</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>P</mi>
     <mo rspace="0pt">-</mo>
     <mo rspace="4.2pt">‚àó</mo>
     <mi>Q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mi>s</mi>
     <mo>,</mo>
     <mi>h</mi>
    </mrow>
    <mo>‚äß</mo>
    <mi>Q</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">h</csymbol>
     <csymbol cd="latexml">models</csymbol>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-‚àó</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">P</csymbol>
      <minus></minus>
      <ci>normal-‚àó</ci>
      <csymbol cd="unknown">Q</csymbol>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
    <apply>
     <csymbol cd="latexml">models</csymbol>
     <list>
      <ci>s</ci>
      <ci>h</ci>
     </list>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{s,h\models P\ast(P-\!\!\ast\,Q)}{s,h\models Q}
  </annotation>
 </semantics>
</math>

 and they form an <a href="adjunction_(category_theory)" title="wikilink">adjunction</a>, i.e., 

<math display="inline" id="Separation_logic:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mo>,</mo>
    <mrow>
     <mi>h</mi>
     <mo>‚à™</mo>
     <msup>
      <mi>h</mi>
      <mo>‚Ä≤</mo>
     </msup>
    </mrow>
   </mrow>
   <mo>‚äß</mo>
   <mrow>
    <mi>P</mi>
    <mo>‚àó</mo>
    <mi>Q</mi>
   </mrow>
   <mo>‚áí</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">models</csymbol>
     <list>
      <ci>s</ci>
      <apply>
       <union></union>
       <ci>h</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>h</ci>
        <ci>normal-‚Ä≤</ci>
       </apply>
      </apply>
     </list>
     <apply>
      <ci>normal-‚àó</ci>
      <ci>P</ci>
      <ci>Q</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-‚áí</ci>
     <share href="#.cmml">
     </share>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s,h\cup h^{\prime}\models P\ast Q\Rightarrow R
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Separation_logic:47">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>,</mo>
   <mi>h</mi>
   <mo>‚äß</mo>
   <mi>P</mi>
   <mo>‚áí</mo>
   <mi>Q</mi>
   <mo rspace="0pt">-</mo>
   <mo rspace="4.2pt">‚àó</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">h</csymbol>
    <csymbol cd="latexml">models</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-‚áí</ci>
    <csymbol cd="unknown">Q</csymbol>
    <minus></minus>
    <ci>normal-‚àó</ci>
    <csymbol cd="unknown">R</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s,h\models P\Rightarrow Q-\!\!\ast\,R
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Separation_logic:48">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <mi>h</mi>
   </mpadded>
   <mo rspace="4.2pt">‚ä•</mo>
   <msup>
    <mi>h</mi>
    <mo>‚Ä≤</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">bottom</csymbol>
    <ci>h</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>h</ci>
     <ci>normal-‚Ä≤</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h\,\bot\,h^{\prime}
  </annotation>
 </semantics>
</math>

; more precisely, the adjoint operators are 

<math display="inline" id="Separation_logic:49">
 <semantics>
  <mrow>
   <mi mathvariant="normal">_</mi>
   <mo>‚àó</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-‚àó</ci>
    <ci>normal-_</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \_\ast Q
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Separation_logic:50">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo rspace="0pt">-</mo>
   <mo rspace="4.2pt">‚àó</mo>
   <mi mathvariant="normal">_</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Q</csymbol>
    <minus></minus>
    <ci>normal-‚àó</ci>
    <csymbol cd="unknown">_</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q-\!\!\ast\,\_
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="reasoning-about-programs-triples-and-proof-rules">Reasoning about programs: triples and proof rules</h2>

<p>In separation logic, Hoare triples have a slightly different meaning than in <a href="Hoare_logic" title="wikilink">Hoare logic</a>. The triple 

<math display="inline" id="Separation_logic:51">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>P</mi>
    <mo rspace="7.5pt" stretchy="false">}</mo>
   </mrow>
   <mpadded width="+5pt">
    <mi>C</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>Q</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <set>
     <ci>P</ci>
    </set>
    <ci>C</ci>
    <set>
     <ci>Q</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{P\}\ C\ \{Q\}
  </annotation>
 </semantics>
</math>

 asserts that if the program, 

<math display="inline" id="Separation_logic:52">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

, executes from an initial state satisfying the precondition, 

<math display="inline" id="Separation_logic:53">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, then the program will <em>not go wrong</em> (e.g., have undefined behaviour), and if it terminates, then the final state will satisfy the postcondition, 

<math display="inline" id="Separation_logic:54">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

. In essence, during its execution, 

<math display="inline" id="Separation_logic:55">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 may access only memory locations whose existence is asserted in the precondition or that have been allocated by 

<math display="inline" id="Separation_logic:56">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 itself.</p>

<p>In addition to the standard rules from <a href="Hoare_logic" title="wikilink">Hoare logic</a>, separation logic supports the following very important rule:</p>

<p>

<math display="inline" id="Separation_logic:57">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+3.3pt">
      <mfrac>
       <mrow>
        <mrow>
         <mo stretchy="false">{</mo>
         <mi>P</mi>
         <mo rspace="7.5pt" stretchy="false">}</mo>
        </mrow>
        <mpadded width="+5pt">
         <mi>C</mi>
        </mpadded>
        <mrow>
         <mo stretchy="false">{</mo>
         <mi>Q</mi>
         <mo stretchy="false">}</mo>
        </mrow>
       </mrow>
       <mrow>
        <mrow>
         <mo stretchy="false">{</mo>
         <mrow>
          <mi>P</mi>
          <mo>‚àó</mo>
          <mi>R</mi>
         </mrow>
         <mo rspace="7.5pt" stretchy="false">}</mo>
        </mrow>
        <mpadded width="+5pt">
         <mi>C</mi>
        </mpadded>
        <mrow>
         <mo stretchy="false">{</mo>
         <mrow>
          <mi>Q</mi>
          <mo>‚àó</mo>
          <mi>R</mi>
         </mrow>
         <mo stretchy="false">}</mo>
        </mrow>
       </mrow>
      </mfrac>
     </mpadded>
     <mi>ùóÜùóàùñΩ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>C</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>‚à©</mo>
    <mrow>
     <mi>ùñøùóè</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>R</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">‚àÖ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <intersect></intersect>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <set>
         <ci>P</ci>
        </set>
        <ci>C</ci>
        <set>
         <ci>Q</ci>
        </set>
       </apply>
       <apply>
        <times></times>
        <set>
         <apply>
          <ci>normal-‚àó</ci>
          <ci>P</ci>
          <ci>R</ci>
         </apply>
        </set>
        <ci>C</ci>
        <set>
         <apply>
          <ci>normal-‚àó</ci>
          <ci>Q</ci>
          <ci>R</ci>
         </apply>
        </set>
       </apply>
      </apply>
      <ci>ùóÜùóàùñΩ</ci>
      <ci>C</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ùñøùóè</ci>
      <ci>R</ci>
     </apply>
    </apply>
    <emptyset></emptyset>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\{P\}\ C\ \{Q\}}{\{P\ast R\}\ C\ \{Q\ast R\}}~{}\mathsf{mod}(C)\cap%
\mathsf{fv}(R)=\emptyset
  </annotation>
 </semantics>
</math>

</p>

<p>This is known as the <strong>frame rule</strong> (named after the <a href="frame_problem" title="wikilink">frame problem</a>) and enables local reasoning. It says that a program that executes safely in a small state (satisfying 

<math display="inline" id="Separation_logic:58">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

), can also execute in any bigger state (satisfying 

<math display="inline" id="Separation_logic:59">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>‚àó</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-‚àó</ci>
    <ci>P</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\ast R
  </annotation>
 </semantics>
</math>

) and that its execution will not affect the additional part of the state (and so 

<math display="inline" id="Separation_logic:60">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 will remain true in the postcondition). The side condition enforces this by specifying that none of the variables modified by 

<math display="inline" id="Separation_logic:61">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 occur free in 

<math display="inline" id="Separation_logic:62">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

, i.e. none of them are in the 'free variable' set 

<math display="inline" id="Separation_logic:63">
 <semantics>
  <mi>ùñøùóè</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùñøùóè</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathsf{fv}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Separation_logic:64">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="implementations">Implementations</h2>

<p>The <a class="uri" href="Ynot" title="wikilink">Ynot</a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> library for the <a href="Coq_proof_assistant" title="wikilink">Coq proof assistant</a> contains an implementation.</p>

<p>The Infer<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> tool for static analysis of Java, C, and Objective-C is based on separation logic and bi-abduction as its foundation.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Program_logic" title="wikilink">Category:Program logic</a> <a href="Category:Substructural_logic" title="wikilink">Category:Substructural logic</a> <a href="Category:Logic_in_computer_science" title="wikilink">Category:Logic in computer science</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.cs.cmu.edu/~jcr/seplogic.pdf">Separation Logic: A Logic for Shared Mutable Data Structures.</a> John C. Reynolds. LICS 2002.<a href="#fnref1">‚Ü©</a></li>
<li id="fn2"></li>
<li id="fn3">Intuitionistic Reasoning about Shared Mutable Data Structure. John Reynolds. Millennial Perspectives in Computer Science, Proceedings of the 1999 Oxford-Microsoft Symposium in Honour of Sir Tony Hoare<a href="#fnref3">‚Ü©</a></li>
<li id="fn4">BI as an Assertion Language for Mutable Data Structures. Samin Ishtiaq, Peter O'Hearn. POPL 2001.<a href="#fnref4">‚Ü©</a></li>
<li id="fn5"><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.29.1331">Local Reasoning about Programs that Alter Data Structures.</a> Peter O'Hearn, John Reynolds, Hongseok Yang. CSL 2001<a href="#fnref5">‚Ü©</a></li>
<li id="fn6">Some techniques for proving programs which alter data structures. R.M. Burstall. Machine Intelligence 7, 1972.<a href="#fnref6">‚Ü©</a></li>
<li id="fn7">The Logic of Bunched Implications P.W. O'Hearn and D. J. Pym. Bulletin of Symbolic Logic , 5(2), June 1999, pp215-244<a href="#fnref7">‚Ü©</a></li>
<li id="fn8"><a href="http://ynot.cs.harvard.edu/">The Ynot Project homepage</a><a href="#fnref8">‚Ü©</a></li>
<li id="fn9"><a href="https://github.com/facebook/infer">The Infer project page on Github</a><a href="#fnref9">‚Ü©</a></li>
<li id="fn10"><a href="http://fbinfer.com/docs/separation-logic-and-bi-abduction.html">Separation logic and bi-abduction, page on Infer project site</a><a href="#fnref10">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
