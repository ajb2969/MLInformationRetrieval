<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="111">Modulo-N code</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Modulo-N code</h1>
<hr/>

<p><strong>Modulo-N code</strong> is a <a href="lossy_compression" title="wikilink">lossy compression</a> algorithm used to compress <a class="uri" href="correlated" title="wikilink">correlated</a> data sources using <a href="modulo_arithmetic" title="wikilink">modulo arithmetic</a>.</p>
<h2 id="compression">Compression</h2>

<p>When applied to two nodes in a <a href="computer_networking" title="wikilink">network</a> whose data are in close range of each other Modulo-N code requires one node (say odd) to send the coded data value as the raw data 

<math display="inline" id="Modulo-N_code:0">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mi>o</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>D</mi>
    <mi>o</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>o</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>o</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{o}=D_{o}
  </annotation>
 </semantics>
</math>

; the even node is required to send the coded data as the 

<math display="inline" id="Modulo-N_code:1">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mi>e</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>D</mi>
      <mi>e</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>m</mi>
    <mi>o</mi>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>e</ci>
     </apply>
     <ci>m</ci>
     <ci>o</ci>
     <ci>d</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{e}=(D_{e})mod(N)
  </annotation>
 </semantics>
</math>

. Hence the name Modulo-N code.</p>

<p>Since it is known that for a number K, at least 

<math display="inline" id="Modulo-N_code:2">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>o</mi>
   <msub>
    <mi>g</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>K</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>o</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   log_{2}(K)
  </annotation>
 </semantics>
</math>

 bits are required to represent it in binary. So the modulo coded data of the two nodes requires totally 

<math display="inline" id="Modulo-N_code:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>l</mi>
    <mi>o</mi>
    <msub>
     <mi>g</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>M</mi>
      <mi>o</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>l</mi>
    <mi>o</mi>
    <msub>
     <mi>g</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>M</mi>
      <mi>e</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>o</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   log_{2}(M_{o})+log_{2}(M_{e})
  </annotation>
 </semantics>
</math>


. As we can generally expect 

<math display="inline" id="Modulo-N_code:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>l</mi>
    <mi>o</mi>
    <msub>
     <mi>g</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>M</mi>
      <mi>e</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>l</mi>
    <mi>o</mi>
    <msub>
     <mi>g</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>M</mi>
      <mi>o</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>e</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>o</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   log_{2}(M_{e})\leq log_{2}(M_{o})
  </annotation>
 </semantics>
</math>

 always, because 

<math display="inline" id="Modulo-N_code:5">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mi>e</mi>
   </msub>
   <mo>≤</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>e</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{e}\leq N
  </annotation>
 </semantics>
</math>

. This is the how compression is achieved.</p>

<p>A compression ratio achieved is 

<math display="inline" id="Modulo-N_code:6">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>.</mo>
   <mrow>
    <mi>R</mi>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mi>l</mi>
       <mi>o</mi>
       <msub>
        <mi>g</mi>
        <mn>2</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>M</mi>
         <mi>o</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>l</mi>
       <mi>o</mi>
       <msub>
        <mi>g</mi>
        <mn>2</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>M</mi>
         <mi>e</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mrow>
      <mn>2</mn>
      <mi>l</mi>
      <mi>o</mi>
      <msub>
       <mi>g</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>M</mi>
        <mi>o</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <ci>C</ci>
    <apply>
     <eq></eq>
     <ci>R</ci>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>l</ci>
        <ci>o</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>M</ci>
         <ci>o</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>l</ci>
        <ci>o</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>M</ci>
         <ci>e</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>l</ci>
       <ci>o</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <ci>o</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C.R=\frac{log_{2}(M_{o})+log_{2}(M_{e})}{2log_{2}(M_{o})}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="decompression">Decompression</h2>

<p>At the receiver by joint decoding we may complete the process of extracting the data and rebuilding the original values. The code from the even node is reconstructed by the <em>assumption</em> that it must be close to the data from the odd node. Hence the decoding algorithm retrieves even node data as<br/>


<math display="inline" id="Modulo-N_code:7">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>L</mi>
   <mi>O</mi>
   <mi>S</mi>
   <mi>E</mi>
   <mi>S</mi>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>M</mi>
     <mi>o</mi>
    </msub>
    <mo>,</mo>
    <mi>N</mi>
    <mo>.</mo>
    <mi>k</mi>
    <mo>+</mo>
    <msub>
     <mi>M</mi>
     <mi>e</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <csymbol cd="unknown">L</csymbol>
    <csymbol cd="unknown">O</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <csymbol cd="unknown">T</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>o</ci>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">k</csymbol>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>e</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   CLOSEST(M_{o},N.k+M_{e})
  </annotation>
 </semantics>
</math>

.</p>

<p>The decoder essentially finds the closest match to 

<math display="inline" id="Modulo-N_code:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>M</mi>
     <mi>o</mi>
    </msub>
    <mo>≃</mo>
    <mi>N</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <msub>
     <mi>M</mi>
     <mi>e</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">similar-to-or-equals</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>o</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{o}\simeq N.k+M_{e}
  </annotation>
 </semantics>
</math>


 and the decoded value is declared as 

<math display="inline" id="Modulo-N_code:9">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>.</mo>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <msub>
     <mi>M</mi>
     <mi>e</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <ci>N</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N.k+M_{e}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="example">Example</h2>

<p>For a mod-8 code, we have <em>Encoder</em></p>

<p><code>D_o=43,D_e=47</code><br/>
<code>M_o=43,M_e=47 mod(8) = 7,</code><br/>
</p>

<p><em>Decoder</em></p>

<p><code> M_o=43,M_e=47 mod(8) = 7,</code><br/>
<code> D_o=43,D_e=CLOSEST(43,8.k + 7)</code><br/>
<code> </code>

<math display="inline" id="Modulo-N_code:10">
 <semantics>
  <mrow>
   <mn>43</mn>
   <mo>≃</mo>
   <mrow>
    <mn>8.5</mn>
    <mo>+</mo>
    <mn>7</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to-or-equals</csymbol>
    <cn type="integer">43</cn>
    <apply>
     <plus></plus>
     <cn type="float">8.5</cn>
     <cn type="integer">7</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   43\simeq 8.5+7
  </annotation>
 </semantics>
</math>

<br/>
<code> D_o=43,D_e=47</code></p>

<p>Modulo-N decoding is similar to <a href="phase_unwrapping" title="wikilink">phase unwrapping</a> and has the same limitation: If the difference from one node to the next is more than N/2 (if the phase changes from one sample to the next more than 

<math display="inline" id="Modulo-N_code:11">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

), then decoding leads to an incorrect value.</p>
<h3 id="see-also">See also</h3>
<ul>
<li><a class="uri" href="DISCUS" title="wikilink">DISCUS</a> is a more sophisticated technique for compressing correlated data sources.</li>
<li><a href="Delta_encoding" title="wikilink">Delta encoding</a> is a related algorithm used in lossless compression algorithms designed for correlated data sources.</li>
</ul>

<p>"</p>

<p><a href="Category:Information_theory" title="wikilink">Category:Information theory</a> <a href="Category:Data_compression" title="wikilink">Category:Data compression</a> <a href="Category:Wireless_sensor_network" title="wikilink">Category:Wireless sensor network</a></p>
</body>
</html>
