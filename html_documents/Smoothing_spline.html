<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1119">Smoothing spline</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Smoothing spline</h1>
<hr/>

<p>The <strong>smoothing spline</strong> is a method of <a class="uri" href="smoothing" title="wikilink">smoothing</a> (fitting a <a href="smooth_curve" title="wikilink">smooth curve</a> to a set of noisy <a href="observation" title="wikilink">observations</a>) using a spline function.</p>
<h2 id="definition">Definition</h2>

<p>Let 

<math display="inline" id="Smoothing_spline:0">
<semantics>
<mover accent="true">
<mi>μ</mi>
<mo stretchy="false">^</mo>
</mover>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-^</ci>
<ci>μ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{\mu}
  </annotation>
</semantics>
</math>

. The smoothing spline estimate 

<math display="inline" id="Smoothing_spline:1">
<semantics>
<mi>μ</mi>
<annotation-xml encoding="MathML-Content">
<ci>μ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mu
  </annotation>
</semantics>
</math>

 of the function 

<math display="block" id="Smoothing_spline:2">
<semantics>
<mrow>
<mrow>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mi>n</mi>
</munderover>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>Y</mi>
<mi>i</mi>
</msub>
<mo>-</mo>
<mrow>
<mover accent="true">
<mi>μ</mi>
<mo stretchy="false">^</mo>
</mover>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
</mrow>
<mo>+</mo>
<mrow>
<mi>λ</mi>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∫</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<msub>
<mi>x</mi>
<mi>n</mi>
</msub>
</msubsup>
<mrow>
<msup>
<mover accent="true">
<mi>μ</mi>
<mo stretchy="false">^</mo>
</mover>
<mi>′′</mi>
</msup>
<mpadded width="+1.7pt">
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
</mpadded>
<mi>d</mi>
<mi>x</mi>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<plus></plus>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<ci>i</ci>
</apply>
<apply>
<times></times>
<apply>
<ci>normal-^</ci>
<ci>μ</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<times></times>
<ci>λ</ci>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>n</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ci>normal-^</ci>
<ci>μ</ci>
</apply>
<ci>′′</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
<ci>d</ci>
<ci>x</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sum_{i=1}^{n}(Y_{i}-\hat{\mu}(x_{i}))^{2}+\lambda\int_{x_{1}}^{x_{n}}\hat{\mu%
}^{\prime\prime}(x)^{2}\,dx.
  </annotation>
</semantics>
</math>

 is defined to be the minimizer (over the class of twice differentiable functions) of<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>
<math display="inline" id="Smoothing_spline:3">
<semantics>
<mrow>
<mi>λ</mi>
<mo>≥</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<geq></geq>
<ci>λ</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lambda\geq 0
  </annotation>
</semantics>
</math>
</p>

<p>Remarks:</p>
<ul>
<li>
<math display="inline" id="Smoothing_spline:4">
<semantics>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{i}
  </annotation>
</semantics>
</math>

 is a smoothing parameter, controlling the trade-off between fidelity to the data and roughness of the function estimate.</li>
<li>The integral is evaluated over the range of the 

<math display="inline" id="Smoothing_spline:5">
<semantics>
<mrow>
<mi>λ</mi>
<mo>→</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<ci>λ</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lambda\to 0
  </annotation>
</semantics>
</math>

.</li>
<li>As 

<math display="inline" id="Smoothing_spline:6">
<semantics>
<mrow>
<mi>λ</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-→</ci>
<ci>λ</ci>
<infinity></infinity>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lambda\to\infty
  </annotation>
</semantics>
</math>

 (no smoothing), the smoothing spline converges to the <a href="interpolating_spline" title="wikilink">interpolating spline</a>.</li>
<li>As 

<math display="inline" id="Smoothing_spline:7">
<semantics>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{i}
  </annotation>
</semantics>
</math>

 (infinite smoothing), the roughness penalty becomes paramount and the estimate converges to a <a href="Ordinary_least_squares" title="wikilink">linear least squares</a> estimate.</li>
<li>The roughness penalty based on the <a href="second_derivative" title="wikilink">second derivative</a> is the most common in modern statistics literature, although the method can easily be adapted to penalties based on other derivatives.</li>
<li>In early literature, with equally-spaced 

<math display="inline" id="Smoothing_spline:8">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<mover accent="true">
<mi>μ</mi>
<mo stretchy="false">^</mo>
</mover>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>;</mo>
<mi>i</mi>
</mrow>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mo>,</mo>
<mrow>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<mi>n</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<list>
<apply>
<times></times>
<apply>
<ci>normal-^</ci>
<ci>μ</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</apply>
<ci>i</ci>
</list>
<cn type="integer">1</cn>
</apply>
<list>
<ci>normal-…</ci>
<ci>n</ci>
</list>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{\mu}(x_{i});i=1,\ldots,n
  </annotation>
</semantics>
</math>

, second or third-order differences were used in the penalty, rather than derivatives.</li>
<li>When the sum-of-squares term is replaced by a log-likelihood, the resulting estimate is termed <em>penalized likelihood</em>. The smoothing spline is the special case of penalized likelihood resulting from a Gaussian likelihood.</li>
</ul>
<h2 id="derivation-of-the-smoothing-spline">Derivation of the smoothing spline</h2>

<p>It is useful to think of fitting a smoothing spline in two steps:</p>
<ol>
<li>First, derive the values 

<math display="inline" id="Smoothing_spline:9">
<semantics>
<mrow>
<mover accent="true">
<mi>μ</mi>
<mo stretchy="false">^</mo>
</mover>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<ci>normal-^</ci>
<ci>μ</ci>
</apply>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{\mu}(x)
  </annotation>
</semantics>
</math>

.</li>
<li>From these values, derive 

<math display="inline" id="Smoothing_spline:10">
<semantics>
<mrow>
<mover accent="true">
<mi>m</mi>
<mo stretchy="false">^</mo>
</mover>
<mo>=</mo>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mover accent="true">
<mi>μ</mi>
<mo stretchy="false">^</mo>
</mover>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<mrow>
<mover accent="true">
<mi>μ</mi>
<mo stretchy="false">^</mo>
</mover>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mi>n</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>T</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<ci>normal-^</ci>
<ci>m</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<vector>
<apply>
<times></times>
<apply>
<ci>normal-^</ci>
<ci>μ</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>normal-…</ci>
<apply>
<times></times>
<apply>
<ci>normal-^</ci>
<ci>μ</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>n</ci>
</apply>
</apply>
</vector>
<ci>T</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{m}=(\hat{\mu}(x_{1}),\ldots,\hat{\mu}(x_{n}))^{T}
  </annotation>
</semantics>
</math>

 for all <em>x</em>.</li>
</ol>

<p>Now, treat the second step first.</p>

<p>Given the vector 

<math display="inline" id="Smoothing_spline:11">
<semantics>
<mrow>
<mo largeop="true" symmetric="true">∫</mo>
<mrow>
<msup>
<mover accent="true">
<mi>μ</mi>
<mo stretchy="false">^</mo>
</mover>
<mi>′′</mi>
</msup>
<mpadded width="+1.7pt">
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
</mpadded>
<mi>d</mi>
<mi>x</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<int></int>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ci>normal-^</ci>
<ci>μ</ci>
</apply>
<ci>′′</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
<ci>d</ci>
<ci>x</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \int\hat{\mu}^{\prime\prime}(x)^{2}\,dx
  </annotation>
</semantics>
</math>

 of fitted values, the sum-of-squares part of the spline criterion is fixed. It remains only to minimize 

<math display="inline" id="Smoothing_spline:12">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<mo>,</mo>
<mrow>
<mover accent="true">
<mi>μ</mi>
<mo stretchy="false">^</mo>
</mover>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
<apply>
<times></times>
<apply>
<ci>normal-^</ci>
<ci>μ</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</apply>
</interval>
</annotation-xml>
<annotation encoding="application/x-tex">
   (x_{i},\hat{\mu}(x_{i}))
  </annotation>
</semantics>
</math>

, and the minimizer is a natural cubic <a href="Spline_(mathematics)" title="wikilink">spline</a> that interpolates the points 

<math display="block" id="Smoothing_spline:13">
<semantics>
<mrow>
<mrow>
<mover accent="true">
<mi>μ</mi>
<mo stretchy="false">^</mo>
</mover>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mi>n</mi>
</munderover>
<mrow>
<mover accent="true">
<mi>μ</mi>
<mo stretchy="false">^</mo>
</mover>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<msub>
<mi>f</mi>
<mi>i</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<ci>normal-^</ci>
<ci>μ</ci>
</apply>
<ci>x</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>n</ci>
</apply>
<apply>
<times></times>
<apply>
<ci>normal-^</ci>
<ci>μ</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<ci>i</ci>
</apply>
<ci>x</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{\mu}(x)=\sum_{i=1}^{n}\hat{\mu}(x_{i})f_{i}(x)
  </annotation>
</semantics>
</math>

. This interpolating spline is a linear operator, and can be written in the form</p>

<p>
<math display="inline" id="Smoothing_spline:14">
<semantics>
<mrow>
<msub>
<mi>f</mi>
<mi>i</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<ci>i</ci>
</apply>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f_{i}(x)
  </annotation>
</semantics>
</math>

 where 

<math display="block" id="Smoothing_spline:15">
<semantics>
<mrow>
<mrow>
<mrow>
<mo largeop="true" symmetric="true">∫</mo>
<mrow>
<msup>
<mover accent="true">
<mi>μ</mi>
<mo stretchy="false">^</mo>
</mover>
<mi>′′</mi>
</msup>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
<mi>d</mi>
<mi>x</mi>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msup>
<mover accent="true">
<mi>m</mi>
<mo stretchy="false">^</mo>
</mover>
<mi>T</mi>
</msup>
<mi>A</mi>
<mover accent="true">
<mi>m</mi>
<mo stretchy="false">^</mo>
</mover>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<int></int>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ci>normal-^</ci>
<ci>μ</ci>
</apply>
<ci>′′</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
<ci>d</ci>
<ci>x</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ci>normal-^</ci>
<ci>m</ci>
</apply>
<ci>T</ci>
</apply>
<ci>A</ci>
<apply>
<ci>normal-^</ci>
<ci>m</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \int\hat{\mu}^{\prime\prime}(x)^{2}dx=\hat{m}^{T}A\hat{m}.
  </annotation>
</semantics>
</math>

 are a set of spline basis functions. As a result, the roughness penalty has the form</p>

<p>
<math display="inline" id="Smoothing_spline:16">
<semantics>
<mrow>
<mo largeop="true" symmetric="true">∫</mo>
<mrow>
<msubsup>
<mi>f</mi>
<mi>i</mi>
<mi>′′</mi>
</msubsup>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<msubsup>
<mi>f</mi>
<mi>j</mi>
<mi>′′</mi>
</msubsup>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>d</mi>
<mi>x</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<int></int>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<ci>i</ci>
</apply>
<ci>′′</ci>
</apply>
<ci>x</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<ci>j</ci>
</apply>
<ci>′′</ci>
</apply>
<ci>x</ci>
<ci>d</ci>
<ci>x</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \int f_{i}^{\prime\prime}(x)f_{j}^{\prime\prime}(x)dx
  </annotation>
</semantics>
</math>

 where the elements of <em>A</em> are 

<math display="inline" id="Smoothing_spline:17">
<semantics>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{i}
  </annotation>
</semantics>
</math>

. The basis functions, and hence the matrix <em>A</em>, depend on the configuration of the predictor variables 

<math display="inline" id="Smoothing_spline:18">
<semantics>
<msub>
<mi>Y</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y_{i}
  </annotation>
</semantics>
</math>

, but not on the responses 

<math display="inline" id="Smoothing_spline:19">
<semantics>
<mover accent="true">
<mi>m</mi>
<mo stretchy="false">^</mo>
</mover>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-^</ci>
<ci>m</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{m}
  </annotation>
</semantics>
</math>

 or 

<math display="block" id="Smoothing_spline:20">
<semantics>
<mrow>
<mrow>
<msup>
<mrow>
<mo>∥</mo>
<mrow>
<mi>Y</mi>
<mo>-</mo>
<mover accent="true">
<mi>m</mi>
<mo stretchy="false">^</mo>
</mover>
</mrow>
<mo>∥</mo>
</mrow>
<mn>2</mn>
</msup>
<mo>+</mo>
<mrow>
<mi>λ</mi>
<msup>
<mover accent="true">
<mi>m</mi>
<mo stretchy="false">^</mo>
</mover>
<mi>T</mi>
</msup>
<mi>A</mi>
<mover accent="true">
<mi>m</mi>
<mo stretchy="false">^</mo>
</mover>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="latexml">norm</csymbol>
<apply>
<minus></minus>
<ci>Y</ci>
<apply>
<ci>normal-^</ci>
<ci>m</ci>
</apply>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<ci>λ</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ci>normal-^</ci>
<ci>m</ci>
</apply>
<ci>T</ci>
</apply>
<ci>A</ci>
<apply>
<ci>normal-^</ci>
<ci>m</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \|Y-\hat{m}\|^{2}+\lambda\hat{m}^{T}A\hat{m},
  </annotation>
</semantics>
</math>

.</p>

<p>Now back to the first step. The penalized sum-of-squares can be written as</p>

<p>
<math display="inline" id="Smoothing_spline:21">
<semantics>
<mrow>
<mi>Y</mi>
<mo>=</mo>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>Y</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>Y</mi>
<mi>n</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<mi>T</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>Y</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<vector>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<ci>n</ci>
</apply>
</vector>
<ci>T</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y=(Y_{1},\ldots,Y_{n})^{T}
  </annotation>
</semantics>
</math>

 where 

<math display="inline" id="Smoothing_spline:22">
<semantics>
<mover accent="true">
<mi>m</mi>
<mo stretchy="false">^</mo>
</mover>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-^</ci>
<ci>m</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{m}
  </annotation>
</semantics>
</math>

. Minimizing over 

<math display="block" id="Smoothing_spline:23">
<semantics>
<mrow>
<mrow>
<mover accent="true">
<mi>m</mi>
<mo stretchy="false">^</mo>
</mover>
<mo>=</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>I</mi>
<mo>+</mo>
<mrow>
<mi>λ</mi>
<mi>A</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mi>Y</mi>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<ci>normal-^</ci>
<ci>m</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<plus></plus>
<ci>I</ci>
<apply>
<times></times>
<ci>λ</ci>
<ci>A</ci>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>Y</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{m}=(I+\lambda A)^{-1}Y.
  </annotation>
</semantics>
</math>

 gives</p>

<p>
<math display="inline" id="Smoothing_spline:24">
<semantics>
<mrow>
<mrow>
<mi>p</mi>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∑</mo>
<mrow>
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mi>n</mi>
</msubsup>
<msup>
<mrow>
<mo>(</mo>
<mfrac>
<mrow>
<msub>
<mi>Y</mi>
<mi>i</mi>
</msub>
<mo>-</mo>
<mrow>
<mover accent="true">
<mi>μ</mi>
<mo stretchy="false">^</mo>
</mover>
<mrow>
<mo>(</mo>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<mo>)</mo>
</mrow>
</mrow>
</mrow>
<msub>
<mi>δ</mi>
<mi>i</mi>
</msub>
</mfrac>
<mo>)</mo>
</mrow>
<mn>2</mn>
</msup>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<mrow>
<mo>(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>p</mi>
</mrow>
<mo>)</mo>
</mrow>
<mrow>
<mo largeop="true" symmetric="true">∫</mo>
<mrow>
<mpadded width="+1.7pt">
<msup>
<mrow>
<mo>(</mo>
<mrow>
<msup>
<mover accent="true">
<mi>μ</mi>
<mo stretchy="false">^</mo>
</mover>
<mrow>
<mo>(</mo>
<mi>m</mi>
<mo>)</mo>
</mrow>
</msup>
<mrow>
<mo>(</mo>
<mi>x</mi>
<mo>)</mo>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
<mn>2</mn>
</msup>
</mpadded>
<mi>d</mi>
<mi>x</mi>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<plus></plus>
<apply>
<times></times>
<ci>p</ci>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<divide></divide>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<ci>i</ci>
</apply>
<apply>
<times></times>
<apply>
<ci>normal-^</ci>
<ci>μ</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>δ</ci>
<ci>i</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>p</ci>
</apply>
<apply>
<int></int>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ci>normal-^</ci>
<ci>μ</ci>
</apply>
<ci>m</ci>
</apply>
<ci>x</ci>
</apply>
<cn type="integer">2</cn>
</apply>
<ci>d</ci>
<ci>x</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p\sum_{i=1}^{n}\left(\frac{Y_{i}-\hat{\mu}\left(x_{i}\right)}{\delta_{i}}%
\right)^{2}+\left(1-p\right)\int\left(\hat{\mu}^{\left(m\right)}\left(x\right)%
\right)^{2}\,dx
  </annotation>
</semantics>
</math>
</p>
<h2 id="de-boors-approach">De Boor's approach</h2>

<p>De Boor's approach exploits the same idea, of finding a balance between having a smooth curve and being close to the given data.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a>
<math display="inline" id="Smoothing_spline:25">
<semantics>
<mi>p</mi>
<annotation-xml encoding="MathML-Content">
<ci>p</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   p
  </annotation>
</semantics>
</math>
</p>

<p>where 

<math display="inline" id="Smoothing_spline:26">
<semantics>
<mrow>
<mo stretchy="false">[</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">]</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<interval closure="closed">
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</interval>
</annotation-xml>
<annotation encoding="application/x-tex">
   [0,1]
  </annotation>
</semantics>
</math>

 is a parameter called smooth factor and belongs to the interval 

<math display="inline" id="Smoothing_spline:27">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mi>δ</mi>
<mi>i</mi>
</msub>
<mo>;</mo>
<mi>i</mi>
</mrow>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mo>,</mo>
<mrow>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<mi>n</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>δ</ci>
<ci>i</ci>
</apply>
<ci>i</ci>
</list>
<cn type="integer">1</cn>
</apply>
<list>
<ci>normal-…</ci>
<ci>n</ci>
</list>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \delta_{i};i=1,\dots,n
  </annotation>
</semantics>
</math>

, and 

<math display="inline" id="Smoothing_spline:28">
<semantics>
<msubsup>
<mi>δ</mi>
<mi>i</mi>
<mrow>
<mo>-</mo>
<mn>2</mn>
</mrow>
</msubsup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>δ</ci>
<ci>i</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">2</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \delta_{i}^{-2}
  </annotation>
</semantics>
</math>

 are the quantities controlling the extent of smoothing (they represent the weight 

<math display="inline" id="Smoothing_spline:29">
<semantics>
<msub>
<mi>Y</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y_{i}
  </annotation>
</semantics>
</math>

 of each point 

<math display="inline" id="Smoothing_spline:30">
<semantics>
<mi>m</mi>
<annotation-xml encoding="MathML-Content">
<ci>m</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   m
  </annotation>
</semantics>
</math>

). In practice, since <a href="cubic_splines" title="wikilink">cubic splines</a> are mostly used, 

<math display="inline" id="Smoothing_spline:31">
<semantics>
<mn>2</mn>
<annotation-xml encoding="MathML-Content">
<cn type="integer">2</cn>
</annotation-xml>
<annotation encoding="application/x-tex">
   2
  </annotation>
</semantics>
</math>

 is usually 

<math display="inline" id="Smoothing_spline:32">
<semantics>
<mrow>
<mi>m</mi>
<mo>=</mo>
<mn>2</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>m</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   m=2
  </annotation>
</semantics>
</math>

. The solution for 

<math display="inline" id="Smoothing_spline:33">
<semantics>
<mrow>
<mi>m</mi>
<mo>=</mo>
<mn>2</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>m</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   m=2
  </annotation>
</semantics>
</math>

 was proposed by Reinsch in 1967.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> For 

<math display="inline" id="Smoothing_spline:34">
<semantics>
<mi>p</mi>
<annotation-xml encoding="MathML-Content">
<ci>p</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   p
  </annotation>
</semantics>
</math>

, when 

<math display="inline" id="Smoothing_spline:35">
<semantics>
<mn>1</mn>
<annotation-xml encoding="MathML-Content">
<cn type="integer">1</cn>
</annotation-xml>
<annotation encoding="application/x-tex">
   1
  </annotation>
</semantics>
</math>

 approaches 

<math display="inline" id="Smoothing_spline:36">
<semantics>
<mover accent="true">
<mi>μ</mi>
<mo stretchy="false">^</mo>
</mover>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-^</ci>
<ci>μ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{\mu}
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="Smoothing_spline:37">
<semantics>
<mi>p</mi>
<annotation-xml encoding="MathML-Content">
<ci>p</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   p
  </annotation>
</semantics>
</math>

 converges to the "natural" spline interpolant to the given data.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> As 

<math display="inline" id="Smoothing_spline:38">
<semantics>
<mn>0</mn>
<annotation-xml encoding="MathML-Content">
<cn type="integer">0</cn>
</annotation-xml>
</semantics>
</math>

 approaches 

<math display="inline" id="Smoothing_spline:39">
<semantics>
<mover accent="true">
<mi>μ</mi>
<mo stretchy="false">^</mo>
</mover>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-^</ci>
<ci>μ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{\mu}
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="Smoothing_spline:40">
<semantics>
<mi>p</mi>
<annotation-xml encoding="MathML-Content">
<ci>p</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   p
  </annotation>
</semantics>
</math>

 converges to a straight line (the smoothest curve). Since finding a suitable value of 

<math display="inline" id="Smoothing_spline:41">
<semantics>
<mi>S</mi>
<annotation-xml encoding="MathML-Content">
<ci>S</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   S
  </annotation>
</semantics>
</math>

 is a task of trial and error, a redundant constant 

<math display="inline" id="Smoothing_spline:42">
<semantics>
<mi>S</mi>
<annotation-xml encoding="MathML-Content">
<ci>S</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   S
  </annotation>
</semantics>
</math>

 was introduced for convenience.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a>
<math display="inline" id="Smoothing_spline:43">
<semantics>
<mi>p</mi>
<annotation-xml encoding="MathML-Content">
<ci>p</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   p
  </annotation>
</semantics>
</math>

 is used to numerically determine the value of 

<math display="inline" id="Smoothing_spline:44">
<semantics>
<mover accent="true">
<mi>μ</mi>
<mo stretchy="false">^</mo>
</mover>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-^</ci>
<ci>μ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \hat{\mu}
  </annotation>
</semantics>
</math>

 so that the function 

<math display="inline" id="Smoothing_spline:45">
<semantics>
<mrow>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∑</mo>
<mrow>
<mi>i</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mi>n</mi>
</msubsup>
<msup>
<mrow>
<mo>(</mo>
<mfrac>
<mrow>
<msub>
<mi>Y</mi>
<mi>i</mi>
</msub>
<mo>-</mo>
<mrow>
<mover accent="true">
<mi>μ</mi>
<mo stretchy="false">^</mo>
</mover>
<mrow>
<mo>(</mo>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<mo>)</mo>
</mrow>
</mrow>
</mrow>
<msub>
<mi>δ</mi>
<mi>i</mi>
</msub>
</mfrac>
<mo>)</mo>
</mrow>
<mn>2</mn>
</msup>
</mrow>
<mo>≤</mo>
<mi>S</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<leq></leq>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<divide></divide>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<ci>i</ci>
</apply>
<apply>
<times></times>
<apply>
<ci>normal-^</ci>
<ci>μ</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>δ</ci>
<ci>i</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>S</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sum_{i=1}^{n}\left(\frac{Y_{i}-\hat{\mu}\left(x_{i}\right)}{\delta_{i}}\right%
)^{2}\leq S
  </annotation>
</semantics>
</math>

 meets the following condition:</p>

<p>
<math display="inline" id="Smoothing_spline:46">
<semantics>
<mrow>
<mi>p</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>p</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p=0
  </annotation>
</semantics>
</math>
</p>

<p>The algorithm described by de Boor starts with 

<math display="inline" id="Smoothing_spline:47">
<semantics>
<mi>p</mi>
<annotation-xml encoding="MathML-Content">
<ci>p</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   p
  </annotation>
</semantics>
</math>

 and increases 

<math display="inline" id="Smoothing_spline:48">
<semantics>
<msub>
<mi>δ</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>δ</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \delta_{i}
  </annotation>
</semantics>
</math>

 until the condition is met.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> If 

<math display="inline" id="Smoothing_spline:49">
<semantics>
<msub>
<mi>Y</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Y</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y_{i}
  </annotation>
</semantics>
</math>

 is an estimation of the standard deviation for 

<math display="inline" id="Smoothing_spline:50">
<semantics>
<mi>S</mi>
<annotation-xml encoding="MathML-Content">
<ci>S</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   S
  </annotation>
</semantics>
</math>

, the constant 

<math display="inline" id="Smoothing_spline:51">
<semantics>
<mrow>
<mo>[</mo>
<mrow>
<mi>n</mi>
<mo>-</mo>
<msqrt>
<mrow>
<mn>2</mn>
<mi>n</mi>
</mrow>
</msqrt>
</mrow>
<mo>,</mo>
<mrow>
<mi>n</mi>
<mo>+</mo>
<msqrt>
<mrow>
<mn>2</mn>
<mi>n</mi>
</mrow>
</msqrt>
</mrow>
<mo>]</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<interval closure="closed">
<apply>
<minus></minus>
<ci>n</ci>
<apply>
<root></root>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>n</ci>
</apply>
</apply>
</apply>
<apply>
<plus></plus>
<ci>n</ci>
<apply>
<root></root>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>n</ci>
</apply>
</apply>
</apply>
</interval>
</annotation-xml>
<annotation encoding="application/x-tex">
   \left[n-\sqrt{2n},n+\sqrt{2n}\right]
  </annotation>
</semantics>
</math>

 is recommended to be chosen in the interval 

<math display="inline" id="Smoothing_spline:52">
<semantics>
<mrow>
<mi>S</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>S</ci>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   S=0
  </annotation>
</semantics>
</math>

. Having 

<math display="inline" id="Smoothing_spline:53">
<semantics>
<mi>S</mi>
<annotation-xml encoding="MathML-Content">
<ci>S</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   S
  </annotation>
</semantics>
</math>

 means the solution is the "natural" spline interpolant.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Increasing 

<math display="inline" id="Smoothing_spline:54">
<semantics>
<mi>y</mi>
<annotation-xml encoding="MathML-Content">
<ci>y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   y
  </annotation>
</semantics>
</math>

 means we obtain a smoother curve by getting farther from the given data.</p>
<h2 id="creating-a-multidimensional-spline">Creating a multidimensional spline</h2>

<p>Given the constraint from the definition formula 

<math display="inline" id="Smoothing_spline:55">
<semantics>
<mrow>
<mi>x</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>x</ci>
<ci>t</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x(t)
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Smoothing_spline:56">
<semantics>
<mrow>
<mi>y</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>y</ci>
<ci>t</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y(t)
  </annotation>
</semantics>
</math>

 so that they would become 

<math display="inline" id="Smoothing_spline:57">
<semantics>
<mrow>
<msub>
<mi>t</mi>
<mrow>
<mi>i</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>=</mo>
<mrow>
<msub>
<mi>t</mi>
<mi>i</mi>
</msub>
<mo>+</mo>
<msqrt>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>x</mi>
<mrow>
<mi>i</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>-</mo>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
<mo>+</mo>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>y</mi>
<mrow>
<mi>i</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>-</mo>
<msub>
<mi>y</mi>
<mi>i</mi>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
</mrow>
</msqrt>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>t</ci>
<apply>
<plus></plus>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>t</ci>
<ci>i</ci>
</apply>
<apply>
<root></root>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<apply>
<plus></plus>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>i</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   t_{i+1}=t_{i}+\sqrt{(x_{i+1}-x_{i})^{2}+(y_{i+1}-y_{i})^{2}}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Smoothing_spline:58">
<semantics>
<mrow>
<msub>
<mi>t</mi>
<mn>1</mn>
</msub>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>t</ci>
<cn type="integer">1</cn>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   t_{1}=0
  </annotation>
</semantics>
</math>

 where 

<math display="inline" id="Smoothing_spline:0">
 <semantics>
  <mover accent="true">
   <mi>μ</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>μ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mu}
  </annotation>
 </semantics>
</math>

 is the cumulating distance 

<math display="inline" id="Smoothing_spline:1">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 where 

<math display="block" id="Smoothing_spline:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>Y</mi>
         <mi>i</mi>
        </msub>
        <mo>-</mo>
        <mrow>
         <mover accent="true">
          <mi>μ</mi>
          <mo stretchy="false">^</mo>
         </mover>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mi>i</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>λ</mi>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
      </msubsup>
      <mrow>
       <msup>
        <mover accent="true">
         <mi>μ</mi>
         <mo stretchy="false">^</mo>
        </mover>
        <mi>′′</mi>
       </msup>
       <mpadded width="+1.7pt">
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mpadded>
       <mi>d</mi>
       <mi>x</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <ci>normal-^</ci>
         <ci>μ</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>μ</ci>
        </apply>
        <ci>′′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>d</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{n}(Y_{i}-\hat{\mu}(x_{i}))^{2}+\lambda\int_{x_{1}}^{x_{n}}\hat{\mu%
}^{\prime\prime}(x)^{2}\,dx.
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>A more detailed analysis on parametrization is done by E.T.Y Lee.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="related-methods">Related methods</h2>

<p>Smoothing splines are related to, but distinct from:</p>
<ul>
<li>Regression splines. In this method, the data is fitted to a set of spline basis functions with a reduced set of knots, typically by least squares. No roughness penalty is used.</li>
<li>Penalized Splines. This combines the reduced knots of regression splines, with the roughness penalty of smoothing splines.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></li>
<li><a href="Elastic_map" title="wikilink">Elastic maps</a> method for <a href="manifold_learning" title="wikilink">manifold learning</a>. This method combines the <a href="least_squares" title="wikilink">least squares</a> penalty for approximation error with the bending and stretching penalty of the approximating manifold and uses the coarse discretization of the optimization problem.</li>
</ul>
<h2 id="source-code">Source code</h2>

<p>Source code for <a href="Spline_(mathematics)" title="wikilink">spline</a> smoothing can be found in the examples from <a href="Carl_R._de_Boor" title="wikilink">Carl de Boor's</a> book <em>A Practical Guide to Splines</em>. The examples are in <a class="uri" href="Fortran" title="wikilink">Fortran</a> <a href="programming_language" title="wikilink">programming language</a>. The updated sources are available also on Carl de Boor's official site <a href="http://pages.cs.wisc.edu/~deboor/">1</a>.</p>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Wahba, G. (1990). <em>Spline Models for Observational Data</em>. SIAM, Philadelphia.</li>
<li>Green, P. J. and Silverman, B. W. (1994). <em>Nonparametric Regression and Generalized Linear Models</em>. CRC Press.</li>
<li>De Boor, C. (2001). <em>A Practical Guide to Splines (Revised Edition)</em>. Springer.</li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Regression_analysis" title="wikilink">Category:Regression analysis</a> <a class="uri" href="Category:Splines" title="wikilink">Category:Splines</a> <a href="Category:Statistical_methods" title="wikilink">Category:Statistical methods</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
</ol>
</section>
</body>
</html>
