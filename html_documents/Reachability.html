<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title offset="1345">Reachability</title>
   <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js">
    </script>
</head>
<body>
<h1>Reachability</h1>
<hr/>
<p>In <a href="graph_theory" title="wikilink">graph theory</a>, <strong>reachability</strong> refers to the ability to get from one <a href="Vertex_(graph_theory)" title="wikilink">vertex</a> to another within a graph. We say that a vertex <span class="LaTeX">$s$</span> can reach a vertex <span class="LaTeX">$t$</span> (or that <span class="LaTeX">$t$</span> is reachable from <span class="LaTeX">$s$</span>) if there exists a sequence of <a href="Glossary_of_graph_theory#Basics" title="wikilink">adjacent</a> vertices (i.e. a <a href="Glossary_of_graph_theory#Walks" title="wikilink">path</a>) which starts with <span class="LaTeX">$s$</span> and ends with <span class="LaTeX">$t$</span>.</p>
<p>In an undirected graph, it is sufficient to identify the <a href="Connected_component_(graph_theory)" title="wikilink">connected components</a>, as any pair of vertices in such a graph can reach each other if and only if they belong to the same connected component. The connected components of a graph can be identified in linear time. The remainder of this article focuses on reachability in a <a href="Directed_graph" title="wikilink"><em>directed</em> graph</a> setting.</p>
<h2 id="definition">Definition</h2>
<p>For a directed graph <span class="LaTeX">$G = (V, E)$</span>, with vertex set <span class="LaTeX">$V$</span> and edge set <span class="LaTeX">$E$</span>, the reachability <a href="Relation_(mathematics)" title="wikilink">relation</a> of <span class="LaTeX">$G$</span> is the <a href="transitive_closure" title="wikilink">transitive closure</a> of <span class="LaTeX">$E$</span>, which is to say the set of all ordered pairs <span class="LaTeX">$(s,t)$</span> of vertices in <span class="LaTeX">$V$</span> for which there exists a sequence of vertices <span class="LaTeX">$v_0 = s, v_1, v_2, ..., v_k = t$</span> such that the edge <span class="LaTeX">$(v_{i-1},v_i)$</span> is in <span class="LaTeX">$E$</span> for all <span class="LaTeX">$1 \leq i \leq k$</span>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<p>If <span class="LaTeX">$G$</span> is <a href="directed_acyclic_graph" title="wikilink">acyclic</a>, then its reachability relation is a <a href="partial_order" title="wikilink">partial order</a>; any partial order may be defined in this way, for instance as the reachability relation of its <a href="transitive_reduction" title="wikilink">transitive reduction</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> A noteworthy consequence of this is that since partial orders are anti-symmetric, if <span class="LaTeX">$s$</span> can reach <span class="LaTeX">$t$</span>, then we know that <span class="LaTeX">$t$</span> <em>cannot</em> reach <span class="LaTeX">$s$</span>. Intuitively, if we could travel from <span class="LaTeX">$s$</span> to <span class="LaTeX">$t$</span> and back to <span class="LaTeX">$s$</span>, then <span class="LaTeX">$G$</span> would contain a cycle, contradicting that it is acyclic. If <span class="LaTeX">$G$</span> is directed but <em>not</em> acyclic (i.e. it contains at least one cycle), then its reachability relation will correspond to a <a class="uri" href="preorder" title="wikilink">preorder</a> instead of a partial order. <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="algorithms">Algorithms</h2>
<p>Algorithms for determining reachability fall into two classes: those that require <a class="uri" href="preprocessing" title="wikilink">preprocessing</a> and those that do not.</p>
<p>If you have only one (or a few) queries to make, it may be more efficient to forgo the use of more complex data structures and compute the reachability of the desired pair directly. This can be accomplished in <a href="linear_time" title="wikilink">linear time</a> using algorithms such as <a href="breadth_first_search" title="wikilink">breadth first search</a> or <a href="iterative_deepening_depth-first_search" title="wikilink">iterative deepening depth-first search</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<p>If you will be making many queries, then a more sophisticated method may be used; the exact choice of method depends on the nature of the graph being analysed. In exchange for preprocessing time and some extra storage space, we can create a data structure which can then answer reachability queries on any pair of vertices in as low as <span class="LaTeX">$O(1)$</span> time. Three different algorithms and data structures for three different, increasingly specialized situations are outlined below.</p>
<h3 id="floyd-warshall-algorithm">Floyd-Warshall Algorithm</h3>
<p>The <a href="Floyd–Warshall_algorithm" title="wikilink">Floyd–Warshall algorithm</a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> can be used to compute the transitive closure of any directed graph, which gives rise to the reachability relation as in the definition, above.</p>
<p>The algorithm requires <span class="LaTeX">$O(|V|^3)$</span> time and <span class="LaTeX">$O(|V|^2)$</span> space in the worst case. This algorithm is not solely interested in reachability as it also computes the shortest path distance between all pairs of vertices. For graphs containing negative cycles, shortest paths may be undefined, but reachability between pairs can still be noted.</p>
<h3 id="thorups-algorithm">Thorup's Algorithm</h3>
<p>For <a href="Planar_Graph" title="wikilink">planar</a> <a href="Directed_graph" title="wikilink">digraphs</a>, a much faster method is available, as described by <a href="Mikkel_Thorup" title="wikilink">Mikkel Thorup</a> in 2004.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> This method can answer reachability queries on a planar graph in <span class="LaTeX">$O(1)$</span> time after spending <span class="LaTeX">$O(n \log{n})$</span> preprocessing time to create a data structure of <span class="LaTeX">$O(n \log{n})$</span> size. This algorithm can also supply approximate shortest path distances, as well as route information.</p>
<p>The overall approach is to associate with each vertex a relatively small set of so-called separator paths such that any path from a vertex <span class="LaTeX">$v$</span> to any other vertex <span class="LaTeX">$w$</span> must go through at least one of the separators associated with <span class="LaTeX">$v$</span> or <span class="LaTeX">$w$</span>. An outline of the reachability related sections follows.</p>
<p>Given a graph <span class="LaTeX">$G$</span>, the algorithm begins by organizing the vertices into layers starting from an arbitrary vertex <span class="LaTeX">$v_0$</span>. The layers are built in alternating steps by first considering all vertices reachable <em>from</em> the previous step (starting with just <span class="LaTeX">$v_0$</span>) and then all vertices which reach <em>to</em> the previous step until all vertices have been assigned to a layer. By construction of the layers, every vertex appears at most two layers, and every <a href="Path_(graph_theory)#Different_types_of_paths" title="wikilink">directed path</a>, or dipath, in <span class="LaTeX">$G$</span> is contained within two adjacent layers <span class="LaTeX">$L_i$</span> and <span class="LaTeX">$L_{i+1}$</span>. Let <span class="LaTeX">$k$</span> be the last layer created, that is, the lowest value for <span class="LaTeX">$k$</span> such that <span class="LaTeX">$\bigcup_{i=0}^{k} = V$</span>.</p>
<p>The graph is then re-expressed as a series of digraphs <span class="LaTeX">$G_0, G_1, \ldots,
G_{k-1}$</span> where each <span class="LaTeX">$G_i = r_i \cup L_i \cup L_{i+1}$</span> and where <span class="LaTeX">$r_i$</span> is the contraction of all previous levels <span class="LaTeX">$L_0 \ldots L_{i-1}$</span> into a single vertex. Because every dipath appears in at most two consecutive layers, and because each <span class="LaTeX">$G_i$</span> is formed by two consecutive layers, every dipath in <span class="LaTeX">$G$</span> appears in its entirety in at least one <span class="LaTeX">$G_i$</span> (and no more than 2 consecutive such graphs)</p>
<p>For each <span class="LaTeX">$G_i$</span>, three separators are identified which, when removed, break the graph into three components which each contain at most <span class="LaTeX">$1/2$</span> the vertices of the original. As <span class="LaTeX">$G_i$</span> is built from two layers of opposed dipaths, each separator may consist of up to 2 dipaths, for a total of up to 6 dipaths over all of the separators. Let <span class="LaTeX">$S$</span> be this set of dipaths. The proof that such separators can always be found is related to the <a href="Planar_Separator_Theorem" title="wikilink">Planar Separator Theorem</a> of Lipton and Tarjan, and these separators can be located in linear time.</p>
<p>For each <span class="LaTeX">$Q \in S$</span>, the directed nature of <span class="LaTeX">$Q$</span> provides for a natural indexing of its vertices from the start to the end of the path. For each vertex <span class="LaTeX">$v$</span> in <span class="LaTeX">$G_i$</span>, we locate the first vertex in <span class="LaTeX">$Q$</span> reachable by <span class="LaTeX">$v$</span>, and the last vertex in <span class="LaTeX">$Q$</span> that reaches to <span class="LaTeX">$v$</span>. That is, we are looking at how early into <span class="LaTeX">$Q$</span> we can get from <span class="LaTeX">$v$</span>, and how far we can stay in <span class="LaTeX">$Q$</span> and still get back to <span class="LaTeX">$v$</span>. This information is stored with each <span class="LaTeX">$v$</span>. Then for any pair of vertices <span class="LaTeX">$u$</span> and <span class="LaTeX">$w$</span>, <span class="LaTeX">$u$</span> can reach <span class="LaTeX">$w$</span> <em>via</em> <span class="LaTeX">$Q$</span> if <span class="LaTeX">$u$</span> connects to <span class="LaTeX">$Q$</span> earlier than <span class="LaTeX">$w$</span> connects from <span class="LaTeX">$Q$</span>.</p>
<p>Every vertex is labelled as above for each step of the recursion which builds <span class="LaTeX">$G_0 \ldots, G_k$</span>. As this recursion has logarithmic depth, a total of <span class="LaTeX">$O(\log{n})$</span> extra information is stored per vertex. From this point, a logarithmic time query for reachability is as simple as looking over each pair of labels for a common, suitable <span class="LaTeX">$Q$</span>. The original paper then works to tune the query time down to <span class="LaTeX">$O(1)$</span>.</p>
<p>In summarizing the analysis of this method, first consider that the layering approach partitions the vertices so that each vertex is considered only <span class="LaTeX">$O(1)$</span> times. The separator phase of the algorithm breaks the graph into components which are at most <span class="LaTeX">$1/2$</span> the size of the original graph, resulting in a logarithmic recursion depth. At each level of the recursion, only linear work is needed to identify the separators as well as the connections possible between vertices. The overall result is <span class="LaTeX">$O(n \log n)$</span> preprocessing time with only <span class="LaTeX">$O(\log{n})$</span> additional information stored for each vertex.</p>
<h3 id="kamedas-algorithm">Kameda's Algorithm</h3>
<figure><b>(Figure)</b>
<figcaption>A suitable digraph for Kameda's method with <span class="LaTeX">$s$</span> and <span class="LaTeX">$t$</span> added.</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>The same graph as above after Kameda's algorithm has run, showing the DFS labels for each vertex</figcaption>
</figure>
<p>An even faster method for pre-processing, due to T. Kameda in 1975,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> can be used if the graph is planar, acyclic, and also exhibits the following additional properties: all 0-<a href="Directed_graph#Indegree_and_outdegree" title="wikilink">indegree</a> and all 0-<a href="Directed_graph#Indegree_and_outdegree" title="wikilink">outdegree</a> vertices appear on the same <a href="Glossary_of_graph_theory#Genus" title="wikilink">face</a> (often assumed to be the outer face), and it is possible to partition the boundary of that face into two parts such that all 0-indegree vertices appear on one part, and all 0-outdegree vertices appear on the other (i.e. the two types of vertices do not alternate).</p>
<p>If <span class="LaTeX">$G$</span> exhibits these properties, then we can preprocess the graph in only <span class="LaTeX">$O(n)$</span> time, and store only <span class="LaTeX">$O(\log{n})$</span> extra bits per vertex, answering reachability queries for any pair of vertices in <span class="LaTeX">$O(1)$</span> time with a simple comparison.</p>
<p>Preprocessing performs the following steps. We add a new vertex <span class="LaTeX">$s$</span> which has an edge to each 0-indegree vertex, and another new vertex <span class="LaTeX">$t$</span> with edges to each 0-outdegree vertex. Note that the properties of <span class="LaTeX">$G$</span> allow us to do so while maintaining planarity, that is, there will still be no edge crossings after these additions. For each vertex we store the list of adjacencies (out-edges) in order of the planarity of the graph (for example, clockwise with respect to the graph's embedding). We then initialize a counter <span class="LaTeX">$i = n + 1$</span> and begin a Depth-First Traversal from <span class="LaTeX">$s$</span>. During this traversal, the adjacency list of each vertex is visited from left-to-right as needed. As vertices are popped from the traversal's stack, they are labelled with the value <span class="LaTeX">$i$</span>, and <span class="LaTeX">$i$</span> is then decremented. Note that <span class="LaTeX">$t$</span> is always labelled with the value <span class="LaTeX">$n+1$</span> and <span class="LaTeX">$s$</span> is always labelled with <span class="LaTeX">$0$</span>. The depth-first traversal is then repeated, but this time the adjacency list of each vertex is visited from right-to-left.</p>
<p>When completed, <span class="LaTeX">$s$</span> and <span class="LaTeX">$t$</span>, and their incident edges, are removed. Each remaining vertex stores a 2-dimensional label with values from <span class="LaTeX">$1$</span> to <span class="LaTeX">$n$</span>. Given two vertices <span class="LaTeX">$u$</span> and <span class="LaTeX">$v$</span>, and their labels <span class="LaTeX">$L(u) = (a_1, a_2)$</span> and <span class="LaTeX">$L(v) =(b_1, b_2)$</span>, we say that <span class="LaTeX">$L(u) < L(v)$</span> if and only if <span class="LaTeX">$a_1 \leq b_1$</span>, <span class="LaTeX">$a_2 \leq
b_2$</span>, and there exists at least one component <span class="LaTeX">$a_1$</span> or <span class="LaTeX">$a_2$</span> which is strictly less than <span class="LaTeX">$b_1$</span> or <span class="LaTeX">$b_2$</span>, respectively.</p>
<p>The main result of this method then states that <span class="LaTeX">$v$</span> is reachable from <span class="LaTeX">$u$</span> if and only if <span class="LaTeX">$L(u) < L(v)$</span>, which is easily calculated in <span class="LaTeX">$O(1)$</span> time.</p>
<h2 id="related-problems">Related Problems</h2>
<p>A related problem is to solve reachability queries with some number <span class="LaTeX">$k$</span> of vertex failures. For example: "Can vertex <span class="LaTeX">$u$</span> still reach vertex <span class="LaTeX">$v$</span> even though vertices <span class="LaTeX">$s_1, s_2, ..., s_k$</span> have failed and can no longer be used?" A similar problem may consider edge failures rather than vertex failures, or a mix of the two. The breadth-first search technique works just as well on such queries, but constructing an efficient oracle is more challenging.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<p>Another problem related to reachability queries is in quickly recalculating changes to reachability relationships when some portion of the graph is changed. For example, this is a relevant concern to <a href="Garbage_collection_(computer_science)" title="wikilink">garbage collection</a> which needs to balance the reclamation of memory (so that it may be reallocated) with the performance concerns of the running application.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Gammoid" title="wikilink">Gammoid</a></li>
<li><a href="St-connectivity" title="wikilink"><em>st</em>-connectivity</a></li>
</ul>
<h2 id="references">References</h2>
<p>"</p>
<p><a href="Category:Graph_connectivity" title="wikilink">Category:Graph connectivity</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4">.<a href="#fnref4">↩</a></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6">.<a href="#fnref6">↩</a></li>
<li id="fn7">.<a href="#fnref7">↩</a></li>
<li id="fn8">.<a href="#fnref8">↩</a></li>
</ol>
</section>
</body>
</html>
