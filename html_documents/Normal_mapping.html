<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="591">Normal mapping</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Normal mapping</h1>
<hr/>

<p> In <a href="3D_computer_graphics" title="wikilink">3D computer graphics</a>, <strong>normal mapping</strong>, or "Dot3 bump mapping", is a technique used for faking the lighting of bumps and dents – an implementation of <a href="bump_mapping" title="wikilink">bump mapping</a>. It is used to add details without using more <a href="polygonal_modeling" title="wikilink">polygons</a>. A common use of this technique is to greatly enhance the appearance and details of a <a href="low_poly" title="wikilink">low polygon model</a> by generating a normal map from a high polygon model or <a href="Heightmap" title="wikilink">height map</a>.</p>

<p>Normal maps are commonly stored as regular <a class="uri" href="RGB" title="wikilink">RGB</a> images where the RGB components correspond to the X, Y, and Z coordinates, respectively, of the <a href="surface_normal" title="wikilink">surface normal</a>.</p>
<h2 id="history">History</h2>

<p>The idea of taking geometric details from a high polygon model was introduced in "Fitting Smooth Surfaces to Dense Polygon Meshes" by Krishnamurthy and Levoy, Proc. <a class="uri" href="SIGGRAPH" title="wikilink">SIGGRAPH</a> 1996,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> where this approach was used for creating <a href="displacement_mapping" title="wikilink">displacement maps</a> over <a class="uri" href="nurbs" title="wikilink">nurbs</a>. In 1998, two papers were presented with key ideas for transferring details with normal maps from high to low polygon meshes: "Appearance Preserving Simplification", by Cohen et al. SIGGRAPH 1998,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and "A general method for preserving attribute values on simplified meshes" by Cignoni et al. IEEE Visualization '98.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The former introduced the idea of storing surface normals directly in a texture, rather than displacements, though it required the low-detail model to be generated by a particular constrained simplification algorithm. The latter presented a simpler approach that decouples the high and low polygonal mesh and allows the recreation of any attributes of the high-detail model (color, <a href="texture_mapping" title="wikilink">texture coordinates</a>, <a href="displacement_mapping" title="wikilink">displacements</a>, etc.) in a way that is not dependent on how the low-detail model was created. The combination of storing normals in a texture, with the more general creation process is still used by most currently available tools.</p>
<h2 id="how-it-works">How it works</h2>

<p><a href="File:Normal_map_example_with_scene_and_result.png" title="wikilink">thumb|upright=1.8|Example of a normal map (center) with the scene it was calculated from (left) and the result when applied to a flat surface (right).</a> To calculate the <a class="uri" href="Lambertian" title="wikilink">Lambertian</a> (diffuse) lighting of a surface, the unit <a href="Vector_(geometric)" title="wikilink">vector</a> from the shading point to the light source is <a href="dot_product" title="wikilink">dotted</a> with the unit vector normal to that surface, and the result is the intensity of the light on that surface. Imagine a polygonal model of a sphere - you can only approximate the shape of the surface. By using a 3-channel bitmap textured across the model, more detailed normal vector information can be encoded. Each channel in the bitmap corresponds to a spatial dimension (X, Y and Z). These spatial dimensions are relative to a constant coordinate system for object-space normal maps, or to a smoothly varying coordinate system (based on the derivatives of position with respect to texture coordinates) in the case of tangent-space normal maps. This adds much more detail to the surface of a model, especially in conjunction with advanced lighting techniques.</p>

<p>Since a normal will be used in the dot product calculation for the diffuse lighting computation, we can see that the {0, 0, –1} would be remapped to the {128, 128, 0} values, giving that kind of sky blue color seen in normal maps (blue (z) coordinate is perspective (deepness) coordinate and RG-xy flat coordinates on screen). {0.3, 0.4, –0.866} would be remapped to the ({0.3, 0.4, –0.866}/2+{0.5, 0.5, 0.5})*255={0.15+0.5, 0.2+0.5, -0.433+0.5}*255={0.65, 0.7, 0.067}*255={166, 179, 17} values (

<math display="inline" id="Normal_mapping:0">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mn>0.3</mn>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mn>0.4</mn>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mn>0.866</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="float">0.3</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="float">0.4</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="float">0.866</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0.3^{2}+0.4^{2}+(-0.866)^{2}=1
  </annotation>
 </semantics>
</math>

). The sign of the z-coordinate (blue channel) must be flipped to match the normal map's normal vector with that of the eye (the viewpoint or camera) or the light vector. Since negative z values mean that the vertex is in front of the camera (rather than behind the camera) this convention guarantees that the surface shines with maximum strength precisely when the light vector and normal vector are coincident.</p>
<h2 id="calculating-tangent-space">Calculating tangent space</h2>

<p>In order to find the perturbation in the normal the tangent space must be correctly calculated.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Most often the normal is perturbed in a fragment shader after applying the model and view matrices. Typically the geometry provides a normal and tangent. The tangent is part of the tangent plane and can be transformed simply with the <a href="Affine_transformation" title="wikilink">linear</a> part of the matrix (the upper 3x3). However, the normal needs to be transformed by the <a href="Surface_normal#Transforming_normals" title="wikilink">inverse transpose</a>. Most applications will want cotangent to match the transformed geometry (and associated UVs). So instead of enforcing the cotangent to be perpendicular to the tangent, it is generally preferable to transform the cotangent just like the tangent. Let <em>t</em> be tangent, <em>b</em> be cotangent, <em>n</em> be normal, <em>M<sub>3x3</sub></em> be the linear part of model matrix, and <em>V<sub>3x3</sub></em> be the linear part of the view matrix.</p>

<p>

<math display="block" id="Normal_mapping:1">
 <semantics>
  <mrow>
   <msup>
    <mi>t</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>t</mi>
    <mo>×</mo>
    <msub>
     <mi>M</mi>
     <mrow>
      <mn>3</mn>
      <mi>x</mi>
      <mn>3</mn>
     </mrow>
    </msub>
    <mo>×</mo>
    <msub>
     <mi>V</mi>
     <mrow>
      <mn>3</mn>
      <mi>x</mi>
      <mn>3</mn>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>t</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>t</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{\prime}=t\times M_{3x3}\times V_{3x3}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Normal_mapping:2">
 <semantics>
  <mrow>
   <msup>
    <mi>b</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>b</mi>
    <mo>×</mo>
    <msub>
     <mi>M</mi>
     <mrow>
      <mn>3</mn>
      <mi>x</mi>
      <mn>3</mn>
     </mrow>
    </msub>
    <mo>×</mo>
    <msub>
     <mi>V</mi>
     <mrow>
      <mn>3</mn>
      <mi>x</mi>
      <mn>3</mn>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>b</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>b</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b^{\prime}=b\times M_{3x3}\times V_{3x3}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Normal_mapping:3">
 <semantics>
  <mrow>
   <msup>
    <mi>n</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>n</mi>
    <mo>×</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>M</mi>
        <mrow>
         <mn>3</mn>
         <mi>x</mi>
         <mn>3</mn>
        </mrow>
       </msub>
       <mo>×</mo>
       <msub>
        <mi>V</mi>
        <mrow>
         <mn>3</mn>
         <mi>x</mi>
         <mn>3</mn>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>1</mn>
       <mi>T</mi>
      </mrow>
     </mrow>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>n</mi>
    <mo>×</mo>
    <msubsup>
     <mi>M</mi>
     <mrow>
      <mn>3</mn>
      <mi>x</mi>
      <mn>3</mn>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>1</mn>
       <mi>T</mi>
      </mrow>
     </mrow>
    </msubsup>
    <mo>×</mo>
    <msubsup>
     <mi>V</mi>
     <mrow>
      <mn>3</mn>
      <mi>x</mi>
      <mn>3</mn>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mn>1</mn>
       <mi>T</mi>
      </mrow>
     </mrow>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>M</ci>
         <apply>
          <times></times>
          <cn type="integer">3</cn>
          <ci>x</ci>
          <cn type="integer">3</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>V</ci>
         <apply>
          <times></times>
          <cn type="integer">3</cn>
          <ci>x</ci>
          <cn type="integer">3</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">1</cn>
         <ci>T</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <apply>
         <times></times>
         <cn type="integer">3</cn>
         <ci>x</ci>
         <cn type="integer">3</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">1</cn>
         <ci>T</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <apply>
         <times></times>
         <cn type="integer">3</cn>
         <ci>x</ci>
         <cn type="integer">3</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">1</cn>
         <ci>T</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{\prime}=n\times(M_{3x3}\times V_{3x3})^{-1T}=n\times M_{3x3}^{-1T}\times V_%
{3x3}^{-1T}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="normal-mapping-in-video-games">Normal mapping in video games</h2>

<p>Interactive normal map rendering was originally only possible on <a class="uri" href="PixelFlow" title="wikilink">PixelFlow</a>, a <a href="parallel_rendering" title="wikilink">parallel rendering</a> machine built at the <a href="University_of_North_Carolina_at_Chapel_Hill" title="wikilink">University of North Carolina at Chapel Hill</a>. It was later possible to perform normal mapping on high-end <a href="Silicon_Graphics" title="wikilink">SGI</a> workstations using multi-pass rendering and <a class="uri" href="framebuffer" title="wikilink">framebuffer</a> operations<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> or on low end PC hardware with some tricks using paletted textures. However, with the advent of <a href="shader" title="wikilink">shaders</a> in personal computers and game consoles, normal mapping became widely used in commercial video games starting in late 2003. Normal mapping's popularity for <a href="real-time_rendering" title="wikilink">real-time rendering</a> is due to its good quality to processing requirements ratio versus other methods of producing similar effects. Much of this efficiency is made possible by distance-indexed detail scaling, a technique which selectively decreases the detail of the normal map of a given texture (cf. <a class="uri" href="mipmapping" title="wikilink">mipmapping</a>), meaning that more distant surfaces require less complex lighting simulation.</p>

<p>Basic normal mapping can be implemented in any hardware that supports palettized textures. The first game console to have specialized normal mapping hardware was the Sega <a class="uri" href="Dreamcast" title="wikilink">Dreamcast</a>. However, Microsoft's <a href="Xbox_(console)" title="wikilink">Xbox</a> was the first console to widely use the effect in retail games. Out of the <a href="History_of_video_game_consoles_(sixth_generation)" title="wikilink">sixth generation consoles</a>, only the <a href="PlayStation_2" title="wikilink">PlayStation 2</a>'s <a href="PlayStation_2#Technical_specifications" title="wikilink">GPU</a> lacks built-in normal mapping support. Games for the <a href="Xbox_360" title="wikilink">Xbox 360</a> and the <a href="PlayStation_3" title="wikilink">PlayStation 3</a> rely heavily on normal mapping and are beginning to implement <a href="parallax_mapping" title="wikilink">parallax mapping</a>. The <a href="Nintendo_3DS" title="wikilink">Nintendo 3DS</a> has been shown to support normal mapping, as demonstrated by <em><a href="Resident_Evil_Revelations" title="wikilink">Resident Evil Revelations</a></em> and <em><a href="Metal_Gear_Solid:_Snake_Eater#Metal_Gear_Solid_3:_Snake_Eater_3D" title="wikilink">Metal Gear Solid: Snake Eater</a></em>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Texture_mapping" title="wikilink">Texture mapping</a></li>
<li><a href="Bump_mapping" title="wikilink">Bump mapping</a></li>
<li><a href="Parallax_mapping" title="wikilink">Parallax mapping</a></li>
<li><a href="Displacement_mapping" title="wikilink">Displacement mapping</a></li>
<li><a href="Reflection_(physics)" title="wikilink">Reflection (physics)</a></li>
<li><a href="Ambient_occlusion" title="wikilink">Ambient occlusion</a></li>
<li><a href="Depth_map" title="wikilink">Depth map</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.falloutsoftware.com/tutorials/gl/normal-map.html">Normal Map Tutorial</a> Per-pixel logic behind Dot3 Normal Mapping</li>
</ul>
<ul>
<li><a href="http://cpetry.github.io/NormalMap-Online">NormalMap-Online</a> Free Generator inside Browser</li>
<li>[<a class="uri" href="http://sunandblackcat.com/tipFullView.php?l=eng&amp;topicid">http://sunandblackcat.com/tipFullView.php?l=eng&amp;topicid;</a>;=7 Normal Mapping on sunandblackcat.com]</li>
<li>[<a class="uri" href="http://www.game-artist.net/forums/vbarticles.php?do=article&amp;articleid">http://www.game-artist.net/forums/vbarticles.php?do=article&amp;articleid;</a>;=16 Introduction to Normal Mapping]</li>
<li><a href="http://wiki.blender.org/index.php/Manual/Bump_and_Normal_Maps">Blender Normal Mapping</a></li>
<li><a href="http://vcg.isti.cnr.it/activities/geometryegraphics/bumpmapping.html">Normal Mapping with paletted textures</a> using old OpenGL extensions.</li>
<li><a href="http://zarria.net/nrmphoto/nrmphoto.html">Normal Map Photography</a> Creating normal maps manually by layering digital photographs</li>
<li><a href="http://www.3dkingdoms.com/tutorial.htm">Normal Mapping Explained</a></li>
<li><a href="http://sourceforge.net/projects/simplenormalmapper">Simple Normal Mapper</a> Open Source normal map generator</li>
</ul>

<p>"</p>

<p><a href="Category:Demo_effects" title="wikilink">Category:Demo effects</a> <a href="Category:Texture_mapping" title="wikilink">Category:Texture mapping</a> <a href="Category:Virtual_reality" title="wikilink">Category:Virtual reality</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Krishnamurthy and Levoy, <em><a href="http://www.graphics.stanford.edu/papers/surfacefitting/">Fitting Smooth Surfaces to Dense Polygon Meshes</a></em>, SIGGRAPH 1996<a href="#fnref1">↩</a></li>
<li id="fn2">Cohen et al., <a href="http://www.cs.unc.edu/~geom/APS/APS.pdf">Appearance-Preserving Simplification</a>, SIGGRAPH 1998 <strong>(PDF)</strong><a href="#fnref2">↩</a></li>
<li id="fn3">Cignoni et al., <a href="http://vcg.isti.cnr.it/publications/papers/rocchini.pdf">A general method for preserving attribute values on simplified meshes</a>, IEEE Visualization 1998 <strong>(PDF)</strong><a href="#fnref3">↩</a></li>
<li id="fn4">Mikkelsen, <a href="http://image.diku.dk/projects/media/morten.mikkelsen.08.pdf">Simulation of Wrinkled Surfaces Revisited</a>, 2008 <strong>(PDF)</strong><a href="#fnref4">↩</a></li>
<li id="fn5">Heidrich and Seidel, <a href="http://www.cs.ubc.ca/~heidrich/Papers/Siggraph.99.pdf">Realistic, Hardware-accelerated Shading and Lighting</a>, SIGGRAPH 1999 <strong>(PDF)</strong><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
