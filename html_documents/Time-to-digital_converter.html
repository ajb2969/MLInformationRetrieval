<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="444">Time-to-digital converter</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Time-to-digital converter</h1>
<hr/>

<p>In <a href="Electronics" title="wikilink">electronic</a> <a class="uri" href="instrumentation" title="wikilink">instrumentation</a> and <a href="signal_processing" title="wikilink">signal processing</a>, a <strong>time to digital converter</strong> (abbreviated <strong>TDC</strong>) is a device for recognizing events and providing a digital representation of the <a class="uri" href="time" title="wikilink">time</a> they occurred. For example, a TDC might output the time of arrival for each incoming pulse. Some applications wish to measure the time interval between two events rather than some notion of an absolute time.</p>

<p>In <a class="uri" href="electronics" title="wikilink">electronics</a> <strong>time-to-digital converters</strong> (TDCs) or <strong>time digitizers</strong> are devices commonly used to measure a time interval and convert it into digital (binary) output. In some cases <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a href="#Interpolation" title="wikilink">interpolating</a> TDCs are also called <strong>time counters</strong> (TCs).</p>

<p>TDCs are used in many different applications, where the time interval between two signal pulses (start and stop pulse) should be determined. Measurement is started and stopped, when either the rising or the falling edge of a signal pulse crosses a set threshold. These requirements are fulfilled in many physical experiments, like <a class="uri" href="time-of-flight" title="wikilink">time-of-flight</a> and lifetime measurements in <a href="atomic_physics" title="wikilink">atomic</a> and <a href="particle_physics" title="wikilink">high energy physics</a>, experiments that involve <a href="laser_rangefinder" title="wikilink">laser ranging</a> and electronic research involving the testing of <a href="integrated_circuits" title="wikilink">integrated circuits</a> and high-speed data transfer.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="application">Application</h2>

<p>TDCs are used in applications where measurement events happen infrequently, such as <a href="high_energy_physics" title="wikilink">high energy physics</a> <a href="experiment" title="wikilink">experiments</a>, where the sheer number of data <a href="channel_(communications)" title="wikilink">channels</a> in most detectors ensures that each channel will be excited only infrequently by particles such as electrons, photons, and ions.</p>
<h2 id="coarse-measurement">Coarse measurement</h2>
<figure><b>(Figure)</b>
<figcaption>A CMOS (rotary) traveling wave <a href="Electronic_oscillator" title="wikilink">oscillator</a> or <a href="Digital_delay_line" title="wikilink">delay line</a> or <a href="distributed_amplifier" title="wikilink">distributed amplifier</a> runs at a flip-flop compatible frequency, but has sharper edges and sub-edge resolution</figcaption>
</figure>

<p>If the required time resolution is not high, then counters can be used to make the conversion.</p>
<h3 id="basic-counter">Basic counter</h3>

<p>In its simplest implementation, a TDC is simply a high-<a class="uri" href="frequency" title="wikilink">frequency</a> <a href="Counter_(digital)" title="wikilink">counter</a> that increments every clock cycle. The current contents of the counter represents the current time. When an event occurs, the counter's value is captured in an output register.</p>

<p>In that approach, the measurement is an integer number of clock cycles, so the measurement is quantized to a clock period. To get finer resolution, a faster clock is needed. The accuracy of the measurement depends upon the stability of the clock frequency.</p>

<p>Typically a TDC uses a <a href="crystal_oscillator" title="wikilink">crystal oscillator</a> reference frequency for good long term stability. High stability crystal oscillators are usually relative low frequency such as 10 MHz (or 100 ns resolution).<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> To get better resolution, a <a href="phase-locked_loop" title="wikilink">phase-locked loop</a> frequency multiplier can be used to generate a faster clock. One might, for example, multiply the crystal reference oscillator by 100 to get a clock rate of 1 GHz (1 ns resolution).</p>
<h4 id="counter-technology">Counter technology</h4>

<p>High clock rates impose additional design constraints on the counter: if the clock period is short, it is difficult to update the count. Binary counters, for example, need a fast carry architecture because they essentially add one to the previous counter value. A solution is using a hybrid counter architecture. A <a href="Ring_counter" title="wikilink">Johnson counter</a>, for example, is a fast non-binary counter. It can be used to count very quickly the low order count; a more conventional binary counter can be used to accumulate the high order count. The fast counter is sometime called a <a class="uri" href="prescaler" title="wikilink">prescaler</a>.</p>

<p>The speed of counters fabricated in <a class="uri" href="CMOS" title="wikilink">CMOS</a>-technology is limited by the capacitance between the gate and the channel and by the resistance of the channel and the signal traces. The product of both is the cut-off-frequency. Modern chip technology allows multiple metal layers and therefore coils with a large number of windings to be inserted into the chip. This allows designers to peak the device for a specific <a class="uri" href="frequency" title="wikilink">frequency</a>, which may lie above the cut-off-frequency of the original transistor.</p>

<p>A peaked variant of the Johnson counter is the <a href="distributed_amplifier" title="wikilink">traveling-wave</a> counter which also achieves sub-cycle resolution. Other methods to achieve sub-cycle resolution include <a href="analog-to-digital_converter" title="wikilink">analog-to-digital converters</a> and <a href="Vernier_scale" title="wikilink">vernier</a> <a href="Counter_(digital)" title="wikilink">Johnson counters</a>.</p>
<h4 id="measuring-a-time-interval">Measuring a time interval</h4>
<figure><b>(Figure)</b>
<figcaption>sketch of the coarse counting method in TDCs: showing measurements of T in various relations to the clock pulses</figcaption>
</figure>

<p>In most situations, the user does not want to just capture an arbitrary time that an event occurs, but wants to measure a time interval, the time between a start event and a stop event.</p>

<p>That can be done by measuring an arbitrary time both the start and stop events and subtracting. The measurement can be off by two counts.</p>

<p>The subtraction can be avoided if the counter is held at zero until the start event, counts during the interval, and then stops counting after the stop event.</p>

<p><strong>Coarse counters</strong> base on a <a href="clock_signal" title="wikilink">reference clock</a> with signals generated at a stable <a class="uri" href="frequency" title="wikilink">frequency</a> 

<math display="inline" id="Time-to-digital_converter:0">
 <semantics>
  <msub>
   <mi>f</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{0}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> When the start signal is detected the <a href="Counter_(digital)" title="wikilink">counter</a> starts counting clock signals and terminates counting after the stop signal is detected. The time interval 

<math display="inline" id="Time-to-digital_converter:1">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 between start and stop is then</p>

<p>

<math display="block" id="Time-to-digital_converter:2">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <mi>n</mi>
    <mo>⋅</mo>
    <msub>
     <mi>T</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <ci>normal-⋅</ci>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=n\cdot T_{0}
  </annotation>
 </semantics>
</math>

</p>

<p>with 

<math display="inline" id="Time-to-digital_converter:3">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, the number of counts and 

<math display="inline" id="Time-to-digital_converter:4">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <msub>
     <mi>f</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{0}=1/f_{0}
  </annotation>
 </semantics>
</math>

, the period of the <a href="clock_signal" title="wikilink">reference clock</a>.</p>
<h3 id="statistical-counter">Statistical counter</h3>

<p>Since start, stop and <a href="clock_signal" title="wikilink">clock signal</a> are asynchronous, there is a uniform <a href="probability_distribution" title="wikilink">probability distribution</a> of the start and stop signal-times between two subsequent clock pulses. This detuning of the start and stop signal from the clock pulses is called <a href="quantization_error" title="wikilink">quantization error</a>.</p>

<p>For a series of measurements on the same constant and asynchronous time interval one measures two different numbers of counted clock pulses 

<math display="inline" id="Time-to-digital_converter:5">
 <semantics>
  <msub>
   <mi>n</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Time-to-digital_converter:6">
 <semantics>
  <msub>
   <mi>n</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{2}
  </annotation>
 </semantics>
</math>

 (see picture). These occur with <a class="uri" href="probabilities" title="wikilink">probabilities</a></p>

<p>

<math display="block" id="Time-to-digital_converter:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>n</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mi>c</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(n_{1})=1-c
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Time-to-digital_converter:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>n</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>q</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q(n_{2})=c
  </annotation>
 </semantics>
</math>

</p>

<p>with 

<math display="inline" id="Time-to-digital_converter:9">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mrow>
    <mi>F</mi>
    <mi>r</mi>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>T</mi>
      <mo>/</mo>
      <msub>
       <mi>T</mi>
       <mn>0</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>r</ci>
     <ci>c</ci>
     <apply>
      <divide></divide>
      <ci>T</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=Frc(T/T_{0})
  </annotation>
 </semantics>
</math>

 the <a href="fractional_part" title="wikilink">fractional part</a> of 

<math display="inline" id="Time-to-digital_converter:10">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>/</mo>
   <msub>
    <mi>T</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T/T_{0}
  </annotation>
 </semantics>
</math>

. The value for the time interval is then obtained by</p>

<p>

<math display="block" id="Time-to-digital_converter:11">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>p</mi>
       <mo>⋅</mo>
       <msub>
        <mi>n</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>q</mi>
       <mo>⋅</mo>
       <msub>
        <mi>n</mi>
        <mn>2</mn>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⋅</mo>
    <msub>
     <mi>T</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <plus></plus>
      <apply>
       <ci>normal-⋅</ci>
       <ci>p</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <ci>q</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=(p\cdot n_{1}+q\cdot n_{2})\cdot T_{0}
  </annotation>
 </semantics>
</math>

</p>

<p>Measuring a time interval using a coarse counter with the averaging method described above is relatively time consuming because of the many repetitions that are needed to determine the probabilities 

<math display="inline" id="Time-to-digital_converter:12">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Time-to-digital_converter:13">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

. In comparison to the other methods described later on, a coarse counter has a very limited resolution (1ns in case of a 1 GHz <a href="clock_signal" title="wikilink">reference clock</a>), but satisfies with its theoretically unlimited measuring range.</p>
<h2 id="fine-measurement">Fine measurement</h2>

<p>In contrast to the coarse counter in the previous section, fine measurement methods with much better accuracy but far smaller measuring range are presented here.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> <a href="analog_signal" title="wikilink">Analogue</a> methods like time interval stretching or double conversion as well as <a href="Digital_data" title="wikilink">digital</a> methods like tapped delay lines and the Vernier method are under examination. Though the <a href="analog_signal" title="wikilink">analogue</a> methods still obtain better accuracies, <a href="Digital_data" title="wikilink">digital</a> time interval measurement is often preferred due to its flexibility in <a href="integrated_circuit" title="wikilink">integrated circuit</a> technology and its robustness against external perturbations like temperature changes.</p>

<p>The counter implementation's accuracy is limited by the clock frequency. If time is measured by whole counts, then the resolution is limited to the clock period. For example, a 10 MHz clock has a resolution of 100 ns. To get resolution finer than a clock period, there are time interpolation circuits.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> These circuits measure the fraction of a clock period: that is, the time between a clock event and the event being measured. The interpolation circuits often require a significant amount of time to perform their function; consequently, the TDC needs a quiet interval before the next measurement.</p>
<h3 id="ramp-interpolator">Ramp interpolator</h3>

<p>When counting is not feasible because the clock rate would be too high, analog methods can be used. Analog methods are often used to measure intervals that are between 10 and 200 ns.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> These methods often use a capacitor that is charged during the interval being measured.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> Initially, the capacitor is discharged to zero volts. When the start event occurs, the capacitor is charged with a constant current <em>I</em><sub>1</sub>; the constant current causes the voltage <em>v</em> on the capacitor to increase linearly with time. The rising voltage is called the fast ramp. When the stop event occurs, the charging current is stopped. The voltage on the capacitor <em>v</em> is directly proportional to the time interval <em>T</em> and can be measured with an <a href="analog-to-digital_converter" title="wikilink">analog-to-digital converter</a> (ADC). The resolution of such a system is in the range of 1 to 10 ps.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>Although a separate ADC can be used, the ADC step is often integrated into the interpolator. A second constant current <em>I</em><sub>2</sub> is used to discharge the capacitor at a constant but much slower rate (the slow ramp). The slow ramp might be 1/1000 of the fast ramp. This discharge effectively "stretches" the time interval;<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> it will take 1000 times as long for the capacitor to discharge to zero volts. The stretched interval can be measured with a counter. The measurement is similar to a <a href="Integrating_ADC" title="wikilink">dual-slope analog converter</a>.</p>

<p>The dual-slope conversion can take a long time: a thousand or so clock ticks in the scheme described above. That limits how often a measurement can be made (dead time). Resolution of 1 ps with a 100 MHz (10 ns) clock requires a stretch ratio of 10,000 and implies a conversion time of 150 μs.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> To decrease the conversion time, the interpolator circuit can be used twice in a <strong>residual interpolator technique</strong>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> The fast ramp is used initially as above to determine the time. The slow ramp is only at 1/100. The slow ramp will cross zero at some time during the clock period. When the ramp crosses zero, the fast ramp is turned on again to measure the crossing time (<em>t</em><sub>residual</sub>). Consequently, the time can be determined to 1 part in 10,000.</p>

<p>Interpolators are often used with a stable system clock. The start event is asynchronous, but the stop event is a following clock.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> For convenience, imagine that the fast ramp rises exactly 1 volt during a 100 ns clock period. Assume the start event occurs at 67.3 ns after a clock pulse; the fast ramp integrator is triggered and starts rising. The asynchronous start event is also routed through a synchronizer that takes at least two clock pulses. By the next clock pulse, the ramp has risen to .327 V. By the second clock pulse, the ramp has risen to 1.327 V and the synchronizer reports the start event has been seen. The fast ramp is stopped and the slow ramp starts. The synchronizer output can be used to capture system time from a counter. After 1327 clocks, the slow ramp returns to its starting point, and interpolator knows that the event occurred 132.7 ns before the synchronizer reported.</p>

<p>The interpolator is actually more involved because there are synchronizer issues and current switching is not instantaneous.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> Also, the interpolator must calibrate the height of the ramp to a clock period.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<h3 id="vernier">Vernier</h3>
<h4 id="vernier-interpolator">Vernier interpolator</h4>

<p>The vernier method is more involved.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> The method involves a triggerable oscillator<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> and a coincidence circuit. At the event, the integer clock count is stored and the oscillator is started. The triggered oscillator has a slightly different frequency than the clock oscillator. For sake of argument, say the triggered oscillator has a period that is 1 ns faster than the clock. If the event happened 67 ns after the last clock, then the triggered oscillator transition will slide by −1 ns after each subsequent clock pulse. The triggered oscillator will be at 66 ns after the next clock, at 65 ns after the second clock, and so forth. A coincidence detector looks for when the triggered oscillator and the clock transition at the same time, and that indicates the fraction time that needs to be added.</p>

<p>The interpolator design is more involved. The triggerable clock must be calibrated to clock. It must also start quickly and cleanly.</p>
<h4 id="vernier-method">Vernier method</h4>

<p>The <strong>Vernier method</strong> is a <a href="Digital_data" title="wikilink">digital</a> version of the time stretching method. Two only slightly detuned <a href="oscillation" title="wikilink">oscillators</a> (with <a class="uri" href="frequencies" title="wikilink">frequencies</a> 

<math display="inline" id="Time-to-digital_converter:14">
 <semantics>
  <msub>
   <mi>f</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Time-to-digital_converter:15">
 <semantics>
  <msub>
   <mi>f</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{2}
  </annotation>
 </semantics>
</math>

) start their signals with the arrival of the start and the stop signal. As soon as the leading edges of the <a href="oscillation" title="wikilink">oscillator</a> signals coincide the measurement ends and the number of periods of the oscillators (

<math display="inline" id="Time-to-digital_converter:16">
 <semantics>
  <msub>
   <mi>n</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Time-to-digital_converter:17">
 <semantics>
  <msub>
   <mi>n</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{2}
  </annotation>
 </semantics>
</math>

 respectively) lead to the original time interval 

<math display="inline" id="Time-to-digital_converter:18">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Time-to-digital_converter:19">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <msub>
       <mi>n</mi>
       <mn>1</mn>
      </msub>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <msub>
      <mi>f</mi>
      <mn>1</mn>
     </msub>
    </mfrac>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <msub>
       <mi>n</mi>
       <mn>2</mn>
      </msub>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <msub>
      <mi>f</mi>
      <mn>2</mn>
     </msub>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=\frac{n_{1}-1}{f_{1}}-\frac{n_{2}-1}{f_{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>Since highly reliable <a href="oscillation" title="wikilink">oscillators</a> with stable and accurate <a class="uri" href="frequency" title="wikilink">frequency</a> are still quite a challenge one also realizes the vernier method via two tapped delay lines using two slightly different cell delay times 

<math display="inline" id="Time-to-digital_converter:20">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

. This setting is called <strong>differential delay line</strong> or <strong>vernier delay line</strong>.</p>

<p>In the example presented here the first delay line affiliated with the start signal contains cells of D-<a href="flip-flop_(electronics)" title="wikilink">flip-flops</a> with delay 

<math display="inline" id="Time-to-digital_converter:21">
 <semantics>
  <msub>
   <mi>τ</mi>
   <mi>L</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>τ</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{L}
  </annotation>
 </semantics>
</math>

 which are initially set to transparent. During the transition of the start signal through one of those cells, the signal is delayed by 

<math display="inline" id="Time-to-digital_converter:22">
 <semantics>
  <msub>
   <mi>τ</mi>
   <mi>L</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>τ</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{L}
  </annotation>
 </semantics>
</math>

 and the state of the flip-flop is sampled as transparent. The second delay line belonging to the stop signal is composed of a series of <a href="operational_amplifier#Applications" title="wikilink">non-inverting buffers</a> with delay 

<math display="inline" id="Time-to-digital_converter:23">
 <semantics>
  <mrow>
   <msub>
    <mi>τ</mi>
    <mi>B</mi>
   </msub>
   <mo><</mo>
   <msub>
    <mi>τ</mi>
    <mi>L</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>τ</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>τ</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{B}<\tau_{L}
  </annotation>
 </semantics>
</math>

. Propagating through its channel the stop signal latches the flip-flops of the start signal's delay line. As soon as the stop signal passes the start signal, the latter is stopped and all leftover flip-flops are sampled opaque. Analogous to the above case of the oscillators the wanted time interval 

<math display="inline" id="Time-to-digital_converter:24">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is then</p>

<p>

<math display="block" id="Time-to-digital_converter:25">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <mi>n</mi>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>τ</mi>
       <mn>1</mn>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>τ</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <ci>normal-⋅</ci>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>τ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>τ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=n\cdot(\tau_{1}-\tau_{2})
  </annotation>
 </semantics>
</math>

</p>

<p>with n the number of cells marked as transparent.</p>
<h3 id="tapped-delay-line">Tapped delay line</h3>
<figure><b>(Figure)</b>
<figcaption>circuit diagram of a tapped delay line</figcaption>
</figure>

<p>In general a <strong>tapped delay line</strong> contains a number of cells with well defined delay times 

<math display="inline" id="Time-to-digital_converter:26">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

. Propagating through this line the start signal is delayed. The state of the line is sampled at the time of the arrival of the stop signal. This can be realized for example with a line of D-flip-flop cells with a delay time 

<math display="inline" id="Time-to-digital_converter:27">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

. The start signal propagates through this line of transparent <a class="uri" href="flip-flops" title="wikilink">flip-flops</a> and is delayed by a certain number of them. The output of each flip-flop is sampled on the fly. The stop signal latches all <a class="uri" href="flip-flops" title="wikilink">flip-flops</a> while propagating through its channel undelayed and the start signal cannot propagate further. Now the time interval between start and stop signal is proportional to the number of <a class="uri" href="flip-flops" title="wikilink">flip-flops</a> that were sampled as transparent.</p>
<h2 id="hybrid-measurement">Hybrid measurement</h2>
<figure><b>(Figure)</b>
<figcaption>Sketch of the Nutt interpolation method</figcaption>
</figure>

<p>Counters can measure long intervals but have limited resolution. Interpolators have high resolution but they cannot measure long intervals. A hybrid approach can achieve both long intervals and high resolution.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> The long interval can be measured with a counter. The counter information is supplemented with two time interpolators: one interpolator measures the (short) interval between the start event and a following clock event, and the second interpolator measure the interval between the stop event and a following clock event. The basic idea has some complications: the start and stop events are asynchronous, and one or both might happen close to a clock pulse. The counter and interpolators must agree on matching the start and end clock events. To accomplish that goal, synchronizers are used.</p>

<p>The common hybrid approach is the <strong>Nutt method</strong>.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> In this example the fine measurement circuit measures the time between start and stop pulse and the respective second nearest clock pulse of the coarse counter (<em>T</em><sub>start</sub>, <em>T</em><sub>stop</sub>), detected by the synchronizer (see figure). Thus the wanted time interval is</p>

<p>

<math display="block" id="Time-to-digital_converter:28">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>n</mi>
      <msub>
       <mi>T</mi>
       <mn>0</mn>
      </msub>
     </mrow>
     <mo>+</mo>
     <msub>
      <mi>T</mi>
      <mi>start</mi>
     </msub>
    </mrow>
    <mo>-</mo>
    <msub>
     <mi>T</mi>
     <mi>stop</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <ci>start</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>stop</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=nT_{0}+T_{\mathrm{start}}-T_{\mathrm{stop}}
  </annotation>
 </semantics>
</math>

</p>

<p>with <em>n</em> the number of counter clock pulses and <em>T</em><sub>0</sub> the period of the coarse counter.</p>
<h2 id="history">History</h2>

<p>Time measurement has played a crucial role in the understanding of nature from the earliest times. Starting with sun, sand or water driven <a class="uri" href="clocks" title="wikilink">clocks</a> we are able to use clocks today, based on the most precise <a class="uri" href="caesium" title="wikilink">caesium</a> resonators.</p>

<p>The first direct predecessor of a TDC was invented in the year 1942 by <a href="Bruno_Rossi" title="wikilink">Bruno Rossi</a> for the measurement of <a class="uri" href="muon" title="wikilink">muon</a> lifetimes.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> It was designed as a <strong>time-to-amplitude-converter</strong>, constantly charging a <a class="uri" href="capacitor" title="wikilink">capacitor</a> during the measured time interval. The corresponding <a class="uri" href="voltage" title="wikilink">voltage</a> is directly proportional to the time interval under examination.</p>

<p>While the basic concepts (like Vernier methods (<a href="Pierre_Vernier" title="wikilink">Pierre Vernier</a> 1584-1638) and time stretching) of dividing time into measurable intervals are still up-to-date, the implementation changed a lot during the past 50 years. Starting with <a href="vacuum_tubes" title="wikilink">vacuum tubes</a> and <a href="transformer_types#RF_transformers" title="wikilink">ferrite pot-core transformers</a> those ideas are implemented in complementary metal-oxide-semiconductor (<a class="uri" href="CMOS" title="wikilink">CMOS</a>) design today.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>
<h2 id="errors">Errors</h2>
<dl>
<dd><small>Some information from <a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></small>
</dd>
</dl>

<p>Regarding even the fine measuring methods presented, there are still errors one may wish remove or at least to consider. Non-linearities of the time-to-digital conversion for example can be identified by taking a large number of measurements of a <a class="uri" href="poissonian" title="wikilink">poissonian</a> distributed source (statistical code density test).<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> Small deviations from the uniform distribution reveal the non-linearities. Inconveniently the statistical code density method is quite sensitive to external temperature changes. Thus stabilizing <a href="delay-locked_loop" title="wikilink">delay</a> or <a href="phase-locked_loop" title="wikilink">phase-locked loop</a> (DLL or PLL) circuits are recommended.</p>

<p>In a similar way, offset errors (non-zero readouts at <em>T</em> = 0) can be removed.</p>

<p>For long time intervals, the error due to instabilities in the <a href="clock_signal" title="wikilink">reference clock</a> (<a class="uri" href="jitter" title="wikilink">jitter</a>) plays a major role. Thus clocks of superior quality are needed for such TDCs.</p>

<p>Furthermore, external noise sources can be eliminated in postprocessing by <a href="robust_statistic" title="wikilink">robust estimation methods</a>.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>
<h2 id="configurations">Configurations</h2>

<p>TDCs are currently built as stand-alone measuring devices in physical experiments or as system components like PCI cards. They can be made up of either discrete or integrated circuits.</p>

<p>Circuit design changes with the purpose of the TDC, which can either be a very good solution for single-shot TDCs with long dead times or some trade-off between dead-time and resolution for multi-shot TDCs.</p>
<h2 id="delay-generator">Delay generator</h2>

<p> </p>

<p>The time-to-digital converter measures the time between a start event and a stop event. There is also a <strong>digital-to-time converter</strong> or <strong>delay generator</strong>. The delay generator converts a number to a time delay. When the delay generator gets a start pulse at its input, then it outputs a stop pulse after the specified delay. The architectures for TDC and delay generators are similar. Both use counters for long, stable, delays. Both must consider the problem of clock quantization errors.</p>

<p>For example, the <a class="uri" href="Tektronix" title="wikilink">Tektronix</a> 7D11 Digital Delay uses a counter architecture.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> A digital delay may be set from 100 ns to 1 s in 100 ns increments. An analog circuit provides an additional fine delay of 0 to 100 ns. A 5 MHz reference clock drives a <a href="phase-locked_loop" title="wikilink">phase-locked loop</a> to produce a stable 500 MHz clock. It is this fast clock that is gated by the (fine-delayed) start event and determines the main quantization error. The fast clock is divided down to 10 MHz and fed to main counter.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> The instrument quantization error depends primarily on the 500 MHz clock (2 ns steps), but other errors also enter; the instrument is specified to have 2.2 ns of <a class="uri" href="jitter" title="wikilink">jitter</a>. The recycle time is 575 ns.</p>

<p>Just as a TDC may use interpolation to get finer than one clock period resolution, a delay generator may use similar techniques. The <a class="uri" href="Hewlett-Packard" title="wikilink">Hewlett-Packard</a> 5359A High Resolution Time Synthesizer provides delays of 0 to 160 ms, has an accuracy of 1 ns, and achieves a typical jitter of 100 ps.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> The design uses a triggered phase-locked oscillator that runs at 200 MHz. Interpolation is done with a ramp, an 8-bit digital-to-analog converter, and a comparator. The resolution is about 45 ps.</p>

<p>When the start pulse is received, then <a href="Counter_(digital)" title="wikilink">counts</a> down and outputs a stop pulse. For low <a class="uri" href="jitter" title="wikilink">jitter</a> the <a href="Counter_(digital)" title="wikilink">synchronous counter</a> has to feed a <a href="Status_register" title="wikilink">zero flag</a> from the <a href="most_significant_bit" title="wikilink">most significant bit</a> down to the <a href="least_significant_bit" title="wikilink">least significant bit</a> and then combine it with the output from the Johnson counter.</p>

<p>A <a href="digital-to-analog_converter" title="wikilink">digital-to-analog converter</a> (DAC) could be used to achieve sub-cycle resolution, but it is easier to either use vernier Johnson counters or traveling-wave Johnson counters.</p>

<p>The delay generator can be used for <a href="pulse_width_modulation" title="wikilink">pulse width modulation</a>, e.g. to drive a <a class="uri" href="MOSFET" title="wikilink">MOSFET</a> to load a <a href="Pockels_cell" title="wikilink">Pockels cell</a> within 8 ns with a specific charge.</p>

<p>The output of a delay generator can gate a digital-to-analog converter and so pulses of a variable height can be generated. This allows matching to low levels needed by analog electronics, higher levels for <a href="Emitter-coupled_logic" title="wikilink">ECL</a> and even higher levels for <a href="Transistor–transistor_logic" title="wikilink">TTL</a>. If a series of DACs is gated in sequence, variable pulse shapes can be generated to account for any transfer function.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Sampling_frequency" title="wikilink">Sampling frequency</a></li>
<li><a class="uri" href="Multivibrator" title="wikilink">Multivibrator</a></li>
<li><a class="uri" href="LIDAR" title="wikilink">LIDAR</a></li>
<li><a class="uri" href="Time-of-flight" title="wikilink">Time-of-flight</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li><a class="uri" href="http://www.freepatentsonline.com/8324952.html">http://www.freepatentsonline.com/8324952.html</a></li>
<li><a href="http://forschung.unibw-muenchen.de/papers/3qvttjtopxog1op34ojasir046besi.pdf">traveling wave CMOS</a></li>
<li><a href="http://www.ece.mcmaster.ca/faculty/teds/PAPERS_folder/IEEE_RAWCON.pdf">traveling wave nFET cascode</a></li>
<li><a class="uri" href="http://www.febo.com/pages/hp5370b/">http://www.febo.com/pages/hp5370b/</a></li>
<li><a class="uri" href="http://www.g8wrb.org/useful-stuff/time/HP-5370B/">http://www.g8wrb.org/useful-stuff/time/HP-5370B/</a></li>
<li><a class="uri" href="http://ilrs.gsfc.nasa.gov/docs/timing/artyukh_time_interval_counter.pdf">http://ilrs.gsfc.nasa.gov/docs/timing/artyukh_time_interval_counter.pdf</a></li>
<li><a class="uri" href="http://ilrs.gsfc.nasa.gov/docs/time_interval_measurements.pdf">http://ilrs.gsfc.nasa.gov/docs/time_interval_measurements.pdf</a></li>
<li><a href="http://tycho.usno.navy.mil/ptti/1994/Vol%2026_22.pdf">http://tycho.usno.navy.mil/ptti/1994/Vol%2026_22.pdf</a></li>
<li><a class="uri" href="http://www.acam.de/fileadmin/Download/pdf/English/AN002_e.pdf">http://www.acam.de/fileadmin/Download/pdf/English/AN002_e.pdf</a></li>
<li>

<p>Università degli studi Roma Tre, Scuola Dottorale in Scienze Matematiche e Fisiche</p></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Digital_circuits" title="wikilink">Category:Digital circuits</a> <a href="Category:Digital_signal_processing" title="wikilink">Category:Digital signal processing</a> <a href="Category:Measuring_instruments" title="wikilink">Category:Measuring instruments</a> <a href="Category:Radio_electronics" title="wikilink">Category:Radio electronics</a> <a href="Category:Signal_processing" title="wikilink">Category:Signal processing</a> <a class="uri" href="Category:Time" title="wikilink">Category:Time</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3">For example, a Hewlett-Packard (now Agilent) 10811 crystal oven oscillator; <a class="uri" href="http://www.hparchive.com/Manuals/HP-10811AB-Manual.pdf">http://www.hparchive.com/Manuals/HP-10811AB-Manual.pdf</a><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6">, entry for <em>time interval counter</em>.<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12">. Kalisz states that the <a href="Stanford_Research_Systems" title="wikilink">Stanford Research Systems</a> SR620 uses this method.<a href="#fnref12">↩</a></li>
<li id="fn13"> stating, "Effectively, the interpolator magnifies the interpolation or uncertainty interval by the ratio of the charge and discharge currents."<a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"> stating, "In practice, the current sources and other circuitry used to build the interpolators are subject to operational variations over temperature and time. The 5360A's interpolators were in a special insulated cavity and had several adjustments. The 5335A uses a self-calibration technique that is not affected by temperature and needs no adjustments."<a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24">"Bruno Benedetto Rossi", George W. Clark, National Academic Press, Washington D.C. 1998, S.13<a href="#fnref24">↩</a></li>
<li id="fn25">"Noise Shaping Techniques for Analog and Time to Digital Converters Using Voltage Controlled Oscillators", Matthew A.Z. Straayer, Phd-Thesis, Massachusetts Institute of Technology (2008)<a href="#fnref25">↩</a></li>
<li id="fn26"></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30">Ten megahertz is a frequency that TTL logic in 1971 could handle. The high frequency divisions were handled with different technologies because high speed digital counters were uncommon in 1971. The first (500 MHz) divider stage is a 100 MHz synchronized <a class="uri" href="multivibrator" title="wikilink">multivibrator</a> to effect a divide by 5 circuit. The second (100nbsp;MHz) stage is a divide by 5 ring counter made from discrete emitter-coupled transistors. The last stage is a flip-flop.<a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
</ol>
</section>
</body>
</html>
