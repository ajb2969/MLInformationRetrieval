<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1176">Read-only Turing machine</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Read-only Turing machine</h1>
<hr/>

<p>A <strong>read-only Turing machine</strong> or <strong>Two-way deterministic finite-state automaton (2DFA)</strong> is class of models of <a class="uri" href="computability" title="wikilink">computability</a> that behave like a standard <a href="Turing_machine" title="wikilink">Turing machine</a> and can move in both directions across input, except cannot write to its input tape. The machine in its bare form is equivalent to a <a href="Deterministic_finite_automaton" title="wikilink">Deterministic finite automaton</a> in computational power, and therefore can only parse a <a href="regular_language" title="wikilink">regular language</a>.</p>
<h2 id="theory">Theory</h2>

<p>We define a standard Turing machine by the 9-tuple</p>

<p>

<math display="inline" id="Read-only_Turing_machine:0">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Q</mi>
    <mo>,</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo>,</mo>
    <mi mathvariant="normal">Γ</mi>
    <mo>,</mo>
    <mo>⊢</mo>
    <mo>,</mo>
    <mi mathvariant="normal">_</mi>
    <mo>,</mo>
    <mi>δ</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo>,</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <vector>
     <ci>Q</ci>
     <ci>normal-Σ</ci>
     <ci>normal-Γ</ci>
     <csymbol cd="latexml">proves</csymbol>
     <ci>normal-_</ci>
     <ci>δ</ci>
     <ci>s</ci>
     <ci>t</ci>
     <ci>r</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=(Q,\Sigma,\Gamma,\vdash,\_,\delta,s,t,r)
  </annotation>
 </semantics>
</math>

 where</p>
<ul>
<li>

<math display="inline" id="Read-only_Turing_machine:1">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is a finite set of <em>states</em>;</li>
<li>

<math display="inline" id="Read-only_Turing_machine:2">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

 is the finite set of the <em>input alphabet</em>;</li>
<li>

<math display="inline" id="Read-only_Turing_machine:3">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

 is the finite <em>tape alphabet</em>;</li>
<li>

<math display="inline" id="Read-only_Turing_machine:4">
 <semantics>
  <mrow>
   <mo>⊢</mo>
   <mo>∈</mo>
   <mi mathvariant="normal">Γ</mi>
   <mo>-</mo>
   <mi mathvariant="normal">Σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <in></in>
    <csymbol cd="unknown">Γ</csymbol>
    <minus></minus>
    <csymbol cd="unknown">Σ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash\in\Gamma-\Sigma
  </annotation>
 </semantics>
</math>

 is the <em>left endmarker</em>;</li>
<li>

<math display="inline" id="Read-only_Turing_machine:5">
 <semantics>
  <mrow>
   <mi mathvariant="normal">_</mi>
   <mo>∈</mo>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>-</mo>
    <mi mathvariant="normal">Σ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>normal-_</ci>
    <apply>
     <minus></minus>
     <ci>normal-Γ</ci>
     <ci>normal-Σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \_\in\Gamma-\Sigma
  </annotation>
 </semantics>
</math>

 is the <em>blank symbol</em>;</li>
<li>

<math display="inline" id="Read-only_Turing_machine:6">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mo>×</mo>
     <mi mathvariant="normal">Γ</mi>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>Q</mi>
     <mo>×</mo>
     <mi mathvariant="normal">Γ</mi>
     <mo>×</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>L</mi>
      <mo>,</mo>
      <mi>R</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>δ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>normal-Γ</ci>
     </apply>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>normal-Γ</ci>
      <set>
       <ci>L</ci>
       <ci>R</ci>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta:Q\times\Gamma\rightarrow Q\times\Gamma\times\{L,R\}
  </annotation>
 </semantics>
</math>

 is the <em>transition function</em>;</li>
<li>

<math display="inline" id="Read-only_Turing_machine:7">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in Q
  </annotation>
 </semantics>
</math>

 is the <em>start state</em>;</li>
<li>

<math display="inline" id="Read-only_Turing_machine:8">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>∈</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>t</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\in Q
  </annotation>
 </semantics>
</math>

 is the <em>accept state</em>;</li>
<li>

<math display="inline" id="Read-only_Turing_machine:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mo>∈</mo>
    <mi>Q</mi>
   </mrow>
   <mo rspace="5.8pt">,</mo>
   <mrow>
    <mi>r</mi>
    <mo>≠</mo>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <ci>r</ci>
     <ci>Q</ci>
    </apply>
    <apply>
     <neq></neq>
     <ci>r</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\in Q,~{}r\neq t
  </annotation>
 </semantics>
</math>

 is the <em>reject state</em>.</li>
</ul>

<p>So given initial state 

<math display="inline" id="Read-only_Turing_machine:10">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 reading symbol 

<math display="inline" id="Read-only_Turing_machine:11">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, we have a transition defined by 

<math display="inline" id="Read-only_Turing_machine:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>q</mi>
     <mo>,</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>q</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi>d</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>δ</ci>
     <interval closure="open">
      <ci>q</ci>
      <ci>a</ci>
     </interval>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>d</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(q,a)=(q_{2},a_{2},d)
  </annotation>
 </semantics>
</math>

 which replaces 

<math display="inline" id="Read-only_Turing_machine:13">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Read-only_Turing_machine:14">
 <semantics>
  <msub>
   <mi>a</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{2}
  </annotation>
 </semantics>
</math>

, transitions to state 

<math display="inline" id="Read-only_Turing_machine:15">
 <semantics>
  <msub>
   <mi>q</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{2}
  </annotation>
 </semantics>
</math>

, and moves the "read head" in direction 

<math display="inline" id="Read-only_Turing_machine:16">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 (left or right) to read the next input.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> In our 2DFA read-only machine, however, 

<math display="inline" id="Read-only_Turing_machine:17">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=a_{2}
  </annotation>
 </semantics>
</math>

 always.</p>

<p>This model is now equivalent to a DFA. The proof involves building a table which lists the result of backtracking with the control in any given state; at the start of the computation, this is simply the result of trying to move past the left endmarker in that state. On each rightward move, the table can be updated using the old table values and the character that was in the previous cell. Since the original head-control had some fixed number of states, and there is a fixed number of states in the tape alphabet, the table has fixed size, and can therefore be computed by another finite state machine. This machine, however, will never need to backtrack, and hence is a DFA.</p>
<h3 id="variants">Variants</h3>

<p>Several variants of this model are also equivalent to DFAs. In particular, the nondeterministic case (in which the transition from one state can be to multiple states given the same input) is reducible to a DFA.</p>

<p>Other variants of this model allow more <a href="Computational_complexity_theory" title="wikilink">computational complexity</a>. With a single infinite <a href="stack_(data_structure)" title="wikilink">stack</a> the model can parse (at least) any language that is computable by a Turing machine in <a href="linear_time" title="wikilink">linear time</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> In particular, the language {a<sup>n</sup>b<sup>n</sup>c<sup>n</sup>} can be parsed by an algorithm which verifies first that there are the same number of a's and b's, then rewinds and verifies that there are the same number of b's and c's. With the further aid of <a href="Nondeterministic_finite_automaton" title="wikilink">nondeterminism</a> the machine can parse any <a href="context-free_language" title="wikilink">context-free language</a>. With two infinite stacks the machine is <a href="Turing_equivalent" title="wikilink">Turing equivalent</a> and can parse any recursive <a href="formal_language" title="wikilink">formal language</a>.</p>

<p>If the machine is allowed to have multiple tape heads, it can parse any language in <a href="L_(complexity)" title="wikilink">L</a> or <a href="NL_(complexity)" title="wikilink">NL</a>, according to whether nondeterminism is allowed.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="applications">Applications</h2>

<p>A read-only Turing machine is used in the definition of a <a href="Universal_Turing_machine" title="wikilink">Universal Turing machine</a> to accept the definition of the Turing machine that is to be modelled, after which computation continues with a standard Turing machine.</p>

<p>In modern research, the model has become important in describing a new complexity class of <a href="Quantum_finite_automata" title="wikilink">Quantum finite automata</a> or deterministic <a href="Probabilistic_automaton" title="wikilink">probabilistic automata</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Computability" title="wikilink">Computability</a></li>
<li><a href="Turing_machine_equivalents" title="wikilink">Turing machine equivalents</a></li>
<li><a href="Stack_machine" title="wikilink">Stack machine</a></li>
<li><a href="Queue_automaton" title="wikilink">Queue automaton</a></li>
<li><a href="Quantum_computer" title="wikilink">Quantum computer</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.webber-labs.com/fl/lectures/ppt-slides/09.ppt">Lecture on finite-state automata by Adam Webber</a></li>
</ul>

<p>"</p>

<p><a href="Category:Turing_machine" title="wikilink">Category:Turing machine</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><em>Computational Complexity</em> by Wagner and Wechsung, section 13.3 (1986, ISBN 90-277-2146-7)<a href="#fnref2">↩</a></li>
<li id="fn3"><em>Computational Complexity</em> by Wagner and Wechsung, section 13.1 (1986, ISBN 90-277-2146-7)<a href="#fnref3">↩</a></li>
<li id="fn4"><mtpl></mtpl> <a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
