<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="206">Beap</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Beap</h1>
<hr/>

<p><strong>Beap</strong>, or <strong>bi-parental <a href="Heap_(data_structure)" title="wikilink">heap</a></strong>, is a <a href="data_structure" title="wikilink">data structure</a> where a node usually has two parents (unless it is the first or last on a level) and two children (unless it is on the last level). Unlike a heap, a beap allows <a class="uri" href="sublinear" title="wikilink">sublinear</a> search. The beap was introduced by <a href="Ian_Munro_(computer_scientist)" title="wikilink">Ian Munro</a> and <a href="Hendra_Suwanda" title="wikilink">Hendra Suwanda</a>. A related data structure is the <a href="Young_tableau" title="wikilink">Young tableau</a>.</p>
<figure><b>(Figure)</b>
<figcaption>Beap</figcaption>
</figure>
<h2 id="performance">Performance</h2>

<p>The height of the structure is approximately 

<math display="inline" id="Beap:0">
 <semantics>
  <msqrt>
   <mi>n</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{n}
  </annotation>
 </semantics>
</math>

. Also, assuming the last level is full, the number of elements on that level is also 

<math display="inline" id="Beap:1">
 <semantics>
  <msqrt>
   <mi>n</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{n}
  </annotation>
 </semantics>
</math>

. In fact, because of these properties all basic operations (insert, remove, find) run in 

<math display="inline" id="Beap:2">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msqrt>
     <mi>n</mi>
    </msqrt>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <root></root>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\sqrt{n})
  </annotation>
 </semantics>
</math>

 time on average. Find operations in the heap can be 

<math display="inline" id="Beap:3">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 in the worst case. Removal and insertion of new elements involves propagation of elements up or down (much like in a heap) in order to restore the beap invariant. An additional perk is that beap provides constant time access to the smallest element and 

<math display="inline" id="Beap:4">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msqrt>
     <mi>n</mi>
    </msqrt>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <root></root>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\sqrt{n})
  </annotation>
 </semantics>
</math>

 time for the maximum element.</p>

<p>Actually, a 

<math display="inline" id="Beap:5">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msqrt>
     <mi>n</mi>
    </msqrt>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <root></root>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\sqrt{n})
  </annotation>
 </semantics>
</math>

 find operation can be implemented if parent pointers at each node are maintained. You would start at the absolute bottom-most element of the top node (similar to the left-most child in a heap) and move either up or right to find the element of interest.</p>
<h2 id="references">References</h2>
<ul>
<li>J. Ian Munro and Hendra Suwanda. <a href="http://www.sciencedirect.com/science/article/pii/0022000080900379">"Implicit data structures for fast search and update"</a>. <em><a href="Journal_of_Computer_and_System_Sciences" title="wikilink">Journal of Computer and System Sciences</a></em>, 21(2):236-250, Oct.1980.</li>
</ul>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Heaps_(data_structures)" title="wikilink">Category:Heaps (data structures)</a></p>
</body>
</html>
