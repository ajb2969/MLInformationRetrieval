<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1337">Glossary of module theory</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Glossary of module theory</h1>
<hr/>

<p><a href="Module_theory" title="wikilink">Module theory</a> is the branch of mathematics in which <a href="module_(mathematics)" title="wikilink">modules</a> are studied. This is a glossary of some terms of the subject.</p>
<h2 id="basic-definition">Basic definition</h2>
<dl>
<dt>left R-module</dt>
<dd>A left module 

<math display="inline" id="Glossary_of_module_theory:0">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 over the <a href="ring_(mathematics)" title="wikilink">ring</a> 

<math display="inline" id="Glossary_of_module_theory:1">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is an <a href="abelian_group" title="wikilink">abelian group</a> 

<math display="inline" id="Glossary_of_module_theory:2">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>M</mi>
   <mo>,</mo>
   <mo>+</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>M</ci>
    <plus></plus>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M,+)
  </annotation>
 </semantics>
</math>

 with an operation 

<math display="inline" id="Glossary_of_module_theory:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mo>×</mo>
    <mi>M</mi>
   </mrow>
   <mo>→</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>M</ci>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\times M\to M
  </annotation>
 </semantics>
</math>

 (called scalar multipliction) satisfies the following condition:

<p>

<math display="block" id="Glossary_of_module_theory:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>r</mi>
     </mrow>
     <mo>,</mo>
     <mi>s</mi>
    </mrow>
    <mo>∈</mo>
    <mi>R</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
    <mo>∈</mo>
    <mi>M</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <list>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>r</ci>
      </apply>
      <ci>s</ci>
     </list>
     <ci>R</ci>
    </apply>
    <apply>
     <in></in>
     <list>
      <ci>m</ci>
      <ci>n</ci>
     </list>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall r,s\in R,m,n\in M
  </annotation>
 </semantics>
</math>

,</p>
<ol>
<li>

<math display="inline" id="Glossary_of_module_theory:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>m</mi>
      <mo>+</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>r</mi>
     <mi>m</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>r</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>r</ci>
     <apply>
      <plus></plus>
      <ci>m</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(m+n)=rm+rn
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Glossary_of_module_theory:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>s</mi>
      <mi>m</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>r</mi>
      <mi>s</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>r</ci>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>s</ci>
     </apply>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(sm)=(rs)m
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Glossary_of_module_theory:7">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+1.7pt">
     <msub>
      <mn>1</mn>
      <mi>R</mi>
     </msub>
    </mpadded>
    <mi>m</mi>
   </mrow>
   <mo>=</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">1</cn>
      <ci>R</ci>
     </apply>
     <ci>m</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1_{R}\,m=m
  </annotation>
 </semantics>
</math>

</li>
</ol>
</dd>
</dl>
<dl>
<dt>right R-module</dt>
<dd>A right module 

<math display="inline" id="Glossary_of_module_theory:8">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 over the ring 

<math display="inline" id="Glossary_of_module_theory:9">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is an abelian group 

<math display="inline" id="Glossary_of_module_theory:10">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>M</mi>
   <mo>,</mo>
   <mo>+</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>M</ci>
    <plus></plus>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M,+)
  </annotation>
 </semantics>
</math>

 with an operation 

<math display="inline" id="Glossary_of_module_theory:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mo>×</mo>
    <mi>R</mi>
   </mrow>
   <mo>→</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>M</ci>
     <ci>R</ci>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\times R\to M
  </annotation>
 </semantics>
</math>

 satisfies the following condition:

<p>

<math display="block" id="Glossary_of_module_theory:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>r</mi>
     </mrow>
     <mo>,</mo>
     <mi>s</mi>
    </mrow>
    <mo>∈</mo>
    <mi>R</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
    <mo>∈</mo>
    <mi>M</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <list>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>r</ci>
      </apply>
      <ci>s</ci>
     </list>
     <ci>R</ci>
    </apply>
    <apply>
     <in></in>
     <list>
      <ci>m</ci>
      <ci>n</ci>
     </list>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall r,s\in R,m,n\in M
  </annotation>
 </semantics>
</math>

,</p>
<ol>
<li>

<math display="inline" id="Glossary_of_module_theory:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>m</mi>
      <mo>+</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>r</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mi>r</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>n</mi>
     <mi>r</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>m</ci>
      <ci>n</ci>
     </apply>
     <ci>r</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>r</ci>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (m+n)r=mr+nr
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Glossary_of_module_theory:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>m</mi>
      <mi>s</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>r</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>s</mi>
      <mi>m</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>s</ci>
     </apply>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <ci>r</ci>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (ms)r=r(sm)
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Glossary_of_module_theory:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <msub>
     <mn>1</mn>
     <mi>R</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>m</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">1</cn>
      <ci>R</ci>
     </apply>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m1_{R}=m
  </annotation>
 </semantics>
</math>

</li>
</ol>
</dd>
</dl>
<dl>
<dd>Or it can be defined as the left module 

<math display="inline" id="Glossary_of_module_theory:16">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 over 

<math display="inline" id="Glossary_of_module_theory:17">
 <semantics>
  <msup>
   <mi>R</mi>
   <mtext>op</mtext>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <mtext>op</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{\textrm{op}}
  </annotation>
 </semantics>
</math>

 (the <a href="opposite_ring" title="wikilink">opposite ring</a> of 

<math display="inline" id="Glossary_of_module_theory:18">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

).
</dd>
</dl>
<dl>
<dt><a class="uri" href="bimodule" title="wikilink">bimodule</a></dt>
<dd>If an abelian group 

<math display="inline" id="Glossary_of_module_theory:19">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is both a left 

<math display="inline" id="Glossary_of_module_theory:20">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

-module and right 

<math display="inline" id="Glossary_of_module_theory:21">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

-module, it can be made to a 

<math display="inline" id="Glossary_of_module_theory:22">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mi>R</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>S</ci>
    <ci>R</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,R)
  </annotation>
 </semantics>
</math>

-bimodule if 

<math display="inline" id="Glossary_of_module_theory:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>m</mi>
       <mi>r</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>s</mi>
       <mi>m</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mpadded width="+1.7pt">
      <mi>r</mi>
     </mpadded>
     <mrow>
      <mo>∀</mo>
      <mi>s</mi>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi>S</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>r</mi>
     <mo>∈</mo>
     <mi>R</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>m</mi>
     <mo>∈</mo>
     <mi>M</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>s</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>r</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <ci>s</ci>
        <ci>m</ci>
       </apply>
       <ci>r</ci>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <ci>s</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <ci>S</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>r</ci>
      <ci>R</ci>
     </apply>
     <apply>
      <in></in>
      <ci>m</ci>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(mr)=(sm)r\,\forall s\in S,r\in R,m\in M
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
<dl>
<dt><a class="uri" href="submodule" title="wikilink">submodule</a></dt>
<dd>Given 

<math display="inline" id="Glossary_of_module_theory:24">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is a left 

<math display="inline" id="Glossary_of_module_theory:25">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

-module, a subgroup 

<math display="inline" id="Glossary_of_module_theory:26">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Glossary_of_module_theory:27">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is a submodule if 

<math display="inline" id="Glossary_of_module_theory:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mi>N</mi>
   </mrow>
   <mo>⊆</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>N</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   RN\subseteq N
  </annotation>
 </semantics>
</math>

 .
</dd>
</dl>
<dl>
<dt>homomorphism of 

<math display="inline" id="Glossary_of_module_theory:29">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

-modules</dt>
<dd>For two left 

<math display="inline" id="Glossary_of_module_theory:30">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

-modules 

<math display="inline" id="Glossary_of_module_theory:31">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>M</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{1},M_{2}
  </annotation>
 </semantics>
</math>

, a group homomorphism 

<math display="inline" id="Glossary_of_module_theory:32">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>M</mi>
     <mn>1</mn>
    </msub>
    <mo>→</mo>
    <msub>
     <mi>M</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ϕ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi:M_{1}\to M_{2}
  </annotation>
 </semantics>
</math>

 is called homomorphism of 

<math display="inline" id="Glossary_of_module_theory:33">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

-modules if 

<math display="inline" id="Glossary_of_module_theory:34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>r</mi>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>m</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>r</mi>
       <mi>m</mi>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>∀</mo>
      <mi>r</mi>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi>R</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>m</mi>
    <mo>∈</mo>
    <msub>
     <mi>M</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>r</ci>
       <ci>ϕ</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <apply>
        <times></times>
        <ci>r</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <ci>r</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <ci>R</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>m</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\phi(m)=\phi(rm)\,\forall r\in R,m\in M_{1}
  </annotation>
 </semantics>
</math>

 .
</dd>
</dl>
<dl>
<dt><a href="quotient_module" title="wikilink">quotient module</a></dt>
<dd>Given a left 

<math display="inline" id="Glossary_of_module_theory:35">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

-modules 

<math display="inline" id="Glossary_of_module_theory:36">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

, a submodule 

<math display="inline" id="Glossary_of_module_theory:37">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Glossary_of_module_theory:38">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>/</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>M</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M/N
  </annotation>
 </semantics>
</math>

 can be made to a left 

<math display="inline" id="Glossary_of_module_theory:39">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

-module by 

<math display="inline" id="Glossary_of_module_theory:40">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>r</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>m</mi>
       <mo>+</mo>
       <mi>N</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>r</mi>
      <mi>m</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>N</mi>
      </mpadded>
      <mrow>
       <mo>∀</mo>
       <mi>r</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi>R</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>m</mi>
    <mo>∈</mo>
    <mi>M</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>r</ci>
       <apply>
        <plus></plus>
        <ci>m</ci>
        <ci>N</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>r</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <times></times>
        <ci>N</ci>
        <apply>
         <csymbol cd="latexml">for-all</csymbol>
         <ci>r</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <ci>R</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>m</ci>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(m+N)=rm+N\,\forall r\in R,m\in M
  </annotation>
 </semantics>
</math>

 . It is also called a <strong>factor module</strong>.
</dd>
</dl>
<dl>
<dt><a href="annihilator_(ring_theory)" title="wikilink">annihilator</a></dt>
<dd>The annihilator of a left 

<math display="inline" id="Glossary_of_module_theory:41">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

-module 

<math display="inline" id="Glossary_of_module_theory:42">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is the set 

<math display="inline" id="Glossary_of_module_theory:43">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Ann</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>r</mi>
     <mo>∈</mo>
     <mi>R</mi>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>r</mi>
      <mi>m</mi>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mn>0</mn>
      </mpadded>
      <mrow>
       <mo>∀</mo>
       <mi>m</mi>
      </mrow>
     </mrow>
     <mo>∈</mo>
     <mi>M</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <mtext>Ann</mtext>
     <ci>M</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>r</ci>
      <ci>R</ci>
     </apply>
     <apply>
      <and></and>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <ci>r</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">0</cn>
        <apply>
         <csymbol cd="latexml">for-all</csymbol>
         <ci>m</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <in></in>
       <share href="#.cmml">
       </share>
       <ci>M</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textrm{Ann}(M):=\{r\in R|rm=0\,\forall m\in M\}
  </annotation>
 </semantics>
</math>

 . It is a (left) <a href="ideal_(ring_theory)" title="wikilink">ideal</a> of 

<math display="inline" id="Glossary_of_module_theory:44">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

.
</dd>
<dd>The annihilator of an element 

<math display="inline" id="Glossary_of_module_theory:45">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>∈</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>m</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\in M
  </annotation>
 </semantics>
</math>

 is the set 

<math display="inline" id="Glossary_of_module_theory:46">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Ann</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>r</mi>
     <mo>∈</mo>
     <mi>R</mi>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>r</mi>
      <mi>m</mi>
     </mrow>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <mtext>Ann</mtext>
     <ci>m</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>r</ci>
      <ci>R</ci>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>r</ci>
       <ci>m</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textrm{Ann}(m):=\{r\in R|rm=0\}
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
<h2 id="types-of-modules">Types of modules</h2>
<dl>
<dt><a href="finitely_generated_module" title="wikilink">finitely generated module</a></dt>
<dd>A module 

<math display="inline" id="Glossary_of_module_theory:47">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is finitely generated if there exist finitely many elements 

<math display="inline" id="Glossary_of_module_theory:48">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},...,x_{n}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Glossary_of_module_theory:49">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 such that every element of 

<math display="inline" id="Glossary_of_module_theory:50">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is a finite linear combination of those elements with coefficients from the scalar ring 

<math display="inline" id="Glossary_of_module_theory:51">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
<dl>
<dt><a href="cyclic_module" title="wikilink">cyclic module</a></dt>
<dd>A module is called a cyclic module if it is generated by one element.
</dd>
</dl>
<dl>
<dt><a href="free_module" title="wikilink">free module</a></dt>
<dd>A free module is a module that has a basis, or equivalently, one that is isomorphic to a direct sum of copies of the scalar ring 

<math display="inline" id="Glossary_of_module_theory:52">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

.
<dl>
<dt>basis</dt>
<dd>A basis of a module 

<math display="inline" id="Glossary_of_module_theory:53">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is a set of elements in 

<math display="inline" id="Glossary_of_module_theory:54">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 such that every element in the module can be expressed as a finite sum of elements in the basis in a unique way.
</dd>
</dl>
</dd>
</dl>
<dl>
<dt><a href="Projective_module" title="wikilink">Projective module</a></dt>
<dd>A 

<math display="inline" id="Glossary_of_module_theory:55">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

-module 

<math display="inline" id="Glossary_of_module_theory:56">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is called a projective module if given a 

<math display="inline" id="Glossary_of_module_theory:57">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

-module homomorphism 

<math display="inline" id="Glossary_of_module_theory:58">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>:</mo>
   <mrow>
    <mi>P</mi>
    <mo>→</mo>
    <mi>M</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>P</ci>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g:P\to M
  </annotation>
 </semantics>
</math>

, and a <a class="uri" href="surjective" title="wikilink">surjective</a> 

<math display="inline" id="Glossary_of_module_theory:59">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

-module homomorphism 

<math display="inline" id="Glossary_of_module_theory:60">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>N</mi>
    <mo>→</mo>
    <mi>M</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>N</ci>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:N\to M
  </annotation>
 </semantics>
</math>

, there exists a 

<math display="inline" id="Glossary_of_module_theory:61">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

-module homomorphism 

<math display="inline" id="Glossary_of_module_theory:62">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>:</mo>
   <mrow>
    <mi>P</mi>
    <mo>→</mo>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>h</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>P</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h:P\to N
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Glossary_of_module_theory:63">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>∘</mo>
    <mi>h</mi>
   </mrow>
   <mo>=</mo>
   <mi>g</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <ci>f</ci>
     <ci>h</ci>
    </apply>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\circ h=g
  </annotation>
 </semantics>
</math>

 .
</dd>
</dl>
<figure><b>(Figure)</b>
<figcaption>The characteristic property of projective modules is called <strong><a href="lift_(mathematics)" title="wikilink">lifting</a></strong>.</figcaption>
</figure>

<p>::The following conditions are equivalent:</p>

<p>:* The covariant functor 

<math display="inline" id="Glossary_of_module_theory:64">
 <semantics>
  <mrow>
   <msub>
    <mtext>Hom</mtext>
    <mi>R</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo>,</mo>
    <mo>-</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext>Hom</mtext>
     <ci>R</ci>
    </apply>
    <interval closure="open">
     <ci>P</ci>
     <minus></minus>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textrm{Hom}_{R}(P,-)
  </annotation>
 </semantics>
</math>

 is <a href="exact_functor" title="wikilink">exact</a>.</p>

<p>:* 

<math display="inline" id="Glossary_of_module_theory:65">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is a projective module.</p>

<p>:* Every short exact sequence 

<math display="inline" id="Glossary_of_module_theory:66">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mi>L</mi>
   <mo>→</mo>
   <msup>
    <mi>L</mi>
    <mo>′</mo>
   </msup>
   <mo>→</mo>
   <mi>P</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <ci>L</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>P</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\to L\to L^{\prime}\to P\to 0
  </annotation>
 </semantics>
</math>

 is split.</p>

<p>:* 

<math display="inline" id="Glossary_of_module_theory:67">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is a direct summand of free modules.</p>
<dl>
<dd>In particular, every free module is projective.
</dd>
</dl>
<dl>
<dt><a href="injective_module" title="wikilink">injective module</a></dt>
<dd>A 

<math display="inline" id="Glossary_of_module_theory:68">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

-module 

<math display="inline" id="Glossary_of_module_theory:69">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is called an injective module if given a 

<math display="inline" id="Glossary_of_module_theory:70">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

-module homomorphism <math>g:
</math></dd>
</dl>

<p>X \to Q, and an <a class="uri" href="injective" title="wikilink">injective</a> 

<math display="inline" id="Glossary_of_module_theory:71">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

-module homomorphism 

<math display="inline" id="Glossary_of_module_theory:72">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:X\to Y
  </annotation>
 </semantics>
</math>

, there exists a 

<math display="inline" id="Glossary_of_module_theory:73">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

-module homomorphism 

<math display="inline" id="Glossary_of_module_theory:74">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>:</mo>
   <mrow>
    <mi>Y</mi>
    <mo>→</mo>
    <mi>Q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>h</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>Y</ci>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h:Y\to Q
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Glossary_of_module_theory:75">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>∘</mo>
    <mi>h</mi>
   </mrow>
   <mo>=</mo>
   <mi>g</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <ci>f</ci>
     <ci>h</ci>
    </apply>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\circ h=g
  </annotation>
 </semantics>
</math>

 . </p>

<p>::The following conditions are equivalent:</p>

<p>:* The contravariant functor 

<math display="inline" id="Glossary_of_module_theory:76">
 <semantics>
  <mrow>
   <msub>
    <mtext>Hom</mtext>
    <mi>R</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>-</mo>
    <mo>,</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext>Hom</mtext>
     <ci>R</ci>
    </apply>
    <interval closure="open">
     <minus></minus>
     <ci>I</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textrm{Hom}_{R}(-,I)
  </annotation>
 </semantics>
</math>

 is <a href="exact_functor" title="wikilink">exact</a>.</p>

<p>:* 

<math display="inline" id="Glossary_of_module_theory:77">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 is a injective module.</p>

<p>:* Every short exact sequence 

<math display="inline" id="Glossary_of_module_theory:78">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mi>I</mi>
   <mo>→</mo>
   <mi>L</mi>
   <mo>→</mo>
   <msup>
    <mi>L</mi>
    <mo>′</mo>
   </msup>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <ci>I</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>L</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\to I\to L\to L^{\prime}\to 0
  </annotation>
 </semantics>
</math>

 is split.</p>
<dl>
<dt><a href="flat_module" title="wikilink">flat module</a></dt>
<dd>A 

<math display="inline" id="Glossary_of_module_theory:79">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

-module 

<math display="inline" id="Glossary_of_module_theory:80">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is called a flat module if the <a href="Tensor_product_of_modules" title="wikilink">tensor product</a> functor 

<math display="inline" id="Glossary_of_module_theory:81">
 <semantics>
  <mrow>
   <mo>-</mo>
   <msub>
    <mo>⊗</mo>
    <mi>R</mi>
   </msub>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>R</ci>
    </apply>
    <csymbol cd="unknown">F</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\otimes_{R}F
  </annotation>
 </semantics>
</math>

 is <a href="exact_functor" title="wikilink">exact</a>.
</dd>
<dd>In particular, every projective module is flat.
</dd>
</dl>
<dl>
<dt><a href="simple_module" title="wikilink">simple module</a></dt>
<dd>A simple module is a nonzero module whose only submodules are zero and itself.
</dd>
</dl>
<dl>
<dt><a href="indecomposable_module" title="wikilink">indecomposable module</a></dt>
<dd>An indecomposable module is a non-zero module that cannot be written as a direct sum of two non-zero submodules. Every simple module is indecomposable.
</dd>
</dl>
<dl>
<dt><a href="principal_indecomposable_module" title="wikilink">principal indecomposable module</a></dt>
<dd>A cyclic indecomposable projective module is known as a PIM.
</dd>
</dl>
<dl>
<dt><a href="semisimple_module" title="wikilink">semisimple module</a></dt>
<dd>A module is called semisimple if it is the direct sum of simple submodules.
</dd>
</dl>
<dl>
<dt><a href="faithful_module" title="wikilink">faithful module</a></dt>
<dd>A faithful module 

<math display="inline" id="Glossary_of_module_theory:82">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is one where the action of each nonzero 

<math display="inline" id="Glossary_of_module_theory:83">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>r</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\in R
  </annotation>
 </semantics>
</math>

 on 

<math display="inline" id="Glossary_of_module_theory:84">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is nontrivial (i.e. 

<math display="inline" id="Glossary_of_module_theory:85">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mi>x</mi>
   </mrow>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   rx\neq 0
  </annotation>
 </semantics>
</math>

 for some x in M). Equivalently, 

<math display="inline" id="Glossary_of_module_theory:86">
 <semantics>
  <mrow>
   <mtext>Ann</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>Ann</mtext>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textrm{Ann}(M)
  </annotation>
 </semantics>
</math>

 is the zero ideal.
</dd>
</dl>
<dl>
<dt><a href="Noetherian_module" title="wikilink">Noetherian module</a></dt>
<dd>A Noetherian module is a module such that every submodule is finitely generated. Equivalently, every increasing chain of submodules becomes stationary after finitely many steps.
</dd>
</dl>
<dl>
<dt><a href="Artinian_module" title="wikilink">Artinian module</a></dt>
<dd>An Artinian module is a module in which every decreasing chain of submodules becomes stationary after finitely many steps.
</dd>
</dl>
<dl>
<dt><a href="finite_length_module" title="wikilink">finite length module</a></dt>
<dd>A module which is both Artinian and Noetherian has additional special properties.
</dd>
</dl>
<dl>
<dt><a href="graded_module" title="wikilink">graded module</a></dt>
<dd>A module 

<math display="inline" id="Glossary_of_module_theory:87">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 over a graded ring 

<math display="inline" id="Glossary_of_module_theory:88">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⊕</mo>
     <mrow>
      <mi>n</mi>
      <mo>∈</mo>
      <mi>ℕ</mi>
     </mrow>
    </msub>
    <msub>
     <mi>A</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <in></in>
       <ci>n</ci>
       <ci>ℕ</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\bigoplus_{n\in\mathbb{N}}A_{n}
  </annotation>
 </semantics>
</math>

 is a graded module if 

<math display="inline" id="Glossary_of_module_theory:89">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 can be expressed as a direct sum 

<math display="inline" id="Glossary_of_module_theory:90">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⊕</mo>
    <mrow>
     <mi>i</mi>
     <mo>∈</mo>
     <mi>ℕ</mi>
    </mrow>
   </msub>
   <msub>
    <mi>M</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <in></in>
      <ci>i</ci>
      <ci>ℕ</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigoplus_{i\in\mathbb{N}}M_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Glossary_of_module_theory:91">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>M</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>⊆</mo>
   <msub>
    <mi>M</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mi>j</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}M_{j}\subseteq M_{i+j}
  </annotation>
 </semantics>
</math>

 .
</dd>
</dl>
<dl>
<dt><a href="invertible_module" title="wikilink">invertible module</a></dt>
<dd>Roughly synonymous to rank 1 projective module.
</dd>
</dl>
<dl>
<dt><a href="uniform_module" title="wikilink">uniform module</a></dt>
<dd>Module in which every two non-zero submodules have a non-zero intersection.
</dd>
</dl>
<dl>
<dt><a href="algebraically_compact_module" title="wikilink">algebraically compact module</a> (<a href="pure_injective_module" title="wikilink">pure injective module</a>)</dt>
<dd>Modules in which all systems of equations can be decided by finitary means. Alternatively, those modules which leave pure-exact sequence exact after applying Hom.
</dd>
</dl>
<dl>
<dt><a href="injective_cogenerator" title="wikilink">injective cogenerator</a></dt>
<dd>An injective module such that every module has a nonzero homomorphism into it.
</dd>
</dl>
<dl>
<dt><a href="irreducible_module" title="wikilink">irreducible module</a></dt>
<dd>synonymous to "simple module"
</dd>
</dl>
<dl>
<dt><a href="completely_reducible_module" title="wikilink">completely reducible module</a></dt>
<dd>synonymous to "semisimple module"
</dd>
</dl>
<h2 id="operations-on-modules">Operations on modules</h2>
<dl>
<dt><a href="Direct_sum_of_modules" title="wikilink">Direct sum of modules</a></dt>
</dl>
<dl>
<dt><a href="Tensor_product_of_modules" title="wikilink">Tensor product of modules</a></dt>
</dl>
<dl>
<dt><a href="Hom_functor" title="wikilink">Hom functor</a></dt>
</dl>
<dl>
<dt><a href="Ext_functor" title="wikilink">Ext functor</a></dt>
</dl>
<dl>
<dt><a href="Tor_functor" title="wikilink">Tor functor</a></dt>
</dl>
<dl>
<dt><a href="Essential_extension" title="wikilink">Essential extension</a></dt>
<dd>An extension in which every nonzero submodule of the larger module meets the smaller module in a nonzero submodule.
</dd>
</dl>
<dl>
<dt><a href="Injective_envelope" title="wikilink">Injective envelope</a></dt>
<dd>A maximal essential extension, or a minimal embedding in an injective module
</dd>
</dl>
<dl>
<dt><a href="Projective_cover" title="wikilink">Projective cover</a></dt>
<dd>A minimal surjection from a projective module.
</dd>
</dl>
<dl>
<dt><a href="Socle_(mathematics)" title="wikilink">Socle</a></dt>
<dd>The largest semisimple submodule
</dd>
</dl>
<dl>
<dt><a href="Radical_of_a_module" title="wikilink">Radical of a module</a></dt>
<dd>The intersection of the maximal submodules. For Artinian modules, the smallest submodule with semisimple quotient.
</dd>
</dl>
<h3 id="changing-scalars">Changing scalars</h3>
<dl>
<dt><a href="Restriction_of_scalars" title="wikilink">Restriction of scalars</a></dt>
<dd>Uses a ring homomorphism from <em>R</em> to <em>S</em> to convert <em>S</em>-modules to <em>R</em>-modules
</dd>
</dl>
<dl>
<dt><a href="Extension_of_scalars" title="wikilink">Extension of scalars</a></dt>
<dd>Uses a ring homomorphism from <em>R</em> to <em>S</em> to convert <em>R</em>-modules to <em>S</em>-modules
</dd>
</dl>
<dl>
<dt><a href="Localization_of_a_module" title="wikilink">Localization of a module</a></dt>
<dd>Converts <em>R</em> modules to <em>S</em> modules, where <em>S</em> is a <a href="localization_of_a_ring" title="wikilink">localization</a> of <em>R</em>
</dd>
</dl>
<dl>
<dt><a href="Endomorphism_ring" title="wikilink">Endomorphism ring</a></dt>
<dd>A left <em>R</em>-module is a right <em>S</em>-module where <em>S</em> is its endomorphism ring.
</dd>
</dl>
<h2 id="homological-algebra"><a href="Homological_algebra" title="wikilink">Homological algebra</a></h2>
<dl>
<dt><a href="Mittag-Leffler_condition" title="wikilink">Mittag-Leffler condition</a> (ML)<br/>
<a href="Short_five_lemma" title="wikilink">Short five lemma</a><br/>
<a href="Five_lemma" title="wikilink">Five lemma</a><br/>
<a href="Snake_lemma" title="wikilink">Snake lemma</a></dt>
</dl>
<h2 id="modules-over-special-rings">Modules over special rings</h2>
<dl>
<dt><a class="uri" href="D-module" title="wikilink">D-module</a></dt>
<dd>A module over a ring of differential operators.
</dd>
<dt><a href="Drinfeld_module" title="wikilink">Drinfeld module</a></dt>
<dd>A module over a ring of functions on algebraic curve with coefficients from a finite field.
</dd>
<dt><a href="Galois_module" title="wikilink">Galois module</a></dt>
<dd>A module over the group ring of a Galois group
</dd>
<dt><a href="Structure_theorem_for_finitely_generated_modules_over_a_principal_ideal_domain" title="wikilink">Structure theorem for finitely generated modules over a principal ideal domain</a></dt>
<dd>Finitely generated modules over PIDs are finite direct sums of primary cyclic modules.
</dd>
<dt><a href="Tate_module" title="wikilink">Tate module</a></dt>
<dd>A special kind of Galois module
</dd>
</dl>
<h2 id="miscellaneous">Miscellaneous</h2>
<dl>
<dt><a href="Rational_canonical_form" title="wikilink">Rational canonical form</a><br/>
<a href="elementary_divisor" title="wikilink">elementary divisor</a><br/>
<a href="invariant_(mathematics)" title="wikilink">invariants</a><br/>
<a href="fitting_ideal" title="wikilink">fitting ideal</a><br/>
normal forms for matrices<br/>
<a href="Jordan_Hölder_composition_series" title="wikilink">Jordan Hölder composition series</a><br/>
<a href="tensor_product" title="wikilink">tensor product</a></dt>
</dl>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Glossary_of_ring_theory" title="wikilink">Glossary of ring theory</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Glossaries_of_mathematics" title="wikilink">Module</a> <a href="Category:Module_theory" title="wikilink"> </a></p>
</body>
</html>
