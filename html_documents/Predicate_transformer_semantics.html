<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="624">Predicate transformer semantics</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Predicate transformer semantics</h1>
<hr/>

<p><strong><a href="Predicate_(mathematical_logic)" title="wikilink">Predicate</a> transformer semantics</strong> were introduced by <a href="Edsger_W._Dijkstra" title="wikilink">Dijkstra</a> in his seminal paper "<a href="Guarded_commands" title="wikilink">Guarded commands, nondeterminacy and formal derivation of programs</a>". They define the semantics of an <a href="imperative_programming" title="wikilink">imperative programming</a> paradigm by assigning to each <em>statement</em> in this language a corresponding <em>predicate transformer</em>: a <a href="total_function" title="wikilink">total function</a> between two <em><a href="Predicate_(mathematical_logic)" title="wikilink">predicates</a></em> on the state space of the statement. In this sense, predicate transformer semantics are a kind of <a href="denotational_semantics" title="wikilink">denotational semantics</a>. Actually, in <a href="guarded_commands" title="wikilink">guarded commands</a>, Dijkstra uses only one kind of predicate transformer: the well-known <strong>weakest preconditions</strong> (see below).</p>

<p>Moreover, predicate transformer semantics are a reformulation of <a href="Floyd–Hoare_logic" title="wikilink">Floyd–Hoare logic</a>. Whereas Hoare logic is presented as a <a href="deductive_system" title="wikilink">deductive system</a>, predicate transformer semantics (either by <strong>weakest-preconditions</strong> or by <strong>strongest-postconditions</strong> see below) are <strong>complete strategies</strong> to build <a href="Deductive_reasoning" title="wikilink">valid deductions</a> of Hoare logic. In other words, they provide an effective <a class="uri" href="algorithm" title="wikilink">algorithm</a> to reduce the problem of verifying a Hoare triple to the problem of proving a <a href="First-order_logic" title="wikilink">first-order formula</a>. Technically, predicate transformer semantics perform a kind of <a href="symbolic_execution" title="wikilink">symbolic execution</a> of statements into predicates: execution runs <em>backward</em> in the case of weakest-preconditions, or runs <em>forward</em> in the case of strongest-postconditions.</p>
<h2 id="weakest-preconditions">Weakest preconditions</h2>
<h3 id="definition">Definition</h3>

<p>Given a <em>statement</em> <em>S</em>, the <strong>weakest-precondition</strong> of <em>S</em> is a function mapping any <a class="uri" href="postcondition" title="wikilink">postcondition</a> <em>R</em> to a <a class="uri" href="precondition" title="wikilink">precondition</a>. Actually, the result of this function, denoted 

<math display="inline" id="Predicate_transformer_semantics:0">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <ci>p</ci>
    <interval closure="open">
     <ci>S</ci>
     <ci>R</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wp(S,R)
  </annotation>
 </semantics>
</math>

, is the "weakest" precondition on the initial state ensuring that execution of <em>S</em> terminates in a final state satisfying <em>R</em>.</p>

<p>More formally, let us use variable <em>x</em> to denote <em>abusively</em> the <a class="uri" href="tuple" title="wikilink">tuple</a> of variables involved in statement <em>S</em>. Then, a given <em>Hoare triple</em> 

<math display="inline" id="Predicate_transformer_semantics:1">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>P</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>Q</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <set>
     <ci>P</ci>
    </set>
    <ci>S</ci>
    <set>
     <ci>Q</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{P\}S\{Q\}
  </annotation>
 </semantics>
</math>

 is provable in <a href="Hoare_logic" title="wikilink">Hoare logic</a> for <strong>total correctness</strong> if and only if the first-order predicate below holds:</p>

<p>

<math display="block" id="Predicate_transformer_semantics:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <mi>P</mi>
   </mrow>
   <mo>⇒</mo>
   <mrow>
    <mi>w</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo>,</mo>
     <mi>Q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇒</ci>
    <list>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>x</ci>
     </apply>
     <ci>P</ci>
    </list>
    <apply>
     <times></times>
     <ci>w</ci>
     <ci>p</ci>
     <interval closure="open">
      <ci>S</ci>
      <ci>Q</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x,P\Rightarrow wp(S,Q)
  </annotation>
 </semantics>
</math>

</p>

<p>Formally, weakest-preconditions are defined recursively over the <a href="abstract_syntax" title="wikilink">abstract syntax</a> of statements. Actually, weakest-precondition semantics is a <a href="continuation-passing_style" title="wikilink">continuation-passing style</a> semantics of state transformers where the predicate in parameter is a continuation.</p>
<h3 id="skip">Skip</h3>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Predicate_transformer_semantics:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mtext>𝐬𝐤𝐢𝐩</mtext>
     <mo>,</mo>
     <mi>R</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">=</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>w</ci>
     <ci>p</ci>
     <interval closure="open">
      <mtext>skip</mtext>
      <ci>R</ci>
     </interval>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wp(\textbf{skip},R)\ =\ R
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
<h3 id="abort">Abort</h3>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Predicate_transformer_semantics:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mtext>𝐚𝐛𝐨𝐫𝐭</mtext>
     <mo>,</mo>
     <mi>R</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">=</mo>
   <mtext>𝐟𝐚𝐥𝐬𝐞</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>w</ci>
     <ci>p</ci>
     <interval closure="open">
      <mtext>abort</mtext>
      <ci>R</ci>
     </interval>
    </apply>
    <mtext>false</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wp(\textbf{abort},R)\ =\ \textbf{false}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
<h3 id="assignment">Assignment</h3>

<p>We give below two equivalent weakest-preconditions for the assignment statement. In these formulas, 

<math display="inline" id="Predicate_transformer_semantics:5">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>←</mo>
    <mi>E</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-←</ci>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R[x\leftarrow E]
  </annotation>
 </semantics>
</math>

 is a copy of <em>R</em> where <a href="Free_variables_and_bound_variables" title="wikilink">free occurrences</a> of <em>x</em> are replaced by <em>E</em>. Hence, here, expression <em>E</em> is implicitly coerced into a <em>valid term</em> of the underlying logic: it is thus a <em>pure</em> expression, totally defined, terminating and without side effect.</p>
<ul>
<li>version 1:</li>
</ul>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Predicate_transformer_semantics:6">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>E</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mo rspace="7.5pt">=</mo>
   <mo>∀</mo>
   <mi>y</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo>=</mo>
   <mi>E</mi>
   <mo>⇒</mo>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>←</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">w</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">y</csymbol>
    <eq></eq>
    <csymbol cd="unknown">E</csymbol>
    <ci>normal-⇒</ci>
    <csymbol cd="unknown">R</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-←</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wp(x:=E,R)\ =\ \forall y,y=E\Rightarrow R[x\leftarrow y]
  </annotation>
 </semantics>
</math>

 where <em>y</em> is a fresh variable (representing the final value of variable <em>x</em>)</p></td>
</tr>
</tbody>
</table>
<ul>
<li>version 2:</li>
</ul>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Predicate_transformer_semantics:7">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>E</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mo rspace="7.5pt">=</mo>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>←</mo>
    <mi>E</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">w</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">R</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-←</ci>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wp(x:=E,R)\ =\ R[x\leftarrow E]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>The first version avoids a potential duplication of <em>E</em> in <em>R</em>, whereas the second version is simpler when there is at most a single occurrence of <em>x</em> in <em>R</em>. The first version also reveals a deep duality between weakest-precondition and strongest-postcondition (see below).</p>

<p>An example of a valid calculation of <em>wp</em> (using version 2) for assignments with integer valued variable <em>x</em> is:</p>

<p>

<math display="block" id="Predicate_transformer_semantics:8">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi>w</mi>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>:=</mo>
       <mi>x</mi>
       <mo>-</mo>
       <mn>5</mn>
       <mo>,</mo>
       <mi>x</mi>
       <mo>></mo>
       <mn>10</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mn>5</mn>
      </mrow>
      <mo>></mo>
      <mn>10</mn>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="center">
     <mo>⇔</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>x</mi>
      <mo>></mo>
      <mn>15</mn>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">w</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="latexml">assign</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <minus></minus>
       <cn type="integer">5</cn>
       <ci>normal-,</ci>
       <csymbol cd="unknown">x</csymbol>
       <gt></gt>
       <cn type="integer">10</cn>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <eq></eq>
     <apply>
      <gt></gt>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <cn type="integer">5</cn>
      </apply>
      <cn type="integer">10</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <ci>normal-⇔</ci>
     <apply>
      <gt></gt>
      <ci>x</ci>
      <cn type="integer">15</cn>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{rcl}wp(x:=x-5,x>10)&=&x-5>10\\
&\Leftrightarrow&x>15\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>This means that in order for the postcondition <em>x &gt; 10</em> to be true after the assignment, the precondition <em>x &gt; 15</em> must be true before the assignment. This is also the "weakest precondition", in that it is the "weakest" restriction on the value of <em>x</em> which makes <em>x &gt; 10</em> true after the assignment.</p>
<h3 id="sequence">Sequence</h3>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Predicate_transformer_semantics:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>S</mi>
      <mn>1</mn>
     </msub>
     <mo>;</mo>
     <msub>
      <mi>S</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi>R</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">=</mo>
   <mrow>
    <mi>w</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>S</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mrow>
      <mi>w</mi>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>S</mi>
        <mn>2</mn>
       </msub>
       <mo>,</mo>
       <mi>R</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>w</ci>
     <ci>p</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>R</ci>
     </list>
    </apply>
    <apply>
     <times></times>
     <ci>w</ci>
     <ci>p</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>w</ci>
       <ci>p</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>S</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>R</ci>
       </interval>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wp(S_{1};S_{2},R)\ =\ wp(S_{1},wp(S_{2},R))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>For example,</p>

<p>

<math display="block" id="Predicate_transformer_semantics:10">
 <semantics>
  <mtable align="top" displaystyle="true">
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi>w</mi>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>:=</mo>
       <mi>x</mi>
       <mo>-</mo>
       <mn>5</mn>
       <mo>;</mo>
       <mi>x</mi>
       <mo>:=</mo>
       <mi>x</mi>
       <mo>*</mo>
       <mpadded width="+5pt">
        <mn>2</mn>
       </mpadded>
       <mo rspace="7.5pt">,</mo>
       <mi>x</mi>
       <mo>></mo>
       <mn>20</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>w</mi>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>:=</mo>
       <mi>x</mi>
       <mo>-</mo>
       <mn>5</mn>
       <mo>,</mo>
       <mi>w</mi>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>:=</mo>
        <mi>x</mi>
        <mo>*</mo>
        <mn>2</mn>
        <mo>,</mo>
        <mi>x</mi>
        <mo>></mo>
        <mn>20</mn>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>w</mi>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>:=</mo>
       <mi>x</mi>
       <mo>-</mo>
       <mn>5</mn>
       <mo>,</mo>
       <mi>x</mi>
       <mo>*</mo>
       <mn>2</mn>
       <mo>></mo>
       <mn>20</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>-</mo>
         <mn>5</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>*</mo>
       <mn>2</mn>
      </mrow>
      <mo>></mo>
      <mn>20</mn>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>x</mi>
      <mo>></mo>
      <mn>15</mn>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">w</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="latexml">assign</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <minus></minus>
       <cn type="integer">5</cn>
       <ci>normal-;</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="latexml">assign</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <times></times>
       <cn type="integer">2</cn>
       <ci>normal-,</ci>
       <csymbol cd="unknown">x</csymbol>
       <gt></gt>
       <cn type="integer">20</cn>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">w</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="latexml">assign</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <minus></minus>
       <cn type="integer">5</cn>
       <ci>normal-,</ci>
       <csymbol cd="unknown">w</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">x</csymbol>
        <csymbol cd="latexml">assign</csymbol>
        <csymbol cd="unknown">x</csymbol>
        <times></times>
        <cn type="integer">2</cn>
        <ci>normal-,</ci>
        <csymbol cd="unknown">x</csymbol>
        <gt></gt>
        <cn type="integer">20</cn>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">w</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="latexml">assign</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <minus></minus>
       <cn type="integer">5</cn>
       <ci>normal-,</ci>
       <csymbol cd="unknown">x</csymbol>
       <times></times>
       <cn type="integer">2</cn>
       <gt></gt>
       <cn type="integer">20</cn>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <eq></eq>
     <apply>
      <gt></gt>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <cn type="integer">5</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">20</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <eq></eq>
     <apply>
      <gt></gt>
      <ci>x</ci>
      <cn type="integer">15</cn>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[t]{rcl}wp(x:=x-5;x:=x*2\ ,\ x>20)&=&wp(x:=x-5,wp(x:=x*2,x>20))\\
&=&wp(x:=x-5,x*2>20)\\
&=&(x-5)*2>20\\
&=&x>15\end{array}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="conditional">Conditional</h3>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Predicate_transformer_semantics:11">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mtext>𝐢𝐟</mtext>
    </mpadded>
    <mpadded width="+5pt">
     <mi>E</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mtext>𝐭𝐡𝐞𝐧</mtext>
    </mpadded>
    <mpadded width="+5pt">
     <msub>
      <mi>S</mi>
      <mn>1</mn>
     </msub>
    </mpadded>
    <mpadded width="+5pt">
     <mtext>𝐞𝐥𝐬𝐞</mtext>
    </mpadded>
    <mpadded width="+5pt">
     <msub>
      <mi>S</mi>
      <mn>2</mn>
     </msub>
    </mpadded>
    <mtext>𝐞𝐧𝐝</mtext>
    <mo>,</mo>
    <mi>R</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mo rspace="7.5pt">=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo>⇒</mo>
    <mi>w</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>S</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi>R</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>E</mi>
    <mo>⇒</mo>
    <mi>w</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>S</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi>R</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">w</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>if</mtext>
     <csymbol cd="unknown">E</csymbol>
     <mtext>then</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
     <mtext>else</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">2</cn>
     </apply>
     <mtext>end</mtext>
     <ci>normal-,</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">w</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <csymbol cd="unknown">R</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <not></not>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">w</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-,</ci>
      <csymbol cd="unknown">R</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wp(\textbf{if}\ E\ \textbf{then}\ S_{1}\ \textbf{else}\ S_{2}\ \textbf{end},R)%
\ =\ (E\Rightarrow wp(S_{1},R))\wedge(\neg E\Rightarrow wp(S_{2},R))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>As example:</p>

<p>

<math display="inline" id="Predicate_transformer_semantics:12">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi>l</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mtext>𝐰𝐡𝐢𝐥𝐞</mtext>
    </mpadded>
    <mpadded width="+5pt">
     <mi>E</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mtext>𝐝𝐨</mtext>
    </mpadded>
    <mpadded width="+5pt">
     <mi>S</mi>
    </mpadded>
    <mtext>𝐝𝐨𝐧𝐞</mtext>
    <mo>,</mo>
    <mi>R</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mo rspace="7.5pt">=</mo>
   <mi>I</mi>
   <mo rspace="7.5pt">∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo>⇒</mo>
    <mi>w</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo>,</mo>
     <mi>I</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo rspace="7.5pt">∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>E</mi>
    <mo>⇒</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">w</csymbol>
    <csymbol cd="unknown">l</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>while</mtext>
     <csymbol cd="unknown">E</csymbol>
     <mtext>do</mtext>
     <csymbol cd="unknown">S</csymbol>
     <mtext>done</mtext>
     <ci>normal-,</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">I</csymbol>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">w</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">I</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <not></not>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wlp(\textbf{while}\ E\ \textbf{do}\ S\ \textbf{done},R)\ =\ I\wedge\ (E%
\Rightarrow wp(S,I))\wedge\ (\neg E\Rightarrow R)
  </annotation>
 </semantics>
</math>

 |} which simplifies to</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Predicate_transformer_semantics:13">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>A</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>∈</mo>
    <mi>ℕ</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <in></in>
     <ci>k</ci>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A_{k})_{k\in\mathbb{N}}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>This simply states that (1) the invariant must hold at the start of the loop; (2) additionally the invariant and guard taken together be strong enough to establish the weakest precondition necessary for the loop body to be able to re-establish the invariant; (3) finally, if and when the loop terminates, the fact that the loop guard is false along with the invariant should be able to establish the required postcondition.</p>
<h4 id="total-correctness">Total Correctness</h4>

<p>To show total correctness, we also have to show that the loop terminates. For this we define a <a href="well-founded_relation" title="wikilink">well-founded relation</a> on the space state denoted "wp(\textbf{while}\ E\ \textbf{do}\ S\ \textbf{done}, R)\ =\</p>

<p><code>          \begin{array}[t]{l} </code><br/>
<code>           I\\ </code><br/>
<code>           \wedge\ \forall y, ((E \wedge I) \Rightarrow wp(S,I \wedge x </code><code> </code></p>

<p>where <em>y</em> is a fresh tuple of variables |} Informally, in the above conjunction of three formulas:</p>
<ul>
<li>the first one means that invariant <em>I</em> must initially hold;</li>
<li>the second one means that the body of the loop (e.g. statement <em>S</em>) must preserve the invariant and decrease the variant: here, variable <em>y</em> represents the initial state of the body execution;</li>
<li>the last one means that <em>R</em> must be established at the end of the loop: here, variable <em>y</em> represents the final state of the loop.</li>
</ul>

<p>In predicate transformers semantics, <em>invariant</em> and <em>variant</em> are built by mimicking the <a href="Kleene_fixed-point_theorem" title="wikilink">Kleene fixed-point theorem</a>. Below, this construction is sketched in <a href="set_theory" title="wikilink">set theory</a>. We assume that <em>U</em> is a set denoting the state space. First, we define a family of subsets of <em>U</em> denoted 

<math display="inline" id="Predicate_transformer_semantics:14">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{k}
  </annotation>
 </semantics>
</math>

 by induction over <a href="natural_number" title="wikilink">natural number</a> <em>k</em>. Informally 

<math display="block" id="Predicate_transformer_semantics:15">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="right">
     <msub>
      <mi>A</mi>
      <mn>0</mn>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mi mathvariant="normal">∅</mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <msub>
      <mi>A</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo rspace="7.5pt">{</mo>
      <mi>y</mi>
      <mo>∈</mo>
      <mpadded width="+5pt">
       <mi>U</mi>
      </mpadded>
      <mo rspace="7.5pt" stretchy="false">|</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>E</mi>
        <mo>⇒</mo>
        <mi>w</mi>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>S</mi>
         <mo>,</mo>
         <mi>x</mi>
         <mo>∈</mo>
         <msub>
          <mi>A</mi>
          <mi>k</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>∧</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi mathvariant="normal">¬</mi>
        <mi>E</mi>
        <mo>⇒</mo>
        <mi>R</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>x</mi>
       <mo>←</mo>
       <mi>y</mi>
       <mo rspace="7.5pt" stretchy="false">]</mo>
      </mrow>
      <mo>}</mo>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">0</cn>
     </apply>
     <eq></eq>
     <emptyset></emptyset>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <csymbol cd="unknown">y</csymbol>
      <in></in>
      <csymbol cd="unknown">U</csymbol>
      <ci>normal-|</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">E</csymbol>
        <ci>normal-⇒</ci>
        <csymbol cd="unknown">w</csymbol>
        <csymbol cd="unknown">p</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">S</csymbol>
         <ci>normal-,</ci>
         <csymbol cd="unknown">x</csymbol>
         <in></in>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>A</ci>
          <ci>k</ci>
         </apply>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-)</ci>
       </cerror>
       <and></and>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <not></not>
        <csymbol cd="unknown">E</csymbol>
        <ci>normal-⇒</ci>
        <csymbol cd="unknown">R</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-←</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <ci>normal-}</ci>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{rcl}A_{0}&=&\emptyset\\
A_{k+1}&=&\left\{\ y\in U\ |\ ((E\Rightarrow wp(S,x\in A_{k}))\wedge(\neg E%
\Rightarrow R))[x\leftarrow y]\ \right\}\\
\end{array}
  </annotation>
 </semantics>
</math>

 represents the set of initial states that makes <em>R</em> satisfied after less than <em>k</em> iterations of the loop:</p>

<p>

<math display="inline" id="Predicate_transformer_semantics:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∃</mo>
     <mi>k</mi>
    </mrow>
    <mo>,</mo>
    <mi>x</mi>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi>A</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <exists></exists>
      <ci>k</ci>
     </apply>
     <ci>x</ci>
    </list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists k,x\in A_{k}
  </annotation>
 </semantics>
</math>

</p>

<p>Then, we define:</p>
<ul>
<li>invariant <em>I</em> as the predicate 

<math display="inline" id="Predicate_transformer_semantics:17">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo><</mo>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>y</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y<z
  </annotation>
 </semantics>
</math>


.</li>
<li>variant 

<math display="inline" id="Predicate_transformer_semantics:18">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mi>i</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo>∈</mo>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>j</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo>∈</mo>
    <msub>
     <mi>A</mi>
     <mi>j</mi>
    </msub>
    <mo>⇒</mo>
    <mi>i</mi>
    <mo><</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <exists></exists>
    <csymbol cd="unknown">i</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">y</csymbol>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>i</ci>
    </apply>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">z</csymbol>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">i</csymbol>
     <lt></lt>
     <csymbol cd="unknown">j</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists i,y\in A_{i}\wedge(\forall j,z\in A_{j}\Rightarrow i<j)
  </annotation>
 </semantics>
</math>

 as the proposition 

<math display="inline" id="Predicate_transformer_semantics:19">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mpadded width="+5pt">
      <mtext>𝐰𝐡𝐢𝐥𝐞</mtext>
     </mpadded>
     <mpadded width="+5pt">
      <mi>E</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mtext>𝐝𝐨</mtext>
     </mpadded>
     <mpadded width="+5pt">
      <mi>S</mi>
     </mpadded>
     <mtext>𝐝𝐨𝐧𝐞</mtext>
    </mrow>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <ci>p</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <mtext>while</mtext>
      <ci>E</ci>
      <mtext>do</mtext>
      <ci>S</ci>
      <mtext>done</mtext>
     </apply>
     <ci>R</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wp(\textbf{while}\ E\ \textbf{do}\ S\ \textbf{done},R)
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>With these definitions, 

<math display="inline" id="Predicate_transformer_semantics:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∃</mo>
     <mi>k</mi>
    </mrow>
    <mo>,</mo>
    <mi>x</mi>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi>A</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <exists></exists>
      <ci>k</ci>
     </apply>
     <ci>x</ci>
    </list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists k,x\in A_{k}
  </annotation>
 </semantics>
</math>

 reduces to formula 

<math display="inline" id="Predicate_transformer_semantics:21">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>𝐢𝐟</mi>
    </mpadded>
    <msub>
     <mi>E</mi>
     <mn>1</mn>
    </msub>
    <mo>→</mo>
    <mpadded width="+5pt">
     <msub>
      <mi>S</mi>
      <mn>1</mn>
     </msub>
    </mpadded>
    <mrow>
     <mo rspace="0.8pt" stretchy="false">[</mo>
     <mo rspace="7.5pt" stretchy="false">]</mo>
    </mrow>
    <mpadded width="+5pt">
     <mi mathvariant="normal">…</mi>
    </mpadded>
    <mrow>
     <mo rspace="0.8pt" stretchy="false">[</mo>
     <mo rspace="7.5pt" stretchy="false">]</mo>
    </mrow>
    <msub>
     <mi>E</mi>
     <mi>n</mi>
    </msub>
    <mo>→</mo>
    <mpadded width="+5pt">
     <msub>
      <mi>S</mi>
      <mi>n</mi>
     </msub>
    </mpadded>
    <mi>𝐟𝐢</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mtable align="top">
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>E</mi>
         <mn>1</mn>
        </msub>
        <mo>∨</mo>
        <mi mathvariant="normal">…</mi>
        <mo>∨</mo>
        <msub>
         <mi>E</mi>
         <mi>n</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mo rspace="7.5pt">∧</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>E</mi>
         <mn>1</mn>
        </msub>
        <mo>⇒</mo>
        <mi>w</mi>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>S</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <mi>R</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mi mathvariant="normal">…</mi>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mo rspace="7.5pt">∧</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>E</mi>
         <mi>n</mi>
        </msub>
        <mo>⇒</mo>
        <mi>w</mi>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>S</mi>
          <mi>n</mi>
         </msub>
         <mo>,</mo>
         <mi>R</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mtd>
    </mtr>
   </mtable>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">w</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">if</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-…</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <ci>normal-]</ci>
     </cerror>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>n</ci>
     </apply>
     <csymbol cd="unknown">fi</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <matrix>
     <matrixrow>
      <apply>
       <or></or>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <and></and>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>E</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-⇒</ci>
        <csymbol cd="unknown">w</csymbol>
        <csymbol cd="unknown">p</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>S</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-,</ci>
         <csymbol cd="unknown">R</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
     </matrixrow>
     <matrixrow>
      <ci>normal-…</ci>
     </matrixrow>
     <matrixrow>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <and></and>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>E</ci>
         <ci>n</ci>
        </apply>
        <ci>normal-⇒</ci>
        <csymbol cd="unknown">w</csymbol>
        <csymbol cd="unknown">p</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>S</ci>
          <ci>n</ci>
         </apply>
         <ci>normal-,</ci>
         <csymbol cd="unknown">R</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
     </matrixrow>
    </matrix>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wp(\mathbf{if}\ E_{1}\rightarrow S_{1}\ [\!]\ \ldots\ [\!]\ E_{n}\rightarrow S%
_{n}\ \mathbf{fi},R)\ =\begin{array}[t]{l}(E_{1}\vee\ldots\vee E_{n})\\
\wedge\ (E_{1}\Rightarrow wp(S_{1},R))\\
\ldots\\
\wedge\ (E_{n}\Rightarrow wp(S_{n},R))\\
\end{array}
  </annotation>
 </semantics>
</math>


.</p>

<p>However in practice, such an abstract construction can not be handled efficiently by theorem provers. Hence, loop invariants and variants are provided by human users, or are inferred by some <a href="abstract_interpretation" title="wikilink">abstract interpretation</a> procedure.</p>
<h3 id="non-deterministic-guarded-commands">Non-deterministic guarded commands</h3>

<p>Actually, Dijkstra's <a href="Guarded_Command_Language" title="wikilink">Guarded Command Language</a> (GCL) is an extension of the simple imperative language given until here with non-deterministic statements. Indeed, GCL aims to be a formal notation to define algorithms. Non-deterministic statements represent choices left to the actual implementation (in an effective programming language): properties proved on non-deterministic statements are ensured for all possible choices of implementation. In other words, weakest-preconditions of non-deterministic statements ensure</p>
<ul>
<li>that there exists a terminating execution (e.g. there exists an implementation),</li>
<li>and, that the final state of all terminating execution satisfies the postcondition.</li>
</ul>

<p>Notice that the definitions of weakest-precondition given above (in particular for <strong>while-loop</strong>) preserve this property.</p>
<h4 id="selection">Selection</h4>

<p>Selection is a generalization of <strong>if</strong> statement:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Predicate_transformer_semantics:22">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{i}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Here, when two guards 

<math display="inline" id="Predicate_transformer_semantics:23">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{j}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Predicate_transformer_semantics:24">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{i}
  </annotation>
 </semantics>
</math>

 are simultaneously true, then execution of this statement can run any of the associated statement 

<math display="inline" id="Predicate_transformer_semantics:25">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{j}
  </annotation>
 </semantics>
</math>

 or 

<math display="block" id="Predicate_transformer_semantics:26">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>P</mi>
   </mpadded>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-|</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\ |
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="repetition">Repetition</h4>

<p>Repetition is a generalization of <strong>while</strong> statement in a similar way.</p>
<h3 id="specification-statement-or-weakest-precondition-of-procedure-call">Specification statement (or weakest-precondition of procedure call)</h3>

<p><a href="Refinement_calculus" title="wikilink">Refinement calculus</a> extends non-deterministic statements with the notion of <em>specification statement</em>. Informally, this statement represents a procedure call in black box, where the body of the procedure is not known. Typically, using a syntax close to <a class="uri" href="B-Method" title="wikilink">B-Method</a>, a <strong>specification statement</strong> is written</p>

<p>

<math display="inline" id="Predicate_transformer_semantics:27">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo rspace="7.5pt">.</mo>
   <mrow>
    <mi>Q</mi>
    <mo>→</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <ci>y</ci>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <ci>Q</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">assign</csymbol>
      <share href="#.cmml">
      </share>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y.\ Q\rightarrow x:=y
  </annotation>
 </semantics>
</math>

 @

<math display="inline" id="Predicate_transformer_semantics:28">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>P</mi>
    </mpadded>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">w</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-|</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wp(P\ |
  </annotation>
 </semantics>
</math>

 where</p>
<ul>
<li><em>x</em> is the global variable modified by the statement,</li>
<li><em>P</em> is a predicate representing the precondition,</li>
<li><em>y</em> is a fresh logical variable, bound in <em>Q</em>, that represents the new value of <em>x</em> non-deterministically chosen by the statement,</li>
<li><em>Q</em> is a predicate representing a postcondition, or more exactly a guard: in <em>Q</em>, variable <em>x</em> represents the initial state and <em>y</em> denotes the final state.</li>
</ul>

<p>The weakest-precondition of <strong>specification statement</strong> is given by:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Predicate_transformer_semantics:29">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo rspace="7.5pt">.</mo>
   <mi>Q</mi>
   <mo>→</mo>
   <mi>x</mi>
   <mo>:=</mo>
   <mpadded width="+5pt">
    <mi>y</mi>
   </mpadded>
   <mo rspace="7.5pt">,</mo>
   <mi>R</mi>
   <mo rspace="7.5pt" stretchy="false">)</mo>
   <mo rspace="7.5pt">=</mo>
   <mi>P</mi>
   <mo>∧</mo>
   <mo>∀</mo>
   <mi>z</mi>
   <mo>,</mo>
   <mi>Q</mi>
   <mo stretchy="false">[</mo>
   <mi>y</mi>
   <mo>←</mo>
   <mi>z</mi>
   <mo stretchy="false">]</mo>
   <mo>⇒</mo>
   <mi>R</mi>
   <mo stretchy="false">[</mo>
   <mi>x</mi>
   <mo>←</mo>
   <mi>z</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">Q</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="latexml">assign</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">R</csymbol>
    <ci>normal-)</ci>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <and></and>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">z</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">Q</csymbol>
    <ci>normal-[</ci>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-←</ci>
    <csymbol cd="unknown">z</csymbol>
    <ci>normal-]</ci>
    <ci>normal-⇒</ci>
    <csymbol cd="unknown">R</csymbol>
    <ci>normal-[</ci>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-←</ci>
    <csymbol cd="unknown">z</csymbol>
    <ci>normal-]</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y.\ Q\rightarrow x:=y\ ,\ R)\ =\ P\wedge\forall z,Q[y\leftarrow z]\Rightarrow R%
[x\leftarrow z]
  </annotation>
 </semantics>
</math>

 @

<math display="inline" id="Predicate_transformer_semantics:30">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo>⇒</mo>
    <mi>w</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo>,</mo>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo>←</mo>
      <msub>
       <mi>x</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>y</mi>
      <mo>←</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>←</mo>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-,</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">w</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">Q</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-←</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>normal-]</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-←</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-]</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-←</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x_{0},(P\Rightarrow wp(S,Q[x\leftarrow x_{0}][y\leftarrow x]))[x%
\leftarrow x_{0}]
  </annotation>
 </semantics>
</math>

 where <em>z</em> is a fresh name</p></td>
</tr>
</tbody>
</table>

<p>Moreover, a statement <em>S</em> <strong>implements</strong> such a specification statement if and only if the following predicate is a tautology:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Predicate_transformer_semantics:31">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>


 where 

<math display="block" id="Predicate_transformer_semantics:32">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>P</mi>
    </mpadded>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">w</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-|</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wp(P\ |
  </annotation>
 </semantics>
</math>

 is a fresh name (denoting the initial state)</p></td>
</tr>
</tbody>
</table>

<p>Indeed, in such a case, the following property is ensured for all postcondition <em>R</em> (this is a direct consequence of <em>wp</em> monotonicity, see below):</p>

<p>

<math display="inline" id="Predicate_transformer_semantics:33">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo rspace="7.5pt">.</mo>
   <mi>Q</mi>
   <mo>→</mo>
   <mi>x</mi>
   <mo>:=</mo>
   <mpadded width="+5pt">
    <mi>y</mi>
   </mpadded>
   <mo rspace="7.5pt">,</mo>
   <mi>R</mi>
   <mo stretchy="false">)</mo>
   <mo>⇒</mo>
   <mi>w</mi>
   <mi>p</mi>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mi>R</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">Q</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="latexml">assign</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">R</csymbol>
    <ci>normal-)</ci>
    <ci>normal-⇒</ci>
    <csymbol cd="unknown">w</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">S</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">R</csymbol>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y.\ Q\rightarrow x:=y\ ,\ R)\Rightarrow wp(S,R)
  </annotation>
 </semantics>
</math>

 @

<math display="inline" id="Predicate_transformer_semantics:34">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi>l</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <ci>l</ci>
    <ci>p</ci>
    <interval closure="open">
     <ci>S</ci>
     <ci>R</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wlp(S,R)
  </annotation>
 </semantics>
</math>

</p>

<p>Informally, this last property ensures that any proof about some statement involving a specification remains valid when replacing this specification by any of its implementations.</p>
<h2 id="other-predicate-transformers">Other predicate transformers</h2>
<h3 id="weakest-liberal-precondition">Weakest liberal precondition </h3>

<p>An important variant of the weakest precondition is the <strong>weakest liberal precondition</strong> 

<math display="inline" id="Predicate_transformer_semantics:35">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>p</ci>
    <interval closure="open">
     <ci>S</ci>
     <ci>R</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   sp(S,R)
  </annotation>
 </semantics>
</math>

, which yields the weakest condition under which <em>S</em> either does not terminate or establishes <em>R</em>. It therefore differs from <em>wp</em> in not guaranteeing termination. Hence it corresponds to <a href="Hoare_logic" title="wikilink">Hoare logic</a> in partial correctness: for the statement language given above, <em>wlp</em> differs with <em>wp</em> only on <strong>while-loop</strong>, in not requiring a variant.</p>
<h3 id="strongest-postcondition">Strongest postcondition</h3>

<p>Given <em>S</em> a statement and <em>R</em> a <a class="uri" href="precondition" title="wikilink">precondition</a> (a predicate on the initial state), then 

<math display="inline" id="Predicate_transformer_semantics:36">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>P</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>Q</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <set>
     <ci>P</ci>
    </set>
    <ci>S</ci>
    <set>
     <ci>Q</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{P\}S\{Q\}
  </annotation>
 </semantics>
</math>


 is their <strong>strongest-postcondition</strong>: it implies any postcondition satisfied by the final state of any execution of S, for any initial state statisfying R. In other words, a Hoare triple 

<math display="block" id="Predicate_transformer_semantics:37">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>s</mi>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo>,</mo>
      <mi>P</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>⇒</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇒</ci>
    <list>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>p</ci>
      <interval closure="open">
       <ci>S</ci>
       <ci>P</ci>
      </interval>
     </apply>
    </list>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x,sp(S,P)\Rightarrow Q
  </annotation>
 </semantics>
</math>

 is provable in Hoare logic if and only if the predicate below hold:</p>

<p>

<math display="block" id="Predicate_transformer_semantics:38">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>P</mi>
    <mo>⇒</mo>
    <mi>w</mi>
    <mi>l</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo>,</mo>
     <mi>Q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mo rspace="7.5pt">⇔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo>,</mo>
     <mi>P</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⇒</mo>
    <mi>Q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">w</csymbol>
     <csymbol cd="unknown">l</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">Q</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⇔</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">s</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">P</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">Q</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall x,P\Rightarrow wlp(S,Q))\ \Leftrightarrow\ (\forall x,sp(S,P)%
\Rightarrow Q)
  </annotation>
 </semantics>
</math>

 Usually, <strong>strongest-postconditions</strong> are used in partial correctness. Hence, we have the following relation between weakest-liberal-preconditions and strongest-postconditions:</p>

<p>

<math display="inline" id="Predicate_transformer_semantics:39">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>E</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mo rspace="7.5pt">=</mo>
   <mo>∃</mo>
   <mi>y</mi>
   <mo>,</mo>
   <mi>x</mi>
   <mo>=</mo>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>←</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>∧</mo>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>←</mo>
    <mi>y</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <exists></exists>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-←</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <and></and>
    <csymbol cd="unknown">R</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-←</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   sp(x:=E,R)\ =\ \exists y,x=E[x\leftarrow y]\wedge R[x\leftarrow y]
  </annotation>
 </semantics>
</math>

</p>

<p>For example, on assignment we have:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="block" id="Predicate_transformer_semantics:40">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>x</mi>
    <mo>-</mo>
    <mn>5</mn>
    <mo>,</mo>
    <mi>x</mi>
    <mo>></mo>
    <mn>15</mn>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mo rspace="7.5pt">=</mo>
   <mo>∃</mo>
   <mi>y</mi>
   <mo>,</mo>
   <mi>x</mi>
   <mo>=</mo>
   <mi>y</mi>
   <mo>-</mo>
   <mn>5</mn>
   <mo>∧</mo>
   <mi>y</mi>
   <mo>></mo>
   <mpadded width="+5pt">
    <mn>15</mn>
   </mpadded>
   <mo rspace="7.5pt">⇔</mo>
   <mi>x</mi>
   <mo>></mo>
   <mn>10</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <minus></minus>
     <cn type="integer">5</cn>
     <ci>normal-,</ci>
     <csymbol cd="unknown">x</csymbol>
     <gt></gt>
     <cn type="integer">15</cn>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <exists></exists>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">y</csymbol>
    <minus></minus>
    <cn type="integer">5</cn>
    <and></and>
    <csymbol cd="unknown">y</csymbol>
    <gt></gt>
    <cn type="integer">15</cn>
    <ci>normal-⇔</ci>
    <csymbol cd="unknown">x</csymbol>
    <gt></gt>
    <cn type="integer">10</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   sp(x:=x-5,x>15)\ =\ \exists y,x=y-5\wedge y>15\ \Leftrightarrow\ x>10
  </annotation>
 </semantics>
</math>

 where <em>y</em> is fresh</p></td>
</tr>
</tbody>
</table>

<p>Above, the logical variable <em>y</em> represents the initial value of variable <em>x</em>. Hence,</p>

<p>

<math display="inline" id="Predicate_transformer_semantics:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>S</mi>
      <mn>1</mn>
     </msub>
     <mo>;</mo>
     <mpadded width="+5pt">
      <msub>
       <mi>S</mi>
       <mn>2</mn>
      </msub>
     </mpadded>
     <mo rspace="7.5pt">,</mo>
     <mi>R</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">=</mo>
   <mrow>
    <mi>s</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>S</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mrow>
      <mi>s</mi>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>S</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi>R</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>p</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>R</ci>
     </list>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>p</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>p</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>S</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>R</ci>
       </interval>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   sp(S_{1};S_{2}\ ,\ R)\ =\ sp(S_{2},sp(S_{1},R))
  </annotation>
 </semantics>
</math>


</p>

<p>On sequence, it appears that <em>sp</em> runs forward (whereas <em>wp</em> runs backward):</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="block" id="Predicate_transformer_semantics:42">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>P</mi>
    <mo>⇒</mo>
    <mi>Q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇒</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>P</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⇒</mo>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">Q</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⇒</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">T</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">P</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">T</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">Q</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall x,P\Rightarrow Q)\Rightarrow(\forall x,T(P)\Rightarrow T(Q))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
<h3 id="win-and-sin-predicate-transformers">Win and sin predicate transformers</h3>

<p><a href="Leslie_Lamport" title="wikilink">Leslie Lamport</a> has suggested <em>win</em> and <em>sin</em> as <em>predicate transformers</em> for <a href="concurrent_programming" title="wikilink">concurrent programming</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="predicate-transformers-properties">Predicate transformers properties</h2>

<p>This section presents some characteristic properties of predicate transformers.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Below, <em>T</em> denotes a predicate transformer (a function between two predicates on the state space) and <em>P</em> a predicate. For instance, <em>T(P)</em> may denote <em>wp(S,P)</em> or <em>sp(S,P)</em>. We keep <em>x</em> as the variable of the state space.</p>
<h3 id="monotonic">Monotonic</h3>

<p>Predicate transformers of interest (<em>wp</em>, <em>wlp</em>, and <em>sp</em>) are <a class="uri" href="monotonic" title="wikilink">monotonic</a>. A predicate transformer <em>T</em> is <strong>monotonic</strong> if and only if:</p>

<p>

<math display="block" id="Predicate_transformer_semantics:43">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐟𝐚𝐥𝐬𝐞</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">⇔</mo>
   <mi>𝐟𝐚𝐥𝐬𝐞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>𝐟𝐚𝐥𝐬𝐞</ci>
    </apply>
    <ci>𝐟𝐚𝐥𝐬𝐞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(\mathbf{false})\ \Leftrightarrow\ \mathbf{false}
  </annotation>
 </semantics>
</math>

</p>

<p>This property is related to the <a href="Hoare_logic#Consequence_rule" title="wikilink">consequence rule of Hoare logic</a>.</p>
<h3 id="strict">Strict</h3>

<p>A predicate transformer <em>T</em> is <strong>strict</strong> iff:</p>

<p>

<math display="inline" id="Predicate_transformer_semantics:44">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi>l</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>𝐟𝐚𝐥𝐬𝐞</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <ci>l</ci>
    <ci>p</ci>
    <interval closure="open">
     <ci>S</ci>
     <ci>𝐟𝐚𝐥𝐬𝐞</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wlp(S,\mathbf{false})
  </annotation>
 </semantics>
</math>

</p>

<p>For instance, <em>wp</em> is strict, whereas <em>wlp</em> is generally not. In particular, if statement <em>S</em> may not terminate then 

<math display="block" id="Predicate_transformer_semantics:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mi>l</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>𝐰𝐡𝐢𝐥𝐞</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>𝐭𝐫𝐮𝐞</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>𝐝𝐨</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>𝐬𝐤𝐢𝐩</mi>
      </mpadded>
      <mi>𝐝𝐨𝐧𝐞</mi>
     </mrow>
     <mo>,</mo>
     <mi>𝐟𝐚𝐥𝐬𝐞</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⇔</mo>
   <mi>𝐭𝐫𝐮𝐞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <times></times>
     <ci>w</ci>
     <ci>l</ci>
     <ci>p</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>𝐰𝐡𝐢𝐥𝐞</ci>
       <ci>𝐭𝐫𝐮𝐞</ci>
       <ci>𝐝𝐨</ci>
       <ci>𝐬𝐤𝐢𝐩</ci>
       <ci>𝐝𝐨𝐧𝐞</ci>
      </apply>
      <ci>𝐟𝐚𝐥𝐬𝐞</ci>
     </interval>
    </apply>
    <ci>𝐭𝐫𝐮𝐞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wlp(\mathbf{while}\ \mathbf{true}\ \mathbf{do}\ \mathbf{skip}\ \mathbf{done},%
\mathbf{false})\ \Leftrightarrow\mathbf{true}
  </annotation>
 </semantics>
</math>

 is satisfiable. We have</p>

<p>

<math display="block" id="Predicate_transformer_semantics:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐭𝐫𝐮𝐞</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">⇔</mo>
   <mi>𝐭𝐫𝐮𝐞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>𝐭𝐫𝐮𝐞</ci>
    </apply>
    <ci>𝐭𝐫𝐮𝐞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(\mathbf{true})\ \Leftrightarrow\ \mathbf{true}
  </annotation>
 </semantics>
</math>

 Indeed, <strong>true</strong> is a valid invariant of that loop.</p>
<h3 id="terminating">Terminating</h3>

<p>A predicate transformer <em>T</em> is <strong>terminating</strong> iff:</p>

<p>

<math display="inline" id="Predicate_transformer_semantics:47">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>𝐭𝐫𝐮𝐞</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <ci>p</ci>
    <interval closure="open">
     <ci>S</ci>
     <ci>𝐭𝐫𝐮𝐞</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wp(S,\mathbf{true})
  </annotation>
 </semantics>
</math>

</p>

<p>Actually, this terminology makes sense only for strict predicate transformers: indeed, 

<math display="block" id="Predicate_transformer_semantics:48">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>P</mi>
      <mo>∧</mo>
      <mi>Q</mi>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">⇔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>P</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∧</mo>
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Q</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <times></times>
     <ci>T</ci>
     <apply>
      <and></and>
      <ci>P</ci>
      <ci>Q</ci>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>P</ci>
     </apply>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>Q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(P\wedge Q)\ \Leftrightarrow\ (T(P)\wedge T(Q))
  </annotation>
 </semantics>
</math>

 is the weakest-precondition ensuring termination of <em>S</em>.</p>

<p>It seems that naming this property <strong>non-aborting</strong> would be more appropriate: in total correctness, non-termination is abortion, whereas in partial correctness, it is not.</p>
<h3 id="conjunctive">Conjunctive</h3>

<p>A predicate transformer <em>T</em> is <strong>conjunctive</strong> iff:</p>

<p>

<math display="inline" id="Predicate_transformer_semantics:49">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mo>.</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">w</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-,</ci>
     <ci>normal-.</ci>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wp(S,.)
  </annotation>
 </semantics>
</math>

</p>

<p>This is the case for 

<math display="block" id="Predicate_transformer_semantics:50">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>P</mi>
      <mo>∨</mo>
      <mi>Q</mi>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">⇔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>P</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∨</mo>
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Q</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <times></times>
     <ci>T</ci>
     <apply>
      <or></or>
      <ci>P</ci>
      <ci>Q</ci>
     </apply>
    </apply>
    <apply>
     <or></or>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>P</ci>
     </apply>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>Q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(P\vee Q)\ \Leftrightarrow\ (T(P)\vee T(Q))
  </annotation>
 </semantics>
</math>

, even if statement <em>S</em> is non-deterministic as a selection statement or a specification statement.</p>
<h3 id="disjunctive">Disjunctive</h3>

<p>A predicate transformer <em>T</em> is <strong>disjunctive</strong> iff:</p>

<p>

<math display="inline" id="Predicate_transformer_semantics:51">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mo>.</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">w</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-,</ci>
     <ci>normal-.</ci>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wp(S,.)
  </annotation>
 </semantics>
</math>


</p>

<p>This is generally not the case of 

<math display="block" id="Predicate_transformer_semantics:52">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>S</mi>
   </mpadded>
   <mo rspace="7.5pt">=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>𝐢𝐟</mi>
    </mpadded>
    <mi>𝐭𝐫𝐮𝐞</mi>
   </mrow>
   <mo>→</mo>
   <mi>x</mi>
   <mo>:=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mn>0</mn>
    </mpadded>
    <mrow>
     <mo rspace="0.8pt" stretchy="false">[</mo>
     <mo rspace="7.5pt" stretchy="false">]</mo>
    </mrow>
    <mi>𝐭𝐫𝐮𝐞</mi>
   </mrow>
   <mo>→</mo>
   <mi>x</mi>
   <mo>:=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mn>1</mn>
    </mpadded>
    <mi>𝐟𝐢</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>𝐢𝐟</ci>
      <ci>𝐭𝐫𝐮𝐞</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">0</cn>
      <list></list>
      <ci>𝐭𝐫𝐮𝐞</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">1</cn>
      <ci>𝐟𝐢</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\ =\ \mathbf{if}\ \mathbf{true}\rightarrow x:=0\ [\!]\ \mathbf{true}%
\rightarrow x:=1\ \mathbf{fi}
  </annotation>
 </semantics>
</math>

 when <em>S</em> is non-deterministic. Indeed, let us consider a non-deterministic statement <em>S</em> choosing an arbitrary boolean. This statement is given here as the following <em>selection statement</em>:</p>

<p>

<math display="inline" id="Predicate_transformer_semantics:53">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <ci>p</ci>
    <interval closure="open">
     <ci>S</ci>
     <ci>R</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wp(S,R)
  </annotation>
 </semantics>
</math>

</p>

<p>Then, 

<math display="inline" id="Predicate_transformer_semantics:54">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>←</mo>
    <mn>0</mn>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>∧</mo>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>←</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-←</ci>
     <cn type="integer">0</cn>
     <ci>normal-]</ci>
    </cerror>
    <and></and>
    <csymbol cd="unknown">R</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-←</ci>
     <cn type="integer">1</cn>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R[x\leftarrow 0]\wedge R[x\leftarrow 1]
  </annotation>
 </semantics>
</math>

 reduces to the formula 

<math display="inline" id="Predicate_transformer_semantics:55">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo rspace="7.5pt">,</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mn>0</mn>
    <mo>∨</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">w</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <cn type="integer">0</cn>
     <or></or>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wp(S,\ x=0\vee x=1)
  </annotation>
 </semantics>
</math>

.</p>

<p>Hence, 

<math display="inline" id="Predicate_transformer_semantics:56">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>=</mo>
    <mn>0</mn>
    <mo>∨</mo>
    <mn>0</mn>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>=</mo>
    <mn>0</mn>
    <mo>∨</mo>
    <mn>1</mn>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">0</cn>
     <eq></eq>
     <cn type="integer">0</cn>
     <or></or>
     <cn type="integer">0</cn>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <eq></eq>
     <cn type="integer">0</cn>
     <or></or>
     <cn type="integer">1</cn>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0=0\vee 0=1)\wedge(1=0\vee 1=1)
  </annotation>
 </semantics>
</math>


 reduces to the <em>tautology</em> 

<math display="inline" id="Predicate_transformer_semantics:57">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∨</mo>
   <mi>w</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">w</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
    <or></or>
    <csymbol cd="unknown">w</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wp(S,x=0)\vee wp(S,x=1)
  </annotation>
 </semantics>
</math>

</p>

<p>Whereas, the formula 

<math display="inline" id="Predicate_transformer_semantics:58">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>=</mo>
    <mn>0</mn>
    <mo>∧</mo>
    <mn>1</mn>
    <mo>=</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>=</mo>
    <mn>0</mn>
    <mo>∧</mo>
    <mn>1</mn>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">0</cn>
     <eq></eq>
     <cn type="integer">0</cn>
     <and></and>
     <cn type="integer">1</cn>
     <eq></eq>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
    <or></or>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <eq></eq>
     <cn type="integer">0</cn>
     <and></and>
     <cn type="integer">1</cn>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0=0\wedge 1=0)\vee(1=0\wedge 1=1)
  </annotation>
 </semantics>
</math>

 reduces to the <em>wrong proposition</em> 

<math display="block" id="Predicate_transformer_semantics:59">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>S</mi>
   </mpadded>
   <mo rspace="7.5pt">=</mo>
   <mpadded width="+5pt">
    <mi>𝐭𝐫𝐮𝐞</mi>
   </mpadded>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <eq></eq>
    <csymbol cd="unknown">true</csymbol>
    <ci>normal-|</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\ =\ \mathbf{true}\ |
  </annotation>
 </semantics>
</math>

.</p>

<p>The same counter-example can be reproduced using a <em>specification statement</em> (see above) instead:</p>

<p>

<math display="inline" id="Predicate_transformer_semantics:60">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo rspace="7.5pt">.</mo>
   <mrow>
    <mi>y</mi>
    <mo>∈</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>→</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <ci>y</ci>
    <apply>
     <and></and>
     <apply>
      <in></in>
      <ci>y</ci>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">assign</csymbol>
      <share href="#.cmml">
      </share>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y.\ y\in\{0,1\}\rightarrow x:=y
  </annotation>
 </semantics>
</math>

 @<span class="LaTeX">$y.\ y \in \{ 0, 1 \} \rightarrow x:=y$</span></p>
<h2 id="applications">Applications</h2>
<ul>
<li>Computations of weakest-preconditions are largely used to statically check <a href="Assertion_(computing)" title="wikilink">assertions in programs</a> using a theorem-prover (like <a href="Satisfiability_Modulo_Theories" title="wikilink">SMT-solvers</a> or <a href="Interactive_theorem_proving" title="wikilink">proof assistants</a>): see <a class="uri" href="Frama-C" title="wikilink">Frama-C</a> or <a href="ESC/Java" title="wikilink">ESC/Java2</a>.</li>
</ul>
<ul>
<li>Unlike many other semantic formalisms, predicate transformer semantics was not designed as an investigation into foundations of computation. Rather, it was intended to provide programmers with a methodology to develop their programs as "correct by construction" in a "calculation style". This "top-down" style was advocated by Dijkstra<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and <a href="Niklaus_Wirth" title="wikilink">N. Wirth</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> It has been formalized further by <a href="Ralph-Johan_Back" title="wikilink">R.-J. Back</a> and others in the <a href="refinement_calculus" title="wikilink">refinement calculus</a>. Some tools like <a class="uri" href="B-Method" title="wikilink">B-Method</a> now provide <a href="automated_reasoning" title="wikilink">automated reasoning</a> in order to promote this methodology.</li>
</ul>
<ul>
<li>In the meta-theory of <a href="Hoare_logic" title="wikilink">Hoare logic</a>, weakest-preconditions appear as a key notion in the proof of <a href="Gödel's_completeness_theorem" title="wikilink">relative completeness</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
</ul>
<h2 id="beyond-predicate-transformers">Beyond predicate transformers</h2>
<h3 id="weakest-preconditions-and-strongest-postconditions-of-imperative-expressions">Weakest-preconditions and strongest-postconditions of imperative expressions</h3>

<p>In predicate transformers semantics, expressions are restricted to terms of the logic (see above). However, this restriction seems too strong for most existing programming languages, where expressions may have side effects (call to a function having a side effect), may not terminate or abort (like <em>division by zero</em>). There are many proposals to extend weakest-preconditions or strongest-postconditions for imperative expression languages and in particular for <a href="Monad_(functional_programming)" title="wikilink">monads</a>.</p>

<p>Among them, <em>Hoare Type Theory</em> combines <a href="Hoare_logic" title="wikilink">Hoare logic</a> for a <a href="Haskell_(programming_language)" title="wikilink">Haskell</a>-like language, <a href="separation_logic" title="wikilink">separation logic</a> and <a href="type_theory" title="wikilink">type theory</a> .<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> This system is currently implemented as a <a class="uri" href="Coq" title="wikilink">Coq</a> library called <strong>Ynot</strong>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> In this language, <a href="Evaluation_strategy" title="wikilink">evaluation of expressions</a> corresponds to computations of <em>strongest-postconditions</em>.</p>
<h3 id="probabilistic-predicate-transformers">Probabilistic Predicate Transformers</h3>

<p><em>Probabilistic Predicate Transformers</em> are an extension of predicate transformers for <a href="Randomized_algorithm" title="wikilink">probabilistic programs</a>. Indeed, such programs have many applications in <a class="uri" href="cryptography" title="wikilink">cryptography</a> (hiding of information using some randomized noise), <a href="distributed_systems" title="wikilink">distributed systems</a> (symmetry breaking). <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Axiomatic_semantics" title="wikilink">Axiomatic semantics</a> — includes predicate transformer semantics</li>
<li><a href="Formal_semantics_of_programming_languages" title="wikilink">Formal semantics of programming languages</a> — an overview</li>
<li><a href="Hoare_logic" title="wikilink">Hoare logic</a> — the best-known axiomatic semantics</li>
<li><a href="Refinement_calculus" title="wikilink">Refinement calculus</a>, an extension of <a href="guarded_commands" title="wikilink">guarded commands</a> (and Hoare logic) exploiting the <a href="Lattice_(order)" title="wikilink">lattice</a> structure of predicate transformers (for "refinement" order).</li>
<li><a href="Dynamic_logic_(modal_logic)" title="wikilink">Dynamic logic</a>, where predicate transformers appear as modalities (in the sense of <a href="modal_logic" title="wikilink">modal logic</a>).</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li><a href="J._W._de_Bakker" title="wikilink">J. W. de Bakker</a>. <em>Mathematical theory of program correctness</em>. Prentice-Hall, 1980.</li>
<li><a href="Marcello_M._Bonsangue" title="wikilink">Marcello M. Bonsangue</a> and <a href="Joost_N._Kok" title="wikilink">Joost N. Kok</a>, <a href="http://dx.doi.org/10.1007/BF01213603"><em>The weakest precondition calculus: Recursion and duality</em></a>, <em><a href="Formal_Aspects_of_Computing" title="wikilink">Formal Aspects of Computing</a></em>, <strong>6</strong>(6):788–800, November 1994. <a href="Digital_object_identifier" title="wikilink">DOI</a> 10.1007/BF01213603.</li>
<li><a href="Edsger_W._Dijkstra" title="wikilink">Edsger W. Dijkstra</a>, <em>Guarded commands, nondeterminacy and formal derivation of program</em>. <em><a href="Communications_of_the_ACM" title="wikilink">Communications of the ACM</a></em>, 18(8):453–457, August 1975. <a href="http://doi.acm.org/10.1145/360933.360975">4</a></li>
<li><a href="Edsger_W._Dijkstra" title="wikilink">Edsger W. Dijkstra</a>. <em>A Discipline of Programming</em>. ISBN 0-613-92411-8. — A systematic introduction to a version of the guarded command language with many worked examples</li>
<li><a href="Edsger_W._Dijkstra" title="wikilink">Edsger W. Dijkstra</a> and <a href="Carel_S._Scholten" title="wikilink">Carel S. Scholten</a>. <em>Predicate Calculus and Program Semantics</em>. Springer-Verlag 1990 ISBN 0-387-96957-8 — A more abstract, formal and definitive treatment</li>
<li><a href="David_Gries" title="wikilink">David Gries</a>. <em>The Science of Programming</em>. Springer-Verlag 1981 ISBN 0-387-96480-0</li>
</ul>

<p>"</p>

<p><a href="Category:Formal_methods" title="wikilink">Category:Formal methods</a> <a href="Category:Program_logic" title="wikilink">Category:Program logic</a> <a href="Category:Dutch_inventions" title="wikilink">Category:Dutch inventions</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Leslie_Lamport" title="wikilink">Leslie Lamport</a>, "<em>win</em> and <em>sin</em>: Predicate Transformers for Concurrency". <em><a href="Association_for_Computing_Machinery" title="wikilink">ACM</a> Transactions on Programming Languages and Systems</em>, 12(3), July 1990. <a href="http://research.microsoft.com/users/lamport/pubs/pubs.html#lamport-win">1</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="Ralph-Johan_Back" title="wikilink">Ralph-Johan Back</a> and <a href="Joakim_von_Wright" title="wikilink">Joakim von Wright</a>, <em>Refinement Calculus: A Systematic Introduction</em>, 1st edition, 1998. ISBN 0-387-98417-8.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="Edsger_W._Dijkstra" title="wikilink">Edsger W. Dijkstra</a>, <em>A constructive approach to program correctness</em>, BIT Numerical Mathematics, 1968 - Springer<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="Niklaus_Wirth" title="wikilink">N. Wirth</a>, <em>Program development by stepwise refinement</em>, Communications of the ACM, 1971 [<a class="uri" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.90.408&amp;rep">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.90.408&amp;rep;</a>;=rep1&amp;type;=pdf]<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="http://coq.inria.fr/V8.2pl1/contribs/HoareTut.hoarelogicsemantics.html">Tutorial on Hoare Logic</a>: a <a class="uri" href="Coq" title="wikilink">Coq</a> library, giving a simple but formal proof that <a href="Hoare_logic" title="wikilink">Hoare logic</a> is sound and complete with respect to an <a href="operational_semantics" title="wikilink">operational semantics</a>.<a href="#fnref5">↩</a></li>
<li id="fn6">Aleksandar Nanevski, Greg Morrisett, Lars Birkedal. <em>Hoare Type Theory, Polymorphism and Separation</em>, Journal of Functional Programming, 18(5/6), 2008 <a href="http://ynot.cs.harvard.edu/papers/jfpsep07.pdf">2</a><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="http://ynot.cs.harvard.edu/">Ynot</a> a <a class="uri" href="Coq" title="wikilink">Coq</a> library implementing Hoare Type Theory.<a href="#fnref7">↩</a></li>
<li id="fn8">Carroll Morgan, Annabelle McIver , Karen Seidel. <em>Probabilistic Predicate Transformers</em>, ACM Transactions on Programming Languages and Systems, 1995 <a href="http://www.cse.unsw.edu.au/~carrollm/probs/Papers/Morgan-96d.pdf">3</a><a href="#fnref8">↩</a></li>
</ol>
</section>
</body>
</html>
