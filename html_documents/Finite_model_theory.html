<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1414">Finite model theory</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Finite model theory</h1>
<hr/>

<p><strong>Finite Model Theory</strong> (FMT) is a subarea of <a href="model_theory" title="wikilink">model theory</a> (MT). MT is the branch of <a href="mathematical_logic" title="wikilink">mathematical logic</a> which deals with the relation between a formal language (syntax) and its interpretations (semantics). FMT is a restriction of MT to <a href="interpretation_(logic)" title="wikilink">interpretations</a> of finite <a href="Structure_(mathematical_logic)" title="wikilink">structures</a>, which have a finite universe.</p>
<ul>
<li>Since many central theorems of MT do not hold when restricted to finite structures, FMT is quite different from MT in its methods of proof. Central results of classical model theory that fail for finite structures include the <a href="compactness_theorem" title="wikilink">compactness theorem</a>, <a href="Gödel's_completeness_theorem" title="wikilink">Gödel's completeness theorem</a>, and the method of <a href="ultraproduct" title="wikilink">ultraproducts</a> for <a href="first-order_logic" title="wikilink">first-order logic</a> (FO).</li>
<li>As MT is closely related to mathematical algebra, FMT became an "unusually effective"<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> instrument in computer science. In other words: "In the history of mathematical logic most interest has concentrated on infinite structures....Yet, the objects computers have and hold are always finite. To study computation we need a theory of finite structures."<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Thus the main application areas of FMT are: <a href="descriptive_complexity" title="wikilink">descriptive complexity theory</a>, <a href="database_theory" title="wikilink">database theory</a> and <a href="Formal_language" title="wikilink">formal language theory</a>.</li>
<li>FMT is mainly about discrimination of structures. The usual motivating question is whether a given class of structures can be described (up to isomorphism) in a given language. For instance, can all cyclic graphs be discriminated (from the non-cyclic ones) by a sentence of first-order logic? This can also be phrased as: is the property "cyclic" FO expressible?</li>
</ul>
<h2 id="basic-challenges">Basic Challenges</h2>

<p>A single structure can always be axiomatized in first-order logic, where axiomatized in a language L means described uniquely up to isomorphism by a single L-sentence. Some finite sets of structures can also be axiomatized in FO. However, FO is not sufficient to axiomatize any set containing infinite structures.</p>
<h3 id="characterisation-of-a-single-structure">Characterisation of a Single Structure</h3>

<p>Is a language L expressive enough to axiomatize a single finite structure S? </p>
<h4 id="problem">Problem</h4>

<p>A structure like (1) in the figure can be described by FO sentences like</p>
<ol>
<li>Every node has an edge to another node

<math display="block" id="Finite_model_theory:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>∀</mo>
     <mi>x</mi>
    </msub>
    <mrow>
     <msub>
      <mo>∃</mo>
      <mi>y</mi>
     </msub>
     <mrow>
      <mi>G</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <exists></exists>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <ci>G</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall_{x}\exists_{y}G(x,y).
  </annotation>
 </semantics>
</math>

</li>
<li>No node has an edge to itself

<math display="block" id="Finite_model_theory:1">
 <semantics>
  <mrow>
   <msub>
    <mo>∀</mo>
    <mrow>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⇒</mo>
    <mi>x</mi>
    <mo>≠</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">for-all</csymbol>
     <list>
      <ci>x</ci>
      <ci>y</ci>
     </list>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">G</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">x</csymbol>
     <neq></neq>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall_{x,y}(G(x,y)\Rightarrow x\neq y).
  </annotation>
 </semantics>
</math>

</li>
<li>There is at least one node that is connected to all others

<math display="block" id="Finite_model_theory:2">
 <semantics>
  <mrow>
   <msub>
    <mo>∃</mo>
    <mi>x</mi>
   </msub>
   <msub>
    <mo>∀</mo>
    <mi>y</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>≠</mo>
    <mi>y</mi>
    <mo>⇒</mo>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <exists></exists>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>y</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <neq></neq>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">G</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists_{x}\forall_{y}(x\neq y\Rightarrow G(x,y)).
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>However, these properties do not axiomatize the structure, since for structure (1') the above properties hold as well, yet structures (1) and (1') are not isomorphic.</p>

<p>Informally the question is whether by adding enough properties, these properties together describe exactly (1) and are valid (all together) for no other structure (up to isomorphism).</p>
<h4 id="approach">Approach</h4>

<p>For a single finite structure it is always possible to precisely describe the structure by a single FO sentence. The principle is illustrated here for a structure with one binary relation 

<math display="inline" id="Finite_model_theory:3">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 and without constants:</p>
<ol>
<li>say that there are at least 

<math display="inline" id="Finite_model_theory:4">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 elements

<math display="block" id="Finite_model_theory:5">
 <semantics>
  <mrow>
   <msub>
    <mi>φ</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
     <mrow>
      <mi>i</mi>
      <mo>≠</mo>
      <mi>j</mi>
     </mrow>
    </munder>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo>=</mo>
       <msub>
        <mi>x</mi>
        <mi>j</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>φ</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <and></and>
      <apply>
       <neq></neq>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <not></not>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{1}=\bigwedge_{i\neq j}\neg(x_{i}=x_{j})
  </annotation>
 </semantics>
</math>

</li>
<li>say that there are at most 

<math display="inline" id="Finite_model_theory:6">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 elements

<math display="block" id="Finite_model_theory:7">
 <semantics>
  <mrow>
   <msub>
    <mi>φ</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mo>∀</mo>
    <mi>y</mi>
   </msub>
   <munder>
    <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
    <mi>i</mi>
   </munder>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>φ</ci>
     <cn type="integer">2</cn>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>y</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <or></or>
     <ci>i</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{2}=\forall_{y}\bigvee_{i}(x_{i}=y)
  </annotation>
 </semantics>
</math>

</li>
<li>state every element of the relation 

<math display="inline" id="Finite_model_theory:8">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>



<math display="block" id="Finite_model_theory:9">
 <semantics>
  <mrow>
   <msub>
    <mi>φ</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>a</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>a</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>R</mi>
     </mrow>
    </munder>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>φ</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <and></and>
      <apply>
       <in></in>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>j</ci>
        </apply>
       </interval>
       <ci>R</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>R</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{3}=\bigwedge_{(a_{i},a_{j})\in R}R(x_{i},x_{j})
  </annotation>
 </semantics>
</math>

</li>
<li>state every non-element of the relation 

<math display="inline" id="Finite_model_theory:10">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>



<math display="block" id="Finite_model_theory:11">
 <semantics>
  <mrow>
   <msub>
    <mi>φ</mi>
    <mn>4</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>a</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>a</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∉</mo>
      <mi>R</mi>
     </mrow>
    </munder>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>φ</ci>
     <cn type="integer">4</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <and></and>
      <apply>
       <notin></notin>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>j</ci>
        </apply>
       </interval>
       <ci>R</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <not></not>
      <ci>R</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{4}=\bigwedge_{(a_{i},a_{j})\notin R}\neg R(x_{i},x_{j})
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>all for the same tuple 

<math display="inline" id="Finite_model_theory:12">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>.</mo>
   <mo>.</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-.</ci>
    <ci>normal-.</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}..x_{n}
  </annotation>
 </semantics>
</math>

, yielding the FO sentence 

<math display="inline" id="Finite_model_theory:13">
 <semantics>
  <mrow>
   <msub>
    <mo>∃</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
   </msub>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <mrow>
     <msub>
      <mo>∃</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>φ</mi>
        <mn>1</mn>
       </msub>
       <mo>∧</mo>
       <msub>
        <mi>φ</mi>
        <mn>2</mn>
       </msub>
       <mo>∧</mo>
       <msub>
        <mi>φ</mi>
        <mn>3</mn>
       </msub>
       <mo>∧</mo>
       <msub>
        <mi>φ</mi>
        <mn>4</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <exists></exists>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>normal-…</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <exists></exists>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <and></and>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <cn type="integer">4</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists_{x_{1}}\dots\exists_{x_{n}}(\varphi_{1}\land\varphi_{2}\land\varphi_{3%
}\land\varphi_{4})
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="extension-to-a-fixed-number-of-structures">Extension to a fixed Number of Structures</h4>

<p>The method of describing a single structure by means of a first-order sentence can easily be extended for any fixed number of structures. A unique description can be obtained by the disjunction of the descriptions for each structure. For instance, for 2 structures this would be</p>

<p>

<math display="block" id="Finite_model_theory:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo>∃</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
     </msub>
     <mrow>
      <mi mathvariant="normal">…</mi>
      <mrow>
       <msub>
        <mo>∃</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>φ</mi>
          <mn>1</mn>
         </msub>
         <mo>∧</mo>
         <msub>
          <mi>φ</mi>
          <mn>2</mn>
         </msub>
         <mo>∧</mo>
         <msub>
          <mi>φ</mi>
          <mn>3</mn>
         </msub>
         <mo>∧</mo>
         <msub>
          <mi>φ</mi>
          <mn>4</mn>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <msub>
      <mo>∃</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
     </msub>
     <mrow>
      <mi mathvariant="normal">…</mi>
      <mrow>
       <msub>
        <mo>∃</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>ϱ</mi>
          <mn>1</mn>
         </msub>
         <mo>∧</mo>
         <msub>
          <mi>ϱ</mi>
          <mn>2</mn>
         </msub>
         <mo>∧</mo>
         <msub>
          <mi>ϱ</mi>
          <mn>3</mn>
         </msub>
         <mo>∧</mo>
         <msub>
          <mi>ϱ</mi>
          <mn>4</mn>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <exists></exists>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>normal-…</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <exists></exists>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <and></and>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>φ</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>φ</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>φ</ci>
         <cn type="integer">3</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>φ</ci>
         <cn type="integer">4</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <exists></exists>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>normal-…</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <exists></exists>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <and></and>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ϱ</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ϱ</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ϱ</ci>
         <cn type="integer">3</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ϱ</ci>
         <cn type="integer">4</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists_{x_{1}}...\exists_{x_{n}}(\varphi_{1}\land\varphi_{2}\land\varphi_{3}%
\land\varphi_{4})\lor\exists_{x_{1}}...\exists_{x_{n}}(\varrho_{1}\land\varrho%
_{2}\land\varrho_{3}\land\varrho_{4}).
  </annotation>
 </semantics>
</math>

</p>
<h4 id="extension-to-an-infinite-structure">Extension to an infinite Structure</h4>

<p>By definition, a set containing an infinite structure falls outside the area that FMT deals with. Note that infinite structures can never be discriminated in FO because of the compactness theorem of classical MT: for every infinite model a non-isomorphic one can be found, but which has exactly the same FO properties.</p>

<p>The most famous example is probably <a href="Non-standard_model_of_arithmetic" title="wikilink">Skolem's theorem</a>, that there is a countable non-standard model of arithmetic.</p>
<h3 id="characterisation-of-a-class-of-structures">Characterisation of a Class of Structures</h3>

<p>Is a language L expressive enough to describe exactly those finite structures that have certain property P in common (up to isomorphism)? </p>
<h4 id="problem-1">Problem</h4>

<p>The descriptions given so far all specify the number of elements of the universe. Unfortunately most interesting sets of structures are not restricted to a certain size, like all graphs that are trees, are connected or are acyclic. Thus to discriminate a finite number of structures is of special importance.</p>
<h4 id="approach-1">Approach</h4>

<p>Instead of a general statement, the following is a sketch of a methodology to differentiate between structures that can and cannot be discriminated.</p>

<p><strong>1.</strong> The core idea is that whenever one wants to see if a Property P can be expressed in FO, one chooses structures A and B, where A does have P and B doesn't. If for A and B the same FO sentences hold, then P cannot be expressed in FO (else it can). In short:</p>

<p>

<math display="inline" id="Finite_model_theory:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>∈</mo>
    <mi>P</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>B</mi>
    <mo>∉</mo>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <ci>A</ci>
     <ci>P</ci>
    </apply>
    <apply>
     <notin></notin>
     <ci>B</ci>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in P,B\not\in P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Finite_model_theory:16">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>≡</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\equiv B
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Finite_model_theory:17">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>≡</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\equiv B
  </annotation>
 </semantics>
</math>

 is shorthand for 

<math display="inline" id="Finite_model_theory:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>⊧</mo>
    <mi>α</mi>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mi>B</mi>
    <mo>⊧</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <csymbol cd="latexml">models</csymbol>
     <ci>A</ci>
     <ci>α</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">models</csymbol>
     <ci>B</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\models\alpha\Leftrightarrow B\models\alpha
  </annotation>
 </semantics>
</math>

 for all FO-sentences α, and P represents the class of structures with property P.</p>

<p><strong>2.</strong> The methodology considers countably many subsets of the language, the union of which forms the language itself. For instance, for FO consider classes FO[m] for each m. For each m the above core idea then has to be shown. That is:</p>

<p>

<math display="inline" id="Finite_model_theory:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>∈</mo>
    <mi>P</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>B</mi>
    <mo>∉</mo>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <ci>A</ci>
     <ci>P</ci>
    </apply>
    <apply>
     <notin></notin>
     <ci>B</ci>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in P,B\not\in P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Finite_model_theory:20">
 <semantics>
  <mrow>
   <mi>A</mi>
   <msub>
    <mo>≡</mo>
    <mi>m</mi>
   </msub>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <equivalent></equivalent>
     <ci>m</ci>
    </apply>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\equiv_{m}B
  </annotation>
 </semantics>
</math>

</p>

<p>with a pair 

<math display="inline" id="Finite_model_theory:21">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>,</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>A</ci>
    <ci>B</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A,B
  </annotation>
 </semantics>
</math>

 for each 

<math display="inline" id="Finite_model_theory:22">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 and α (in ≡) from FO[m]. It may be appropriate to choose the classes FO[m] to form a partition of the language.</p>

<p><strong>3.</strong> One common way to define FO[m] is by means of the <a href="quantifier_rank" title="wikilink">quantifier rank</a> qr(α) of a FO formula α, which expresses the depth of quantifier nesting. For example for a formula in <a href="prenex_normal_form" title="wikilink">prenex normal form</a>, qr is simply the total number of its quantifiers. Then FO[m] can be defined as all FO formulas α with qr(α) ≤ m (or, if a partition is desired, as those FO formulas with quantifier rank equal to m).</p>

<p><strong>4.</strong> Thus it all comes down to showing 

<math display="inline" id="Finite_model_theory:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>⊧</mo>
    <mi>α</mi>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mi>B</mi>
    <mo>⊧</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <csymbol cd="latexml">models</csymbol>
     <ci>A</ci>
     <ci>α</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">models</csymbol>
     <ci>B</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\models\alpha\Leftrightarrow B\models\alpha
  </annotation>
 </semantics>
</math>

 on the subsets FO[m]. The main approach here is to use the algebraic characterization provided by <a href="Ehrenfeucht–Fraïssé_game" title="wikilink">Ehrenfeucht–Fraïssé games</a>. Informally, these take a single partial isomorphism on A and B and extend it m times, in order to either prove or disprove 

<math display="inline" id="Finite_model_theory:24">
 <semantics>
  <mrow>
   <mi>A</mi>
   <msub>
    <mo>≡</mo>
    <mi>m</mi>
   </msub>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <equivalent></equivalent>
     <ci>m</ci>
    </apply>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\equiv_{m}B
  </annotation>
 </semantics>
</math>

, dependent on who wins the game.</p>
<h4 id="example">Example</h4>

<p>We want to show that the property that the size of an orderered structure <strong>A</strong>=(A, ≤) is even, can not be expressed in FO.</p>

<p><strong>1.</strong> The idea is to pick <strong>A</strong> ∈ EVEN and <strong>B</strong> ∉ EVEN, where EVEN is the class of all structures of even size.</p>

<p><strong>2.</strong> We start with 2 ordered structures <strong>A<sub>2</sub></strong> and <strong>B<sub>2</sub></strong> with universes A<sub>2</sub> = {1, 2, 3, 4} and B<sub>2</sub> = {1, 2, 3, 4, 5}. Obviously <strong>A<sub>2</sub></strong> ∈ EVEN and <strong>B<sub>2</sub></strong> ∉ EVEN.</p>

<p><strong>3.</strong> For m = 2, we can now show* that in a 2-move <a href="Ehrenfeucht–Fraïssé_game" title="wikilink">Ehrenfeucht–Fraïssé game</a> on <strong>A<sub>2</sub></strong> and <strong>B<sub>2</sub></strong> the duplicator always wins, and thus <strong>A<sub>2</sub></strong> and <strong>B<sub>2</sub></strong> cannot be discriminated in FO[2], i.e. <strong>A<sub>2</sub></strong> 

<math display="inline" id="Finite_model_theory:25">
 <semantics>
  <mo>⊧</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">models</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \models
  </annotation>
 </semantics>
</math>

 α ⇔ <strong>B<sub>2</sub></strong> 

<math display="inline" id="Finite_model_theory:26">
 <semantics>
  <mo>⊧</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">models</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \models
  </annotation>
 </semantics>
</math>

 α for every α ∈ FO[2].</p>

<p><strong>4.</strong> Next we have to scale the structures up by increasing m. For example, for m = 3 we must find an <strong>A<sub>3</sub></strong> and <strong>B<sub>3</sub></strong> such that the duplicator always wins the 3-move game. This can be achieved by A<sub>3</sub> = {1, ..., 8} and B<sub>3</sub> = {1, ..., 9}. More generally, we can choose A<sub>m</sub> = {1, ..., 2<sup>m</sup>} and B<sub>m</sub> = {1, ..., 2<sup>m</sup>+1}; for any m the duplicator always wins the m-move game for this pair of structures*.</p>

<p><strong>5.</strong> Thus EVEN on finite ordered structures cannot be expressed in FO.</p>

<p>(*) Note that the proof of the result of the <a href="Ehrenfeucht–Fraïssé_game" title="wikilink">Ehrenfeucht–Fraïssé game</a> has been omitted, since it is not the main focus here.</p>
<h2 id="applications">Applications</h2>
<h3 id="database-theory">Database Theory</h3>

<p>A substantial fragment of <a class="uri" href="SQL" title="wikilink">SQL</a> (namely that which is effectively <a href="relational_algebra" title="wikilink">relational algebra</a>) is based on first-order logic (more precisely can be translated in <a href="domain_relational_calculus" title="wikilink">domain relational calculus</a> by means of <a href="Codd's_theorem" title="wikilink">Codd's theorem</a>), as the following example illustrates: Think of a database table "GIRLS" with the columns "FIRST_NAME" and "LAST_NAME". This corresponds to a binary relation, say G(f, l) on FIRST_NAME X LAST_NAME. The FO query <strong>{l : G('Judy', l)}</strong>, which returns all the last names where the first name is 'Judy', would look in SQL like this:</p>

<p><code>select LAST_NAME </code><br/>
<code>from GIRLS</code><br/>
<code>where FIRST_NAME = 'Judy'</code></p>

<p>Notice, we assume here, that all last names appear only once (or we should use SELECT DISTINCT since we assume that relations and answers are sets, not bags).</p>

<p>Next we want to make a more complex statement. Therefore in addition to the "GIRLS" table we have a table "BOYS" also with the columns "FIRST_NAME" and "LAST_NAME". Now we want to query the last names of all the girls that have the same last name as at least one of the boys. The FO query is <strong>{(f,l) : ∃h ( G(f, l) ∧ B(h, l) )}</strong>, and the corresponding SQL statement is:</p>

<p><code>select FIRST_NAME, LAST_NAME </code><br/>
<code>from GIRLS</code><br/>
<code>where LAST_NAME IN ( select LAST_NAME from BOYS );</code></p>

<p>Notice that in order to express the "∧" we introduced the new language element "IN" with a subsequent select statement. This makes the language more expressive for the price of higher difficulty to learn and implement. This is a common trade-off in formal language design. The way shown above ("IN") is by far not the only one to extend the language. An alternative way is e.g. to introduce a "JOIN" operator, that is:</p>

<p><code>select distinct g.FIRST_NAME, g.LAST_NAME </code><br/>
<code>from GIRLS g, BOYS b</code><br/>
<code>where g.LAST_NAME=b.LAST_NAME;</code></p>

<p>First-order logic is too restrictive for some database applications, for instance because of its inability to express <a href="transitive_closure" title="wikilink">transitive closure</a>. This has led to more powerful constructs being added to database query languages, such as <a href="recursive_WITH" title="wikilink">recursive WITH</a> in <a class="uri" href="SQL:1999" title="wikilink">SQL:1999</a>. More expressive logics, like <a href="fixpoint_logic" title="wikilink">fixpoint logics</a>, have therefore been studied in finite model theory because of their relevance to database theory and applications.</p>
<h3 id="querying-search">Querying &amp; Search</h3>

<p>Narrative data contains no defined relations. Thus the logical structure of text search queries can be expressed in Propositional Logic, like in:</p>

<p><code>("Java" AND NOT "island") OR ("C#" AND NOT "music")</code></p>

<p>Note that the challenges in full text search are different from database querying, like ranking of results.</p>
<h2 id="history">History</h2>
<ol>
<li><a href="Trakhtenbrot's_theorem" title="wikilink">Trakhtenbrot 1950</a>: failure of completeness theorem in FO,</li>
<li>Scholz 1952: characterisation of spectra in FO,</li>
<li><a href="Fagin's_theorem" title="wikilink">Fagin 1974</a>: the set of all properties expressible in existential second-order logic is precisely the complexity class NP,</li>
<li>Chandra, Harel 1979/ 80: fixed-point FO extension for db query languages capable of expressing transitive closure -&gt; queries as central objects of FMT.</li>
<li><a href="Neil_Immerman" title="wikilink">Immerman</a>, <a href="Moshe_Vardi" title="wikilink">Vardi</a> 1982: fixed point logic over ordered structures captures PTIME -&gt; descriptive complexity (... <a href="Immerman–Szelepcsényi_theorem" title="wikilink">Immerman–Szelepcsényi theorem</a>)</li>
<li><a href="Heinz-Dieter_Ebbinghaus" title="wikilink">Ebbinghaus</a>, Flum 1995: First comprehensive book "Finite Model Theory"</li>
<li><a href="Serge_Abiteboul" title="wikilink">Abiteboul</a>, Hull, <a href="Victor_Vianu" title="wikilink">Vianu</a> 1995: Book "Foundations of Databases"</li>
<li><a href="Neil_Immerman" title="wikilink">Immerman</a> 1999: Book "Descriptive Complexity"</li>
<li>Kuper, Libkin, Paredaens 2000: Book "Constraint Databases"</li>
<li>Darmstadt 2005/ Aachen2006: first international workshops on "Algorithmic Model Theory"</li>
</ol>
<h2 id="citations">Citations</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>

<p>Also suitable as a general introduction and overview.</p></li>
<li>Leonid Libkin. <a href="http://www.springer.com/cda/content/document/cda_downloaddocument/9783540212027-c1.pdf">Introductory chapter of "Elements of Finite Model Theory"</a>. Motivates three main application areas: databases, complexity and formal languages.</li>
<li>Jouko Väänänen. <a href="http://www.math.helsinki.fi/logic/people/jouko.vaananen/shortcourse.pdf">A Short Course on Finite Model Theory</a>. Department of Mathematics, University of Helsinki. Based on lectures from 1993-1994.</li>
<li>Anuj Dawar. <a href="http://www.cl.cam.ac.uk/~ad260/modth/slides.pdf">Infinite and Finite Model Theory</a>, slides, University of Cambridge, 2002.</li>
<li>

<p>Includes a list of open FMT problems.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Finite_model_theory" title="wikilink"> </a> <a href="Category:Model_theory" title="wikilink"> </a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
