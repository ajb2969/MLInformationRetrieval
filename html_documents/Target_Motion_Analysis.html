<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1499">Target Motion Analysis</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Target Motion Analysis</h1>
<hr/>

<p><strong>Target Motion Analysis</strong> (<strong>TMA</strong>) is a process to determine the position of a target using passive sensor information. Sensors like passive <em><a href="Radar" title="wikilink"> RADAR</a></em> and <em><a href="Sonar" title="wikilink"> SONAR</a></em> provide directional and occasionally frequency information. TMA is done by marking from which direction the sound comes at different times, and comparing the motion with that of the operator's own ship. Changes in relative motion are analyzed using standard geometrical techniques along with some assumptions about limiting cases. There are two different ways to execute TMA: manual and automated.</p>
<h2 id="manual-tma">Manual TMA</h2>

<p>Manual TMA methods involve computation executed by humans instead of computers. There exist several manual TMA methods such as: Ekelund Ranging, 1934 Rule, Spears Wheel etc.</p>
<h3 id="ekelund-ranging">Ekelund ranging</h3>

<p>One of the best known TMA techniques is Ekelund ranging.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It is a method that is specifically designed for a 2leg-1zig scenario. This method works by first estimating the bearing rates during the first 

<math display="inline" id="Target_Motion_Analysis:0">
 <semantics>
  <mrow>
   <mi>B</mi>
   <msup>
    <mi>R</mi>
    <mn>1</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   BR^{1}
  </annotation>
 </semantics>
</math>

 and second leg 

<math display="inline" id="Target_Motion_Analysis:1">
 <semantics>
  <mrow>
   <mi>B</mi>
   <msup>
    <mi>R</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   BR^{2}
  </annotation>
 </semantics>
</math>

. Secondly, one calculates the speed of advance along the line of sight with the target on the first 

<math display="inline" id="Target_Motion_Analysis:2">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>O</mi>
   <msup>
    <mi>A</mi>
    <mn>1</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SOA^{1}
  </annotation>
 </semantics>
</math>

and second leg 

<math display="inline" id="Target_Motion_Analysis:3">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>O</mi>
   <msup>
    <mi>A</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SOA^{2}
  </annotation>
 </semantics>
</math>

. The rule then states that the range of the target at the moment of manoeuvre is given by:</p>

<p>

<math display="block" id="Target_Motion_Analysis:4">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mstyle displaystyle="false">
    <mfrac>
     <mrow>
      <mrow>
       <mi>S</mi>
       <mi>O</mi>
       <msup>
        <mi>A</mi>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>S</mi>
       <mi>O</mi>
       <msup>
        <mi>A</mi>
        <mn>1</mn>
       </msup>
      </mrow>
     </mrow>
     <mrow>
      <mrow>
       <mi>B</mi>
       <msup>
        <mi>R</mi>
        <mn>1</mn>
       </msup>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>B</mi>
       <msup>
        <mi>R</mi>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
    </mfrac>
   </mstyle>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>S</ci>
       <ci>O</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>S</ci>
       <ci>O</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>B</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>R</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>B</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>R</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{2}=\textstyle\frac{SOA^{2}-SOA^{1}}{BR^{1}-BR^{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>To check the solution of a Ekelund Ranging solution there is also an iPhone app available.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="automated-tma">Automated TMA</h2>

<p>Automated TMA methods involve computations executed by computers. This allows for the simultaneous tracking of multiple targets. There exist several automated TMA methods such as: Maximum Likelihood Estimator (MLE), etc.</p>
<h3 id="maximum-likelihood-estimator-mle">Maximum Likelihood Estimator (MLE)</h3>

<p>The MLE method tries to fit the directional measurements (bearings) to a theoretical linear motion model of the target. The bearing function to be fitted is:</p>

<p>

<math display="block" id="Target_Motion_Analysis:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>β</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <mi>r</mi>
    <mi>c</mi>
    <mi>t</mi>
    <mi>a</mi>
    <mi>n</mi>
    <mn>2</mn>
    <mrow>
     <mo stretchy="false">(</mo>
     <mstyle displaystyle="false">
      <mfrac>
       <mrow>
        <mrow>
         <mrow>
          <msub>
           <mi>V</mi>
           <mi>y</mi>
          </msub>
          <mo>*</mo>
          <mi>t</mi>
         </mrow>
         <mo>+</mo>
         <msub>
          <mi>y</mi>
          <mn>0</mn>
         </msub>
        </mrow>
        <mo>-</mo>
        <mrow>
         <msup>
          <mi>y</mi>
          <mi>O</mi>
         </msup>
         <mi>B</mi>
         <mi>S</mi>
        </mrow>
       </mrow>
       <mrow>
        <mrow>
         <mrow>
          <msub>
           <mi>V</mi>
           <mi>x</mi>
          </msub>
          <mo>*</mo>
          <mi>t</mi>
         </mrow>
         <mo>+</mo>
         <msub>
          <mi>x</mi>
          <mn>0</mn>
         </msub>
        </mrow>
        <mo>-</mo>
        <msup>
         <mi>x</mi>
         <mi>O</mi>
        </msup>
       </mrow>
      </mfrac>
     </mstyle>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>β</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>r</ci>
     <ci>c</ci>
     <ci>t</ci>
     <ci>a</ci>
     <ci>n</ci>
     <cn type="integer">2</cn>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>V</ci>
          <ci>y</ci>
         </apply>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>y</ci>
         <ci>O</ci>
        </apply>
        <ci>B</ci>
        <ci>S</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>V</ci>
          <ci>x</ci>
         </apply>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>O</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta(t)=arctan2(\textstyle\frac{V_{y}*t+y_{0}-y^{O}BS}{V_{x}*t+x_{0}-x^{O}})
  </annotation>
 </semantics>
</math>

</p>

<p>If 

<math display="inline" id="Target_Motion_Analysis:6">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 measerements of 

<math display="inline" id="Target_Motion_Analysis:7">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mi>e</mi>
   <mi>t</mi>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>b</ci>
    <ci>e</ci>
    <ci>t</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   beta_{i}
  </annotation>
 </semantics>
</math>

 have been collected, the problem reduces to an overdetermined system of 

<math display="inline" id="Target_Motion_Analysis:8">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 non-linear equations. The state vector associated is</p>

<p>

<math display="block" id="Target_Motion_Analysis:9">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <msub>
      <mi>y</mi>
      <mn>0</mn>
     </msub>
     <msub>
      <mi>V</mi>
      <mi>x</mi>
     </msub>
     <msub>
      <mi>V</mi>
      <mi>y</mi>
     </msub>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=[x_{0}y_{0}V_{x}V_{y}]
  </annotation>
 </semantics>
</math>

 and can be solved by numerical estimation procedures like <em><a href="Gauss–Newton_algorithm" title="wikilink"> Gauss-Newton</a></em>.</p>
<h2 id="references">References</h2>
<references>
</references>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Tracking" title="wikilink">Category:Tracking</a> <a href="Category:Military_technology" title="wikilink">Category:Military technology</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">D.H. Wagner, W.C. Mylander and T.J. Sanders (1999). <em>Naval Operations Analysis</em>, United States of America: Naval Institute Press,. ISBN 9781591149507.<a href="#fnref1">↩</a></li>
<li id="fn2">SlimeSoft <a href="https://itunes.apple.com/us/app/ekelund-range/id305672427?mt=8">"Ekelund Range"</a>. Retrieved on 15 December 2014.<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
