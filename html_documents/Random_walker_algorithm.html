<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1879">Random walker algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Random walker algorithm</h1>
<hr>The '''random walker algorithm''' is an algorithm for [[image segmentation]].  In the first description of the algorithm,<ref name="grady2006random">L. Grady: [http://www.cns.bu.edu/~lgrady/grady2006random.pdf Random Walks for Image Segmentation], IEEE Trans. on Pattern Analysis and Machine Intelligence, Vol. 28, No. 11, pp. 1768–1783, Nov., 2006.</ref> a user interactively labels a small number of pixels with known labels (called seeds), e.g., "object" and "background". The unlabeled pixels are each imagined 
<p>to release a random walker, and the probability is computed that each pixel's random walker first arrives at a seed bearing each label, i.e., if a user places K seeds, each with a different label, then it is necessary to compute, for each pixel, the probability that a random walker leaving the pixel will first arrive at each seed. This computation may be determined analytically by solving a system of linear equations. After computing these probabilities for each pixel, the pixel is assigned to the label for which it is most likely to send a random walker. The image is modeled as a <a href="Graph_(mathematics)" title="wikilink">graph</a>, in which each pixel corresponds to a node which is connected to neighboring pixels by edges, and the edges are weighted to reflect the similarity between the pixels. Therefore, the random walk occurs on the weighted graph (see Doyle and Snell for an introduction to random walks on graphs<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>).</p>

<p>Although the initial algorithm was formulated as an interactive method for image segmentation, it has been extended to be a fully automatic algorithm, given a data fidelity term (e.g., an intensity prior).<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> It has also been extended to other applications.</p>

<p>The algorithm was initially published as a conference paper<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and later as a journal paper.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="mathematics">Mathematics</h2>

<p>Although the algorithm was described in terms of random walks, the probability that each node sends a random walker to the seeds may be calculated analytically by solving a sparse, positive-definite system of linear equations with the graph <a href="Laplacian_matrix_of_a_graph" title="wikilink">Laplacian matrix</a>, which we may represent with the variable 

<math display="inline" id="Random_walker_algorithm:0">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

. The algorithm was shown to apply to an arbitrary number of labels (objects), but the exposition here is in terms of two labels (for simplicity of exposition).</p>

<p>Assume that the image is represented by a <a href="Graph_(mathematics)" title="wikilink">graph</a>, with each node 

<math display="inline" id="Random_walker_algorithm:1">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

 associated with a pixel and each edge 

<math display="inline" id="Random_walker_algorithm:2">
 <semantics>
  <msub>
   <mi>e</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{ij}
  </annotation>
 </semantics>
</math>

 connecting neighboring pixels 

<math display="inline" id="Random_walker_algorithm:3">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Random_walker_algorithm:4">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{j}
  </annotation>
 </semantics>
</math>

. The edge weights are used to encode node similarity, which may be derived from differences in image intensity, color, texture or any other meaningful features. For example, using image intensity 

<math display="inline" id="Random_walker_algorithm:5">
 <semantics>
  <msub>
   <mi>g</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i}
  </annotation>
 </semantics>
</math>

 at node 

<math display="inline" id="Random_walker_algorithm:6">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

, it is common to use the edge weighting function</p>

<p>

<math display="block" id="Random_walker_algorithm:7">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>β</mi>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mi>g</mi>
            <mi>i</mi>
           </msub>
           <mo>-</mo>
           <msub>
            <mi>g</mi>
            <mi>j</mi>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <exp></exp>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>β</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>g</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>g</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{ij}=\exp{\left(-\beta(g_{i}-g_{j})^{2}\right)}.
  </annotation>
 </semantics>
</math>

</p>

<p>The nodes, edges and weights can then be used to construct the graph <a href="Laplacian_matrix_of_a_graph" title="wikilink">Laplacian matrix</a>.</p>

<p>The random walker algorithm optimizes the energy</p>

<p>

<math display="block" id="Random_walker_algorithm:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mi>T</mi>
    </msup>
    <mi>L</mi>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <msub>
      <mi>e</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </munder>
    <mrow>
     <msub>
      <mi>w</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <msup>
      <mrow>
       <mo>(</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>x</mi>
         <mi>j</mi>
        </msub>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>T</ci>
      </apply>
      <ci>L</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x)=x^{T}Lx=\sum_{e_{ij}}w_{ij}\left(x_{i}-x_{j}\right)^{2}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Random_walker_algorithm:9">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 represents a real-valued variable associated with each node in the graph and the optimization is constrained by 

<math display="inline" id="Random_walker_algorithm:10">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}=1
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Random_walker_algorithm:11">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}\in F
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Random_walker_algorithm:12">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}=0
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Random_walker_algorithm:13">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}\in B
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Random_walker_algorithm:14">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Random_walker_algorithm:15">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 represent the sets of foreground and background seeds, respectively. If we let 

<math display="inline" id="Random_walker_algorithm:16">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 represent the set of nodes which are seeded (i.e., 

<math display="inline" id="Random_walker_algorithm:17">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mi>F</mi>
    <mo>∪</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <union></union>
     <ci>F</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=F\cup B
  </annotation>
 </semantics>
</math>

) and 

<math display="inline" id="Random_walker_algorithm:18">
 <semantics>
  <mover accent="true">
   <mi>S</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{S}
  </annotation>
 </semantics>
</math>

 represent the set of unseeded nodes (i.e., 

<math display="inline" id="Random_walker_algorithm:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mo>∪</mo>
    <mover accent="true">
     <mi>S</mi>
     <mo>¯</mo>
    </mover>
   </mrow>
   <mo>=</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <union></union>
     <ci>S</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>S</ci>
     </apply>
    </apply>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\cup\overline{S}=V
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Random_walker_algorithm:20">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is the set of all nodes), then the optimum of the energy minimization problem is given by the solution to</p>

<p>

<math display="block" id="Random_walker_algorithm:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>L</mi>
      <mrow>
       <mover accent="true">
        <mi>S</mi>
        <mo>¯</mo>
       </mover>
       <mo>,</mo>
       <mover accent="true">
        <mi>S</mi>
        <mo>¯</mo>
       </mover>
      </mrow>
     </msub>
     <msub>
      <mi>x</mi>
      <mover accent="true">
       <mi>S</mi>
       <mo>¯</mo>
      </mover>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>L</mi>
       <mrow>
        <mover accent="true">
         <mi>S</mi>
         <mo>¯</mo>
        </mover>
        <mo>,</mo>
        <mi>S</mi>
       </mrow>
      </msub>
      <msub>
       <mi>x</mi>
       <mi>S</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <list>
       <apply>
        <ci>normal-¯</ci>
        <ci>S</ci>
       </apply>
       <apply>
        <ci>normal-¯</ci>
        <ci>S</ci>
       </apply>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <list>
        <apply>
         <ci>normal-¯</ci>
         <ci>S</ci>
        </apply>
        <ci>S</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{\overline{S},\overline{S}}x_{\overline{S}}=-L_{\overline{S},S}x_{S},
  </annotation>
 </semantics>
</math>

 where the subscripts are used to indicate the portion of the graph Laplacian matrix 

<math display="inline" id="Random_walker_algorithm:22">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 indexed by the respective sets.</p>

<p>To incorporate likelihood (unary) terms into the algorithm, it was shown in <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> that one may optimize the energy</p>

<p>

<math display="block" id="Random_walker_algorithm:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>x</mi>
       <mi>T</mi>
      </msup>
      <mi>L</mi>
      <mi>x</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>γ</mi>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mrow>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mn>1</mn>
            <mo>-</mo>
            <mi>x</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>T</mi>
         </msup>
         <mi>F</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mn>1</mn>
           <mo>-</mo>
           <mi>x</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msup>
          <mi>x</mi>
          <mi>T</mi>
         </msup>
         <mi>B</mi>
         <mi>x</mi>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <msub>
        <mi>e</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
      </munder>
      <mrow>
       <msub>
        <mi>w</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
       <msup>
        <mrow>
         <mo>(</mo>
         <mrow>
          <msub>
           <mi>x</mi>
           <mi>i</mi>
          </msub>
          <mo>-</mo>
          <msub>
           <mi>x</mi>
           <mi>j</mi>
          </msub>
         </mrow>
         <mo>)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>γ</mi>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mrow>
         <munder>
          <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
          <msub>
           <mi>v</mi>
           <mi>i</mi>
          </msub>
         </munder>
         <mrow>
          <msub>
           <mi>f</mi>
           <mi>i</mi>
          </msub>
          <msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mn>1</mn>
             <mo>-</mo>
             <msub>
              <mi>x</mi>
              <mi>i</mi>
             </msub>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
           <mn>2</mn>
          </msup>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <munder>
          <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
          <msub>
           <mi>v</mi>
           <mi>i</mi>
          </msub>
         </munder>
         <mrow>
          <msub>
           <mi>b</mi>
           <mi>i</mi>
          </msub>
          <msubsup>
           <mi>x</mi>
           <mi>i</mi>
           <mn>2</mn>
          </msubsup>
         </mrow>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>T</ci>
       </apply>
       <ci>L</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>γ</ci>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
           <ci>x</ci>
          </apply>
          <ci>T</ci>
         </apply>
         <ci>F</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <ci>x</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <ci>T</ci>
         </apply>
         <ci>B</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>i</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>j</ci>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>γ</ci>
       <apply>
        <plus></plus>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>v</ci>
           <ci>i</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <ci>i</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <minus></minus>
            <cn type="integer">1</cn>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>i</ci>
            </apply>
           </apply>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>v</ci>
           <ci>i</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>b</ci>
           <ci>i</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>i</ci>
           </apply>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x)=x^{T}Lx+\gamma\left((1-x)^{T}F(1-x)+x^{T}Bx\right)=\sum_{e_{ij}}w_{ij}%
\left(x_{i}-x_{j}\right)^{2}+\gamma\left(\sum_{v_{i}}f_{i}(1-x_{i})^{2}+\sum_{%
v_{i}}b_{i}x_{i}^{2}\right),
  </annotation>
 </semantics>
</math>

 for positive, diagonal matrices 

<math display="inline" id="Random_walker_algorithm:24">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Random_walker_algorithm:25">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

. Optimizing this energy leads to the system of linear equations</p>

<p>

<math display="block" id="Random_walker_algorithm:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msub>
        <mi>L</mi>
        <mrow>
         <mover accent="true">
          <mi>S</mi>
          <mo>¯</mo>
         </mover>
         <mo>,</mo>
         <mover accent="true">
          <mi>S</mi>
          <mo>¯</mo>
         </mover>
        </mrow>
       </msub>
       <mo>+</mo>
       <mrow>
        <mi>γ</mi>
        <msub>
         <mi>F</mi>
         <mrow>
          <mover accent="true">
           <mi>S</mi>
           <mo>¯</mo>
          </mover>
          <mo>,</mo>
          <mover accent="true">
           <mi>S</mi>
           <mo>¯</mo>
          </mover>
         </mrow>
        </msub>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>γ</mi>
        <msub>
         <mi>B</mi>
         <mrow>
          <mover accent="true">
           <mi>S</mi>
           <mo>¯</mo>
          </mover>
          <mo>,</mo>
          <mover accent="true">
           <mi>S</mi>
           <mo>¯</mo>
          </mover>
         </mrow>
        </msub>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
     <msub>
      <mi>x</mi>
      <mover accent="true">
       <mi>S</mi>
       <mo>¯</mo>
      </mover>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>L</mi>
        <mrow>
         <mover accent="true">
          <mi>S</mi>
          <mo>¯</mo>
         </mover>
         <mo>,</mo>
         <mi>S</mi>
        </mrow>
       </msub>
       <msub>
        <mi>x</mi>
        <mi>S</mi>
       </msub>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>γ</mi>
      <msub>
       <mi>F</mi>
       <mrow>
        <mover accent="true">
         <mi>S</mi>
         <mo>¯</mo>
        </mover>
        <mo>,</mo>
        <mover accent="true">
         <mi>S</mi>
         <mo>¯</mo>
        </mover>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <list>
        <apply>
         <ci>normal-¯</ci>
         <ci>S</ci>
        </apply>
        <apply>
         <ci>normal-¯</ci>
         <ci>S</ci>
        </apply>
       </list>
      </apply>
      <apply>
       <times></times>
       <ci>γ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <list>
         <apply>
          <ci>normal-¯</ci>
          <ci>S</ci>
         </apply>
         <apply>
          <ci>normal-¯</ci>
          <ci>S</ci>
         </apply>
        </list>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>γ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <list>
         <apply>
          <ci>normal-¯</ci>
          <ci>S</ci>
         </apply>
         <apply>
          <ci>normal-¯</ci>
          <ci>S</ci>
         </apply>
        </list>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <list>
         <apply>
          <ci>normal-¯</ci>
          <ci>S</ci>
         </apply>
         <ci>S</ci>
        </list>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>γ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <list>
        <apply>
         <ci>normal-¯</ci>
         <ci>S</ci>
        </apply>
        <apply>
         <ci>normal-¯</ci>
         <ci>S</ci>
        </apply>
       </list>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(L_{\overline{S},\overline{S}}+\gamma F_{\overline{S},\overline{S}}+%
\gamma B_{\overline{S},\overline{S}}\right)x_{\overline{S}}=-L_{\overline{S},S%
}x_{S}-\gamma F_{\overline{S},\overline{S}}.
  </annotation>
 </semantics>
</math>

 The set of seeded nodes, 

<math display="inline" id="Random_walker_algorithm:27">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, may be empty in this case (i.e., 

<math display="inline" id="Random_walker_algorithm:28">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>S</mi>
    <mo>¯</mo>
   </mover>
   <mo>=</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¯</ci>
     <ci>S</ci>
    </apply>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{S}=V
  </annotation>
 </semantics>
</math>

), but the presence of the positive diagonal matrices allows for a unique solution to this linear system.</p>

<p>For example, if the likelihood/unary terms are used to incorporate a color model of the object, then 

<math display="inline" id="Random_walker_algorithm:29">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}
  </annotation>
 </semantics>
</math>

 would represent the confidence that the color at node 

<math display="inline" id="Random_walker_algorithm:30">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

 would belong to object (i.e., a larger value of 

<math display="inline" id="Random_walker_algorithm:31">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}
  </annotation>
 </semantics>
</math>

 indicates greater confidence that 

<math display="inline" id="Random_walker_algorithm:32">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

 belonged to the object label) and 

<math display="inline" id="Random_walker_algorithm:33">
 <semantics>
  <msub>
   <mi>b</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>b</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{i}
  </annotation>
 </semantics>
</math>

 would represent the confidence that the color at node 

<math display="inline" id="Random_walker_algorithm:34">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

 belongs to the background.</p>
<h2 id="algorithm-interpretations">Algorithm interpretations</h2>

<p>The random walker algorithm was initially motivated by labeling a pixel as object/background based on the probability that a random walker dropped at the pixel would first reach an object (foreground) seed or a background seed. However, there are several other interpretations of this same algorithm which have appeared in.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h3 id="circuit-theory-interpretations">Circuit theory interpretations</h3>

<p>There are well-known connections between <a href="electrical_circuit" title="wikilink">electrical circuit</a> theory and random walks on graphs.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Consequently, the random walker algorithm has two different interpretations in terms of an electric circuit. In both cases, the graph is viewed as an electric circuit in which each edge is replaced by a passive linear <a class="uri" href="resistor" title="wikilink">resistor</a>. The resistance, 

<math display="inline" id="Random_walker_algorithm:35">
 <semantics>
  <msub>
   <mi>r</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{ij}
  </annotation>
 </semantics>
</math>

, associated with edge 

<math display="inline" id="Random_walker_algorithm:36">
 <semantics>
  <msub>
   <mi>e</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{ij}
  </annotation>
 </semantics>
</math>

 is set equal to 

<math display="inline" id="Random_walker_algorithm:37">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{ij}=\frac{1}{w_{ij}}
  </annotation>
 </semantics>
</math>

 (i.e., the edge weight equals <a href="electrical_conductance" title="wikilink">electrical conductance</a>).</p>

<p>In the first interpretation, each node associated with a background seed, 

<math display="inline" id="Random_walker_algorithm:38">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}\in B
  </annotation>
 </semantics>
</math>

, is tied directly to <a href="Ground_(electricity)" title="wikilink">ground</a> while each node associated with an object/foreground seed, 

<math display="inline" id="Random_walker_algorithm:39">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}\in F
  </annotation>
 </semantics>
</math>

 is attached to a unit <a href="direct_current" title="wikilink">direct current</a> ideal <a href="voltage_source" title="wikilink">voltage source</a> tied to ground (i.e., to establish a unit potential at each 

<math display="inline" id="Random_walker_algorithm:40">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}\in F
  </annotation>
 </semantics>
</math>

). The steady-state electrical circuit potentials established at each node by this circuit configuration will exactly equal the random walker probabilities. Specifically, the electrical potential, 

<math display="inline" id="Random_walker_algorithm:41">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 at node 

<math display="inline" id="Random_walker_algorithm:42">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

 will equal the probability that a random walker dropped at node 

<math display="inline" id="Random_walker_algorithm:43">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

 will reach an object/foreground node before reaching a background node.</p>

<p>In the second interpretation, labeling a node as object or background by thresholding the random walker probability at 0.5 is equivalent to labeling a node as object or background based on the relative effective conductance between the node and the object or background seeds. Specifically, if a node has a higher effective conductance (lower effective resistance) to the object seeds than to the background seeds, then node is labeled as object. If a node has a higher effective conductance (lower effective resistance) to the background seeds than to the object seeds, then node is labeled as background.</p>
<h2 id="extensions">Extensions</h2>

<p>The traditional random walker algorithm described above has been extended in several ways:</p>
<ul>
<li>Random walks with restart<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></li>
<li>Alpha matting<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></li>
<li>Threshold selection<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></li>
<li>Soft inputs<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></li>
<li>Run on a presegmented image<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></li>
<li>Scale space random walk<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></li>
<li>Fast random walker using offline <a class="uri" href="precomputation" title="wikilink">precomputation</a> <ref>L. Grady, A.K. Sinop: Fast approximate random walker segmentation using eigenvector</ref></li>
</ul>

<p>precomputation. In IEEE Conf. CVPR, pp. 1–8, 2008<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<ul>
<li>Generalized random walks allowing flexible compatibility functions <a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></li>
<li>Power watersheds unifying graph cuts, random walker and shortest path <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></li>
<li>Random walker watersheds <a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></li>
<li>Multivariate Gaussian conditional random field <a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></li>
</ul>
<h2 id="applications">Applications</h2>

<p>Beyond image segmentation, the random walker algorithm or its extensions has been additionally applied to several problems in computer vision and graphics:</p>
<ul>
<li>Image Colorization<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></li>
<li>Interactive rotoscoping<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></li>
<li>Medical image segmentation<ref>S. P. Dakua, J. S. Sahambi: LV Contour Extraction from Cardiac MR</ref></li>
</ul>

<p>Images Using Random Walks Approach, Int. Journal of Recent Trends in Engineering, Vol 1, No. 3, May 2009<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>
<ul>
<li>Merging multiple segmentations<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></li>
<li>Mesh segmentation<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a><a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></li>
<li>Mesh denoising<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></li>
<li>Segmentation editing<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></li>
<li>Shadow elimination<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></li>
<li>Stereo matching (i.e., one-dimensional image registration)<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></li>
<li>Image fusion <a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a><a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cns.bu.edu/~lgrady/random_walker_matlab_code.zip">Matlab code implementing the original random walker algorithm</a></li>
<li><a href="http://fastrw.cs.sfu.ca/">Matlab code implementing the random walker algorithm with precomputation</a></li>
<li><a href="http://scikit-image.org/docs/dev/auto_examples/plot_random_walker_segmentation.html">Python implementation of the original random walker algorithm</a> in the image processing toolbox <a href="http://scikit-image.org/">scikit-image</a></li>
</ul>

<p>"</p>

<p><a href="Category:Image_segmentation" title="wikilink">Category:Image segmentation</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">P. Doyle, J. L. Snell: Random Walks and Electric Networks, Mathematical Association of America, 1984<a href="#fnref1">↩</a></li>
<li id="fn2">Leo Grady: Multilabel Random Walker Image Segmentation Using Prior Models, Proc. of CVPR, Vol. 1, pp. 763–770, 2005. <a href="http://www.cns.bu.edu/%7Elgrady/grady2005multilabel.pdf">1</a><a href="#fnref2">↩</a></li>
<li id="fn3">Leo Grady, Gareth Funka-Lea: Multi-Label Image Segmentation for Medical Applications Based on Graph-Theoretic Electrical Potentials, Proc. of the 8th ECCV Workshop on Computer Vision Approaches to Medical Image Analysis and Mathematical Methods in Biomedical Image Analysis, pp. 230–245, 2004.<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7">P. G. Doyle, J. L. Snell: Random Walks and Electrical Networks, Carus Mathematical Monographs, 1984<a href="#fnref7">↩</a></li>
<li id="fn8">T. H. Kim, K. M. Lee, S. U. Lee: Generative Image Segmentation Using Random Walks with Restart, Proc. of ECCV 2008, pp. 264–275<a href="#fnref8">↩</a></li>
<li id="fn9">J. Wang, M. Agrawala, M. F. Cohen: Soft scissors: an interactive tool for realtime high quality matting, Proc. of SIGGRAPH 2007<a href="#fnref9">↩</a></li>
<li id="fn10">S. Rysavy, A. Flores, R. Enciso, K. Okada: Classifiability Criteria for Refining of Random Walks Segmentation, Proc. of ICPR 2008<a href="#fnref10">↩</a></li>
<li id="fn11">W. Yang, J. Cai, J. Zheng, J. Luo: User-friendly Interactive Image Segmentation through Unified Combinatorial User Inputs, IEEE Trans. on Image Proc., 2010<a href="#fnref11">↩</a></li>
<li id="fn12">C. Chefd'hotel, A. Sebbane: Random walk and front propagation on watershed adjacency graphs for multilabel image segmentation, Proc. of ICV 2007<a href="#fnref12">↩</a></li>
<li id="fn13">R. Rzeszutek, T. El-Maraghi, D. Androutsos: Image segmentation using scale-space random walks, Proc. of the 16th international conference on Digital Signal Processing, pp. 458–461, 2009<a href="#fnref13">↩</a></li>
<li id="fn14">S. Andrews, G. Hamarneh, A. Saad. Fast random walker with priors using precomputation for interactive medical image segmentation, Proc. of MICCAI 2010<a href="#fnref14">↩</a></li>
<li id="fn15">R. Shen, I. Cheng, J. Shi, A. Basu: Generalized Random Walks for Fusion of Multi-exposure Images, IEEE Trans. on Image Processing, 2011.<a href="#fnref15">↩</a></li>
<li id="fn16">C. Couprie, L. Grady, L. Najman, H. Talbot: Power Watershed: A Unifying Graph-Based Optimization Framework, IEEE Trans. on Pattern Analysis and Machine Intelligence, 2011.<a href="#fnref16">↩</a></li>
<li id="fn17">S. Ram, J. J. Rodriguez: Random Walker Watersheds: A New Image Segmentation Approach, in IEEE International Conference on Acoustics, Speech, and Signal Processing (ICASSP), pp. 1473-1477, Vancouver, Canada, May 2013<a href="#fnref17">↩</a></li>
<li id="fn18">R. Shen, I. Cheng, A. Basu: QoE-Based Multi-Exposure Fusion in Hierarchical Multivariate Gaussian CRF, IEEE Trans. on Image Processing, 2013.<a href="#fnref18">↩</a></li>
<li id="fn19">X. Liu, J. Liu, Z. Feng: Colorization Using Segmentation with Random Walk, Computer Analysis of Images and Patterns, pp. 468–475, 2009<a href="#fnref19">↩</a></li>
<li id="fn20">R. Rzeszutek, T. El-Maraghi, D. Androutsos: Interactive rotoscoping through scale-space random walks, Proc. of the 2009 IEEE international conference on Multimedia and Expo<a href="#fnref20">↩</a></li>
<li id="fn21">F. Maier, A. Wimmer, G. Soza, J. N. Kaftan, D. Fritz, R. Dillmann: Automatic Liver Segmentation Using the Random Walker Algorithm, Bildverarbeitung für die Medizin 2008<a href="#fnref21">↩</a></li>
<li id="fn22">P. Wighton, M. Sadeghi, T. K. Lee, M. S. Atkins: A Fully Automatic Random Walker Segmentation for Skin Lesions in a Supervised Setting, Proc. of MICCAI 2009<a href="#fnref22">↩</a></li>
<li id="fn23">P. Wattuya, K. Rothaus, J. S. Prassni, X. Jiang: A random walker based approach to combining multiple segmentations, Proc. of ICPR 2008<a href="#fnref23">↩</a></li>
<li id="fn24">Y.-K. Lai, S.-M. Hu, R. R. Martin, P. L. Rosin: Fast mesh segmentation using random walks, Proc. of the 2008 ACM symposium on Solid and physical modeling<a href="#fnref24">↩</a></li>
<li id="fn25">J. Zhang, J. Zheng, J. Cai: Interactive Mesh Cutting Using Constrained Random Walks, IEEE Trans. on Visualization and Computer Graphics, 2010.<a href="#fnref25">↩</a></li>
<li id="fn26">X. Sun, P. L. Rosin, R. R. Martin, F. C. Langbein: Random walks for feature-preserving mesh denoising, Computer Aided Geometric Design, Vol. 25, No. 7, Oct. 2008, pp. 437–456<a href="#fnref26">↩</a></li>
<li id="fn27">L. Grady, G. Funka-Lea: An Energy Minimization Approach to the Data Driven Editing of Presegmented Images/Volumes, Proc. of MICCAI, Vol. 2, 2006, pp. 888–895<a href="#fnref27">↩</a></li>
<li id="fn28">G. Li, L. Qingsheng, Q. Xiaoxu: Moving Vehicle Shadow Elimination Based on Random Walk and Edge Features, Proc. of IITA 2008<a href="#fnref28">↩</a></li>
<li id="fn29">R. Shen, I. Cheng, X. Li, A. Basu: Stereo matching using random walks, Proc. of ICPR 2008<a href="#fnref29">↩</a></li>
<li id="fn30"></li>
<li id="fn31"></li>
</ol>
</section>
</hr></body>
</html>
