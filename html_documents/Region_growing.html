<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="700">Region growing</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Region growing</h1>
<hr/>

<p><strong>Region growing</strong> is a simple region-based <a href="image_segmentation" title="wikilink">image segmentation</a> method. It is also classified as a pixel-based image segmentation method since it involves the selection of initial <a href="seed_point" title="wikilink">seed points</a>.</p>

<p>This approach to segmentation examines neighboring pixels of initial seed points and determines whether the pixel neighbors should be added to the region. The process is iterated on, in the same manner as general <a href="data_clustering" title="wikilink">data clustering</a> algorithms. A general discussion of the region growing algorithm is described below.</p>
<h2 id="region-based-segmentation">Region-based segmentation</h2>

<p>The main goal of segmentation is to partition an image into regions. Some segmentation methods such as <a href="Thresholding_(image_processing)" title="wikilink">thresholding</a> achieve this goal by looking for the boundaries between regions based on discontinuities in <a class="uri" href="grayscale" title="wikilink">grayscale</a> or <a class="uri" href="color" title="wikilink">color</a> properties. Region-based segmentation is a technique for determining the region directly. The basic formulation is:</p>

<p>

<math display="block" id="Region_growing:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow></mrow>
     <mrow>
      <msubsup>
       <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋃</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </msubsup>
      <msub>
       <mi>R</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>R</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>a</ci>
     <mtext></mtext>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <union></union>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a)\text{ }\bigcup\nolimits_{i=1}^{n}{R_{i}=R.}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Region_growing:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow></mrow>
      <msub>
       <mi>R</mi>
       <mi>i</mi>
      </msub>
      <mtext>is a connected region</mtext>
     </mrow>
     <mo>,</mo>
     <mtext>i</mtext>
    </mrow>
    <mo>=</mo>
    <mtext>1</mtext>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mtext>2</mtext>
    <mo>,</mo>
    <mrow>
     <mrow></mrow>
     <mi mathvariant="normal">…</mi>
    </mrow>
    <mo>,</mo>
    <mtext>n</mtext>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <times></times>
       <ci>b</ci>
       <mtext></mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>i</ci>
       </apply>
       <mtext>is a connected region</mtext>
      </apply>
      <mtext>i</mtext>
     </list>
     <mtext>1</mtext>
    </apply>
    <list>
     <mtext>2</mtext>
     <apply>
      <times></times>
      <mtext></mtext>
      <ci>normal-…</ci>
     </apply>
     <mtext>n</mtext>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (b)\text{ }R_{i}\text{ is a connected region},\text{ i}=\text{1},\text{ 2},%
\text{ }...,\text{n}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Region_growing:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow></mrow>
      <msub>
       <mi>R</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋂</mo>
       <msub>
        <mi>R</mi>
        <mi>j</mi>
       </msub>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi mathvariant="normal">∅</mi>
      <mtext>for all</mtext>
      <mi>i</mi>
     </mrow>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mn>2</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>c</ci>
       <mtext></mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <intersect></intersect>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <emptyset></emptyset>
       <mtext>for all</mtext>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <list>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (c)\text{ }R_{i}\bigcap R_{j}=\varnothing\text{ for all }i=1,2,...,n.
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Region_growing:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>d</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow></mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>R</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>T</mi>
      <mi>R</mi>
      <mi>U</mi>
      <mi>E</mi>
      <mtext>for</mtext>
      <mi>i</mi>
     </mrow>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mn>2</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>d</ci>
       <mtext></mtext>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>R</ci>
       <ci>U</ci>
       <ci>E</ci>
       <mtext>for</mtext>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <list>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (d)\text{ }P(R_{i})=TRUE\text{ for }i=1,2,...,n.
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Region_growing:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>e</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow></mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>R</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋃</mo>
        <msub>
         <mi>R</mi>
         <mi>j</mi>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>F</mi>
     <mi>A</mi>
     <mi>L</mi>
     <mi>S</mi>
     <mi>E</mi>
     <mtext>for any adjacent region</mtext>
     <msub>
      <mi>R</mi>
      <mi>i</mi>
     </msub>
     <mtext>and</mtext>
     <msub>
      <mi>R</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>e</ci>
     <mtext></mtext>
     <ci>P</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <union></union>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>A</ci>
     <ci>L</ci>
     <ci>S</ci>
     <ci>E</ci>
     <mtext>for any adjacent region</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>i</ci>
     </apply>
     <mtext>and</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (e)\text{ }P(R_{i}\bigcup R_{j})=FALSE\text{ for any adjacent region }R_{i}%
\text{ and }R_{j}.
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Region_growing:5">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>R</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(R_{i})
  </annotation>
 </semantics>
</math>

 is a <a href="logical_predicate" title="wikilink">logical predicate</a> defined over the points in set 

<math display="inline" id="Region_growing:6">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Region_growing:7">
 <semantics>
  <mi mathvariant="normal">∅</mi>
  <annotation-xml encoding="MathML-Content">
   <emptyset></emptyset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varnothing
  </annotation>
 </semantics>
</math>

 is the null set. (a) means that the segmentation must be complete; that is, every pixel must be in a region.</p>

<p>(b) requires that points in a region must be connected in some predefined sense.</p>

<p>(c) indicates that the regions must be disjoint.</p>

<p>(d) deals with the properties that must be satisfied by the pixels in a segmented region. For example 

<math display="inline" id="Region_growing:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>R</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mtext>TRUE</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <mtext>TRUE</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(R_{i})=\text{TRUE}
  </annotation>
 </semantics>
</math>

 if all pixels in 

<math display="inline" id="Region_growing:9">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{i}
  </annotation>
 </semantics>
</math>

 have the same grayscale.</p>

<p>(e) indicates that region 

<math display="inline" id="Region_growing:10">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{i}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Region_growing:11">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{j}
  </annotation>
 </semantics>
</math>

 are different in the sense of predicate 

<math display="inline" id="Region_growing:12">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="basic-concept-of-seed-points">Basic concept of seed points</h2>

<p>The first step in region growing is to select a set of seed points. Seed point selection is based on some user criterion (for example, pixels in a certain grayscale range, pixels evenly spaced on a grid, etc.). The initial region begins as the exact location of these seeds.</p>

<p>The regions are then grown from these seed points to adjacent points depending on a region membership criterion. The criterion could be, for example, pixel intensity, grayscale <a href="wikt:texture" title="wikilink">texture</a>, or color.</p>

<p>Since the regions are grown on the basis of the criterion, the image information itself is important. For example, if the criterion were a pixel intensity threshold value, knowledge of the <a class="uri" href="histogram" title="wikilink">histogram</a> of the image would be of use, as one could use it to determine a suitable threshold value for the region membership criterion.</p>

<p>There is a very simple example followed below. Here we use <a href="4-connected_neighborhood" title="wikilink">4-connected neighborhood</a> to grow from the seed points. We can also choose <a href="8-connected_neighborhood" title="wikilink">8-connected neighborhood</a> for our pixels adjacent relationship. And the criteria we make here is the same pixel value. That is, we keep examining the adjacent pixels of seed points. If they have the same intensity value with the seed points, we classify them into the seed points. It is an iterated process until there are no change in two successive iterative stages. Of course, we can make other criteria, but the main goal is to classify the similarity of the image into regions.</p>
<h2 id="some-important-issues">Some important issues</h2>

<p> </p>

<p>Then we can conclude several important issues about region growing：</p>

<p><strong>1.The suitable selection of seed points is important.</strong></p>

<p>The selection of seed points is depending on the users. For example, in a grayscale lightning image, we may want to segment the lightning from the background. Then probably, we can examine the <a class="uri" href="histogram" title="wikilink">histogram</a> and choose the seed points from the highest range of it.</p>

<p><strong>2.More information of the image is better.</strong></p>

<p>Obviously, the connectivity or pixel adjacent information is helpful for us to determine the threshold and seed points.</p>

<p><strong>3.The value, “minimum area threshold”.</strong></p>

<p>No region in region growing method result will be smaller than this threshold in the segmented image.</p>

<p><strong>4.The value, “Similarity threshold value“.</strong></p>

<p>If the difference of pixel-value or the difference value of average grayscale of a set of pixels less than “Similarity threshold value”, the regions will be considered as a same region.</p>

<p>The criteria of similarities or so called homogeneity we choose are also important. It usually depends on the original image and the segmentation result we want.</p>

<p>Some criteria often used are grayscale (average intensity or variance), color, and texture or shape.</p>
<h2 id="simulation-examples">Simulation examples</h2>

<p>Here we show a simple example for region growing.</p>

<p>Figure 1 is the original image which is a grayscale lightning image. The grayscale value of this image is from 0 to 255. The reason we apply region growing on this image is that we want to mark the strongest lightning part of the image and we also want the result to be connected without being split apart. Therefore, we choose the points having the highest grayscale value which is 255 as the seed points shown in the Figure 2.</p>

<p>After determining the seed points, we have to determine the range of threshold. Always keep in mind that the objective is to mark the strongest light in the image. The third figure is the region growing result from choosing the threshold between 225 and the value of seed points (which is 255). Hence we only mark out the points whose grayscale values are above 225.</p>

<p>If we make the range of threshold wider, we will get a result having a bigger area of the lightning region shown as the Figure 4 and the Figure 5.</p>

<p>We can observe the difference between the last two figures which have different threshold values. Region growing provides the ability for us to separate the part we want connected.</p>

<p>As we can see in Figure 3 to Figure 5, the segmented results in this example are seed-oriented connected. That means the result grew from the same seed points are the same regions. And the points will not be grown without being connected with the seed points.</p>

<p>Therefore, there are still lots of points in the original image having the grayscale values above 155 which are not marked in Figure 5.</p>

<p>This characteristic ensures the reliability of the segmentation and provides the ability to resist noise. For this example, this characteristic prevents us marking out the non-lightning part in the image because the lightning is always connected as one part.</p>
<h2 id="the-advantages-and-disadvantages-of-region-growing">The advantages and disadvantages of region growing</h2>

<p>We briefly conclude the advantages and disadvantages of region growing.</p>

<p><strong>Advantages：</strong></p>

<p>1. Region growing methods can correctly separate the regions that have the same properties we define.</p>

<p>2. Region growing methods can provide the original images which have clear edges with good segmentation results.</p>

<p>3. The concept is simple. We only need a small number of seed points to represent the property we want, then grow the region.</p>

<p>4. We can determine the seed points and the criteria we want to make.</p>

<p>5. We can choose the multiple criteria at the same time.</p>

<p>6. It performs well with respect to noise.</p>

<p>We can conquer the noise problem easily by using some mask to filter the holes or outliers. Therefore, the problem of noise actually does not exist. In conclusion, it is obvious that the most serious problem of region growing is the power and time consuming.</p>
<h2 id="references">References</h2>
<ul>
<li>Jian-Jiun Ding, The class of "<em>Time-Frequency Analysis and Wavelet Transform</em>", the Department of Electrical Engineering, National Taiwan University (NTU), Taipei, Taiwan, 2007.</li>
<li>Jian-Jiun Ding, The class of "<em>Advanced Digital Signal Processing</em>", the Department of Electrical Engineering, National Taiwan University (NTU), Taipei, Taiwan, 2008.</li>
<li>W. K. Pratt, <em>Digital Image Processing 4th Edition</em>, John Wiley &amp; Sons, Inc., Los Altos, California, 2007</li>
<li>M. Petrou and P. Bosdogianni, <em>Image Processing the Fundamentals</em>, Wiley, UK, 2004.</li>
<li>R. C. Gonzalez and R.E. Woods, <em>Digital Image Processing 2nd Edition</em>, Prentice Hall, New Jersey, 2002.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="k-means" title="wikilink">k-means</a> algorithm</li>
<li><a href="watershed_(algorithm)" title="wikilink">watershed (algorithm)</a></li>
</ul>

<p>"</p>

<p><a href="Category:Image_segmentation" title="wikilink">Category:Image segmentation</a></p>
</body>
</html>
