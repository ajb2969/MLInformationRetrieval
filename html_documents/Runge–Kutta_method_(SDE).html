<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1336">Runge–Kutta method (SDE)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Runge–Kutta method (SDE)</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a> of stochastic systems, the <strong>Runge–Kutta method</strong> is a technique for the approximate <a href="numerical_analysis" title="wikilink">numerical solution</a> of a <a href="stochastic_differential_equation" title="wikilink">stochastic differential equation</a>. It is a generalization of the <a href="Runge–Kutta_methods" title="wikilink">Runge–Kutta method</a> for <a href="ordinary_differential_equation" title="wikilink">ordinary differential equations</a> to stochastic differential equations (SDEs). Importantly, the method does not involve knowing derivatives the coefficient functions in the SDEs.</p>
<h2 id="most-basic-scheme">Most basic scheme</h2>

<p>Consider the <a href="Itō_diffusion" title="wikilink">Itō diffusion</a> 

<math display="inline" id="Runge–Kutta_method_(SDE):0">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 satisfying the following Itō stochastic differential equation</p>

<p>

<math display="block" id="Runge–Kutta_method_(SDE):1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>d</mi>
     <msub>
      <mi>X</mi>
      <mi>t</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>X</mi>
        <mi>t</mi>
       </msub>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>t</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>b</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>X</mi>
        <mi>t</mi>
       </msub>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <msub>
       <mi>W</mi>
       <mi>t</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>t</ci>
      </apply>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>b</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>t</ci>
      </apply>
      <ci>d</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{d}X_{t}}=a(X_{t})\,{d}t+b(X_{t})\,{d}W_{t},
  </annotation>
 </semantics>
</math>

</p>

<p>with <a href="initial_condition" title="wikilink">initial condition</a> 

<math display="inline" id="Runge–Kutta_method_(SDE):2">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{0}=x_{0}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Runge–Kutta_method_(SDE):3">
 <semantics>
  <msub>
   <mi>W</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{t}
  </annotation>
 </semantics>
</math>

 stands for the <a href="Wiener_process" title="wikilink">Wiener process</a>, and suppose that we wish to solve this SDE on some interval of time 

<math display="inline" id="Runge–Kutta_method_(SDE):4">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mi>T</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <cn type="integer">0</cn>
    <ci>T</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,T]
  </annotation>
 </semantics>
</math>

. Then the basic <strong>Runge–Kutta approximation</strong> to the true solution 

<math display="inline" id="Runge–Kutta_method_(SDE):5">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is the <a href="Markov_chain" title="wikilink">Markov chain</a> 

<math display="inline" id="Runge–Kutta_method_(SDE):6">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 defined as follows:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<ul>
<li>partition the interval 

<math display="inline" id="Runge–Kutta_method_(SDE):7">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mi>T</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <cn type="integer">0</cn>
    <ci>T</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,T]
  </annotation>
 </semantics>
</math>

 into 

<math display="inline" id="Runge–Kutta_method_(SDE):8">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 subintervals of width 

<math display="inline" id="Runge–Kutta_method_(SDE):9">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mo>=</mo>
   <mrow>
    <mi>T</mi>
    <mo>/</mo>
    <mi>N</mi>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>δ</ci>
     <apply>
      <divide></divide>
      <ci>T</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta=T/N>0
  </annotation>
 </semantics>
</math>

:</li>
</ul>

<p>

<math display="block" id="Runge–Kutta_method_(SDE):10">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo>=</mo>
    <msub>
     <mi>τ</mi>
     <mn>0</mn>
    </msub>
    <mo><</mo>
    <msub>
     <mi>τ</mi>
     <mn>1</mn>
    </msub>
    <mo><</mo>
    <mi mathvariant="normal">…</mi>
    <mo><</mo>
    <msub>
     <mi>τ</mi>
     <mi>N</mi>
    </msub>
    <mo>=</mo>
    <mi>T</mi>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <ci>normal-…</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0=\tau_{0}<\tau_{1}<\dots<\tau_{N}=T;
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>set 

<math display="inline" id="Runge–Kutta_method_(SDE):11">
 <semantics>
  <mrow>
   <msub>
    <mi>Y</mi>
    <mn>0</mn>
   </msub>
   <mo>:=</mo>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{0}:=x_{0}
  </annotation>
 </semantics>
</math>

;</li>
</ul>
<ul>
<li>recursively compute 

<math display="inline" id="Runge–Kutta_method_(SDE):12">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{n}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Runge–Kutta_method_(SDE):13">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>n</mi>
   <mo>≤</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>n</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq n\leq N
  </annotation>
 </semantics>
</math>

 by</li>
</ul>

<p>

<math display="block" id="Runge–Kutta_method_(SDE):14">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Y</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>:=</mo>
    <mrow>
     <msub>
      <mi>Y</mi>
      <mi>n</mi>
     </msub>
     <mo>+</mo>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>Y</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>δ</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>b</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>Y</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi mathvariant="normal">Δ</mi>
      <msub>
       <mi>W</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mrow>
         <mi>b</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mover accent="true">
            <mi mathvariant="normal">Υ</mi>
            <mo stretchy="false">^</mo>
           </mover>
           <mi>n</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>b</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>Y</mi>
           <mi>n</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mrow>
       <mo>(</mo>
       <mrow>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi mathvariant="normal">Δ</mi>
           <msub>
            <mi>W</mi>
            <mi>n</mi>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>2</mn>
        </msup>
        <mo>-</mo>
        <mi>δ</mi>
       </mrow>
       <mo>)</mo>
      </mrow>
      <msup>
       <mi>δ</mi>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mn>1</mn>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Y</ci>
       <ci>n</ci>
      </apply>
      <ci>δ</ci>
     </apply>
     <apply>
      <times></times>
      <ci>b</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Y</ci>
       <ci>n</ci>
      </apply>
      <ci>normal-Δ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>W</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>b</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-^</ci>
          <ci>normal-Υ</ci>
         </apply>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>b</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Y</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <times></times>
         <ci>normal-Δ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>W</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>δ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>δ</ci>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{n+1}:=Y_{n}+a(Y_{n})\delta+b(Y_{n})\Delta W_{n}+\frac{1}{2}\left(b(\hat{%
\Upsilon}_{n})-b(Y_{n})\right)\left((\Delta W_{n})^{2}-\delta\right)\delta^{-1%
/2},
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Runge–Kutta_method_(SDE):15">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <msub>
     <mi>W</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>W</mi>
     <msub>
      <mi>τ</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>W</mi>
     <msub>
      <mi>τ</mi>
      <mi>n</mi>
     </msub>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>τ</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>τ</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta W_{n}=W_{\tau_{n+1}}-W_{\tau_{n}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Runge–Kutta_method_(SDE):16">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi mathvariant="normal">Υ</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>Y</mi>
      <mi>n</mi>
     </msub>
     <mo>+</mo>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>Y</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>δ</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>b</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>Y</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>δ</mi>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>normal-Υ</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Y</ci>
       <ci>n</ci>
      </apply>
      <ci>δ</ci>
     </apply>
     <apply>
      <times></times>
      <ci>b</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Y</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>δ</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\Upsilon}_{n}=Y_{n}+a(Y_{n})\delta+b(Y_{n})\delta^{1/2}.
  </annotation>
 </semantics>
</math>

 The <a href="random_variables" title="wikilink">random variables</a> 

<math display="inline" id="Runge–Kutta_method_(SDE):17">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <msub>
    <mi>W</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta W_{n}
  </annotation>
 </semantics>
</math>

 are <a href="independent_and_identically_distributed" title="wikilink">independent and identically distributed</a> <a href="normal_distribution" title="wikilink">normal random variables</a> with <a href="expected_value" title="wikilink">expected value</a> zero and <a class="uri" href="variance" title="wikilink">variance</a> 

<math display="inline" id="Runge–Kutta_method_(SDE):18">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

.</p>

<p>This scheme has strong order 1, meaning that the approximation error of the actual solution at a fixed time scales with the time step 

<math display="inline" id="Runge–Kutta_method_(SDE):19">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

. It has also weak order 1, meaning that the error on the statistics of the solution scales with the time step 

<math display="inline" id="Runge–Kutta_method_(SDE):20">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

. See the references for complete and exact statements.</p>

<p>The functions 

<math display="inline" id="Runge–Kutta_method_(SDE):21">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Runge–Kutta_method_(SDE):22">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 can be time-varying without any complication. The method can be generalized to the case of several coupled equations; the principle is the same but the equations become longer.</p>
<h2 id="variation-of-the-improved-euler-is-flexible">Variation of the Improved Euler is flexible</h2>

<p>A newer Runge—Kutta scheme also of strong order 1 straightforwardly reduces to the Improved Euler scheme for deterministic ODEs. <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Consider the vector stochastic process 

<math display="inline" id="Runge–Kutta_method_(SDE):23">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>X</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <apply>
      <ci>normal-→</ci>
      <ci>X</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{X}(t)\in\mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

 that satisfies the general Ito SDE</p>

<p>

<math display="block" id="Runge–Kutta_method_(SDE):24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mover accent="true">
      <mi>X</mi>
      <mo stretchy="false">→</mo>
     </mover>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mover accent="true">
       <mi>a</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <mover accent="true">
        <mi>X</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>t</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mover accent="true">
       <mi>b</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <mover accent="true">
        <mi>X</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>W</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-→</ci>
       <ci>a</ci>
      </apply>
      <interval closure="open">
       <ci>t</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>X</ci>
       </apply>
      </interval>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-→</ci>
       <ci>b</ci>
      </apply>
      <interval closure="open">
       <ci>t</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>X</ci>
       </apply>
      </interval>
      <ci>d</ci>
      <ci>W</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\vec{X}=\vec{a}(t,\vec{X})\,dt+\vec{b}(t,\vec{X})\,dW,
  </annotation>
 </semantics>
</math>

 where drift 

<math display="inline" id="Runge–Kutta_method_(SDE):25">
 <semantics>
  <mover accent="true">
   <mi>a</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{a}
  </annotation>
 </semantics>
</math>

 and volatility 

<math display="inline" id="Runge–Kutta_method_(SDE):26">
 <semantics>
  <mover accent="true">
   <mi>b</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{b}
  </annotation>
 </semantics>
</math>

 are sufficiently smooth functions of their arguments. Given time step 

<math display="inline" id="Runge–Kutta_method_(SDE):27">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

, and given the value 

<math display="inline" id="Runge–Kutta_method_(SDE):28">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>X</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>t</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mover accent="true">
     <mi>X</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-→</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-→</ci>
      <ci>X</ci>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{X}(t_{k})=\vec{X}_{k}
  </annotation>
 </semantics>
</math>

, estimate 

<math display="inline" id="Runge–Kutta_method_(SDE):29">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>X</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{X}(t_{k+1})
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Runge–Kutta_method_(SDE):30">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>X</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{X}_{k+1}
  </annotation>
 </semantics>
</math>

 for time 

<math display="inline" id="Runge–Kutta_method_(SDE):31">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>t</mi>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <mi>h</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>k</ci>
     </apply>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{k+1}=t_{k}+h
  </annotation>
 </semantics>
</math>

 via</p>

<p>

<math display="block" id="Runge–Kutta_method_(SDE):32">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <msub>
        <mover accent="true">
         <mi>K</mi>
         <mo stretchy="false">→</mo>
        </mover>
        <mn>1</mn>
       </msub>
       <mo>=</mo>
       <mrow>
        <mrow>
         <mi>h</mi>
         <mover accent="true">
          <mi>a</mi>
          <mo stretchy="false">→</mo>
         </mover>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>t</mi>
           <mi>k</mi>
          </msub>
          <mo>,</mo>
          <msub>
           <mover accent="true">
            <mi>X</mi>
            <mo stretchy="false">→</mo>
           </mover>
           <mi>k</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mrow>
            <mi mathvariant="normal">Δ</mi>
            <msub>
             <mi>W</mi>
             <mi>k</mi>
            </msub>
           </mrow>
           <mo>-</mo>
           <mrow>
            <msub>
             <mi>S</mi>
             <mi>k</mi>
            </msub>
            <msqrt>
             <mi>h</mi>
            </msqrt>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mover accent="true">
          <mi>b</mi>
          <mo stretchy="false">→</mo>
         </mover>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>t</mi>
           <mi>k</mi>
          </msub>
          <mo>,</mo>
          <msub>
           <mover accent="true">
            <mi>X</mi>
            <mo stretchy="false">→</mo>
           </mover>
           <mi>k</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo>,</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <msub>
        <mover accent="true">
         <mi>K</mi>
         <mo stretchy="false">→</mo>
        </mover>
        <mn>2</mn>
       </msub>
       <mo>=</mo>
       <mrow>
        <mrow>
         <mi>h</mi>
         <mover accent="true">
          <mi>a</mi>
          <mo stretchy="false">→</mo>
         </mover>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>t</mi>
           <mrow>
            <mi>k</mi>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
          </msub>
          <mo>,</mo>
          <mrow>
           <msub>
            <mover accent="true">
             <mi>X</mi>
             <mo stretchy="false">→</mo>
            </mover>
            <mi>k</mi>
           </msub>
           <mo>+</mo>
           <msub>
            <mover accent="true">
             <mi>K</mi>
             <mo stretchy="false">→</mo>
            </mover>
            <mn>1</mn>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mrow>
            <mi mathvariant="normal">Δ</mi>
            <msub>
             <mi>W</mi>
             <mi>k</mi>
            </msub>
           </mrow>
           <mo>+</mo>
           <mrow>
            <msub>
             <mi>S</mi>
             <mi>k</mi>
            </msub>
            <msqrt>
             <mi>h</mi>
            </msqrt>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mover accent="true">
          <mi>b</mi>
          <mo stretchy="false">→</mo>
         </mover>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>t</mi>
           <mrow>
            <mi>k</mi>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
          </msub>
          <mo>,</mo>
          <mrow>
           <msub>
            <mover accent="true">
             <mi>X</mi>
             <mo stretchy="false">→</mo>
            </mover>
            <mi>k</mi>
           </msub>
           <mo>+</mo>
           <msub>
            <mover accent="true">
             <mi>K</mi>
             <mo stretchy="false">→</mo>
            </mover>
            <mn>1</mn>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo>,</mo>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <msub>
        <mover accent="true">
         <mi>X</mi>
         <mo stretchy="false">→</mo>
        </mover>
        <mrow>
         <mi>k</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mo>=</mo>
       <mrow>
        <msub>
         <mover accent="true">
          <mi>X</mi>
          <mo stretchy="false">→</mo>
         </mover>
         <mi>k</mi>
        </msub>
        <mo>+</mo>
        <mrow>
         <mfrac>
          <mn>1</mn>
          <mn>2</mn>
         </mfrac>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mover accent="true">
             <mi>K</mi>
             <mo stretchy="false">→</mo>
            </mover>
            <mn>1</mn>
           </msub>
           <mo>+</mo>
           <msub>
            <mover accent="true">
             <mi>K</mi>
             <mo stretchy="false">→</mo>
            </mover>
            <mn>2</mn>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo>,</mo>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-→</ci>
        <ci>K</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>h</ci>
        <apply>
         <ci>normal-→</ci>
         <ci>a</ci>
        </apply>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>t</ci>
          <ci>k</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-→</ci>
           <ci>X</ci>
          </apply>
          <ci>k</ci>
         </apply>
        </interval>
       </apply>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>normal-Δ</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>W</ci>
           <ci>k</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>S</ci>
           <ci>k</ci>
          </apply>
          <apply>
           <root></root>
           <ci>h</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <ci>normal-→</ci>
         <ci>b</ci>
        </apply>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>t</ci>
          <ci>k</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-→</ci>
           <ci>X</ci>
          </apply>
          <ci>k</ci>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-→</ci>
        <ci>K</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>h</ci>
        <apply>
         <ci>normal-→</ci>
         <ci>a</ci>
        </apply>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>t</ci>
          <apply>
           <plus></plus>
           <ci>k</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <plus></plus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <ci>normal-→</ci>
            <ci>X</ci>
           </apply>
           <ci>k</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <ci>normal-→</ci>
            <ci>K</ci>
           </apply>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </interval>
       </apply>
       <apply>
        <times></times>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <ci>normal-Δ</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>W</ci>
           <ci>k</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>S</ci>
           <ci>k</ci>
          </apply>
          <apply>
           <root></root>
           <ci>h</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <ci>normal-→</ci>
         <ci>b</ci>
        </apply>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>t</ci>
          <apply>
           <plus></plus>
           <ci>k</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <plus></plus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <ci>normal-→</ci>
            <ci>X</ci>
           </apply>
           <ci>k</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <ci>normal-→</ci>
            <ci>K</ci>
           </apply>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-→</ci>
        <ci>X</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-→</ci>
         <ci>X</ci>
        </apply>
        <ci>k</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-→</ci>
           <ci>K</ci>
          </apply>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-→</ci>
           <ci>K</ci>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{rl}&\vec{K}_{1}=h\vec{a}(t_{k},\vec{X}_{k})+(\Delta W_{k}-S_{k%
}\sqrt{h})\vec{b}(t_{k},\vec{X}_{k}),\\
&\vec{K}_{2}=h\vec{a}(t_{k+1},\vec{X}_{k}+\vec{K}_{1})+(\Delta W_{k}+S_{k}%
\sqrt{h})\vec{b}(t_{k+1},\vec{X}_{k}+\vec{K}_{1}),\\
&\vec{X}_{k+1}=\vec{X}_{k}+\frac{1}{2}(\vec{K}_{1}+\vec{K}_{2}),\end{array}
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>where 

<math display="inline" id="Runge–Kutta_method_(SDE):33">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <msub>
     <mi>W</mi>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msqrt>
     <mi>h</mi>
    </msqrt>
    <msub>
     <mi>Z</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <root></root>
      <ci>h</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta W_{k}=\sqrt{h}Z_{k}
  </annotation>
 </semantics>
</math>

 for normal random 

<math display="inline" id="Runge–Kutta_method_(SDE):34">
 <semantics>
  <mrow>
   <msub>
    <mi>Z</mi>
    <mi>k</mi>
   </msub>
   <mo>∼</mo>
   <mrow>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Z</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <ci>N</ci>
     <interval closure="open">
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{k}\sim N(0,1)
  </annotation>
 </semantics>
</math>

;</li>
<li>and where 

<math display="inline" id="Runge–Kutta_method_(SDE):35">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>±</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">plus-or-minus</csymbol>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{k}=\pm 1
  </annotation>
 </semantics>
</math>

, each alternative chosen with probability 

<math display="inline" id="Runge–Kutta_method_(SDE):36">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/2
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>The above describes only one time step. Repeat this time step 

<math display="inline" id="Runge–Kutta_method_(SDE):37">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>t</mi>
      <mi>m</mi>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>t</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <mi>h</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (t_{m}-t_{0})/h
  </annotation>
 </semantics>
</math>

 times in order to integrate the SDE from time 

<math display="inline" id="Runge–Kutta_method_(SDE):38">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <msub>
    <mi>t</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=t_{0}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Runge–Kutta_method_(SDE):39">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <msub>
    <mi>t</mi>
    <mi>m</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=t_{m}
  </annotation>
 </semantics>
</math>

.</p>

<p>The scheme integrates Stratonovich SDEs to 

<math display="inline" id="Runge–Kutta_method_(SDE):40">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>h</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(h)
  </annotation>
 </semantics>
</math>

 provided one sets 

<math display="inline" id="Runge–Kutta_method_(SDE):41">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>k</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{k}=0
  </annotation>
 </semantics>
</math>

 throughout (instead of choosing 

<math display="inline" id="Runge–Kutta_method_(SDE):42">
 <semantics>
  <mrow>
   <mo>±</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">plus-or-minus</csymbol>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pm 1
  </annotation>
 </semantics>
</math>

).</p>
<h2 id="higher-order-runge-kutta-schemes">Higher order Runge-Kutta schemes</h2>

<p>Higher-order schemes also exist, but become increasingly complex. Rossler developed many schemes for Ito SDEs. <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Whereas Komori developed schemes for Stratonovich SDEs. <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Numerical_differential_equations" title="wikilink">Category:Numerical differential equations</a> <a href="Category:Stochastic_differential_equations" title="wikilink">Category:Stochastic differential equations</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">P. E. Kloeden and E. Platen. <em>Numerical solution of stochastic differential equations</em>, volume 23 of Applications of Mathematics. Springer--Verlag, 1992.<a href="#fnref1">↩</a></li>
<li id="fn2">A. J. Roberts. Modify the improved Euler scheme to integrate stochastic differential equations. <a href="http://arxiv.org/abs/1210.0933">1</a>, Oct 2012.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
