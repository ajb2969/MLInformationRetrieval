<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="790">Ext functor</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Ext functor</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the <strong>Ext functors</strong> of <a href="homological_algebra" title="wikilink">homological algebra</a> are <a href="derived_functor" title="wikilink">derived functors</a> of <a href="Hom_functor" title="wikilink">Hom functors</a>. They were first used in <a href="algebraic_topology" title="wikilink">algebraic topology</a>, but are common in many areas of mathematics. The name "Ext" comes from group theory, as the Ext functor is used in <a href="group_cohomology" title="wikilink">group cohomology</a> to classify <a href="Abelian_group" title="wikilink">abelian</a> <a href="group_extension" title="wikilink">group extensions</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="definition-and-computation">Definition and computation</h2>

<p>Let <em>R</em> be a <a href="ring_(mathematics)" title="wikilink">ring</a> and let Mod<sub><em>R</em></sub> be the <a href="Category_(mathematics)" title="wikilink">category</a> of <a href="module_(mathematics)" title="wikilink">modules</a> over <em>R</em>. Let <em>B</em> be in Mod<sub><em>R</em></sub> and set <em>T</em>(<em>B</em>) = Hom<sub><em>R</em></sub>(<em>A,B</em>), for fixed <em>A</em> in Mod<sub><em>R</em></sub>. This is a <a href="left_exact_functor" title="wikilink">left exact functor</a> and thus has right <a href="derived_functor" title="wikilink">derived functors</a> <em>R<sup>n</sup>T</em>. The Ext functor is defined by</p>

<p>

<math display="block" id="Ext_functor:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mo>Ext</mo>
      <mi>R</mi>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo>,</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>R</mi>
        <mi>n</mi>
       </msup>
       <mi>T</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Ext</ci>
       <ci>R</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <ci>n</ci>
      </apply>
      <ci>T</ci>
     </apply>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Ext}_{R}^{n}(A,B)=(R^{n}T)(B).
  </annotation>
 </semantics>
</math>

</p>

<p>This can be calculated by taking any <a href="injective_resolution" title="wikilink">injective resolution</a></p>

<p>

<math display="block" id="Ext_functor:1">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo>→</mo>
    <mi>B</mi>
    <mo>→</mo>
    <msup>
     <mi>I</mi>
     <mn>0</mn>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>I</mi>
     <mn>1</mn>
    </msup>
    <mo>→</mo>
    <mi mathvariant="normal">…</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <ci>B</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>I</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>I</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-…</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\rightarrow B\rightarrow I^{0}\rightarrow I^{1}\rightarrow\dots,
  </annotation>
 </semantics>
</math>

</p>

<p>and computing</p>

<p>

<math display="block" id="Ext_functor:2">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo>→</mo>
    <mrow>
     <msub>
      <mo>Hom</mo>
      <mi>R</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo>,</mo>
      <msup>
       <mi>I</mi>
       <mn>0</mn>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <msub>
      <mo>Hom</mo>
      <mi>R</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo>,</mo>
      <msup>
       <mi>I</mi>
       <mn>1</mn>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mi mathvariant="normal">…</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Hom</ci>
       <ci>R</ci>
      </apply>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>I</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Hom</ci>
       <ci>R</ci>
      </apply>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>I</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-…</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\rightarrow\operatorname{Hom}_{R}(A,I^{0})\rightarrow\operatorname{Hom}_{R}(A%
,I^{1})\rightarrow\dots.
  </annotation>
 </semantics>
</math>

</p>

<p>Then (<em>R<sup>n</sup>T</em>)(<em>B</em>) is the <a href="homology_(mathematics)" title="wikilink">homology</a> of this complex. Note that Hom<sub><em>R</em></sub>(<em>A,B</em>) is excluded from the complex.</p>

<p>An alternative definition is given using the functor <em>G</em>(<em>A</em>)=Hom<sub><em>R</em></sub>(<em>A,B</em>). For a fixed module <em>B</em>, this is a <a href="Covariance_and_contravariance_of_functors" title="wikilink">contravariant</a> <a href="left_exact_functor" title="wikilink">left exact functor</a>, and thus we also have right <a href="derived_functor" title="wikilink">derived functors</a> <em>R<sup>n</sup>G</em>, and can define</p>

<p>

<math display="block" id="Ext_functor:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mo>Ext</mo>
      <mi>R</mi>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo>,</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>R</mi>
        <mi>n</mi>
       </msup>
       <mi>G</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Ext</ci>
       <ci>R</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <ci>n</ci>
      </apply>
      <ci>G</ci>
     </apply>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Ext}_{R}^{n}(A,B)=(R^{n}G)(A).
  </annotation>
 </semantics>
</math>

</p>

<p>This can be calculated by choosing any <a href="projective_resolution" title="wikilink">projective resolution</a></p>

<p>

<math display="block" id="Ext_functor:4">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <mo>→</mo>
    <msup>
     <mi>P</mi>
     <mn>1</mn>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>P</mi>
     <mn>0</mn>
    </msup>
    <mo>→</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dots\rightarrow P^{1}\rightarrow P^{0}\rightarrow A\rightarrow 0,
  </annotation>
 </semantics>
</math>

</p>

<p>and proceeding dually by computing</p>

<p>

<math display="block" id="Ext_functor:5">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo>→</mo>
    <mrow>
     <msub>
      <mo>Hom</mo>
      <mi>R</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>P</mi>
       <mn>0</mn>
      </msup>
      <mo>,</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <msub>
      <mo>Hom</mo>
      <mi>R</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>P</mi>
       <mn>1</mn>
      </msup>
      <mo>,</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mi mathvariant="normal">…</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Hom</ci>
       <ci>R</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>P</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Hom</ci>
       <ci>R</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>P</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-…</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\rightarrow\operatorname{Hom}_{R}(P^{0},B)\rightarrow\operatorname{Hom}_{R}(P%
^{1},B)\rightarrow\dots.
  </annotation>
 </semantics>
</math>

</p>

<p>Then (<em>R<sup>n</sup>G</em>)(<em>A</em>) is the homology of this complex. Again note that Hom<sub><em>R</em></sub>(<em>A,B</em>) is excluded.</p>

<p>These two constructions turn out to yield <a class="uri" href="isomorphic" title="wikilink">isomorphic</a> results, and so both may be used to calculate the Ext functor.</p>
<h2 id="ext-and-extensions">Ext and extensions</h2>
<h3 id="equivalence-of-extensions">Equivalence of extensions</h3>

<p>Ext functors derive their name from the relationship to extensions of modules. Given <em>R</em>-modules <em>A</em> and <em>B</em>, an <strong>extension of <em>A</em> by <em>B</em></strong> is a <a href="short_exact_sequence" title="wikilink">short exact sequence</a> of <em>R</em>-modules</p>

<p>

<math display="block" id="Ext_functor:6">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mi>B</mi>
   <mo>→</mo>
   <mi>E</mi>
   <mo>→</mo>
   <mi>A</mi>
   <mo>→</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <ci>B</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>E</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\rightarrow B\rightarrow E\rightarrow A\rightarrow 0.
  </annotation>
 </semantics>
</math>

</p>

<p>Two extensions</p>

<p>

<math display="block" id="Ext_functor:7">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mi>B</mi>
   <mo>→</mo>
   <mi>E</mi>
   <mo>→</mo>
   <mi>A</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <ci>B</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>E</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\rightarrow B\rightarrow E\rightarrow A\rightarrow 0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Ext_functor:8">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mi>B</mi>
   <mo>→</mo>
   <msup>
    <mi>E</mi>
    <mo>′</mo>
   </msup>
   <mo>→</mo>
   <mi>A</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <ci>B</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>E</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\rightarrow B\rightarrow E^{\prime}\rightarrow A\rightarrow 0
  </annotation>
 </semantics>
</math>

</p>

<p>are said to be <strong>equivalent</strong> (as extensions of <em>A</em> by <em>B</em>) if there is a <a href="commutative_diagram" title="wikilink">commutative diagram</a></p>

<p>.</p>

<p>Note that the <a href="Five_Lemma" title="wikilink">Five Lemma</a> implies that the middle arrow is an isomorphism. An extension of <em>A</em> by <em>B</em> is called <strong>split</strong> if it is equivalent to the <strong>trivial extension</strong></p>

<p>

<math display="block" id="Ext_functor:9">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mi>B</mi>
   <mo>→</mo>
   <mrow>
    <mi>A</mi>
    <mo>⊕</mo>
    <mi>B</mi>
   </mrow>
   <mo>→</mo>
   <mi>A</mi>
   <mo>→</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <ci>B</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\rightarrow B\rightarrow A\oplus B\rightarrow A\rightarrow 0.
  </annotation>
 </semantics>
</math>

</p>

<p>There is a bijective correspondence between <a href="equivalence_class" title="wikilink">equivalence classes</a> of extensions</p>

<p>

<math display="block" id="Ext_functor:10">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mi>B</mi>
   <mo>→</mo>
   <mi>E</mi>
   <mo>→</mo>
   <mi>A</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <ci>B</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>E</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\rightarrow B\rightarrow E\rightarrow A\rightarrow 0
  </annotation>
 </semantics>
</math>

</p>

<p>of <em>A</em> by <em>B</em> and elements of</p>

<p>

<math display="block" id="Ext_functor:11">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo>Ext</mo>
     <mi>R</mi>
     <mn>1</mn>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Ext</ci>
      <ci>R</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Ext}_{R}^{1}(A,B).
  </annotation>
 </semantics>
</math>

</p>
<h3 id="the-baer-sum-of-extensions">The Baer sum of extensions</h3>

<p>Given two extensions</p>

<p>

<math display="block" id="Ext_functor:12">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mi>B</mi>
   <mo>→</mo>
   <mi>E</mi>
   <mo>→</mo>
   <mi>A</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <ci>B</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>E</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\rightarrow B\rightarrow E\rightarrow A\rightarrow 0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Ext_functor:13">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mi>B</mi>
   <mo>→</mo>
   <msup>
    <mi>E</mi>
    <mo>′</mo>
   </msup>
   <mo>→</mo>
   <mi>A</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <ci>B</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>E</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\rightarrow B\rightarrow E^{\prime}\rightarrow A\rightarrow 0
  </annotation>
 </semantics>
</math>

</p>

<p>we can construct the <strong>Baer sum</strong>, by forming the <a href="Pullback_(category_theory)" title="wikilink">pullback</a> over 

<math display="inline" id="Ext_functor:14">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="inline" id="Ext_functor:15">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>=</mo>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>e</mi>
       <mo>,</mo>
       <msup>
        <mi>e</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mrow>
       <mi>E</mi>
       <mo>⊕</mo>
       <mpadded width="+2.8pt">
        <msup>
         <mi>E</mi>
         <mo>′</mo>
        </msup>
       </mpadded>
      </mrow>
     </mrow>
     <mo rspace="5.3pt" stretchy="false">|</mo>
     <mrow>
      <mrow>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>e</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
       <msup>
        <mi>g</mi>
        <mo>′</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>e</mi>
         <mo>′</mo>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Γ</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <interval closure="open">
       <ci>e</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <ci>normal-′</ci>
       </apply>
      </interval>
      <apply>
       <csymbol cd="latexml">direct-sum</csymbol>
       <ci>E</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>E</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>g</ci>
       <ci>e</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>g</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma=\left\{(e,e^{\prime})\in E\oplus E^{\prime}\;|\;g(e)=g^{\prime}(e^{%
\prime})\right\}.
  </annotation>
 </semantics>
</math>

</p>

<p>We form the quotient</p>

<p>

<math display="inline" id="Ext_functor:16">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>b</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo>,</mo>
       <mrow>
        <msup>
         <mi>f</mi>
         <mo>′</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>b</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo rspace="5.3pt" stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo rspace="5.3pt" stretchy="false">|</mo>
     <mrow>
      <mi>b</mi>
      <mo>∈</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Y</ci>
    <apply>
     <divide></divide>
     <ci>normal-Γ</ci>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <minus></minus>
       <interval closure="open">
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>b</ci>
        </apply>
        <cn type="integer">0</cn>
       </interval>
       <interval closure="open">
        <cn type="integer">0</cn>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>f</ci>
          <ci>normal-′</ci>
         </apply>
         <ci>b</ci>
        </apply>
       </interval>
      </apply>
      <apply>
       <in></in>
       <ci>b</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=\Gamma/\{(f(b),0)-(0,f^{\prime}(b))\;|\;b\in B\}
  </annotation>
 </semantics>
</math>

,</p>

<p>that is, we <a href="mod_out" title="wikilink">mod out</a> by the relation 

<math display="inline" id="Ext_functor:17">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mi>e</mi>
    </mrow>
    <mo>,</mo>
    <msup>
     <mi>e</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∼</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>,</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <msup>
      <mi>e</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <interval closure="open">
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>b</ci>
      </apply>
      <ci>e</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
    <interval closure="open">
     <ci>e</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>b</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f(b)+e,e^{\prime})\sim(e,f^{\prime}(b)+e^{\prime})
  </annotation>
 </semantics>
</math>

. The extension</p>

<p>

<math display="block" id="Ext_functor:18">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mi>B</mi>
   <mo>→</mo>
   <mi>Y</mi>
   <mo>→</mo>
   <mi>A</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <ci>B</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>Y</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\rightarrow B\rightarrow Y\rightarrow A\rightarrow 0
  </annotation>
 </semantics>
</math>

</p>

<p>where the first arrow is 

<math display="inline" id="Ext_functor:19">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mrow>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <ci>b</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>b</ci>
       </apply>
       <cn type="integer">0</cn>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <interval closure="open">
       <cn type="integer">0</cn>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>b</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\mapsto[(f(b),0)]=[(0,f^{\prime}(b))]
  </annotation>
 </semantics>
</math>

 and the second 

<math display="inline" id="Ext_functor:20">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>,</mo>
    <msup>
     <mi>e</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↦</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>g</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>e</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <interval closure="open">
      <ci>e</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <ci>normal-′</ci>
      </apply>
     </interval>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>e</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (e,e^{\prime})\mapsto g(e)=g^{\prime}(e^{\prime})
  </annotation>
 </semantics>
</math>

 thus formed is called the Baer sum of the extensions <em>E</em> and <em>E</em>'.</p>

<p><a href="Up_to" title="wikilink">Up to</a> equivalence of extensions, the Baer sum is commutative and has the trivial extension as identity element. The extension 0 → <em>B</em> → <em>E</em> → <em>A</em> → 0 has for opposite the same extension with exactly one of the central arrows turned to their opposite <em>eg</em> the morphism <em>g</em> is replaced by <em>-g</em>.</p>

<p>The set of extensions up to equivalence is an <a href="abelian_group" title="wikilink">abelian group</a> that is a realization of the functor Ext(<em>A</em>, <em>B</em>)</p>
<h2 id="construction-of-ext-in-abelian-categories">Construction of Ext in abelian categories</h2>

<p>The above identification enables us to define Ext(<em>A</em>, <em>B</em>) even for <a href="abelian_categories" title="wikilink">abelian categories</a> <strong>Ab</strong> without reference to <a href="Projective_module" title="wikilink">projectives</a> and <a href="Injective_module" title="wikilink">injectives</a> (even if the category has no projectives or injectives). We simply take Ext(<em>A</em>, <em>B</em>) to be the set of equivalence classes of extensions of <em>A</em> by <em>B</em>, forming an abelian group under the Baer sum. Similarly, we can define higher Ext groups Ext(<em>A</em>, <em>B</em>) as equivalence classes of <em>n-extensions</em>, which are exact sequences</p>

<p>

<math display="block" id="Ext_functor:21">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mi>B</mi>
   <mo>→</mo>
   <msub>
    <mi>X</mi>
    <mi>n</mi>
   </msub>
   <mo>→</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>→</mo>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo>→</mo>
   <mi>A</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <ci>B</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\rightarrow B\rightarrow X_{n}\rightarrow\cdots\rightarrow X_{1}\rightarrow A\rightarrow
0
  </annotation>
 </semantics>
</math>

</p>

<p>under the <a href="equivalence_relation" title="wikilink">equivalence relation</a> generated by the relation that identifies two extensions</p>

<p>

<math display="block" id="Ext_functor:22">
 <semantics>
  <mrow>
   <mi>ξ</mi>
   <mo>:</mo>
   <mrow>
    <mn>0</mn>
    <mo>→</mo>
    <mi>B</mi>
    <mo>→</mo>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo>→</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>→</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>→</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ξ</ci>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <cn type="integer">0</cn>
      <ci>B</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <ci>normal-⋯</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <ci>A</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi:0\rightarrow B\rightarrow X_{n}\rightarrow\cdots\rightarrow X_{1}%
\rightarrow A\rightarrow 0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Ext_functor:23">
 <semantics>
  <mrow>
   <msup>
    <mi>ξ</mi>
    <mo>′</mo>
   </msup>
   <mo>:</mo>
   <mrow>
    <mn>0</mn>
    <mo>→</mo>
    <mi>B</mi>
    <mo>→</mo>
    <msubsup>
     <mi>X</mi>
     <mi>n</mi>
     <mo>′</mo>
    </msubsup>
    <mo>→</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>→</mo>
    <msubsup>
     <mi>X</mi>
     <mn>1</mn>
     <mo>′</mo>
    </msubsup>
    <mo>→</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ξ</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <cn type="integer">0</cn>
      <ci>B</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>X</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <ci>normal-⋯</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>X</ci>
        <ci>normal-′</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <ci>A</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi^{\prime}:0\rightarrow B\rightarrow X^{\prime}_{n}\rightarrow\cdots%
\rightarrow X^{\prime}_{1}\rightarrow A\rightarrow 0
  </annotation>
 </semantics>
</math>

</p>

<p>if there are maps <em>X<sub>m</sub></em> → <em>X′<sub>m</sub></em> for all <em>m</em> in {1, 2, ..., <em>n</em>} so that every resulting <a href="Commutative_diagram" title="wikilink">square commutes</a>, i.e. if there is a <a href="chain_map" title="wikilink">chain map</a> <em>X

<math display="block" id="Ext_functor:24">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

→

<math display="inline" id="Ext_functor:25">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

</em>'.</p>

<p>The Baer sum of the two <em>n</em>-extensions above is formed by letting <em>X</em> be the <a href="Pullback_(category_theory)" title="wikilink">pullback</a> of <em>X<sub>1</sub></em> and <em>X</em> over <em>A</em>, and <em>X</em> be the <a href="Pushout_(category_theory)" title="wikilink">pushout</a> of <em>X<sub>n</sub></em> and <em>X</em> under <em>B</em> quotiented by the skew diagonal copy of B; see Weibel, §3.4. Then we define the Baer sum of the extensions to be</p>

<p>

<math display="block" id="Ext_functor:26">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mi>B</mi>
   <mo>→</mo>
   <msubsup>
    <mi>X</mi>
    <mi>n</mi>
    <mi>′′</mi>
   </msubsup>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>X</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>⊕</mo>
    <msubsup>
     <mi>X</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>′</mo>
    </msubsup>
   </mrow>
   <mo>→</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo>⊕</mo>
    <msubsup>
     <mi>X</mi>
     <mn>2</mn>
     <mo>′</mo>
    </msubsup>
   </mrow>
   <mo>→</mo>
   <msubsup>
    <mi>X</mi>
    <mn>1</mn>
    <mi>′′</mi>
   </msubsup>
   <mo>→</mo>
   <mi>A</mi>
   <mo>→</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <ci>B</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>X</ci>
       <ci>′′</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>X</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>X</ci>
        <ci>normal-′</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>X</ci>
       <ci>′′</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\rightarrow B\rightarrow X^{\prime\prime}_{n}\rightarrow X_{n-1}\oplus X^{%
\prime}_{n-1}\rightarrow\cdots\rightarrow X_{2}\oplus X^{\prime}_{2}%
\rightarrow X^{\prime\prime}_{1}\rightarrow A\rightarrow 0.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="further-properties-of-ext">Further properties of Ext</h2>

<p>The Ext functor exhibits some convenient properties, useful in computations.</p>
<ul>
<li>Ext(<em>A</em>, <em>B</em>) = 0 for <em>i</em> &gt; 0 if either <em>B</em> is <a href="injective_module" title="wikilink">injective</a> or <em>A</em> <a href="projective_module" title="wikilink">projective</a>.</li>
</ul>
<ul>
<li>A converse also holds: if Ext(<em>A</em>, <em>B</em>) = 0 for all <em>A</em>, then Ext(<em>A</em>, <em>B</em>) = 0 for all <em>A</em>, and <em>B</em> is injective; if Ext(<em>A</em>, <em>B</em>) = 0 for all <em>B</em>, then Ext(<em>A</em>, <em>B</em>) = 0 for all <em>B</em>, and <em>A</em> is projective.</li>
</ul>
<ul>
<li>

<math display="inline" id="Ext_functor:27">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo>Ext</mo>
     <mi>R</mi>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msub>
       <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⊕</mo>
       <mi>α</mi>
      </msub>
      <msub>
       <mi>A</mi>
       <mi>α</mi>
      </msub>
     </mrow>
     <mo>,</mo>
     <mi>B</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>≅</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∏</mo>
     <mi>α</mi>
    </msub>
    <mrow>
     <msubsup>
      <mo>Ext</mo>
      <mi>R</mi>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>A</mi>
       <mi>α</mi>
      </msub>
      <mo>,</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Ext</ci>
       <ci>n</ci>
      </apply>
      <ci>R</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">direct-sum</csymbol>
       <ci>α</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>α</ci>
      </apply>
     </apply>
     <ci>B</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <ci>α</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Ext</ci>
        <ci>n</ci>
       </apply>
       <ci>R</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>α</ci>
      </apply>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Ext}^{n}_{R}\left(\bigoplus_{\alpha}A_{\alpha},B\right)\cong%
\prod_{\alpha}\operatorname{Ext}^{n}_{R}(A_{\alpha},B)
  </annotation>
 </semantics>
</math>

</li>
</ul>
<ul>
<li>

<math display="inline" id="Ext_functor:28">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo>Ext</mo>
     <mi>R</mi>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <mo>(</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∏</mo>
       <mi>β</mi>
      </msub>
      <msub>
       <mi>B</mi>
       <mi>β</mi>
      </msub>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>≅</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∏</mo>
     <mi>β</mi>
    </msub>
    <mrow>
     <msubsup>
      <mo>Ext</mo>
      <mi>R</mi>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo>,</mo>
      <msub>
       <mi>B</mi>
       <mi>β</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Ext</ci>
       <ci>n</ci>
      </apply>
      <ci>R</ci>
     </apply>
     <ci>A</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <ci>β</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>β</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <ci>β</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Ext</ci>
        <ci>n</ci>
       </apply>
       <ci>R</ci>
      </apply>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>β</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Ext}^{n}_{R}\left(A,\prod_{\beta}B_{\beta}\right)\cong\prod_{%
\beta}\operatorname{Ext}^{n}_{R}(A,B_{\beta})
  </annotation>
 </semantics>
</math>

</li>
</ul>
<h2 id="ring-structure-and-module-structure-on-specific-exts">Ring structure and module structure on specific Exts</h2>

<p>One more very useful way to view the Ext functor is this: when an element of Ext(<em>A</em>, <em>B</em>) = 0 is considered as an equivalence class of maps <em>f</em>: <em>P<sub>n</sub></em> → <em>B</em> for a <a href="Projective_module#Facts" title="wikilink">projective resolution</a> <em>P</em><sub>*</sub> of <em>A</em> ; so, then we can pick a long exact sequence <em>Q</em><sub>*</sub> ending with <em>B</em> and lift the map <em>f</em> using the projectivity of the modules <em>P<sub>m</sub></em> to a <a href="Chain_complex#Chain_maps" title="wikilink">chain map</a> <em>f</em><sub>*</sub>: <em>P</em><sub>*</sub> → <em>Q</em><sub>*</sub> of degree -n. It turns out that <a href="Chain_complex#Chain_homotopy" title="wikilink">homotopy classes</a> of such chain maps correspond precisely to the equivalence classes in the definition of Ext above.</p>

<p>Under sufficiently nice circumstances, such as when the <a href="Ring_(mathematics)" title="wikilink">ring</a> <em>R</em> is a <a href="group_ring" title="wikilink">group ring</a> over a field <em>k</em>, or an augmented <em>k</em>-<a href="Algebra_over_a_field" title="wikilink">algebra</a>, we can impose a ring structure on Ext(<em>k</em>, <em>k</em>). The multiplication has quite a few equivalent interpretations, corresponding to different interpretations of the elements of Ext(<em>k</em>, <em>k</em>).</p>

<p>One interpretation is in terms of these homotopy classes of chain maps. Then the product of two elements is represented by the composition of the corresponding representatives. We can choose a single resolution of <em>k</em>, and do all the calculations inside Hom<sub><em>R</em></sub>(<em>P</em><sub>*</sub>,<em>P</em><sub>*</sub>), which is a differential graded algebra, with cohomology precisely Ext<sub><em>R</em></sub>(<em>k,k</em>).</p>

<p>The Ext groups can also be interpreted in terms of exact sequences; this has the advantage that it does not rely on the existence of projective or injective modules. Then we take the viewpoint above that an element of Ext(<em>A</em>, <em>B</em>) is a class, under a certain equivalence relation, of exact sequences of length <em>n</em> + 2 starting with <em>B</em> and ending with <em>A</em>. This can then be spliced with an element in Ext(<em>C</em>, <em>A</em>), by replacing ... → <em>X</em><sub>1</sub> → <em>A</em> → 0 and 0 → <em>A</em> → <em>Y<sub>n</sub></em> → ... with:</p>

<p>

<math display="block" id="Ext_functor:29">
 <semantics>
  <mrow>
   <mi mathvariant="normal">⋯</mi>
   <mo>→</mo>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>Y</mi>
    <mi>n</mi>
   </msub>
   <mo>→</mo>
   <mi mathvariant="normal">⋯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Y</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdots\rightarrow X_{1}\rightarrow Y_{n}\rightarrow\cdots
  </annotation>
 </semantics>
</math>

</p>

<p>where the middle arrow is the composition of the functions <em>X</em><sub>1</sub> → <em>A</em> and <em>A</em> → <em>Y<sub>n</sub></em>. This product is called the <em>Yoneda splice</em>.</p>

<p>These viewpoints turn out to be equivalent whenever both make sense.</p>

<p>Using similar interpretations, we find that Ext(<em>k</em>, <em>M</em>) is a <a href="Module_(mathematics)" title="wikilink">module</a> over Ext(<em>k</em>, <em>k</em>), again for sufficiently nice situations.</p>
<h2 id="interesting-examples">Interesting examples</h2>

<p>If <strong>Z</strong>[<em>G</em>] is the <a href="group_ring" title="wikilink">integral group ring</a> for a <a href="Group_(mathematics)" title="wikilink">group</a> <em>G</em>, then Ext(<strong>Z</strong>, <em>M</em>) is the <a href="group_cohomology" title="wikilink">group cohomology</a> H*(<em>G,M</em>) with coefficients in <em>M</em>.</p>

<p>For <strong>F</strong><sub><em>p</em></sub> the <a href="finite_field" title="wikilink">finite field</a> on <em>p</em> elements, we also have that H*(<em>G,M</em>) = Ext<mtpl></mtpl>(<strong>F</strong><sub><em>p</em></sub>, <em>M</em>), and it turns out that the group cohomology doesn't depend on the base ring chosen.</p>

<p>If <em>A</em> is a <em>k</em>-<a href="algebra_over_a_field" title="wikilink">algebra</a>, then Ext<mtpl></mtpl>(<em>A</em>, <em>M</em>) is the <a href="Hochschild_cohomology" title="wikilink">Hochschild cohomology</a> HH*(<em>A,M</em>) with coefficients in the <em>A</em>-bimodule <em>M</em>.</p>

<p>If <em>R</em> is chosen to be the <a href="universal_enveloping_algebra" title="wikilink">universal enveloping algebra</a> for a <a href="Lie_algebra" title="wikilink">Lie algebra</a> 

<math display="inline" id="Ext_functor:30">
 <semantics>
  <mi>𝔤</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔤</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{g}
  </annotation>
 </semantics>
</math>

 over a commutative ring <em>k</em>, then Ext(<em>k</em>, <em>M</em>) is the <a href="Lie_algebra_cohomology" title="wikilink">Lie algebra cohomology</a> 

<math display="inline" id="Ext_functor:31">
 <semantics>
  <mrow>
   <msup>
    <mo>H</mo>
    <mo>*</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝔤</mi>
    <mo>,</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-H</ci>
     <times></times>
    </apply>
    <ci>𝔤</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{H}^{*}(\mathfrak{g},M)
  </annotation>
 </semantics>
</math>

 with coefficients in the module <em>M</em>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Tor_functor" title="wikilink">Tor functor</a></li>
<li>The <a href="Grothendieck_group#Grothendieck_group_and_extensions_in_an_abelian_category" title="wikilink">Grothendieck group</a> is a construction centered on extensions</li>
<li>The <a href="universal_coefficient_theorem_for_cohomology" title="wikilink">universal coefficient theorem for cohomology</a> is one notable use of the Ext functor</li>
<li><a href="Grothendieck_duality" title="wikilink">Grothendieck duality</a></li>
<li><a href="Yoneda_product" title="wikilink">Yoneda product</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Homological_algebra" title="wikilink">Category:Homological algebra</a> <a href="Category:Binary_operations" title="wikilink">Category:Binary operations</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
