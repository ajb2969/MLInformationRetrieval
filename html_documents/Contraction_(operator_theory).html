<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1217">Contraction (operator theory)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Contraction (operator theory)</h1>
<hr/>

<p>In <a href="operator_theory" title="wikilink">operator theory</a>, a discipline within mathematics, a <a href="bounded_operator" title="wikilink">bounded operator</a> <em>T</em>: <em>X</em> → <em>Y</em> between <a href="normed_vector_space" title="wikilink">normed vector spaces</a> <em>X</em> and <em>Y</em> is said to be a <strong>contraction</strong> if its <a href="operator_norm" title="wikilink">operator norm</a> ||<em>T</em>|| ≤ 1. Every bounded operator becomes a contraction after suitable scaling. The analysis of contractions provides insight into the structure of operators, or a family of operators. The theory of contractions on <a href="Hilbert_space" title="wikilink">Hilbert space</a> is largely due to <a href="Béla_Szőkefalvi-Nagy" title="wikilink">Béla Szőkefalvi-Nagy</a> and <a href="Ciprian_Foias" title="wikilink">Ciprian Foias</a>.</p>
<h2 id="contractions-on-a-hilbert-space">Contractions on a Hilbert space</h2>

<p>If <em>T</em> is a contraction acting on a <a href="Hilbert_space" title="wikilink">Hilbert space</a> 

<math display="inline" id="Contraction_(operator_theory):0">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

, the following basic objects associated with <em>T</em> can be defined.</p>

<p>The <strong>defect operators</strong> of <em>T</em> are the operators <em>D<sub>T</sub></em> = (1 − <em>T*T</em>)<sup>½</sup> and <em>D<sub>T*</sub></em> = (1 − <em>TT*</em>)<sup>½</sup>. The square root is the <a href="square_root_of_a_matrix" title="wikilink">positive semidefinite one</a> given by the <a href="spectral_theorem" title="wikilink">spectral theorem</a>. The <strong>defect spaces</strong> 

<math display="inline" id="Contraction_(operator_theory):1">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">𝒟</mi>
   <mi>T</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝒟</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{D}_{T}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Contraction_(operator_theory):2">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">𝒟</mi>
   <mrow>
    <mi>T</mi>
    <mo>*</mo>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝒟</ci>
    <list>
     <ci>T</ci>
     <times></times>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{D}_{T*}
  </annotation>
 </semantics>
</math>

 are the ranges Ran(<em>D<sub>T</sub></em>) and Ran(<em>D<sub>T*</sub></em>) respectively. The positive operator <em>D<sub>T</sub></em> induces an inner product on 

<math display="inline" id="Contraction_(operator_theory):3">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

. The inner product space can be identified naturally with Ran(<em>D</em><sub><em>T</em></sub>). A similar statement holds for 

<math display="inline" id="Contraction_(operator_theory):4">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">𝒟</mi>
   <mrow>
    <mi>T</mi>
    <mo>*</mo>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝒟</ci>
    <list>
     <ci>T</ci>
     <times></times>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{D}_{T*}
  </annotation>
 </semantics>
</math>

.</p>

<p>The <strong>defect indices</strong> of <em>T</em> are the pair</p>

<p>

<math display="block" id="Contraction_(operator_theory):5">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>dim</mo>
     <msub>
      <mi class="ltx_font_mathcaligraphic">𝒟</mi>
      <mi>T</mi>
     </msub>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo>dim</mo>
     <msub>
      <mi class="ltx_font_mathcaligraphic">𝒟</mi>
      <msup>
       <mi>T</mi>
       <mo>*</mo>
      </msup>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="latexml">dimension</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒟</ci>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">dimension</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒟</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <times></times>
      </apply>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\dim\mathcal{D}_{T},\dim\mathcal{D}_{T^{*}}).
  </annotation>
 </semantics>
</math>

</p>

<p>The defect operators and the defect indices are a measure of the non-unitarity of <em>T</em>.</p>

<p>A contraction <em>T</em> on a Hilbert space can be canonically decomposed into an orthogonal direct sum</p>

<p>

<math display="block" id="Contraction_(operator_theory):6">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊕</mo>
    <mi>U</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <ci>normal-Γ</ci>
     <ci>U</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=\Gamma\oplus U
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>U</em> is a unitary operator and Γ is <em>completely non-unitary</em> in the sense that it has no <a href="invariant_subspace" title="wikilink">reducing subspaces</a> on which its restriction is unitary. If <em>U</em> = 0, <em>T</em> is said to be a <strong>completely non-unitary contraction</strong>. A special case of this decomposition is the <a href="Wold_decomposition" title="wikilink">Wold decomposition</a> for an <a class="uri" href="isometry" title="wikilink">isometry</a>, where Γ is a proper isometry.</p>

<p>Contractions on Hilbert spaces can be viewed as the operator analogs of cos θ and are called <strong>operator angles</strong> in some contexts. The explicit description of contractions leads to (operator-)parametrizations of positive and unitary matrices.</p>
<h2 id="dilation-theorem-for-contractions">Dilation theorem for contractions</h2>

<p><a href="Sz.-Nagy's_dilation_theorem" title="wikilink">Sz.-Nagy's dilation theorem</a>, proved in 1953, states that for any contraction <em>T</em> on a Hilbert space <em>H</em>, there is a <a href="unitary_operator" title="wikilink">unitary operator</a> <em>U</em> on a larger Hilbert space <em>K</em> ⊇ <em>H</em> such that if <em>P</em> is the orthogonal projection of <em>K</em> onto <em>H</em> then <em>T</em><sup><em>n</em></sup> = <em>P</em> <em>U</em><sup><em>n</em></sup> <em>P</em> for all <em>n</em> &gt; 0. The operator <em>U</em> is called a <a href="dilation_(operator_theory)" title="wikilink">dilation</a> of <em>T</em> and is uniquely determined if <em>U</em> is minimal, i.e. <em>K</em> is the smallest closed subspace invariant under <em>U</em> and <em>U</em>* containing <em>H</em>.</p>

<p>In fact define<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>

<math display="block" id="Contraction_(operator_theory):7">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
    <mo>=</mo>
    <mrow>
     <mi>H</mi>
     <mo>⊕</mo>
     <mi>H</mi>
     <mo>⊕</mo>
     <mi>H</mi>
     <mo>⊕</mo>
     <mi mathvariant="normal">⋯</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ℋ</ci>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <ci>H</ci>
     <ci>H</ci>
     <ci>H</ci>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\mathcal{H}=H\oplus H\oplus H\oplus\cdots,}
  </annotation>
 </semantics>
</math>

</p>

<p>the orthogonal direct sum of countably many copies of <em>H</em>.</p>

<p>Let <em>V</em> be the isometry on 

<math display="inline" id="Contraction_(operator_theory):8">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

 defined by</p>

<p>

<math display="block" id="Contraction_(operator_theory):9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>ξ</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>ξ</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>ξ</mi>
       <mn>3</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>T</mi>
      <msub>
       <mi>ξ</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msqrt>
       <mrow>
        <mi>I</mi>
        <mo>-</mo>
        <mrow>
         <msup>
          <mi>T</mi>
          <mo>*</mo>
         </msup>
         <mi>T</mi>
        </mrow>
       </mrow>
      </msqrt>
      <msub>
       <mi>ξ</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi>ξ</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>ξ</mi>
      <mn>3</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ξ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ξ</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ξ</ci>
       <cn type="integer">3</cn>
      </apply>
      <ci>normal-…</ci>
     </vector>
    </apply>
    <vector>
     <apply>
      <times></times>
      <ci>T</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ξ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <root></root>
       <apply>
        <minus></minus>
        <ci>I</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>T</ci>
          <times></times>
         </apply>
         <ci>T</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ξ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-…</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{V(\xi_{1},\xi_{2},\xi_{3},\dots)=(T\xi_{1},\sqrt{I-T^{*}T}\xi_{1%
},\xi_{2},\xi_{3},\dots).}
  </annotation>
 </semantics>
</math>

</p>

<p>Let</p>

<p>

<math display="block" id="Contraction_(operator_theory):10">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒦</mi>
    <mo>=</mo>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">ℋ</mi>
     <mo>⊕</mo>
     <mi class="ltx_font_mathcaligraphic">ℋ</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝒦</ci>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <ci>ℋ</ci>
     <ci>ℋ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\mathcal{K}=\mathcal{H}\oplus\mathcal{H}.}
  </annotation>
 </semantics>
</math>

</p>

<p>Define a unitary <em>W</em> on 

<math display="inline" id="Contraction_(operator_theory):11">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒦</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒦</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{K}
  </annotation>
 </semantics>
</math>

 by</p>

<p>

<math display="block" id="Contraction_(operator_theory):12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>W</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>V</mi>
       <mi>x</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>I</mi>
         <mo>-</mo>
         <mrow>
          <mi>V</mi>
          <msup>
           <mi>V</mi>
           <mo>*</mo>
          </msup>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>y</mi>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <msup>
        <mi>V</mi>
        <mo>*</mo>
       </msup>
       <mi>y</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>W</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <interval closure="open">
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>V</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <ci>I</ci>
        <apply>
         <times></times>
         <ci>V</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>V</ci>
          <times></times>
         </apply>
        </apply>
       </apply>
       <ci>y</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>V</ci>
        <times></times>
       </apply>
       <ci>y</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{W(x,y)=(Vx+(I-VV^{*})y,-V^{*}y).}
  </annotation>
 </semantics>
</math>

</p>

<p><em>W</em> is then a unitary dilation of <em>T</em> with <em>H</em> considered as the first component of 

<math display="inline" id="Contraction_(operator_theory):13">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℋ</mi>
   <mo>⊂</mo>
   <mi class="ltx_font_mathcaligraphic">𝒦</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>ℋ</ci>
    <ci>𝒦</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}\subset\mathcal{K}
  </annotation>
 </semantics>
</math>

.</p>

<p>The minimal dilation <em>U</em> is obtained by taking the restriction of <em>W</em> to the closed subspace generated by powers of <em>W</em> applied to <em>H</em>.</p>
<h2 id="dilation-theorem-for-contraction-semigroups">Dilation theorem for contraction semigroups</h2>

<p>There is an alternative proof of Sz.-Nagy's dilation theorem, which allows significant generalisations.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Let <em>G</em> be a group, <em>U</em>(<em>g</em>) a unitary representation of <em>G</em> on a Hilbert space <em>K</em> and <em>P</em> an orthogonal projection onto a closed subspace <em>H</em> = <em>PK</em> of <em>K</em>.</p>

<p>The operator-valued function</p>

<p>

<math display="block" id="Contraction_(operator_theory):14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>g</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>P</mi>
     <mi>U</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>g</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>P</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>U</ci>
     <ci>g</ci>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\Phi(g)=PU(g)P,}
  </annotation>
 </semantics>
</math>

</p>

<p>with values in operators on <em>K</em> satisfies the positive-definiteness condition</p>

<p>

<math display="block" id="Contraction_(operator_theory):15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <msub>
       <mi>λ</mi>
       <mi>i</mi>
      </msub>
      <mover accent="true">
       <msub>
        <mi>λ</mi>
        <mi>j</mi>
       </msub>
       <mo>¯</mo>
      </mover>
      <mi mathvariant="normal">Φ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msubsup>
         <mi>g</mi>
         <mi>j</mi>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msubsup>
        <msub>
         <mi>g</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>P</mi>
     <msup>
      <mi>T</mi>
      <mo>*</mo>
     </msup>
     <mi>T</mi>
     <mi>P</mi>
    </mrow>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <sum></sum>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <ci>normal-¯</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>normal-Φ</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>g</ci>
          <ci>j</ci>
         </apply>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <times></times>
      </apply>
      <ci>T</ci>
      <ci>P</ci>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum\lambda_{i}\overline{\lambda_{j}}\Phi(g_{j}^{-1}g_{i})=PT^{*}TP\geq 0,
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Contraction_(operator_theory):16">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mo>=</mo>
    <mrow>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <msub>
       <mi>λ</mi>
       <mi>i</mi>
      </msub>
      <mi>U</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>g</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <sum></sum>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>i</ci>
      </apply>
      <ci>U</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{T=\sum\lambda_{i}U(g_{i}).}
  </annotation>
 </semantics>
</math>

</p>

<p>Moreover</p>

<p>

<math display="block" id="Contraction_(operator_theory):17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>P</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\Phi(1)=P.}
  </annotation>
 </semantics>
</math>

</p>

<p>Conversely, every operator-valued positive-definite function arises in this way. Recall that every (continuous) scalar-valued positive-definition function on a topological group is of the form φ(<em>g</em>) = 〈<em>U<sub>g</sub> v</em>, <em>v</em>〉 where <em>U<sub>g</sub></em> is a (strongly continuous) unitary representation (see <a href="Bochner's_theorem" title="wikilink">Bochner's theorem</a>). Replacing <em>v</em>, a rank-1 projection, by a general projection gives the operator-valued statement. In fact the construction is identical; this is sketched below.</p>

<p>Let 

<math display="inline" id="Contraction_(operator_theory):18">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

 be the space of functions on <em>G</em> of finite support with values in <em>H</em> with inner product</p>

<p>

<math display="block" id="Contraction_(operator_theory):19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>f</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>f</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>g</mi>
       <mo>,</mo>
       <mi>h</mi>
      </mrow>
     </munder>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">Φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msup>
          <mi>h</mi>
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msup>
         <mi>g</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>f</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>g</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <msub>
        <mi>f</mi>
        <mn>2</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>h</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <list>
       <ci>g</ci>
       <ci>h</ci>
      </list>
     </apply>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>normal-Φ</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>h</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>g</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>g</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>h</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{(f_{1},f_{2})=\sum_{g,h}(\Phi(h^{-1}g)f_{1}(g),f_{2}(h)).}
  </annotation>
 </semantics>
</math>

</p>

<p><em>G</em> acts unitarily on 

<math display="inline" id="Contraction_(operator_theory):20">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

 by</p>

<p>

<math display="block" id="Contraction_(operator_theory):21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>U</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>g</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>g</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>U</ci>
     <ci>g</ci>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{U(g)f(x)=f(g^{-1}x).}
  </annotation>
 </semantics>
</math>

</p>

<p>Moreover <em>H</em> can be identified with a closed subspace of 

<math display="inline" id="Contraction_(operator_theory):22">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

 using the isometric embedding sending <em>v</em> in <em>H</em> to <em>f</em><sub><em>v</em></sub> with</p>

<p>

<math display="block" id="Contraction_(operator_theory):23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>v</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>g</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>δ</mi>
      <mrow>
       <mi>g</mi>
       <mo>,</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mi>v</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>v</ci>
     </apply>
     <ci>g</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <list>
       <ci>g</ci>
       <cn type="integer">1</cn>
      </list>
     </apply>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{v}(g)=\delta_{g,1}v.\,
  </annotation>
 </semantics>
</math>

</p>

<p>If <em>P</em> is the projection of 

<math display="inline" id="Contraction_(operator_theory):24">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

 onto <em>H</em>, then</p>

<p>

<math display="block" id="Contraction_(operator_theory):25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mi>U</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>g</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>P</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>g</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>U</ci>
     <ci>g</ci>
     <ci>P</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <ci>g</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{PU(g)P=\Phi(g),}
  </annotation>
 </semantics>
</math>

</p>

<p>using the above identification.</p>

<p>When <em>G</em> is a separable topological group, Φ is continuous in the strong (or weak) operator topology if and only if <em>U</em> is.</p>

<p>In this case functions supported on a countable dense subgroup of <em>G</em> are dense in 

<math display="inline" id="Contraction_(operator_theory):26">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

, so that 

<math display="inline" id="Contraction_(operator_theory):27">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℋ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℋ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

 is separable.</p>

<p>When <em>G</em> = <strong>Z</strong> any contraction operator <em>T</em> defines such a function Φ through</p>

<p>

<math display="block" id="Contraction_(operator_theory):28">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi mathvariant="normal">Φ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mi>I</mi>
    </mrow>
    <mo rspace="7.6pt">,</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <msup>
       <mi>T</mi>
       <mi>n</mi>
      </msup>
     </mrow>
     <mo rspace="7.6pt">,</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mi>n</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>T</mi>
         <mo>*</mo>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>n</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>normal-Φ</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>I</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>normal-Φ</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>normal-Φ</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>T</ci>
        <times></times>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\Phi(0)=I,\,\,\,\Phi(n)=T^{n},\,\,\,\Phi(-n)=(T^{*})^{n},
  </annotation>
 </semantics>
</math>

</p>

<p>for <em>n</em> &gt; 0. The above construction then yields a minimal unitary dilation.</p>

<p>The same method can be applied to prove a second dilation theorem of Sz._Nagy for a one-parameter strongly continuous contraction semigroup <em>T</em>(<em>t</em>) (<em>t</em> ≥ 0) on a Hilbert space <em>H</em>.  had previously proved the result for one-parameter semigroups of isometries,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>The theorem states that there is a larger Hilbert space <em>K</em> containing <em>H</em> and a unitary representation <em>U</em>(<em>t</em>) of <strong>R</strong> such that</p>

<p>

<math display="block" id="Contraction_(operator_theory):29">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>U</ci>
     <ci>t</ci>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{T(t)=PU(t)P}
  </annotation>
 </semantics>
</math>

</p>

<p>and the translates <em>U</em>(<em>t</em>)<em>H</em> generate <em>K</em>.</p>

<p>In fact <em>T</em>(<em>t</em>) defines a continuous operator-valued positove-definite function Φ on <strong>R</strong> through</p>

<p>

<math display="block" id="Contraction_(operator_theory):30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi mathvariant="normal">Φ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mi>I</mi>
    </mrow>
    <mo rspace="7.6pt">,</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
       <mi>T</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo rspace="7.6pt">,</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mi>t</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
       <mi>T</mi>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>*</mo>
       </msup>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>normal-Φ</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>I</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>normal-Φ</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>normal-Φ</ci>
       <apply>
        <minus></minus>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>t</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\Phi(0)=I,\,\,\,\Phi(t)=T(t),\,\,\,\Phi(-t)=T(t)^{*},}
  </annotation>
 </semantics>
</math>

</p>

<p>for <em>t</em> &gt; 0. Φ is positive-definite on cyclic subgroups of <strong>R</strong>, by the argument for <strong>Z</strong>, and hence on <strong>R</strong> itself by continuity.</p>

<p>The previous construction yields a minimal unitary representation <em>U</em>(<em>t</em>) and projection <em>P</em>.</p>

<p>The <a href="Hille-Yosida_theorem" title="wikilink">Hille-Yosida theorem</a> assigns a closed <a href="unbounded_operator" title="wikilink">unbounded operator</a> <em>A</em> to every contractive one-parameter semigroup <em>T</em>'(<em>t</em>) through</p>

<p>

<math display="block" id="Contraction_(operator_theory):31">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mi>ξ</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo movablelimits="false">lim</mo>
      <mrow>
       <mi>t</mi>
       <mo>↓</mo>
       <mn>0</mn>
      </mrow>
     </munder>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mi>t</mi>
      </mfrac>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>T</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mi>I</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>ξ</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>ξ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-↓</ci>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>t</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>T</ci>
        <ci>t</ci>
       </apply>
       <ci>I</ci>
      </apply>
      <ci>ξ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{A\xi=\lim_{t\downarrow 0}{1\over t}(T(t)-I)\xi,}
  </annotation>
 </semantics>
</math>

</p>

<p>where the domain on <em>A</em> consists of all ξ for which this limit exists.</p>

<p><em>A</em> is called the <strong>generator</strong> of the semigroup and satisfies</p>

<p>

<math display="block" id="Contraction_(operator_theory):32">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi mathvariant="normal">ℜ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mi>ξ</mi>
      </mrow>
      <mo>,</mo>
      <mi>ξ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <minus></minus>
     <apply>
      <real></real>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>ξ</ci>
      </apply>
      <ci>ξ</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{-\Re(A\xi,\xi)\geq 0}
  </annotation>
 </semantics>
</math>

</p>

<p>on its domain. When <em>A</em> is a self-adjoint operator</p>

<p>

<math display="block" id="Contraction_(operator_theory):33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>e</mi>
     <mrow>
      <mi>A</mi>
      <mi>t</mi>
     </mrow>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{T(t)=e^{At},}
  </annotation>
 </semantics>
</math>

</p>

<p>in the sense of the <a href="spectral_theorem" title="wikilink">spectral theorem</a> and this notation is used more generally in semigroup theory.</p>

<p>The <strong>cogenerator</strong> of the semigroup is the contraction defined by</p>

<p>

<math display="block" id="Contraction_(operator_theory):34">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mo>+</mo>
       <mi>I</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mo>-</mo>
        <mi>I</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>A</ci>
      <ci>I</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>A</ci>
       <ci>I</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{T=(A+I)(A-I)^{-1}.}
  </annotation>
 </semantics>
</math>

</p>

<p><em>A</em> can be recovered from <em>T</em> using the formula</p>

<p>

<math display="block" id="Contraction_(operator_theory):35">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>T</mi>
       <mo>+</mo>
       <mi>I</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>T</mi>
        <mo>-</mo>
        <mi>I</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>T</ci>
      <ci>I</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>T</ci>
       <ci>I</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{A=(T+I)(T-I)^{-1}.}
  </annotation>
 </semantics>
</math>

</p>

<p>In particular a dilation of <em>T</em> on <em>K</em> ⊃ <em>H</em> immediately gives a dilation of the semigroup.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="functional-calculus">Functional calculus</h2>

<p>Let <em>T</em> be totally non-unitary contraction on <em>H</em>. Then the minimal unitary dilation <em>U</em> of <em>T</em> on <em>K</em> ⊃ <em>H</em> is unitarily equivalent to a direct sum of copies the bilateral shift operator, i.e. multiplication by <em>z</em> on L<sup>2</sup>(<em>S</em><sup>1</sup>).<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>If <em>P</em> is the orthogonal projection onto <em>H</em> then for <em>f</em> in L<sup>∞</sup> = L<sup>∞</sup>(<em>S</em><sup>1</sup>) it follows that the operator <em>f</em>(<em>T</em>) can be defined by</p>

<p>

<math display="block" id="Contraction_(operator_theory):36">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>ξ</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>P</mi>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>U</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>ξ</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>T</ci>
     <ci>ξ</ci>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>f</ci>
     <ci>U</ci>
     <ci>ξ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{f(T)\xi=Pf(U)\xi.}
  </annotation>
 </semantics>
</math>

</p>

<p>Let H<sup>∞</sup> be the space of bounded holomorphic functions on the unit disk <em>D</em>. Any such function has boundary values in L<sup>∞</sup> and is uniquely determined by these, so that there is an embedding H<sup>∞</sup> ⊂ L<sup>∞</sup>.</p>

<p>For <em>f</em> in H<sup>∞</sup>, <em>f</em>(<em>T</em>) can be defined without reference to the unitary dilation.</p>

<p>In fact if</p>

<p>

<math display="block" id="Contraction_(operator_theory):37">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>≥</mo>
      <mn>0</mn>
     </mrow>
    </munder>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>n</mi>
     </msub>
     <msup>
      <mi>z</mi>
      <mi>n</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <geq></geq>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{f(z)=\sum_{n\geq 0}a_{n}z^{n}}
  </annotation>
 </semantics>
</math>

</p>

<p>for |<em>z</em>| \displaystyle{f_r(z))=\sum_{n\ge 0} r^n a_n z^n}</p>

<p>is holomorphic on |<em>z</em>| <em>r</em>(<em>T</em>) is defined by the holomorphic functional calculus and <em>f</em>(<em>T</em>) can be defined by</p>

<p>

<math display="block" id="Contraction_(operator_theory):38">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>ξ</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo movablelimits="false">lim</mo>
      <mrow>
       <mi>r</mi>
       <mo>→</mo>
       <mn>1</mn>
      </mrow>
     </munder>
     <mrow>
      <msub>
       <mi>f</mi>
       <mi>r</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>T</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>ξ</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>T</ci>
     <ci>ξ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>r</ci>
      </apply>
      <ci>T</ci>
      <ci>ξ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{f(T)\xi=\lim_{r\rightarrow 1}f_{r}(T)\xi.}
  </annotation>
 </semantics>
</math>

</p>

<p>The map sending <em>f</em> to <em>f</em>(<em>T</em>) defines an algebra homomorphism of H<sup>∞</sup> into bounded operators on <em>H</em>. Moreover if</p>

<p>

<math display="block" id="Contraction_(operator_theory):39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>f</mi>
      <mo>∼</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>≥</mo>
       <mn>0</mn>
      </mrow>
     </munder>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>n</mi>
      </msub>
      <msup>
       <mover accent="true">
        <mi>z</mi>
        <mo>¯</mo>
       </mover>
       <mi>n</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <csymbol cd="latexml">similar-to</csymbol>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <geq></geq>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-¯</ci>
        <ci>z</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{f^{\sim}(z)=\sum_{n\geq 0}a_{n}\overline{z}^{n},}
  </annotation>
 </semantics>
</math>

</p>

<p>then</p>

<p>

<math display="block" id="Contraction_(operator_theory):40">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>f</mi>
      <mo>∼</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>T</mi>
        <mo>*</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>*</mo>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <csymbol cd="latexml">similar-to</csymbol>
     </apply>
     <ci>T</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <times></times>
      </apply>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{f^{\sim}(T)=f(T^{*})^{*}.}
  </annotation>
 </semantics>
</math>

</p>

<p>This map has the following continuity property: if a uniformly bounded sequence <em>f</em><sub><em>n</em></sub> tends almost everywhere to <em>f</em>, then <em>f</em><sub><em>n</em></sub>(<em>T</em>) tends to <em>f</em>(<em>T</em>) in the strong operator topology.</p>

<p>For <em>t</em> ≥ 0, let <em>e</em><sub><em>t</em></sub> be the inner function</p>

<p>

<math display="block" id="Contraction_(operator_theory):41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>e</mi>
      <mi>t</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mi>t</mi>
      <mfrac>
       <mrow>
        <mi>z</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mrow>
        <mi>z</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mfrac>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>t</ci>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <exp></exp>
     <apply>
      <times></times>
      <ci>t</ci>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <ci>z</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <minus></minus>
        <ci>z</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{e_{t}(z)=\exp t{z+1\over z-1}.}
  </annotation>
 </semantics>
</math>

</p>

<p>If <em>T</em> is the cogenerator of a one-parameter semigroup of completely non-unitary contractions <em>T</em>(<em>t</em>), then</p>

<p>

<math display="block" id="Contraction_(operator_theory):42">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>e</mi>
     <mi>t</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>t</ci>
     </apply>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{T(t)=e_{t}(T)}
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Contraction_(operator_theory):43">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
      <mi>I</mi>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
      <mrow>
       <msubsup>
        <mo largeop="true" symmetric="true">∫</mo>
        <mn>0</mn>
        <mi mathvariant="normal">∞</mi>
       </msubsup>
       <mrow>
        <msup>
         <mi>e</mi>
         <mrow>
          <mo>-</mo>
          <mi>t</mi>
         </mrow>
        </msup>
        <mi>T</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo rspace="4.2pt" stretchy="false">)</mo>
        </mrow>
        <mi>d</mi>
        <mi>t</mi>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <ci>I</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <cn type="integer">0</cn>
        </apply>
        <infinity></infinity>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <apply>
          <minus></minus>
          <ci>t</ci>
         </apply>
        </apply>
        <ci>T</ci>
        <ci>t</ci>
        <ci>d</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{T={1\over 2}I-{1\over 2}\int_{0}^{\infty}e^{-t}T(t)\,dt.}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="c0-contractions">C<sub>0</sub> contractions</h2>

<p>A completely non-unitary contraction <em>T</em> is said to belong to the class C<sub>0</sub> if and only if <em>f</em>(<em>T</em>) = 0 for some non-zero <em>f</em> in H<sup>∞</sup>. In this case the set of such <em>f</em> forms an ideal in H<sup>∞</sup>. It has the form φ ⋅ H<sup>∞</sup> where <em>g</em> is an <a href="inner_function" title="wikilink">inner function</a>, i.e. such that |φ| = 1 on <em>S</em><sup>1</sup>: φ is uniquely determined up to multiplication by a complex number of modulus 1 and is called the <strong>minimal function</strong> of <em>T</em>. It has properties analogous to the <a href="minimal_polynomial" title="wikilink">minimal polynomial</a> of a matrix.</p>

<p>The minimal function φ admits a canonical factorization</p>

<p>

<math display="block" id="Contraction_(operator_theory):44">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>c</mi>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>z</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>φ</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>B</ci>
     <ci>z</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>P</ci>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\varphi(z)=cB(z)e^{-P(z)},}
  </annotation>
 </semantics>
</math>

</p>

<p>where |<em>c</em>|=1, <em>B</em>(<em>z</em>) is a <a href="Blaschke_product" title="wikilink">Blaschke product</a></p>

<p>

<math display="block" id="Contraction_(operator_theory):45">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <msup>
      <mrow>
       <mo>[</mo>
       <mrow>
        <mfrac>
         <mrow>
          <mo stretchy="false">|</mo>
          <msub>
           <mi>λ</mi>
           <mi>i</mi>
          </msub>
          <mo stretchy="false">|</mo>
         </mrow>
         <msub>
          <mi>λ</mi>
          <mi>i</mi>
         </msub>
        </mfrac>
        <mfrac>
         <mrow>
          <msub>
           <mi>λ</mi>
           <mi>i</mi>
          </msub>
          <mo>-</mo>
          <mi>z</mi>
         </mrow>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <msub>
           <mover accent="true">
            <mi>λ</mi>
            <mo>¯</mo>
           </mover>
           <mi>i</mi>
          </msub>
         </mrow>
        </mfrac>
       </mrow>
       <mo>]</mo>
      </mrow>
      <msub>
       <mi>m</mi>
       <mi>i</mi>
      </msub>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>B</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">product</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <abs></abs>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>λ</ci>
           <ci>i</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>λ</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>λ</ci>
           <ci>i</ci>
          </apply>
          <ci>z</ci>
         </apply>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <ci>normal-¯</ci>
            <ci>λ</ci>
           </apply>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{B(z)=\prod\left[{|\lambda_{i}|\over\lambda_{i}}{\lambda_{i}-z%
\over 1-\overline{\lambda}_{i}}\right]^{m_{i}},}
  </annotation>
 </semantics>
</math>

</p>

<p>with</p>

<p>

<math display="block" id="Contraction_(operator_theory):46">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <msub>
       <mi>m</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <mo stretchy="false">|</mo>
         <msub>
          <mi>λ</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">|</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo><</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <sum></sum>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <abs></abs>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\sum m_{i}(1-|\lambda_{i}|)<\infty,}
  </annotation>
 </semantics>
</math>

</p>

<p>and <em>P</em>(<em>z</em>) is holomorphic with non-negative real part in <em>D</em>. By the <a href="positive_harmonic_function#Herglotz_representation_theorem_for_holomorphic_functions" title="wikilink">Herglotz representation theorem</a>,</p>

<p>

<math display="block" id="Contraction_(operator_theory):47">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mn>0</mn>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
     </mrow>
    </msubsup>
    <mrow>
     <mpadded width="+1.7pt">
      <mfrac>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mrow>
         <msup>
          <mi>e</mi>
          <mrow>
           <mo>-</mo>
           <mrow>
            <mi>i</mi>
            <mi>θ</mi>
           </mrow>
          </mrow>
         </msup>
         <mi>z</mi>
        </mrow>
       </mrow>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <msup>
          <mi>e</mi>
          <mrow>
           <mo>-</mo>
           <mrow>
            <mi>i</mi>
            <mi>θ</mi>
           </mrow>
          </mrow>
         </msup>
         <mi>z</mi>
        </mrow>
       </mrow>
      </mfrac>
     </mpadded>
     <mi>d</mi>
     <mi>μ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>θ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>e</ci>
          <apply>
           <minus></minus>
           <apply>
            <times></times>
            <ci>i</ci>
            <ci>θ</ci>
           </apply>
          </apply>
         </apply>
         <ci>z</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>e</ci>
          <apply>
           <minus></minus>
           <apply>
            <times></times>
            <ci>i</ci>
            <ci>θ</ci>
           </apply>
          </apply>
         </apply>
         <ci>z</ci>
        </apply>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>μ</ci>
      <ci>θ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{P(z)=\int_{0}^{2\pi}{1+e^{-i\theta}z\over 1-e^{-i\theta}z}\,d\mu%
(\theta)}
  </annotation>
 </semantics>
</math>

</p>

<p>for some non-negative finite measure μ on the circle: in this case, if non-zero, μ must be <a href="singular_measure" title="wikilink">singular</a> with respect to Lebesgue measure. In the above decomposition of φ, either of the two factors can be absent.</p>

<p>The minimal function φ determines the <a class="uri" href="spectrum" title="wikilink">spectrum</a> of <em>T</em>. Within the unit disk, the spectral values are the zeros of φ. There are at most countably many such λ<sub>i</sub>, all eigenvalues of <em>T</em>, the zeros of <em>B</em>(<em>z</em>). A point of the unit circle does not lie in the spectrum of <em>T</em> if and only if φ has a holomorphic continuation to a neighbourhood of that point.</p>

<p>φ reduces to a Blaschke product exactly when <em>H</em> equals the closure of the direct sum (not necessarily orthogonal) of the generalized eigenspaces<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>

<math display="block" id="Contraction_(operator_theory):48">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>ξ</mi>
     <mo>:</mo>
     <mrow>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>T</mi>
          <mo>-</mo>
          <mrow>
           <msub>
            <mi>λ</mi>
            <mi>i</mi>
           </msub>
           <mi>I</mi>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <msub>
         <mi>m</mi>
         <mi>i</mi>
        </msub>
       </msup>
       <mi>ξ</mi>
      </mrow>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>ξ</ci>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>T</ci>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>λ</ci>
           <ci>i</ci>
          </apply>
          <ci>I</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <ci>ξ</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{H_{i}=\{\xi:(T-\lambda_{i}I)^{m_{i}}\xi=0\}.}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="quasi-similarity">Quasi-similarity</h2>

<p>Two contractions <em>T</em><sub>1</sub> and <em>T</em><sub>2</sub> are said to be <strong>quasi-similar</strong> when there are bounded operators <em>A</em>, <em>B</em> with trivial kernel and dense range such that</p>

<p>

<math display="block" id="Contraction_(operator_theory):49">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>A</mi>
      <msub>
       <mi>T</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msub>
       <mi>T</mi>
       <mn>2</mn>
      </msub>
      <mi>A</mi>
     </mrow>
    </mrow>
    <mo rspace="7.6pt">,</mo>
    <mrow>
     <mrow>
      <mi>B</mi>
      <msub>
       <mi>T</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msub>
       <mi>T</mi>
       <mn>1</mn>
      </msub>
      <mi>B</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>B</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{AT_{1}=T_{2}A,\,\,\,BT_{2}=T_{1}B.}
  </annotation>
 </semantics>
</math>

</p>

<p>The following properties of a contraction <em>T</em> are preserved under quasi-similarlity:</p>
<ul>
<li>being unitary</li>
<li>being completely non-unitary</li>
<li>being in the class C<sub>0</sub></li>
<li>being <strong>multiplicity free</strong>, i.e. having a commutative <a class="uri" href="commutant" title="wikilink">commutant</a></li>
</ul>

<p>Two quasi-similar C<sub>0</sub> contractions have the same minimal function and hence the same spectrum.</p>

<p>The <strong>classification theorem</strong> for C<sub>0</sub> contractions states that two multiplicity free C<sub>0</sub> contractions are quasi-similar if and only if they have the same minimal function (up to a scalar multiple).<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>A model for multiplicity free C<sub>0</sub> contractions with minimal function φ is given by taking</p>

<p>

<math display="block" id="Contraction_(operator_theory):50">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>H</mi>
      <mn>2</mn>
     </msup>
     <mo>⊖</mo>
     <mrow>
      <mi>φ</mi>
      <msup>
       <mi>H</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <apply>
     <csymbol cd="latexml">symmetric-difference</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <ci>φ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{H=H^{2}\ominus\varphi H^{2},}
  </annotation>
 </semantics>
</math>

</p>

<p>where H<sup>2</sup> is the <a href="Hardy_space" title="wikilink">Hardy space</a> of the circle and letting <em>T</em> be multiplication by <em>z</em>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>Such operators are called <strong>Jordan blocks</strong> and denoted <em>S</em>(φ).</p>

<p>As a generalization of <a href="Beurling's_theorem" title="wikilink">Beurling's theorem</a>, the commutant of such an operator consists exactly of operators ψ(<em>T</em>) with ψ in <em>H</em><sup>≈</sup>, i.e. multiplication operators on <em>H</em><sup>2</sup> corresponding to functions in <em>H</em><sup>≈</sup>.</p>

<p>A C<sub>0</sub> contraction operator <em>T</em> is multiplcity free if and only if it is quasi-similar to a Jordan block (necessarily corresponding the one corresponding to its minimal function).</p>

<p><strong>Examples.</strong></p>
<ul>
<li>If a contraction <em>T</em> if quasi-similar to an operator <em>S</em> with</li>
</ul>

<p>

<math display="block" id="Contraction_(operator_theory):51">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <msub>
     <mi>e</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>λ</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>e</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{Se_{i}=\lambda_{i}e_{i}}
  </annotation>
 </semantics>
</math>

</p>

<p>with the λ<sub>i</sub>'s distinct, of modulus less than 1, such that</p>

<p>

<math display="block" id="Contraction_(operator_theory):52">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>λ</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <sum></sum>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{\sum(1-|\lambda_{i}|)<1}
  </annotation>
 </semantics>
</math>

</p>

<p>and (<em>e</em><sub><em>i</em></sub>) is an orthonormal basis, then <em>S</em>, and hence <em>T</em>, is C<sub>0</sub> and multiplicity free. Hence <em>H</em> is the closure of direct sum of the λ<sub>i</sub>-eigenspaces of <em>T</em>, each having multiplicity one. This can also be seen directly using the definition of quasi-similarity.</p>
<ul>
<li>The results above can be applied equally well to one-parameter semigroups, since, from the functional calculus, two semigroups are quasi-similar if and only if their cogenerators are quasi-similar.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></li>
</ul>

<p><strong>Classification theorem for C<sub>0</sub> contractions:</strong> <em>Every C<sub>0</sub> contraction is canonically quasi-similar to a direct sum of Jordan blocks.</em></p>

<p>In fact every C<sub>0</sub> contraction is quasi-similar to a unique operator of the form</p>

<p>

<math display="block" id="Contraction_(operator_theory):53">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>φ</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊕</mo>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>φ</mi>
        <mn>1</mn>
       </msub>
       <msub>
        <mi>φ</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊕</mo>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>φ</mi>
        <mn>1</mn>
       </msub>
       <msub>
        <mi>φ</mi>
        <mn>2</mn>
       </msub>
       <msub>
        <mi>φ</mi>
        <mn>3</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊕</mo>
    <mi mathvariant="normal">⋯</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>φ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>φ</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle{S=S(\varphi_{1})\oplus S(\varphi_{1}\varphi_{2})\oplus S(\varphi%
_{1}\varphi_{2}\varphi_{3})\oplus\cdots}
  </annotation>
 </semantics>
</math>

</p>

<p>where the φ<sub><em>n</em></sub> are uniquely determined inner functions, with φ<sub><em>1</em></sub> the minimal function of <em>S</em> and hence <em>T</em>.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Kallman–Rota_inequality" title="wikilink">Kallman–Rota inequality</a></li>
<li><a href="Stinespring_dilation_theorem" title="wikilink">Stinespring dilation theorem</a></li>
<li><a href="Hille-Yosida_theorem#Hille-Yosida_theorem_for_contraction_semigroups" title="wikilink">Hille-Yosida theorem for contraction semigroups</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Operator_theory" title="wikilink">Category:Operator theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
</ol>
</section>
</body>
</html>
