<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="435">Operator theory</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Operator theory</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <strong>operator theory</strong> is the study of <a href="linear_operator" title="wikilink">linear operators</a> on <a href="function_space" title="wikilink">function spaces</a>, beginning with <a href="differential_operator" title="wikilink">differential operators</a> and <a href="integral_operator" title="wikilink">integral operators</a>. The operators may be presented abstractly by their characteristics, such as <a href="bounded_linear_operator" title="wikilink">bounded linear operators</a> or <a href="closed_operator" title="wikilink">closed operators</a>, and consideration may be given to <a href="nonlinear_operator" title="wikilink">nonlinear operators</a>. The study, which depends heavily on the <a class="uri" href="topology" title="wikilink">topology</a> of function spaces, is a branch of <a href="functional_analysis" title="wikilink">functional analysis</a>.</p>

<p>If a collection of operators forms an <a href="algebra_over_a_field" title="wikilink">algebra over a field</a>, then it is an <a href="operator_algebra" title="wikilink">operator algebra</a>. The description of operator algebras is part of operator theory.</p>
<h2 id="single-operator-theory">Single operator theory</h2>

<p>Single operator theory deals with the properties and classification of single operators. For example, the classification of <a href="normal_operator" title="wikilink">normal operators</a> in terms of their <a href="spectrum_of_an_operator" title="wikilink">spectra</a> falls into this category.</p>
<h3 id="spectrum-of-operators">Spectrum of operators</h3>

<p>The <strong>spectral theorem</strong> is any of a number of results about <a href="linear_operator" title="wikilink">linear operators</a> or about <a href="matrix_(mathematics)" title="wikilink">matrices</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> In broad terms the spectral <a class="uri" href="theorem" title="wikilink">theorem</a> provides conditions under which an <a href="Operator_(mathematics)" title="wikilink">operator</a> or a matrix can be <a href="Diagonalizable_matrix" title="wikilink">diagonalized</a> (that is, represented as a <a href="diagonal_matrix" title="wikilink">diagonal matrix</a> in some basis). This concept of diagonalization is relatively straightforward for operators on finite-dimensional spaces, but requires some modification for operators on infinite-dimensional spaces. In general, the spectral theorem identifies a class of <a href="linear_operator" title="wikilink">linear operators</a> that can be modelled by <a href="multiplication_operator" title="wikilink">multiplication operators</a>, which are as simple as one can hope to find. In more abstract language, the spectral theorem is a statement about commutative <a href="C*-algebra" title="wikilink">C*-algebras</a>. See also <a href="spectral_theory" title="wikilink">spectral theory</a> for a historical perspective.</p>

<p>Examples of operators to which the spectral theorem applies are <a href="self-adjoint_operator" title="wikilink">self-adjoint operators</a> or more generally <a href="normal_operator" title="wikilink">normal operators</a> on <a href="Hilbert_space" title="wikilink">Hilbert spaces</a>.</p>

<p>The spectral theorem also provides a <a href="canonical_form" title="wikilink">canonical</a> decomposition, called the <strong>spectral decomposition</strong>, <strong>eigenvalue decomposition</strong>, or <strong><a href="eigendecomposition_of_a_matrix" title="wikilink">eigendecomposition</a></strong>, of the underlying vector space on which the operator acts.</p>
<h4 id="normal-operators">Normal operators</h4>

<p>A <strong>normal operator</strong> on a complex <a href="Hilbert_space" title="wikilink">Hilbert space</a> <em>H</em> is a <a href="continuous_function_(topology)" title="wikilink">continuous</a> <a href="linear_operator" title="wikilink">linear operator</a> <em>N</em> : <em>H</em> → <em>H</em> that <a href="commutator" title="wikilink">commutes</a> with its <a href="hermitian_adjoint" title="wikilink">hermitian adjoint</a> <em>N*</em>, that is: <em>NN*</em> = <em>N*N</em>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Normal operators are important because the <a href="spectral_theorem" title="wikilink">spectral theorem</a> holds for them. Today, the class of normal operators is well-understood. Examples of normal operators are</p>
<ul>
<li><a href="unitary_operator" title="wikilink">unitary operators</a>: <em>N*</em> = <em>N</em><sup>−1</sup></li>
<li><a href="Hermitian_operator" title="wikilink">Hermitian operators</a> (i.e., selfadjoint operators): <em>N*</em> = <em>N</em>; (also, anti-selfadjoint operators: <em>N*</em> = −<em>N</em>)</li>
<li><a href="positive_operator" title="wikilink">positive operators</a>: <em>N</em> = <em>MM*</em></li>
<li><a href="Normal_matrix" title="wikilink">normal matrices</a> can be seen as normal operators if one takes the Hilbert space to be <strong>C</strong><sup><em>n</em></sup>.</li>
</ul>

<p>The spectral theorem extends to a more general class of matrices. Let <em>A</em> be an operator on a finite-dimensional inner product space. <em>A</em> is said to be <a href="normal_matrix" title="wikilink">normal</a> if <em>A</em><sup>*</sup> <em>A</em> = <em>A A</em><sup>*</sup>. One can show that <em>A</em> is normal if and only if it is unitarily diagonalizable: By the <a href="Schur_decomposition" title="wikilink">Schur decomposition</a>, we have <em>A</em> = <em>U T U</em><sup>*</sup>, where <em>U</em> is unitary and <em>T</em> upper-triangular. Since <em>A</em> is normal, <em>T T</em><sup>*</sup> = <em>T</em><sup>*</sup> <em>T</em>. Therefore <em>T</em> must be diagonal since normal upper triangular matrices are diagonal. The converse is obvious.</p>

<p>In other words, <em>A</em> is normal if and only if there exists a <a href="unitary_matrix" title="wikilink">unitary matrix</a> <em>U</em> such that</p>

<p>

<math display="block" id="Operator_theory:0">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mi>U</mi>
    <mi>D</mi>
    <mpadded width="+2.8pt">
     <msup>
      <mi>U</mi>
      <mo>*</mo>
     </msup>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>U</ci>
     <ci>D</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>U</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=UDU^{*}\;
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>D</em> is a <a href="diagonal_matrix" title="wikilink">diagonal matrix</a>. Then, the entries of the diagonal of <em>D</em> are the <a href="eigenvalue" title="wikilink">eigenvalues</a> of <em>A</em>. The column vectors of <em>U</em> are the eigenvectors of <em>A</em> and they are orthonormal. Unlike the Hermitian case, the entries of <em>D</em> need not be real.</p>
<h3 id="polar-decomposition">Polar decomposition</h3>

<p>The <strong>polar decomposition</strong> of any <a href="bounded_linear_operator" title="wikilink">bounded linear operator</a> <em>A</em> between complex <a href="Hilbert_space" title="wikilink">Hilbert spaces</a> is a canonical factorization as the product of a <a href="partial_isometry" title="wikilink">partial isometry</a> and a non-negative operator.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>The polar decomposition for matrices generalizes as follows: if <em>A</em> is a bounded linear operator then there is a unique factorization of <em>A</em> as a product <em>A</em> = <em>UP</em> where <em>U</em> is a partial isometry, <em>P</em> is a non-negative self-adjoint operator and the initial space of <em>U</em> is the closure of the range of <em>P</em>.</p>

<p>The operator <em>U</em> must be weakened to a partial isometry, rather than unitary, because of the following issues. If <em>A</em> is the <a href="shift_operator" title="wikilink">one-sided shift</a> on <em>l</em><sup>2</sup>(<strong>N</strong>), then |<em>A</em>| = {<em>A*A</em>}<sup>½</sup> = <em>I</em>. So if <em>A</em> = <em>U</em> |<em>A</em>|, <em>U</em> must be <em>A</em>, which is not unitary.</p>

<p>The existence of a polar decomposition is a consequence of <a href="Douglas'_lemma" title="wikilink">Douglas' lemma</a>:</p>
<dl>
<dd><strong>Lemma</strong> If <em>A</em>, <em>B</em> are bounded operators on a Hilbert space <em>H</em>, and <em>A*A</em> ≤ <em>B*B</em>, then there exists a contraction <em>C</em> such that <em>A = CB</em>. Furthermore, <em>C</em> is unique if <em>Ker</em>(<em>B*</em>) ⊂ <em>Ker</em>(<em>C</em>).
</dd>
</dl>

<p>The operator <em>C</em> can be defined by <em>C(Bh)</em> = <em>Ah</em>, extended by continuity to the closure of <em>Ran</em>(<em>B</em>), and by zero on the orthogonal complement to all of <em>H</em>. The lemma then follows since <em>A*A</em> ≤ <em>B*B</em> implies <em>Ker</em>(<em>A</em>) ⊂ <em>Ker</em>(<em>B</em>).</p>

<p>In particular. If <em>A*A</em> = <em>B*B</em>, then <em>C</em> is a partial isometry, which is unique if <em>Ker</em>(<em>B*</em>) ⊂ <em>Ker</em>(<em>C</em>). In general, for any bounded operator <em>A</em>,</p>

<p>

<math display="block" id="Operator_theory:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>A</mi>
      <mo>*</mo>
     </msup>
     <mi>A</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>A</mi>
         <mo>*</mo>
        </msup>
        <mi>A</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </msup>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>A</mi>
         <mo>*</mo>
        </msup>
        <mi>A</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <times></times>
     </apply>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <times></times>
       </apply>
       <ci>A</ci>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <times></times>
       </apply>
       <ci>A</ci>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{*}A=(A^{*}A)^{\frac{1}{2}}(A^{*}A)^{\frac{1}{2}},
  </annotation>
 </semantics>
</math>

</p>

<p>where (<em>A*A</em>)<sup>½</sup> is the unique positive square root of <em>A*A</em> given by the usual <a href="functional_calculus" title="wikilink">functional calculus</a>. So by the lemma, we have</p>

<p>

<math display="block" id="Operator_theory:2">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mi>U</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>A</mi>
        <mo>*</mo>
       </msup>
       <mi>A</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>U</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <times></times>
       </apply>
       <ci>A</ci>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=U(A^{*}A)^{\frac{1}{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>for some partial isometry <em>U</em>, which is unique if <em>Ker</em>(<em>A*</em>) ⊂ <em>Ker</em>(<em>U</em>). Take <em>P</em> to be (<em>A*A</em>)<sup>½</sup> and one obtains the polar decomposition <em>A</em> = <em>UP</em>. Notice that an analogous argument can be used to show ''A = P'U' '', where ''P' '' is positive and ''U' '' a partial isometry.</p>

<p>When <em>H</em> is finite dimensional, <em>U</em> can be extended to a unitary operator; this is not true in general (see example above). Alternatively, the polar decomposition can be shown using the operator version of <a href="singular_value_decomposition#Bounded_operators_on_Hilbert_spaces" title="wikilink">singular value decomposition</a>.</p>

<p>By property of the <a href="continuous_functional_calculus" title="wikilink">continuous functional calculus</a>, <em>|A|</em> is in the <a class="uri" href="C*-algebra" title="wikilink">C*-algebra</a> generated by <em>A</em>. A similar but weaker statement holds for the partial isometry: <em>U</em> is in the <a href="von_Neumann_algebra" title="wikilink">von Neumann algebra</a> generated by <em>A</em>. If <em>A</em> is invertible, the polar part <em>U</em> will be in the <a class="uri" href="C*-algebra" title="wikilink">C*-algebra</a> as well.</p>
<h2 id="operator-algebras">Operator algebras</h2>

<p>The theory of <a href="operator_algebra" title="wikilink">operator algebras</a> brings <a href="algebra_over_a_field" title="wikilink">algebras</a> of operators such as <a href="C*-algebra" title="wikilink">C*-algebras</a> to the fore.</p>
<h3 id="c-algebras">C*-algebras</h3>

<p>A C*-algebra, <em>A</em>, is a <a href="Banach_algebra" title="wikilink">Banach algebra</a> over the field of <a href="complex_number" title="wikilink">complex numbers</a>, together with a <a href="Map_(mathematics)" title="wikilink">map</a> * : <em>A</em> → <em>A</em>. One writes <em>x*</em> for the image of an element <em>x</em> of <em>A</em>. The map * has the following properties:<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<ul>
<li>It is an <a href="Semigroup_with_involution" title="wikilink">involution</a>, for every <em>x</em> in <em>A</em></li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Operator_theory:3">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mrow>
     <mi></mi>
     <mo>*</mo>
     <mo>*</mo>
    </mrow>
   </msup>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mo>*</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
   </msup>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <apply>
       <times></times>
       <csymbol cd="latexml">absent</csymbol>
       <times></times>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
      <times></times>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{**}=(x^{*})^{*}=x
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>
<ul>
<li>For all <em>x</em>, <em>y</em> in <em>A</em>:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Operator_theory:4">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>+</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mo>*</mo>
    </msup>
    <mo>+</mo>
    <msup>
     <mi>y</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <times></times>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x+y)^{*}=x^{*}+y^{*}
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Operator_theory:5">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>y</mi>
     <mo>*</mo>
    </msup>
    <msup>
     <mi>x</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <times></times>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (xy)^{*}=y^{*}x^{*}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li>For every λ in <strong>C</strong> and every <em>x</em> in <em>A</em>:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Operator_theory:6">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>λ</mi>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>*</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <mover accent="true">
      <mi>λ</mi>
      <mo>¯</mo>
     </mover>
     <msup>
      <mi>x</mi>
      <mo>*</mo>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
     <times></times>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-¯</ci>
      <ci>λ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x)^{*}=\overline{\lambda}x^{*}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li>For all <em>x</em> in <em>A</em>:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Operator_theory:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <msup>
       <mi>x</mi>
       <mo>*</mo>
      </msup>
      <mi>x</mi>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>∥</mo>
      <mi>x</mi>
      <mo>∥</mo>
     </mrow>
     <mrow>
      <mo>∥</mo>
      <msup>
       <mi>x</mi>
       <mo>*</mo>
      </msup>
      <mo>∥</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|x^{*}x\|=\|x\|\|x^{*}\|.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p><strong>Remark.</strong> The first three identities say that <em>A</em> is a <a class="uri" href="*-algebra" title="wikilink">*-algebra</a>. The last identity is called the <strong>C* identity</strong> and is equivalent to:</p>

<p>

<math display="inline" id="Operator_theory:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>x</mi>
      <msup>
       <mi>x</mi>
       <mo>*</mo>
      </msup>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo>∥</mo>
      <mi>x</mi>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <times></times>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>x</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|xx^{*}\|=\|x\|^{2},
  </annotation>
 </semantics>
</math>


</p>

<p>The C*-identity is a very strong requirement. For instance, together with the <a href="spectral_radius" title="wikilink">spectral radius formula</a>, it implies that the C*-norm is uniquely determined by the algebraic structure:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Operator_theory:9">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo>∥</mo>
      <mi>x</mi>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <msup>
       <mi>x</mi>
       <mo>*</mo>
      </msup>
      <mi>x</mi>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>sup</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>λ</mi>
       <mo stretchy="false">|</mo>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mrow>
        <msup>
         <mi>x</mi>
         <mo>*</mo>
        </msup>
        <mi>x</mi>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>λ</mi>
        <mn>1</mn>
        <mtext>is not invertible</mtext>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>x</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <times></times>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">supremum</csymbol>
      <apply>
       <csymbol cd="latexml">conditional-set</csymbol>
       <apply>
        <abs></abs>
        <ci>λ</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <times></times>
         </apply>
         <ci>x</ci>
        </apply>
        <apply>
         <times></times>
         <ci>λ</ci>
         <cn type="float">1</cn>
         <mtext>is not invertible</mtext>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|x\|^{2}=\|x^{*}x\|=\sup\{|\lambda|:x^{*}x-\lambda\,1\text{ is not invertible%
}\}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Invariant_subspace" title="wikilink">Invariant subspace</a></li>
<li><a href="Functional_calculus" title="wikilink">Functional calculus</a></li>
<li><a href="Spectral_theory" title="wikilink">Spectral theory</a>
<ul>
<li><a href="Resolvent_formalism" title="wikilink">Resolvent formalism</a></li>
</ul></li>
<li><a href="Compact_operator" title="wikilink">Compact operator</a>
<ul>
<li><a href="Fredholm_theory" title="wikilink">Fredholm theory</a> of <a href="integral_equation" title="wikilink">integral equations</a>
<ul>
<li><a href="Integral_operator" title="wikilink">Integral operator</a></li>
<li><a href="Fredholm_operator" title="wikilink">Fredholm operator</a></li>
</ul></li>
</ul></li>
<li><a href="Self-adjoint_operator" title="wikilink">Self-adjoint operator</a></li>
<li><a href="Unbounded_operator" title="wikilink">Unbounded operator</a>
<ul>
<li><a href="Differential_operator" title="wikilink">Differential operator</a></li>
</ul></li>
<li><a href="Umbral_calculus" title="wikilink">Umbral calculus</a></li>
<li><a href="Contraction_mapping" title="wikilink">Contraction mapping</a></li>
<li><a href="Positive_operator" title="wikilink">Positive operator</a> on a <a href="Hilbert_space" title="wikilink">Hilbert space</a></li>
<li><a href="Perron–Frobenius_theorem#Generalizations" title="wikilink">Nonnegative operator</a> on a <a href="ordered_vector_space" title="wikilink">partially ordered vector space</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li><a href="John_B._Conway" title="wikilink">Conway, J. B.</a>: <em>A Course in Functional Analysis</em>, 2nd edition, Springer-Verlag, 1994, ISBN 0-387-97245-5</li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.mathphysics.com/opthy/OpHistory.html">History of Operator Theory</a></li>
</ul>

<p>"</p>

<p><a href="Category:Operator_theory" title="wikilink"> </a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Sunder, V.S. ''Functional Analysis: Spectral Theory (1997) Birkhäuser Verlag<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">. An excellent introduction to the subject, accessible for those with a knowledge of basic <a href="functional_analysis" title="wikilink">functional analysis</a>.<a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
