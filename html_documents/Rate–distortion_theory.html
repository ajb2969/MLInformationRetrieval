<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="852">Rate–distortion theory</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Rate–distortion theory</h1>
<hr/>

<p><strong>Rate–distortion theory</strong> is a major branch of <a href="information_theory" title="wikilink">information theory</a> which provides the theoretical foundations for <a href="lossy_data_compression" title="wikilink">lossy data compression</a>; it addresses the problem of determining the minimal number of bits per symbol, as measured by the rate <em>R</em>, that should be communicated over a channel, so that the source (input signal) can be approximately reconstructed at the receiver (output signal) without exceeding a given distortion <em>D</em>.</p>
<h2 id="introduction">Introduction</h2>

<p>Rate–distortion theory gives an analytical expression for how much compression can be achieved using lossy compression methods. Many of the existing audio, speech, image, and video compression techniques have transforms, quantization, and bit-rate allocation procedures that capitalize on the general shape of rate–distortion functions.</p>

<p>Rate–distortion theory was created by <a href="Claude_Shannon" title="wikilink">Claude Shannon</a> in his foundational work on information theory.</p>

<p>In rate–distortion theory, the <em>rate</em> is usually understood as the number of <a href="bit" title="wikilink">bits</a> per data sample to be stored or transmitted. The notion of <em>distortion</em> is a subject of on-going discussion. In the most simple case (which is actually used in most cases), the distortion is defined as the expected value of the square of the difference between input and output signal (i.e., the <a href="mean_squared_error" title="wikilink">mean squared error</a> ). However, since we know that most <a href="lossy_compression" title="wikilink">lossy compression</a> techniques operate on data that will be perceived by human consumers (listening to music, watching pictures and video) the distortion measure should preferably be modeled on human <a class="uri" href="perception" title="wikilink">perception</a> and perhaps <a class="uri" href="aesthetics" title="wikilink">aesthetics</a>: much like the use of <a class="uri" href="probability" title="wikilink">probability</a> in <a href="lossless_compression" title="wikilink">lossless compression</a>, distortion measures can ultimately be identified with <a href="loss_function" title="wikilink">loss functions</a> as used in Bayesian <a href="estimation_theory" title="wikilink">estimation</a> and <a href="decision_theory" title="wikilink">decision theory</a>. In audio compression, perceptual models (and therefore perceptual distortion measures) are relatively well developed and routinely used in compression techniques such as <a class="uri" href="MP3" title="wikilink">MP3</a> or <a class="uri" href="Vorbis" title="wikilink">Vorbis</a>, but are often not easy to include in rate–distortion theory. In image and video compression, the human perception models are less well developed and inclusion is mostly limited to the <a class="uri" href="JPEG" title="wikilink">JPEG</a> and <a class="uri" href="MPEG" title="wikilink">MPEG</a> weighting (<a href="quantization_(signal_processing)" title="wikilink">quantization</a>, <a href="Normalization_(image_processing)" title="wikilink">normalization</a>) matrix.</p>
<h2 id="ratedistortion-functions">Rate–distortion functions</h2>

<p>The functions that relate the rate and distortion are found as the solution of the following minimization problem:</p>

<p>

<math display="block" id="Rate–distortion_theory:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mo movablelimits="false">inf</mo>
      <mrow>
       <msub>
        <mi>Q</mi>
        <mrow>
         <mi>Y</mi>
         <mo stretchy="false">|</mo>
         <mi>X</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo stretchy="false">|</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <msub>
       <mi>I</mi>
       <mi>Q</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Y</mi>
       <mo>;</mo>
       <mi>X</mi>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
      <mpadded width="+5pt">
       <mtext>subject to</mtext>
      </mpadded>
      <msub>
       <mi>D</mi>
       <mi>Q</mi>
      </msub>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <msup>
     <mi>D</mi>
     <mo>*</mo>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">infimum</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <csymbol cd="unknown">Y</csymbol>
         <ci>normal-|</ci>
         <csymbol cd="unknown">X</csymbol>
        </cerror>
       </apply>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">y</csymbol>
        <ci>normal-|</ci>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>Q</ci>
      </apply>
      <list>
       <ci>Y</ci>
       <ci>X</ci>
      </list>
      <mtext>subject to</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>D</ci>
       <ci>Q</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>D</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \inf_{Q_{Y|X}(y|x)}I_{Q}(Y;X)\ \mbox{subject to}\ D_{Q}\leq D^{*}.
  </annotation>
 </semantics>
</math>

</p>

<p>Here <em>Q</em><sub><em>Y</em> | <em>X</em></sub>(<em>y</em> | <em>x</em>), sometimes called a test channel, is the <a href="conditional_probability" title="wikilink">conditional</a> <a href="probability_density_function" title="wikilink">probability density function</a> (PDF) of the communication channel output (compressed signal) <em>Y</em> for a given input (original signal) <em>X</em>, and <em>I</em><sub><em>Q</em></sub>(<em>Y</em> ; <em>X</em>) is the <strong><a href="mutual_information" title="wikilink">mutual information</a></strong> between <em>Y</em> and <em>X</em> defined as</p>

<p>

<math display="block" id="Rate–distortion_theory:1">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo>;</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>-</mo>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">|</mo>
    <mi>X</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">I</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-;</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">H</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <minus></minus>
    <csymbol cd="unknown">H</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(Y;X)=H(Y)-H(Y|X)\,
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>H</em>(<em>Y</em>) and <em>H</em>(<em>Y</em> | <em>X</em>) are the entropy of the output signal <em>Y</em> and the <a href="conditional_entropy" title="wikilink">conditional entropy</a> of the output signal given the input signal, respectively:</p>

<p>

<math display="block" id="Rate–distortion_theory:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>P</mi>
       <mi>Y</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <msub>
        <mi>log</mi>
        <mn>2</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>P</mi>
          <mi>Y</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mi>d</mi>
      <mi>y</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>Y</ci>
       </apply>
       <ci>y</ci>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>P</ci>
          <ci>Y</ci>
         </apply>
         <ci>y</ci>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(Y)=-\int_{-\infty}^{\infty}P_{Y}(y)\log_{2}(P_{Y}(y))\,dy
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Rate–distortion_theory:3">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo stretchy="false">|</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo>-</mo>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mo>-</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mo>-</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <msub>
    <mi>Q</mi>
    <mrow>
     <mi>Y</mi>
     <mo stretchy="false">|</mo>
     <mi>X</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <msub>
    <mi>P</mi>
    <mi>X</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <msub>
    <mi>log</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Q</mi>
     <mrow>
      <mi>Y</mi>
      <mo stretchy="false">|</mo>
      <mi>X</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">|</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
   <mi>d</mi>
   <mpadded width="+1.7pt">
    <mi>x</mi>
   </mpadded>
   <mi>d</mi>
   <mi>y</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">H</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <minus></minus>
       <infinity></infinity>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <minus></minus>
       <infinity></infinity>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">Y</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">X</csymbol>
     </cerror>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>X</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <log></log>
     <cn type="integer">2</cn>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">Y</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">X</csymbol>
      </cerror>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(Y|X)=-\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}Q_{Y|X}(y|x)P_{X}(x)\log%
_{2}(Q_{Y|X}(y|x))\,dx\,dy.
  </annotation>
 </semantics>
</math>

</p>

<p>The problem can also be formulated as a distortion–rate function, where we find the infimum over achievable distortions for given rate constraint. The relevant expression is:</p>

<p>

<math display="block" id="Rate–distortion_theory:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mo movablelimits="false">inf</mo>
      <mrow>
       <msub>
        <mi>Q</mi>
        <mrow>
         <mi>Y</mi>
         <mo stretchy="false">|</mo>
         <mi>X</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo stretchy="false">|</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <msub>
         <mi>D</mi>
         <mi>Q</mi>
        </msub>
        <mrow>
         <mo stretchy="false">[</mo>
         <mi>X</mi>
         <mo>,</mo>
         <mi>Y</mi>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo rspace="7.5pt" stretchy="false">]</mo>
      </mrow>
      <mpadded width="+5pt">
       <mtext>subject to</mtext>
      </mpadded>
      <msub>
       <mi>I</mi>
       <mi>Q</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Y</mi>
       <mo>;</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mi>R</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">infimum</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <csymbol cd="unknown">Y</csymbol>
         <ci>normal-|</ci>
         <csymbol cd="unknown">X</csymbol>
        </cerror>
       </apply>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">y</csymbol>
        <ci>normal-|</ci>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>D</ci>
         <ci>Q</ci>
        </apply>
        <interval closure="closed">
         <ci>X</ci>
         <ci>Y</ci>
        </interval>
       </apply>
      </apply>
      <mtext>subject to</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>Q</ci>
      </apply>
      <list>
       <ci>Y</ci>
       <ci>X</ci>
      </list>
     </apply>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \inf_{Q_{Y|X}(y|x)}E[D_{Q}[X,Y]]\ \mbox{subject to}\ I_{Q}(Y;X)\leq R.
  </annotation>
 </semantics>
</math>

</p>

<p>The two formulations lead to functions which are inverses of each other.</p>

<p>The mutual information can be understood as a measure for 'prior' uncertainty the receiver has about the sender's signal (<em>H(Y)</em>), diminished by the uncertainty that is left after receiving information about the sender's signal (<em>H</em>(<em>Y</em> | <em>X</em>)). Of course the decrease in uncertainty is due to the communicated amount of information, which is <em>I</em>(<em>Y</em>; <em>X</em>).</p>

<p>As an example, in case there is <em>no</em> communication at all, then <em>H</em>(<em>Y</em> |<em>X</em>) = <em>H</em>(<em>Y</em>) and <em>I</em>(<em>Y</em>; <em>X</em>) = 0. Alternatively, if the communication channel is perfect and the received signal <em>Y</em> is identical to the signal <em>X</em> at the sender, then <em>H</em>(<em>Y</em> | <em>X</em>) = 0 and <em>I</em>(<em>Y</em>; <em>X</em>) = <em>H</em>(<em>Y</em>) = <em>H</em>(<em>X</em>).</p>

<p>In the definition of the rate–distortion function, <em>D</em><sub>Q</sub> and <em>D</em><sup>*</sup> are the distortion between <em>X</em> and <em>Y</em> for a given <em>Q</em><sub><em>Y</em> | <em>X</em></sub>(<em>y</em> | <em>x</em>) and the prescribed maximum distortion, respectively. When we use the <a href="mean_squared_error" title="wikilink">mean squared error</a> as distortion measure, we have (for <a href="amplitude-continuous_signal" title="wikilink">amplitude-continuous signals</a>):</p>

<p>

<math display="block" id="Rate–distortion_theory:5">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mi>Q</mi>
   </msub>
   <mo>=</mo>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mo>-</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mo>-</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <msub>
    <mi>P</mi>
    <mrow>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Y</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mpadded width="+1.7pt">
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>-</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mpadded>
   <mi>d</mi>
   <mpadded width="+1.7pt">
    <mi>x</mi>
   </mpadded>
   <mi>d</mi>
   <mi>y</mi>
   <mo>=</mo>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mo>-</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mo>-</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <msub>
    <mi>Q</mi>
    <mrow>
     <mi>Y</mi>
     <mo stretchy="false">|</mo>
     <mi>X</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <msub>
    <mi>P</mi>
    <mi>X</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mpadded width="+1.7pt">
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>-</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mpadded>
   <mi>d</mi>
   <mpadded width="+1.7pt">
    <mi>x</mi>
   </mpadded>
   <mi>d</mi>
   <mi>y</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>Q</ci>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <minus></minus>
       <infinity></infinity>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <minus></minus>
       <infinity></infinity>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <list>
      <ci>X</ci>
      <ci>Y</ci>
     </list>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <minus></minus>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cn type="integer">2</cn>
    </apply>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <minus></minus>
       <infinity></infinity>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <minus></minus>
       <infinity></infinity>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">Y</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">X</csymbol>
     </cerror>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>X</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <minus></minus>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cn type="integer">2</cn>
    </apply>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{Q}=\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}P_{X,Y}(x,y)(x-y)^{2}\,dx%
\,dy=\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}Q_{Y|X}(y|x)P_{X}(x)(x-y)^{%
2}\,dx\,dy.
  </annotation>
 </semantics>
</math>

</p>

<p>As the above equations show, calculating a rate–distortion function requires the stochastic description of the input <em>X</em> in terms of the PDF <em>P</em><sub><em>X</em></sub>(<em>x</em>), and then aims at finding the conditional PDF <em>Q</em><sub><em>Y</em> | <em>X</em></sub>(<em>y</em> | <em>x</em>) that minimize rate for a given distortion <em>D</em><sup>*</sup>. These definitions can be formulated measure-theoretically to account for discrete and mixed random variables as well.</p>

<p>An <a href="Analytical_expression" title="wikilink">analytical</a> solution to this <a href="Optimization_problem" title="wikilink">minimization problem</a> is often difficult to obtain except in some instances for which we next offer two of the best known examples. The rate–distortion function of any source is known to obey several fundamental properties, the most important ones being that it is a <a href="Continuous_function" title="wikilink">continuous</a>, <a href="monotonically_decreasing" title="wikilink">monotonically decreasing</a> <a href="Convex_function" title="wikilink">convex</a> (U) <a href="function_(mathematics)" title="wikilink">function</a> and thus the shape for the function in the examples is typical (even measured rate–distortion functions in real life tend to have very similar forms).</p>

<p>Although analytical solutions to this problem are scarce, there are upper and lower bounds to these functions including the famous <a href="Shannon_lower_bound" title="wikilink">Shannon lower bound</a> (SLB), which in the case of squared error and memoryless sources, states that for arbitrary sources with finite differential entropy,</p>

<p>

<math display="block" id="Rate–distortion_theory:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>D</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>D</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>D</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>D</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(D)\geq h(X)-h(D)\,
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>h(D)</em> is the differential entropy of a Gaussian random variable with variance D. This lower bound is extensible to sources with memory and other distortion measures. One important feature of the SLB is that it is asymptotically tight in the low distortion regime for a wide class of sources and in some occasions, it actually coincides with the rate–distortion function. Shannon Lower Bounds can generally be found if the distortion between any two numbers can be expressed as a function of the difference between the value of these two numbers.</p>

<p>The <a href="Blahut–Arimoto_algorithm" title="wikilink">Blahut–Arimoto algorithm</a>, co-invented by <a href="Richard_Blahut" title="wikilink">Richard Blahut</a>, is an elegant iterative technique for numerically obtaining rate–distortion functions of arbitrary finite input/output alphabet sources and much work has been done to extend it to more general problem instances.</p>

<p>When working with stationary sources with memory, it is necessary to modify the definition of the rate distortion function and it must be understood in the sense of a limit taken over sequences of increasing lengths.</p>

<p>

<math display="block" id="Rate–distortion_theory:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>D</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo movablelimits="false">lim</mo>
     <mrow>
      <mi>n</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </munder>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>D</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>D</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>n</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>n</ci>
      </apply>
      <ci>D</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(D)=\lim_{n\rightarrow\infty}R_{n}(D)
  </annotation>
 </semantics>
</math>

 where</p>

<p>

<math display="block" id="Rate–distortion_theory:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>D</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>n</mi>
    </mfrac>
    <mrow>
     <munder>
      <mo movablelimits="false">inf</mo>
      <mrow>
       <msub>
        <mi>Q</mi>
        <mrow>
         <msup>
          <mi>Y</mi>
          <mi>n</mi>
         </msup>
         <mo stretchy="false">|</mo>
         <msup>
          <mi>X</mi>
          <mi>n</mi>
         </msup>
        </mrow>
       </msub>
       <mo>∈</mo>
       <mi class="ltx_font_mathcaligraphic">𝒬</mi>
      </mrow>
     </munder>
     <mrow>
      <mi>I</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>Y</mi>
        <mi>n</mi>
       </msup>
       <mo>,</mo>
       <msup>
        <mi>X</mi>
        <mi>n</mi>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>n</ci>
     </apply>
     <ci>D</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">infimum</csymbol>
       <apply>
        <in></in>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>Y</ci>
           <ci>n</ci>
          </apply>
          <ci>normal-|</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>X</ci>
           <ci>n</ci>
          </apply>
         </cerror>
        </apply>
        <ci>𝒬</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>I</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>Y</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>X</ci>
         <ci>n</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{n}(D)=\frac{1}{n}\inf_{Q_{Y^{n}|X^{n}}\in\mathcal{Q}}I(Y^{n},X^{n})
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Rate–distortion_theory:9">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒬</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>Q</mi>
     <mrow>
      <msup>
       <mi>Y</mi>
       <mi>n</mi>
      </msup>
      <mo stretchy="false">|</mo>
      <msup>
       <mi>X</mi>
       <mi>n</mi>
      </msup>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>Y</mi>
      <mi>n</mi>
     </msup>
     <mo stretchy="false">|</mo>
     <msup>
      <mi>X</mi>
      <mi>n</mi>
     </msup>
     <mo>,</mo>
     <msub>
      <mi>X</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>:</mo>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>X</mi>
       <mi>n</mi>
      </msup>
      <mo>,</mo>
      <msup>
       <mi>Y</mi>
       <mi>n</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>≤</mo>
    <mi>D</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Q</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Y</ci>
        <ci>n</ci>
       </apply>
       <ci>normal-|</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>X</ci>
        <ci>n</ci>
       </apply>
      </cerror>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Y</ci>
       <ci>n</ci>
      </apply>
      <ci>normal-|</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>X</ci>
       <ci>n</ci>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-:</ci>
     <csymbol cd="unknown">E</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">d</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>X</ci>
        <ci>n</ci>
       </apply>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Y</ci>
        <ci>n</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <leq></leq>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{Q}=\{Q_{Y^{n}|X^{n}}(Y^{n}|X^{n},X_{0}):E[d(X^{n},Y^{n})]\leq D\}
  </annotation>
 </semantics>
</math>

 where superscripts denote a complete sequence up to that time and the subscript <em>0</em> indicates initial state.</p>
<h3 id="memoryless-independent-gaussian-source">Memoryless (independent) Gaussian source</h3>

<p>If we assume that <em>P</em><sub><em>X</em></sub>(<em>x</em>) is <a href="normal_distribution" title="wikilink">Gaussian</a> with <a class="uri" href="variance" title="wikilink">variance</a> σ<sup>2</sup>, and if we assume that successive samples of the signal <em>X</em> are <a href="stochastically_independent" title="wikilink">stochastically independent</a> (or equivalently, the source is <em><a href="memorylessness" title="wikilink">memoryless</a></em>, or the signal is <em>uncorrelated</em>), we find the following <a href="analytical_expression" title="wikilink">analytical expression</a> for the rate–distortion function:</p>

<p>

<math display="block" id="Rate–distortion_theory:10">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>D</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mrow>
         <mstyle displaystyle="false">
          <mfrac>
           <mn>1</mn>
           <mn>2</mn>
          </mfrac>
         </mstyle>
         <mrow>
          <msub>
           <mi>log</mi>
           <mn>2</mn>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <msubsup>
             <mi>σ</mi>
             <mi>x</mi>
             <mn>2</mn>
            </msubsup>
            <mo>/</mo>
            <mi>D</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mn>0</mn>
        </mrow>
        <mo>≤</mo>
        <mi>D</mi>
        <mo>≤</mo>
        <msubsup>
         <mi>σ</mi>
         <mi>x</mi>
         <mn>2</mn>
        </msubsup>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mn>0</mn>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>D</mi>
         </mrow>
         <mo>></mo>
         <msubsup>
          <mi>σ</mi>
          <mi>x</mi>
          <mn>2</mn>
         </msubsup>
        </mrow>
        <mo>.</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <log></log>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <divide></divide>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>σ</ci>
            <ci>x</ci>
           </apply>
           <cn type="integer">2</cn>
          </apply>
          <ci>D</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <and></and>
        <apply>
         <leq></leq>
         <apply>
          <times></times>
          <mtext>if</mtext>
          <cn type="integer">0</cn>
         </apply>
         <ci>D</ci>
        </apply>
        <apply>
         <leq></leq>
         <share href="#.cmml">
         </share>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>σ</ci>
           <ci>x</ci>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <csymbol cd="latexml">absent</csymbol>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <apply>
        <gt></gt>
        <apply>
         <times></times>
         <mtext>if</mtext>
         <ci>D</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>σ</ci>
          <ci>x</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(D)=\left\{\begin{matrix}\frac{1}{2}\log_{2}(\sigma_{x}^{2}/D),&\mbox{if }0%
\leq D\leq\sigma_{x}^{2}\\
\\
0,&\mbox{if }D>\sigma_{x}^{2}.\end{matrix}\right.
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The following figure shows what this function looks like:</p>
<figure><b>(Figure)</b>
<figcaption>Rate distortion function.png</figcaption>
</figure>

<p>Rate–distortion theory tell us that 'no compression system exists that performs outside the gray area'. The closer a practical compression system is to the red (lower) bound, the better it performs. As a general rule, this bound can only be attained by increasing the coding block length parameter. Nevertheless, even at unit blocklengths one can often find good (scalar) quantizers that operate at distances from the rate–distortion function that are practically relevant.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>This rate–distortion function holds only for Gaussian memoryless sources. It is known that the Gaussian source is the most "difficult" source to encode: for a given mean square error, it requires the greatest number of bits. The performance of a practical compression system working on—say—images, may well be below the <em>R(D)</em> lower bound shown.</p>
<h2 id="connecting-rate-distortion-theory-to-channel-capacity">Connecting rate-distortion theory to channel capacity <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></h2>

<p>Suppose we want to transmit information about a source to the user with a distortion not exceeding <em>D</em>. Rate–distortion theory tells us that at least <em>R</em>(<em>D</em>) bits/symbol of information from the source must reach the user. We also know from Shannon's channel coding theorem that if the source entropy is <em>H</em> bits/symbol, and the <a href="channel_capacity" title="wikilink">channel capacity</a> is <em>C</em> (where <em>C</em> </p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
