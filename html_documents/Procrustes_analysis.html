<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="633">Procrustes analysis</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Procrustes analysis</h1>
<hr/>

<p>In <a class="uri" href="statistics" title="wikilink">statistics</a>, <strong>Procrustes analysis</strong> is a form of <a href="statistical_shape_analysis" title="wikilink">statistical shape analysis</a> used to analyse the distribution of a set of <a href="shape" title="wikilink">shapes</a>. The name <em><a class="uri" href="Procrustes" title="wikilink">Procrustes</a></em> () refers to a bandit from Greek mythology who made his victims fit his bed either by stretching their limbs or cutting them off.</p>

<p>To compare the shape of two or more objects, the objects must be first optimally "superimposed". <strong>Procrustes superimposition</strong> (PS) is performed by optimally <a href="translation_(geometry)" title="wikilink">translating</a>, <a href="rotation_(mathematics)" title="wikilink">rotating</a> and <a href="scaling_(geometry)" title="wikilink">uniformly scaling</a> the objects. In other words, both the <a href="Orientation_(geometry)" title="wikilink">placement in space</a> and the size of the objects are freely adjusted. The aim is to obtain a similar placement and size, by minimizing a measure of shape difference called the Procrustes distance between the objects. This is sometimes called <strong>full</strong>, as opposed to <strong>partial</strong> PS, in which scaling is not performed (i.e. the size of the objects is preserved). Notice that, after full PS, the objects will exactly coincide if their <a class="uri" href="shape" title="wikilink">shape</a> is identical. For instance, with full PS two spheres with different radius will always coincide, because they have exactly the same shape. Conversely, with partial PS they will never coincide. This implies that, by the strict definition of the term <em>shape</em> in <a class="uri" href="geometry" title="wikilink">geometry</a>, shape analysis should be performed using full PS. A statistical analysis based on partial PS is not a pure shape analysis as it is not only sensitive to shape differences, but also to size differences. Both full and partial PS will never manage to perfectly match two objects with different shape, such as a cube and a sphere, or a right hand and a left hand.</p>

<p>In some cases, both full and partial PS may also include <a href="Reflection_(mathematics)" title="wikilink">reflection</a>. Reflection allows, for instance, a successful (possibly perfect) superimposition of a right hand to a left hand. Thus, partial PS with reflection enabled preserves size but allows translation, rotation and reflection, while full PS with reflection enabled allows translation, rotation, scaling and reflection.</p>

<p>In mathematics:</p>
<ul>
<li>an <a href="orthogonal_Procrustes_problem" title="wikilink">orthogonal Procrustes problem</a> is a method which can be used to find out the optimal <em>rotation and/or reflection</em> (i.e., the optimal orthogonal linear transformation) for the PS of an object with respect to another.</li>
<li>a constrained <a href="orthogonal_Procrustes_problem" title="wikilink">orthogonal Procrustes problem</a>, subject to <a href="determinant" title="wikilink">det</a>(<em>R</em>) = 1 (where <em>R</em> is a rotation matrix), is a method which can be used to determine the optimal <em>rotation</em> for the PS of an object with respect to another (reflection is not allowed). In some contexts, this method is called the <a href="Kabsch_algorithm" title="wikilink">Kabsch algorithm</a>.</li>
</ul>

<p>Optimal translation and scaling are determined with much simpler operations (see below).</p>

<p>When a shape is compared to another, or a set of shapes is compared to an arbitrarily selected reference shape, Procrustes analysis is sometimes further qualified as <strong>classical</strong> or <strong>ordinary</strong>, as opposed to <strong><a href="Generalized_Procrustes_analysis" title="wikilink">Generalized</a></strong> Procrustes analysis (GPA), which compares three or more shapes to an optimally determined "mean shape".</p>
<h2 id="ordinary-procrustes-analysis">Ordinary Procrustes analysis</h2>

<p>Here we just consider objects made up from a finite number <em>k</em> of points in <em>n</em> dimensions. Often, these points are selected on the continuous surface of complex objects, such as a human bone, and in this case they are called <a href="landmark_point" title="wikilink">landmark points</a>.</p>

<p>The shape of an object can be considered as a member of an <a href="equivalence_class" title="wikilink">equivalence class</a> formed by removing the <a href="translation_(geometry)" title="wikilink">translational</a>, <a href="rotation_(mathematics)" title="wikilink">rotational</a> and <a href="scaling_(geometry)" title="wikilink">uniform scaling</a> components.</p>
<h3 id="translation">Translation</h3>

<p>For example, translational components can be removed from an object by translating the object so that the <a class="uri" href="mean" title="wikilink">mean</a> of all the object's points (i.e. its <a class="uri" href="centroid" title="wikilink">centroid</a>) lies at the origin.</p>

<p>Mathematically: take 

<math display="inline" id="Procrustes_analysis:0">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>


 points in two dimensions, say</p>

<p>

<math display="block" id="Procrustes_analysis:1">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo rspace="4.2pt" stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
    <ci>normal-…</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>k</ci>
     </apply>
    </interval>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((x_{1},y_{1}),(x_{2},y_{2}),\dots,(x_{k},y_{k}))\,
  </annotation>
 </semantics>
</math>

.</p>

<p>The mean of these points is 

<math display="inline" id="Procrustes_analysis:2">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mo>,</mo>
   <mover accent="true">
    <mi>y</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <ci>normal-¯</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <ci>y</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\bar{x},\bar{y})
  </annotation>
 </semantics>
</math>

 where</p>

<p>

<math display="block" id="Procrustes_analysis:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">¯</mo>
     </mover>
     <mo>=</mo>
     <mfrac>
      <mrow>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>+</mo>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
       <mo>+</mo>
       <mi mathvariant="normal">⋯</mi>
       <mo>+</mo>
       <msub>
        <mi>x</mi>
        <mi>k</mi>
       </msub>
      </mrow>
      <mi>k</mi>
     </mfrac>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mover accent="true">
      <mi>y</mi>
      <mo stretchy="false">¯</mo>
     </mover>
     <mo>=</mo>
     <mfrac>
      <mrow>
       <msub>
        <mi>y</mi>
        <mn>1</mn>
       </msub>
       <mo>+</mo>
       <msub>
        <mi>y</mi>
        <mn>2</mn>
       </msub>
       <mo>+</mo>
       <mi mathvariant="normal">⋯</mi>
       <mo>+</mo>
       <msub>
        <mi>y</mi>
        <mi>k</mi>
       </msub>
      </mrow>
      <mi>k</mi>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-¯</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-¯</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{x}=\frac{x_{1}+x_{2}+\cdots+x_{k}}{k},\quad\bar{y}=\frac{y_{1}+y_{2}+%
\cdots+y_{k}}{k}.
  </annotation>
 </semantics>
</math>

</p>

<p>Now translate these points so that their mean is translated to the origin 

<math display="inline" id="Procrustes_analysis:4">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">¯</mo>
     </mover>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>y</mi>
     <mo>-</mo>
     <mover accent="true">
      <mi>y</mi>
      <mo stretchy="false">¯</mo>
     </mover>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
    <interval closure="open">
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>y</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)\to(x-\bar{x},y-\bar{y})
  </annotation>
 </semantics>
</math>

, giving the point 

<math display="inline" id="Procrustes_analysis:5">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>-</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">¯</mo>
     </mover>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>-</mo>
     <mover accent="true">
      <mi>y</mi>
      <mo stretchy="false">¯</mo>
     </mover>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <interval closure="open">
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <ci>normal-¯</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <ci>normal-¯</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </interval>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1}-\bar{x},y_{1}-\bar{y}),\dots
  </annotation>
 </semantics>
</math>


.</p>
<h3 id="uniform-scaling">Uniform scaling</h3>

<p>Likewise, the scale component can be removed by scaling the object so that the <a href="root_mean_square" title="wikilink">root mean square</a> distance (<em>RMSD</em>) from the points to the translated origin is 1. This RMSD is a statistical measure of the object's <strong>scale</strong> or <strong>size</strong>:</p>

<p>

<math display="block" id="Procrustes_analysis:6">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <msqrt>
    <mfrac>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>x</mi>
          <mn>1</mn>
         </msub>
         <mo>-</mo>
         <mover accent="true">
          <mi>x</mi>
          <mo stretchy="false">¯</mo>
         </mover>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mo>+</mo>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>y</mi>
          <mn>1</mn>
         </msub>
         <mo>-</mo>
         <mover accent="true">
          <mi>y</mi>
          <mo stretchy="false">¯</mo>
         </mover>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mi mathvariant="normal">⋯</mi>
     </mrow>
     <mi>k</mi>
    </mfrac>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <root></root>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <ci>normal-¯</ci>
          <ci>x</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <ci>normal-¯</ci>
          <ci>y</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-⋯</ci>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=\sqrt{{(x_{1}-\bar{x})^{2}+(y_{1}-\bar{y})^{2}+\cdots}\over k}
  </annotation>
 </semantics>
</math>

</p>

<p>The scale becomes 1 when the point coordinates are divided by the object's initial scale:</p>

<p>

<math display="block" id="Procrustes_analysis:7">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>-</mo>
      <mover accent="true">
       <mi>x</mi>
       <mo stretchy="false">¯</mo>
      </mover>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mi>s</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mo>-</mo>
      <mover accent="true">
       <mi>y</mi>
       <mo stretchy="false">¯</mo>
      </mover>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mi>s</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <ci>normal-¯</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>s</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <ci>normal-¯</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <ci>s</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((x_{1}-\bar{x})/s,(y_{1}-\bar{y})/s)
  </annotation>
 </semantics>
</math>

.</p>

<p>Notice that other methods for defining and removing the scale are sometimes used in the literature.</p>
<h3 id="rotation">Rotation</h3>

<p>Removing the rotational component is more complex, as a standard reference orientation is not always available. Consider two objects composed of the same number of points with scale and translation removed. Let the points of these be 

<math display="inline" id="Procrustes_analysis:8">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <ci>normal-…</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((x_{1},y_{1}),\ldots)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Procrustes_analysis:9">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>w</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>z</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <ci>normal-…</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((w_{1},z_{1}),\ldots)
  </annotation>
 </semantics>
</math>

. One of these objects can be used to provide a reference orientation. Fix the reference object and rotate the other around the origin, until you find an optimum angle of rotation 

<math display="inline" id="Procrustes_analysis:10">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta\,\!
  </annotation>
 </semantics>
</math>


 such that the sum of the squared distances (<em>SSD</em>) between the corresponding points is minimised (an example of <a href="least_squares" title="wikilink">least squares</a> technique).</p>

<p>A rotation by angle 

<math display="inline" id="Procrustes_analysis:11">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta\,\!
  </annotation>
 </semantics>
</math>

 gives</p>

<p>

<math display="block" id="Procrustes_analysis:12">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>u</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>cos</mi>
      <mrow>
       <mpadded width="+1.7pt">
        <mi>θ</mi>
       </mpadded>
       <msub>
        <mi>w</mi>
        <mn>1</mn>
       </msub>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>sin</mi>
      <mrow>
       <mpadded width="+1.7pt">
        <mi>θ</mi>
       </mpadded>
       <msub>
        <mi>z</mi>
        <mn>1</mn>
       </msub>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="4.2pt">,</mo>
    <mrow>
     <mrow>
      <mi>sin</mi>
      <mrow>
       <mpadded width="+1.7pt">
        <mi>θ</mi>
       </mpadded>
       <msub>
        <mi>w</mi>
        <mn>1</mn>
       </msub>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>cos</mi>
      <mrow>
       <mpadded width="+1.7pt">
        <mi>θ</mi>
       </mpadded>
       <msub>
        <mi>z</mi>
        <mn>1</mn>
       </msub>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <interval closure="open">
     <apply>
      <minus></minus>
      <apply>
       <cos></cos>
       <apply>
        <times></times>
        <ci>θ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <sin></sin>
       <apply>
        <times></times>
        <ci>θ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <sin></sin>
       <apply>
        <times></times>
        <ci>θ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <cos></cos>
       <apply>
        <times></times>
        <ci>θ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u_{1},v_{1})=(\cos\theta\,w_{1}-\sin\theta\,z_{1},\,\sin\theta\,w_{1}+\cos%
\theta\,z_{1})\,\!
  </annotation>
 </semantics>
</math>

.</p>

<p>where (u,v) are the coordinates of a rotated point. Taking the derivative of 

<math display="inline" id="Procrustes_analysis:13">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>u</mi>
       <mn>1</mn>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>+</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>v</mi>
       <mn>1</mn>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>+</mo>
   <mi mathvariant="normal">⋯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-⋯</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u_{1}-x_{1})^{2}+(v_{1}-y_{1})^{2}+\cdots
  </annotation>
 </semantics>
</math>

 with respect to 

<math display="inline" id="Procrustes_analysis:14">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 and solving for 

<math display="inline" id="Procrustes_analysis:15">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>


 when the derivative is zero gives</p>

<p>

<math display="block" id="Procrustes_analysis:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>θ</mi>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>tan</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <msubsup>
         <mo largeop="true" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>k</mi>
        </msubsup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <msub>
            <mi>w</mi>
            <mi>i</mi>
           </msub>
           <msub>
            <mi>y</mi>
            <mi>i</mi>
           </msub>
          </mrow>
          <mo>-</mo>
          <mrow>
           <msub>
            <mi>z</mi>
            <mi>i</mi>
           </msub>
           <msub>
            <mi>x</mi>
            <mi>i</mi>
           </msub>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <msubsup>
         <mo largeop="true" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>k</mi>
        </msubsup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <msub>
            <mi>w</mi>
            <mi>i</mi>
           </msub>
           <msub>
            <mi>x</mi>
            <mi>i</mi>
           </msub>
          </mrow>
          <mo>+</mo>
          <mrow>
           <msub>
            <mi>z</mi>
            <mi>i</mi>
           </msub>
           <msub>
            <mi>y</mi>
            <mi>i</mi>
           </msub>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>θ</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <tan></tan>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>k</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>w</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>k</ci>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>w</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta=\tan^{-1}\left(\frac{\sum_{i=1}^{k}(w_{i}y_{i}-z_{i}x_{i})}{\sum_{i=1}^%
{k}(w_{i}x_{i}+z_{i}y_{i})}\right).
  </annotation>
 </semantics>
</math>

</p>

<p>When the object is three-dimensional, the optimum rotation is represented by a 3-by-3 <a href="rotation_matrix" title="wikilink">rotation matrix</a> <em>R</em>, rather than a simple angle, and in this case <a href="singular_value_decomposition" title="wikilink">singular value decomposition</a> can be used to find the optimum value for <em>R</em> (see the solution for the constrained <a href="orthogonal_Procrustes_problem" title="wikilink">orthogonal Procrustes problem</a>, subject to <a href="Determinant" title="wikilink">det</a>(<em>R</em>) = 1).</p>
<h3 id="shape-comparison">Shape comparison</h3>

<p>The difference between the shape of two objects can be evaluated only after "superimposing" the two objects by translating, scaling and optimally rotating them as explained above. The square root of the above mentioned SSD between corresponding points can be used as a statistical measure of this difference in shape:</p>

<p>

<math display="block" id="Procrustes_analysis:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mo>=</mo>
    <msqrt>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>u</mi>
          <mn>1</mn>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>x</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mo>+</mo>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>v</mi>
          <mn>1</mn>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>y</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mi mathvariant="normal">⋯</mi>
     </mrow>
    </msqrt>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>d</ci>
    <apply>
     <root></root>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-⋯</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=\sqrt{(u_{1}-x_{1})^{2}+(v_{1}-y_{1})^{2}+\cdots}.
  </annotation>
 </semantics>
</math>

</p>

<p>This measure is often called <strong>Procrustes distance</strong>. Notice that other more complex definitions of Procrustes distance, and other measures of "shape difference" are sometimes used in the literature.</p>
<h3 id="superimposing-a-set-of-shapes">Superimposing a set of shapes</h3>

<p>We showed how to superimpose two shapes. The same method can be applied to superimpose a set of three or more shapes, as far as the above mentioned reference orientation is used for all of them. However, Generalized Procrustes analysis provides a better method to achieve this goal.</p>
<h2 id="generalized-procrustes-analysis-gpa">Generalized Procrustes analysis (GPA)</h2>

<p>GPA applies the Procrustes analysis method to optimally superimpose a set of objects, instead of superimposing them to an arbitrarily selected shape.</p>

<p>Generalized and ordinary Procrustes analysis differ only in their determination of a reference <a href="Orientation_(geometry)" title="wikilink">orientation</a> for the objects, which in the former technique is optimally determined, and in the latter one is arbitrarily selected. Scaling and translation are performed the same way by both techniques. When only two shapes are compared, GPA is equivalent to ordinary Procrustes analysis.</p>

<p>The algorithm outline is the following:</p>
<ol>
<li>arbitrarily choose a reference shape (typically by selecting it among the available instances)</li>
<li>superimpose all instances to current reference shape</li>
<li>compute the mean shape of the current set of superimposed shapes</li>
<li>if the Procrustes distance between mean and reference shape is above a threshold, set reference to mean shape and continue to step 2.</li>
</ol>
<h2 id="variations">Variations</h2>

<p>There are many ways of representing the shape of an object. The shape of an object can be considered as a member of an equivalence class formed by taking the set of all sets of <em>k</em> points in <em>n</em> dimensions, that is <strong>R</strong><sup>kn</sup> and factoring out the set of all translations, rotations and scalings. A particular representation of shape is found by choosing a particular representation of the equivalence class. This will give a <a class="uri" href="manifold" title="wikilink">manifold</a> of dimension <em>kn</em>-4. Procrustes is one method of doing this with particular statistical justification.</p>

<p>Bookstein obtains a representation of shape by fixing the position of two points called the bases line. One point will be fixed at the origin and the other at (1,0) the remaining points form the <em>Bookstein</em> coordinates.</p>

<p>It is also common to consider <em>shape and scale</em> that is with translational and rotational components removed.</p>
<h2 id="examples">Examples</h2>

<p>Shape analysis is used in <a href="biological_data" title="wikilink">biological data</a> to identify the variations of anatomical features characterised by landmark data, for example in considering the shape of jaw bones.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>One study by <a href="David_George_Kendall" title="wikilink">David George Kendall</a> examined the triangles formed by <a href="standing_stones" title="wikilink">standing stones</a> to deduce if these were often arranged in straight lines. The shape of a triangle can be represented as a point on the sphere, and the distribution of all shapes can be thought of a distribution over the sphere. The sample distribution from the standing stones was compared with the theoretical distribution to show that the occurrence of straight lines was no more than average.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Active_shape_model" title="wikilink">Active shape model</a></li>
<li><a href="Alignments_of_random_points" title="wikilink">Alignments of random points</a></li>
<li><a class="uri" href="Biometrics" title="wikilink">Biometrics</a></li>
<li><a href="Generalized_Procrustes_analysis" title="wikilink">Generalized Procrustes analysis</a></li>
<li><a href="Image_registration" title="wikilink">Image registration</a></li>
<li><a href="Kent_distribution" title="wikilink">Kent distribution</a></li>
<li><a class="uri" href="Morphometrics" title="wikilink">Morphometrics</a></li>
<li><a href="Orthogonal_Procrustes_problem" title="wikilink">Orthogonal Procrustes problem</a></li>
<li><a class="uri" href="Procrustes" title="wikilink">Procrustes</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>F.L. Bookstein, <em>Morphometric tools for landmark data</em>, Cambridge University Press, (1991).</li>
<li>J.C. Gower, G.B. Dijksterhuis, <em>Procrustes Problems</em>, Oxford University Press (2004).</li>
<li>I.L.Dryden, K.V. Mardia, <em>Statistical Shape Analysis</em>, Wiley, Chichester, (1998).</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://petitjeanmichel.free.fr/itoweb.petitjean.shape.html">Extensions to continuum of points and distributions</a> Procrustes Methods, Shape Recognition, Similarity and Docking, by Michel Petitjean.</li>
</ul>

<p>"</p>

<p><a href="Category:Multivariate_statistics" title="wikilink">Category:Multivariate statistics</a> <a href="Category:Euclidean_symmetries" title="wikilink">Category:Euclidean symmetries</a> <a class="uri" href="Category:Biometrics" title="wikilink">Category:Biometrics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.rps.psu.edu/mar94/goodall.html">"Exploring Space Shape"</a> by Nancy Marie Brown, Research/Penn State, Vol. 15, no. 1, March 1994<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://links.jstor.org/sici?sici=0883-4237(198905)4%3A2%3C87%3AASOTST%3E2.0.CO%3B2-P">"A Survey of the Statistical Theory of Shape"</a>, by David G. Kendall, Statistical Science, Vol. 4, No. 2 (May, 1989), pp. 87–99<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
