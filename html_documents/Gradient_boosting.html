<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1749">Gradient boosting</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Gradient boosting</h1>
<hr/>

<p><strong>Gradient boosting</strong> is a <a href="machine_learning" title="wikilink">machine learning</a> technique for <a href="Regression_(machine_learning)" title="wikilink">regression</a> and <a href="Classification_(machine_learning)" title="wikilink">classification</a> problems, which produces a prediction model in the form of an <a href="Ensemble_learning" title="wikilink">ensemble</a> of weak prediction models, typically <a href="Decision_tree_learning" title="wikilink">decision trees</a>. It builds the model in a stage-wise fashion like other <a href="Boosting_(meta-algorithm)" title="wikilink">boosting</a> methods do, and it generalizes them by allowing optimization of an arbitrary <a href="Differentiable_function" title="wikilink">differentiable</a> <a href="loss_function" title="wikilink">loss function</a>.</p>

<p>The idea of gradient boosting originated in the observation by <a href="Leo_Breiman" title="wikilink">Leo Breiman</a> <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> that boosting can be interpreted as an optimization algorithm on a suitable cost function. Explicit regression gradient boosting algorithms were subsequently developed by <a href="Jerome_H._Friedman" title="wikilink">Jerome H. Friedman</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> simultaneously with the more general functional gradient boosting perspective of Llew Mason, Jonathan Baxter, Peter Bartlett and Marcus Frean .<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The latter two papers introduced the abstract view of boosting algorithms as iterative <em>functional gradient descent</em> algorithms. That is, algorithms that optimize a cost <em>functional</em> over function space by iteratively choosing a function (weak hypothesis) that points in the negative gradient direction. This functional gradient view of boosting has led to the development of boosting algorithms in many areas of machine learning and statistics beyond regression and classification.</p>
<h2 id="informal-introduction">Informal introduction</h2>

<p>(This section follows the exposition of gradient boosting by Li.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a>)</p>

<p>Like other boosting methods, gradient boosting combines weak learners into a single strong learner, in an iterative fashion. It is easiest to explain in the least-squares <a href="regression_analysis" title="wikilink">regression</a> setting, where the goal is to learn a model 

<math display="inline" id="Gradient_boosting:0">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 that predicts values 

<math display="inline" id="Gradient_boosting:1">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>y</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-^</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{y}=F(x)
  </annotation>
 </semantics>
</math>

, minimizing the <a href="mean_squared_error" title="wikilink">mean squared error</a> 

<math display="inline" id="Gradient_boosting:2">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mover accent="true">
      <mi>y</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mo>-</mo>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-^</ci>
      <ci>y</ci>
     </apply>
     <ci>y</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\hat{y}-y)^{2}
  </annotation>
 </semantics>
</math>

 to the true values 

<math display="inline" id="Gradient_boosting:3">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 (averaged over some training set).</p>

<p>At each stage 

<math display="inline" id="Gradient_boosting:4">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>m</mi>
   <mo>≤</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>m</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq m\leq M
  </annotation>
 </semantics>
</math>

 of gradient boosting, it may be assumed that there is some imperfect model 

<math display="inline" id="Gradient_boosting:5">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{m}
  </annotation>
 </semantics>
</math>

 (at the outset, a very weak model that just predicts the mean 

<math display="inline" id="Gradient_boosting:6">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 in the training set could be used). The gradient boosting algorithm does not change 

<math display="inline" id="Gradient_boosting:7">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{m}
  </annotation>
 </semantics>
</math>

 in any way; instead, it improves on it by constructing a new model that adds an estimator 

<math display="inline" id="Gradient_boosting:8">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 to provide a better model 

<math display="inline" id="Gradient_boosting:9">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>F</mi>
     <mrow>
      <mi>m</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>F</mi>
      <mi>m</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <apply>
       <plus></plus>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>m</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{m+1}(x)=F_{m}(x)+h(x)
  </annotation>
 </semantics>
</math>

. The question is now, how to find 

<math display="inline" id="Gradient_boosting:10">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

? The gradient boosting solution starts with the observation that a perfect 

<math display="inline" id="Gradient_boosting:11">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 would imply</p>

<p>

<math display="block" id="Gradient_boosting:12">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mrow>
     <mi>m</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>F</mi>
      <mi>m</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <apply>
       <plus></plus>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <ci>m</ci>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{m+1}=F_{m}(x)+h(x)=y
  </annotation>
 </semantics>
</math>

</p>

<p>or, equivalently,</p>

<p>

<math display="block" id="Gradient_boosting:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>y</mi>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>F</mi>
      <mi>m</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>y</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>m</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)=y-F_{m}(x)
  </annotation>
 </semantics>
</math>

.</p>

<p>Therefore, gradient boosting will fit 

<math display="inline" id="Gradient_boosting:14">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 to the <em>residual</em> 

<math display="inline" id="Gradient_boosting:15">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>-</mo>
   <mrow>
    <msub>
     <mi>F</mi>
     <mi>m</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>y</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>m</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y-F_{m}(x)
  </annotation>
 </semantics>
</math>

. Like in other boosting variants, each 

<math display="inline" id="Gradient_boosting:16">
 <semantics>
  <msub>
   <mi>F</mi>
   <mrow>
    <mi>m</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <apply>
     <plus></plus>
     <ci>m</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{m+1}
  </annotation>
 </semantics>
</math>

 learns to correct its predecessor 

<math display="inline" id="Gradient_boosting:17">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{m}
  </annotation>
 </semantics>
</math>

. A generalization of this idea to other loss functions than squared error (and to classification and ranking problems) follows from the observation that residuals 

<math display="inline" id="Gradient_boosting:18">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>-</mo>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>y</ci>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y-F(x)
  </annotation>
 </semantics>
</math>

 are the negative gradients of the squared error loss function 

<math display="inline" id="Gradient_boosting:19">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>y</mi>
      <mo>-</mo>
      <mrow>
       <mi>F</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <ci>y</ci>
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}(y-F(x))^{2}
  </annotation>
 </semantics>
</math>

. So, gradient boosting is a <a href="gradient_descent" title="wikilink">gradient descent</a> algorithm; and generalizing it entails "plugging in" a different loss and its gradient.</p>
<h2 id="algorithm">Algorithm</h2>

<p>In many <a href="supervised_learning" title="wikilink">supervised learning</a> problems one has an output variable 

<math display="inline" id="Gradient_boosting:20">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 and a vector of input variables 

<math display="inline" id="Gradient_boosting:21">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 connected together via a <a href="joint_probability_distribution" title="wikilink">joint probability distribution</a> 

<math display="inline" id="Gradient_boosting:22">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x,y)
  </annotation>
 </semantics>
</math>

. Using a training set 

<math display="inline" id="Gradient_boosting:23">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <ci>normal-…</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </interval>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(x_{1},y_{1}),\dots,(x_{n},y_{n})\}
  </annotation>
 </semantics>
</math>

 of known values of 

<math display="inline" id="Gradient_boosting:24">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and corresponding values of 

<math display="inline" id="Gradient_boosting:25">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

, the goal is to find an approximation 

<math display="inline" id="Gradient_boosting:26">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>F</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>F</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{F}(x)
  </annotation>
 </semantics>
</math>

 to a function 

<math display="inline" id="Gradient_boosting:27">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 that minimizes the expected value of some specified <a href="loss_function" title="wikilink">loss function</a> 

<math display="inline" id="Gradient_boosting:28">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <interval closure="open">
     <ci>y</ci>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>x</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(y,F(x))
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Gradient_boosting:29">
 <semantics>
  <mrow>
   <msup>
    <mi>F</mi>
    <mo>*</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <munder accentunder="true">
      <mrow>
       <mi>arg</mi>
       <mi>min</mi>
      </mrow>
      <mo>𝐹</mo>
     </munder>
    </mpadded>
    <msub>
     <mi>𝔼</mi>
     <mrow>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo>,</mo>
       <mrow>
        <mi>F</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>F</ci>
     <times></times>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>F</ci>
      <apply>
       <arg></arg>
       <min></min>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔼</ci>
      <list>
       <ci>x</ci>
       <ci>y</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>L</ci>
       <interval closure="open">
        <ci>y</ci>
        <apply>
         <times></times>
         <ci>F</ci>
         <ci>x</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{*}=\underset{F}{\arg\min}\,\mathbb{E}_{x,y}[L(y,F(x))]
  </annotation>
 </semantics>
</math>

.</p>

<p>Gradient boosting method assumes a real-valued <em>y</em> and seeks an approximation 

<math display="inline" id="Gradient_boosting:30">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>F</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>F</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{F}(x)
  </annotation>
 </semantics>
</math>

 in the form of a weighted sum of functions 

<math display="inline" id="Gradient_boosting:31">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mi>ᵢ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>ᵢ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   hᵢ(x)
  </annotation>
 </semantics>
</math>

 from some class ℋ, called base (or weak) learners:</p>

<p>

<math display="block" id="Gradient_boosting:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>M</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>γ</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>h</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mtext>const</mtext>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>M</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>i</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
     <mtext>const</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x)=\sum_{i=1}^{M}\gamma_{i}h_{i}(x)+\mbox{const}
  </annotation>
 </semantics>
</math>

.</p>

<p>In accordance with the <a href="empirical_risk_minimization" title="wikilink">empirical risk minimization</a> principle, the method tries to find an approximation 

<math display="inline" id="Gradient_boosting:33">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>F</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>F</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{F}(x)
  </annotation>
 </semantics>
</math>

 that minimizes the average value of the loss function on the training set. It does so by starting with a model, consisting of a constant function 

<math display="inline" id="Gradient_boosting:34">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>F</mi>
    </mpadded>
    <mn>0</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!F_{0}(x)
  </annotation>
 </semantics>
</math>

, and incrementally expanding it in a <a href="Greedy_algorithm" title="wikilink">greedy</a> fashion:</p>

<p>

<math display="block" id="Gradient_boosting:35">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>F</mi>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder accentunder="true">
     <mrow>
      <mi>arg</mi>
      <mi>min</mi>
     </mrow>
     <mo>𝛾</mo>
    </munder>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <mi>γ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>γ</ci>
      <apply>
       <arg></arg>
       <min></min>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>L</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <ci>γ</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{0}(x)=\underset{\gamma}{\arg\min}\sum_{i=1}^{n}L(y_{i},\gamma)
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Gradient_boosting:36">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>F</mi>
     <mi>m</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>F</mi>
      <mrow>
       <mi>m</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <munder accentunder="true">
      <mrow>
       <mpadded width="+1.7pt">
        <mi>arg</mi>
       </mpadded>
       <mi>min</mi>
      </mrow>
      <mrow>
       <mi>f</mi>
       <mo>∈</mo>
       <mi class="ltx_font_mathcaligraphic">ℋ</mi>
      </mrow>
     </munder>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
        <mo>,</mo>
        <mrow>
         <mrow>
          <msub>
           <mi>F</mi>
           <mrow>
            <mi>m</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>x</mi>
            <mi>i</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>+</mo>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>x</mi>
            <mi>i</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>m</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <apply>
        <in></in>
        <ci>f</ci>
        <ci>ℋ</ci>
       </apply>
       <apply>
        <times></times>
        <ci>arg</ci>
        <ci>min</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <ci>L</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <plus></plus>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>F</ci>
            <apply>
             <minus></minus>
             <ci>m</ci>
             <cn type="integer">1</cn>
            </apply>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>i</ci>
           </apply>
          </apply>
          <apply>
           <times></times>
           <ci>f</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>i</ci>
           </apply>
          </apply>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{m}(x)=F_{m-1}(x)+\underset{f\in\mathcal{H}}{\operatorname{arg\,min}}\sum_{i%
=1}^{n}L(y_{i},F_{m-1}(x_{i})+f(x_{i}))
  </annotation>
 </semantics>
</math>

,</p>

<p>where 

<math display="inline" id="Gradient_boosting:37">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is restricted to be a function from the class ℋ of base learner functions.</p>

<p>However, the problem of choosing at each step the best 

<math display="inline" id="Gradient_boosting:38">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 for an arbitrary loss function 

<math display="inline" id="Gradient_boosting:39">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is a hard optimization problem in general, and so we'll "cheat" by solving a much easier problem instead.</p>

<p>The idea is to apply a <a href="steepest_descent" title="wikilink">steepest descent</a> step to this minimization problem. If we only cared about predictions at the points of the training set, and 

<math display="inline" id="Gradient_boosting:40">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 were unrestricted, we'd update the model per the following equation, where we view 

<math display="inline" id="Gradient_boosting:41">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <interval closure="open">
     <ci>y</ci>
     <ci>f</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(y,f)
  </annotation>
 </semantics>
</math>

 not as a functional of 

<math display="inline" id="Gradient_boosting:42">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

, but as a function of a vector of values 

<math display="inline" id="Gradient_boosting:43">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!f(x_{1}),\ldots,f(x_{n})
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Gradient_boosting:44">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>F</mi>
      <mi>m</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>F</mi>
       <mrow>
        <mi>m</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>γ</mi>
       <mi>m</mi>
      </msub>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>n</mi>
       </munderover>
       <mrow>
        <mrow>
         <msub>
          <mo>∇</mo>
          <mi>f</mi>
         </msub>
         <mi>L</mi>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>y</mi>
          <mi>i</mi>
         </msub>
         <mo>,</mo>
         <mrow>
          <msub>
           <mi>F</mi>
           <mrow>
            <mi>m</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>x</mi>
            <mi>i</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>m</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>γ</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>normal-∇</ci>
          <ci>f</ci>
         </apply>
         <ci>L</ci>
        </apply>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>F</ci>
           <apply>
            <minus></minus>
            <ci>m</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{m}(x)=F_{m-1}(x)-\gamma_{m}\sum_{i=1}^{n}\nabla_{f}L(y_{i},F_{m-1}(x_{i})),
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Gradient_boosting:45">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>γ</mi>
     <mi>m</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <munder accentunder="true">
      <mrow>
       <mi>arg</mi>
       <mi>min</mi>
      </mrow>
      <mo>𝛾</mo>
     </munder>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <mi>L</mi>
       <mrow>
        <mo>(</mo>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
        <mo>,</mo>
        <mrow>
         <mrow>
          <msub>
           <mi>F</mi>
           <mrow>
            <mi>m</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>x</mi>
            <mi>i</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mi>γ</mi>
          <mfrac>
           <mrow>
            <mrow>
             <mo>∂</mo>
             <mi>L</mi>
            </mrow>
            <mrow>
             <mo stretchy="false">(</mo>
             <msub>
              <mi>y</mi>
              <mi>i</mi>
             </msub>
             <mo>,</mo>
             <mrow>
              <msub>
               <mi>F</mi>
               <mrow>
                <mi>m</mi>
                <mo>-</mo>
                <mn>1</mn>
               </mrow>
              </msub>
              <mrow>
               <mo stretchy="false">(</mo>
               <msub>
                <mi>x</mi>
                <mi>i</mi>
               </msub>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mrow>
            <mrow>
             <mo>∂</mo>
             <mi>f</mi>
            </mrow>
            <mrow>
             <mo stretchy="false">(</mo>
             <msub>
              <mi>x</mi>
              <mi>i</mi>
             </msub>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mfrac>
         </mrow>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>γ</ci>
      <apply>
       <arg></arg>
       <min></min>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>L</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>F</ci>
           <apply>
            <minus></minus>
            <ci>m</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>i</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>γ</ci>
          <apply>
           <divide></divide>
           <apply>
            <times></times>
            <apply>
             <partialdiff></partialdiff>
             <ci>L</ci>
            </apply>
            <interval closure="open">
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>y</ci>
              <ci>i</ci>
             </apply>
             <apply>
              <times></times>
              <apply>
               <csymbol cd="ambiguous">subscript</csymbol>
               <ci>F</ci>
               <apply>
                <minus></minus>
                <ci>m</ci>
                <cn type="integer">1</cn>
               </apply>
              </apply>
              <apply>
               <csymbol cd="ambiguous">subscript</csymbol>
               <ci>x</ci>
               <ci>i</ci>
              </apply>
             </apply>
            </interval>
           </apply>
           <apply>
            <times></times>
            <apply>
             <partialdiff></partialdiff>
             <ci>f</ci>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>i</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma_{m}=\underset{\gamma}{\arg\min}\sum_{i=1}^{n}L\left(y_{i},F_{m-1}(x_{i}%
)-\gamma\frac{\partial L(y_{i},F_{m-1}(x_{i}))}{\partial f(x_{i})}\right).
  </annotation>
 </semantics>
</math>

</p>

<p>But as 

<math display="inline" id="Gradient_boosting:46">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 must come from a restricted class of functions (that's what allows us to generalize), we'll just choose the one that most closely approximates the gradient of 

<math display="inline" id="Gradient_boosting:47">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

. Having chosen 

<math display="inline" id="Gradient_boosting:48">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

, the multiplier 

<math display="inline" id="Gradient_boosting:49">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   γ
  </annotation>
 </semantics>
</math>

 is then selected using <a href="line_search" title="wikilink">line search</a> just as shown in the second equation above.</p>

<p>In pseudocode, the generic gradient boosting method is:<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a>  Input: training set 

<math display="inline" id="Gradient_boosting:50">
 <semantics>
  <mrow>
   <msubsup>
    <mrow>
     <mo lspace="0.8pt" stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>n</mi>
   </msubsup>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
      </interval>
     </set>
     <apply>
      <eq></eq>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\{(x_{i},y_{i})\}_{i=1}^{n},
  </annotation>
 </semantics>
</math>

 a differentiable loss function 

<math display="inline" id="Gradient_boosting:51">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>L</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mrow>
      <mi>F</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <interval closure="open">
     <ci>y</ci>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>x</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!L(y,F(x)),
  </annotation>
 </semantics>
</math>

 number of iterations 

<math display="inline" id="Gradient_boosting:52">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mrow>
    <mi>M</mi>
    <mo>.</mo>
   </mrow>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!M.
  </annotation>
 </semantics>
</math>

</p>

<p>Algorithm:</p>
<ol>
<li>Initialize model with a constant value:

<p>

<math display="block" id="Gradient_boosting:53">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>F</mi>
      <mn>0</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder accentunder="true">
      <mrow>
       <mi>arg</mi>
       <mi>min</mi>
      </mrow>
      <mo>𝛾</mo>
     </munder>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
        <mo>,</mo>
        <mi>γ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>γ</ci>
      <apply>
       <arg></arg>
       <min></min>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>L</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <ci>γ</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{0}(x)=\underset{\gamma}{\arg\min}\sum_{i=1}^{n}L(y_{i},\gamma).
  </annotation>
 </semantics>
</math>

</p></li>
<li>For 

<math display="inline" id="Gradient_boosting:54">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 = 1 to 

<math display="inline" id="Gradient_boosting:55">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

:
<ol>
<li>Compute so-called <em>pseudo-residuals</em>:

<p>

<math display="block" id="Gradient_boosting:56">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>r</mi>
      <mrow>
       <mi>i</mi>
       <mi>m</mi>
      </mrow>
     </msub>
     <mo>=</mo>
     <mrow>
      <mo>-</mo>
      <msub>
       <mrow>
        <mo>[</mo>
        <mfrac>
         <mrow>
          <mrow>
           <mo>∂</mo>
           <mi>L</mi>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>y</mi>
            <mi>i</mi>
           </msub>
           <mo>,</mo>
           <mrow>
            <mi>F</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <msub>
              <mi>x</mi>
              <mi>i</mi>
             </msub>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mrow>
          <mrow>
           <mo>∂</mo>
           <mi>F</mi>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>x</mi>
            <mi>i</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mfrac>
        <mo>]</mo>
       </mrow>
       <mrow>
        <mrow>
         <mi>F</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>=</mo>
        <mrow>
         <msub>
          <mi>F</mi>
          <mrow>
           <mi>m</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </msub>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mtext>for</mtext>
      <mi>i</mi>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mn>1</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mi>n</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>m</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <apply>
           <partialdiff></partialdiff>
           <ci>L</ci>
          </apply>
          <interval closure="open">
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>y</ci>
            <ci>i</ci>
           </apply>
           <apply>
            <times></times>
            <ci>F</ci>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>i</ci>
            </apply>
           </apply>
          </interval>
         </apply>
         <apply>
          <times></times>
          <apply>
           <partialdiff></partialdiff>
           <ci>F</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <ci>F</ci>
         <ci>x</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>F</ci>
          <apply>
           <minus></minus>
           <ci>m</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>for</mtext>
      <ci>i</ci>
     </apply>
     <list>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>n</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{im}=-\left[\frac{\partial L(y_{i},F(x_{i}))}{\partial F(x_{i})}\right]_{F(x%
)=F_{m-1}(x)}\quad\mbox{for }i=1,\ldots,n.
  </annotation>
 </semantics>
</math>

</p></li>
<li>Fit a base learner 

<math display="inline" id="Gradient_boosting:57">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>h</mi>
    </mpadded>
    <mi>m</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>m</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!h_{m}(x)
  </annotation>
 </semantics>
</math>

 to pseudo-residuals, i.e. train it using the training set 

<math display="inline" id="Gradient_boosting:58">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>r</mi>
      <mrow>
       <mi>i</mi>
       <mi>m</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>m</ci>
        </apply>
       </apply>
      </interval>
     </set>
     <apply>
      <eq></eq>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(x_{i},r_{im})\}_{i=1}^{n}
  </annotation>
 </semantics>
</math>

.</li>
<li>Compute multiplier 

<math display="inline" id="Gradient_boosting:59">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>γ</mi>
   </mpadded>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>γ</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\gamma_{m}
  </annotation>
 </semantics>
</math>

 by solving the following <a href="Line_search" title="wikilink">one-dimensional optimization</a> problem:

<p>

<math display="block" id="Gradient_boosting:60">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>γ</mi>
     <mi>m</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <munder accentunder="true">
      <mrow>
       <mpadded width="+1.7pt">
        <mi>arg</mi>
       </mpadded>
       <mi>min</mi>
      </mrow>
      <mo>𝛾</mo>
     </munder>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <mi>L</mi>
       <mrow>
        <mo>(</mo>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
        <mo>,</mo>
        <mrow>
         <mrow>
          <msub>
           <mi>F</mi>
           <mrow>
            <mi>m</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>x</mi>
            <mi>i</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>+</mo>
         <mrow>
          <mi>γ</mi>
          <msub>
           <mi>h</mi>
           <mi>m</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>x</mi>
            <mi>i</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>γ</ci>
      <apply>
       <times></times>
       <ci>arg</ci>
       <ci>min</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>L</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>F</ci>
           <apply>
            <minus></minus>
            <ci>m</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>i</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>γ</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>h</ci>
           <ci>m</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma_{m}=\underset{\gamma}{\operatorname{arg\,min}}\sum_{i=1}^{n}L\left(y_{i%
},F_{m-1}(x_{i})+\gamma h_{m}(x_{i})\right).
  </annotation>
 </semantics>
</math>

</p></li>
<li>Update the model:

<p>

<math display="block" id="Gradient_boosting:61">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>F</mi>
      <mi>m</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>F</mi>
       <mrow>
        <mi>m</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>γ</mi>
       <mi>m</mi>
      </msub>
      <msub>
       <mi>h</mi>
       <mi>m</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>m</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>γ</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>m</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{m}(x)=F_{m-1}(x)+\gamma_{m}h_{m}(x).
  </annotation>
 </semantics>
</math>

</p></li>
</ol></li>
<li>Output 

<math display="inline" id="Gradient_boosting:62">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>F</mi>
     <mi>M</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>M</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{M}(x).
  </annotation>
 </semantics>
</math>

</li>
</ol>
<h2 id="gradient-tree-boosting">Gradient tree boosting</h2>

<p>Gradient boosting is typically used with <a href="decision_tree" title="wikilink">decision trees</a> (especially <a href="Classification_and_regression_tree" title="wikilink">CART</a> trees) of a fixed size as base learners. For this special case Friedman proposes a modification to gradient boosting method which improves the quality of fit of each base learner.</p>

<p>Generic gradient boosting at the <em>m</em>-th step would fit a decision tree 

<math display="inline" id="Gradient_boosting:63">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>h</mi>
    </mpadded>
    <mi>m</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>m</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!h_{m}(x)
  </annotation>
 </semantics>
</math>

 to pseudo-residuals. Let 

<math display="inline" id="Gradient_boosting:64">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>J</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>J</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!J
  </annotation>
 </semantics>
</math>

 be the number of its leaves. The tree partitions the input space into 

<math display="inline" id="Gradient_boosting:65">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>J</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>J</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!J
  </annotation>
 </semantics>
</math>

 disjoint regions 

<math display="inline" id="Gradient_boosting:66">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>R</mi>
    </mpadded>
    <mrow>
     <mn>1</mn>
     <mi>m</mi>
    </mrow>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>R</mi>
    <mrow>
     <mi>J</mi>
     <mi>m</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <apply>
      <times></times>
      <cn type="integer">1</cn>
      <ci>m</ci>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <apply>
      <times></times>
      <ci>J</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!R_{1m},\ldots,R_{Jm}
  </annotation>
 </semantics>
</math>

 and predicts a constant value in each region. Using the <a href="indicator_notation" title="wikilink">indicator notation</a>, the output of 

<math display="inline" id="Gradient_boosting:67">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="-1.7pt" width="-1.7pt">
     <mi>h</mi>
    </mpadded>
    <mi>m</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>m</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!h_{m}(x)
  </annotation>
 </semantics>
</math>

 for input <em>x</em> can be written as the sum:</p>

<p>

<math display="block" id="Gradient_boosting:68">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>m</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>j</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>J</mi>
   </munderover>
   <msub>
    <mi>b</mi>
    <mrow>
     <mi>j</mi>
     <mi>m</mi>
    </mrow>
   </msub>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <msub>
     <mi>R</mi>
     <mrow>
      <mi>j</mi>
      <mi>m</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>m</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>J</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <csymbol cd="unknown">I</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>m</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{m}(x)=\sum_{j=1}^{J}b_{jm}I(x\in R_{jm}),
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Gradient_boosting:69">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>b</mi>
   </mpadded>
   <mrow>
    <mi>j</mi>
    <mi>m</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>b</ci>
    <apply>
     <times></times>
     <ci>j</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!b_{jm}
  </annotation>
 </semantics>
</math>

 is the value predicted in the region 

<math display="inline" id="Gradient_boosting:70">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>R</mi>
   </mpadded>
   <mrow>
    <mi>j</mi>
    <mi>m</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <apply>
     <times></times>
     <ci>j</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!R_{jm}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>Then the coefficients 

<math display="inline" id="Gradient_boosting:71">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>b</mi>
   </mpadded>
   <mrow>
    <mi>j</mi>
    <mi>m</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>b</ci>
    <apply>
     <times></times>
     <ci>j</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!b_{jm}
  </annotation>
 </semantics>
</math>

 are multiplied by some value 

<math display="inline" id="Gradient_boosting:72">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>γ</mi>
   </mpadded>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>γ</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\gamma_{m}
  </annotation>
 </semantics>
</math>

, chosen using line search so as to minimize the loss function, and the model is updated as follows:</p>

<p>

<math display="block" id="Gradient_boosting:73">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>F</mi>
       <mi>m</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>F</mi>
        <mrow>
         <mi>m</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>γ</mi>
        <mi>m</mi>
       </msub>
       <msub>
        <mi>h</mi>
        <mi>m</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <msub>
      <mi>γ</mi>
      <mi>m</mi>
     </msub>
     <mo>=</mo>
     <mrow>
      <munder accentunder="true">
       <mrow>
        <mpadded width="+1.7pt">
         <mi>arg</mi>
        </mpadded>
        <mi>min</mi>
       </mrow>
       <mo>𝛾</mo>
      </munder>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>n</mi>
       </munderover>
       <mrow>
        <mi>L</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>y</mi>
          <mi>i</mi>
         </msub>
         <mo>,</mo>
         <mrow>
          <mrow>
           <msub>
            <mi>F</mi>
            <mrow>
             <mi>m</mi>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
           </msub>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>x</mi>
             <mi>i</mi>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>+</mo>
          <mrow>
           <mi>γ</mi>
           <msub>
            <mi>h</mi>
            <mi>m</mi>
           </msub>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>x</mi>
             <mi>i</mi>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>m</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <apply>
         <minus></minus>
         <ci>m</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>m</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>γ</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>γ</ci>
       <apply>
        <times></times>
        <ci>arg</ci>
        <ci>min</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <ci>L</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <plus></plus>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>F</ci>
            <apply>
             <minus></minus>
             <ci>m</ci>
             <cn type="integer">1</cn>
            </apply>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>i</ci>
           </apply>
          </apply>
          <apply>
           <times></times>
           <ci>γ</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>h</ci>
            <ci>m</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>i</ci>
           </apply>
          </apply>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{m}(x)=F_{m-1}(x)+\gamma_{m}h_{m}(x),\quad\gamma_{m}=\underset{\gamma}{%
\operatorname{arg\,min}}\sum_{i=1}^{n}L(y_{i},F_{m-1}(x_{i})+\gamma h_{m}(x_{i%
})).
  </annotation>
 </semantics>
</math>

</p>

<p>Friedman proposes to modify this algorithm so that it chooses a separate optimal value 

<math display="inline" id="Gradient_boosting:74">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>γ</mi>
   </mpadded>
   <mrow>
    <mi>j</mi>
    <mi>m</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>γ</ci>
    <apply>
     <times></times>
     <ci>j</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\gamma_{jm}
  </annotation>
 </semantics>
</math>

 for each of the tree's regions, instead of a single 

<math display="inline" id="Gradient_boosting:75">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>γ</mi>
   </mpadded>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>γ</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!\gamma_{m}
  </annotation>
 </semantics>
</math>

 for the whole tree. He calls the modified algorithm "TreeBoost". The coefficients 

<math display="inline" id="Gradient_boosting:76">
 <semantics>
  <msub>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>b</mi>
   </mpadded>
   <mrow>
    <mi>j</mi>
    <mi>m</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>b</ci>
    <apply>
     <times></times>
     <ci>j</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!b_{jm}
  </annotation>
 </semantics>
</math>

 from the tree-fitting procedure can be then simply discarded and the model update rule becomes:</p>

<p>

<math display="block" id="Gradient_boosting:77">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mi>m</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>F</mi>
    <mrow>
     <mi>m</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>j</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>J</mi>
   </munderover>
   <msub>
    <mi>γ</mi>
    <mrow>
     <mi>j</mi>
     <mi>m</mi>
    </mrow>
   </msub>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <msub>
     <mi>R</mi>
     <mrow>
      <mi>j</mi>
      <mi>m</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <msub>
    <mi>γ</mi>
    <mrow>
     <mi>j</mi>
     <mi>m</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <munder accentunder="true">
    <mrow>
     <mpadded width="+1.7pt">
      <mi>arg</mi>
     </mpadded>
     <mi>min</mi>
    </mrow>
    <mo>𝛾</mo>
   </munder>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo>∈</mo>
     <msub>
      <mi>R</mi>
      <mrow>
       <mi>j</mi>
       <mi>m</mi>
      </mrow>
     </msub>
    </mrow>
   </munder>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>F</mi>
     <mrow>
      <mi>m</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mi>γ</mi>
    <msub>
     <mi>h</mi>
     <mi>m</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>m</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <apply>
      <minus></minus>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>J</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <csymbol cd="unknown">I</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>m</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <ci>γ</ci>
     <apply>
      <times></times>
      <ci>arg</ci>
      <ci>min</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <apply>
        <times></times>
        <ci>j</ci>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <apply>
       <minus></minus>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <plus></plus>
     <csymbol cd="unknown">γ</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>m</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{m}(x)=F_{m-1}(x)+\sum_{j=1}^{J}\gamma_{jm}I(x\in R_{jm}),\quad\gamma_{jm}=%
\underset{\gamma}{\operatorname{arg\,min}}\sum_{x_{i}\in R_{jm}}L(y_{i},F_{m-1%
}(x_{i})+\gamma h_{m}(x_{i})).
  </annotation>
 </semantics>
</math>

</p>
<h3 id="size-of-trees">Size of trees</h3>

<p>

<math display="inline" id="Gradient_boosting:78">
 <semantics>
  <mpadded lspace="-1.7pt" width="-1.7pt">
   <mi>J</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>J</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!J
  </annotation>
 </semantics>
</math>

, the number of terminal nodes in trees, is the method's parameter which can be adjusted for a data set at hand. It controls the maximum allowed level of <a href="Interaction_(statistics)" title="wikilink">interaction</a> between variables in the model. With 

<math display="inline" id="Gradient_boosting:79">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>J</mi>
   </mpadded>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>J</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!J=2
  </annotation>
 </semantics>
</math>

 (<a href="decision_stump" title="wikilink">decision stumps</a>), no interaction between variables is allowed. With 

<math display="inline" id="Gradient_boosting:80">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mi>J</mi>
   </mpadded>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>J</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!J=3
  </annotation>
 </semantics>
</math>

 the model may include effects of the interaction between up to two variables, and so on.</p>

<p>Hastie et al.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> comment that typically 

<math display="inline" id="Gradient_boosting:81">
 <semantics>
  <mrow>
   <mn>4</mn>
   <mo>≤</mo>
   <mi>J</mi>
   <mo>≤</mo>
   <mn>8</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">4</cn>
     <ci>J</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <cn type="integer">8</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4\leq J\leq 8
  </annotation>
 </semantics>
</math>

 work well for boosting and results are fairly insensitive to the choice of 

<math display="inline" id="Gradient_boosting:82">
 <semantics>
  <mi>J</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>J</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J
  </annotation>
 </semantics>
</math>

 in this range, 

<math display="inline" id="Gradient_boosting:83">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>J</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J=2
  </annotation>
 </semantics>
</math>

 is insufficient for many applications, and 

<math display="inline" id="Gradient_boosting:84">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mo>></mo>
   <mn>10</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>J</ci>
    <cn type="integer">10</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J>10
  </annotation>
 </semantics>
</math>

 is unlikely to be required.</p>
<h2 id="regularization">Regularization</h2>

<p>Fitting the training set too closely can lead to degradation of the model's generalization ability. Several so-called <a href="Regularization_(mathematics)" title="wikilink">regularization</a> techniques reduce this <a class="uri" href="overfitting" title="wikilink">overfitting</a> effect by constraining the fitting procedure.</p>

<p>One natural regularization parameter is the number of gradient boosting iterations <em>M</em> (i.e. the number of trees in the model when the base learner is a decision tree). Increasing <em>M</em> reduces the error on training set, but setting it too high may lead to overfitting. An optimal value of <em>M</em> is often selected by monitoring prediction error on a separate validation data set. Besides controlling <em>M</em>, several other regularization techniques are used.</p>
<h3 id="shrinkage">Shrinkage</h3>

<p>An important part of gradient boosting method is regularization by shrinkage which consists in modifying the update rule as follows:</p>

<p>

<math display="block" id="Gradient_boosting:85">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>F</mi>
       <mi>m</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>F</mi>
        <mrow>
         <mi>m</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mrow>
        <mi>ν</mi>
        <mo>⋅</mo>
        <msub>
         <mi>γ</mi>
         <mi>m</mi>
        </msub>
       </mrow>
       <msub>
        <mi>h</mi>
        <mi>m</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mn>0</mn>
     <mo><</mo>
     <mi>ν</mi>
     <mo>≤</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>m</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <apply>
         <minus></minus>
         <ci>m</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <ci>ν</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>γ</ci>
         <ci>m</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>m</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <lt></lt>
      <cn type="integer">0</cn>
      <ci>ν</ci>
     </apply>
     <apply>
      <leq></leq>
      <share href="#.cmml">
      </share>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{m}(x)=F_{m-1}(x)+\nu\cdot\gamma_{m}h_{m}(x),\quad 0<\nu\leq 1,
  </annotation>
 </semantics>
</math>

 where parameter 

<math display="inline" id="Gradient_boosting:86">
 <semantics>
  <mi>ν</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ν</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu
  </annotation>
 </semantics>
</math>

 is called the "learning rate".</p>

<p>Empirically it has been found that using small learning rates (such as 

<math display="inline" id="Gradient_boosting:87">
 <semantics>
  <mrow>
   <mi>ν</mi>
   <mo><</mo>
   <mn>0.1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>ν</ci>
    <cn type="float">0.1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu<0.1
  </annotation>
 </semantics>
</math>

) yields dramatic improvements in model's generalization ability over gradient boosting without shrinking (

<math display="inline" id="Gradient_boosting:88">
 <semantics>
  <mrow>
   <mi>ν</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ν</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu=1
  </annotation>
 </semantics>
</math>

).<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> However, it comes at the price of increasing computational time both during training and querying: lower learning rate requires more iterations.</p>
<h3 id="stochastic-gradient-boosting">Stochastic gradient boosting</h3>

<p>Soon after the introduction of gradient boosting Friedman proposed a minor modification to the algorithm, motivated by <a href="Leo_Breiman" title="wikilink">Breiman</a>'s <a href="Bootstrap_aggregation" title="wikilink">bagging</a> method.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Specifically, he proposed that at each iteration of the algorithm, a base learner should be fit on a subsample of the training set drawn at random without replacement.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> Friedman observed a substantial improvement in gradient boosting's accuracy with this modification.</p>

<p>Subsample size is some constant fraction <em>f</em> of the size of the training set. When <em>f</em> = 1, the algorithm is deterministic and identical to the one described above. Smaller values of <em>f</em> introduce randomness into the algorithm and help prevent <a class="uri" href="overfitting" title="wikilink">overfitting</a>, acting as a kind of <a href="Regularization_(mathematics)" title="wikilink">regularization</a>. The algorithm also becomes faster, because regression trees have to be fit to smaller datasets at each iteration. Friedman<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> obtained that 

<math display="inline" id="Gradient_boosting:89">
 <semantics>
  <mrow>
   <mpadded lspace="-1.7pt" width="-1.7pt">
    <mn>0.5</mn>
   </mpadded>
   <mo>≤</mo>
   <mi>f</mi>
   <mo>≤</mo>
   <mn>0.8</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="float">0.5</cn>
     <ci>f</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <cn type="float">0.8</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \!0.5\leq f\leq 0.8
  </annotation>
 </semantics>
</math>

 leads to good results for small and moderate sized training sets. Therefore, <em>f</em> is typically set to 0.5, meaning that one half of the training set is used to build each base learner.</p>

<p>Also, like in bagging, subsampling allows one to define an <a href="out-of-bag_estimate" title="wikilink">out-of-bag estimate</a> of the prediction performance improvement by evaluating predictions on those observations which were not used in the building of the next base learner. Out-of-bag estimates help avoid the need for an independent validation dataset, but often underestimate actual performance improvement and the optimal number of iterations.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h3 id="number-of-observations-in-leaves">Number of observations in leaves</h3>

<p>Gradient tree boosting implementations often also use regularization by limiting the minimum number of observations in trees' terminal nodes (this parameter is called <code>n.minobsinnode</code> in the R <code>gbm</code> package<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a>). It is used in the tree building process by ignoring any splits that lead to nodes containing fewer than this number of training set instances.</p>

<p>Imposing this limit helps to reduce variance in predictions at leaves.</p>
<h3 id="penalize-complexity-of-tree">Penalize Complexity of Tree</h3>

<p>Another useful regularization techniques for gradient boosted trees is to penalize model complexity of the learned model. <a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> The model complexity can be defined proportional number of leaves in the learned trees. The jointly optimization of loss and model complexity corresponds to a post-pruning algorithm to remove branches that fail to reduce the loss by a threshold. Other kinds of regularization such as l2 penalty on the leave values can also be added to avoid overfitting.</p>
<h2 id="usage">Usage</h2>

<p>Recently, gradient boosting has gained some popularity in the field of <a href="learning_to_rank" title="wikilink">learning to rank</a>. The commercial web search engines <a class="uri" href="Yahoo" title="wikilink">Yahoo</a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> and <a class="uri" href="Yandex" title="wikilink">Yandex</a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> use variants of gradient boosting in their machine-learned ranking engines.</p>
<h2 id="names">Names</h2>

<p>The method goes by a variety of names. Friedman introduced his regression technique as a "Gradient Boosting Machine" (GBM).<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> Mason, Baxter et. el. described the generalized abstract class of algorithms as "functional gradient boosting".<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p>A popular open-source implementation<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> for <a href="R_(programming_language)" title="wikilink">R</a> calls it "Generalized Boosting Model". Commercial implementations from Salford Systems use the names "Multiple Additive Regression Trees" (MART) and TreeNet, both trademarked.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="AdaBoost" title="wikilink">AdaBoost</a></li>
<li><a href="Random_forest" title="wikilink">Random forest</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Decision_trees" title="wikilink">Category:Decision trees</a> <a href="Category:Ensemble_learning" title="wikilink">Category:Ensemble learning</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Brieman, L. "<a href="http://statistics.berkeley.edu/sites/default/files/tech-reports/486.pdf">Arcing The Edge</a>" (June 1997)<a href="#fnref1">↩</a></li>
<li id="fn2">Friedman, J. H. "<a href="http://www-stat.stanford.edu/~jhf/ftp/trebst.pdf">Greedy Function Approximation: A Gradient Boosting Machine.</a>" (February 1999)<a href="#fnref2">↩</a></li>
<li id="fn3">Friedman, J. H. "<a href="https://statweb.stanford.edu/~jhf/ftp/stobst.pdf">Stochastic Gradient Boosting.</a>" (March 1999)<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9">Note: in case of usual CART trees, the trees are fitted using least-squares loss, and so the coefficient 

<math display="inline" id="Gradient_boosting:90">
 <semantics>
  <msub>
   <mi>b</mi>
   <mrow>
    <mi>j</mi>
    <mi>m</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>b</ci>
    <apply>
     <times></times>
     <ci>j</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{jm}
  </annotation>
 </semantics>
</math>

 for the region 

<math display="inline" id="Gradient_boosting:91">
 <semantics>
  <msub>
   <mi>R</mi>
   <mrow>
    <mi>j</mi>
    <mi>m</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <apply>
     <times></times>
     <ci>j</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{jm}
  </annotation>
 </semantics>
</math>

 is equal to just the value of output variable, averaged over all training instances in 

<math display="inline" id="Gradient_boosting:92">
 <semantics>
  <msub>
   <mi>R</mi>
   <mrow>
    <mi>j</mi>
    <mi>m</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <apply>
     <times></times>
     <ci>j</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{jm}
  </annotation>
 </semantics>
</math>

.<a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13">Note that this is different from bagging, which samples with replacement because it uses samples of the same size as the training set.<a href="#fnref13">↩</a></li>
<li id="fn14">Friedman, J. H. "<a href="http://www-stat.stanford.edu/~jhf/ftp/stobst.pdf">Stochastic Gradient Boosting.</a>" (March 1999)<a href="#fnref14">↩</a></li>
<li id="fn15">Ridgeway, Greg (2007). <a href="http://cran.r-project.org/web/packages/gbm/gbm.pdf">Generalized Boosted Models: A guide to the gbm package.</a><a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17">Tianqi Chen. <a href="http://homes.cs.washington.edu/~tqchen/pdf/BoostedTree.pdf">Introduction to Boosted Trees</a><a href="#fnref17">↩</a></li>
<li id="fn18">Cossock, David and Zhang, Tong (2008). <a href="http://www.stat.rutgers.edu/~tzhang/papers/it08-ranking.pdf">Statistical Analysis of Bayes Optimal Subset Ranking</a>, page 14.<a href="#fnref18">↩</a></li>
<li id="fn19">[<a class="uri" href="http://webmaster.ya.ru/replies.xml?item_no=5707&amp;ncrnd">http://webmaster.ya.ru/replies.xml?item_no=5707&amp;ncrnd;</a>;=5118 Yandex corporate blog entry about new ranking model "Snezhinsk"] (in Russian)<a href="#fnref19">↩</a></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
</ol>
</section>
</body>
</html>
