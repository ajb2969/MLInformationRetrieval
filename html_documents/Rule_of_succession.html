<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="705">Rule of succession</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Rule of succession</h1>
<hr/>

<p>In <a href="probability_theory" title="wikilink">probability theory</a>, the <strong>rule of succession</strong> is a formula introduced in the 18th century by <a href="Pierre-Simon_Laplace" title="wikilink">Pierre-Simon Laplace</a> in the course of treating the <a href="sunrise_problem" title="wikilink">sunrise problem</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The formula is still used, particularly to estimate underlying probabilities when there are few observations, or for events that have not been observed to occur at all in (finite) sample data. Assigning events a zero probability contravenes <a href="Cromwell's_rule" title="wikilink">Cromwell's rule</a>, which can never be strictly justified in physical situations, albeit sometimes must be assumed in practice.</p>
<h2 id="statement-of-the-rule-of-succession">Statement of the rule of succession</h2>

<p>If we repeat an experiment that we know can result in a success or failure, <em>n</em> times independently, and get <em>s</em> successes, then what is the probability that the next repetition will succeed?</p>

<p>More abstractly: If <em>X</em><sub>1</sub>, ..., <em>X</em><sub><em>n</em>+1</sub> are <a href="conditional_independence" title="wikilink">conditionally independent</a> <a href="random_variable" title="wikilink">random variables</a> that each can assume the value 0 or 1, then, if we know nothing more about them,</p>

<p>

<math display="block" id="Rule_of_succession:0">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mn>1</mn>
    <mo>∣</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>s</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>2</mn>
    </mrow>
   </mfrac>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <plus></plus>
     <ci>normal-⋯</ci>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X_{n+1}=1\mid X_{1}+\cdots+X_{n}=s)={s+1\over n+2}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="interpretation">Interpretation</h2>

<p>Since we have the prior knowledge that we are looking at an experiment for which both success and failure are possible, our estimate is as if we had observed one success and one failure for sure before we even started the experiments. In a sense we made <em>n</em> + 2 observations (known as <a href="pseudocount" title="wikilink">pseudocounts</a>) with <em>s</em>+1 successes. Beware: although this may seem the simplest and most reasonable assumption, which also happens to be true, so is a useful mnemonic, it still requires a proof! Indeed, assuming a pseudocount of one per possibility is one way to generalise the binary result, but has unexpected consequences — see <a href="rule_of_succession#Generalization_to_any_number_of_possibilities" title="wikilink">Generalization to any number of possibilities</a>, below.</p>

<p>Nevertheless, if we had <strong>not</strong> known from the start that both success and failure are possible, then we would have had to assign</p>

<p>

<math display="block" id="Rule_of_succession:1">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mn>1</mn>
    <mo>∣</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mi>s</mi>
    <mi>n</mi>
   </mfrac>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>normal-′</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <plus></plus>
     <ci>normal-⋯</ci>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>s</ci>
     <ci>n</ci>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{\prime}(X_{n+1}=1\mid X_{1}+\cdots+X_{n}=s)={s\over n}.
  </annotation>
 </semantics>
</math>

</p>

<p>But see <a href="rule_of_succession#Mathematical_details" title="wikilink">Mathematical details</a>, below, for an analysis of its validity. In particular it is not valid when 

<math display="inline" id="Rule_of_succession:2">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=0
  </annotation>
 </semantics>
</math>

, or 

<math display="inline" id="Rule_of_succession:3">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=n
  </annotation>
 </semantics>
</math>

.</p>

<p>If the number of observations increases, 

<math display="inline" id="Rule_of_succession:4">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Rule_of_succession:5">
 <semantics>
  <msup>
   <mi>P</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>P</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{\prime}
  </annotation>
 </semantics>
</math>

 get more and more similar, which is intuitively clear: the more data we have, the less importance should be assigned to our prior information.</p>
<h2 id="historical-application-to-the-sunrise-problem">Historical application to the sunrise problem</h2>

<p>Laplace used the rule of succession to calculate the probability that the sun will rise tomorrow, given that it has risen every day for the past 5000 years. One obtains a very large factor of approximately 5000 × 365.25, which gives odds of 1826251:1 in favour of the sun rising tomorrow.</p>

<p>However, as the mathematical details below show, the basic assumption for using the rule of succession would be that we have no prior knowledge about the question whether the sun will or will not rise tomorrow, except that it can do either. This is not the case for sunrises.</p>

<p>Laplace knew this well, and he wrote to conclude the sunrise example: “But this number is far greater for him who, seeing in the totality of phenomena the principle regulating the days and seasons, realizes that nothing at the present moment can arrest the course of it.” Yet Laplace was ridiculed for this calculation; his opponents gave no heed to that sentence, or failed to understand its importance.</p>

<p>In the 1940s, <a href="Rudolf_Carnap" title="wikilink">Rudolf Carnap</a> investigated a probability-based theory of <a href="inductive_reasoning" title="wikilink">inductive reasoning</a>, and developed measures of degree of confirmation, which he considered as alternatives to Laplace's rule of succession.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> See also <a href="New_riddle_of_induction#Carnap" title="wikilink">New riddle of induction#Carnap</a>.</p>
<h2 id="mathematical-details">Mathematical details</h2>

<p>The proportion <em>p</em> is assigned a uniform distribution to describe the uncertainty about its true value. (Note: This proportion is not random, but uncertain. We assign a probability distribution to <em>p</em> to express our uncertainty, not to attribute randomness to <em>p</em>. But this amounts, mathematically, to the same thing as treating <em>p as if</em> it were random).</p>

<p>Let <em>X</em><sub><em>i</em></sub> be 1 if we observe a "success" on the <em>i</em>th <a href="Bernoulli_trial" title="wikilink">trial</a>, otherwise 0, with probability <em>p</em> of success on each trial. Thus each <em>X</em> is 0 or 1; each <em>X</em> has a <a href="Bernoulli_distribution" title="wikilink">Bernoulli distribution</a>. Suppose these <em>X</em>s are <a href="conditional_independence" title="wikilink">conditionally independent</a> given <em>p</em>.</p>

<p><a href="Bayes'_theorem" title="wikilink">Bayes' theorem</a> says that to find the conditional probability distribution of <em>p</em> given the data <em>X</em><sub><em>i</em></sub>, <em>i</em> = 1, ..., <em>n</em>, one multiplies the "<a href="Prior_probability" title="wikilink">prior</a>" (i.e., marginal) probability measure assigned to <em>p</em> by the <a href="likelihood_function" title="wikilink">likelihood function</a></p>

<p>

<math display="block" id="Rule_of_succession:6">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo>∣</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>n</mi>
   </munderover>
   <msup>
    <mi>p</mi>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
   </msup>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo>-</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </msup>
   <mo>=</mo>
   <msup>
    <mi>p</mi>
    <mi>s</mi>
   </msup>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo>-</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mi>s</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cn type="integer">1</cn>
      <minus></minus>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>p</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cn type="integer">1</cn>
      <minus></minus>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>s</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(p)=P(X_{1}=x_{1},\ldots,X_{n}=x_{n}\mid p)=\prod_{i=1}^{n}p^{x_{i}}(1-p)^{1-%
x_{i}}=p^{s}(1-p)^{n-s}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>s</em> = <em>x</em><sub>1</sub> + ... + <em>x</em><sub><em>n</em></sub> is the number of "successes" and <em>n</em> is of course the number of trials, and then <a href="normalizing_constant" title="wikilink">normalizes</a>, to get the "posterior" (i.e., conditional on the data) probability distribution of <em>p</em>. (We are using capital <em>X</em> to denote a random variable and lower-case <em>x</em> either as the <a href="bound_variable" title="wikilink">dummy</a> in the definition of a function or as the data actually observed.)</p>

<p>The prior <a href="probability_density_function" title="wikilink">probability density function</a> that expresses total ignorance of <em>p</em> except for the certain knowledge that it is neither 1 nor 0 (i.e., that we know that the experiment can in fact succeed or fail) is equal to 1 for 0 \int_0^1 p^s(1-p)^{n-s}\,dp={s!(n-s)! \over (n+1)!}</p>

<p>(see <a href="beta_function" title="wikilink">beta function</a> for more on integrals of this form).</p>

<p>The posterior probability density function is therefore</p>

<p>

<math display="block" id="Rule_of_succession:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>p</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
      <mrow>
       <mrow>
        <mi>s</mi>
        <mo lspace="0pt" rspace="3.5pt">!</mo>
       </mrow>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mi>s</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo lspace="0pt" rspace="3.5pt">!</mo>
       </mrow>
      </mrow>
     </mfrac>
     <msup>
      <mi>p</mi>
      <mi>s</mi>
     </msup>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>p</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>s</mi>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <factorial></factorial>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <factorial></factorial>
        <ci>s</ci>
       </apply>
       <apply>
        <factorial></factorial>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>p</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(p)={(n+1)!\over s!(n-s)!}p^{s}(1-p)^{n-s}.
  </annotation>
 </semantics>
</math>

</p>

<p>This is a <a href="beta_distribution" title="wikilink">beta distribution</a> with <a href="expected_value" title="wikilink">expected value</a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Rule_of_succession:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mn>0</mn>
      <mn>1</mn>
     </msubsup>
     <mrow>
      <mi>p</mi>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>p</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>p</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mi>s</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>2</mn>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>f</ci>
      <ci>p</ci>
      <ci>d</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{0}^{1}pf(p)\,dp={s+1\over n+2}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Since the conditional probability for success in the next experiment, given the value of <em>p</em>, is just <em>p</em>, the <a href="law_of_total_probability" title="wikilink">law of total probability</a> tell us that the probability of success in the next experiment is just the expected value of <em>p</em>. Since all of this is conditional on the observed data <em>X</em><sub><em>i</em></sub> for <em>i</em> = 1, ..., <em>n</em>, we have</p>

<p>

<math display="block" id="Rule_of_succession:9">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mn>1</mn>
    <mo>∣</mo>
    <msub>
     <mi>X</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mtext>for</mtext>
    <mi>i</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>s</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>2</mn>
    </mrow>
   </mfrac>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>i</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <mtext>for</mtext>
     <csymbol cd="unknown">i</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X_{n+1}=1\mid X_{i}=x_{i}\text{ for }i=1,\dots,n)={s+1\over n+2}.
  </annotation>
 </semantics>
</math>

</p>

<p>The same calculation can be performed with the prior that expresses total ignorance of <em>p</em>, including ignorance with regards to the question whether the experiment can succeed, or can fail. This prior, except for a normalizing constant, is 1/(<em>p</em>(1 − <em>p</em>)) for 0 ≤ <em>p</em> ≤ 1 and 0 otherwise.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> If the calculation above is repeated with this prior, we get</p>

<p>

<math display="block" id="Rule_of_succession:10">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mn>1</mn>
    <mo>∣</mo>
    <msub>
     <mi>X</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mtext>for</mtext>
    <mi>i</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mi>s</mi>
    <mi>n</mi>
   </mfrac>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>normal-′</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>i</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <mtext>for</mtext>
     <csymbol cd="unknown">i</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>s</ci>
     <ci>n</ci>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{\prime}(X_{n+1}=1\mid X_{i}=x_{i}\text{ for }i=1,\dots,n)={s\over n}.
  </annotation>
 </semantics>
</math>

</p>

<p>Thus, with the prior specifying total ignorance, the probability of success is governed by the observed frequency of success. However, the posterior distribution that led to this result is the Beta(<em>s</em>,<em>n</em> − <em>s</em>) distribution, which is not proper when <em>s</em> = <em>n</em> or <em>s</em> = 0 (i.e. the normalisation constant is infinite when <em>s</em> = 0 or <em>s</em> = <em>n</em>). This means that we cannot use this form of the posterior distribution to calculate the probability of the next observation succeeding when <em>s</em> = 0 or <em>s</em> = <em>n</em>. This puts the information contained in the rule of succession in greater light: it can be thought of as expressing the prior assumption that if sampling was continued indefinitely, we would eventually observe at least one success, and at least one failure in the sample. The prior expressing total ignorance does not assume this knowledge.</p>

<p>To evaluate the "complete ignorance" case when <em>s</em> = 0 or <em>s</em> = <em>n</em> can be dealt with by first going back to the <a href="hypergeometric_distribution" title="wikilink">hypergeometric distribution</a>, denoted by 

<math display="inline" id="Rule_of_succession:11">
 <semantics>
  <mrow>
   <mi>Hyp</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">|</mo>
    <mi>N</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Hyp</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Hyp}(s|N,n,S)
  </annotation>
 </semantics>
</math>

. This is the approach taken in Jaynes(2003). The binomial 

<math display="inline" id="Rule_of_succession:12">
 <semantics>
  <mrow>
   <mi>Bin</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo stretchy="false">|</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Bin</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Bin}(r|n,p)
  </annotation>
 </semantics>
</math>

 can be derived as a limiting form, where 

<math display="inline" id="Rule_of_succession:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <mo>,</mo>
    <mi>S</mi>
   </mrow>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <list>
     <ci>N</ci>
     <ci>S</ci>
    </list>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N,S\rightarrow\infty
  </annotation>
 </semantics>
</math>

 in such a way that their ratio 

<math display="inline" id="Rule_of_succession:14">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <mfrac>
    <mi>S</mi>
    <mi>N</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <apply>
     <divide></divide>
     <ci>S</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p={S\over N}
  </annotation>
 </semantics>
</math>

 remains fixed. One can think of 

<math display="inline" id="Rule_of_succession:15">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 as the number of successes in the total population, of size 

<math display="inline" id="Rule_of_succession:16">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

</p>

<p>The equivalent prior to 

<math display="inline" id="Rule_of_succession:17">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <times></times>
     <ci>p</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {1\over p(1-p)}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Rule_of_succession:18">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mi>S</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {1\over S(N-S)}
  </annotation>
 </semantics>
</math>

, with a domain of 

<math display="inline" id="Rule_of_succession:19">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>S</mi>
   <mo>≤</mo>
   <mrow>
    <mi>N</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>S</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq S\leq N-1
  </annotation>
 </semantics>
</math>

. Working conditional to 

<math display="inline" id="Rule_of_succession:20">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 means that estimating 

<math display="inline" id="Rule_of_succession:21">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is equivalent to estimating 

<math display="inline" id="Rule_of_succession:22">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, and then dividing this estimate by 

<math display="inline" id="Rule_of_succession:23">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

. The posterior for 

<math display="inline" id="Rule_of_succession:24">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 can be given as:</p>

<p>

<math display="block" id="Rule_of_succession:25">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">|</mo>
    <mi>N</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∝</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mi>S</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mrow>
    <mo>(</mo>
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mi>S</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mi>s</mi>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mrow>
    <mo>(</mo>
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mrow>
        <mi>N</mi>
        <mo>-</mo>
        <mi>S</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>s</mi>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mo>∝</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mi>S</mi>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>N</mi>
        <mo>-</mo>
        <mi>S</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mi>S</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>S</mi>
        <mo>-</mo>
        <mi>s</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>N</mi>
        <mo>-</mo>
        <mi>S</mi>
        <mo>-</mo>
        <mrow>
         <mo stretchy="false">[</mo>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mi>s</mi>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proportional-to</csymbol>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">binomial</csymbol>
     <ci>S</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">binomial</csymbol>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <csymbol cd="latexml">proportional-to</csymbol>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <factorial></factorial>
       <ci>S</ci>
      </apply>
      <apply>
       <factorial></factorial>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <ci>S</ci>
      </apply>
      <apply>
       <factorial></factorial>
       <apply>
        <minus></minus>
        <ci>S</ci>
        <ci>s</ci>
       </apply>
      </apply>
      <apply>
       <factorial></factorial>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <ci>S</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <ci>s</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(S|N,n,s)\propto{1\over S(N-S)}{S\choose s}{N-S\choose n-s}\propto{S!(N-S)!%
\over S(N-S)(S-s)!(N-S-[n-s])!}
  </annotation>
 </semantics>
</math>

</p>

<p>And it can be seen that, if <em>s</em> = <em>n</em> or <em>s</em> = 0, then one of the factorials in the numerator cancels exactly with one in the denominator. Taking the <em>s</em> = 0 case, we have:</p>

<p>

<math display="block" id="Rule_of_succession:26">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">|</mo>
    <mi>N</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo>=</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∝</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mi>S</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>N</mi>
        <mo>-</mo>
        <mi>S</mi>
        <mo>-</mo>
        <mi>n</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </munderover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mi>S</mi>
       <mo>-</mo>
       <mi>j</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mi>S</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">s</csymbol>
     <eq></eq>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proportional-to</csymbol>
    <apply>
     <divide></divide>
     <apply>
      <factorial></factorial>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <ci>S</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <factorial></factorial>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <ci>S</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <ci>S</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <ci>S</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(S|N,n,s=0)\propto{(N-S-1)!\over S(N-S-n)!}={\prod_{j=1}^{n-1}(N-S-j)\over S}
  </annotation>
 </semantics>
</math>

</p>

<p>Adding in the normalising constant, which is always finite (because there is no singularities in the range of the posterior, and there are a finite number of terms) gives:</p>

<p>

<math display="block" id="Rule_of_succession:27">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">|</mo>
    <mi>N</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo>=</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </munderover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mi>S</mi>
       <mo>-</mo>
       <mi>j</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>R</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mrow>
        <mi>N</mi>
        <mo>-</mo>
        <mi>n</mi>
       </mrow>
      </msubsup>
      <mfrac>
       <mrow>
        <msubsup>
         <mo largeop="true" symmetric="true">∏</mo>
         <mrow>
          <mi>j</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msubsup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>N</mi>
          <mo>-</mo>
          <mi>R</mi>
          <mo>-</mo>
          <mi>j</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mi>R</mi>
      </mfrac>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">s</csymbol>
     <eq></eq>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <ci>S</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>R</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>N</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <csymbol cd="latexml">product</csymbol>
           <apply>
            <eq></eq>
            <ci>j</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <apply>
           <minus></minus>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <minus></minus>
          <ci>N</ci>
          <ci>R</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <ci>R</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(S|N,n,s=0)={\prod_{j=1}^{n-1}(N-S-j)\over S\sum_{R=1}^{N-n}{\prod_{j=1}^{n-1%
}(N-R-j)\over R}}
  </annotation>
 </semantics>
</math>

</p>

<p>So the posterior expectation for 

<math display="inline" id="Rule_of_succession:28">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <mfrac>
    <mi>S</mi>
    <mi>N</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <apply>
     <divide></divide>
     <ci>S</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p={S\over N}
  </annotation>
 </semantics>
</math>

 is:</p>

<p>

<math display="block" id="Rule_of_succession:29">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mi>S</mi>
     <mi>N</mi>
    </mfrac>
    <mo stretchy="false">|</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo>=</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi>N</mi>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mi>N</mi>
   </mfrac>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>S</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mi>n</mi>
    </mrow>
   </munderover>
   <mi>S</mi>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">|</mo>
    <mi>N</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi>s</mi>
    <mo>=</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mi>N</mi>
   </mfrac>
   <mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>S</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mi>n</mi>
      </mrow>
     </munderover>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </munderover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>N</mi>
        <mo>-</mo>
        <mi>S</mi>
        <mo>-</mo>
        <mi>j</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>R</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mi>n</mi>
      </mrow>
     </msubsup>
     <mfrac>
      <mrow>
       <msubsup>
        <mo largeop="true" symmetric="true">∏</mo>
        <mrow>
         <mi>j</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msubsup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>N</mi>
         <mo>-</mo>
         <mi>R</mi>
         <mo>-</mo>
         <mi>j</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mi>R</mi>
     </mfrac>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <divide></divide>
      <ci>S</ci>
      <ci>N</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">s</csymbol>
     <eq></eq>
     <cn type="integer">0</cn>
     <ci>normal-,</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>S</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <csymbol cd="unknown">S</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">n</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <csymbol cd="unknown">s</csymbol>
     <eq></eq>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>N</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>S</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <csymbol cd="latexml">product</csymbol>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <ci>S</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>R</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <csymbol cd="latexml">product</csymbol>
          <apply>
           <eq></eq>
           <ci>j</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>N</ci>
         <ci>R</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>R</ci>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\left({S\over N}|n,s=0,N\right)={1\over N}\sum_{S=1}^{N-n}SP(S|N,n=1,s=0)={1%
\over N}{\sum_{S=1}^{N-n}\prod_{j=1}^{n-1}(N-S-j)\over\sum_{R=1}^{N-n}{\prod_{%
j=1}^{n-1}(N-R-j)\over R}}
  </annotation>
 </semantics>
</math>

</p>

<p>An approximate analytical expression for large <em>N</em> is given by first making the approximation to the product term:</p>

<p>

<math display="block" id="Rule_of_succession:30">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mi>R</mi>
      <mo>-</mo>
      <mi>j</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mi>R</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <ci>R</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <ci>R</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \prod_{j=1}^{n-1}(N-R-j)\approx(N-R)^{n-1}
  </annotation>
 </semantics>
</math>

</p>

<p>and then replacing the summation in the numerator with an integral</p>

<p>

<math display="block" id="Rule_of_succession:31">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>S</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mi>n</mi>
     </mrow>
    </munderover>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </munderover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mi>S</mi>
       <mo>-</mo>
       <mi>j</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mn>1</mn>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mi>n</mi>
     </mrow>
    </msubsup>
    <mrow>
     <mpadded width="+1.7pt">
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>N</mi>
         <mo>-</mo>
         <mi>S</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mpadded>
     <mi>d</mi>
     <mi>S</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>N</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>n</mi>
     </msup>
     <mo>-</mo>
     <msup>
      <mi>n</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <mi>n</mi>
   </mfrac>
   <mo>≈</mo>
   <mfrac>
    <msup>
     <mi>N</mi>
     <mi>n</mi>
    </msup>
    <mi>n</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <approx></approx>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>S</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <csymbol cd="latexml">product</csymbol>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <ci>S</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>N</ci>
         <ci>S</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>N</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>N</ci>
       <ci>n</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{S=1}^{N-n}\prod_{j=1}^{n-1}(N-S-j)\approx\int_{1}^{N-n}(N-S)^{n-1}\,dS={%
(N-1)^{n}-n^{n}\over n}\approx{N^{n}\over n}
  </annotation>
 </semantics>
</math>

</p>

<p>The same procedure is followed for the denominator, but the process is a bit more tricky, as the integral is harder to evaluate</p>

<p>

<math display="inline" id="Rule_of_succession:32">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>R</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mi>n</mi>
     </mrow>
    </munderover>
   </mstyle>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </munderover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>N</mi>
        <mo>-</mo>
        <mi>R</mi>
        <mo>-</mo>
        <mi>j</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mi>R</mi>
    </mfrac>
   </mstyle>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>R</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <ci>R</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\sum_{R=1}^{N-n}{\prod_{j=1}^{n-1}(N-R-j)\over R}
  </annotation>
 </semantics>
</math>


</p>

<p>where ln is the <a href="natural_logarithm" title="wikilink">natural logarithm</a> plugging in these approximations into the expectation gives</p>

<p>

<math display="block" id="Rule_of_succession:33">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mi>S</mi>
     <mi>N</mi>
    </mfrac>
    <mo stretchy="false">|</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo>=</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi>N</mi>
    <mo>)</mo>
   </mrow>
   <mo>≈</mo>
   <mfrac>
    <mn>1</mn>
    <mi>N</mi>
   </mfrac>
   <mfrac>
    <mfrac>
     <msup>
      <mi>N</mi>
      <mi>n</mi>
     </msup>
     <mi>n</mi>
    </mfrac>
    <mrow>
     <msup>
      <mi>N</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mi>ln</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>N</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>ln</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>N</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>10</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>e</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <msub>
        <mi>log</mi>
        <mn>10</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>N</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mn>0.434294</mn>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <msub>
        <mi>log</mi>
        <mn>10</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>N</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <divide></divide>
      <ci>S</ci>
      <ci>N</ci>
     </apply>
     <ci>normal-|</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">s</csymbol>
     <eq></eq>
     <cn type="integer">0</cn>
     <ci>normal-,</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <approx></approx>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>N</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>N</ci>
       <ci>n</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>N</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <ln></ln>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <ln></ln>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">10</cn>
      </apply>
      <ci>e</ci>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <cn type="integer">10</cn>
        </apply>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="float">0.434294</cn>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <cn type="integer">10</cn>
        </apply>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\left({S\over N}|n,s=0,N\right)\approx{1\over N}{{N^{n}\over n}\over N^{n-1}%
\ln(N)}={1\over n[\ln(N)]}={\log_{10}(e)\over n[\log_{10}(N)]}={0.434294\over n%
[\log_{10}(N)]}
  </annotation>
 </semantics>
</math>

</p>

<p>where the base 10 <a class="uri" href="logarithm" title="wikilink">logarithm</a> has been used in the final answer for ease of calculation. For instance if the population is of size <em>10</em><sup><em>k</em></sup> then probability of success on the next sample is given by:</p>

<p>

<math display="block" id="Rule_of_succession:34">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mi>S</mi>
     <mi>N</mi>
    </mfrac>
    <mo>∣</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo>=</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi>N</mi>
    <mo>=</mo>
    <msup>
     <mn>10</mn>
     <mi>k</mi>
    </msup>
    <mo>)</mo>
   </mrow>
   <mo>≈</mo>
   <mfrac>
    <mn>0.434294</mn>
    <mrow>
     <mi>n</mi>
     <mi>k</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <divide></divide>
      <ci>S</ci>
      <ci>N</ci>
     </apply>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">s</csymbol>
     <eq></eq>
     <cn type="integer">0</cn>
     <ci>normal-,</ci>
     <csymbol cd="unknown">N</csymbol>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">10</cn>
      <ci>k</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <approx></approx>
    <apply>
     <divide></divide>
     <cn type="float">0.434294</cn>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\left({S\over N}\mid n,s=0,N=10^{k}\right)\approx{0.434294\over nk}
  </annotation>
 </semantics>
</math>

</p>

<p>So for example, if the population be on the order of tens of billions, so that <em>k</em> = 10, and we observe <em>n</em> = 10 results without success, then the expected proportion in the population is approximately 0.43%. If the population is smaller, so that <em>n</em> = 10, <em>k</em> = 5 (tens of thousands), the expected proportion rises to approximately 0.86%, and so on. Similarly, if the number of observations is smaller, so that <em>n</em> = 5, <em>k</em> = 10, the proportion rise to approximately 0.86% again.</p>

<p>This probability has no lower bound, and can be made arbitrarily small for larger and larger choices of <em>N</em>, or <em>k</em>. This means that the probability depends on the size of the population from which one is sampling. In passing to the limit of infinite <em>N</em> (for the simpler analytic properties) we are "throwing away" a piece of very important information. Note that this ignorance relationship only holds as long as only no successes are observed. It is correspondingly revised back to the observed frequency rule 

<math display="inline" id="Rule_of_succession:35">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <mfrac>
    <mi>s</mi>
    <mi>n</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <apply>
     <divide></divide>
     <ci>s</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p={s\over n}
  </annotation>
 </semantics>
</math>

 as soon as one success is observed. The corresponding results are found for the <em>s=n</em> case by switching labels, and then subtracting the probability from 1.</p>
<h2 id="generalization-to-any-number-of-possibilities">Generalization to any number of possibilities</h2>

<p>This section gives a heuristic derivation to that given in <em>Probability Theory: The Logic of Science</em>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>The rule of succession has many different intuitive interpretations, and depending on which intuition one uses, the generalisation may be different. Thus, the way to proceed from here is very carefully, and to re-derive the results from first principles, rather than to introduce an intuitively sensible generalisation. The full derivation can be found in Jaynes' book, but it does admit an easier to understand alternative derivation, once the solution is known. Another point to emphasise is that the prior state of knowledge described by the rule of succession is given as an enumeration of the possibilities, with the additional information that it is possible to observe each category. This can be equivalently stated as observing each category once prior to gathering the data. To denote that this is the knowledge used, an <em>I</em><sub><em>m</em></sub> is put as part of the conditions in the probability assignments.</p>

<p>The rule of succession comes from setting a binomial likelihood, and a uniform prior distribution. Thus a straight forward generalisation is just the multivariate extensions of these two distributions: 1)Setting a uniform prior over the initial m categories, and 2) using the <a href="multinomial_distribution" title="wikilink">multinomial distribution</a> as the likelihood function (which is the multivariate generalisation of the binomial distribution). It can be shown that the uniform distribution is a special case of the <a href="Dirichlet_distribution" title="wikilink">Dirichlet distribution</a> with all of its parameters equal to 1 (just as the uniform is Beta(1,1) in the binary case). The Dirichlet distribution is the <a href="conjugate_prior" title="wikilink">conjugate prior</a> for the multinomial distribution, which means that the posterior distribution is also a Dirichlet distribution with different parameters. Let <em>p</em><sub><em>i</em></sub> denote the probability that category <em>i</em> will be observed, and let <em>n</em><sub><em>i</em></sub> denote the number of times category <em>i</em> (<em>i</em> = 1, ..., <em>m</em>) actually was observed. Then the joint posterior distribution of the probabilities <em>p</em><sub>1</sub>, ..., <em>p</em><sub><em>m</em></sub> is given by;</p>

<p>

<math display="block" id="Rule_of_succession:36">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>p</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>p</mi>
     <mi>m</mi>
    </msub>
    <mo>∣</mo>
    <msub>
     <mi>n</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>n</mi>
     <mi>m</mi>
    </msub>
    <mo>,</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mfrac>
          <mrow>
           <mi mathvariant="normal">Γ</mi>
           <mrow>
            <mo>(</mo>
            <mrow>
             <msubsup>
              <mo largeop="true" symmetric="true">∑</mo>
              <mrow>
               <mi>i</mi>
               <mo>=</mo>
               <mn>1</mn>
              </mrow>
              <mi>m</mi>
             </msubsup>
             <mrow>
              <mo stretchy="false">(</mo>
              <mrow>
               <msub>
                <mi>n</mi>
                <mi>i</mi>
               </msub>
               <mo>+</mo>
               <mn>1</mn>
              </mrow>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo>)</mo>
           </mrow>
          </mrow>
          <mrow>
           <msubsup>
            <mo largeop="true" symmetric="true">∏</mo>
            <mrow>
             <mi>i</mi>
             <mo>=</mo>
             <mn>1</mn>
            </mrow>
            <mi>m</mi>
           </msubsup>
           <mrow>
            <mi mathvariant="normal">Γ</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <msub>
               <mi>n</mi>
               <mi>i</mi>
              </msub>
              <mo>+</mo>
              <mn>1</mn>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mrow>
         </mfrac>
         <msubsup>
          <mi>p</mi>
          <mn>1</mn>
          <msub>
           <mi>n</mi>
           <mn>1</mn>
          </msub>
         </msubsup>
         <mi mathvariant="normal">⋯</mi>
         <msubsup>
          <mi>p</mi>
          <mi>m</mi>
          <msub>
           <mi>n</mi>
           <mi>m</mi>
          </msub>
         </msubsup>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mstyle displaystyle="false">
          <msubsup>
           <mo largeop="true" symmetric="true">∑</mo>
           <mrow>
            <mi>i</mi>
            <mo>=</mo>
            <mn>1</mn>
           </mrow>
           <mi>m</mi>
          </msubsup>
         </mstyle>
         <msub>
          <mi>p</mi>
          <mi>i</mi>
         </msub>
        </mrow>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mi></mi>
      </mtd>
      <mtd></mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise.</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>m</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>m</ci>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>normal-Γ</ci>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>i</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <ci>m</ci>
         </apply>
         <apply>
          <plus></plus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>n</ci>
           <ci>i</ci>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <csymbol cd="latexml">product</csymbol>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>m</ci>
        </apply>
        <apply>
         <times></times>
         <ci>normal-Γ</ci>
         <apply>
          <plus></plus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>n</ci>
           <ci>i</ci>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <csymbol cd="latexml">absent</csymbol>
     <mtext>otherwise</mtext>
     <cn type="integer">0</cn>
     <mtext>otherwise.</mtext>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(p_{1},\ldots,p_{m}\mid n_{1},\ldots,n_{m},I)=\begin{cases}{\displaystyle%
\frac{\Gamma\left(\sum_{i=1}^{m}(n_{i}+1)\right)}{\prod_{i=1}^{m}\Gamma(n_{i}+%
1)}p_{1}^{n_{1}}\cdots p_{m}^{n_{m}}},&\sum_{i=1}^{m}p_{i}=1\\
\\
0&\text{otherwise.}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>To get the generalised rule of succession, note that the probability of observing category <em>i</em> on the next observation, conditional on the <em>p</em><sub><em>i</em></sub> is just <em>p</em><sub><em>i</em></sub>, we simply require its expectation. Letting <em>A</em><sub><em>i</em></sub> denote the event that the next observation is in category <em>i</em> (<em>i</em> = 1, ..., <em>m</em>), and let <em>n</em> = <em>n</em><sub>1</sub> + ... + <em>n</em><sub><em>m</em></sub> be the total number of observations made. The result, using the properties of the dirichlet distribution is:</p>

<p>

<math display="block" id="Rule_of_succession:37">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>n</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>n</mi>
     <mi>m</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>I</mi>
     <mi>m</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>n</mi>
      <mi>i</mi>
     </msub>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mi>m</mi>
    </mrow>
   </mfrac>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>m</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>m</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>i</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(A_{i}|n_{1},\ldots,n_{m},I_{m})={n_{i}+1\over n+m}.
  </annotation>
 </semantics>
</math>

</p>

<p>This solution reduces to the probability that would be assigned using the principle of indifference before any observations made (i.e. <em>n</em> = 0), consistent with the original rule of succession. It also contains the rule of succession as a special case, when <em>m</em> = 2, as a generalisation should.</p>

<p>Because the propositions or events <em>A</em><sub><em>i</em></sub> are mutually exclusive, it is possible to collapse the <em>m</em> categories into 2. Simply add up the <em>A</em><sub><em>i</em></sub> probabilities that correspond to "success" to get the probability of success. Supposing that this aggregates <em>c</em> categories as "success" and <em>m-c</em> categories as "failure". Let <em>s</em> denote the sum of the relevant <em>n</em><sub>i</sub> values that have been termed "success". The probability of "success" at the next trial is then:</p>

<p>

<math display="block" id="Rule_of_succession:38">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mtext>success</mtext>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>n</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>n</mi>
     <mi>m</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>I</mi>
     <mi>m</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>s</mi>
     <mo>+</mo>
     <mi>c</mi>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mi>m</mi>
    </mrow>
   </mfrac>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>success</mtext>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>m</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>m</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <ci>s</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\text{success}|n_{1},\ldots,n_{m},I_{m})={s+c\over n+m},
  </annotation>
 </semantics>
</math>

</p>

<p>which is different from the original rule of succession. But note that the original rule of succession is based on <em>I</em><sub>2</sub>, whereas the generalisation is based on <em>I</em><sub><em>m</em></sub>. This means that the information contained in <em>I</em><sub><em>m</em></sub> is different from that contained in <em>I</em><sub>2</sub>. This indicates that mere knowledge of more than two outcomes we know are possible is relevant information when collapsing these categories down to just two. This illustrates the subtlety in describing the prior information, and why it is important to specify which prior information one is using.</p>
<h2 id="further-analysis">Further analysis</h2>

<p>A good model is essential (i.e., a good compromise between accuracy and practicality). To paraphrase <a class="uri" href="Laplace" title="wikilink">Laplace</a> on the <a href="sunrise_problem" title="wikilink">sunrise problem</a>: Although we have a huge number of samples of the sun rising, there are far better models of the sun than assuming it has a certain probability of rising each day, e.g., simply having a half-life.</p>

<p>Given a good model, it is best to make as many observations as practicable, depending of the expected reliability of prior knowledge, cost of observations, time and resources available, and accuracy required.</p>

<p>One of the most difficult aspects of the rule of succession is not the mathematical formulas, but answering the question: When does the rule of succession apply? In the generalisation section, it was noted very explicitly by adding the prior information <em>I</em><sub>m</sub> into the calculations. Thus, when all that is known about a phenomenon is that there are <em>m</em> known possible outcomes prior to observing any data, only then does the rule of succession apply. If the rule of succession is applied in problems where this does not accurately describe the prior state of knowledge, then it may give counter-intuitive results. This is not because the rule of succession is defective, but that it is effectively answering a different question, based on different prior information.</p>

<p>In principle (see <a href="Cromwell's_rule" title="wikilink">Cromwell's rule</a>), no possibility should have its probability (or its pseudocount) set to zero, since nothing in the physical world should be assumed strictly impossible (though it may be)—even if contrary to all observations and current theories. Indeed, <a href="Bayes_rule" title="wikilink">Bayes rule</a> takes ''absolutely '' no account of an observation previously believed to have zero probability—it is still declared impossible. However, only considering the a fixed set of the possibilities is an acceptable route, one just needs to remember that the results are conditional on (or restricted to) the set being considered, and not some "universal" set. In fact Larry Bretthorst <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> shows that including the possibility of "something else" into the hypothesis space makes no difference to the relative probabilities of the other hypothesis - it simply renormalises them to add up to a value less than 1. Until "something else" is specified, the likelihood function conditional on this "something else" is indeterminate, for how is one to determine 

<math display="inline" id="Rule_of_succession:39">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mtext>data</mtext>
    <mo stretchy="false">|</mo>
    <mtext>something else</mtext>
    <mo>,</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>data</mtext>
     <ci>normal-|</ci>
     <mtext>something else</mtext>
     <ci>normal-,</ci>
     <csymbol cd="unknown">I</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Pr(\text{data}|\text{something else},I)
  </annotation>
 </semantics>
</math>

?. Thus no updating of the prior probability for "something else" can occur until it is more accurately defined.</p>

<p>However, it is sometimes debatable whether prior knowledge should affect the relative probabilities, or also the total weight of the prior knowledge compared to actual observations. This does not have a clear cut answer, for it depends on what prior knowledge one is considering. In fact, an alternative prior state of knowledge could be of the form "I have specified <em>m</em> potential categories, but I am sure that only one of them is possible prior to observing the data. However, I do not know which particular category this is." A mathematical way to describe this prior is the dirichlet distribution with all parameters equal to <em>m</em><sup>−1</sup>, which then gives a pseudocount of <em>1</em> to the denominator instead of <em>m</em>, and adds a pseudocount of <em>m</em><sup>−1</sup> to each category. This gives a slightly different probability in the binary case of 

<math display="inline" id="Rule_of_succession:40">
 <semantics>
  <mfrac>
   <mrow>
    <mi>s</mi>
    <mo>+</mo>
    <mn>0.5</mn>
   </mrow>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <plus></plus>
     <ci>s</ci>
     <cn type="float">0.5</cn>
    </apply>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{s+0.5}{n+1}
  </annotation>
 </semantics>
</math>

.</p>

<p>Prior probabilities are only worth spending significant effort estimating when likely to have significant effect. They may be important when there are few observations — especially when so few that there have been few, if any, observations of some possibilities – such as a rare animal, in a given region. Also important when there are many observations, where it is believed that the expectation should be heavily weighted towards the prior estimates, in spite of many observations to the contrary, such as for a roulette wheel in a well-respected casino. In the latter case, at least some of the <a href="pseudocount" title="wikilink">pseudocounts</a> may need to be very large. They are not always small, and thereby soon outweighed by actual observations, as is often assumed. However, although a last resort, for everyday purposes, prior knowledge is usually vital. So most decisions must be subjective to some extent (dependent upon the analyst and analysis used).</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Additive_smoothing" title="wikilink">Additive smoothing</a></li>
<li><a href="Krichevsky–Trofimov_estimator" title="wikilink">Krichevsky–Trofimov estimator</a></li>
<li><a href="Principle_of_indifference" title="wikilink">Principle of indifference</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Probability_assessment" title="wikilink">Category:Probability assessment</a> <a href="Category:Inductive_reasoning" title="wikilink">Category:Inductive reasoning</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Laplace, Pierre-Simon (1814). Essai philosophique sur les probabilités. Paris: Courcier.<a href="#fnref1">↩</a></li>
<li id="fn2">; here: p.86, 97<a href="#fnref2">↩</a></li>
<li id="fn3">; here: p.145<a href="#fnref3">↩</a></li>
<li id="fn4"><a class="uri" href="http://www.stats.org.uk/priors/noninformative/Smith.pdf">http://www.stats.org.uk/priors/noninformative/Smith.pdf</a><a href="#fnref4">↩</a></li>
<li id="fn5">Jaynes, E.T. (2003), Probability Theory: The Logic of Science, Cambridge, UK, Cambridge University Press.<a href="#fnref5">↩</a></li>
<li id="fn6">Page 55 – G. Larry Bretthost. Bayesian Spectrum Analysis and parameter estimation. PhD thesis 1988. available at <a class="uri" href="http://bayes.wustl.edu/glb/book.pdf">http://bayes.wustl.edu/glb/book.pdf</a><a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
