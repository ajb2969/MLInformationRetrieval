<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="395">BL (logic)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>BL (logic)</h1>
<hr/>

<p><strong>Basic fuzzy Logic</strong> (or shortly <strong>BL</strong>), the logic of <a href="continuous_function" title="wikilink">continuous</a> <a href="t-norm" title="wikilink">t-norms</a>, is one of <a href="t-norm_fuzzy_logics" title="wikilink">t-norm fuzzy logics</a>. It belongs to the broader class of <a href="substructural_logic" title="wikilink">substructural logics</a>, or logics of <a href="residuated_lattice" title="wikilink">residuated lattices</a>;<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> it extends the logic of all left-continuous t-norms <a href="Monoidal_t-norm_logic" title="wikilink">MTL</a>.</p>
<h2 id="syntax">Syntax</h2>
<h3 id="language">Language</h3>

<p>The language of the propositional logic BL consists of <a href="countable" title="wikilink">countably</a> many <a href="propositional_variable" title="wikilink">propositional variables</a> and the following primitive <a href="logical_connective" title="wikilink">logical connectives</a>:</p>
<ul>
<li><strong>Implication</strong> 

<math display="inline" id="BL_(logic):0">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow
  </annotation>
 </semantics>
</math>

 (<a href="arity" title="wikilink">binary</a>)</li>
<li><strong>Strong conjunction</strong> 

<math display="inline" id="BL_(logic):1">
 <semantics>
  <mo>⊗</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">tensor-product</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \otimes
  </annotation>
 </semantics>
</math>

 (binary). The sign &amp; is a more traditional notation for strong conjunction in the literature on fuzzy logic, while the notation 

<math display="inline" id="BL_(logic):2">
 <semantics>
  <mo>⊗</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">tensor-product</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \otimes
  </annotation>
 </semantics>
</math>

 follows the tradition of substructural logics.</li>
<li><strong>Bottom</strong> 

<math display="inline" id="BL_(logic):3">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>


 (<a class="uri" href="nullary" title="wikilink">nullary</a> — a <a href="propositional_constant" title="wikilink">propositional constant</a>); 

<math display="inline" id="BL_(logic):4">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 or 

<math display="inline" id="BL_(logic):5">
 <semantics>
  <mover accent="true">
   <mn>0</mn>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{0}
  </annotation>
 </semantics>
</math>

 are common alternative signs and <strong>zero</strong> a common alternative name for the propositional constant (as the constants bottom and zero of substructural logics coincide in MTL).</li>
</ul>

<p>The following are the most common defined logical connectives:</p>
<ul>
<li><strong>Weak conjunction</strong> 

<math display="inline" id="BL_(logic):6">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>

 (binary), also called <strong>lattice conjunction</strong> (as it is always realized by the <a href="lattice_(order)" title="wikilink">lattice</a> operation of <a href="meet_(mathematics)" title="wikilink">meet</a> in algebraic semantics). Unlike <a href="Monoidal_t-norm_logic" title="wikilink">MTL</a> and weaker substructural logics, weak conjunction is definable in BL as</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="BL_(logic):7">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∧</mo>
   <mi>B</mi>
   <mo>≡</mo>
   <mi>A</mi>
   <mo>⊗</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <and></and>
    <csymbol cd="unknown">B</csymbol>
    <equivalent></equivalent>
    <csymbol cd="unknown">A</csymbol>
    <csymbol cd="latexml">tensor-product</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\wedge B\equiv A\otimes(A\rightarrow B)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li><strong>Negation</strong> 

<math display="inline" id="BL_(logic):8">
 <semantics>
  <mi mathvariant="normal">¬</mi>
  <annotation-xml encoding="MathML-Content">
   <not></not>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg
  </annotation>
 </semantics>
</math>


 (<a href="unary_operation" title="wikilink">unary</a>), defined as</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="BL_(logic):9">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>A</mi>
   </mrow>
   <mo>≡</mo>
   <mi>A</mi>
   <mo>→</mo>
   <mo>⊥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <times></times>
      <not></not>
      <ci>A</ci>
     </apply>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <csymbol cd="latexml">bottom</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg A\equiv A\rightarrow\bot
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li><strong>Equivalence</strong> 

<math display="inline" id="BL_(logic):10">
 <semantics>
  <mo>↔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftrightarrow
  </annotation>
 </semantics>
</math>

 (binary), defined as</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="BL_(logic):11">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>↔</mo>
   <mi>B</mi>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>→</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-↔</ci>
    <csymbol cd="unknown">B</csymbol>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\leftrightarrow B\equiv(A\rightarrow B)\wedge(B\rightarrow A)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>As in MTL, the definition is equivalent to 

<math display="inline" id="BL_(logic):12">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊗</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>→</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">tensor-product</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\rightarrow B)\otimes(B\rightarrow A).
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<ul>
<li><strong>(Weak) disjunction</strong> 

<math display="inline" id="BL_(logic):13">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vee
  </annotation>
 </semantics>
</math>


 (binary), also called <strong>lattice disjunction</strong> (as it is always realized by the <a href="lattice_(order)" title="wikilink">lattice</a> operation of <a href="join_(mathematics)" title="wikilink">join</a> in algebraic semantics), defined as</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="BL_(logic):14">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∨</mo>
   <mi>B</mi>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>→</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo>→</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <or></or>
    <csymbol cd="unknown">B</csymbol>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\vee B\equiv((A\rightarrow B)\rightarrow B)\wedge((B\rightarrow A)\rightarrow
A)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li><strong>Top</strong> 

<math display="inline" id="BL_(logic):15">
 <semantics>
  <mo>⊤</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">top</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \top
  </annotation>
 </semantics>
</math>

 (nullary), also called <strong>one</strong> and denoted by 

<math display="inline" id="BL_(logic):16">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="BL_(logic):17">
 <semantics>
  <mover accent="true">
   <mn>1</mn>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{1}
  </annotation>
 </semantics>
</math>

 (as the constants top and zero of substructural logics coincide in MTL), defined as</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="BL_(logic):18">
 <semantics>
  <mrow>
   <mo>⊤</mo>
   <mo>≡</mo>
   <mo>⊥</mo>
   <mo>→</mo>
   <mo>⊥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <csymbol cd="latexml">top</csymbol>
    <equivalent></equivalent>
    <csymbol cd="latexml">bottom</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="latexml">bottom</csymbol>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \top\equiv\bot\rightarrow\bot
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>

<p><a href="Well-formed_formula" title="wikilink">Well-formed formulae</a> of BL are defined as usual in <a href="propositional_logic" title="wikilink">propositional logics</a>. In order to save parentheses, it is common to use the following order of precedence:</p>
<ul>
<li>Unary connectives (bind most closely)</li>
<li>Binary connectives other than implication and equivalence</li>
<li>Implication and equivalence (bind most loosely)</li>
</ul>
<h3 id="axioms">Axioms</h3>

<p>A <a href="Hilbert-style_deduction_system" title="wikilink">Hilbert-style deduction system</a> for BL has been introduced by <a href="Petr_Hájek" title="wikilink">Petr Hájek</a> (1998). Its single derivation rule is <a href="modus_ponens" title="wikilink">modus ponens</a>:</p>
<dl>
<dd>from 

<math display="inline" id="BL_(logic):19">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="BL_(logic):20">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\rightarrow B
  </annotation>
 </semantics>
</math>

 derive 

<math display="inline" id="BL_(logic):21">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B.
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>The following are its <a href="axiom_scheme" title="wikilink">axiom schemata</a>:</p>

<p>

<math display="block" id="BL_(logic):22">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>BL1</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>→</mo>
       <mi>B</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>→</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>B</mi>
        <mo>→</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>→</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo>→</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>BL2</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi>A</mi>
       <mo>⊗</mo>
       <mi>B</mi>
      </mrow>
      <mo>→</mo>
      <mi>A</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>BL3</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi>A</mi>
       <mo>⊗</mo>
       <mi>B</mi>
      </mrow>
      <mo>→</mo>
      <mrow>
       <mi>B</mi>
       <mo>⊗</mo>
       <mi>A</mi>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>BL4</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>A</mi>
      <mo>⊗</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>→</mo>
       <mi>B</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>→</mo>
      <mi>B</mi>
      <mo>⊗</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>B</mi>
       <mo>→</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>BL5a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>→</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>B</mi>
        <mo>→</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>→</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>⊗</mo>
       <mi>B</mi>
       <mo>→</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>BL5b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>⊗</mo>
       <mi>B</mi>
       <mo>→</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>→</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>→</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>B</mi>
        <mo>→</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>BL6</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo>→</mo>
        <mi>B</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>→</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>→</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>B</mi>
         <mo>→</mo>
         <mi>A</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>→</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>→</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>BL7</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>⊥</mo>
      <mo>→</mo>
      <mi>A</mi>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <ci>BL1</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">B</csymbol>
        <ci>normal-→</ci>
        <csymbol cd="unknown">C</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-→</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">A</csymbol>
        <ci>normal-→</ci>
        <csymbol cd="unknown">C</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <ci>BL2</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
      <ci>A</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <ci>BL3</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>B</ci>
       <ci>A</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <ci>BL4</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">A</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <csymbol cd="unknown">B</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <ci>BL5a</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-→</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">B</csymbol>
        <ci>normal-→</ci>
        <csymbol cd="unknown">C</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">C</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <ci>BL5b</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">C</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-→</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">B</csymbol>
        <ci>normal-→</ci>
        <csymbol cd="unknown">C</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <ci>BL6</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">A</csymbol>
        <ci>normal-→</ci>
        <csymbol cd="unknown">B</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-→</ci>
       <csymbol cd="unknown">C</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">B</csymbol>
         <ci>normal-→</ci>
         <csymbol cd="unknown">A</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-→</ci>
        <csymbol cd="unknown">C</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-→</ci>
       <csymbol cd="unknown">C</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <ci>BL7</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="latexml">bottom</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">A</csymbol>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{ll}{\rm(BL1)}\colon&(A\rightarrow B)\rightarrow((B\rightarrow C%
)\rightarrow(A\rightarrow C))\\
{\rm(BL2)}\colon&A\otimes B\rightarrow A\\
{\rm(BL3)}\colon&A\otimes B\rightarrow B\otimes A\\
{\rm(BL4)}\colon&A\otimes(A\rightarrow B)\rightarrow B\otimes(B\rightarrow A)%
\\
{\rm(BL5a)}\colon&(A\rightarrow(B\rightarrow C))\rightarrow(A\otimes B%
\rightarrow C)\\
{\rm(BL5b)}\colon&(A\otimes B\rightarrow C)\rightarrow(A\rightarrow(B%
\rightarrow C))\\
{\rm(BL6)}\colon&((A\rightarrow B)\rightarrow C)\rightarrow(((B\rightarrow A)%
\rightarrow C)\rightarrow C)\\
{\rm(BL7)}\colon&\bot\rightarrow A\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>The axioms (BL2) and (BL3) of the original axiomatic system were shown to be redundant (Chvalovský, 2012) and (Cintula, 2005). All the other axioms were shown to be independent (Chvalovský, 2012).</p>
<h2 id="semantics">Semantics</h2>

<p>Like in other propositional <a href="t-norm_fuzzy_logics" title="wikilink">t-norm fuzzy logics</a>, <a href="algebraic_semantics_(mathematical_logic)" title="wikilink">algebraic semantics</a> is predominantly used for BL, with three main classes of <a href="algebraic_structure" title="wikilink">algebras</a> with respect to which the logic is <a href="Completeness_(logic)" title="wikilink">complete</a>:</p>
<ul>
<li><strong>General semantics</strong>, formed of all <em>BL-algebras</em> — that is, all algebras for which the logic is <a href="Soundness_theorem" title="wikilink">sound</a></li>
<li><strong>Linear semantics</strong>, formed of all <em>linear</em> BL-algebras — that is, all BL-algebras whose <a href="lattice_(order)" title="wikilink">lattice</a> order is <a href="total_order" title="wikilink">linear</a></li>
<li><strong>Standard semantics</strong>, formed of all <em>standard</em> BL-algebras — that is, all BL-algebras whose lattice reduct is the real unit interval [0, 1] with the usual order; they are uniquely determined by the function that interprets strong conjunction, which can be any continuous <a class="uri" href="t-norm" title="wikilink">t-norm</a></li>
</ul>
<h2 id="bibliography">Bibliography</h2>
<ul>
<li>Hájek P., 1998, <em>Metamathematics of Fuzzy Logic</em>. Dordrecht: Kluwer.</li>
<li>Ono, H., 2003, "Substructural logics and residuated lattices — an introduction". In F.V. Hendricks, J. Malinowski (eds.): Trends in Logic: 50 Years of Studia Logica, <em>Trends in Logic</em> <strong>20</strong>: 177–212.</li>
<li>Cintula P., 2005, "Short note: On the redundancy of axiom (A3) in BL and MTL". <em>Soft Computing</em> <strong>9</strong>: 942.</li>
<li>Chvalovský K., 2012, "<a href="http://karel.chvalovsky.cz/publications/nezavislost.pdf">On the Independence of Axioms in BL and MTL</a>". <em>Fuzzy Sets and Systems</em> <strong>197</strong>: 123–129, .</li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Fuzzy_logic" title="wikilink">Category:Fuzzy logic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Ono (2003).<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
