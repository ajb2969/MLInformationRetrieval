<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1785">Computing the permanent</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Computing the permanent</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the <strong>computation of the <a class="uri" href="permanent" title="wikilink">permanent</a> of a <a href="matrix_(mathematics)" title="wikilink">matrix</a></strong> is a problem that is known to be more difficult than the computation of the <a class="uri" href="determinant" title="wikilink">determinant</a> of a matrix despite the apparent similarity of the definitions.</p>

<p>The permanent is defined similarly to the determinant, as a sum of products of sets of matrix entries that lie in distinct rows and columns. However, where the determinant weights each of these products with a ±1 sign based on the <a href="Parity_of_a_permutation" title="wikilink">parity of the set</a>, the permanent weights them all with a +1 sign.</p>

<p>While the determinant can be computed in <a href="polynomial_time" title="wikilink">polynomial time</a> by <a href="Gaussian_elimination" title="wikilink">Gaussian elimination</a>, the permanent cannot. In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, <a href="Permanent_is_sharp-P-complete" title="wikilink">a theorem of Valiant</a> states that computing permanents is <a href="sharp-P-complete" title="wikilink">#P-hard</a>, and even <a href="sharp-P-complete" title="wikilink">#P-complete</a> for matrices in which all entries are 0 or 1. This puts the computation of the permanent in a class of problems believed to be even more difficult to compute than <a href="NP_(complexity)" title="wikilink">NP</a>. It is known that computing the permanent is impossible for logspace-uniform <a href="ACC0" title="wikilink">ACC<sup>0</sup></a> circuits.</p>

<p>The development of both exact and approximate algorithms for computing the permanent of a matrix is an active area of research.</p>
<h2 id="definition-and-naive-algorithm">Definition and naive algorithm</h2>

<p>The permanent of an <em>n</em>-by-<em>n</em> matrix <em>A</em> = (<em>a</em><sub><em>i,j</em></sub>) is defined as</p>

<p>

<math display="block" id="Computing_the_permanent:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>perm</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>σ</mi>
       <mo>∈</mo>
       <msub>
        <mi>S</mi>
        <mi>n</mi>
       </msub>
      </mrow>
     </munder>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <msub>
       <mi>a</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mrow>
         <mi>σ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>i</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>perm</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>σ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <list>
        <ci>i</ci>
        <apply>
         <times></times>
         <ci>σ</ci>
         <ci>i</ci>
        </apply>
       </list>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{perm}(A)=\sum_{\sigma\in S_{n}}\prod_{i=1}^{n}a_{i,\sigma(i)}.
  </annotation>
 </semantics>
</math>

</p>

<p>The sum here extends over all elements σ of the <a href="symmetric_group" title="wikilink">symmetric group</a> <em>S</em><sub><em>n</em></sub>, i.e. over all <a href="permutation" title="wikilink">permutations</a> of the numbers 1, 2, ..., <em>n</em>. This formula differs from the corresponding formula for the determinant only in that, in the determinant, each product is multiplied by the <a href="Parity_of_a_permutation" title="wikilink">sign of the permutation</a> σ while in this formula each product is unsigned. The formula may be directly translated into an algorithm that naively expands the formula, summing over all permutations and within the sum multiplying out each matrix entry. This requires <em>n!</em> <em>n</em> arithmetic operations.</p>
<h2 id="ryser-formula">Ryser formula</h2>

<p>The best known<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> general exact algorithm is due to . Ryser’s method is based on an <a href="inclusion-exclusion_principle" title="wikilink">inclusion–exclusion</a> formula that can be given<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> as follows: Let 

<math display="inline" id="Computing_the_permanent:1">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{k}
  </annotation>
 </semantics>
</math>

 be obtained from <em>A</em> by deleting <em>k</em> columns, let 

<math display="inline" id="Computing_the_permanent:2">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>A</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(A_{k})
  </annotation>
 </semantics>
</math>

 be the product of the row-sums of 

<math display="inline" id="Computing_the_permanent:3">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{k}
  </annotation>
 </semantics>
</math>

, and let 

<math display="inline" id="Computing_the_permanent:4">
 <semantics>
  <msub>
   <mi mathvariant="normal">Σ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Σ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{k}
  </annotation>
 </semantics>
</math>

 be the sum of the values of 

<math display="inline" id="Computing_the_permanent:5">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>A</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(A_{k})
  </annotation>
 </semantics>
</math>

 over all possible 

<math display="inline" id="Computing_the_permanent:6">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{k}
  </annotation>
 </semantics>
</math>

. Then</p>

<p>

<math display="block" id="Computing_the_permanent:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>perm</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </munderover>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>k</mi>
      </msup>
      <msub>
       <mi mathvariant="normal">Σ</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>perm</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Σ</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{perm}(A)=\sum_{k=0}^{n-1}(-1)^{k}\Sigma_{k}.
  </annotation>
 </semantics>
</math>

</p>

<p>It may be rewritten in terms of the matrix entries as follows<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>

<math display="block" id="Computing_the_permanent:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>perm</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>n</mi>
     </msup>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>S</mi>
        <mo>⊆</mo>
        <mrow>
         <mo stretchy="false">{</mo>
         <mn>1</mn>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo>,</mo>
         <mi>n</mi>
         <mo stretchy="false">}</mo>
        </mrow>
       </mrow>
      </munder>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo stretchy="false">|</mo>
         <mi>S</mi>
         <mo stretchy="false">|</mo>
        </mrow>
       </msup>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>n</mi>
        </munderover>
        <mrow>
         <munder>
          <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
          <mrow>
           <mi>j</mi>
           <mo>∈</mo>
           <mi>S</mi>
          </mrow>
         </munder>
         <msub>
          <mi>a</mi>
          <mrow>
           <mi>i</mi>
           <mi>j</mi>
          </mrow>
         </msub>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>perm</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <subset></subset>
        <ci>S</ci>
        <set>
         <cn type="integer">1</cn>
         <ci>normal-…</ci>
         <ci>n</ci>
        </set>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <abs></abs>
         <ci>S</ci>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <csymbol cd="latexml">product</csymbol>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <in></in>
           <ci>j</ci>
           <ci>S</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <apply>
           <times></times>
           <ci>i</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{perm}(A)=(-1)^{n}\sum_{S\subseteq\{1,\dots,n\}}(-1)^{|S|}\prod_{%
i=1}^{n}\sum_{j\in S}a_{ij}.
  </annotation>
 </semantics>
</math>

</p>

<p>Ryser’s formula can be evaluated using 

<math display="inline" id="Computing_the_permanent:9">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>n</mi>
     </msup>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(2^{n}n^{2})
  </annotation>
 </semantics>
</math>

 arithmetic operations, or 

<math display="inline" id="Computing_the_permanent:10">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>n</mi>
     </msup>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(2^{n}n)
  </annotation>
 </semantics>
</math>

 by processing the sets 

<math display="inline" id="Computing_the_permanent:11">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 in <a href="Gray_code" title="wikilink">Gray code</a> order.</p>
<h2 id="balasubramanian-baxfranklin-glynn-formula">Balasubramanian-Bax/Franklin-Glynn formula</h2>

<p>Another formula that appears to be as fast as Ryser's (or perhaps even twice as fast) is to be found in the two Ph.D. theses; see , ; also . The methods to find the formula are quite different, being related to the combinatorics of the Muir algebra, and to finite difference theory respectively. Another way, connected with invariant theory is via the <a href="polarization_identity" title="wikilink">polarization identity</a> for a <a href="symmetric_tensor" title="wikilink">symmetric tensor</a> . The formula generalizes to infinitely many others, as found by all these authors, although it is not clear if they are any faster than the basic one. See .</p>

<p>The simplest known formula of this type (when the characteristic of the field is not two) is</p>

<p>

<math display="block" id="Computing_the_permanent:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>perm</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>[</mo>
      <mrow>
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mi>δ</mi>
       </munder>
       <mrow>
        <mrow>
         <mo>(</mo>
         <mrow>
          <munderover>
           <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
           <mrow>
            <mi>k</mi>
            <mo>=</mo>
            <mn>1</mn>
           </mrow>
           <mi>m</mi>
          </munderover>
          <msub>
           <mi>δ</mi>
           <mi>k</mi>
          </msub>
         </mrow>
         <mo>)</mo>
        </mrow>
        <mrow>
         <munderover>
          <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
          <mrow>
           <mi>j</mi>
           <mo>=</mo>
           <mn>1</mn>
          </mrow>
          <mi>m</mi>
         </munderover>
         <mrow>
          <munderover>
           <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
           <mrow>
            <mi>i</mi>
            <mo>=</mo>
            <mn>1</mn>
           </mrow>
           <mi>m</mi>
          </munderover>
          <mrow>
           <msub>
            <mi>δ</mi>
            <mi>i</mi>
           </msub>
           <msub>
            <mi>a</mi>
            <mrow>
             <mi>i</mi>
             <mi>j</mi>
            </mrow>
           </msub>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo>]</mo>
     </mrow>
     <mo>/</mo>
     <msup>
      <mn>2</mn>
      <mrow>
       <mi>m</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>perm</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>δ</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <csymbol cd="latexml">product</csymbol>
           <apply>
            <eq></eq>
            <ci>k</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <ci>m</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>δ</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <csymbol cd="latexml">product</csymbol>
           <apply>
            <eq></eq>
            <ci>j</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <ci>m</ci>
         </apply>
         <apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <sum></sum>
            <apply>
             <eq></eq>
             <ci>i</ci>
             <cn type="integer">1</cn>
            </apply>
           </apply>
           <ci>m</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>δ</ci>
            <ci>i</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>a</ci>
            <apply>
             <times></times>
             <ci>i</ci>
             <ci>j</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{perm}(A)=\left[\sum_{\delta}\left(\prod_{k=1}^{m}\delta_{k}%
\right)\prod_{j=1}^{m}\sum_{i=1}^{m}\delta_{i}a_{ij}\right]/2^{m-1},
  </annotation>
 </semantics>
</math>

 where the outer sum is over all 

<math display="inline" id="Computing_the_permanent:13">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>m</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <ci>m</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{m-1}
  </annotation>
 </semantics>
</math>

 vectors 

<math display="inline" id="Computing_the_permanent:14">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>δ</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mn>1</mn>
    <mo>,</mo>
    <msub>
     <mi>δ</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>δ</mi>
     <mi>m</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mo>±</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mi>m</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">δ</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <cn type="integer">1</cn>
     </apply>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <ci>m</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <csymbol cd="latexml">plus-or-minus</csymbol>
      <cn type="integer">1</cn>
      <ci>normal-}</ci>
     </cerror>
     <ci>m</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta=(\delta_{1}=1,\delta_{2},\dots,\delta_{m})\in\{\pm 1\}^{m}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="special-cases">Special cases</h2>
<h3 id="planar-and-k33-free">Planar and <em>K</em><sub>3,3</sub>-free</h3>

<p>The number of <a href="perfect_matching" title="wikilink">perfect matchings</a> in a <a href="bipartite_graph" title="wikilink">bipartite graph</a> is counted by the permanent of the graph's <a href="biadjacency_matrix" title="wikilink">biadjacency matrix</a>, and the permanent of any 0-1 matrix can be <a href="Permanent#Perfect_matchings" title="wikilink">interpreted in this way</a> as the number of perfect matchings in a graph. For <a href="planar_graph" title="wikilink">planar graphs</a> (regardless of bipartiteness), the <a href="FKT_algorithm" title="wikilink">FKT algorithm</a> computes the number of perfect matchings in polynomial time by changing the signs of a carefully chosen subset of the entries in the <a href="Tutte_matrix" title="wikilink">Tutte matrix</a> of the graph, so that the <a class="uri" href="Pfaffian" title="wikilink">Pfaffian</a> of the resulting <a href="skew-symmetric_matrix" title="wikilink">skew-symmetric matrix</a> (the <a href="square_root" title="wikilink">square root</a> of its <a class="uri" href="determinant" title="wikilink">determinant</a>) is the number of perfect matchings. This technique can be generalized to graphs that contain no subgraph <a href="homeomorphism_(graph_theory)" title="wikilink">homeomorphic</a> to the <a href="complete_bipartite_graph" title="wikilink">complete bipartite graph</a> <em>K</em><sub>3,3</sub>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p><a href="George_Pólya" title="wikilink">George Pólya</a> had asked the question<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> of when it is possible to change the signs of some of the entries of a 01 matrix A so that the determinant of the new matrix is the permanent of A. Not all 01 matrices are "convertible" in this manner; in fact it is known () that there is no linear map 

<math display="inline" id="Computing_the_permanent:15">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Computing_the_permanent:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo rspace="4.2pt">per</mo>
     <mi>T</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>det</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>per</ci>
      <ci>T</ci>
     </apply>
     <ci>A</ci>
    </apply>
    <apply>
     <determinant></determinant>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{per}\,T(A)=\det A
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Computing_the_permanent:17">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times n
  </annotation>
 </semantics>
</math>

 matrices 

<math display="inline" id="Computing_the_permanent:18">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. The characterization of "convertible" matrices was given by  who showed that such matrices are precisely those that are the <a href="biadjacency_matrix" title="wikilink">biadjacency matrix</a> of bipartite graphs that have a <a href="Pfaffian_orientation" title="wikilink">Pfaffian orientation</a>: an orientation of the edges such that for every even cycle 

<math display="inline" id="Computing_the_permanent:19">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 for which 

<math display="inline" id="Computing_the_permanent:20">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>∖</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <setdiff></setdiff>
    <ci>G</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\setminus C
  </annotation>
 </semantics>
</math>

 has a perfect matching, there are an odd number of edges directed along C (and thus an odd number with the opposite orientation). It was also shown that these graphs are exactly those that do not contain a subgraph homeomorphic to 

<math display="inline" id="Computing_the_permanent:21">
 <semantics>
  <msub>
   <mi>K</mi>
   <mrow>
    <mn>3</mn>
    <mo>,</mo>
    <mn>3</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <list>
     <cn type="integer">3</cn>
     <cn type="integer">3</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{3,3}
  </annotation>
 </semantics>
</math>

, as above.</p>
<h3 id="computation-modulo-a-number">Computation modulo a number</h3>

<p><a href="modular_arithmetic" title="wikilink">Modulo</a> 2, the permanent is the same as the determinant, as 

<math display="inline" id="Computing_the_permanent:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mn>1</mn>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (-1)\equiv 1\;\;(\mathop{{\rm mod}}2).
  </annotation>
 </semantics>
</math>

 It can also be computed modulo 

<math display="inline" id="Computing_the_permanent:23">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{k}
  </annotation>
 </semantics>
</math>

 in time 

<math display="inline" id="Computing_the_permanent:24">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mrow>
      <mrow>
       <mn>4</mn>
       <mi>k</mi>
      </mrow>
      <mo>-</mo>
      <mn>3</mn>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">4</cn>
       <ci>k</ci>
      </apply>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{4k-3})
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Computing_the_permanent:25">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>≥</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>k</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\geq 2
  </annotation>
 </semantics>
</math>

. However, it is <a href="UP_(complexity)" title="wikilink">UP-hard</a> to compute the permanent modulo any number that is not a power of 2. </p>

<p>There are various formulae given by  for the computation modulo a prime 

<math display="inline" id="Computing_the_permanent:26">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

. Firstly there is one using symbolic calculations with partial derivatives.</p>

<p>Secondly, for 

<math display="inline" id="Computing_the_permanent:27">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=3
  </annotation>
 </semantics>
</math>

 there is the following formula (Grigoriy Kogan, 1996) using the determinants of the principal submatrices of the matrix:</p>

<p>

<math display="block" id="Computing_the_permanent:28">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>perm</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>m</mi>
      </msup>
      <msub>
       <mi mathvariant="normal">Σ</mi>
       <mrow>
        <mi>U</mi>
        <mo>⊆</mo>
        <mrow>
         <mo stretchy="false">{</mo>
         <mn>1</mn>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo>,</mo>
         <mi>m</mi>
         <mo stretchy="false">}</mo>
        </mrow>
       </mrow>
      </msub>
      <mrow>
       <mo movablelimits="false">det</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>A</mi>
         <mi>U</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>.</mo>
    <mrow>
     <mo movablelimits="false">det</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>A</mi>
       <mover accent="true">
        <mi>U</mi>
        <mo stretchy="false">¯</mo>
       </mover>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <ci>perm</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Σ</ci>
       <apply>
        <subset></subset>
        <ci>U</ci>
        <set>
         <cn type="integer">1</cn>
         <ci>normal-…</ci>
         <ci>m</ci>
        </set>
       </apply>
      </apply>
      <apply>
       <determinant></determinant>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>U</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <determinant></determinant>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>U</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{perm}(A)=(-1)^{m}\Sigma_{U\subseteq\{1,\dots,m\}}\det(A_{U}).%
\det(A_{\bar{U}}),
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Computing_the_permanent:29">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>U</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{U}
  </annotation>
 </semantics>
</math>

 is the principal submatrix of 

<math display="inline" id="Computing_the_permanent:30">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 induced by the rows and columns of 

<math display="inline" id="Computing_the_permanent:31">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 indexed by 

<math display="inline" id="Computing_the_permanent:32">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Computing_the_permanent:33">
 <semantics>
  <mover accent="true">
   <mi>U</mi>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{U}
  </annotation>
 </semantics>
</math>

 is the complement of 

<math display="inline" id="Computing_the_permanent:34">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Computing_the_permanent:35">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>m</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">1</cn>
    <ci>normal-…</ci>
    <ci>m</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{1,\dots,m\}.
  </annotation>
 </semantics>
</math>

</p>

<p>(The determinant of an empty submatrix is defined to be 1).</p>

<p>This formula implies the following identities over fields of Characteristic 3 (Grigoriy Kogan, 1996):</p>

<p>for any invertible 

<math display="inline" id="Computing_the_permanent:36">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Computing_the_permanent:37">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>perm</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>A</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo movablelimits="false">det</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>perm</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>perm</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <determinant></determinant>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>perm</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{perm}(A^{-1})\det(A)^{2}=\operatorname{perm}(A)
  </annotation>
 </semantics>
</math>

; for any unitary 

<math display="inline" id="Computing_the_permanent:38">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 , i.e. a square matrix 

<math display="inline" id="Computing_the_permanent:39">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Computing_the_permanent:40">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>U</mi>
     <mi>T</mi>
    </msup>
    <mi>U</mi>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mi>I</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>U</ci>
      <ci>T</ci>
     </apply>
     <ci>U</ci>
    </apply>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U^{T}U=I\,
  </annotation>
 </semantics>
</math>

 ,</p>

<p>

<math display="block" id="Computing_the_permanent:41">
 <semantics>
  <mrow>
   <mo>perm</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>U</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mo movablelimits="false">det</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>U</mi>
    <mo>+</mo>
    <mi>V</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo movablelimits="false">det</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>U</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>perm</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">U</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cn type="integer">2</cn>
    </apply>
    <eq></eq>
    <determinant></determinant>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">U</csymbol>
     <plus></plus>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <determinant></determinant>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">U</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{perm}(U)^{2}=\det(U+V)\det(U)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Computing_the_permanent:42">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is the matrix whose entries are the cubes of the corresponding entries of 

<math display="inline" id="Computing_the_permanent:43">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="approximate-computation">Approximate computation</h2>

<p>When the entries of <em>A</em> are nonnegative, the permanent can be computed <a href="approximation_algorithm" title="wikilink">approximately</a> in <a href="randomized_algorithm" title="wikilink">probabilistic</a> polynomial time, up to an error of ε<em>M</em>, where <em>M</em> is the value of the permanent and ε &gt; 0 is arbitrary. In other words, there exists a <a href="fully_polynomial-time_randomized_approximation_scheme" title="wikilink">fully polynomial-time randomized approximation scheme</a> (FPRAS) ().</p>

<p>The most difficult step in the computation is the construction of an algorithm to <a href="Sampling_(statistics)" title="wikilink">sample</a> almost <a href="Uniform_distribution_(discrete)" title="wikilink">uniformly</a> from the set of all perfect matchings in a given bipartite graph: in other words, a fully polynomial almost uniform sampler (FPAUS). This can be done using a <a href="Markov_chain_Monte_Carlo" title="wikilink">Markov chain Monte Carlo</a> algorithm that uses a <a href="Metropolis–Hastings_algorithm" title="wikilink">Metropolis rule</a> to define and run a <a href="Markov_chain" title="wikilink">Markov chain</a> whose distribution is close to uniform, and whose <a href="Markov_chain_mixing_time" title="wikilink">mixing time</a> is polynomial.</p>

<p>It is possible to approximately count the number of perfect matchings in a graph via the <a href="Random_self-reducibility" title="wikilink">self-reducibility</a> of the permanent, by using the FPAUS in combination with a well-known reduction from sampling to counting due to . Let 

<math display="inline" id="Computing_the_permanent:44">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M(G)
  </annotation>
 </semantics>
</math>

 denote the number of perfect matchings in 

<math display="inline" id="Computing_the_permanent:45">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

. Roughly, for any particular edge 

<math display="inline" id="Computing_the_permanent:46">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Computing_the_permanent:47">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, by sampling many matchings in 

<math display="inline" id="Computing_the_permanent:48">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 and counting how many of them are matchings in 

<math display="inline" id="Computing_the_permanent:49">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>∖</mo>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <setdiff></setdiff>
    <ci>G</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\setminus e
  </annotation>
 </semantics>
</math>

, one can obtain an estimate of the ratio 

<math display="inline" id="Computing_the_permanent:50">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>M</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>G</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>M</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>G</mi>
       <mo>∖</mo>
       <mi>e</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ρ</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>G</ci>
     </apply>
     <apply>
      <times></times>
      <ci>M</ci>
      <apply>
       <setdiff></setdiff>
       <ci>G</ci>
       <ci>e</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho=\frac{M(G)}{M(G\setminus e)}
  </annotation>
 </semantics>
</math>

. The number 

<math display="inline" id="Computing_the_permanent:51">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M(G)
  </annotation>
 </semantics>
</math>

 is then 

<math display="inline" id="Computing_the_permanent:52">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mi>M</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>G</mi>
     <mo>∖</mo>
     <mi>e</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ρ</ci>
    <ci>M</ci>
    <apply>
     <setdiff></setdiff>
     <ci>G</ci>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho M(G\setminus e)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Computing_the_permanent:53">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>G</mi>
     <mo>∖</mo>
     <mi>e</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <apply>
     <setdiff></setdiff>
     <ci>G</ci>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M(G\setminus e)
  </annotation>
 </semantics>
</math>

 can be approximated by applying the same method recursively.</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Computational_complexity_theory" title="wikilink">Category:Computational complexity theory</a> <a href="Category:Linear_algebra" title="wikilink">Category:Linear algebra</a> <a href="Category:Matrix_theory" title="wikilink">Category:Matrix theory</a> <a class="uri" href="Category:Permutations" title="wikilink">Category:Permutations</a> <a href="Category:Computational_problems" title="wikilink">Category:Computational problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">As of 2008, see <a href="#fnref1">↩</a></li>
<li id="fn2"> [<a class="uri" href="http://books.google.com/books?id=5l5ps2JkyT0C&amp;pg">http://books.google.com/books?id=5l5ps2JkyT0C&amp;pg;</a>;=PA108&amp;dq;=permanent+ryser&amp;lr;=#PPA99,M1 p. 99]<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">, <a href="#fnref4">↩</a></li>
<li id="fn5">, <a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
