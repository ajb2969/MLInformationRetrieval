<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1718">Diffusion map</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Diffusion map</h1>
<hr>'''Diffusion maps''' is a [[dimensionality reduction]] or [[feature extraction]] algorithm introduced by [[Ronald Coifman|R. R. Coifman]] and 
<p>S. Lafon.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> It computes a family of embeddings of a data set into Euclidean space (often low-dimensional) whose coordinates can be computed from the eigenvectors and eigenvalues of a diffusion operator on the data. The Euclidean distance between points in the embedded space is equal to the "diffusion distance" between probability distributions centered at those points. Different from linear dimensionality reduction methods such as <a href="principal_component_analysis" title="wikilink">principal component analysis</a> (PCA) and <a href="multi-dimensional_scaling" title="wikilink">multi-dimensional scaling</a> (MDS), diffusion maps is part of the family of <a href="nonlinear_dimensionality_reduction" title="wikilink">nonlinear dimensionality reduction</a> methods which focus on discovering the underlying <a class="uri" href="manifold" title="wikilink">manifold</a> that the data has been sampled from. By integrating local similarities at different scales, diffusion maps gives a global description of the data-set. Compared with other methods, the diffusion maps algorithm is robust to noise perturbation and is computationally inexpensive.</p>
<h2 id="definition-of-diffusion-maps">Definition of diffusion maps</h2>

<p>Following <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> and,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> diffusion maps can be defined in four steps.</p>
<h3 id="connectivity">Connectivity</h3>

<p>Diffusion maps exploit the relationship between <a href="heat_diffusion" title="wikilink">heat diffusion</a> and random walk <a href="Markov_chain" title="wikilink">Markov chain</a>. The basic observation is that if we take a random walk on the data, walking to a nearby data-point is more likely than walking to another that is far away. Let 

<math display="inline" id="Diffusion_map:0">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>X</mi>
   <mo>,</mo>
   <mi class="ltx_font_mathcaligraphic">ùíú</mi>
   <mo>,</mo>
   <mi>Œº</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>X</ci>
    <ci>ùíú</ci>
    <ci>Œº</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (X,\mathcal{A},\mu)
  </annotation>
 </semantics>
</math>

 be a measure space, where 

<math display="inline" id="Diffusion_map:1">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is the data set and 

<math display="inline" id="Diffusion_map:2">
 <semantics>
  <mi>Œº</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œº</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 represents the distribution on the points on 

<math display="inline" id="Diffusion_map:3">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

.</p>

<p>Based on this, the connectivity 

<math display="inline" id="Diffusion_map:4">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 between two data points, 

<math display="inline" id="Diffusion_map:5">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Diffusion_map:6">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

, can be defined as the probability of walking from 

<math display="inline" id="Diffusion_map:7">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Diffusion_map:8">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 in one step of the random walk. Usually, this probability is specified in terms of kernel function on the two points

<math display="block" id="Diffusion_map:9">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mo>√ó</mo>
     <mi>X</mi>
    </mrow>
    <mo>‚Üí</mo>
    <mi>‚Ñù</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>k</ci>
    <apply>
     <ci>normal-‚Üí</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>X</ci>
     </apply>
     <ci>‚Ñù</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k:X\times X\rightarrow\mathbb{R}
  </annotation>
 </semantics>
</math>

. For example, the popular Gaussian kernel:</p>

<p>

<math display="block" id="Diffusion_map:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <mfrac>
      <msup>
       <mrow>
        <mo fence="true">||</mo>
        <mrow>
         <mi>x</mi>
         <mo>-</mo>
         <mi>y</mi>
        </mrow>
        <mo fence="true">||</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mi>œµ</mi>
     </mfrac>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <minus></minus>
          <ci>x</ci>
          <ci>y</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>œµ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(x,y)=e^{-\frac{||x-y||^{2}}{\epsilon}}
  </annotation>
 </semantics>
</math>

</p>

<p>More generally, the <a href="Integral_kernel" title="wikilink">kernel</a> function has the following properties</p>

<p>

<math display="block" id="Diffusion_map:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <ci>y</ci>
      <ci>x</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(x,y)=k(y,x)
  </annotation>
 </semantics>
</math>

 (

<math display="inline" id="Diffusion_map:12">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is symmetric)</p>

<p>

<math display="block" id="Diffusion_map:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚â•</mo>
   <mrow>
    <mrow>
     <mpadded width="+3.4pt">
      <mn>0</mn>
     </mpadded>
     <mrow>
      <mo>‚àÄ</mo>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <list>
     <apply>
      <times></times>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>y</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(x,y)\geq 0\,\,\forall x,y
  </annotation>
 </semantics>
</math>

 (

<math display="inline" id="Diffusion_map:14">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is positivity preserving).</p>

<p>The kernel constitutes the prior definition of the <em>local</em> geometry of data-set. Since a given kernel will capture a specific feature of the data set, its choice should be guided by the application that one has in mind. This is a major difference with methods such as <a href="principal_component_analysis" title="wikilink">principal component analysis</a>, where correlations between all data points are taken into account at once.</p>

<p>Given 

<math display="inline" id="Diffusion_map:15">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>X</mi>
   <mo>,</mo>
   <mi>k</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>X</ci>
    <ci>k</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (X,k)
  </annotation>
 </semantics>
</math>

, we can then construct a reversible Markov chain on 

<math display="inline" id="Diffusion_map:16">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 (a process known as the normalized graph Laplacian construction):</p>

<p>

<math display="block" id="Diffusion_map:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">‚à´</mo>
     <mi>X</mi>
    </msub>
    <mrow>
     <mi>k</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>Œº</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <ci>k</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
      <ci>d</ci>
      <ci>Œº</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(x)=\int_{X}k(x,y)d\mu(y)
  </annotation>
 </semantics>
</math>

</p>

<p>and define:</p>

<p>

<math display="block" id="Diffusion_map:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>k</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>k</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x,y)=\frac{k(x,y)}{d(x)}
  </annotation>
 </semantics>
</math>

</p>

<p>Although the new normalized kernel does not inherit the symmetric property, it does inherit the positivity-preserving property and gains a conservation property:</p>

<p>

<math display="block" id="Diffusion_map:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">‚à´</mo>
     <mi>X</mi>
    </msub>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>Œº</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <ci>p</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
      <ci>d</ci>
      <ci>Œº</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{X}p(x,y)d\mu(y)=1
  </annotation>
 </semantics>
</math>

</p>
<h3 id="diffusion-process">Diffusion process</h3>

<p>From 

<math display="inline" id="Diffusion_map:20">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x,y)
  </annotation>
 </semantics>
</math>

 we can construct a transition matrix of a Markov chain (

<math display="inline" id="Diffusion_map:21">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

) on 

<math display="inline" id="Diffusion_map:22">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

. In other words, 

<math display="inline" id="Diffusion_map:23">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x,y)
  </annotation>
 </semantics>
</math>

 represents the one-step transition probability from 

<math display="inline" id="Diffusion_map:24">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Diffusion_map:25">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Diffusion_map:26">
 <semantics>
  <msup>
   <mi>M</mi>
   <mi>t</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>M</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M^{t}
  </annotation>
 </semantics>
</math>

 gives the t-step transition matrix.</p>

<p>We define the diffusion matrix 

<math display="inline" id="Diffusion_map:27">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 (it is also a version of graph Laplacian matrix)</p>

<p>

<math display="block" id="Diffusion_map:28">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>j</mi>
     </msub>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <list>
      <ci>i</ci>
      <ci>j</ci>
     </list>
    </apply>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{i,j}=k(x_{i},x_{j})\,
  </annotation>
 </semantics>
</math>

</p>

<p>We then define the new kernel</p>

<p>

<math display="block" id="Diffusion_map:29">
 <semantics>
  <mrow>
   <msubsup>
    <mi>L</mi>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Œ±</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>k</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Œ±</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mfrac>
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mi>j</mi>
      </mrow>
     </msub>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>d</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>d</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>j</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>Œ±</mi>
     </msup>
    </mfrac>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>L</ci>
       <ci>Œ±</ci>
      </apply>
      <list>
       <ci>i</ci>
       <ci>j</ci>
      </list>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>k</ci>
       <ci>Œ±</ci>
      </apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <list>
        <ci>i</ci>
        <ci>j</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <ci>d</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <ci>d</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>Œ±</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{(\alpha)}_{i,j}=k^{(\alpha)}(x_{i},x_{j})=\frac{L_{i,j}}{(d(x_{i})d(x_{j}))%
^{\alpha}}\,
  </annotation>
 </semantics>
</math>

 or equivalently,</p>

<p>

<math display="block" id="Diffusion_map:30">
 <semantics>
  <mrow>
   <msup>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Œ±</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>D</mi>
     <mrow>
      <mo>-</mo>
      <mi>Œ±</mi>
     </mrow>
    </msup>
    <mi>L</mi>
    <mpadded width="+1.7pt">
     <msup>
      <mi>D</mi>
      <mrow>
       <mo>-</mo>
       <mi>Œ±</mi>
      </mrow>
     </msup>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>L</ci>
     <ci>Œ±</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>D</ci>
      <apply>
       <minus></minus>
       <ci>Œ±</ci>
      </apply>
     </apply>
     <ci>L</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>D</ci>
      <apply>
       <minus></minus>
       <ci>Œ±</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{(\alpha)}=D^{-\alpha}LD^{-\alpha}\,
  </annotation>
 </semantics>
</math>

 where D is a diagonal matrix and 

<math display="inline" id="Diffusion_map:31">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>D</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>i</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mi>j</mi>
     </msub>
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <list>
      <ci>i</ci>
      <ci>i</ci>
     </list>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <list>
       <ci>i</ci>
       <ci>j</ci>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{i,i}=\sum_{j}L_{i,j}.
  </annotation>
 </semantics>
</math>

</p>

<p>We apply the graph Laplacian normalization to this new kernel:</p>

<p>

<math display="block" id="Diffusion_map:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>D</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>Œ±</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <msup>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Œ±</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>D</ci>
       <ci>Œ±</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <ci>Œ±</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=({D}^{(\alpha)})^{-1}L^{(\alpha)},\,
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Diffusion_map:33">
 <semantics>
  <msup>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Œ±</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>D</ci>
    <ci>Œ±</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D^{(\alpha)}
  </annotation>
 </semantics>
</math>

 is a diagonal matrix and 

<math display="inline" id="Diffusion_map:34">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>D</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>i</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Œ±</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mi>j</mi>
     </msub>
     <msubsup>
      <mi>L</mi>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mi>j</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Œ±</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>D</ci>
      <ci>Œ±</ci>
     </apply>
     <list>
      <ci>i</ci>
      <ci>i</ci>
     </list>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>L</ci>
       <ci>Œ±</ci>
      </apply>
      <list>
       <ci>i</ci>
       <ci>j</ci>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {D}^{(\alpha)}_{i,i}=\sum_{j}L^{(\alpha)}_{i,j}.
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Diffusion_map:35">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <msubsup>
     <mi>M</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
     </mrow>
     <mi>t</mi>
    </msubsup>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>M</ci>
      <ci>t</ci>
     </apply>
     <list>
      <ci>i</ci>
      <ci>j</ci>
     </list>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x_{j},t|x_{i})=M^{t}_{i,j}\,
  </annotation>
 </semantics>
</math>

</p>

<p>One of the main ideas of diffusion framework is that running the chain forward in time (taking larger and larger powers of 

<math display="inline" id="Diffusion_map:36">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

) reveals the geometric structure of 

<math display="inline" id="Diffusion_map:37">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 at larger and larger scales (the diffusion process). Specifically, the notion of a <em>cluster</em> in the data set is quantified as a region in which the probability of escaping this region is low (within a certain time t). Therefore, t not only serves as a time parameter, but also has the dual role of scale parameter.</p>

<p>The eigendecomposition of the matrix 

<math display="inline" id="Diffusion_map:38">
 <semantics>
  <msup>
   <mi>M</mi>
   <mi>t</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>M</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M^{t}
  </annotation>
 </semantics>
</math>

 yields</p>

<p>

<math display="block" id="Diffusion_map:39">
 <semantics>
  <mrow>
   <msubsup>
    <mi>M</mi>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
    </mrow>
    <mi>t</mi>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
     <mi>l</mi>
    </munder>
    <mrow>
     <msubsup>
      <mi>Œª</mi>
      <mi>l</mi>
      <mi>t</mi>
     </msubsup>
     <msub>
      <mi>œà</mi>
      <mi>l</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>œï</mi>
      <mi>l</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>M</ci>
      <ci>t</ci>
     </apply>
     <list>
      <ci>i</ci>
      <ci>j</ci>
     </list>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>l</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Œª</ci>
        <ci>l</ci>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>œà</ci>
       <ci>l</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>œï</ci>
       <ci>l</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M^{t}_{i,j}=\sum_{l}\lambda_{l}^{t}\psi_{l}(x_{i})\phi_{l}(x_{j})\,
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Diffusion_map:40">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>Œª</mi>
    <mi>l</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Œª</ci>
     <ci>l</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\lambda_{l}\}
  </annotation>
 </semantics>
</math>

 is the sequence of eigenvalues of 

<math display="inline" id="Diffusion_map:41">
 <semantics>
  <msup>
   <mi>M</mi>
   <mi>t</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>M</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M^{t}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Diffusion_map:42">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>œà</mi>
    <mi>l</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>œà</ci>
     <ci>l</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\psi_{l}\}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Diffusion_map:43">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>œï</mi>
    <mi>l</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>œï</ci>
     <ci>l</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\phi_{l}\}
  </annotation>
 </semantics>
</math>

 are the biorthogonal right and left eigenvectors respectively. Due to the spectrum decay of the eigenvalues, only a few terms are necessary to achieve a given relative accuracy in this sum.</p>
<h4 id="parameter-alpha-and-the-diffusion-operator">Parameter 

<math display="inline" id="Diffusion_map:44">
 <semantics>
  <mi>Œ±</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ±</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 and the Diffusion Operator</h4>

<p>The reason to introduce the normalization step involving 

<math display="inline" id="Diffusion_map:45">
 <semantics>
  <mi>Œ±</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ±</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is to tune the influence of the data point density on the infinitesimal transition of the diffusion. In some applications, the sampling of the data is generally not related to the geometry of the manifold we are interested in describing. In this case, we can set 

<math display="inline" id="Diffusion_map:46">
 <semantics>
  <mrow>
   <mi>Œ±</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Œ±</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=1
  </annotation>
 </semantics>
</math>

 and the diffusion operator approximates the Laplace‚ÄìBeltrami operator. We then recover the Riemannian geometry of the data set regardless of the distribution of the points. To describe the long-term behavior of the point distribution of a system of stochastic differential equations, we can use 

<math display="inline" id="Diffusion_map:47">
 <semantics>
  <mrow>
   <mi>Œ±</mi>
   <mo>=</mo>
   <mn>0.5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Œ±</ci>
    <cn type="float">0.5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=0.5
  </annotation>
 </semantics>
</math>

 and the resulting Markov chain approximates the Fokker-Planck diffusion. With 

<math display="inline" id="Diffusion_map:48">
 <semantics>
  <mrow>
   <mi>Œ±</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Œ±</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=0
  </annotation>
 </semantics>
</math>

, it reduces to the classical graph Laplacian normalization.</p>
<h3 id="diffusion-distance">Diffusion distance</h3>

<p>The diffusion distance at time 

<math display="inline" id="Diffusion_map:49">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 between two points can be measured as the similarity of two points in the observation space with the connectivity between them. It is given by</p>

<p>

<math display="block" id="Diffusion_map:50">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>D</mi>
     <mi>t</mi>
    </msub>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
     <mi>y</mi>
    </munder>
    <mfrac>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo>,</mo>
        <mi>t</mi>
        <mo stretchy="false">|</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>-</mo>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo>,</mo>
        <mi>t</mi>
        <mo stretchy="false">|</mo>
        <msub>
         <mi>x</mi>
         <mi>j</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mrow>
      <msub>
       <mi>œï</mi>
       <mn>0</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
      </interval>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>y</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">p</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">y</csymbol>
         <ci>normal-,</ci>
         <csymbol cd="unknown">t</csymbol>
         <ci>normal-|</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
         <ci>normal-)</ci>
        </cerror>
        <minus></minus>
        <csymbol cd="unknown">p</csymbol>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">y</csymbol>
         <ci>normal-,</ci>
         <csymbol cd="unknown">t</csymbol>
         <ci>normal-|</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>j</ci>
         </apply>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-)</ci>
       </cerror>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>œï</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{t}(x_{i},x_{j})^{2}=\sum_{y}\frac{(p(y,t|x_{i})-p(y,t|x_{j}))^{2}}{\phi_{0}%
(y)}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Diffusion_map:51">
 <semantics>
  <mrow>
   <msub>
    <mi>œï</mi>
    <mn>0</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>œï</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{0}(y)
  </annotation>
 </semantics>
</math>

 is the stationary distribution of the Markov chain, given by the first left eigenvector of 

<math display="inline" id="Diffusion_map:52">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

. Explicitly:</p>

<p>

<math display="block" id="Diffusion_map:53">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>œï</mi>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>z</mi>
       <mo>‚àà</mo>
       <mi>X</mi>
      </mrow>
     </msub>
     <mrow>
      <mi>d</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>œï</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>y</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>z</ci>
        <ci>X</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{0}(y)=\frac{d(y)}{\sum_{z\in X}d(z)}
  </annotation>
 </semantics>
</math>

 Intuitively, 

<math display="inline" id="Diffusion_map:54">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mi>t</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>t</ci>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{t}(x_{i},x_{j})
  </annotation>
 </semantics>
</math>

 is small if there is a large number of short paths connecting 

<math display="inline" id="Diffusion_map:55">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Diffusion_map:56">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}
  </annotation>
 </semantics>
</math>

. There are several interesting features associated with the diffusion distance, based on our previous discussion that 

<math display="inline" id="Diffusion_map:57">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 also serves as a scale parameter:</p>
<ol>
<li>Points are closer at a given scale (as specified by 

<math display="inline" id="Diffusion_map:58">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mi>t</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>t</ci>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{t}(x_{i},x_{j})
  </annotation>
 </semantics>
</math>

) if they are highly connected in the graph, therefore emphasizing the concept of a cluster.</li>
<li>This distance is robust to noise, since the distance between two points depends on all possible paths of length 

<math display="inline" id="Diffusion_map:59">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 between the points.</li>
<li>From a machine learning point of view, the distance takes into account all evidences linking 

<math display="inline" id="Diffusion_map:60">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Diffusion_map:61">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}
  </annotation>
 </semantics>
</math>

, allowing us to conclude that this distance is appropriate for the design of inference algorithms based on the majority of preponderance.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></li>
</ol>
<h3 id="diffusion-process-and-low-dimensional-embedding">Diffusion process and low-dimensional embedding</h3>

<p>The diffusion distance can be calculated using the eigenvectors by</p>

<p>

<math display="block" id="Diffusion_map:62">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>D</mi>
     <mi>t</mi>
    </msub>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
     <mi>l</mi>
    </munder>
    <mrow>
     <msubsup>
      <mi>Œª</mi>
      <mi>l</mi>
      <mrow>
       <mn>2</mn>
       <mi>t</mi>
      </mrow>
     </msubsup>
     <mpadded width="+1.7pt">
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <msub>
           <mi>œà</mi>
           <mi>l</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>x</mi>
            <mi>i</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mrow>
          <msub>
           <mi>œà</mi>
           <mi>l</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>x</mi>
            <mi>j</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mpadded>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
      </interval>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>l</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Œª</ci>
        <ci>l</ci>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>œà</ci>
          <ci>l</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>œà</ci>
          <ci>l</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{t}(x_{i},x_{j})^{2}=\sum_{l}\lambda_{l}^{2t}(\psi_{l}(x_{i})-\psi_{l}(x_{j}%
))^{2}\,
  </annotation>
 </semantics>
</math>

</p>

<p>So the eigenvectors can be used as a new set of coordinates for the data. The diffusion map is defined as:</p>

<p>

<math display="block" id="Diffusion_map:63">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Œ®</mi>
     <mi>t</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msubsup>
      <mi>Œª</mi>
      <mn>1</mn>
      <mi>t</mi>
     </msubsup>
     <msub>
      <mi>œà</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msubsup>
      <mi>Œª</mi>
      <mn>2</mn>
      <mi>t</mi>
     </msubsup>
     <msub>
      <mi>œà</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <mrow>
     <msubsup>
      <mi>Œª</mi>
      <mi>k</mi>
      <mi>t</mi>
     </msubsup>
     <msub>
      <mi>œà</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Œ®</ci>
      <ci>t</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <vector>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Œª</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>œà</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Œª</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>œà</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>x</ci>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Œª</ci>
        <ci>k</ci>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>œà</ci>
       <ci>k</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi_{t}(x)=(\lambda_{1}^{t}\psi_{1}(x),\lambda_{2}^{t}\psi_{2}(x),\ldots,%
\lambda_{k}^{t}\psi_{k}(x))
  </annotation>
 </semantics>
</math>

</p>

<p>Because of the spectrum decay, it is sufficient to use only the first <em>k</em> eigenvectors and eigenvalues. Thus we get the diffusion map from the original data to a <em>k</em>-dimensional space which is embedded in the original space.</p>

<p>In,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> it is proved that</p>

<p>

<math display="block" id="Diffusion_map:64">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>D</mi>
     <mi>t</mi>
    </msub>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <msup>
     <mrow>
      <mo fence="true">||</mo>
      <mrow>
       <mrow>
        <msub>
         <mi mathvariant="normal">Œ®</mi>
         <mi>t</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi mathvariant="normal">Œ®</mi>
         <mi>t</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>j</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo fence="true">||</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
      </interval>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-Œ®</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-Œ®</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{t}(x_{i},x_{j})^{2}=||\Psi_{t}(x_{i})-\Psi_{t}(x_{j})||^{2}\,
  </annotation>
 </semantics>
</math>

 so the Euclidean distance in the diffusion coordinates approximates the diffusion distance.</p>
<h2 id="algorithm">Algorithm</h2>

<p>The basic algorithm framework of diffusion map is as:</p>

<p>Step 1. Given the similarity matrix <em>L</em></p>

<p>Step 2. Normalize the matrix according to parameter 

<math display="inline" id="Diffusion_map:65">
 <semantics>
  <mi>Œ±</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ±</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>



<math display="block" id="Diffusion_map:66">
 <semantics>
  <mrow>
   <msup>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Œ±</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>D</mi>
     <mrow>
      <mo>-</mo>
      <mi>Œ±</mi>
     </mrow>
    </msup>
    <mi>L</mi>
    <msup>
     <mi>D</mi>
     <mrow>
      <mo>-</mo>
      <mi>Œ±</mi>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>L</ci>
     <ci>Œ±</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>D</ci>
      <apply>
       <minus></minus>
       <ci>Œ±</ci>
      </apply>
     </apply>
     <ci>L</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>D</ci>
      <apply>
       <minus></minus>
       <ci>Œ±</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{(\alpha)}=D^{-\alpha}LD^{-\alpha}
  </annotation>
 </semantics>
</math>

</p>

<p>Step 3. Form the normalized matrix 

<math display="inline" id="Diffusion_map:67">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>D</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>Œ±</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <msup>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Œ±</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>D</ci>
       <ci>Œ±</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <ci>Œ±</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=({D}^{(\alpha)})^{-1}L^{(\alpha)}
  </annotation>
 </semantics>
</math>

</p>

<p>Step 4. Compute the <em>k</em> largest eigenvalues of 

<math display="inline" id="Diffusion_map:68">
 <semantics>
  <msup>
   <mi>M</mi>
   <mi>t</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>M</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M^{t}
  </annotation>
 </semantics>
</math>

 and the corresponding eigenvectors</p>

<p>Step 5. Use diffusion map to get the embedding 

<math display="inline" id="Diffusion_map:69">
 <semantics>
  <msub>
   <mi mathvariant="normal">Œ®</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Œ®</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi_{t}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="application">Application</h2>

<p>In the paper,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> they showed how to design a kernel that reproduces the diffusion induced by a <a href="Fokker-Planck_equation" title="wikilink">Fokker-Planck equation</a>. Also, they explained that when the data approximate a manifold, then one can recover the geometry of this manifold by computing an approximation of the <a href="Laplace-Beltrami_operator" title="wikilink">Laplace-Beltrami operator</a>. This computation is completely insensitive to the distribution of the points and therefore provides a separation of the statistics and the geometry of the data. Since Diffusion map gives a global description of the data-set, it can measure the distances between pair of sample points in the manifold the data is embedded. Based on diffusion map, there are many applications, such as spectral clustering, low dimensional representation of images, image segmentation,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> 3D model segmentation,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> speaker identification,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> sampling on manifolds,anomaly detection,<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> image inpainting,<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> and so on.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Nonlinear_dimensionality_reduction" title="wikilink">Nonlinear dimensionality reduction</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Machine_learning_algorithms" title="wikilink">Category:Machine learning algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
</ol>
</section>
</hr></body>
</html>
