<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="156">Space hierarchy theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Space hierarchy theorem</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, the <strong>space hierarchy theorems</strong> are separation results that show that both deterministic and nondeterministic machines can solve more problems in (asymptotically) more space, subject to certain conditions. For example, a <a href="deterministic_Turing_machine" title="wikilink">deterministic Turing machine</a> can solve more <a href="decision_problem" title="wikilink">decision problems</a> in space <em>n</em> log <em>n</em> than in space <em>n</em>. The somewhat weaker analogous theorems for time are the <a href="time_hierarchy_theorem" title="wikilink">time hierarchy theorems</a>.</p>

<p>The foundation for the hierarchy theorems lies in the intuition that with either more time or more space comes the ability to compute more functions (or decide more languages). The hierarchy theorems are used to demonstrate that the time and space complexity classes form a hierarchy where classes with tighter bounds contain fewer languages than those with more relaxed bounds. Here we define and prove the space hierarchy theorem.</p>

<p>The space hierarchy theorems rely on the concept of <a href="space-constructible_function" title="wikilink">space-constructible functions</a>. The deterministic and nondeterministic space hierarchy theorems state that for all space-constructible functions <em>f</em>(<em>n</em>),</p>

<p>

<math display="block" id="Space_hierarchy_theorem:0">
 <semantics>
  <mrow>
   <mrow>
    <mo>SPACE</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>o</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>⊊</mo>
   <mrow>
    <mo>SPACE</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <prsubset></prsubset>
    <apply>
     <ci>SPACE</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>SPACE</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{SPACE}\left(o(f(n))\right)\subsetneq\operatorname{SPACE}(f(n))
  </annotation>
 </semantics>
</math>

, where SPACE stands for either <a class="uri" href="DSPACE" title="wikilink">DSPACE</a> or <a class="uri" href="NSPACE" title="wikilink">NSPACE</a>, and 

<math display="inline" id="Space_hierarchy_theorem:1">
 <semantics>
  <mi>o</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>o</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o
  </annotation>
 </semantics>
</math>

 refers to the <a href="little_o" title="wikilink">little o</a> notation.</p>
<h2 id="statement">Statement</h2>

<p>Formally, a function 

<math display="inline" id="Space_hierarchy_theorem:2">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>ℕ</mi>
    <mo>⟶</mo>
    <mi>ℕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-⟶</ci>
     <ci>ℕ</ci>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\mathbb{N}\longrightarrow\mathbb{N}
  </annotation>
 </semantics>
</math>

 is space-constructible if 

<math display="inline" id="Space_hierarchy_theorem:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mpadded width="+3.3pt">
     <mi>log</mi>
    </mpadded>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)\geq\log~{}n
  </annotation>
 </semantics>
</math>

 and there exists a Turing machine which computes the function 

<math display="inline" id="Space_hierarchy_theorem:4">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)
  </annotation>
 </semantics>
</math>

 in space 

<math display="inline" id="Space_hierarchy_theorem:5">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(f(n))
  </annotation>
 </semantics>
</math>

 when starting with an input 

<math display="inline" id="Space_hierarchy_theorem:6">
 <semantics>
  <msup>
   <mn>1</mn>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">1</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1^{n}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Space_hierarchy_theorem:7">
 <semantics>
  <msup>
   <mn>1</mn>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">1</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1^{n}
  </annotation>
 </semantics>
</math>

 represents a string of 

<math display="inline" id="Space_hierarchy_theorem:8">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Space_hierarchy_theorem:9">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

s. Most of the common functions that we work with are space-constructible, including polynomials, exponents, and logarithms.</p>

<p>For every space-constructible function 

<math display="inline" id="Space_hierarchy_theorem:10">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>ℕ</mi>
    <mo>⟶</mo>
    <mi>ℕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-⟶</ci>
     <ci>ℕ</ci>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\mathbb{N}\longrightarrow\mathbb{N}
  </annotation>
 </semantics>
</math>

, there exists a language 

<math display="inline" id="Space_hierarchy_theorem:11">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 that is decidable in space 

<math display="inline" id="Space_hierarchy_theorem:12">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(f(n))
  </annotation>
 </semantics>
</math>

 but not in space 

<math display="inline" id="Space_hierarchy_theorem:13">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o(f(n))
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="proof">Proof</h2>

<p>The goal here is to define a language that can be decided in space 

<math display="inline" id="Space_hierarchy_theorem:14">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(f(n))
  </annotation>
 </semantics>
</math>

 but not space 

<math display="inline" id="Space_hierarchy_theorem:15">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o(f(n))
  </annotation>
 </semantics>
</math>

. Here we define the language 

<math display="inline" id="Space_hierarchy_theorem:16">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

:</p>
<blockquote>

<p>

<math display="inline" id="Space_hierarchy_theorem:17">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mo rspace="5.8pt" stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>M</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>,</mo>
     <msup>
      <mn>10</mn>
      <mi>k</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>:</mo>
    <mi>M</mi>
    <mtext>does not accept</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>M</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>,</mo>
     <msup>
      <mn>10</mn>
      <mi>k</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mtext>using space</mtext>
    <mo>≤</mo>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo stretchy="false">|</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>M</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>,</mo>
     <msup>
      <mn>10</mn>
      <mi>k</mi>
     </msup>
     <mo stretchy="false">|</mo>
     <mo rspace="5.8pt" stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">L</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-⟨</ci>
       <csymbol cd="unknown">M</csymbol>
       <ci>normal-⟩</ci>
      </cerror>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">10</cn>
       <ci>k</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-:</ci>
     <csymbol cd="unknown">M</csymbol>
     <mtext>does not accept</mtext>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-⟨</ci>
       <csymbol cd="unknown">M</csymbol>
       <ci>normal-⟩</ci>
      </cerror>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">10</cn>
       <ci>k</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <mtext>using space</mtext>
     <leq></leq>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <ci>normal-|</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-⟨</ci>
       <csymbol cd="unknown">M</csymbol>
       <ci>normal-⟩</ci>
      </cerror>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">10</cn>
       <ci>k</ci>
      </apply>
      <ci>normal-|</ci>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=\{~{}(\langle M\rangle,10^{k}):M\mbox{ does not accept }(\langle M\rangle,10%
^{k})\mbox{ using space }\leq f(|\langle M\rangle,10^{k}|)~{}\}
  </annotation>
 </semantics>
</math>

</p>
</blockquote>

<p>Now, for any machine 

<math display="inline" id="Space_hierarchy_theorem:18">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 that decides a language in space 

<math display="inline" id="Space_hierarchy_theorem:19">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o(f(n))
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Space_hierarchy_theorem:20">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>


 will differ in at least one spot from the language of 

<math display="inline" id="Space_hierarchy_theorem:21">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

, namely at the value of 

<math display="inline" id="Space_hierarchy_theorem:22">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>M</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>,</mo>
   <msup>
    <mn>10</mn>
    <mi>k</mi>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="latexml">delimited-⟨⟩</csymbol>
     <ci>M</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">10</cn>
     <ci>k</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\langle M\rangle,10^{k})
  </annotation>
 </semantics>
</math>

. The algorithm for deciding the language 

<math display="inline" id="Space_hierarchy_theorem:23">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is as follows:</p>
<ol>
<li>On an input 

<math display="inline" id="Space_hierarchy_theorem:24">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, compute 

<math display="inline" id="Space_hierarchy_theorem:25">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>x</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <abs></abs>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(|x|)
  </annotation>
 </semantics>
</math>


 using space-constructibility, and mark off 

<math display="inline" id="Space_hierarchy_theorem:26">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>x</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <abs></abs>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(|x|)
  </annotation>
 </semantics>
</math>

 cells of tape. Whenever an attempt is made to use more than 

<math display="inline" id="Space_hierarchy_theorem:27">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>x</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <abs></abs>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(|x|)
  </annotation>
 </semantics>
</math>

 cells, <em>reject</em>.</li>
<li>If 

<math display="inline" id="Space_hierarchy_theorem:28">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is not of the form 

<math display="inline" id="Space_hierarchy_theorem:29">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>M</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>,</mo>
   <msup>
    <mn>10</mn>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">delimited-⟨⟩</csymbol>
     <ci>M</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">10</cn>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle M\rangle,10^{k}
  </annotation>
 </semantics>
</math>

 for some TM 

<math display="inline" id="Space_hierarchy_theorem:30">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>


, <em>reject</em>.</li>
<li>Simulate 

<math display="inline" id="Space_hierarchy_theorem:31">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 on input 

<math display="inline" id="Space_hierarchy_theorem:32">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 for at most 

<math display="inline" id="Space_hierarchy_theorem:33">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>x</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <abs></abs>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{f(|x|)}
  </annotation>
 </semantics>
</math>

 steps (using 

<math display="inline" id="Space_hierarchy_theorem:34">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>x</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <abs></abs>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(|x|)
  </annotation>
 </semantics>
</math>

 space). If the simulation tries to use more than 

<math display="inline" id="Space_hierarchy_theorem:35">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>x</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <abs></abs>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(|x|)
  </annotation>
 </semantics>
</math>


 space or more than 

<math display="inline" id="Space_hierarchy_theorem:36">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>x</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <abs></abs>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{f(|x|)}
  </annotation>
 </semantics>
</math>

 operations, then <em>reject</em>.</li>
<li>If 

<math display="inline" id="Space_hierarchy_theorem:37">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 accepted 

<math display="inline" id="Space_hierarchy_theorem:38">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 during this simulation, then <em>reject</em>; otherwise, <em>accept</em>.</li>
</ol>

<p>Note on step 3: Execution is limited to 

<math display="inline" id="Space_hierarchy_theorem:39">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>x</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <abs></abs>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{f(|x|)}
  </annotation>
 </semantics>
</math>

 steps in order to avoid the case where 

<math display="inline" id="Space_hierarchy_theorem:40">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>


 does not halt on the input 

<math display="inline" id="Space_hierarchy_theorem:41">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. That is, the case where 

<math display="inline" id="Space_hierarchy_theorem:42">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 consumes space of only 

<math display="inline" id="Space_hierarchy_theorem:43">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(f(x))
  </annotation>
 </semantics>
</math>

 as required, but runs for infinite time.</p>

<p>The above proof holds for the case of PSPACE whereas we must make some change for the case of NPSPACE. The crucial point is that while on a deterministic TM we may easily invert acceptance and rejection (crucial for step 4), this is not possible on a non-deterministic machine.<br/>
For the case of NPSPACE we will first modify step 4 to:</p>
<ol>
<li>If 

<math display="inline" id="Space_hierarchy_theorem:44">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 accepted 

<math display="inline" id="Space_hierarchy_theorem:45">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 during this simulation, then <em>accept</em>; otherwise, <em>reject</em>.</li>
</ol>

<p>We will now prove by contradiction that 

<math display="inline" id="Space_hierarchy_theorem:46">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 can not be decided by a TM using 

<math display="inline" id="Space_hierarchy_theorem:47">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o(f(n))
  </annotation>
 </semantics>
</math>

 cells.<br/>
Assuming 

<math display="inline" id="Space_hierarchy_theorem:48">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 can be decided by a TM using 

<math display="inline" id="Space_hierarchy_theorem:49">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o(f(n))
  </annotation>
 </semantics>
</math>

 cells, and following from the <a href="Immerman–Szelepcsényi_theorem" title="wikilink">Immerman–Szelepcsényi theorem</a> follows that 

<math display="inline" id="Space_hierarchy_theorem:50">
 <semantics>
  <mover accent="true">
   <mi>L</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{L}
  </annotation>
 </semantics>
</math>


 can also be determined by a TM (which we will call 

<math display="inline" id="Space_hierarchy_theorem:51">
 <semantics>
  <mover accent="true">
   <mi>M</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{M}
  </annotation>
 </semantics>
</math>

) using 

<math display="inline" id="Space_hierarchy_theorem:52">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o(f(n))
  </annotation>
 </semantics>
</math>

 cells.<br/>
Here lies the contradiction, therefore our assumption must be false:</p>
<ol>
<li>If 

<math display="inline" id="Space_hierarchy_theorem:53">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mover accent="true">
      <mi>M</mi>
      <mo>¯</mo>
     </mover>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>,</mo>
    <msup>
     <mn>10</mn>
     <mi>k</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>w</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <ci>M</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">10</cn>
      <ci>k</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w=(\langle\overline{M}\rangle,10^{k})
  </annotation>
 </semantics>
</math>

 (for some large enough k) is not in 

<math display="inline" id="Space_hierarchy_theorem:54">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Space_hierarchy_theorem:55">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>


 will accept it, therefore 

<math display="inline" id="Space_hierarchy_theorem:56">
 <semantics>
  <mover accent="true">
   <mi>M</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{M}
  </annotation>
 </semantics>
</math>

 rejects 

<math display="inline" id="Space_hierarchy_theorem:57">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

, therefore 

<math display="inline" id="Space_hierarchy_theorem:58">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 is in 

<math display="inline" id="Space_hierarchy_theorem:59">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 (contradiction).</li>
<li>If 

<math display="inline" id="Space_hierarchy_theorem:60">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mover accent="true">
      <mi>M</mi>
      <mo>¯</mo>
     </mover>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>,</mo>
    <msup>
     <mn>10</mn>
     <mi>k</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>w</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <ci>M</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">10</cn>
      <ci>k</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w=(\langle\overline{M}\rangle,10^{k})
  </annotation>
 </semantics>
</math>


 (for some large enough k) is in 

<math display="inline" id="Space_hierarchy_theorem:61">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Space_hierarchy_theorem:62">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 will reject it, therefore 

<math display="inline" id="Space_hierarchy_theorem:63">
 <semantics>
  <mover accent="true">
   <mi>M</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{M}
  </annotation>
 </semantics>
</math>

 accepts 

<math display="inline" id="Space_hierarchy_theorem:64">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

, therefore 

<math display="inline" id="Space_hierarchy_theorem:65">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>


 is not in 

<math display="inline" id="Space_hierarchy_theorem:66">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 (contradiction).</li>
</ol>
<h2 id="comparison-and-improvements">Comparison and improvements</h2>

<p>The space hierarchy theorem is stronger than the analogous <a href="time_hierarchy_theorem" title="wikilink">time hierarchy theorems</a> in several ways:</p>
<ul>
<li>It only requires s(n) to be at least log <em>n</em> instead of at least <em>n</em>.</li>
<li>It can separate classes with any asymptotic difference, whereas the time hierarchy theorem requires them to be separated by a logarithmic factor.</li>
<li>It only requires the function to be space-constructible, not time-constructible.</li>
</ul>

<p>It seems to be easier to separate classes in space than in time. Indeed, whereas the time hierarchy theorem has seen little remarkable improvement since its inception, the nondeterministic space hierarchy theorem has seen at least one important improvement by Viliam Geffert in his 2003 paper "Space hierarchy theorem revised". This paper made several striking generalizations of the theorem:</p>
<ul>
<li>It relaxes the space-constructibility requirement. Instead of merely separating the union classes <strong>DSPACE</strong>(O(s(n)) and <strong>DSPACE</strong>(o(s(n)), it separates <strong>DSPACE</strong>(f(n)) from <strong>DSPACE</strong>(g(n)) where f(n) is an arbitrary O(s(n)) function and g(n) is a <a href="computable_function" title="wikilink">computable</a> o(s(n)) function. These functions need not be space-constructible or even monotone increasing.</li>
<li>It identifies a <a href="unary_language" title="wikilink">unary language</a>, or tally language, which is in one class but not the other. In the original theorem, the separating language was arbitrary.</li>
<li>It does not require s(n) to be at least log <em>n</em>; it can be any nondeterministically fully space-constructible function.</li>
</ul>
<h2 id="refinement-of-space-hierarchy">Refinement of space hierarchy</h2>

<p>If space is measured as the number of cells used regardless of alphabet size, then SPACE(f(n)) = SPACE(O(f(n))) because one can achieve any linear compression by switching to a larger alphabet. However, by measuring space in bits, a much sharper separation is achievable for deterministic space. Instead of being defined up to a multiplicative constant, space is now defined up to an additive constant. However, because any constant amount of external space can be saved by storing the contents into the internal state, we still have SPACE(f(n)) = SPACE(f(n)+O(1)).</p>

<p>Assume that f is space-constructible. SPACE is deterministic.</p>
<ul>
<li>For a wide variety of sequential computational models, including for Turing machines, SPACE(f(n)-<a href="Big_O_Notation" title="wikilink">ω</a>(log(f(n)+n))) ⊊ SPACE(f(n)). This holds even if SPACE(f(n)-ω(log(f(n)+n))) is defined using a different computational model than SPACE(f(n)) because the different models can simulate each other with O(log(f(n)+n)) space overhead.</li>
<li>For certain computational models, including Turing machines with a fixed number of tapes (with one head per tape) and fixed alphabet size and with delimiters for the visited segment on each tape, SPACE(f(n)-ω(1)) ⊊ SPACE(f(n)).</li>
</ul>

<p>The proof is similar to the proof of the space hierarchy theorem, but with two complications: The universal Turing machine has to be space-efficient, and the reversal has to be space-efficient. One can generally construct universal Turing machines with O(log(space)) space overhead, and under appropriate assumptions, just O(1) space overhead (which may depend on the machine being simulated). For the reversal, the key issue is how to detect if the simulated machine rejects by entering an infinite (space-constrained) loop. Simply counting the number of steps taken would increase space consumption by about f(n). At the cost of a potentially exponential time increase, loops can be detected space-efficiently as follows: <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Modify the machine to erase everything and to go to a specific configuration A on success. Use <a href="depth-first_search" title="wikilink">depth-first search</a> to determine whether A is reachable in the space bound from the starting configuration. The search starts at A and goes over configurations that lead to A. Because of determinism, this can be done in place and without going into a loop. Also (but this is not necessary for the proof), to determine whether the machine exceeds the space bound (as opposed to looping within the space bound), we can iterate over all configurations about to exceed the space bound and check (again using depth-first search) whether the initial configuration leads to any of them.</p>
<h2 id="corollaries">Corollaries</h2>
<h3 id="corollary-1">Corollary 1</h3>

<p><em>For any two functions 

<math display="inline" id="Space_hierarchy_theorem:67">
 <semantics>
  <msub>
   <mi>f</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Space_hierarchy_theorem:68">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>2</mn>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi>ℕ</mi>
    <mo>⟶</mo>
    <mi>ℕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <ci>normal-⟶</ci>
     <ci>ℕ</ci>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{2}:\mathbb{N}\longrightarrow\mathbb{N}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Space_hierarchy_theorem:69">
 <semantics>
  <msub>
   <mi>f</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1}
  </annotation>
 </semantics>
</math>

(n) is o(

<math display="inline" id="Space_hierarchy_theorem:70">
 <semantics>
  <msub>
   <mi>f</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{2}
  </annotation>
 </semantics>
</math>

(n)) and 

<math display="inline" id="Space_hierarchy_theorem:71">
 <semantics>
  <msub>
   <mi>f</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{2}
  </annotation>
 </semantics>
</math>

 is space-constructible, SPACE(

<math display="inline" id="Space_hierarchy_theorem:72">
 <semantics>
  <msub>
   <mi>f</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1}
  </annotation>
 </semantics>
</math>

(n)) 

<math display="inline" id="Space_hierarchy_theorem:73">
 <semantics>
  <mo>⊊</mo>
  <annotation-xml encoding="MathML-Content">
   <prsubset></prsubset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subsetneq
  </annotation>
 </semantics>
</math>

 SPACE(

<math display="inline" id="Space_hierarchy_theorem:74">
 <semantics>
  <msub>
   <mi>f</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{2}
  </annotation>
 </semantics>
</math>

(n)).</em></p>

<p>This corollary lets us separate various space complexity classes. For any function 

<math display="inline" id="Space_hierarchy_theorem:75">
 <semantics>
  <msup>
   <mi>n</mi>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{k}
  </annotation>
 </semantics>
</math>

 is space-constructible for any natural number k. Therefore for any two natural numbers 

<math display="inline" id="Space_hierarchy_theorem:76">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mn>1</mn>
   </msub>
   <mo><</mo>
   <msub>
    <mi>k</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{1}<k_{2}
  </annotation>
 </semantics>
</math>

 we can prove SPACE(

<math display="inline" id="Space_hierarchy_theorem:77">
 <semantics>
  <msup>
   <mi>n</mi>
   <msub>
    <mi>k</mi>
    <mn>1</mn>
   </msub>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{k_{1}}
  </annotation>
 </semantics>
</math>

) 

<math display="inline" id="Space_hierarchy_theorem:78">
 <semantics>
  <mo>⊊</mo>
  <annotation-xml encoding="MathML-Content">
   <prsubset></prsubset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subsetneq
  </annotation>
 </semantics>
</math>

 SPACE(

<math display="inline" id="Space_hierarchy_theorem:79">
 <semantics>
  <msup>
   <mi>n</mi>
   <msub>
    <mi>k</mi>
    <mn>2</mn>
   </msub>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{k_{2}}
  </annotation>
 </semantics>
</math>

). We can extend this idea for real numbers in the following corollary. This demonstrates the detailed hierarchy within the PSPACE class.</p>
<h3 id="corollary-2">Corollary 2</h3>

<p><em>For any two nonnegative real numbers 

<math display="inline" id="Space_hierarchy_theorem:80">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo><</mo>
    <msub>
     <mi>a</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1}<a_{2},
  </annotation>
 </semantics>
</math>

 SPACE(

<math display="inline" id="Space_hierarchy_theorem:81">
 <semantics>
  <msup>
   <mi>n</mi>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{a_{1}}
  </annotation>
 </semantics>
</math>

) 

<math display="inline" id="Space_hierarchy_theorem:82">
 <semantics>
  <mo>⊊</mo>
  <annotation-xml encoding="MathML-Content">
   <prsubset></prsubset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subsetneq
  </annotation>
 </semantics>
</math>

 SPACE(

<math display="inline" id="Space_hierarchy_theorem:83">
 <semantics>
  <msup>
   <mi>n</mi>
   <msub>
    <mi>a</mi>
    <mn>2</mn>
   </msub>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{a_{2}}
  </annotation>
 </semantics>
</math>

).</em></p>
<h3 id="corollary-3">Corollary 3</h3>

<p><em><a href="NL_(complexity)" title="wikilink">NL</a> 

<math display="inline" id="Space_hierarchy_theorem:84">
 <semantics>
  <mo>⊊</mo>
  <annotation-xml encoding="MathML-Content">
   <prsubset></prsubset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subsetneq
  </annotation>
 </semantics>
</math>

 <a class="uri" href="PSPACE" title="wikilink">PSPACE</a>.</em></p>
<h4 id="proof-1">Proof</h4>

<p><a href="Savitch's_theorem" title="wikilink">Savitch's theorem</a> shows that NL 

<math display="inline" id="Space_hierarchy_theorem:85">
 <semantics>
  <mo>⊆</mo>
  <annotation-xml encoding="MathML-Content">
   <subset></subset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subseteq
  </annotation>
 </semantics>
</math>

 SPACE(

<math display="inline" id="Space_hierarchy_theorem:86">
 <semantics>
  <mrow>
   <msup>
    <mi>log</mi>
    <mn>2</mn>
   </msup>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <log></log>
     <cn type="integer">2</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log^{2}n
  </annotation>
 </semantics>
</math>

), while the space hierarchy theorem shows that SPACE(

<math display="inline" id="Space_hierarchy_theorem:87">
 <semantics>
  <mrow>
   <msup>
    <mi>log</mi>
    <mn>2</mn>
   </msup>
   <mi>n</mi>
   <mo stretchy="false">)</mo>
   <mo>⊊</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <log></log>
     <cn type="integer">2</cn>
    </apply>
    <csymbol cd="unknown">n</csymbol>
    <ci>normal-)</ci>
    <prsubset></prsubset>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log^{2}n)\subsetneq
  </annotation>
 </semantics>
</math>

 SPACE(

<math display="inline" id="Space_hierarchy_theorem:88">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

). Thus we get this corollary along with the fact that TQBF 

<math display="inline" id="Space_hierarchy_theorem:89">
 <semantics>
  <mo>∉</mo>
  <annotation-xml encoding="MathML-Content">
   <notin></notin>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \notin
  </annotation>
 </semantics>
</math>

 NL since TQBF is PSPACE-complete.</p>

<p>This could also be proven using the non-deterministic space hierarchy theorem to show that NL 

<math display="inline" id="Space_hierarchy_theorem:90">
 <semantics>
  <mo>⊊</mo>
  <annotation-xml encoding="MathML-Content">
   <prsubset></prsubset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subsetneq
  </annotation>
 </semantics>
</math>

 NPSPACE, and using Savitch's theorem to show that PSPACE = NPSPACE.</p>
<h3 id="corollary-4">Corollary 4</h3>

<p><a class="uri" href="PSPACE" title="wikilink">PSPACE</a> 

<math display="inline" id="Space_hierarchy_theorem:91">
 <semantics>
  <mo>⊊</mo>
  <annotation-xml encoding="MathML-Content">
   <prsubset></prsubset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subsetneq
  </annotation>
 </semantics>
</math>

 <a class="uri" href="EXPSPACE" title="wikilink">EXPSPACE</a>.</p>

<p>This last corollary shows the existence of decidable problems that are intractable. In other words their decision procedures must use more than polynomial space.</p>
<h3 id="corollary-5">Corollary 5</h3>

<p>There are problems in <strong>PSPACE</strong> requiring an arbitrarily large exponent to solve; therefore <strong>PSPACE</strong> does not collapse to <strong>DSPACE</strong>(<em>n</em><sup><em>k</em></sup>) for some constant <em>k</em>.</p>
<h2 id="see-also">See Also</h2>
<ul>
<li><a href="Time_hierarchy_theorem" title="wikilink">Time hierarchy theorem</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li><a href="Luca_Trevisan" title="wikilink">Luca Trevisan</a>. <a href="http://www.cs.berkeley.edu/~luca/cs172-04/noteh.pdf">Notes on Hierarchy Theorems</a>. Handout 7. CS172: Automata, Computability and Complexity. U.C. Berkeley. April 26, 2004.</li>
<li>Viliam Geffert. <a href="http://portal.acm.org/citation.cfm?id=763728">Space hierarchy theorem revised</a>. <em>Theoretical Computer Science</em>, volume 295, number 1-3, p.171-187. February 24, 2003.</li>
<li>

<p>Pages 306–310 of section 9.1: Hierarchy theorems.</p></li>
<li>

<p>Section 7.2: The Hierarchy Theorem, pp.143–146.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a> <a href="Category:Structural_complexity_theory" title="wikilink">Category:Structural complexity theory</a> <a href="Category:Theorems_in_computational_complexity_theory" title="wikilink">Category:Theorems in computational complexity theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
