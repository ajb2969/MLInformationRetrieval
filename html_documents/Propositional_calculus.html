<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="606">Propositional calculus</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Propositional calculus</h1>
<hr/>

<p><strong>Propositional calculus</strong> (also called <strong>propositional logic</strong>, <strong>sentential calculus</strong>, or <strong>sentential logic</strong>) is the branch of <a href="mathematical_logic" title="wikilink">mathematical logic</a> concerned with the study of propositions (whether they are true or false) that are formed by other propositions with the use of <a href="logical_connective" title="wikilink">logical connectives</a>, and how their value depends on the truth value of their components. Logical connectives are found in natural languages. In English for example, some examples are "and" (<a href="logical_conjunction" title="wikilink">conjunction</a>), "or" (<a href="logical_disjunction" title="wikilink">disjunction</a>), "not” (<a class="uri" href="negation" title="wikilink">negation</a>) and "if" (but only when used to denote <a href="material_conditional" title="wikilink">material conditional</a>).</p>

<p>The following is an example of a very simple inference within the scope of propositional logic:</p>
<dl>
<dd>Premise 1: If it's raining then it's cloudy.
</dd>
<dd>Premise 2: It's raining.
</dd>
<dd>Conclusion: It's cloudy.
</dd>
</dl>

<p>Both premises and the conclusions are propositions. The premises are taken for granted and then with the application of <a href="modus_ponens" title="wikilink">modus ponens</a> (an <a href="inference_rule" title="wikilink">inference rule</a>) the conclusion follows.</p>

<p>As propositional logic is not concerned with the structure of propositions beyond the point where they can't be decomposed anymore by logical connectives, this inference can be restated replacing those <em>atomic</em> statements with statement letters, which are interpreted as variables representing statements:</p>
<dl>
<dd>Premise 1

<math display="block" id="Propositional_calculus:0">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>→</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\to Q
  </annotation>
 </semantics>
</math>


</dd>
<dd>Premise 2

<math display="block" id="Propositional_calculus:1">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>


</dd>
<dd>Conclusion

<math display="block" id="Propositional_calculus:2">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>The same can be stated succinctly in the following way:</p>

<p>

<math display="block" id="Propositional_calculus:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mo>→</mo>
    <mrow>
     <mi>Q</mi>
     <mo>,</mo>
     <mi>P</mi>
    </mrow>
   </mrow>
   <mo>⊢</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <apply>
     <ci>normal-→</ci>
     <ci>P</ci>
     <list>
      <ci>Q</ci>
      <ci>P</ci>
     </list>
    </apply>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\to Q,P\vdash Q
  </annotation>
 </semantics>
</math>

</p>

<p>When 

<math display="inline" id="Propositional_calculus:4">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is interpreted as “It's raining” and 

<math display="inline" id="Propositional_calculus:5">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 as “it's cloudy” the above symbolic expressions can be seen to exactly correspond with the original expression in natural language. Not only that, but they will also correspond with any other inference of this <em>form</em>, which will be valid on the same basis that this inference is.</p>

<p>Propositional logic may be studied through a <a href="formal_system" title="wikilink">formal system</a> in which <a href="well-formed_formula" title="wikilink">formulas</a> of a <a href="formal_language" title="wikilink">formal language</a> may be <a href="interpretation_(logic)" title="wikilink">interpreted</a> to represent <a class="uri" href="propositions" title="wikilink">propositions</a>. A <a href="deductive_system" title="wikilink">system</a> of <a href="rule_of_inference" title="wikilink">inference rules</a> and <a href="axiom" title="wikilink">axioms</a> allows certain formulas to be derived. These derived formulas are called <a href="theorem" title="wikilink">theorems</a> and may be interpreted to be true propositions. A constructed sequence of such formulas is known as a <em><a href="formal_proof" title="wikilink">derivation</a></em> or <em>proof</em> and the last formula of the sequence is the theorem. The derivation may be interpreted as proof of the proposition represented by the theorem.</p>

<p>When a <a href="formal_system" title="wikilink">formal system</a> is used to represent formal logic, only statement letters are represented directly. The natural language propositions that arise when they're interpreted are outside the scope of the system, and the relation between the formal system and its interpretation is likewise outside the formal system itself.</p>

<p>Usually in <strong>truth-functional propositional logic</strong>, formulas are interpreted as having either a <a href="truth_value" title="wikilink">truth value</a> of <em>true</em> or a truth value of <em>false</em>. Truth-functional propositional logic and systems <a href="isomorphism" title="wikilink">isomorphic</a> to it, are considered to be <strong><a href="zeroth-order_logic" title="wikilink">zeroth-order logic</a></strong>.</p>
<h2 id="history">History</h2>

<p>Although propositional logic (which is interchangeable with propositional calculus) had been hinted by earlier philosophers, it was developed into a formal logic by <a class="uri" href="Chrysippus" title="wikilink">Chrysippus</a> in the 3rd century BC<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and expanded by the <a class="uri" href="Stoics" title="wikilink">Stoics</a>. The logic was focused on <a href="proposition" title="wikilink">propositions</a>. This advancement was different from the traditional <a href="syllogism" title="wikilink">syllogistic logic</a> which was focused on <a href="Syllogisms#Terms_in_syllogism" title="wikilink">terms</a>. However, later in antiquity, the propositional logic developed by the Stoics was no longer understood . Consequently, the system was essentially reinvented by <a href="Peter_Abelard" title="wikilink">Peter Abelard</a> in the 12th century.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Propositional logic was eventually refined using <a href="symbolic_logic" title="wikilink">symbolic logic</a>. The 17th/18th century philosopher <a href="Gottfried_Leibniz" title="wikilink">Gottfried Leibniz</a> has been credited with being the founder of symbolic logic for his work with the <a href="calculus_ratiocinator" title="wikilink">calculus ratiocinator</a>. Although his work was the first of its kind, it was unknown to the larger logical community. Consequently, many of the advances achieved by Leibniz were reachieved by logicians like <a href="George_Boole" title="wikilink">George Boole</a> and <a href="Augustus_De_Morgan" title="wikilink">Augustus De Morgan</a> completely independent of Leibniz.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Just as propositional logic can be considered an advancement from the earlier syllogistic logic, <a href="Gottlob_Frege" title="wikilink">Gottlob Frege's</a> <a href="predicate_logic" title="wikilink">predicate logic</a> was an advancement from the earlier propositional logic. One author describes predicate logic as combining "the distinctive features of syllogistic logic and propositional logic."<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Consequently, predicate logic ushered in a new era in logic's history; however, advances in propositional logic were still made after Frege, including <a href="natural_deduction" title="wikilink">Natural Deduction</a>, <a href="Method_of_analytic_tableaux" title="wikilink">Truth-Trees</a> and <a href="truth-table" title="wikilink">Truth-Tables</a>. Natural deduction was invented by <a href="Gerhard_Gentzen" title="wikilink">Gerhard Gentzen</a> and <a href="Jan_Łukasiewicz" title="wikilink">Jan Łukasiewicz</a>. Truth-Trees were invented by <a href="Evert_Willem_Beth" title="wikilink">Evert Willem Beth</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The invention of truth-tables, however, is of controversial attribution.</p>

<p>Within works by Frege<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> and <a href="Bertrand_Russell" title="wikilink">Bertrand Russell</a>,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> one finds ideas influential in bringing about the notion of truth tables. The actual 'tabular structure' (being formatted as a table), itself, is generally credited to either <a href="Ludwig_Wittgenstein" title="wikilink">Ludwig Wittgenstein</a> or <a href="Emil_Post" title="wikilink">Emil Post</a> (or both, independently).<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Besides Frege and Russell, others credited with having ideas preceding truth-tables include Philo, Boole, <a href="Charles_Sanders_Peirce" title="wikilink">Charles Sanders Peirce</a>, and <a href="Ernst_Schröder" title="wikilink">Ernst Schröder</a>. Others credited with the tabular structure include Łukasiewicz, Schröder, <a href="Alfred_North_Whitehead" title="wikilink">Alfred North Whitehead</a>, <a href="William_Stanley_Jevons" title="wikilink">William Stanley Jevons</a>, <a href="John_Venn" title="wikilink">John Venn</a>, and <a href="Clarence_Irving_Lewis" title="wikilink">Clarence Irving Lewis</a>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Ultimately, some have concluded, like John Shosky, that "It is far from clear that any one person should be given the title of 'inventor' of truth-tables.".<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="terminology">Terminology</h2>

<p>In general terms, a calculus is a <a href="formal_system" title="wikilink">formal system</a> that consists of a set of syntactic expressions (<em><a href="well-formed_formula" title="wikilink">well-formed formulas</a></em>), a distinguished subset of these expressions (axioms), plus a set of formal rules that define a specific <a href="binary_relation" title="wikilink">binary relation</a>, intended to be interpreted to be <a href="logical_equivalence" title="wikilink">logical equivalence</a>, on the space of expressions.</p>

<p>When the formal system is intended to be a <a href="logical_system" title="wikilink">logical system</a>, the expressions are meant to be interpreted to be statements, and the rules, known to be <em>inference rules</em>, are typically intended to be truth-preserving. In this setting, the rules (which may include <a class="uri" href="axioms" title="wikilink">axioms</a>) can then be used to derive ("infer") formulas representing true statements from given formulas representing true statements.</p>

<p>The set of axioms may be empty, a nonempty finite set, a countably infinite set, or be given by <a href="axiom_schema" title="wikilink">axiom schemata</a>. A <a href="formal_grammar" title="wikilink">formal grammar</a> recursively defines the expressions and well-formed formulas of the <a href="formal_language" title="wikilink">language</a>. In addition a <a class="uri" href="semantics" title="wikilink">semantics</a> may be given which defines truth and <a href="valuation_(logic)" title="wikilink">valuations</a> (or <a href="interpretation_(logic)" title="wikilink">interpretations</a>).</p>

<p>The <a href="formal_language" title="wikilink">language</a> of a propositional calculus consists of</p>
<ol>
<li>a set of primitive symbols, variously referred to be <em><a href="atomic_formula" title="wikilink">atomic formulas</a></em>, <em>placeholders</em>, <em>proposition letters</em>, or <em>variables</em>, and</li>
<li>a set of operator symbols, variously interpreted to be <em><a href="logical_operator" title="wikilink">logical operators</a></em> or <em>logical connectives</em>.</li>
</ol>

<p>A <em><a href="well-formed_formula" title="wikilink">well-formed formula</a></em> is any atomic formula, or any formula that can be built up from atomic formulas by means of operator symbols according to the rules of the grammar.</p>

<p>Mathematicians sometimes distinguish between propositional constants, propositional variables, and schemata. Propositional constants represent some particular proposition, while propositional variables range over the set of all atomic propositions. Schemata, however, range over all propositions. It is common to represent propositional constants by 

<math display="inline" id="Propositional_calculus:6">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Propositional_calculus:7">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Propositional_calculus:8">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

, propositional variables by 

<math display="inline" id="Propositional_calculus:9">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Propositional_calculus:10">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Propositional_calculus:11">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

, and schematic letters are often Greek letters, most often 

<math display="inline" id="Propositional_calculus:12">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Propositional_calculus:13">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ψ
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Propositional_calculus:14">
 <semantics>
  <mi>χ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>χ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   χ
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="basic-concepts">Basic concepts</h2>

<p>The following outlines a standard propositional calculus. Many different formulations exist which are all more or less equivalent but differ in the details of:</p>
<ol>
<li>their language, that is, the particular collection of primitive symbols and operator symbols,</li>
<li>the set of axioms, or distinguished formulas, and</li>
<li>the set of inference rules.</li>
</ol>

<p>Any given proposition may be represented with a letter called a 'propositional constant', analogous to representing a number by a letter in mathematics, for instance, 

<math display="inline" id="Propositional_calculus:15">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mn>5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <cn type="integer">5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=5
  </annotation>
 </semantics>
</math>

. All propositions require exactly one of two truth-values: true or false. For example, let 

<math display="inline" id="Propositional_calculus:16">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 be the proposition that it is raining outside. This will be true (

<math display="inline" id="Propositional_calculus:17">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

) if it is raining outside and false otherwise (

<math display="inline" id="Propositional_calculus:18">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-¬</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ¬P
  </annotation>
 </semantics>
</math>

).</p>
<ul>
<li>We then define <a class="uri" href="truth-functional" title="wikilink">truth-functional</a> operators, beginning with negation. (

<math display="inline" id="Propositional_calculus:19">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-¬</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ¬P
  </annotation>
 </semantics>
</math>

 represents the negation of 

<math display="inline" id="Propositional_calculus:20">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, which can be thought of as the denial of 

<math display="inline" id="Propositional_calculus:21">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

. In the example above, (

<math display="inline" id="Propositional_calculus:22">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-¬</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ¬P
  </annotation>
 </semantics>
</math>

 expresses that it is not raining outside, or by a more standard reading: "It is not the case that it is raining outside." When 

<math display="inline" id="Propositional_calculus:23">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is true, (

<math display="inline" id="Propositional_calculus:24">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-¬</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ¬P
  </annotation>
 </semantics>
</math>

 is false; and when 

<math display="inline" id="Propositional_calculus:25">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is false, (

<math display="inline" id="Propositional_calculus:26">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-¬</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ¬P
  </annotation>
 </semantics>
</math>

 is true. {(

<math display="inline" id="Propositional_calculus:27">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi mathvariant="normal">¬</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-¬</ci>
    <ci>normal-¬</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ¬¬P
  </annotation>
 </semantics>
</math>

 always has the same truth-value as 

<math display="inline" id="Propositional_calculus:28">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

.</li>
<li>Conjunction is a truth-functional connective which forms a proposition out of two simpler propositions, for example, 

<math display="inline" id="Propositional_calculus:29">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:30">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

. The conjunction of 

<math display="inline" id="Propositional_calculus:31">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:32">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is written 

<math display="inline" id="Propositional_calculus:33">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi mathvariant="normal">∧</mi>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>normal-∧</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P∧Q
  </annotation>
 </semantics>
</math>

, and expresses that each are true. We read 

<math display="inline" id="Propositional_calculus:34">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi mathvariant="normal">∧</mi>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>normal-∧</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P∧Q
  </annotation>
 </semantics>
</math>

 for "

<math display="inline" id="Propositional_calculus:35">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:36">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

". For any two propositions, there are four possible assignments of truth values:
<ol>
<li>

<math display="inline" id="Propositional_calculus:37">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is true and 

<math display="inline" id="Propositional_calculus:38">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is true</li>
<li>

<math display="inline" id="Propositional_calculus:39">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is true and 

<math display="inline" id="Propositional_calculus:40">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is false</li>
<li>

<math display="inline" id="Propositional_calculus:41">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is false and 

<math display="inline" id="Propositional_calculus:42">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is true</li>
<li>

<math display="inline" id="Propositional_calculus:43">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is false and 

<math display="inline" id="Propositional_calculus:44">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is false</li>
</ol></li>
</ul>
<dl>
<dd>The conjunction of 

<math display="inline" id="Propositional_calculus:45">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:46">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is true in case 1 and is false otherwise. Where 

<math display="inline" id="Propositional_calculus:47">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is the proposition that it is raining outside and 

<math display="inline" id="Propositional_calculus:48">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is the proposition that a cold-front is over Kansas, 

<math display="inline" id="Propositional_calculus:49">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi mathvariant="normal">∧</mi>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>normal-∧</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P∧Q
  </annotation>
 </semantics>
</math>

 is true when it is raining outside and there is a cold-front over Kansas. If it is not raining outside, then 

<math display="inline" id="Propositional_calculus:50">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi mathvariant="normal">∧</mi>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>normal-∧</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P∧Q
  </annotation>
 </semantics>
</math>

 is false; and if there is no cold-front over Kansas, then 

<math display="inline" id="Propositional_calculus:51">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi mathvariant="normal">∧</mi>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>normal-∧</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P∧Q
  </annotation>
 </semantics>
</math>

 is false.
</dd>
</dl>
<ul>
<li>Disjunction resembles conjunction in that it forms a proposition out of two simpler propositions. We write it 

<math display="inline" id="Propositional_calculus:52">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi mathvariant="normal">∨</mi>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>normal-∨</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P∨Q
  </annotation>
 </semantics>
</math>

, and it is read "

<math display="inline" id="Propositional_calculus:53">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Propositional_calculus:54">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

". It expresses that either 

<math display="inline" id="Propositional_calculus:55">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Propositional_calculus:56">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is true. Thus, in the cases listed above, the disjunction of 

<math display="inline" id="Propositional_calculus:57">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:58">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is true in all cases except 4. Using the example above, the disjunction expresses that it is either raining outside or there is a cold front over Kansas. (Note, this use of disjunction is supposed to resemble the use of the English word "or". However, it is most like the English <a href="inclusive_disjunction" title="wikilink">inclusive</a> "or", which can be used to express the truth of at least one of two propositions. It is not like the English <a href="exclusive_disjunction" title="wikilink">exclusive</a> "or", which expresses the truth of exactly one of two propositions. That is to say, the exclusive "or" is false when both 

<math display="inline" id="Propositional_calculus:59">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:60">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 are true (case 1). An example of the exclusive or is: You may have a bagel or a pastry, but not both. Often in natural language, given the appropriate context, the addendum "but not both" is omitted but implied. In mathematics, however, "or" is always inclusive or; if exclusive or is meant it will be specified, possibly by "xor".)</li>
<li>Material conditional also joins two simpler propositions, and we write 

<math display="inline" id="Propositional_calculus:61">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi mathvariant="normal">→</mi>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>normal-→</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P→Q
  </annotation>
 </semantics>
</math>

, which is read "if 

<math display="inline" id="Propositional_calculus:62">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Propositional_calculus:63">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

". The proposition to the left of the arrow is called the antecedent and the proposition to the right is called the consequent. (There is no such designation for conjunction or disjunction, since they are commutative operations.) It expresses that 

<math display="inline" id="Propositional_calculus:64">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is true whenever 

<math display="inline" id="Propositional_calculus:65">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is true. Thus it is true in every case above except case 2, because this is the only case when 

<math display="inline" id="Propositional_calculus:66">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is true but 

<math display="inline" id="Propositional_calculus:67">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is not. Using the example, if 

<math display="inline" id="Propositional_calculus:68">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Propositional_calculus:69">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 expresses that if it is raining outside then there is a cold-front over Kansas. The material conditional is often confused with physical causation. The material conditional, however, only relates two propositions by their truth-values—which is not the relation of cause and effect. It is contentious in the literature whether the material implication represents logical causation.</li>
<li>Biconditional joins two simpler propositions, and we write 

<math display="inline" id="Propositional_calculus:70">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi mathvariant="normal">↔</mi>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>normal-↔</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P↔Q
  </annotation>
 </semantics>
</math>

, which is read "

<math display="inline" id="Propositional_calculus:71">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Propositional_calculus:72">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

". It expresses that 

<math display="inline" id="Propositional_calculus:73">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:74">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 have the same truth-value, thus 

<math display="inline" id="Propositional_calculus:75">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Propositional_calculus:76">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is true in cases 1 and 4, and false otherwise.</li>
</ul>

<p>It is extremely helpful to look at the <a href="truth_table" title="wikilink">truth tables</a> for these different operators, as well as the <a href="method_of_analytic_tableaux" title="wikilink">method of analytic tableaux</a>.</p>
<h3 id="closure-under-operations">Closure under operations</h3>

<p>Propositional logic is closed under truth-functional connectives. That is to say, for any proposition 

<math display="inline" id="Propositional_calculus:77">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Propositional_calculus:78">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-¬</ci>
    <ci>φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ¬φ
  </annotation>
 </semantics>
</math>

 is also a proposition. Likewise, for any propositions 

<math display="inline" id="Propositional_calculus:79">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:80">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ψ
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Propositional_calculus:81">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mi mathvariant="normal">∧</mi>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>φ</ci>
    <ci>normal-∧</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ∧ψ
  </annotation>
 </semantics>
</math>

 is a proposition, and similarly for disjunction, conditional, and biconditional. This implies that, for instance, 

<math display="inline" id="Propositional_calculus:82">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mi mathvariant="normal">∧</mi>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>φ</ci>
    <ci>normal-∧</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ∧ψ
  </annotation>
 </semantics>
</math>

 is a proposition, and so it can be conjoined with another proposition. In order to represent this, we need to use parentheses to indicate which proposition is conjoined with which. For instance, 

<math display="inline" id="Propositional_calculus:83">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi mathvariant="normal">∧</mi>
   <mi>Q</mi>
   <mi mathvariant="normal">∧</mi>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>normal-∧</ci>
    <ci>Q</ci>
    <ci>normal-∧</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P∧Q∧R
  </annotation>
 </semantics>
</math>

 is not a well-formed formula, because we do not know if we are conjoining 

<math display="inline" id="Propositional_calculus:84">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi mathvariant="normal">∧</mi>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>normal-∧</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P∧Q
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Propositional_calculus:85">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 or if we are conjoining 

<math display="inline" id="Propositional_calculus:86">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Propositional_calculus:87">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mi mathvariant="normal">∧</mi>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>normal-∧</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q∧R
  </annotation>
 </semantics>
</math>

. Thus we must write either 

<math display="inline" id="Propositional_calculus:88">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>P</mi>
     <mi mathvariant="normal">∧</mi>
     <mi>Q</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal">∧</mi>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>normal-∧</ci>
     <ci>Q</ci>
    </apply>
    <ci>normal-∧</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P∧Q)∧R
  </annotation>
 </semantics>
</math>

 to represent the former, or 

<math display="inline" id="Propositional_calculus:89">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi mathvariant="normal">∧</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>Q</mi>
     <mi mathvariant="normal">∧</mi>
     <mi>R</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>normal-∧</ci>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>normal-∧</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P∧(Q∧R)
  </annotation>
 </semantics>
</math>

 to represent the latter. By evaluating the truth conditions, we see that both expressions have the same truth conditions (will be true in the same cases), and moreover that any proposition formed by arbitrary conjunctions will have the same truth conditions, regardless of the location of the parentheses. This means that conjunction is associative, however, one should not assume that parentheses never serve a purpose. For instance, the sentence 

<math display="inline" id="Propositional_calculus:90">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi mathvariant="normal">∧</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>Q</mi>
     <mi mathvariant="normal">∨</mi>
     <mi>R</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>normal-∧</ci>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>normal-∨</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P∧(Q∨R)
  </annotation>
 </semantics>
</math>

 does not have the same truth conditions of 

<math display="inline" id="Propositional_calculus:91">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>P</mi>
     <mi mathvariant="normal">∧</mi>
     <mi>Q</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal">∨</mi>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>normal-∧</ci>
     <ci>Q</ci>
    </apply>
    <ci>normal-∨</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P∧Q)∨R
  </annotation>
 </semantics>
</math>

, so they are different sentences distinguished only by the parentheses. One can verify this by the truth-table method referenced above.</p>

<p>Note: For any arbitrary number of propositional constants, we can form a finite number of cases which list their possible truth-values. A simple way to generate this is by truth-tables, in which one writes 

<math display="inline" id="Propositional_calculus:92">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Propositional_calculus:93">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

, ..., 

<math display="inline" id="Propositional_calculus:94">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

, for any list of 

<math display="inline" id="Propositional_calculus:95">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 propositional constants—that is to say, any list of propositional constants with 

<math display="inline" id="Propositional_calculus:96">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 entries. Below this list, one writes <mtpl></mtpl> rows, and below 

<math display="inline" id="Propositional_calculus:97">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 one fills in the first half of the rows with true (or T) and the second half with false (or F). Below 

<math display="inline" id="Propositional_calculus:98">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 one fills in one-quarter of the rows with T, then one-quarter with F, then one-quarter with T and the last quarter with F. The next column alternates between true and false for each eighth of the rows, then sixteenths, and so on, until the last propositional constant varies between T and F for each row. This will give a complete listing of cases or truth-value assignments possible for those propositional constants.</p>
<h3 id="argument">Argument</h3>

<p>The propositional calculus then defines an <em><a class="uri" href="argument" title="wikilink">argument</a></em> to be a set of propositions. A valid argument is a set of propositions, the last of which follows from—or is implied by—the rest. All other arguments are invalid. The simplest valid argument is <a href="modus_ponens" title="wikilink">modus ponens</a>, one instance of which is the following set of propositions:</p>

<p>

<math display="block" id="Propositional_calculus:99">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="right">
     <mn>1.</mn>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>P</mi>
      <mo>→</mo>
      <mi>Q</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mn>2.</mn>
    </mtd>
    <mtd columnalign="left">
     <mi>P</mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd class="ltx_border_t" columnalign="right">
     <mo>∴</mo>
    </mtd>
    <mtd class="ltx_border_t" columnalign="left">
     <mi>Q</mi>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="float">1.</cn>
     <apply>
      <ci>normal-→</ci>
      <ci>P</ci>
      <ci>Q</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <cn type="float">2.</cn>
     <ci>P</ci>
    </matrixrow>
    <matrixrow>
     <csymbol cd="latexml">therefore</csymbol>
     <ci>Q</ci>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{rl}1.&P\to Q\\
2.&P\\
\hline\therefore&Q\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>This is a set of three propositions, each line is a proposition, and the last follows from the rest. The first two lines are called premises, and the last line the conclusion. We say that any proposition 

<math display="inline" id="Propositional_calculus:100">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 follows from any set of propositions 

<math display="inline" id="Propositional_calculus:101">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>P</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>P</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>n</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P_{1},...,P_{n})
  </annotation>
 </semantics>
</math>

, if 

<math display="inline" id="Propositional_calculus:102">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 must be true whenever every member of the set 

<math display="inline" id="Propositional_calculus:103">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>P</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>P</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>n</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P_{1},...,P_{n})
  </annotation>
 </semantics>
</math>

 is true. In the argument above, for any 

<math display="inline" id="Propositional_calculus:104">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:105">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

, whenever 

<math display="inline" id="Propositional_calculus:106">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi mathvariant="normal">→</mi>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>normal-→</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P→Q
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:107">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 are true, necessarily 

<math display="inline" id="Propositional_calculus:108">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is true. Notice that, when 

<math display="inline" id="Propositional_calculus:109">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is true, we cannot consider cases 3 and 4 (from the truth table). When 

<math display="inline" id="Propositional_calculus:110">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi mathvariant="normal">→</mi>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>normal-→</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P→Q
  </annotation>
 </semantics>
</math>

 is true, we cannot consider case 2. This leaves only case 1, in which 

<math display="inline" id="Propositional_calculus:111">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is also true. Thus 

<math display="inline" id="Propositional_calculus:112">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is implied by the premises.</p>

<p>This generalizes schematically. Thus, where 

<math display="inline" id="Propositional_calculus:113">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:114">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ψ
  </annotation>
 </semantics>
</math>

 may be any propositions at all,</p>

<p>

<math display="block" id="Propositional_calculus:115">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="right">
     <mn>1.</mn>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>φ</mi>
      <mo>→</mo>
      <mi>ψ</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mn>2.</mn>
    </mtd>
    <mtd columnalign="left">
     <mi>φ</mi>
    </mtd>
   </mtr>
   <mtr>
    <mtd class="ltx_border_t" columnalign="right">
     <mo>∴</mo>
    </mtd>
    <mtd class="ltx_border_t" columnalign="left">
     <mi>ψ</mi>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="float">1.</cn>
     <apply>
      <ci>normal-→</ci>
      <ci>φ</ci>
      <ci>ψ</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <cn type="float">2.</cn>
     <ci>φ</ci>
    </matrixrow>
    <matrixrow>
     <csymbol cd="latexml">therefore</csymbol>
     <ci>ψ</ci>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{rl}1.&\varphi\to\psi\\
2.&\varphi\\
\hline\therefore&\psi\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>Other argument forms are convenient, but not necessary. Given a complete set of axioms (see below for one such set), modus ponens is sufficient to prove all other argument forms in propositional logic, thus they may be considered to be a derivative. Note, this is not true of the extension of propositional logic to other logics like <a href="first-order_logic" title="wikilink">first-order logic</a>. First-order logic requires at least one additional rule of inference in order to obtain <a href="Completeness_(logic)" title="wikilink">completeness</a>.</p>

<p>The significance of argument in formal logic is that one may obtain new truths from established truths. In the first example above, given the two premises, the truth of 

<math display="inline" id="Propositional_calculus:116">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is not yet known or stated. After the argument is made, 

<math display="inline" id="Propositional_calculus:117">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is deduced. In this way, we define a deduction system to be a set of all propositions that may be deduced from another set of propositions. For instance, given the set of propositions 

<math display="inline" id="Propositional_calculus:118">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>P</mi>
    <mi>Q</mi>
    <mo>,</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>Q</mi>
    <mi mathvariant="italic">and</mi>
    <mi>R</mi>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>P</mi>
     <mi>Q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>R</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">P</csymbol>
     <csymbol cd="unknown">Q</csymbol>
     <ci>normal-,</ci>
     <not></not>
     <csymbol cd="unknown">Q</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-,</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">P</csymbol>
      <csymbol cd="unknown">Q</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\{PQ,\neg Q\and R,(PQ)\to R\}
  </annotation>
 </semantics>
</math>

, we can define a deduction system, 

<math display="inline" id="Propositional_calculus:119">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Γ
  </annotation>
 </semantics>
</math>

, which is the set of all propositions which follow from 

<math display="inline" id="Propositional_calculus:120">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. <a href="deduction_theorem#Virtual_rules_of_inference" title="wikilink">Reiteration</a> is always assumed, so 

<math display="inline" id="Propositional_calculus:121">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mi>Q</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>Q</mi>
     <mi mathvariant="italic">and</mi>
     <mi>R</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>P</mi>
      <mi>Q</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mi>R</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Γ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <list>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>Q</ci>
      </apply>
      <apply>
       <times></times>
       <not></not>
       <ci>Q</ci>
       <ci>italic- and</ci>
       <ci>R</ci>
      </apply>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>Q</ci>
      </apply>
     </list>
     <ci>R</ci>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <ci>normal-Γ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   PQ,\neg Q\and R,(PQ)\to R\in\Gamma
  </annotation>
 </semantics>
</math>

. Also, from the first element of 

<math display="inline" id="Propositional_calculus:122">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, last element, as well as modus ponens, 

<math display="inline" id="Propositional_calculus:123">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is a consequence, and so 

<math display="inline" id="Propositional_calculus:124">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Γ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>R</ci>
    <ci>normal-Γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\in\Gamma
  </annotation>
 </semantics>
</math>

. Because we have not included sufficiently complete axioms, though, nothing else may be deduced. Thus, even though most deduction systems studied in propositional logic are able to deduce 

<math display="inline" id="Propositional_calculus:125">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mi>Q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>P</mi>
    <mo>→</mo>
    <mi>Q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <csymbol cd="unknown">Q</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-↔</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <not></not>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">Q</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (PQ)\leftrightarrow(\neg P\to Q)
  </annotation>
 </semantics>
</math>

, this one is too weak to prove such a proposition.</p>
<h2 id="generic-description-of-a-propositional-calculus">Generic description of a propositional calculus</h2>

<p>A <strong>propositional calculus</strong> is a <a href="formal_system" title="wikilink">formal system</a> 

<math display="inline" id="Propositional_calculus:126">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℒ</mi>
   <mo>=</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℒ</mi>
    <mrow>
     <mo>(</mo>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\Alpha</mtext>
     </merror>
     <mo rspace="7.5pt">,</mo>
     <mi mathvariant="normal">Ω</mi>
     <mo rspace="7.5pt">,</mo>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\Zeta</mtext>
     </merror>
     <mo rspace="7.5pt">,</mo>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\Iota</mtext>
     </merror>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ℒ</ci>
    <apply>
     <times></times>
     <ci>ℒ</ci>
     <vector>
      <mtext>\Alpha</mtext>
      <ci>normal-Ω</ci>
      <mtext>\Zeta</mtext>
      <mtext>\Iota</mtext>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{L}=\mathcal{L}\left(\Alpha,\ \Omega,\ \Zeta,\ \Iota\right)
  </annotation>
 </semantics>
</math>

, where:</p>
<ul>
<li>The <em>alpha set</em> 

<math display="inline" id="Propositional_calculus:127">
 <semantics>
  <merror class="ltx_ERROR undefined undefined">
   <mtext>\Alpha</mtext>
  </merror>
  <annotation-xml encoding="MathML-Content">
   <mtext>\Alpha</mtext>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Alpha
  </annotation>
 </semantics>
</math>

 is a finite set of elements called <em>proposition symbols</em> or <em><a href="propositional_variable" title="wikilink">propositional variables</a></em>. Syntactically speaking, these are the most basic elements of the formal language 

<math display="inline" id="Propositional_calculus:128">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℒ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℒ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{L}
  </annotation>
 </semantics>
</math>

, otherwise referred to as <em><a href="atomic_formula" title="wikilink">atomic formulas</a></em> or <em>terminal elements</em>. In the examples to follow, the elements of 

<math display="inline" id="Propositional_calculus:129">
 <semantics>
  <merror class="ltx_ERROR undefined undefined">
   <mtext>\Alpha</mtext>
  </merror>
  <annotation-xml encoding="MathML-Content">
   <mtext>\Alpha</mtext>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Alpha
  </annotation>
 </semantics>
</math>

 are typically the letters 

<math display="inline" id="Propositional_calculus:130">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Propositional_calculus:131">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Propositional_calculus:132">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

, and so on.</li>
</ul>
<ul>
<li>The <em>omega set</em> 

<math display="inline" id="Propositional_calculus:133">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ω
  </annotation>
 </semantics>
</math>

 is a finite set of elements called <em><a href="Operation_(mathematics)" title="wikilink">operator symbols</a></em> or <em><a href="logical_connective" title="wikilink">logical connectives</a></em>. The set 

<math display="inline" id="Propositional_calculus:134">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ω
  </annotation>
 </semantics>
</math>

 is <a href="Partition_of_a_set" title="wikilink">partitioned</a> into disjoint subsets as follows:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Propositional_calculus:135">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi mathvariant="normal">Ω</mi>
      <mn>0</mn>
     </msub>
     <mo>∪</mo>
     <msub>
      <mi mathvariant="normal">Ω</mi>
      <mn>1</mn>
     </msub>
     <mo>∪</mo>
     <mi mathvariant="normal">…</mi>
     <mo>∪</mo>
     <msub>
      <mi mathvariant="normal">Ω</mi>
      <mi>j</mi>
     </msub>
     <mo>∪</mo>
     <mi mathvariant="normal">…</mi>
     <mo>∪</mo>
     <msub>
      <mi mathvariant="normal">Ω</mi>
      <mi>m</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Ω</ci>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ω</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ω</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ω</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ω</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega=\Omega_{0}\cup\Omega_{1}\cup\ldots\cup\Omega_{j}\cup\ldots\cup\Omega_{m}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>In this partition, 

<math display="inline" id="Propositional_calculus:136">
 <semantics>
  <msub>
   <mi mathvariant="normal">Ω</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Ω</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{j}
  </annotation>
 </semantics>
</math>

 is the set of operator symbols of <em><a class="uri" href="arity" title="wikilink">arity</a></em> 

<math display="inline" id="Propositional_calculus:137">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
<dl>
<dd>In the more familiar propositional calculi, 

<math display="inline" id="Propositional_calculus:138">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ω
  </annotation>
 </semantics>
</math>

 is typically partitioned as follows:
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Propositional_calculus:139">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Ω</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi mathvariant="normal">¬</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Ω</ci>
     <cn type="integer">1</cn>
    </apply>
    <set>
     <not></not>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{1}=\{\lnot\},
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Propositional_calculus:140">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Ω</mi>
     <mn>2</mn>
    </msub>
    <mo>⊆</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mo>∧</mo>
     <mo>,</mo>
     <mo>∨</mo>
     <mo>,</mo>
     <mo>→</mo>
     <mo>,</mo>
     <mo>↔</mo>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Ω</ci>
     <cn type="integer">2</cn>
    </apply>
    <set>
     <and></and>
     <or></or>
     <ci>normal-→</ci>
     <ci>normal-↔</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{2}\subseteq\{\land,\lor,\to,\leftrightarrow\}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>A frequently adopted convention treats the constant <a href="logical_value" title="wikilink">logical values</a> as operators of arity zero, thus:
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Propositional_calculus:141">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Ω</mi>
     <mn>0</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Ω</ci>
     <cn type="integer">0</cn>
    </apply>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{0}=\{0,1\}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>Some writers use the <a class="uri" href="tilde" title="wikilink">tilde</a> (~), or N, instead of 

<math display="inline" id="Propositional_calculus:142">
 <semantics>
  <mi mathvariant="normal">¬</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-¬</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ¬
  </annotation>
 </semantics>
</math>

; and some use the <a class="uri" href="ampersand" title="wikilink">ampersand</a> (&amp;), the prefixed K, or 

<math display="inline" id="Propositional_calculus:143">
 <semantics>
  <mo>⋅</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⋅</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdot
  </annotation>
 </semantics>
</math>

 instead of 

<math display="inline" id="Propositional_calculus:144">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>

. Notation varies even more for the set of logical values, with symbols like {false, true}, {F, T}, or 

<math display="inline" id="Propositional_calculus:145">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mo>⊥</mo>
   <mo>,</mo>
   <mo>⊤</mo>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <csymbol cd="latexml">bottom</csymbol>
    <csymbol cd="latexml">top</csymbol>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\bot,\top\}
  </annotation>
 </semantics>
</math>

 all being seen in various contexts instead of {0, 1}.
</dd>
</dl>
<ul>
<li>The <em>zeta set</em> 

<math display="inline" id="Propositional_calculus:146">
 <semantics>
  <merror class="ltx_ERROR undefined undefined">
   <mtext>\Zeta</mtext>
  </merror>
  <annotation-xml encoding="MathML-Content">
   <mtext>\Zeta</mtext>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Zeta
  </annotation>
 </semantics>
</math>

 is a finite set of <em>transformation rules</em> that are called <em><a href="inference_rule" title="wikilink">inference rules</a></em> when they acquire logical applications.</li>
</ul>
<ul>
<li>The <em>iota set</em> 

<math display="inline" id="Propositional_calculus:147">
 <semantics>
  <merror class="ltx_ERROR undefined undefined">
   <mtext>\Iota</mtext>
  </merror>
  <annotation-xml encoding="MathML-Content">
   <mtext>\Iota</mtext>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Iota
  </annotation>
 </semantics>
</math>

 is a finite set of <em>initial points</em> that are called <em><a href="axiom" title="wikilink">axioms</a></em> when they receive logical interpretations.</li>
</ul>

<p>The <em>language</em> of 

<math display="inline" id="Propositional_calculus:148">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℒ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℒ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{L}
  </annotation>
 </semantics>
</math>

, also known as its set of <em>formulas</em>, <em><a href="well-formed_formula" title="wikilink">well-formed formulas</a></em>, is <a href="inductive_definition" title="wikilink">inductively defined</a> by the following rules:</p>
<ol>
<li>Base: Any element of the alpha set 

<math display="inline" id="Propositional_calculus:149">
 <semantics>
  <merror class="ltx_ERROR undefined undefined">
   <mtext>\Alpha</mtext>
  </merror>
  <annotation-xml encoding="MathML-Content">
   <mtext>\Alpha</mtext>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Alpha
  </annotation>
 </semantics>
</math>

 is a formula of 

<math display="inline" id="Propositional_calculus:150">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℒ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℒ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{L}
  </annotation>
 </semantics>
</math>

.</li>
<li>If 

<math display="inline" id="Propositional_calculus:151">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>p</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>p</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>j</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1},p_{2},\ldots,p_{j}
  </annotation>
 </semantics>
</math>

 are formulas and 

<math display="inline" id="Propositional_calculus:152">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is in 

<math display="inline" id="Propositional_calculus:153">
 <semantics>
  <msub>
   <mi mathvariant="normal">Ω</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Ω</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{j}
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Propositional_calculus:154">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>p</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>p</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>p</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>j</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(f(p_{1},p_{2},\ldots,p_{j})\right)
  </annotation>
 </semantics>
</math>

 is a formula.</li>
<li>Closed: Nothing else is a formula of 

<math display="inline" id="Propositional_calculus:155">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℒ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℒ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{L}
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>Repeated applications of these rules permits the construction of complex formulas. For example:</p>
<ol>
<li>By rule 1, 

<math display="inline" id="Propositional_calculus:156">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is a formula.</li>
<li>By rule 2, 

<math display="inline" id="Propositional_calculus:157">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg p
  </annotation>
 </semantics>
</math>

 is a formula.</li>
<li>By rule 1, 

<math display="inline" id="Propositional_calculus:158">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 is a formula.</li>
<li>By rule 2, 

<math display="inline" id="Propositional_calculus:159">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>p</mi>
    </mrow>
    <mo>∨</mo>
    <mi>q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <times></times>
     <not></not>
     <ci>p</ci>
    </apply>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\neg p\lor q)
  </annotation>
 </semantics>
</math>

 is a formula.</li>
</ol>
<h2 id="example-1.-simple-axiom-system">Example 1. Simple axiom system</h2>

<p>Let 

<math display="inline" id="Propositional_calculus:160">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">ℒ</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℒ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\Alpha</mtext>
     </merror>
     <mo>,</mo>
     <mi mathvariant="normal">Ω</mi>
     <mo>,</mo>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\Zeta</mtext>
     </merror>
     <mo>,</mo>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\Iota</mtext>
     </merror>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℒ</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>ℒ</ci>
     <vector>
      <mtext>\Alpha</mtext>
      <ci>normal-Ω</ci>
      <mtext>\Zeta</mtext>
      <mtext>\Iota</mtext>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{L}_{1}=\mathcal{L}(\Alpha,\Omega,\Zeta,\Iota)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Propositional_calculus:161">
 <semantics>
  <merror class="ltx_ERROR undefined undefined">
   <mtext>\Alpha</mtext>
  </merror>
  <annotation-xml encoding="MathML-Content">
   <mtext>\Alpha</mtext>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Alpha
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Propositional_calculus:162">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Propositional_calculus:163">
 <semantics>
  <merror class="ltx_ERROR undefined undefined">
   <mtext>\Zeta</mtext>
  </merror>
  <annotation-xml encoding="MathML-Content">
   <mtext>\Zeta</mtext>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Zeta
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Propositional_calculus:164">
 <semantics>
  <merror class="ltx_ERROR undefined undefined">
   <mtext>\Iota</mtext>
  </merror>
  <annotation-xml encoding="MathML-Content">
   <mtext>\Iota</mtext>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Iota
  </annotation>
 </semantics>
</math>

 are defined as follows:</p>
<ul>
<li>The alpha set 

<math display="inline" id="Propositional_calculus:165">
 <semantics>
  <merror class="ltx_ERROR undefined undefined">
   <mtext>\Alpha</mtext>
  </merror>
  <annotation-xml encoding="MathML-Content">
   <mtext>\Alpha</mtext>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Alpha
  </annotation>
 </semantics>
</math>

, is a finite set of symbols that is large enough to supply the needs of a given discussion, for example:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Propositional_calculus:166">
 <semantics>
  <mrow>
   <mrow>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\Alpha</mtext>
    </merror>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>p</mi>
     <mo>,</mo>
     <mi>q</mi>
     <mo>,</mo>
     <mi>r</mi>
     <mo>,</mo>
     <mi>s</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mi>u</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>\Alpha</mtext>
    <set>
     <ci>p</ci>
     <ci>q</ci>
     <ci>r</ci>
     <ci>s</ci>
     <ci>t</ci>
     <ci>u</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Alpha=\{p,q,r,s,t,u\}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li>Of the three connectives for conjunction, disjunction, and implication (

<math display="inline" id="Propositional_calculus:167">
 <semantics>
  <mrow>
   <mo>∧</mo>
   <mo>,</mo>
   <mo>∨</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <and></and>
    <or></or>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge,\lor
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Propositional_calculus:168">
 <semantics>
  <mi mathvariant="normal">→</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   →
  </annotation>
 </semantics>
</math>

), one can be taken as primitive and the other two can be defined in terms of it and negation (

<math display="inline" id="Propositional_calculus:169">
 <semantics>
  <mi mathvariant="normal">¬</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-¬</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ¬
  </annotation>
 </semantics>
</math>

).<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> Indeed, all of the logical connectives can be defined in terms of a <a href="sole_sufficient_operator" title="wikilink">sole sufficient operator</a>. The biconditional (

<math display="inline" id="Propositional_calculus:170">
 <semantics>
  <mi mathvariant="normal">↔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ↔
  </annotation>
 </semantics>
</math>

) can of course be defined in terms of conjunction and implication, with 

<math display="inline" id="Propositional_calculus:171">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>↔</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\leftrightarrow b
  </annotation>
 </semantics>
</math>

 defined as 

<math display="inline" id="Propositional_calculus:172">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>→</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo>→</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a\to b)\land(b\to a)
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<dl>
<dd>Adopting negation and implication as the two primitive operations of a propositional calculus is tantamount to having the omega set 

<math display="inline" id="Propositional_calculus:173">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi mathvariant="normal">Ω</mi>
     <mn>1</mn>
    </msub>
    <mo>∪</mo>
    <msub>
     <mi mathvariant="normal">Ω</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Ω</ci>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ω</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ω</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega=\Omega_{1}\cup\Omega_{2}
  </annotation>
 </semantics>
</math>

 partition as follows:
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Propositional_calculus:174">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Ω</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi mathvariant="normal">¬</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Ω</ci>
     <cn type="integer">1</cn>
    </apply>
    <set>
     <not></not>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{1}=\{\lnot\},
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Propositional_calculus:175">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Ω</mi>
     <mn>2</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mo>→</mo>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Ω</ci>
     <cn type="integer">2</cn>
    </apply>
    <set>
     <ci>normal-→</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{2}=\{\to\}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li>An axiom system discovered by <a href="Jan_Łukasiewicz" title="wikilink">Jan Łukasiewicz</a> formulates a propositional calculus in this language as follows. The axioms are all <a href="substitution_instance" title="wikilink">substitution instances</a> of:</li>
</ul>

<p>::* 

<math display="inline" id="Propositional_calculus:176">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>p</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>→</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\to(q\to p))
  </annotation>
 </semantics>
</math>

</p>

<p>::* 

<math display="inline" id="Propositional_calculus:177">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>q</mi>
     <mo>→</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo>→</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo>→</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">r</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">r</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((p\to(q\to r))\to((p\to q)\to(p\to r)))
  </annotation>
 </semantics>
</math>

</p>

<p>::* 

<math display="inline" id="Propositional_calculus:178">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>p</mi>
    <mo>→</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>→</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <not></not>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-→</ci>
     <not></not>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((\neg p\to\neg q)\to(q\to p))
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>The rule of inference is <a href="modus_ponens" title="wikilink">modus ponens</a> (i.e., from 

<math display="inline" id="Propositional_calculus:179">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:180">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>p</mi>
    <mo>→</mo>
    <mi>q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\to q)
  </annotation>
 </semantics>
</math>

, infer 

<math display="inline" id="Propositional_calculus:181">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

). Then 

<math display="inline" id="Propositional_calculus:182">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∨</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\lor b
  </annotation>
 </semantics>
</math>

 is defined as 

<math display="inline" id="Propositional_calculus:183">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>a</mi>
   </mrow>
   <mo>→</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>a</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg a\to b
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Propositional_calculus:184">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∧</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\land b
  </annotation>
 </semantics>
</math>

 is defined as 

<math display="inline" id="Propositional_calculus:185">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>a</mi>
     <mo>→</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>b</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <not></not>
    <apply>
     <ci>normal-→</ci>
     <ci>a</ci>
     <apply>
      <times></times>
      <not></not>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg(a\to\neg b)
  </annotation>
 </semantics>
</math>

. This system is used in <a class="uri" href="Metamath" title="wikilink">Metamath</a> <a href="http://us.metamath.org/mpegif/mmset.html#scaxioms">set.mm</a> formal proof database.</li>
</ul>
<h2 id="example-2.-natural-deduction-system">Example 2. Natural deduction system</h2>

<p>Let 

<math display="inline" id="Propositional_calculus:186">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">ℒ</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℒ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\Alpha</mtext>
     </merror>
     <mo>,</mo>
     <mi mathvariant="normal">Ω</mi>
     <mo>,</mo>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\Zeta</mtext>
     </merror>
     <mo>,</mo>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\Iota</mtext>
     </merror>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℒ</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <ci>ℒ</ci>
     <vector>
      <mtext>\Alpha</mtext>
      <ci>normal-Ω</ci>
      <mtext>\Zeta</mtext>
      <mtext>\Iota</mtext>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{L}_{2}=\mathcal{L}(\Alpha,\Omega,\Zeta,\Iota)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Propositional_calculus:187">
 <semantics>
  <merror class="ltx_ERROR undefined undefined">
   <mtext>\Alpha</mtext>
  </merror>
  <annotation-xml encoding="MathML-Content">
   <mtext>\Alpha</mtext>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Alpha
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Propositional_calculus:188">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Propositional_calculus:189">
 <semantics>
  <merror class="ltx_ERROR undefined undefined">
   <mtext>\Zeta</mtext>
  </merror>
  <annotation-xml encoding="MathML-Content">
   <mtext>\Zeta</mtext>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Zeta
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Propositional_calculus:190">
 <semantics>
  <merror class="ltx_ERROR undefined undefined">
   <mtext>\Iota</mtext>
  </merror>
  <annotation-xml encoding="MathML-Content">
   <mtext>\Iota</mtext>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Iota
  </annotation>
 </semantics>
</math>

 are defined as follows:</p>
<ul>
<li>The alpha set 

<math display="inline" id="Propositional_calculus:191">
 <semantics>
  <merror class="ltx_ERROR undefined undefined">
   <mtext>\Alpha</mtext>
  </merror>
  <annotation-xml encoding="MathML-Content">
   <mtext>\Alpha</mtext>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Alpha
  </annotation>
 </semantics>
</math>

, is a finite set of symbols that is large enough to supply the needs of a given discussion, for example:

<p>

<math display="block" id="Propositional_calculus:192">
 <semantics>
  <mrow>
   <mrow>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\Alpha</mtext>
    </merror>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>p</mi>
     <mo>,</mo>
     <mi>q</mi>
     <mo>,</mo>
     <mi>r</mi>
     <mo>,</mo>
     <mi>s</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mi>u</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>\Alpha</mtext>
    <set>
     <ci>p</ci>
     <ci>q</ci>
     <ci>r</ci>
     <ci>s</ci>
     <ci>t</ci>
     <ci>u</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Alpha=\{p,q,r,s,t,u\}.
  </annotation>
 </semantics>
</math>

</p></li>
<li>The omega set 

<math display="inline" id="Propositional_calculus:193">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi mathvariant="normal">Ω</mi>
     <mn>1</mn>
    </msub>
    <mo>∪</mo>
    <msub>
     <mi mathvariant="normal">Ω</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Ω</ci>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ω</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ω</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega=\Omega_{1}\cup\Omega_{2}
  </annotation>
 </semantics>
</math>

 partitions as follows:

<p>

<math display="block" id="Propositional_calculus:194">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Ω</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi mathvariant="normal">¬</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Ω</ci>
     <cn type="integer">1</cn>
    </apply>
    <set>
     <not></not>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{1}=\{\lnot\},
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Propositional_calculus:195">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Ω</mi>
     <mn>2</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mo>∧</mo>
     <mo>,</mo>
     <mo>∨</mo>
     <mo>,</mo>
     <mo>→</mo>
     <mo>,</mo>
     <mo>↔</mo>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Ω</ci>
     <cn type="integer">2</cn>
    </apply>
    <set>
     <and></and>
     <or></or>
     <ci>normal-→</ci>
     <ci>normal-↔</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{2}=\{\land,\lor,\to,\leftrightarrow\}.
  </annotation>
 </semantics>
</math>

</p></li>
</ul>

<p>In the following example of a propositional calculus, the transformation rules are intended to be interpreted as the inference rules of a so-called <em><a href="natural_deduction_system" title="wikilink">natural deduction system</a></em>. The particular system presented here has no initial points, which means that its interpretation for logical applications derives its <a href="theorem" title="wikilink">theorems</a> from an empty axiom set.</p>
<ul>
<li>The set of initial points is empty, that is, 

<math display="inline" id="Propositional_calculus:196">
 <semantics>
  <mrow>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\Iota</mtext>
   </merror>
   <mo>=</mo>
   <mi mathvariant="normal">∅</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>\Iota</mtext>
    <emptyset></emptyset>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Iota=\varnothing
  </annotation>
 </semantics>
</math>

.</li>
<li>The set of transformation rules, 

<math display="inline" id="Propositional_calculus:197">
 <semantics>
  <merror class="ltx_ERROR undefined undefined">
   <mtext>\Zeta</mtext>
  </merror>
  <annotation-xml encoding="MathML-Content">
   <mtext>\Zeta</mtext>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Zeta
  </annotation>
 </semantics>
</math>

, is described as follows:</li>
</ul>

<p>Our propositional calculus has ten inference rules. These rules allow us to derive other true formulas given a set of formulas that are assumed to be true. The first nine simply state that we can infer certain well-formed formulas from other well-formed formulas. The last rule however uses hypothetical reasoning in the sense that in the premise of the rule we temporarily assume an (unproven) hypothesis to be part of the set of inferred formulas to see if we can infer a certain other formula. Since the first nine rules don't do this they are usually described as <em>non-hypothetical</em> rules, and the last one as a <em>hypothetical</em> rule.</p>

<p>In describing the transformation rules, we may introduce a metalanguage symbol 

<math display="inline" id="Propositional_calculus:198">
 <semantics>
  <mo>⊢</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">proves</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash
  </annotation>
 </semantics>
</math>

. It is basically a convenient shorthand for saying "infer that". The format is 

<math display="inline" id="Propositional_calculus:199">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash\psi
  </annotation>
 </semantics>
</math>

, in which 

<math display="inline" id="Propositional_calculus:200">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Γ
  </annotation>
 </semantics>
</math>

 is a (possibly empty) set of formulas called premises, and 

<math display="inline" id="Propositional_calculus:201">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ψ
  </annotation>
 </semantics>
</math>

 is a formula called conclusion. The transformation rule 

<math display="inline" id="Propositional_calculus:202">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash\psi
  </annotation>
 </semantics>
</math>

 means that if every proposition in 

<math display="inline" id="Propositional_calculus:203">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Γ
  </annotation>
 </semantics>
</math>

 is a theorem (or has the same truth value as the axioms), then 

<math display="inline" id="Propositional_calculus:204">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ψ
  </annotation>
 </semantics>
</math>

 is also a theorem. Note that considering the following rule <a href="Conjunction_introduction" title="wikilink">Conjunction introduction</a>, we will know whenever 

<math display="inline" id="Propositional_calculus:205">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Γ
  </annotation>
 </semantics>
</math>

 has more than one formula, we can always safely reduce it into one formula using conjunction. So for short, from that time on we may represent 

<math display="inline" id="Propositional_calculus:206">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Γ
  </annotation>
 </semantics>
</math>

 as one formula instead of a set. Another omission for convenience is when 

<math display="inline" id="Propositional_calculus:207">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Γ
  </annotation>
 </semantics>
</math>

 is an empty set, in which case 

<math display="inline" id="Propositional_calculus:208">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Γ
  </annotation>
 </semantics>
</math>

 may not appear.</p>
<dl>
<dt><a href="Negation_introduction" title="wikilink">Negation introduction</a>: From 

<math display="inline" id="Propositional_calculus:209">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>p</mi>
    <mo>→</mo>
    <mi>q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\to q)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:210">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>p</mi>
    <mo>→</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>q</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>p</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\to\neg q)
  </annotation>
 </semantics>
</math>

, infer 

<math display="inline" id="Propositional_calculus:211">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg p
  </annotation>
 </semantics>
</math>

.</dt>
<dd>That is, 

<math display="inline" id="Propositional_calculus:212">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo>→</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo>→</mo>
     <mi mathvariant="normal">¬</mi>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>⊢</mo>
   <mi mathvariant="normal">¬</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-→</ci>
      <not></not>
      <csymbol cd="unknown">q</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-}</ci>
    </cerror>
    <csymbol cd="latexml">proves</csymbol>
    <not></not>
    <csymbol cd="unknown">p</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(p\to q),(p\to\neg q)\}\vdash\neg p
  </annotation>
 </semantics>
</math>

.
</dd>
<dt><a href="Negation_elimination" title="wikilink">Negation elimination</a>: From 

<math display="inline" id="Propositional_calculus:213">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg p
  </annotation>
 </semantics>
</math>

, infer 

<math display="inline" id="Propositional_calculus:214">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>p</mi>
    <mo>→</mo>
    <mi>r</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>p</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\to r)
  </annotation>
 </semantics>
</math>

.</dt>
<dd>That is, 

<math display="inline" id="Propositional_calculus:215">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>p</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>→</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <not></not>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-}</ci>
    </cerror>
    <csymbol cd="latexml">proves</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\neg p\}\vdash(p\to r)
  </annotation>
 </semantics>
</math>

.
</dd>
<dt><a href="Double_negative_elimination" title="wikilink">Double negative elimination</a>: From 

<math display="inline" id="Propositional_calculus:216">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi mathvariant="normal">¬</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <not></not>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\neg p
  </annotation>
 </semantics>
</math>

, infer 

<math display="inline" id="Propositional_calculus:217">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

.</dt>
<dd>That is, 

<math display="inline" id="Propositional_calculus:218">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi mathvariant="normal">¬</mi>
    <mi>p</mi>
   </mrow>
   <mo>⊢</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <apply>
     <times></times>
     <not></not>
     <not></not>
     <ci>p</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\neg p\vdash p
  </annotation>
 </semantics>
</math>

.
</dd>
<dt><a href="Conjunction_introduction" title="wikilink">Conjunction introduction</a>: From 

<math display="inline" id="Propositional_calculus:219">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:220">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

, infer 

<math display="inline" id="Propositional_calculus:221">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>p</mi>
    <mo>∧</mo>
    <mi>q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\land q)
  </annotation>
 </semantics>
</math>

.</dt>
<dd>That is, 

<math display="inline" id="Propositional_calculus:222">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>p</mi>
     <mo>∧</mo>
     <mi>q</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <set>
     <ci>p</ci>
     <ci>q</ci>
    </set>
    <apply>
     <and></and>
     <ci>p</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{p,q\}\vdash(p\land q)
  </annotation>
 </semantics>
</math>

.
</dd>
<dt><a href="Conjunction_elimination" title="wikilink">Conjunction elimination</a>: From 

<math display="inline" id="Propositional_calculus:223">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>p</mi>
    <mo>∧</mo>
    <mi>q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\land q)
  </annotation>
 </semantics>
</math>

, infer 

<math display="inline" id="Propositional_calculus:224">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

.</dt>
<dd>From 

<math display="inline" id="Propositional_calculus:225">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>p</mi>
    <mo>∧</mo>
    <mi>q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\land q)
  </annotation>
 </semantics>
</math>

, infer 

<math display="inline" id="Propositional_calculus:226">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

.
</dd>
<dd>That is, 

<math display="inline" id="Propositional_calculus:227">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>p</mi>
     <mo>∧</mo>
     <mi>q</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <apply>
     <and></and>
     <ci>p</ci>
     <ci>q</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\land q)\vdash p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:228">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>p</mi>
     <mo>∧</mo>
     <mi>q</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <apply>
     <and></and>
     <ci>p</ci>
     <ci>q</ci>
    </apply>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\land q)\vdash q
  </annotation>
 </semantics>
</math>

.
</dd>
<dt><a href="Disjunction_introduction" title="wikilink">Disjunction introduction</a>: From 

<math display="inline" id="Propositional_calculus:229">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, infer 

<math display="inline" id="Propositional_calculus:230">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>p</mi>
    <mo>∨</mo>
    <mi>q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\lor q)
  </annotation>
 </semantics>
</math>

.</dt>
<dd>From 

<math display="inline" id="Propositional_calculus:231">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

, infer 

<math display="inline" id="Propositional_calculus:232">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>p</mi>
    <mo>∨</mo>
    <mi>q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\lor q)
  </annotation>
 </semantics>
</math>

.
</dd>
<dd>That is, 

<math display="inline" id="Propositional_calculus:233">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>p</mi>
     <mo>∨</mo>
     <mi>q</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>p</ci>
    <apply>
     <or></or>
     <ci>p</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\vdash(p\lor q)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:234">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>p</mi>
     <mo>∨</mo>
     <mi>q</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>q</ci>
    <apply>
     <or></or>
     <ci>p</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\vdash(p\lor q)
  </annotation>
 </semantics>
</math>

.
</dd>
<dt><a href="Disjunction_elimination" title="wikilink">Disjunction elimination</a>: From 

<math display="inline" id="Propositional_calculus:235">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>p</mi>
    <mo>∨</mo>
    <mi>q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\lor q)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:236">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>p</mi>
    <mo>→</mo>
    <mi>r</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>p</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\to r)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:237">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>q</mi>
    <mo>→</mo>
    <mi>r</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>q</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (q\to r)
  </annotation>
 </semantics>
</math>

, infer 

<math display="inline" id="Propositional_calculus:238">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

.</dt>
<dd>That is, 

<math display="inline" id="Propositional_calculus:239">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>p</mi>
    <mo>∨</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mi>p</mi>
    <mo>→</mo>
    <mi>r</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo>→</mo>
    <mi>r</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>⊢</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">p</csymbol>
     <or></or>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-}</ci>
    </cerror>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="unknown">r</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{p\lor q,p\to r,q\to r\}\vdash r
  </annotation>
 </semantics>
</math>

.
</dd>
<dt><a href="Biconditional_introduction" title="wikilink">Biconditional introduction</a>: From 

<math display="inline" id="Propositional_calculus:240">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>p</mi>
    <mo>→</mo>
    <mi>q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\to q)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:241">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>q</mi>
    <mo>→</mo>
    <mi>p</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>q</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (q\to p)
  </annotation>
 </semantics>
</math>

, infer 

<math display="inline" id="Propositional_calculus:242">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>p</mi>
    <mo>↔</mo>
    <mi>q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\leftrightarrow q)
  </annotation>
 </semantics>
</math>

.</dt>
<dd>That is, 

<math display="inline" id="Propositional_calculus:243">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>p</mi>
    <mo>→</mo>
    <mi>q</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo>→</mo>
    <mi>p</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>↔</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-}</ci>
    </cerror>
    <csymbol cd="latexml">proves</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-↔</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{p\to q,q\to p\}\vdash(p\leftrightarrow q)
  </annotation>
 </semantics>
</math>

.
</dd>
<dt><a href="Biconditional_elimination" title="wikilink">Biconditional elimination</a>: From 

<math display="inline" id="Propositional_calculus:244">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>p</mi>
    <mo>↔</mo>
    <mi>q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\leftrightarrow q)
  </annotation>
 </semantics>
</math>

, infer 

<math display="inline" id="Propositional_calculus:245">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>p</mi>
    <mo>→</mo>
    <mi>q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\to q)
  </annotation>
 </semantics>
</math>

.</dt>
<dd>From 

<math display="inline" id="Propositional_calculus:246">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>p</mi>
    <mo>↔</mo>
    <mi>q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\leftrightarrow q)
  </annotation>
 </semantics>
</math>

, infer 

<math display="inline" id="Propositional_calculus:247">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>q</mi>
    <mo>→</mo>
    <mi>p</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>q</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (q\to p)
  </annotation>
 </semantics>
</math>

.
</dd>
<dd>That is, 

<math display="inline" id="Propositional_calculus:248">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>↔</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>→</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-↔</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proves</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\leftrightarrow q)\vdash(p\to q)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:249">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>↔</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>→</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-↔</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proves</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\leftrightarrow q)\vdash(q\to p)
  </annotation>
 </semantics>
</math>

.
</dd>
<dt><a href="Modus_ponens" title="wikilink">Modus ponens</a> (conditional elimination) : From 

<math display="inline" id="Propositional_calculus:250">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:251">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>p</mi>
    <mo>→</mo>
    <mi>q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\to q)
  </annotation>
 </semantics>
</math>

, infer 

<math display="inline" id="Propositional_calculus:252">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

.</dt>
<dd>That is, 

<math display="inline" id="Propositional_calculus:253">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>p</mi>
    <mo>→</mo>
    <mi>q</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>⊢</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-}</ci>
    </cerror>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="unknown">q</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{p,p\to q\}\vdash q
  </annotation>
 </semantics>
</math>

.
</dd>
<dt><a href="Conditional_proof" title="wikilink">Conditional proof</a> (conditional introduction) : From [accepting 

<math display="inline" id="Propositional_calculus:254">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 allows a proof of 

<math display="inline" id="Propositional_calculus:255">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

], infer 

<math display="inline" id="Propositional_calculus:256">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>p</mi>
    <mo>→</mo>
    <mi>q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\to q)
  </annotation>
 </semantics>
</math>

.</dt>
<dd>That is, 

<math display="inline" id="Propositional_calculus:257">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>⊢</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>→</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proves</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\vdash q)\vdash(p\to q)
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
<h2 id="basic-and-derived-argument-forms">Basic and derived argument forms</h2>

<p><span id="propcalc_table"></span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>style="text-align:center;" Basic and Derived Argument Forms</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Name</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Modus_Ponens" title="wikilink">Modus Ponens</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Modus_Tollens" title="wikilink">Modus Tollens</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Hypothetical_Syllogism" title="wikilink">Hypothetical Syllogism</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Disjunctive_syllogism" title="wikilink">Disjunctive Syllogism</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Constructive_dilemma" title="wikilink">Constructive Dilemma</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Destructive_dilemma" title="wikilink">Destructive Dilemma</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Bidirectional Dilemma</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Conjunction_elimination" title="wikilink">Simplification</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Logical_conjunction" title="wikilink">Conjunction</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Logical_disjunction" title="wikilink">Addition</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Distributive_property" title="wikilink">Composition</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="De_Morgan's_laws" title="wikilink">De Morgan's Theorem</a> (1)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="De_Morgan's_laws" title="wikilink">De Morgan's Theorem</a> (2)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Commutative_property" title="wikilink">Commutation</a> (1)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Commutative_property" title="wikilink">Commutation</a> (2)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Commutative_property" title="wikilink">Commutation</a> (3)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Associative_property" title="wikilink">Association</a> (1)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Associative_property" title="wikilink">Association</a> (2)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Distributive_property" title="wikilink">Distribution</a> (1)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Distributive_property" title="wikilink">Distribution</a> (2)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Double_negative_elimination" title="wikilink">Double Negation</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Transposition_(logic)" title="wikilink">Transposition</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Material_implication_(rule_of_inference)" title="wikilink">Material Implication</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Material_equivalence" title="wikilink">Material Equivalence</a> (1)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Material_equivalence" title="wikilink">Material Equivalence</a> (2)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Material_equivalence" title="wikilink">Material Equivalence</a> (3)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Exportation_(logic)" title="wikilink">Exportation</a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Exportation_(logic)" title="wikilink">Importation</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Tautology_(rule_of_inference)" title="wikilink">Tautology</a> (1)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Tautology_(rule_of_inference)" title="wikilink">Tautology</a> (2)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Law_of_excluded_middle" title="wikilink">Tertium non datur (Law of Excluded Middle)</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Law_of_noncontradiction" title="wikilink">Law of Non-Contradiction</a></p></td>
</tr>
</tbody>
</table>
<h2 id="proofs-in-propositional-calculus">Proofs in propositional calculus</h2>

<p>One of the main uses of a propositional calculus, when interpreted for logical applications, is to determine relations of logical equivalence between propositional formulas. These relationships are determined by means of the available transformation rules, sequences of which are called <em>derivations</em> or <em>proofs</em>.</p>

<p>In the discussion to follow, a proof is presented as a sequence of numbered lines, with each line consisting of a single formula followed by a <em>reason</em> or <em>justification</em> for introducing that formula. Each premise of the argument, that is, an assumption introduced as an hypothesis of the argument, is listed at the beginning of the sequence and is marked as a "premise" in lieu of other justification. The conclusion is listed on the last line. A proof is complete if every line follows from the previous ones by the correct application of a transformation rule. (For a contrasting approach, see <a href="Method_of_analytic_tableaux" title="wikilink">proof-trees</a>).</p>
<h3 id="example-of-a-proof">Example of a proof</h3>
<ul>
<li>To be shown that 

<math display="inline" id="Propositional_calculus:258">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi mathvariant="normal">→</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>normal-→</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A→A
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li>One possible proof of this (which, though valid, happens to contain more steps than are necessary) may be arranged as follows:</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>style="text-align:center;" Example of a Proof</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Number</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>4</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>5</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>6</p></td>
</tr>
</tbody>
</table>

<p>Interpret 

<math display="inline" id="Propositional_calculus:259">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>⊢</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>A</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\vdash A
  </annotation>
 </semantics>
</math>

 as "Assuming 

<math display="inline" id="Propositional_calculus:260">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, infer 

<math display="inline" id="Propositional_calculus:261">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

". Read 

<math display="inline" id="Propositional_calculus:262">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mrow>
    <mi>A</mi>
    <mo>→</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <ci>normal-→</ci>
     <ci>A</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash A\to A
  </annotation>
 </semantics>
</math>

 as "Assuming nothing, infer that 

<math display="inline" id="Propositional_calculus:263">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Propositional_calculus:264">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

", or "It is a tautology that 

<math display="inline" id="Propositional_calculus:265">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Propositional_calculus:266">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

", or "It is always true that 

<math display="inline" id="Propositional_calculus:267">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Propositional_calculus:268">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

".</p>
<h2 id="soundness-and-completeness-of-the-rules">Soundness and completeness of the rules</h2>

<p>The crucial properties of this set of rules are that they are <em><a href="soundness" title="wikilink">sound</a></em> and <em>complete</em>. Informally this means that the rules are correct and that no other rules are required. These claims can be made more formal as follows.</p>

<p>We define a <em>truth assignment</em> as a <a href="function_(mathematics)" title="wikilink">function</a> that maps propositional variables to <strong>true</strong> or <strong>false</strong>. Informally such a truth assignment can be understood as the description of a possible <a href="State_of_affairs_(philosophy)" title="wikilink">state of affairs</a> (or <a href="possible_world" title="wikilink">possible world</a>) where certain statements are true and others are not. The semantics of formulas can then be formalized by defining for which "state of affairs" they are considered to be true, which is what is done by the following definition.</p>

<p>We define when such a truth assignment 

<math display="inline" id="Propositional_calculus:269">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 satisfies a certain <a href="well-formed_formula" title="wikilink">well-formed formula</a> with the following rules:</p>
<ul>
<li>

<math display="inline" id="Propositional_calculus:270">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 satisfies the propositional variable 

<math display="inline" id="Propositional_calculus:271">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 <a href="if_and_only_if" title="wikilink">if and only if</a> 

<math display="inline" id="Propositional_calculus:272">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>P</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>t</mi>
    <mi>r</mi>
    <mi>u</mi>
    <mi>e</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>P</ci>
    </apply>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>r</ci>
     <ci>u</ci>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(P)=true
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Propositional_calculus:273">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 satisfies 

<math display="inline" id="Propositional_calculus:274">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-¬</ci>
    <ci>φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ¬φ
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Propositional_calculus:275">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 does not satisfy 

<math display="inline" id="Propositional_calculus:276">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Propositional_calculus:277">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 satisfies 

<math display="inline" id="Propositional_calculus:278">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>φ</mi>
    <mi mathvariant="normal">∧</mi>
    <mi>ψ</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>φ</ci>
    <ci>normal-∧</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (φ∧ψ)
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Propositional_calculus:279">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 satisfies both 

<math display="inline" id="Propositional_calculus:280">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:281">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ψ
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Propositional_calculus:282">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 satisfies 

<math display="inline" id="Propositional_calculus:283">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>φ</mi>
    <mi mathvariant="normal">∨</mi>
    <mi>ψ</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>φ</ci>
    <ci>normal-∨</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (φ∨ψ)
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Propositional_calculus:284">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 satisfies at least one of either 

<math display="inline" id="Propositional_calculus:285">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Propositional_calculus:286">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ψ
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Propositional_calculus:287">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 satisfies 

<math display="inline" id="Propositional_calculus:288">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>φ</mi>
    <mi mathvariant="normal">→</mi>
    <mi>ψ</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>φ</ci>
    <ci>normal-→</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (φ→ψ)
  </annotation>
 </semantics>
</math>

 if and only if it is not the case that 

<math display="inline" id="Propositional_calculus:289">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 satisfies 

<math display="inline" id="Propositional_calculus:290">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 but not 

<math display="inline" id="Propositional_calculus:291">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ψ
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Propositional_calculus:292">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 satisfies 

<math display="inline" id="Propositional_calculus:293">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>φ</mi>
    <mi mathvariant="normal">↔</mi>
    <mi>ψ</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>φ</ci>
    <ci>normal-↔</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (φ↔ψ)
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Propositional_calculus:294">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 satisfies both 

<math display="inline" id="Propositional_calculus:295">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:296">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ψ
  </annotation>
 </semantics>
</math>

 or satisfies neither one of them</li>
</ul>

<p>With this definition we can now formalize what it means for a formula 

<math display="inline" id="Propositional_calculus:297">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 to be implied by a certain set 

<math display="inline" id="Propositional_calculus:298">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 of formulas. Informally this is true if in all worlds that are possible given the set of formulas 

<math display="inline" id="Propositional_calculus:299">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 the formula 

<math display="inline" id="Propositional_calculus:300">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 also holds. This leads to the following formal definition: We say that a set 

<math display="inline" id="Propositional_calculus:301">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 of well-formed formulas <em>semantically entails</em> (or <em>implies</em>) a certain well-formed formula 

<math display="inline" id="Propositional_calculus:302">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 if all truth assignments that satisfy all the formulas in 

<math display="inline" id="Propositional_calculus:303">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 also satisfy 

<math display="inline" id="Propositional_calculus:304">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

.</p>

<p>Finally we define <em>syntactical entailment</em> such that 

<math display="inline" id="Propositional_calculus:305">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 is syntactically entailed by 

<math display="inline" id="Propositional_calculus:306">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 if and only if we can derive it with the inference rules that were presented above in a finite number of steps. This allows us to formulate exactly what it means for the set of inference rules to be sound and complete:</p>

<p><strong>Soundness:</strong> If the set of well-formed formulas 

<math display="inline" id="Propositional_calculus:307">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 syntactically entails the well-formed formula 

<math display="inline" id="Propositional_calculus:308">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Propositional_calculus:309">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 semantically entails 

<math display="inline" id="Propositional_calculus:310">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

.</p>

<p><strong>Completeness:</strong> If the set of well-formed formulas 

<math display="inline" id="Propositional_calculus:311">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 semantically entails the well-formed formula 

<math display="inline" id="Propositional_calculus:312">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Propositional_calculus:313">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 syntactically entails 

<math display="inline" id="Propositional_calculus:314">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

.</p>

<p>For the above set of rules this is indeed the case.</p>
<h3 id="sketch-of-a-soundness-proof">Sketch of a soundness proof</h3>

<p>(For most <a href="logical_system" title="wikilink">logical systems</a>, this is the comparatively "simple" direction of proof)</p>

<p>Notational conventions: Let 

<math display="inline" id="Propositional_calculus:315">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 be a variable ranging over sets of sentences. Let 

<math display="inline" id="Propositional_calculus:316">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>,</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>A</ci>
    <ci>B</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A,B
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:317">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 range over sentences. For "

<math display="inline" id="Propositional_calculus:318">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 syntactically entails 

<math display="inline" id="Propositional_calculus:319">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

" we write "

<math display="inline" id="Propositional_calculus:320">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 proves 

<math display="inline" id="Propositional_calculus:321">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

". For "

<math display="inline" id="Propositional_calculus:322">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 semantically entails 

<math display="inline" id="Propositional_calculus:323">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

" we write "

<math display="inline" id="Propositional_calculus:324">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Propositional_calculus:325">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

".</p>

<p>We want to show: 

<math display="inline" id="Propositional_calculus:326">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A)(G)
  </annotation>
 </semantics>
</math>

 (if 

<math display="inline" id="Propositional_calculus:327">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 proves 

<math display="inline" id="Propositional_calculus:328">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Propositional_calculus:329">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Propositional_calculus:330">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

).</p>

<p>We note that "

<math display="inline" id="Propositional_calculus:331">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 proves 

<math display="inline" id="Propositional_calculus:332">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

" has an inductive definition, and that gives us the immediate resources for demonstrating claims of the form "If 

<math display="inline" id="Propositional_calculus:333">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 proves 

<math display="inline" id="Propositional_calculus:334">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, then ...". So our proof proceeds by induction.</p>

<p>Notice that Basis Step II can be omitted for <a href="natural_deduction" title="wikilink">natural deduction</a> systems because they have no axioms. When used, Step II involves showing that each of the axioms is a (semantic) <a href="logical_truth" title="wikilink">logical truth</a>.</p>

<p>The Basis steps demonstrate that the simplest provable sentences from 

<math display="inline" id="Propositional_calculus:335">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 are also implied by 

<math display="inline" id="Propositional_calculus:336">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, for any 

<math display="inline" id="Propositional_calculus:337">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

. (The proof is simple, since the semantic fact that a set implies any of its members, is also trivial.) The Inductive step will systematically cover all the further sentences that might be provable—by considering each case where we might reach a logical conclusion using an inference rule—and shows that if a new sentence is provable, it is also logically implied. (For example, we might have a rule telling us that from "

<math display="inline" id="Propositional_calculus:338">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

" we can derive "

<math display="inline" id="Propositional_calculus:339">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Propositional_calculus:340">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

". In III.a We assume that if 

<math display="inline" id="Propositional_calculus:341">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is provable it is implied. We also know that if 

<math display="inline" id="Propositional_calculus:342">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is provable then "

<math display="inline" id="Propositional_calculus:343">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Propositional_calculus:344">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

" is provable. We have to show that then "

<math display="inline" id="Propositional_calculus:345">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Propositional_calculus:346">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

" too is implied. We do so by appeal to the semantic definition and the assumption we just made. 

<math display="inline" id="Propositional_calculus:347">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is provable from 

<math display="inline" id="Propositional_calculus:348">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, we assume. So it is also implied by 

<math display="inline" id="Propositional_calculus:349">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

. So any semantic valuation making all of 

<math display="inline" id="Propositional_calculus:350">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 true makes 

<math display="inline" id="Propositional_calculus:351">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 true. But any valuation making 

<math display="inline" id="Propositional_calculus:352">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 true makes "

<math display="inline" id="Propositional_calculus:353">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Propositional_calculus:354">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

" true, by the defined semantics for "or". So any valuation which makes all of 

<math display="inline" id="Propositional_calculus:355">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 true makes "

<math display="inline" id="Propositional_calculus:356">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Propositional_calculus:357">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

" true. So "

<math display="inline" id="Propositional_calculus:358">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Propositional_calculus:359">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

" is implied.) Generally, the Inductive step will consist of a lengthy but simple <a href="case-by-case_analysis" title="wikilink">case-by-case analysis</a> of all the rules of inference, showing that each "preserves" semantic implication.</p>

<p>By the definition of provability, there are no sentences provable other than by being a member of 

<math display="inline" id="Propositional_calculus:360">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, an axiom, or following by a rule; so if all of those are semantically implied, the deduction calculus is sound.</p>
<h3 id="sketch-of-completeness-proof">Sketch of completeness proof</h3>

<p>(This is usually the much harder direction of proof.)</p>

<p>We adopt the same notational conventions as above.</p>

<p>We want to show: If 

<math display="inline" id="Propositional_calculus:361">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Propositional_calculus:362">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Propositional_calculus:363">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 proves 

<math display="inline" id="Propositional_calculus:364">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. We proceed by <a class="uri" href="contraposition" title="wikilink">contraposition</a>: We show instead that if 

<math display="inline" id="Propositional_calculus:365">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 does <strong>not</strong> prove 

<math display="inline" id="Propositional_calculus:366">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Propositional_calculus:367">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 does <strong>not</strong> imply 

<math display="inline" id="Propositional_calculus:368">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

.</p>

<p><a href="Q.E.D." title="wikilink">QED</a></p>
<h3 id="another-outline-for-a-completeness-proof">Another outline for a completeness proof</h3>

<p>If a formula is a <a href="Tautology_(logic)" title="wikilink">tautology</a>, then there is a <a href="truth_table" title="wikilink">truth table</a> for it which shows that each valuation yields the value true for the formula. Consider such a valuation. By mathematical induction on the length of the subformulas, show that the truth or falsity of the subformula follows from the truth or falsity (as appropriate for the valuation) of each propositional variable in the subformula. Then combine the lines of the truth table together two at a time by using "(

<math display="inline" id="Propositional_calculus:369">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is true implies 

<math display="inline" id="Propositional_calculus:370">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

) implies ((

<math display="inline" id="Propositional_calculus:371">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is false implies 

<math display="inline" id="Propositional_calculus:372">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

) implies 

<math display="inline" id="Propositional_calculus:373">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

)". Keep repeating this until all dependencies on propositional variables have been eliminated. The result is that we have proved the given tautology. Since every tautology is provable, the logic is complete.</p>
<h2 id="interpretation-of-a-truth-functional-propositional-calculus">Interpretation of a truth-functional propositional calculus</h2>

<p>An <strong>interpretation of a truth-functional propositional calculus</strong> 

<math display="inline" id="Propositional_calculus:374">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

 is an <a href="assignment_(mathematical_logic)" title="wikilink">assignment</a> to each <a href="Propositional_variable" title="wikilink">propositional symbol</a> of 

<math display="inline" id="Propositional_calculus:375">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

 of one or the other (but not both) of the <a href="truth_value" title="wikilink">truth values</a> <a class="uri" href="truth" title="wikilink">truth</a> (<strong>T</strong>) and <a href="false_(logic)" title="wikilink">falsity</a> (<strong>F</strong>), and an assignment to the <a href="logical_connective" title="wikilink">connective symbols</a> of 

<math display="inline" id="Propositional_calculus:376">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

 of their usual truth-functional meanings. An interpretation of a truth-functional propositional calculus may also be expressed in terms of <a href="truth_tables" title="wikilink">truth tables</a>.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>For 

<math display="inline" id="Propositional_calculus:377">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 distinct propositional symbols there are 

<math display="inline" id="Propositional_calculus:378">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}
  </annotation>
 </semantics>
</math>

 distinct possible interpretations. For any particular symbol 

<math display="inline" id="Propositional_calculus:379">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, for example, there are 

<math display="inline" id="Propositional_calculus:380">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mn>1</mn>
   </msup>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{1}=2
  </annotation>
 </semantics>
</math>

 possible interpretations:</p>
<ol>
<li>

<math display="inline" id="Propositional_calculus:381">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is assigned <strong>T</strong>, or</li>
<li>

<math display="inline" id="Propositional_calculus:382">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is assigned <strong>F</strong>.</li>
</ol>

<p>For the pair 

<math display="inline" id="Propositional_calculus:383">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Propositional_calculus:384">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 there are 

<math display="inline" id="Propositional_calculus:385">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{2}=4
  </annotation>
 </semantics>
</math>

 possible interpretations:</p>
<ol>
<li>both are assigned <strong>T</strong>,</li>
<li>both are assigned <strong>F</strong>,</li>
<li>

<math display="inline" id="Propositional_calculus:386">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is assigned <strong>T</strong> and 

<math display="inline" id="Propositional_calculus:387">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 is assigned <strong>F</strong>, or</li>
<li>

<math display="inline" id="Propositional_calculus:388">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is assigned <strong>F</strong> and 

<math display="inline" id="Propositional_calculus:389">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 is assigned <strong>T</strong>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></li>
</ol>

<p>Since 

<math display="inline" id="Propositional_calculus:390">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

 has 

<math display="inline" id="Propositional_calculus:391">
 <semantics>
  <msub>
   <mi mathvariant="normal">ℵ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-ℵ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \aleph_{0}
  </annotation>
 </semantics>
</math>

, that is, <a href="Denumerably_infinite" title="wikilink">denumerably</a> many propositional symbols, there are 

<math display="inline" id="Propositional_calculus:392">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <msub>
     <mi mathvariant="normal">ℵ</mi>
     <mn>0</mn>
    </msub>
   </msup>
   <mo>=</mo>
   <mi>𝔠</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-ℵ</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <ci>𝔠</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{\aleph_{0}}=\mathfrak{c}
  </annotation>
 </semantics>
</math>

, and therefore <a href="Cardinality_of_the_continuum" title="wikilink">uncountably many</a> distinct possible interpretations of 

<math display="inline" id="Propositional_calculus:393">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h3 id="interpretation-of-a-sentence-of-truth-functional-propositional-logic">Interpretation of a sentence of truth-functional propositional logic</h3>

<p>If 

<math display="inline" id="Propositional_calculus:394">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:395">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ψ
  </annotation>
 </semantics>
</math>

 are <a href="formula_(mathematical_logic)" title="wikilink">formulas</a> of 

<math display="inline" id="Propositional_calculus:396">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:397">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℐ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℐ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{I}
  </annotation>
 </semantics>
</math>

 is an interpretation of 

<math display="inline" id="Propositional_calculus:398">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

 then:</p>
<ul>
<li>A sentence of propositional logic is <em>true under an interpretation</em> 

<math display="inline" id="Propositional_calculus:399">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℐ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℐ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{I}
  </annotation>
 </semantics>
</math>

 iff 

<math display="inline" id="Propositional_calculus:400">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℐ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℐ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{I}
  </annotation>
 </semantics>
</math>

 assigns the truth value <strong>T</strong> to that sentence. If a sentence is <a href="logical_truth" title="wikilink">true</a> under an interpretation, then that interpretation is called a <em>model</em> of that sentence.</li>
<li>

<math display="inline" id="Propositional_calculus:401">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 is <em>false under an interpretation</em> 

<math display="inline" id="Propositional_calculus:402">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℐ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℐ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{I}
  </annotation>
 </semantics>
</math>

 iff 

<math display="inline" id="Propositional_calculus:403">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 is not true under 

<math display="inline" id="Propositional_calculus:404">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℐ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℐ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{I}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></li>
<li>A sentence of propositional logic is <em>logically valid</em> if it is true under every interpretation</li>
</ul>

<p>

<math display="block" id="Propositional_calculus:405">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊧</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \models\phi
  </annotation>
 </semantics>
</math>

 means that 

<math display="inline" id="Propositional_calculus:406">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 is logically valid</p>
<ul>
<li>A sentence 

<math display="inline" id="Propositional_calculus:407">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ψ
  </annotation>
 </semantics>
</math>

 of propositional logic is a <em><a href="Logical_consequence" title="wikilink">semantic consequence</a></em> of a sentence 

<math display="inline" id="Propositional_calculus:408">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 iff there is no interpretation under which 

<math display="inline" id="Propositional_calculus:409">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 is true and 

<math display="inline" id="Propositional_calculus:410">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ψ
  </annotation>
 </semantics>
</math>

 is false.</li>
<li>A sentence of propositional logic is <em><a href="Consistency" title="wikilink">consistent</a></em> iff it is true under at least one interpretation. It is inconsistent if it is not consistent.</li>
</ul>

<p>Some consequences of these definitions:</p>
<ul>
<li>For any given interpretation a given formula is either true or false.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></li>
<li>No formula is both true and false under the same interpretation.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></li>
<li>

<math display="inline" id="Propositional_calculus:411">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 is false for a given interpretation iff 

<math display="inline" id="Propositional_calculus:412">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\phi
  </annotation>
 </semantics>
</math>

 is true for that interpretation; and 

<math display="inline" id="Propositional_calculus:413">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 is true under an interpretation iff 

<math display="inline" id="Propositional_calculus:414">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\phi
  </annotation>
 </semantics>
</math>

 is false under that interpretation.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></li>
<li>If 

<math display="inline" id="Propositional_calculus:415">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:416">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>ψ</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ϕ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\to\psi)
  </annotation>
 </semantics>
</math>

 are both true under a given interpretation, then 

<math display="inline" id="Propositional_calculus:417">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ψ
  </annotation>
 </semantics>
</math>

 is true under that interpretation.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></li>
<li>If 

<math display="inline" id="Propositional_calculus:418">
 <semantics>
  <mrow>
   <mi></mi>
   <msub>
    <mo>⊧</mo>
    <mi mathvariant="normal">P</mi>
   </msub>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">models</csymbol>
     <ci>normal-P</ci>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \models_{\mathrm{P}}\phi
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:419">
 <semantics>
  <mrow>
   <msub>
    <mo>⊧</mo>
    <mi mathvariant="normal">P</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">models</csymbol>
     <ci>normal-P</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \models_{\mathrm{P}}(\phi\to\psi)
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Propositional_calculus:420">
 <semantics>
  <mrow>
   <mi></mi>
   <msub>
    <mo>⊧</mo>
    <mi mathvariant="normal">P</mi>
   </msub>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">models</csymbol>
     <ci>normal-P</ci>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \models_{\mathrm{P}}\psi
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></li>
<li>

<math display="inline" id="Propositional_calculus:421">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\phi
  </annotation>
 </semantics>
</math>

 is true under 

<math display="inline" id="Propositional_calculus:422">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℐ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℐ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{I}
  </annotation>
 </semantics>
</math>

 iff 

<math display="inline" id="Propositional_calculus:423">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 is not true under 

<math display="inline" id="Propositional_calculus:424">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℐ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℐ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{I}
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Propositional_calculus:425">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>ψ</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ϕ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\to\psi)
  </annotation>
 </semantics>
</math>

 is true under 

<math display="inline" id="Propositional_calculus:426">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℐ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℐ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{I}
  </annotation>
 </semantics>
</math>

 iff either 

<math display="inline" id="Propositional_calculus:427">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 is not true under 

<math display="inline" id="Propositional_calculus:428">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℐ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℐ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{I}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Propositional_calculus:429">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ψ
  </annotation>
 </semantics>
</math>

 is true under 

<math display="inline" id="Propositional_calculus:430">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℐ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℐ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{I}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></li>
<li>A sentence 

<math display="inline" id="Propositional_calculus:431">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ψ
  </annotation>
 </semantics>
</math>

 of propositional logic is a semantic consequence of a sentence 

<math display="inline" id="Propositional_calculus:432">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

 iff 

<math display="inline" id="Propositional_calculus:433">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>ψ</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ϕ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi\to\psi)
  </annotation>
 </semantics>
</math>

 is <a href="logically_valid" title="wikilink">logically valid</a>, that is, 

<math display="inline" id="Propositional_calculus:434">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <msub>
    <mo>⊧</mo>
    <mi mathvariant="normal">P</mi>
   </msub>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">models</csymbol>
     <ci>normal-P</ci>
    </apply>
    <ci>ϕ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\models_{\mathrm{P}}\psi
  </annotation>
 </semantics>
</math>

 iff 

<math display="inline" id="Propositional_calculus:435">
 <semantics>
  <mrow>
   <msub>
    <mo>⊧</mo>
    <mi mathvariant="normal">P</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ϕ</mi>
    <mo>→</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">models</csymbol>
     <ci>normal-P</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \models_{\mathrm{P}}(\phi\to\psi)
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></li>
</ul>
<h2 id="alternative-calculus">Alternative calculus</h2>

<p>It is possible to define another version of propositional calculus, which defines most of the syntax of the logical operators by means of axioms, and which uses only one inference rule.</p>
<h3 id="axioms">Axioms</h3>

<p>Let 

<math display="inline" id="Propositional_calculus:436">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   φ
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Propositional_calculus:437">
 <semantics>
  <mi>χ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>χ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   χ
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Propositional_calculus:438">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ψ
  </annotation>
 </semantics>
</math>

 stand for well-formed formulas. (The well-formed formulas themselves would not contain any Greek letters, but only capital Roman letters, connective operators, and parentheses.) Then the axioms are as follows:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>style="text-align:center;" Axioms</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Name</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>THEN-1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>THEN-2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>AND-1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>AND-2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>AND-3</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>OR-1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>OR-2</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>OR-3</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>NOT-1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>NOT-2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>NOT-3</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>IFF-1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>IFF-2</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>IFF-3</p></td>
</tr>
</tbody>
</table>
<ul>
<li>Axiom THEN-2 may be considered to be a "distributive property of implication with respect to implication."</li>
<li>Axioms AND-1 and AND-2 correspond to "conjunction elimination". The relation between AND-1 and AND-2 reflects the commutativity of the conjunction operator.</li>
<li>Axiom AND-3 corresponds to "conjunction introduction."</li>
<li>Axioms OR-1 and OR-2 correspond to "disjunction introduction." The relation between OR-1 and OR-2 reflects the commutativity of the disjunction operator.</li>
<li>Axiom NOT-1 corresponds to "reductio ad absurdum."</li>
<li>Axiom NOT-2 says that "anything can be deduced from a contradiction."</li>
<li>Axiom NOT-3 is called "<a href="law_of_excluded_middle" title="wikilink">tertium non datur</a>" (<a class="uri" href="Latin" title="wikilink">Latin</a>: "a third is not given") and reflects the semantic valuation of propositional formulas: a formula can have a truth-value of either true or false. There is no third truth-value, at least not in classical logic. <a href="Intuitionistic_logic" title="wikilink">Intuitionistic logicians</a> do not accept the axiom NOT-3.</li>
</ul>
<h3 id="inference-rule">Inference rule</h3>

<p>The inference rule is <a href="modus_ponens" title="wikilink">modus ponens</a>:</p>

<p>

<math display="block" id="Propositional_calculus:439">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ϕ</mi>
     <mo rspace="7.5pt">,</mo>
     <mi>ϕ</mi>
    </mrow>
    <mo>→</mo>
    <mi>χ</mi>
   </mrow>
   <mo>⊢</mo>
   <mi>χ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <apply>
     <ci>normal-→</ci>
     <list>
      <ci>ϕ</ci>
      <ci>ϕ</ci>
     </list>
     <ci>χ</ci>
    </apply>
    <ci>χ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi,\ \phi\to\chi\vdash\chi
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="meta-inference-rule">Meta-inference rule</h3>

<p>Let a demonstration be represented by a sequence, with hypotheses to the left of the <a href="Turnstile_(symbol)" title="wikilink">turnstile</a> and the conclusion to the right of the turnstile. Then the <a href="deduction_theorem" title="wikilink">deduction theorem</a> can be stated as follows:</p>
<dl>
<dd><em>If the sequence</em>

<p>

<math display="block" id="Propositional_calculus:440">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ϕ</mi>
     <mn>1</mn>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <msub>
     <mi>ϕ</mi>
     <mn>2</mn>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <mi mathvariant="normal">…</mi>
    <mo rspace="7.5pt">,</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>n</mi>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <mi>χ</mi>
   </mrow>
   <mo>⊢</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
     <ci>χ</ci>
    </list>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{1},\ \phi_{2},\ ...,\ \phi_{n},\ \chi\vdash\psi
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd><em>has been demonstrated, then it is also possible to demonstrate the sequence</em>

<p>

<math display="block" id="Propositional_calculus:441">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ϕ</mi>
     <mn>1</mn>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <msub>
     <mi>ϕ</mi>
     <mn>2</mn>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <mi mathvariant="normal">…</mi>
    <mo rspace="7.5pt">,</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mi>χ</mi>
    <mo>→</mo>
    <mi>ψ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
    </list>
    <apply>
     <ci>normal-→</ci>
     <ci>χ</ci>
     <ci>ψ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{1},\ \phi_{2},\ ...,\ \phi_{n}\vdash\chi\to\psi
  </annotation>
 </semantics>
</math>

.</p>
</dd>
</dl>

<p>This deduction theorem (DT) is not itself formulated with propositional calculus: it is not a theorem of propositional calculus, but a theorem about propositional calculus. In this sense, it is a <a class="uri" href="meta-theorem" title="wikilink">meta-theorem</a>, comparable to theorems about the soundness or completeness of propositional calculus.</p>

<p>On the other hand, DT is so useful for simplifying the syntactical proof process that it can be considered and used as another inference rule, accompanying modus ponens. In this sense, DT corresponds to the natural <a href="conditional_proof" title="wikilink">conditional proof</a> inference rule which is part of the first version of propositional calculus introduced in this article.</p>

<p>The converse of DT is also valid:</p>
<dl>
<dd><em>If the sequence</em>

<p>

<math display="block" id="Propositional_calculus:442">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ϕ</mi>
     <mn>1</mn>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <msub>
     <mi>ϕ</mi>
     <mn>2</mn>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <mi mathvariant="normal">…</mi>
    <mo rspace="7.5pt">,</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mi>χ</mi>
    <mo>→</mo>
    <mi>ψ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
    </list>
    <apply>
     <ci>normal-→</ci>
     <ci>χ</ci>
     <ci>ψ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{1},\ \phi_{2},\ ...,\ \phi_{n}\vdash\chi\to\psi
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd><em>has been demonstrated, then it is also possible to demonstrate the sequence</em>

<p>

<math display="block" id="Propositional_calculus:443">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ϕ</mi>
     <mn>1</mn>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <msub>
     <mi>ϕ</mi>
     <mn>2</mn>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <mi mathvariant="normal">…</mi>
    <mo rspace="7.5pt">,</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>n</mi>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <mi>χ</mi>
   </mrow>
   <mo>⊢</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
     <ci>χ</ci>
    </list>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{1},\ \phi_{2},\ ...,\ \phi_{n},\ \chi\vdash\psi
  </annotation>
 </semantics>
</math>

</p>
</dd>
</dl>

<p>in fact, the validity of the converse of DT is almost trivial compared to that of DT:</p>
<dl>
<dd><em>If</em>

<p>

<math display="block" id="Propositional_calculus:444">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ϕ</mi>
     <mn>1</mn>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <mi mathvariant="normal">…</mi>
    <mo rspace="7.5pt">,</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mi>χ</mi>
    <mo>→</mo>
    <mi>ψ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
    </list>
    <apply>
     <ci>normal-→</ci>
     <ci>χ</ci>
     <ci>ψ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{1},\ ...,\ \phi_{n}\vdash\chi\to\psi
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd><em>then</em>
<dl>
<dd>1

<math display="block" id="Propositional_calculus:445">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ϕ</mi>
     <mn>1</mn>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <mi mathvariant="normal">…</mi>
    <mo rspace="7.5pt">,</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>n</mi>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <mi>χ</mi>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mi>χ</mi>
    <mo>→</mo>
    <mi>ψ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
     <ci>χ</ci>
    </list>
    <apply>
     <ci>normal-→</ci>
     <ci>χ</ci>
     <ci>ψ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{1},\ ...,\ \phi_{n},\ \chi\vdash\chi\to\psi
  </annotation>
 </semantics>
</math>


</dd>
<dd>2

<math display="block" id="Propositional_calculus:446">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ϕ</mi>
     <mn>1</mn>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <mi mathvariant="normal">…</mi>
    <mo rspace="7.5pt">,</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>n</mi>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <mi>χ</mi>
   </mrow>
   <mo>⊢</mo>
   <mi>χ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
     <ci>χ</ci>
    </list>
    <ci>χ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{1},\ ...,\ \phi_{n},\ \chi\vdash\chi
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd><em>and from (1) and (2) can be deduced</em>
<dl>
<dd>3

<math display="block" id="Propositional_calculus:447">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ϕ</mi>
     <mn>1</mn>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <mi mathvariant="normal">…</mi>
    <mo rspace="7.5pt">,</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>n</mi>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <mi>χ</mi>
   </mrow>
   <mo>⊢</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
     <ci>χ</ci>
    </list>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{1},\ ...,\ \phi_{n},\ \chi\vdash\psi
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd><em>by means of modus ponens, Q.E.D.</em>
</dd>
</dl>

<p>The converse of DT has powerful implications: it can be used to convert an axiom into an inference rule. For example, the axiom AND-1,</p>

<p>

<math display="block" id="Propositional_calculus:448">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mrow>
    <mrow>
     <mi>ϕ</mi>
     <mo>∧</mo>
     <mi>χ</mi>
    </mrow>
    <mo>→</mo>
    <mi>ϕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <and></and>
      <ci>ϕ</ci>
      <ci>χ</ci>
     </apply>
     <ci>ϕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash\phi\wedge\chi\to\phi
  </annotation>
 </semantics>
</math>

 can be transformed by means of the converse of the deduction theorem into the inference rule</p>

<p>

<math display="block" id="Propositional_calculus:449">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mo>∧</mo>
    <mi>χ</mi>
   </mrow>
   <mo>⊢</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <apply>
     <and></and>
     <ci>ϕ</ci>
     <ci>χ</ci>
    </apply>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\wedge\chi\vdash\phi
  </annotation>
 </semantics>
</math>

 which is <a href="conjunction_elimination" title="wikilink">conjunction elimination</a>, one of the ten inference rules used in the first version (in this article) of the propositional calculus.</p>
<h3 id="example-of-a-proof-1">Example of a proof</h3>

<p>The following is an example of a (syntactical) demonstration, involving only axioms THEN-1 and THEN-2:</p>

<p><strong>Prove:</strong> 

<math display="inline" id="Propositional_calculus:450">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>A</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\to A
  </annotation>
 </semantics>
</math>

 (Reflexivity of implication).</p>

<p><strong>Proof:</strong></p>
<ol>
<li>

<math display="inline" id="Propositional_calculus:451">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo>→</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>→</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>→</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo>→</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>→</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-→</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\to((B\to A)\to A))\to((A\to(B\to A))\to(A\to A))
  </annotation>
 </semantics>
</math>


<dl>
<dd>Axiom THEN-2 with 

<math display="inline" id="Propositional_calculus:452">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ϕ</mi>
     <mo>=</mo>
     <mi>A</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>χ</mi>
     <mo>=</mo>
     <mi>B</mi>
     <mo>→</mo>
     <mi>A</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>ψ</mi>
    <mo>=</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <ci>ϕ</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <and></and>
      <apply>
       <eq></eq>
       <ci>χ</ci>
       <ci>B</ci>
      </apply>
      <apply>
       <ci>normal-→</ci>
       <share href="#.cmml">
       </share>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>ψ</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi=A,\chi=B\to A,\psi=A
  </annotation>
 </semantics>
</math>


</dd>
</dl></li>
<li>

<math display="inline" id="Propositional_calculus:453">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo>→</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\to((B\to A)\to A)
  </annotation>
 </semantics>
</math>


<dl>
<dd>Axiom THEN-1 with 

<math display="inline" id="Propositional_calculus:454">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mo>=</mo>
    <mi>A</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>χ</mi>
    <mo>=</mo>
    <mi>B</mi>
    <mo>→</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>ϕ</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <ci>χ</ci>
      <ci>B</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi=A,\chi=B\to A
  </annotation>
 </semantics>
</math>


</dd>
</dl></li>
<li>

<math display="inline" id="Propositional_calculus:455">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo>→</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\to(B\to A))\to(A\to A)
  </annotation>
 </semantics>
</math>


<dl>
<dd>From (1) and (2) by modus ponens.
</dd>
</dl></li>
<li>

<math display="inline" id="Propositional_calculus:456">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>→</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\to(B\to A)
  </annotation>
 </semantics>
</math>


<dl>
<dd>Axiom THEN-1 with 

<math display="inline" id="Propositional_calculus:457">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mo>=</mo>
    <mi>A</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>χ</mi>
    <mo>=</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>ϕ</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <eq></eq>
     <ci>χ</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi=A,\chi=B
  </annotation>
 </semantics>
</math>


</dd>
</dl></li>
<li>

<math display="inline" id="Propositional_calculus:458">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>A</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\to A
  </annotation>
 </semantics>
</math>


<dl>
<dd>From (3) and (4) by modus ponens.
</dd>
</dl></li>
</ol>
<h2 id="equivalence-to-equational-logics">Equivalence to equational logics</h2>

<p>The preceding alternative calculus is an example of a <a href="Hilbert-style_deduction_system" title="wikilink">Hilbert-style deduction system</a>. In the case of propositional systems the axioms are terms built with logical connectives and the only inference rule is modus ponens. Equational logic as standardly used informally in high school algebra is a different kind of calculus from Hilbert systems. Its theorems are equations and its inference rules express the properties of equality, namely that it is a congruence on terms that admits substitution.</p>

<p>Classical propositional calculus as described above is equivalent to <a href="Boolean_algebra_(logic)" title="wikilink">Boolean algebra</a>, while <a href="Intuitionistic_logic" title="wikilink">intuitionistic propositional calculus</a> is equivalent to <a href="Heyting_algebra" title="wikilink">Heyting algebra</a>. The equivalence is shown by translation in each direction of the theorems of the respective systems. Theorems 

<math display="inline" id="Propositional_calculus:459">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 of classical or intuitionistic propositional calculus are translated as equations 

<math display="inline" id="Propositional_calculus:460">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ϕ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi=1
  </annotation>
 </semantics>
</math>

 of Boolean or Heyting algebra respectively. Conversely theorems 

<math display="inline" id="Propositional_calculus:461">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=y
  </annotation>
 </semantics>
</math>

 of Boolean or Heyting algebra are translated as theorems 

<math display="inline" id="Propositional_calculus:462">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>→</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>→</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x\to y)\land(y\to x)
  </annotation>
 </semantics>
</math>

 of classical or intuitionistic calculus respectively, for which 

<math display="inline" id="Propositional_calculus:463">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≡</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\equiv y
  </annotation>
 </semantics>
</math>

 is a standard abbreviation. In the case of Boolean algebra 

<math display="inline" id="Propositional_calculus:464">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=y
  </annotation>
 </semantics>
</math>

 can also be translated as 

<math display="inline" id="Propositional_calculus:465">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>x</mi>
     <mo>∧</mo>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>x</mi>
     </mrow>
     <mo>∧</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>y</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <and></and>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <not></not>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <not></not>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x\land y)\lor(\neg x\land\neg y)
  </annotation>
 </semantics>
</math>

, but this translation is incorrect intuitionistically.</p>

<p>In both Boolean and Heyting algebra, inequality 

<math display="inline" id="Propositional_calculus:466">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≤</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\leq y
  </annotation>
 </semantics>
</math>

 can be used in place of equality. The equality 

<math display="inline" id="Propositional_calculus:467">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=y
  </annotation>
 </semantics>
</math>

 is expressible as a pair of inequalities 

<math display="inline" id="Propositional_calculus:468">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≤</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\leq y
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Propositional_calculus:469">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>≤</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>y</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\leq x
  </annotation>
 </semantics>
</math>

. Conversely the inequality 

<math display="inline" id="Propositional_calculus:470">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≤</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\leq y
  </annotation>
 </semantics>
</math>

 is expressible as the equality 

<math display="inline" id="Propositional_calculus:471">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>∧</mo>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <and></and>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\land y=x
  </annotation>
 </semantics>
</math>

, or as 

<math display="inline" id="Propositional_calculus:472">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>∨</mo>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <or></or>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\lor y=y
  </annotation>
 </semantics>
</math>

. The significance of inequality for Hilbert-style systems is that it corresponds to the latter's deduction or <a class="uri" href="entailment" title="wikilink">entailment</a> symbol 

<math display="inline" id="Propositional_calculus:473">
 <semantics>
  <mo>⊢</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">proves</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash
  </annotation>
 </semantics>
</math>

. An entailment</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Propositional_calculus:474">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ϕ</mi>
     <mn>1</mn>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <msub>
     <mi>ϕ</mi>
     <mn>2</mn>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <mi mathvariant="normal">…</mi>
    <mo rspace="7.5pt">,</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>⊢</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
    </list>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{1},\ \phi_{2},\ \dots,\ \phi_{n}\vdash\psi
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>is translated in the inequality version of the algebraic framework as</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Propositional_calculus:475">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <msub>
      <mi>ϕ</mi>
      <mn>1</mn>
     </msub>
    </mpadded>
    <mo rspace="7.5pt">∧</mo>
    <mpadded width="+5pt">
     <msub>
      <mi>ϕ</mi>
      <mn>2</mn>
     </msub>
    </mpadded>
    <mo rspace="7.5pt">∧</mo>
    <mpadded width="+5pt">
     <mi mathvariant="normal">…</mi>
    </mpadded>
    <mo rspace="7.5pt">∧</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>≤</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <leq></leq>
    <ci>ψ</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{1}\ \land\ \phi_{2}\ \land\ \dots\ \land\ \phi_{n}\ \ \leq\ \ \psi
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Conversely the algebraic inequality 

<math display="inline" id="Propositional_calculus:476">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≤</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\leq y
  </annotation>
 </semantics>
</math>

 is translated as the entailment</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Propositional_calculus:477">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>x</mi>
   </mpadded>
   <mo rspace="7.5pt">⊢</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\ \vdash\ y
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
</dd>
</dl>

<p>The difference between implication 

<math display="inline" id="Propositional_calculus:478">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>→</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\to y
  </annotation>
 </semantics>
</math>

 and inequality or <a class="uri" href="entailment" title="wikilink">entailment</a> 

<math display="inline" id="Propositional_calculus:479">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≤</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\leq y
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Propositional_calculus:480">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>x</mi>
   </mpadded>
   <mo rspace="7.5pt">⊢</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\ \vdash\ y
  </annotation>
 </semantics>
</math>

 is that the former is internal to the logic while the latter is external. Internal implication between two terms is another term of the same kind. Entailment as external implication between two terms expresses a metatruth outside the language of the logic, and is considered part of the <a class="uri" href="metalanguage" title="wikilink">metalanguage</a>. Even when the logic under study is intuitionistic, entailment is ordinarily understood classically as two-valued: either the left side entails, or is less-or-equal to, the right side, or it is not.</p>

<p>Similar but more complex translations to and from algebraic logics are possible for natural deduction systems as described above and for the <a href="sequent_calculus" title="wikilink">sequent calculus</a>. The entailments of the latter can be interpreted as two-valued, but a more insightful interpretation is as a set, the elements of which can be understood as abstract proofs organized as the morphisms of a <a href="Category_(mathematics)" title="wikilink">category</a>. In this interpretation the cut rule of the sequent calculus corresponds to composition in the category. Boolean and Heyting algebras enter this picture as special categories having at most one morphism per homset, i.e., one proof per entailment, corresponding to the idea that existence of proofs is all that matters: any proof will do and there is no point in distinguishing them.</p>
<h2 id="graphical-calculi">Graphical calculi</h2>

<p>It is possible to generalize the definition of a formal language from a set of finite sequences over a finite basis to include many other sets of mathematical structures, so long as they are built up by finitary means from finite materials. What's more, many of these families of formal structures are especially well-suited for use in logic.</p>

<p>For example, there are many families of <a href="graph_(mathematics)" title="wikilink">graphs</a> that are close enough analogues of formal languages that the concept of a calculus is quite easily and naturally extended to them. Indeed, many species of graphs arise as <em><a href="parse_graph" title="wikilink">parse graphs</a></em> in the syntactic analysis of the corresponding families of text structures. The exigencies of practical computation on formal languages frequently demand that text strings be converted into <a href="pointer_structure" title="wikilink">pointer structure</a> renditions of parse graphs, simply as a matter of checking whether strings are well-formed formulas or not. Once this is done, there are many advantages to be gained from developing the graphical analogue of the calculus on strings. The mapping from strings to parse graphs is called <em><a class="uri" href="parsing" title="wikilink">parsing</a></em> and the inverse mapping from parse graphs to strings is achieved by an operation that is called <em><a href="graph_traversal" title="wikilink">traversing</a></em> the graph.</p>
<h2 id="other-logical-calculi">Other logical calculi</h2>

<p>Propositional calculus is about the simplest kind of logical calculus in current use. It can be extended in several ways. (<a href="Term_logic" title="wikilink">Aristotelian "syllogistic" calculus</a>, which is largely supplanted in modern logic, is in <em>some</em> ways simpler – but in other ways more complex – than propositional calculus.) The most immediate way to develop a more complex logical calculus is to introduce rules that are sensitive to more fine-grained details of the sentences being used.</p>

<p><a href="First-order_logic" title="wikilink">First-order logic</a> (a.k.a. first-order predicate logic) results when the "atomic sentences" of propositional logic are broken up into <a href="singular_term" title="wikilink">terms</a>, <a href="variable_(mathematics)" title="wikilink">variables</a>, <a href="Predicate_(logic)" title="wikilink">predicates</a>, and <a href="Quantifier_(logic)" title="wikilink">quantifiers</a>, all keeping the rules of propositional logic with some new ones introduced. (For example, from "All dogs are mammals" we may infer "If Rover is a dog then Rover is a mammal".) With the tools of first-order logic it is possible to formulate a number of theories, either with explicit axioms or by rules of inference, that can themselves be treated as logical calculi. <a class="uri" href="Arithmetic" title="wikilink">Arithmetic</a> is the best known of these; others include <a href="set_theory" title="wikilink">set theory</a> and <a class="uri" href="mereology" title="wikilink">mereology</a>. <a href="Second-order_logic" title="wikilink">Second-order logic</a> and other <a href="higher-order_logic" title="wikilink">higher-order logics</a> are formal extensions of first-order logic. Thus, it makes sense to refer to propositional logic as <em>"zeroth-order logic"</em>, when comparing it with these logics.</p>

<p><a href="Modal_logic" title="wikilink">Modal logic</a> also offers a variety of inferences that cannot be captured in propositional calculus. For example, from "Necessarily 

<math display="inline" id="Propositional_calculus:481">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

" we may infer that 

<math display="inline" id="Propositional_calculus:482">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

. From 

<math display="inline" id="Propositional_calculus:483">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 we may infer "It is possible that 

<math display="inline" id="Propositional_calculus:484">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

". The translation between modal logics and algebraic logics concerns classical and intuitionistic logics but with the introduction of a unary operator on Boolean or Heyting algebras, different from the Boolean operations, interpreting the possibility modality, and in the case of Heyting algebra a second operator interpreting necessity (for Boolean algebra this is redundant since necessity is the De Morgan dual of possibility). The first operator preserves 0 and disjunction while the second preserves 1 and conjunction.</p>

<p><a href="Many-valued_logic" title="wikilink">Many-valued logics</a> are those allowing sentences to have values other than <em>true</em> and <em>false</em>. (For example, <em>neither</em> and <em>both</em> are standard "extra values"; "continuum logic" allows each sentence to have any of an infinite number of "degrees of truth" between <em>true</em> and <em>false</em>.) These logics often require calculational devices quite distinct from propositional calculus. When the values form a Boolean algebra (which may have more than two or even infinitely many values), many-valued logic reduces to classical logic; many-valued logics are therefore only of independent interest when the values form an algebra that is not Boolean.</p>
<h2 id="solvers">Solvers</h2>

<p>Finding solutions to propositional logic formulas is an <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problem. However, practical methods exist (e.g., <a href="DPLL_algorithm" title="wikilink">DPLL algorithm</a>, 1962; <a href="Chaff_algorithm" title="wikilink">Chaff algorithm</a>, 2001) that are very fast for many useful cases. Recent work has extended the <a href="SAT_solver" title="wikilink">SAT solver</a> algorithms to work with propositions containing <a href="arithmetic_expression" title="wikilink">arithmetic expressions</a>; these are the <a href="SMT_solver" title="wikilink">SMT solvers</a>.</p>
<h2 id="see-also">See also</h2>
<h3 id="higher-logical-levels">Higher logical levels</h3>
<ul>
<li><a href="First-order_logic" title="wikilink">First-order logic</a></li>
<li><a href="Second-order_propositional_logic" title="wikilink">Second-order propositional logic</a></li>
<li><a href="Second-order_logic" title="wikilink">Second-order logic</a></li>
<li><a href="Higher-order_logic" title="wikilink">Higher-order logic</a></li>
</ul>
<h3 id="related-topics">Related topics</h3>
<ul>
<li><a href="Boolean_algebra_(logic)" title="wikilink">Boolean algebra (logic)</a></li>
<li><a href="Boolean_algebra_(structure)" title="wikilink">Boolean algebra (structure)</a></li>
<li><a href="Boolean_algebra_topics" title="wikilink">Boolean algebra topics</a></li>
<li><a href="Boolean_domain" title="wikilink">Boolean domain</a></li>
<li><a href="Boolean_function" title="wikilink">Boolean function</a></li>
<li><a href="Boolean-valued_function" title="wikilink">Boolean-valued function</a></li>
<li><a href="Categorical_logic" title="wikilink">Categorical logic</a></li>
<li><a href="Combinational_logic" title="wikilink">Combinational logic</a></li>
<li><a href="Combinatory_logic" title="wikilink">Combinatory logic</a></li>
<li><a href="Conceptual_graph" title="wikilink">Conceptual graph</a></li>
<li><a href="Disjunctive_syllogism" title="wikilink">Disjunctive syllogism</a></li>
<li><a href="Entitative_graph" title="wikilink">Entitative graph</a></li>
</ul>
<ul>
<li><a href="Existential_graph" title="wikilink">Existential graph</a></li>
<li><a href="Frege's_propositional_calculus" title="wikilink">Frege's propositional calculus</a></li>
<li><a href="Implicational_propositional_calculus" title="wikilink">Implicational propositional calculus</a></li>
<li><a href="Intuitionistic_propositional_calculus" title="wikilink">Intuitionistic propositional calculus</a></li>
<li><a href="Jean_Buridan" title="wikilink">Jean Buridan</a></li>
<li><a href="Laws_of_Form" title="wikilink">Laws of Form</a></li>
<li><a href="Logical_graph" title="wikilink">Logical graph</a></li>
<li><a href="Logical_NOR" title="wikilink">Logical NOR</a></li>
<li><a href="Logical_value" title="wikilink">Logical value</a></li>
</ul>
<ul>
<li><a href="Operation_(mathematics)" title="wikilink">Operation</a></li>
<li><a href="Paul_of_Venice" title="wikilink">Paul of Venice</a></li>
<li><a href="Peirce's_law" title="wikilink">Peirce's law</a></li>
<li><a href="Peter_of_Spain" title="wikilink">Peter of Spain</a></li>
<li><a href="Propositional_formula" title="wikilink">Propositional formula</a></li>
<li><a href="Symmetric_difference" title="wikilink">Symmetric difference</a></li>
<li><a href="Truth_function" title="wikilink">Truth function</a></li>
<li><a href="Truth_table" title="wikilink">Truth table</a></li>
<li><a href="Walter_Burley" title="wikilink">Walter Burley</a></li>
<li><a href="William_of_Sherwood" title="wikilink">William of Sherwood</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Brown, Frank Markham (2003), <em>Boolean Reasoning: The Logic of Boolean Equations</em>, 1st edition, Kluwer Academic Publishers, Norwell, MA. 2nd edition, Dover Publications, Mineola, NY.</li>
<li><a href="Chen_Chung_Chang" title="wikilink">Chang, C.C.</a> and <a href="Howard_Jerome_Keisler" title="wikilink">Keisler, H.J.</a> (1973), <em>Model Theory</em>, North-Holland, Amsterdam, Netherlands.</li>
<li>Kohavi, Zvi (1978), <em>Switching and Finite Automata Theory</em>, 1st edition, McGraw–Hill, 1970. 2nd edition, McGraw–Hill, 1978.</li>
<li><a href="Robert_R._Korfhage" title="wikilink">Korfhage, Robert R.</a> (1974), <em>Discrete Computational Structures</em>, Academic Press, New York, NY.</li>
<li><a href="Joachim_Lambek" title="wikilink">Lambek, J.</a> and Scott, P.J. (1986), <em>Introduction to Higher Order Categorical Logic</em>, Cambridge University Press, Cambridge, UK.</li>
<li>Mendelson, Elliot (1964), <em>Introduction to Mathematical Logic</em>, D. Van Nostrand Company.</li>
</ul>
<h3 id="related-works">Related works</h3>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="Kevin_C._Klement" title="wikilink">Klement, Kevin C.</a> (2006), "Propositional Logic", in James Fieser and Bradley Dowden (eds.), <em><a href="Internet_Encyclopedia_of_Philosophy" title="wikilink">Internet Encyclopedia of Philosophy</a></em>, <a href="http://www.iep.utm.edu/p/prop-log.htm">Eprint</a>.</li>
<li><a href="http://www.qedeq.org/current/doc/math/qedeq_formal_logic_v1_en.pdf">Formal Predicate Calculus</a>, contains a systematic formal development along the lines of <a href="Propositional_calculus#Alternative_calculus" title="wikilink">Alternative calculus</a></li>
<li><em><a href="http://www.fecundity.com/logic/">forall x: an introduction to formal logic</a></em>, by <a href="P.D._Magnus" title="wikilink">P.D. Magnus</a>, covers formal semantics and <a href="proof_theory" title="wikilink">proof theory</a> for sentential logic.</li>
<li><a href="http://www.proofwiki.org/wiki/Category:Propositional_Calculus">Category:Propositional Calculus</a> on ProofWiki (<a href="GFDL" title="wikilink">GFDLed</a>)</li>
<li><a href="http://logic-law.com/index.php?title=Propositional_Logic">An Outline of Propositional Logic</a></li>
</ul>

<p>"</p>

<p><a href="Category:Propositional_calculus" title="wikilink"> </a> <a href="Category:Systems_of_formal_logic" title="wikilink">Category:Systems of formal logic</a> <a href="Category:Logical_calculi" title="wikilink">Category:Logical calculi</a> <a href="Category:Boolean_algebra" title="wikilink">Category:Boolean algebra</a> <a href="Category:Classical_logic" title="wikilink">Category:Classical logic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://plato.stanford.edu/entries/logic-ancient/">Ancient Logic (Stanford Encyclopedia of Philosophy)</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://plato.stanford.edu/entries/leibniz-logic-influence/#Con">Leibniz's Influence on 19th Century Logic</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">Beth, Evert W.; "Semantic entailment and formal derivability", series: Mededlingen van de Koninklijke Nederlandse Akademie van Wetenschappen, Afdeling Letterkunde, Nieuwe Reeks, vol. 18, no. 13, Noord-Hollandsche Uitg. Mij., Amsterdam, 1955, pp. 309–42. Reprinted in Jaakko Intikka (ed.) <em>The Philosophy of Mathematics</em>, Oxford University Press, 1969<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="http://frege.brown.edu/heck/pdf/unpublished/TruthInFrege.pdf">Truth in Frege</a><a href="#fnref6">↩</a></li>
<li id="fn7">[<a class="uri" href="http://digitalcommons.mcmaster.ca/cgi/viewcontent.cgi?article=1219&amp;context">http://digitalcommons.mcmaster.ca/cgi/viewcontent.cgi?article=1219&amp;context;</a>;=russelljournal Russell's Use of Truth-Tables]<a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11">Wernick, William (1942) "Complete Sets of Logical Functions," <em>Transactions of the American Mathematical Society</em> <strong>51</strong>, pp. 117–132.<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
</ol>
</section>
</body>
</html>
