<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="856">Singular homology</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Singular homology</h1>
<hr/>

<p>In <a href="algebraic_topology" title="wikilink">algebraic topology</a>, a branch of <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <strong>singular homology</strong> refers to the study of a certain set of <a href="algebraic_invariant" title="wikilink">algebraic invariants</a> of a <a href="topological_space" title="wikilink">topological space</a> <em>X</em>, the so-called <strong>homology groups</strong> 

<math display="inline" id="Singular_homology:0">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>n</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{n}(X)
  </annotation>
 </semantics>
</math>

. Intuitively spoken, singular homology counts, for each dimension <em>n</em>, the <em>n</em>-dimensional holes of a space. Singular homology is a particular example of a <a href="homology_theory" title="wikilink">homology theory</a>, which has now grown to be a rather broad collection of theories. Of the various theories, it is perhaps one of the simpler ones to understand, being built on fairly concrete constructions.</p>

<p>In brief, singular homology is constructed by taking maps of the <a href="simplex" title="wikilink">standard <em>n</em>-simplex</a> to a topological space, and composing them into <a href="free_abelian_group#Formal_sum" title="wikilink">formal sums</a>, called <strong>singular chains</strong>. The <a href="boundary_(topology)" title="wikilink">boundary operation</a> on a simplex induces a singular <a href="chain_complex" title="wikilink">chain complex</a>. The singular homology is then the <a href="homology_(mathematics)" title="wikilink">homology</a> of the chain complex. The resulting homology groups are the same for all <a href="Homotopy#Homotopy_equivalence_and_null-homotopy" title="wikilink">homotopically equivalent</a> spaces, which is the reason for their study. These constructions can be applied to all topological spaces, and so singular homology can be expressed in terms of <a href="category_theory" title="wikilink">category theory</a>, where the homology group becomes a <a class="uri" href="functor" title="wikilink">functor</a> from the <a href="category_of_topological_spaces" title="wikilink">category of topological spaces</a> to the category of graded <a href="abelian_group" title="wikilink">abelian groups</a>. These ideas are developed in greater detail below.</p>
<h2 id="singular-simplices">Singular simplices</h2>

<p>A <a href="simplex" title="wikilink">singular <em>n</em>-simplex</a> is a continuous mapping 

<math display="inline" id="Singular_homology:1">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{n}
  </annotation>
 </semantics>
</math>

 from the standard <em>n</em>-<a class="uri" href="simplex" title="wikilink">simplex</a> 

<math display="inline" id="Singular_homology:2">
 <semantics>
  <msup>
   <mi mathvariant="normal">Δ</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Δ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{n}
  </annotation>
 </semantics>
</math>

 to a topological space <em>X</em>. Notationally, one writes 

<math display="inline" id="Singular_homology:3">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mi>n</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi mathvariant="normal">Δ</mi>
     <mi>n</mi>
    </msup>
    <mo>→</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Δ</ci>
      <ci>n</ci>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{n}:\Delta^{n}\to X
  </annotation>
 </semantics>
</math>

. This mapping need not be <a class="uri" href="injective" title="wikilink">injective</a>, so there can be non-equivalent singular simplices with the same image in <em>X</em>.</p>

<p>The boundary of 

<math display="inline" id="Singular_homology:4">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi mathvariant="normal">Δ</mi>
     <mi>n</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Δ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{n}(\Delta^{n})
  </annotation>
 </semantics>
</math>

, denoted as 

<math display="inline" id="Singular_homology:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>∂</mo>
     <mi>n</mi>
    </msub>
    <msub>
     <mi>σ</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi mathvariant="normal">Δ</mi>
     <mi>n</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Δ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial_{n}\sigma_{n}(\Delta^{n})
  </annotation>
 </semantics>
</math>

, is defined to be the <a href="formal_sum" title="wikilink">formal sum</a> of the singular (<em>n</em> − 1)-simplices represented by the restriction of 

<math display="inline" id="Singular_homology:6">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 to the faces of the standard <em>n</em>-simplex, with an alternating sign to take orientation into account. (A formal sum is an element of the <a href="free_abelian_group" title="wikilink">free abelian group</a> on the simplices. The basis for the group is the infinite set of all possible images of standard simplices. The group operation is "addition" and the sum of image <em>a</em> with image <em>b</em> is usually simply designated <em>a</em> + <em>b</em>, but <em>a</em> + <em>a</em> = 2<em>a</em> and so on. Every image <em>a</em> has a negative −<em>a</em>.) Thus, if we designate the range of 

<math display="inline" id="Singular_homology:7">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{n}
  </annotation>
 </semantics>
</math>

 by its vertices</p>

<p>

<math display="block" id="Singular_homology:8">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>p</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>p</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>,</mo>
    <msub>
     <mi>p</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <msub>
      <mi>σ</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>e</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>σ</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>e</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>σ</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>e</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>n</ci>
     </apply>
    </list>
    <list>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [p_{0},p_{1},\cdots,p_{n}]=[\sigma_{n}(e_{0}),\sigma_{n}(e_{1}),\cdots,\sigma_%
{n}(e_{n})]
  </annotation>
 </semantics>
</math>

</p>

<p>corresponding to the vertices 

<math display="inline" id="Singular_homology:9">
 <semantics>
  <msub>
   <mi>e</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{k}
  </annotation>
 </semantics>
</math>

 of the standard <em>n</em>-simplex 

<math display="inline" id="Singular_homology:10">
 <semantics>
  <msup>
   <mi mathvariant="normal">Δ</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Δ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{n}
  </annotation>
 </semantics>
</math>

 (which of course does not fully specify the standard simplex image produced by 

<math display="inline" id="Singular_homology:11">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{n}
  </annotation>
 </semantics>
</math>

), then</p>

<p>

<math display="block" id="Singular_homology:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo>∂</mo>
      <mi>n</mi>
     </msub>
     <msub>
      <mi>σ</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi mathvariant="normal">Δ</mi>
      <mi>n</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>k</mi>
     </msup>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>p</mi>
       <mn>0</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo>,</mo>
      <msub>
       <mi>p</mi>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>p</mi>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>,</mo>
      <mrow>
       <mi mathvariant="normal">⋯</mi>
       <msub>
        <mi>p</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <partialdiff></partialdiff>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Δ</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <ci>k</ci>
      </apply>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <apply>
         <minus></minus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>normal-⋯</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial_{n}\sigma_{n}(\Delta^{n})=\sum_{k=0}^{n}(-1)^{k}[p_{0},\cdots,p_{k-1}%
,p_{k+1},\cdots p_{n}]
  </annotation>
 </semantics>
</math>

</p>

<p>is a <a href="formal_sum" title="wikilink">formal sum</a> of the faces of the simplex image designated in a specific way. (That is, a particular face has to be the image of 

<math display="inline" id="Singular_homology:13">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{n}
  </annotation>
 </semantics>
</math>

 applied to a designation of a face of 

<math display="inline" id="Singular_homology:14">
 <semantics>
  <msup>
   <mi mathvariant="normal">Δ</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Δ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{n}
  </annotation>
 </semantics>
</math>

 which depends on the order that its vertices are listed.) Thus, for example, the boundary of 

<math display="inline" id="Singular_homology:15">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>p</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>p</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>σ</ci>
    <interval closure="closed">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma=[p_{0},p_{1}]
  </annotation>
 </semantics>
</math>

 (a curve going from 

<math display="inline" id="Singular_homology:16">
 <semantics>
  <msub>
   <mi>p</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{0}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Singular_homology:17">
 <semantics>
  <msub>
   <mi>p</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1}
  </annotation>
 </semantics>
</math>

) is the formal sum (or "formal difference") 

<math display="inline" id="Singular_homology:18">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>p</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>p</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [p_{1}]-[p_{0}]
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="singular-chain-complex">Singular chain complex</h2>

<p>The usual construction of singular homology proceeds by defining formal sums of simplices, which may be understood to be elements of a <a href="free_abelian_group" title="wikilink">free abelian group</a>, and then showing that we can define a certain group, the <strong>homology group</strong> of the topological space, involving the boundary operator.</p>

<p>Consider first the set of all possible singular <em>n</em>-simplices 

<math display="inline" id="Singular_homology:19">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi mathvariant="normal">Δ</mi>
     <mi>n</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Δ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{n}(\Delta^{n})
  </annotation>
 </semantics>
</math>

 on a topological space <em>X</em>. This set may be used as the basis of a <a href="free_abelian_group" title="wikilink">free abelian group</a>, so that each 

<math display="inline" id="Singular_homology:20">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi mathvariant="normal">Δ</mi>
     <mi>n</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Δ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{n}(\Delta^{n})
  </annotation>
 </semantics>
</math>

 is a generator of the group. This set of generators is of course usually infinite, frequently <a class="uri" href="uncountable" title="wikilink">uncountable</a>, as there are many ways of mapping a simplex into a typical topological space. The free abelian group generated by this basis is commonly denoted as 

<math display="inline" id="Singular_homology:21">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>n</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}(X)
  </annotation>
 </semantics>
</math>

. Elements of 

<math display="inline" id="Singular_homology:22">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>n</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}(X)
  </annotation>
 </semantics>
</math>

 are called <strong>singular <em>n</em>-chains</strong>; they are formal sums of singular simplices with integer coefficients. In order for the theory to be placed on a firm foundation, it is commonly required that a chain be a sum of only a finite number of simplices.</p>

<p>The <a href="boundary_(topology)" title="wikilink">boundary</a> 

<math display="inline" id="Singular_homology:23">
 <semantics>
  <mo>∂</mo>
  <annotation-xml encoding="MathML-Content">
   <partialdiff></partialdiff>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial
  </annotation>
 </semantics>
</math>

 is readily extended to act on singular <em>n</em>-chains. The extension, called the <a href="boundary_operator" title="wikilink">boundary operator</a>, written as</p>

<p>

<math display="block" id="Singular_homology:24">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>∂</mo>
     <mi>n</mi>
    </msub>
    <mo>:</mo>
    <mrow>
     <msub>
      <mi>C</mi>
      <mi>n</mi>
     </msub>
     <mo>→</mo>
     <msub>
      <mi>C</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <partialdiff></partialdiff>
     <ci>n</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial_{n}:C_{n}\to C_{n-1},
  </annotation>
 </semantics>
</math>

</p>

<p>is a <a class="uri" href="homomorphism" title="wikilink">homomorphism</a> of groups. The boundary operator, together with the 

<math display="inline" id="Singular_homology:25">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}
  </annotation>
 </semantics>
</math>

, form a <a href="chain_complex" title="wikilink">chain complex</a> of abelian groups, called the <strong>singular complex</strong>. It is often denoted as 

<math display="inline" id="Singular_homology:26">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>C</mi>
     <mo>∙</mo>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <msub>
    <mo>∂</mo>
    <mo>∙</mo>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>normal-∙</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <partialdiff></partialdiff>
     <ci>normal-∙</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (C_{\bullet}(X),\partial_{\bullet})
  </annotation>
 </semantics>
</math>

 or more simply 

<math display="inline" id="Singular_homology:27">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mo>∙</mo>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>normal-∙</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{\bullet}(X)
  </annotation>
 </semantics>
</math>

.</p>

<p>The kernel of the boundary operator is 

<math display="inline" id="Singular_homology:28">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Z</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ker</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mo>∂</mo>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <ci>n</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">kernel</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{n}(X)=\ker(\partial_{n})
  </annotation>
 </semantics>
</math>

, and is called the <strong>group of singular <em>n</em>-cycles</strong>. The image of the boundary operator is 

<math display="inline" id="Singular_homology:29">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>B</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>im</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mo>∂</mo>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <ci>n</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <ci>im</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{n}(X)=\operatorname{im}(\partial_{n+1})
  </annotation>
 </semantics>
</math>

, and is called the <strong>group of singular <em>n</em>-boundaries</strong>.</p>

<p>It can also be shown that 

<math display="inline" id="Singular_homology:30">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>∂</mo>
     <mi>n</mi>
    </msub>
    <mo>∘</mo>
    <msub>
     <mo>∂</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial_{n}\circ\partial_{n+1}=0
  </annotation>
 </semantics>
</math>

. The 

<math display="inline" id="Singular_homology:31">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-th homology group of 

<math display="inline" id="Singular_homology:32">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is then defined as the <a href="factor_group" title="wikilink">factor group</a></p>

<p>

<math display="block" id="Singular_homology:33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>H</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mi>Z</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>/</mo>
      <msub>
       <mi>B</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>n</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Z</ci>
        <ci>n</ci>
       </apply>
       <ci>X</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{n}(X)=Z_{n}(X)/B_{n}(X).
  </annotation>
 </semantics>
</math>

</p>

<p>The elements of 

<math display="inline" id="Singular_homology:34">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>n</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{n}(X)
  </annotation>
 </semantics>
</math>

 are called <strong>homology classes</strong>.</p>
<h2 id="homotopy-invariance">Homotopy invariance</h2>

<p>If <em>X</em> and <em>Y</em> are two topological spaces with the same <a href="homotopy_type" title="wikilink">homotopy type</a>, then</p>

<p>

<math display="block" id="Singular_homology:35">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Y</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>n</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>n</ci>
     </apply>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{n}(X)=H_{n}(Y)\,
  </annotation>
 </semantics>
</math>

</p>

<p>for all <em>n</em> ≥ 0. This means homology groups are topological invariants.</p>

<p>In particular, if <em>X</em> is a connected <a href="contractible_space" title="wikilink">contractible space</a>, then all its homology groups are 0, except 

<math display="inline" id="Singular_homology:36">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>X</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{0}(X)=\mathbb{Z}
  </annotation>
 </semantics>
</math>

.</p>

<p>A proof for the homotopy invariance of singular homology groups can be sketched as follows. A continuous map <em>f</em>: <em>X</em> → <em>Y</em> induces a homomorphism</p>

<p>

<math display="block" id="Singular_homology:37">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi mathvariant="normal">♯</mi>
    </msub>
    <mo>:</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>C</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>→</mo>
     <mrow>
      <msub>
       <mi>C</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>normal-♯</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>n</ci>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>n</ci>
      </apply>
      <ci>Y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{\sharp}:C_{n}(X)\rightarrow C_{n}(Y).
  </annotation>
 </semantics>
</math>

</p>

<p>It can be verified immediately that</p>

<p>

<math display="block" id="Singular_homology:38">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>f</mi>
      <mi mathvariant="normal">♯</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi mathvariant="normal">♯</mi>
     </msub>
     <mo>∂</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <partialdiff></partialdiff>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>normal-♯</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>normal-♯</ci>
     </apply>
     <partialdiff></partialdiff>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial f_{\sharp}=f_{\sharp}\partial,
  </annotation>
 </semantics>
</math>

</p>

<p>i.e. <em>f</em><sub>#</sub> is a <a href="chain_complex#Chain_maps" title="wikilink">chain map</a>, which descends to homomorphisms on homology</p>

<p>

<math display="block" id="Singular_homology:39">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mo>*</mo>
    </msub>
    <mo>:</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>H</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>→</mo>
     <mrow>
      <msub>
       <mi>H</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <times></times>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>n</ci>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>n</ci>
      </apply>
      <ci>Y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{*}:H_{n}(X)\rightarrow H_{n}(Y).
  </annotation>
 </semantics>
</math>

</p>

<p>We now show that if <em>f</em> and <em>g</em> are homotopically equivalent, then <em>f</em><sub>*</sub> = <em>g</em><sub>*</sub>. From this follows that if <em>f</em> is a homotopy equivalence, then <em>f</em><sub>*</sub> is an isomorphism.</p>

<p>Let <em>F</em> : <em>X</em> × [0, 1] → <em>Y</em> be a homotopy that takes <em>f</em> to <em>g</em>. On the level of chains, define a homomorphism</p>

<p>

<math display="block" id="Singular_homology:40">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>C</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <msub>
      <mi>C</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>P</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>n</ci>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>Y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P:C_{n}(X)\rightarrow C_{n+1}(Y)
  </annotation>
 </semantics>
</math>

</p>

<p>that, geometrically speaking, takes a basis element σ: Δ<sup><em>n</em></sup> → <em>X</em> of <em>C<sub>n</sub></em>(<em>X</em>) to the "prism" <em>P</em>(σ): Δ<sup><em>n</em></sup> × <em>I</em> → <em>Y</em>. The boundary of <em>P</em>(σ) can be expressed as</p>

<p>

<math display="block" id="Singular_homology:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∂</mo>
      <mi>P</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>σ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mi>f</mi>
        <mi mathvariant="normal">♯</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>σ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>g</mi>
        <mi mathvariant="normal">♯</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>σ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>∂</mo>
        <mi>σ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <partialdiff></partialdiff>
      <ci>P</ci>
     </apply>
     <ci>σ</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>normal-♯</ci>
       </apply>
       <ci>σ</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>normal-♯</ci>
       </apply>
       <ci>σ</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <partialdiff></partialdiff>
       <ci>σ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial P(\sigma)=f_{\sharp}(\sigma)-g_{\sharp}(\sigma)+P(\partial\sigma).
  </annotation>
 </semantics>
</math>

</p>

<p>So if <em>α</em> in <em>C<sub>n</sub></em>(<em>X</em>) is an <em>n</em>-cycle, then <em>f</em><sub>#</sub>(<em>α</em> ) and <em>g</em><sub>#</sub>(<em>α</em>) differ by a boundary:</p>

<p>

<math display="block" id="Singular_homology:42">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>f</mi>
       <mi mathvariant="normal">♯</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>α</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>g</mi>
       <mi mathvariant="normal">♯</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>α</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>∂</mo>
      <mi>P</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>α</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>normal-♯</ci>
      </apply>
      <ci>α</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>normal-♯</ci>
      </apply>
      <ci>α</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <partialdiff></partialdiff>
      <ci>P</ci>
     </apply>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{\sharp}(\alpha)-g_{\sharp}(\alpha)=\partial P(\alpha),
  </annotation>
 </semantics>
</math>

</p>

<p>i.e. they are homologous. This proves the claim.</p>
<h2 id="functoriality">Functoriality</h2>

<p>The construction above can be defined for any topological space, and is preserved by the action of continuous maps. This generality implies that singular homology theory can be recast in the language of <a href="category_theory" title="wikilink">category theory</a>. In particular, the homology group can be understood to be a <a class="uri" href="functor" title="wikilink">functor</a> from the <a href="category_of_topological_spaces" title="wikilink">category of topological spaces</a> <strong>Top</strong> to the <a href="category_of_abelian_groups" title="wikilink">category of abelian groups</a> <strong>Ab</strong>.</p>

<p>Consider first that 

<math display="inline" id="Singular_homology:43">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>↦</mo>
   <mrow>
    <msub>
     <mi>C</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>X</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>n</ci>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\mapsto C_{n}(X)
  </annotation>
 </semantics>
</math>

 is a map from topological spaces to free abelian groups. This suggests that 

<math display="inline" id="Singular_homology:44">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>n</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}(X)
  </annotation>
 </semantics>
</math>

 might be taken to be a functor, provided one can understand its action on the <a href="morphism" title="wikilink">morphisms</a> of <strong>Top</strong>. Now, the morphisms of <strong>Top</strong> are continuous functions, so if 

<math display="inline" id="Singular_homology:45">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:X\to Y
  </annotation>
 </semantics>
</math>

 is a continuous map of topological spaces, it can be extended to a homomorphism of groups</p>

<p>

<math display="block" id="Singular_homology:46">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mo>*</mo>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>C</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <msub>
      <mi>C</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Y</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <times></times>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>n</ci>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>n</ci>
      </apply>
      <ci>Y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{*}:C_{n}(X)\to C_{n}(Y)\,
  </annotation>
 </semantics>
</math>

</p>

<p>by defining</p>

<p>

<math display="block" id="Singular_homology:47">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mo>*</mo>
    </msub>
    <mrow>
     <mo>(</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mi>i</mi>
      </munder>
      <mrow>
       <msub>
        <mi>a</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>σ</mi>
        <mi>i</mi>
       </msub>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mo>∘</mo>
       <msub>
        <mi>σ</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <times></times>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <compose></compose>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{*}\left(\sum_{i}a_{i}\sigma_{i}\right)=\sum_{i}a_{i}(f\circ\sigma_{i})
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Singular_homology:48">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mi>i</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi mathvariant="normal">Δ</mi>
     <mi>n</mi>
    </msup>
    <mo>→</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Δ</ci>
      <ci>n</ci>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{i}:\Delta^{n}\to X
  </annotation>
 </semantics>
</math>

 is a singular simplex, and 

<math display="inline" id="Singular_homology:49">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mi>i</mi>
   </msub>
   <mrow>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mpadded width="+1.7pt">
     <msub>
      <mi>σ</mi>
      <mi>i</mi>
     </msub>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i}a_{i}\sigma_{i}\,
  </annotation>
 </semantics>
</math>

 is a singular <em>n</em>-chain, that is, an element of 

<math display="inline" id="Singular_homology:50">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>n</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}(X)
  </annotation>
 </semantics>
</math>

. This shows that 

<math display="inline" id="Singular_homology:51">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}
  </annotation>
 </semantics>
</math>

 is a functor</p>

<p>

<math display="block" id="Singular_homology:52">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>n</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>𝕋</mi>
     <mi>𝕠</mi>
     <mi>𝕡</mi>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>𝔸</mi>
     <mi>𝕓</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>𝕋</ci>
      <ci>𝕠</ci>
      <ci>𝕡</ci>
     </apply>
     <apply>
      <times></times>
      <ci>𝔸</ci>
      <ci>𝕓</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}:\mathbb{Top}\to\mathbb{Ab}
  </annotation>
 </semantics>
</math>

</p>

<p>from the <a href="category_of_topological_spaces" title="wikilink">category of topological spaces</a> to the <a href="category_of_abelian_groups" title="wikilink">category of abelian groups</a>.</p>

<p>The boundary operator commutes with continuous maps, so that 

<math display="inline" id="Singular_homology:53">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>∂</mo>
     <mi>n</mi>
    </msub>
    <msub>
     <mi>f</mi>
     <mo>*</mo>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>f</mi>
     <mo>*</mo>
    </msub>
    <msub>
     <mo>∂</mo>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <times></times>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial_{n}f_{*}=f_{*}\partial_{n}
  </annotation>
 </semantics>
</math>

. This allows the entire chain complex to be treated as a functor. In particular, this shows that the map 

<math display="inline" id="Singular_homology:54">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>↦</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>X</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>n</ci>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\mapsto H_{n}(X)
  </annotation>
 </semantics>
</math>

 is a <a class="uri" href="functor" title="wikilink">functor</a></p>

<p>

<math display="block" id="Singular_homology:55">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>n</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>𝕋</mi>
     <mi>𝕠</mi>
     <mi>𝕡</mi>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>𝔸</mi>
     <mi>𝕓</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>𝕋</ci>
      <ci>𝕠</ci>
      <ci>𝕡</ci>
     </apply>
     <apply>
      <times></times>
      <ci>𝔸</ci>
      <ci>𝕓</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{n}:\mathbb{Top}\to\mathbb{Ab}
  </annotation>
 </semantics>
</math>

</p>

<p>from the category of topological spaces to the category of abelian groups. By the homotopy axiom, one has that 

<math display="inline" id="Singular_homology:56">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{n}
  </annotation>
 </semantics>
</math>

 is also a functor, called the <a href="homology_functor" title="wikilink">homology functor</a>, acting on <strong>hTop</strong>, the quotient <a href="homotopy_category" title="wikilink">homotopy category</a>:</p>

<p>

<math display="block" id="Singular_homology:57">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mi>𝕙</mi>
      <mi>𝕋</mi>
      <mi>𝕠</mi>
      <mi>𝕡</mi>
     </mrow>
     <mo>→</mo>
     <mrow>
      <mi>𝔸</mi>
      <mi>𝕓</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>𝕙</ci>
      <ci>𝕋</ci>
      <ci>𝕠</ci>
      <ci>𝕡</ci>
     </apply>
     <apply>
      <times></times>
      <ci>𝔸</ci>
      <ci>𝕓</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{n}:\mathbb{hTop}\to\mathbb{Ab}.
  </annotation>
 </semantics>
</math>

</p>

<p>This distinguishes singular homology from other homology theories, wherein 

<math display="inline" id="Singular_homology:58">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{n}
  </annotation>
 </semantics>
</math>

 is still a functor, but is not necessarily defined on all of <strong>Top</strong>. In some sense, singular homology is the "largest" homology theory, in that every homology theory on a <a class="uri" href="subcategory" title="wikilink">subcategory</a> of <strong>Top</strong> agrees with singular homology on that subcategory. On the other hand, the singular homology does not have the cleanest categorical properties; such a cleanup motivates the development of other homology theories such as <a href="cellular_homology" title="wikilink">cellular homology</a>.</p>

<p>More generally, the homology functor is defined axiomatically, as a functor on an <a href="abelian_category" title="wikilink">abelian category</a>, or, alternately, as a functor on <a href="chain_complex" title="wikilink">chain complexes</a>, satisfying axioms that require a <a href="boundary_morphism" title="wikilink">boundary morphism</a> that turns <a href="short_exact_sequence" title="wikilink">short exact sequences</a> into <a href="long_exact_sequence" title="wikilink">long exact sequences</a>. In the case of singular homology, the homology functor may be factored into two pieces, a topological piece and an algebraic piece. The topological piece is given by</p>

<p>

<math display="block" id="Singular_homology:59">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mo>∙</mo>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>𝕋</mi>
     <mi>𝕠</mi>
     <mi>𝕡</mi>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>ℂ</mi>
     <mi>𝕠</mi>
     <mi>𝕞</mi>
     <mi>𝕡</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>normal-∙</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>𝕋</ci>
      <ci>𝕠</ci>
      <ci>𝕡</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ℂ</ci>
      <ci>𝕠</ci>
      <ci>𝕞</ci>
      <ci>𝕡</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{\bullet}:\mathbb{Top}\to\mathbb{Comp}
  </annotation>
 </semantics>
</math>

</p>

<p>which maps topological spaces as 

<math display="inline" id="Singular_homology:60">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>C</mi>
      <mo>∙</mo>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <msub>
     <mo>∂</mo>
     <mo>∙</mo>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>X</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>normal-∙</ci>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <ci>normal-∙</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\mapsto(C_{\bullet}(X),\partial_{\bullet})
  </annotation>
 </semantics>
</math>

 and continuous functions as 

<math display="inline" id="Singular_homology:61">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>↦</mo>
   <msub>
    <mi>f</mi>
    <mo>*</mo>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>f</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\mapsto f_{*}
  </annotation>
 </semantics>
</math>

. Here, then, 

<math display="inline" id="Singular_homology:62">
 <semantics>
  <msub>
   <mi>C</mi>
   <mo>∙</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>normal-∙</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{\bullet}
  </annotation>
 </semantics>
</math>

 is understood to be the singular chain functor, which maps topological spaces to the <a href="category_of_chain_complexes" title="wikilink">category of chain complexes</a> <strong>Comp</strong> (or <strong>Kom</strong>). The category of chain complexes has chain complexes as its <a href="object_(category_theory)" title="wikilink">objects</a>, and <a href="chain_map" title="wikilink">chain maps</a> as its <a href="morphism" title="wikilink">morphisms</a>.</p>

<p>The second, algebraic part is the homology functor</p>

<p>

<math display="block" id="Singular_homology:63">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>n</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>ℂ</mi>
     <mi>𝕠</mi>
     <mi>𝕞</mi>
     <mi>𝕡</mi>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>𝔸</mi>
     <mi>𝕓</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>ℂ</ci>
      <ci>𝕠</ci>
      <ci>𝕞</ci>
      <ci>𝕡</ci>
     </apply>
     <apply>
      <times></times>
      <ci>𝔸</ci>
      <ci>𝕓</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{n}:\mathbb{Comp}\to\mathbb{Ab}
  </annotation>
 </semantics>
</math>

</p>

<p>which maps</p>

<p>

<math display="block" id="Singular_homology:64">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mo>∙</mo>
   </msub>
   <mo>↦</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>C</mi>
      <mo>∙</mo>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>Z</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>C</mi>
        <mo>∙</mo>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>/</mo>
     <msub>
      <mi>B</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>C</mi>
      <mo>∙</mo>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>normal-∙</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>normal-∙</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Z</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <ci>normal-∙</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>normal-∙</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{\bullet}\mapsto H_{n}(C_{\bullet})=Z_{n}(C_{\bullet})/B_{n}(C_{\bullet})
  </annotation>
 </semantics>
</math>

</p>

<p>and takes chain maps to maps of abelian groups. It is this homology functor that may be defined axiomatically, so that it stands on its own as a functor on the category of chain complexes.</p>

<p>Homotopy maps re-enter the picture by defining homotopically equivalent chain maps. Thus, one may define the <a href="quotient_category" title="wikilink">quotient category</a> <strong>hComp</strong> or <strong>K</strong>, the <a href="homotopy_category_of_chain_complexes" title="wikilink">homotopy category of chain complexes</a>.</p>
<h2 id="coefficients-in-r">Coefficients in <em>R</em></h2>

<p>Given any unital <a href="ring_(mathematics)" title="wikilink">ring</a> <em>R</em>, the set of singular <em>n</em>-simplices on a topological space can be taken to be the generators of a <a href="free_module" title="wikilink">free <em>R</em>-module</a>. That is, rather than performing the above constructions from the starting point of free abelian groups, one instead uses free <em>R</em>-modules in their place. All of the constructions go through with little or no change. The result of this is</p>

<p>

<math display="block" id="Singular_homology:65">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>n</ci>
    </apply>
    <interval closure="open">
     <ci>X</ci>
     <ci>R</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{n}(X,R)
  </annotation>
 </semantics>
</math>

</p>

<p>which is now an <a href="module_(mathematics)" title="wikilink"><em>R</em>-module</a>. Of course, it is usually <em>not</em> a free module. The usual homology group is regained by noting that</p>

<p>

<math display="block" id="Singular_homology:66">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>ℤ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>n</ci>
     </apply>
     <interval closure="open">
      <ci>X</ci>
      <ci>ℤ</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>n</ci>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{n}(X,\mathbb{Z})=H_{n}(X)
  </annotation>
 </semantics>
</math>

</p>

<p>when one takes the ring to be the ring of integers. The notation <em>H</em><sub><em>n</em></sub>(<em>X</em>, <em>R</em>) should not be confused with the nearly identical notation <em>H</em><sub><em>n</em></sub>(<em>X</em>, <em>A</em>), which denotes the relative homology (below).</p>
<h2 id="relative-homology">Relative homology</h2>

<p>For a subspace 

<math display="inline" id="Singular_homology:67">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>⊂</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>A</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\subset X
  </annotation>
 </semantics>
</math>

, the <a href="relative_homology" title="wikilink">relative homology</a> <em>H</em><sub><em>n</em></sub>(<em>X</em>, <em>A</em>) is understood to be the homology of the quotient of the chain complexes, that is,</p>

<p>

<math display="block" id="Singular_homology:68">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mrow>
        <msub>
         <mi>C</mi>
         <mo>∙</mo>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>X</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>/</mo>
       <msub>
        <mi>C</mi>
        <mo>∙</mo>
       </msub>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>n</ci>
     </apply>
     <interval closure="open">
      <ci>X</ci>
      <ci>A</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <ci>normal-∙</ci>
        </apply>
        <ci>X</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>normal-∙</ci>
       </apply>
      </apply>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{n}(X,A)=H_{n}(C_{\bullet}(X)/C_{\bullet}(A))
  </annotation>
 </semantics>
</math>

</p>

<p>where the quotient of chain complexes is given by the short exact sequence</p>

<p>

<math display="block" id="Singular_homology:69">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>C</mi>
     <mo>∙</mo>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>C</mi>
     <mo>∙</mo>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>C</mi>
       <mo>∙</mo>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>/</mo>
     <msub>
      <mi>C</mi>
      <mo>∙</mo>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>normal-∙</ci>
      </apply>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>normal-∙</ci>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <ci>normal-∙</ci>
        </apply>
        <ci>X</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>normal-∙</ci>
       </apply>
      </apply>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\to C_{\bullet}(A)\to C_{\bullet}(X)\to C_{\bullet}(X)/C_{\bullet}(A)\to 0.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="cohomology">Cohomology</h2>

<p>By dualizing the homology <a href="chain_complex" title="wikilink">chain complex</a> (i.e. applying the functor Hom(-, <em>R</em>), <em>R</em> being any ring) we obtain a <a href="cochain_complex" title="wikilink">cochain complex</a> with coboundary map 

<math display="inline" id="Singular_homology:70">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

. The <strong>cohomology groups</strong> of <em>X</em> are defined as the cohomology groups of this complex; in a quip, "cohomology is the homology of the co [the dual complex]".</p>

<p>The cohomology groups have a richer, or at least more familiar, algebraic structure than the homology groups. Firstly, they form a <a href="differential_graded_algebra" title="wikilink">differential graded algebra</a> as follows:</p>
<ul>
<li>the graded set of groups form a graded <em>R</em>-<a href="Module_(mathematics)" title="wikilink">module</a>;</li>
<li>this can be given the structure of a graded <em>R</em>-<a href="Algebra_(ring_theory)" title="wikilink">algebra</a> using the <a href="cup_product" title="wikilink">cup product</a>;</li>
<li>the <a href="Bockstein_homomorphism" title="wikilink">Bockstein homomorphism</a> <em>β</em> gives a differential.</li>
</ul>

<p>There are additional <a href="cohomology_operation" title="wikilink">cohomology operations</a>, and the cohomology algebra has addition structure mod <em>p</em> (as before, the mod <em>p</em> cohomology is the cohomology of the mod <em>p</em> cochain complex, not the mod <em>p</em> reduction of the cohomology), notably the <a href="Steenrod_algebra" title="wikilink">Steenrod algebra</a> structure.</p>
<h2 id="betti-homology-and-cohomology">Betti homology and cohomology</h2>

<p>Since the number of <a href="homology_theories" title="wikilink">homology theories</a> has become large (see <a href=":Category:Homology_theory" title="wikilink">:Category:Homology theory</a>), the terms <strong><em>Betti homology</em></strong> and <strong><em>Betti cohomology</em></strong> are sometimes applied (particularly by authors writing on <a href="algebraic_geometry" title="wikilink">algebraic geometry</a>) to the singular theory, as giving rise to the <a href="Betti_number" title="wikilink">Betti numbers</a> of the most familiar spaces such as <a href="simplicial_complex" title="wikilink">simplicial complexes</a> and <a href="closed_manifold" title="wikilink">closed manifolds</a>.</p>
<h2 id="extraordinary-homology">Extraordinary homology</h2>

<p>If one defines a homology theory axiomatically (via the <a href="Eilenberg–Steenrod_axioms" title="wikilink">Eilenberg–Steenrod axioms</a>), and then relaxes one of the axioms (the <em>dimension axiom</em>), one obtains a generalized theory, called an <a href="extraordinary_homology_theory" title="wikilink">extraordinary homology theory</a>. These originally arose in the form of <a href="extraordinary_cohomology_theories" title="wikilink">extraordinary cohomology theories</a>, namely <a class="uri" href="K-theory" title="wikilink">K-theory</a> and <a href="cobordism_theory" title="wikilink">cobordism theory</a>. In this context, singular homology is referred to as <strong>ordinary homology.</strong></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Derived_category" title="wikilink">Derived category</a></li>
<li><a href="Excision_theorem" title="wikilink">Excision theorem</a></li>
<li><a href="Hurewicz_theorem" title="wikilink">Hurewicz theorem</a></li>
<li><a href="Simplicial_homology" title="wikilink">Simplicial homology</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Allen Hatcher, <a href="http://www.math.cornell.edu/~hatcher/AT/ATpage.html"><em>Algebraic topology.</em></a> Cambridge University Press, ISBN 0-521-79160-X and ISBN 0-521-79540-0</li>
<li>J.P. May, <em>A Concise Course in Algebraic Topology</em>, Chicago University Press ISBN 0-226-51183-9</li>
<li>Joseph J. Rotman, <em>An Introduction to Algebraic Topology</em>, Springer-Verlag, ISBN 0-387-96678-1</li>
</ul>

<p>"</p>

<p><a href="Category:Homology_theory" title="wikilink">Category:Homology theory</a></p>
</body>
</html>
