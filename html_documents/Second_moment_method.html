<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="823">Second moment method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Second moment method</h1>
<hr/>

<p>In mathematics, the <strong>second moment method</strong> is a technique used in <a href="probability_theory" title="wikilink">probability theory</a> and <a class="uri" href="analysis" title="wikilink">analysis</a> to show that a <a href="random_variable" title="wikilink">random variable</a> has positive probability of being positive. More generally, the "moment method" consists of bounding the probability that a random variable fluctuates far from its mean, by using its moments.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The method is often quantitative, in that one can often deduce a lower bound on the probability that the random variable is larger than some constant times its expectation. The method involves comparing the second <a href="moment_(mathematics)" title="wikilink">moment</a> of random variables to the square of the first moment.</p>
<h2 id="first-moment-method">First moment method</h2>

<p>The first moment method is a simple application of <a href="Markov's_inequality" title="wikilink">Markov's inequality</a> for integer-valued variables. For a <strong>non-negative</strong>, <strong>integer-valued</strong> random variable <em>X</em>, we may want to prove that <em>X</em> = 0 with high probability. To obtain an upper bound for P(<em>X</em> &gt; 0), and thus a lower bound for P(<em>X</em> = 0), we first note that since <em>X</em> takes only integer values, P(<em>X</em> &gt; 0) = P(<em>X</em> ≥ 1). Since <em>X</em> is non-negative we can now apply <a href="Markov's_inequality" title="wikilink">Markov's inequality</a> to obtain P(<em>X</em> ≥ 1) ≤ E[<em>X</em>]. Combining these we have P(<em>X</em> &gt; 0) ≤ E[<em>X</em>]; the first moment method is simply the use of this inequality.</p>
<h2 id="second-moment-method">Second moment method</h2>

<p>In the other direction, E[<em>X</em>] being "large" does not directly imply that P(<em>X</em> = 0) is small. However, we can often use the second moment to derive such a conclusion, using <a href="Cauchy–Schwarz_inequality" title="wikilink">Cauchy–Schwarz inequality</a>.</p>

<p><strong>Theorem</strong>: If <em>X</em> ≥ 0 is a <a href="random_variable" title="wikilink">random variable</a> with finite variance, then</p>

<p>

<math display="block" id="Second_moment_method:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>P</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>X</mi>
       <mo>></mo>
       <mn>0</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mfrac>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>E</mo>
        <mrow>
         <mo stretchy="false">[</mo>
         <mi>X</mi>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo>E</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <msup>
        <mi>X</mi>
        <mn>2</mn>
       </msup>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <ci>normal-P</ci>
     <apply>
      <gt></gt>
      <ci>X</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-E</ci>
       <ci>X</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <ci>normal-E</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>X</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{P}(X>0)\geq\frac{(\operatorname{E}[X])^{2}}{\operatorname{E}[X^{%
2}]}.
  </annotation>
 </semantics>
</math>

</p>

<p><strong>Proof</strong>: Using the <a href="Cauchy-Schwarz_inequality" title="wikilink">Cauchy-Schwarz inequality</a>, we have</p>

<p>

<math display="block" id="Second_moment_method:1">
 <semantics>
  <mrow>
   <mo>E</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>X</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mo>E</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>X</mi>
    <msub>
     <mn mathvariant="bold">1</mn>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>X</mi>
      <mo>></mo>
      <mn>0</mn>
      <mo stretchy="false">}</mo>
     </mrow>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≤</mo>
   <mo>E</mo>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <msup>
      <mi>X</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">]</mo>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </msup>
   <mo>P</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>></mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </msup>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-E</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <ci>normal-E</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">X</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="float">1</cn>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-{</ci>
       <csymbol cd="unknown">X</csymbol>
       <gt></gt>
       <cn type="integer">0</cn>
       <ci>normal-}</ci>
      </cerror>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <leq></leq>
    <ci>normal-E</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>X</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-]</ci>
     </cerror>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>normal-P</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">X</csymbol>
      <gt></gt>
      <cn type="integer">0</cn>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{E}[X]=\operatorname{E}[X\,\mathbf{1}_{\{X>0\}}]\leq\operatorname%
{E}[X^{2}]^{1/2}\operatorname{P}(X>0)^{1/2}.
  </annotation>
 </semantics>
</math>

 Solving for 

<math display="inline" id="Second_moment_method:2">
 <semantics>
  <mrow>
   <mo>P</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>X</mi>
     <mo>></mo>
     <mn>0</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-P</ci>
    <apply>
     <gt></gt>
     <ci>X</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{P}(X>0)
  </annotation>
 </semantics>
</math>

, the desired inequality then follows. ∎</p>

<p>The method can also be used on distributional limits of random variables. Furthermore, the estimate of the previous theorem can be refined by means of the so-called <a href="Paley–Zygmund_inequality" title="wikilink">Paley–Zygmund inequality</a>. Suppose that <em>X<sub>n</sub></em> is a sequence of non-negative real-valued random variables which <a href="converge_in_law" title="wikilink">converge in law</a> to a random variable <em>X</em>. If there are finite positive constants <em>c</em><sub>1</sub>, <em>c</em><sub>2</sub> such that</p>

<p>

<math display="block" id="Second_moment_method:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo>[</mo>
     <msubsup>
      <mi>X</mi>
      <mi>n</mi>
      <mn>2</mn>
     </msubsup>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <msub>
     <mi>c</mi>
     <mn>1</mn>
    </msub>
    <mi>E</mi>
    <msup>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>X</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\left[X_{n}^{2}\right]\leq c_{1}E[X_{n}]^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Second_moment_method:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo>[</mo>
     <msub>
      <mi>X</mi>
      <mi>n</mi>
     </msub>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <msub>
    <mi>c</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\left[X_{n}\right]\geq c_{2}
  </annotation>
 </semantics>
</math>

</p>

<p>hold for every <em>n</em>, then it follows from the <a href="Paley–Zygmund_inequality" title="wikilink">Paley–Zygmund inequality</a> that for every <em>n</em> and θ in (0, 1)</p>

<p>

<math display="block" id="Second_moment_method:5">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo>≥</mo>
    <msub>
     <mi>c</mi>
     <mn>2</mn>
    </msub>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≥</mo>
   <mfrac>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>θ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <msub>
     <mi>c</mi>
     <mn>1</mn>
    </msub>
   </mfrac>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">2</cn>
     </apply>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <geq></geq>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>θ</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X_{n}\geq c_{2}\theta)\geq\frac{(1-\theta)^{2}}{c_{1}}.
  </annotation>
 </semantics>
</math>

</p>

<p>Consequently, the same inequality is satisfied by <em>X</em>.</p>
<h2 id="example-application-of-method">Example application of method</h2>
<h3 id="setup-of-problem">Setup of problem</h3>

<p>The <a href="Bernoulli_bond_percolation" title="wikilink">Bernoulli bond percolation</a> <a href="Glossary_of_graph_theory#Subgraphs" title="wikilink">subgraph</a> of a graph <em>G</em> at parameter <em>p</em> is a random subgraph obtained from <em>G</em> by deleting every edge of <em>G</em> with probability 1−<em>p</em>, independently. The <a href="binary_tree" title="wikilink">infinite complete binary tree</a> <em>T</em> is an infinite <a href="tree_(graph_theory)" title="wikilink">tree</a> where one vertex (called the root) has two neighbors and every other vertex has three neighbors. The second moment method can be used to show that at every parameter <em>p</em> ∈ (1/2, 1] with positive probability the connected component of the root in the percolation subgraph of <em>T</em> is infinite.</p>
<h3 id="application-of-method">Application of method</h3>

<p>Let <em>K</em> be the percolation component of the root, and let <em>T<sub>n</sub></em> be the set of vertices of <em>T</em> that are at distance <em>n</em> from the root. Let <em>X<sub>n</sub></em> be the number of vertices in <em>T<sub>n</sub></em> ∩ <em>K</em>. To prove that <em>K</em> is infinite with positive probability, it is enough to show that 

<math display="inline" id="Second_moment_method:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>lim sup</mo>
     <mrow>
      <mi>n</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
    <msub>
     <mn>1</mn>
     <mrow>
      <msub>
       <mi>X</mi>
       <mi>n</mi>
      </msub>
      <mo>></mo>
      <mn>0</mn>
     </mrow>
    </msub>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">limit-supremum</csymbol>
      <apply>
       <ci>normal-→</ci>
       <ci>n</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">1</cn>
      <apply>
       <gt></gt>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \limsup_{n\to\infty}1_{X_{n}>0}>0
  </annotation>
 </semantics>
</math>

 with positive probability. By the <a href="reverse_Fatou_lemma" title="wikilink">reverse Fatou lemma</a>, it suffices to show that 

<math display="inline" id="Second_moment_method:7">
 <semantics>
  <mrow>
   <msub>
    <mo>inf</mo>
    <mrow>
     <mi>n</mi>
     <mo>→</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
   </msub>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo>></mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">infimum</csymbol>
     <apply>
      <ci>normal-→</ci>
      <ci>n</ci>
      <infinity></infinity>
     </apply>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
     <gt></gt>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
    <gt></gt>
    <cn type="integer">0</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \inf_{n\to\infty}P(X_{n}>0)>0
  </annotation>
 </semantics>
</math>

. The <a href="Cauchy–Schwarz_inequality" title="wikilink">Cauchy–Schwarz inequality</a> gives</p>

<p>

<math display="block" id="Second_moment_method:8">
 <semantics>
  <mrow>
   <mi>E</mi>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>X</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>≤</mo>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msubsup>
     <mi>X</mi>
     <mi>n</mi>
     <mn>2</mn>
    </msubsup>
    <mo rspace="4.2pt" stretchy="false">]</mo>
   </mrow>
   <mi>E</mi>
   <mrow>
    <mo>[</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mn>1</mn>
       <mrow>
        <msub>
         <mi>X</mi>
         <mi>n</mi>
        </msub>
        <mo>></mo>
        <mn>0</mn>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>]</mo>
   </mrow>
   <mo>=</mo>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msubsup>
     <mi>X</mi>
     <mi>n</mi>
     <mn>2</mn>
    </msubsup>
    <mo rspace="4.2pt" stretchy="false">]</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo>></mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>n</ci>
      </apply>
      <ci>normal-]</ci>
     </cerror>
     <cn type="integer">2</cn>
    </apply>
    <leq></leq>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>n</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <cn type="integer">1</cn>
        <apply>
         <gt></gt>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <ci>n</ci>
         </apply>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>n</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
     <gt></gt>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[X_{n}]^{2}\leq E[X_{n}^{2}]\,E\left[(1_{X_{n}>0})^{2}\right]=E[X_{n}^{2}]\,P%
(X_{n}>0).
  </annotation>
 </semantics>
</math>

 Therefore, it is sufficient to show that</p>

<p>

<math display="block" id="Second_moment_method:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mo movablelimits="false">inf</mo>
      <mi>n</mi>
     </munder>
     <mfrac>
      <mrow>
       <mi>E</mi>
       <msup>
        <mrow>
         <mo>[</mo>
         <msub>
          <mi>X</mi>
          <mi>n</mi>
         </msub>
         <mo>]</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
      <mrow>
       <mi>E</mi>
       <mrow>
        <mo>[</mo>
        <msubsup>
         <mi>X</mi>
         <mi>n</mi>
         <mn>2</mn>
        </msubsup>
        <mo>]</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
    <mo>></mo>
    <mpadded width="+1.7pt">
     <mn>0</mn>
    </mpadded>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">infimum</csymbol>
      <ci>n</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <ci>n</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \inf_{n}\frac{E\left[X_{n}\right]^{2}}{E\left[X_{n}^{2}\right]}>0\,,
  </annotation>
 </semantics>
</math>

 that is, that the second moment is bounded from above by a constant times the first moment squared (and both are nonzero). In many applications of the second moment method, one is not able to calculate the moments precisely, but can nevertheless establish this inequality.</p>

<p>In this particular application, these moments can be calculated. For every specific <em>v</em> in <em>T<sub>n</sub></em>,</p>

<p>

<math display="block" id="Second_moment_method:10">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo>∈</mo>
    <mi>K</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>p</mi>
    <mi>n</mi>
   </msup>
   <mo rspace="4.2pt">.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">v</csymbol>
     <in></in>
     <csymbol cd="unknown">K</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>p</ci>
     <ci>n</ci>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(v\in K)=p^{n}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>Since 

<math display="inline" id="Second_moment_method:11">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>T</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |T_{n}|=2^{n}
  </annotation>
 </semantics>
</math>

, it follows that</p>

<p>

<math display="block" id="Second_moment_method:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>X</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <msup>
      <mn>2</mn>
      <mi>n</mi>
     </msup>
    </mpadded>
    <msup>
     <mi>p</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E[X_{n}]=2^{n}\,p^{n}
  </annotation>
 </semantics>
</math>

</p>

<p>which is the first moment. Now comes the second moment calculation.</p>

<p>

<math display="block" id="Second_moment_method:13">
 <semantics>
  <mrow>
   <mpadded width="-1.7pt">
    <mi>E</mi>
   </mpadded>
   <mrow>
    <mo>[</mo>
    <msubsup>
     <mi>X</mi>
     <mi>n</mi>
     <mn>2</mn>
    </msubsup>
    <mo>]</mo>
   </mrow>
   <mo>=</mo>
   <mpadded width="-1.7pt">
    <mi>E</mi>
   </mpadded>
   <mrow>
    <mo>[</mo>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>v</mi>
      <mo>∈</mo>
      <msub>
       <mi>T</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </munder>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>u</mi>
      <mo>∈</mo>
      <msub>
       <mi>T</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </munder>
    <msub>
     <mn>1</mn>
     <mrow>
      <mi>v</mi>
      <mo>∈</mo>
      <mi>K</mi>
     </mrow>
    </msub>
    <msub>
     <mn>1</mn>
     <mrow>
      <mi>u</mi>
      <mo>∈</mo>
      <mi>K</mi>
     </mrow>
    </msub>
    <mo>]</mo>
   </mrow>
   <mo>=</mo>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>v</mi>
     <mo>∈</mo>
     <msub>
      <mi>T</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </munder>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>u</mi>
     <mo>∈</mo>
     <msub>
      <mi>T</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </munder>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo>,</mo>
    <mi>u</mi>
    <mo>∈</mo>
    <mi>K</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>n</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>v</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>u</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">1</cn>
      <apply>
       <in></in>
       <ci>v</ci>
       <ci>K</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="float">1</cn>
      <apply>
       <in></in>
       <ci>u</ci>
       <ci>K</ci>
      </apply>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <ci>v</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <ci>u</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">u</csymbol>
     <in></in>
     <csymbol cd="unknown">K</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\!\left[X_{n}^{2}\right]=E\!\left[\sum_{v\in T_{n}}\sum_{u\in T_{n}}1_{v\in K%
}\,1_{u\in K}\right]=\sum_{v\in T_{n}}\sum_{u\in T_{n}}P(v,u\in K).
  </annotation>
 </semantics>
</math>

</p>

<p>For each pair <em>v</em>, <em>u</em> in <em>T<sub>n</sub></em> let <em>w(v, u)</em> denote the vertex in <em>T</em> that is farthest away from the root and lies on the simple path in <em>T</em> to each of the two vertices <em>v</em> and <em>u</em>, and let <em>k(v, u)</em> denote the distance from <em>w</em> to the root. In order for <em>v</em>, <em>u</em> to both be in <em>K</em>, it is necessary and sufficient for the three simple paths from <em>w(v, u)</em> to <em>v</em>, <em>u</em> and the root to be in <em>K</em>. Since the number of edges contained in the union of these three paths is 2<em>n</em> − <em>k(v, u)</em>, we obtain</p>

<p>

<math display="block" id="Second_moment_method:14">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo>,</mo>
    <mi>u</mi>
    <mo>∈</mo>
    <mi>K</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>p</mi>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>n</mi>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>k</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo>,</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">u</csymbol>
     <in></in>
     <csymbol cd="unknown">K</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>p</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>k</ci>
       <interval closure="open">
        <ci>v</ci>
        <ci>u</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(v,u\in K)=p^{2n-k(v,u)}.
  </annotation>
 </semantics>
</math>

</p>

<p>The number of pairs <em>(v, u)</em> such that <em>k(v, u)</em> = <em>s</em> is equal to 

<math display="inline" id="Second_moment_method:15">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mn>2</mn>
     <mi>s</mi>
    </msup>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mi>s</mi>
     </mrow>
    </msup>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mi>s</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>n</mi>
     </mrow>
     <mo>-</mo>
     <mi>s</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>s</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="float">2</cn>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="float">2</cn>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{s}\,2^{n-s}\,2^{n-s-1}=2^{2n-s-1}
  </annotation>
 </semantics>
</math>

, for <em>s</em> = 0, 1, ..., <em>n</em>. Hence,</p>

<p>

<math display="block" id="Second_moment_method:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="-1.7pt">
      <mi>E</mi>
     </mpadded>
     <mrow>
      <mo>[</mo>
      <msubsup>
       <mi>X</mi>
       <mi>n</mi>
       <mn>2</mn>
      </msubsup>
      <mo>]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>s</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msup>
       <mn>2</mn>
       <mrow>
        <mrow>
         <mn>2</mn>
         <mi>n</mi>
        </mrow>
        <mo>-</mo>
        <mi>s</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <msup>
       <mi>p</mi>
       <mrow>
        <mrow>
         <mn>2</mn>
         <mi>n</mi>
        </mrow>
        <mo>-</mo>
        <mi>s</mi>
       </mrow>
      </msup>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </mpadded>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>2</mn>
        <mi>p</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>n</mi>
     </msup>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>s</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>2</mn>
         <mi>p</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>s</mi>
      </msup>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </mpadded>
     <mpadded width="+1.7pt">
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>2</mn>
         <mi>p</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>n</mi>
      </msup>
     </mpadded>
     <mfrac>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>2</mn>
          <mi>p</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mrow>
        <mn>2</mn>
        <mi>p</mi>
       </mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mfrac>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mfrac>
       <mi>p</mi>
       <mrow>
        <mrow>
         <mn>2</mn>
         <mi>p</mi>
        </mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mfrac>
     </mpadded>
     <mi>E</mi>
     <msup>
      <mrow>
       <mo stretchy="false">[</mo>
       <msub>
        <mi>X</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">]</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>n</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>s</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>n</ci>
         </apply>
         <ci>s</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>n</ci>
         </apply>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>p</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>s</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>p</ci>
        </apply>
        <ci>s</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>p</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>p</ci>
         </apply>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>p</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>p</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>p</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>E</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\!\left[X_{n}^{2}\right]=\sum_{s=0}^{n}2^{2n-s-1}p^{2n-s}=\frac{1}{2}\,(2p)^{%
n}\sum_{s=0}^{n}(2p)^{s}=\frac{1}{2}\,(2p)^{n}\,\frac{(2p)^{n+1}-1}{2p-1}\leq%
\frac{p}{2p-1}\,E[X_{n}]^{2},
  </annotation>
 </semantics>
</math>

</p>

<p>which completes the proof.</p>
<h3 id="discussion">Discussion</h3>
<ul>
<li>The choice of the random variables <em>X</em><sub><em>n</em></sub> was rather natural in this setup. In some more difficult applications of the method, some ingenuity might be required in order to choose the random variables <em>X</em><sub><em>n</em></sub> for which the argument can be carried through.</li>
<li>The <a href="Paley–Zygmund_inequality" title="wikilink">Paley–Zygmund inequality</a> is sometimes used instead of the <a href="Cauchy–Schwarz_inequality" title="wikilink">Cauchy–Schwarz inequality</a> and may occasionally give more refined results.</li>
<li>Under the (incorrect) assumption that the events <em>v</em>, <em>u</em> in <em>K</em> are always independent, one has 

<math display="inline" id="Second_moment_method:17">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo>,</mo>
    <mi>u</mi>
    <mo>∈</mo>
    <mi>K</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo>∈</mo>
    <mi>K</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>∈</mo>
    <mi>K</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">u</csymbol>
     <in></in>
     <csymbol cd="unknown">K</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">v</csymbol>
     <in></in>
     <csymbol cd="unknown">K</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">u</csymbol>
     <in></in>
     <csymbol cd="unknown">K</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(v,u\in K)=P(v\in K)\,P(u\in K)
  </annotation>
 </semantics>
</math>

, and the second moment is equal to the first moment squared. The second moment method typically works in situations in which the corresponding events or random variables are “nearly independent".</li>
<li>In this application, the random variables <em>X</em><sub><em>n</em></sub> are given as sums</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Second_moment_method:18">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>v</mi>
       <mo>∈</mo>
       <msub>
        <mi>T</mi>
        <mi>n</mi>
       </msub>
      </mrow>
     </msub>
     <msub>
      <mn>1</mn>
      <mrow>
       <mi>v</mi>
       <mo>∈</mo>
       <mi>K</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>v</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">1</cn>
      <apply>
       <in></in>
       <ci>v</ci>
       <ci>K</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{n}=\sum_{v\in T_{n}}1_{v\in K}.
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
<dd>In other applications, the corresponding useful random variables are <a href="integral" title="wikilink">integrals</a>

<p>

<math display="block" id="Second_moment_method:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <msub>
       <mi>f</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>μ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>n</ci>
      </apply>
      <ci>t</ci>
      <ci>d</ci>
      <ci>μ</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{n}=\int f_{n}(t)\,d\mu(t),
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>where the functions <em>f</em><sub><em>n</em></sub> are random. In such a situation, one considers the product measure <em>μ</em> × <em>μ</em> and calculates

<p>:<math> \begin{align}</math></p>
</dd>
</dl>

<p>E \left[X_n^2 \right ] &amp; = E\left[\int\int f_n(x)\,f_n(y)\,d\mu(x)\,d\mu(y)\right ] \\ &amp; = E\left[ \int\int E\left[f_n(x)\,f_n(y)\right]\,d\mu(x)\,d\mu(y)\right ], \end{align}</p>
<dl>
<dd>where the last step is typically justified using <a href="Fubini's_theorem" title="wikilink">Fubini's theorem</a>.
</dd>
</dl>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
<references>
</references>

<p>"</p>

<p><a href="Category:Probabilistic_inequalities" title="wikilink">Category:Probabilistic inequalities</a> <a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
