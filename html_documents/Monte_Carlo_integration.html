<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1708">Monte Carlo integration</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Monte Carlo integration</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>An illustration of Monte Carlo integration. In this example, the domain <em>D</em> is the inner circle and the domain E is the square. Because the square's area (4) can be easily calculated, the area of the circle (π*1<sup>2</sup>) can be estimated by the ratio (0.8) of the points inside the circle (40) to the total number of points (50), yielding an approximation for the circle's area of 4*0.8 = 3.2 ≈ π*1<sup>2</sup>.</figcaption>
</figure>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <strong>Monte Carlo integration</strong> is a technique for <a href="numerical_quadrature" title="wikilink">numerical integration</a> using <a href="pseudorandomness" title="wikilink">random numbers</a>. It is a particular <a href="Monte_Carlo_method" title="wikilink">Monte Carlo method</a> that numerically computes a <a href="definite_integral" title="wikilink">definite integral</a>. While other algorithms usually evaluate the integrand at a regular grid,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Monte Carlo randomly choose points at which the integrand is evaluated.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> This method is particularly useful for higher-dimensional integrals.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>There are different methods to perform a Monte Carlo integration, such as <a href="Uniform_distribution_(continuous)" title="wikilink">uniform sampling</a>, <a href="stratified_sampling" title="wikilink">stratified sampling</a>, <a href="importance_sampling" title="wikilink">importance sampling</a>, <a href="Particle_filter" title="wikilink">Sequential Monte Carlo</a> (a.k.a. particle filter), <a href="Mean_field_particle_methods" title="wikilink">and mean field particle methods.</a></p>
<h2 id="overview">Overview</h2>

<p>In numerical integration, methods such as the <a href="Trapezoidal_rule" title="wikilink">Trapezoidal rule</a> use a <a href="Deterministic_algorithm" title="wikilink">deterministic approach</a>. Monte Carlo integration, on the other hand, employs a <a href="Stochastic" title="wikilink">non-deterministic</a> approach: each realization provides a different outcome. In Monte Carlo, the final outcome is an approximation of the correct value with respective error bars, and the correct value is within those error bars.</p>

<p>The problem Monte Carlo integration addresses is the computation of a <a href="Multiple_integral" title="wikilink">multidimensional definite integral</a></p>

<p>

<math display="block" id="Monte_Carlo_integration:0">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi mathvariant="normal">Ω</mi>
    </msub>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>𝐱</mi>
       <mo>¯</mo>
      </mover>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mover accent="true">
      <mi>𝐱</mi>
      <mo>¯</mo>
     </mover>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>I</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>normal-Ω</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>𝐱</ci>
      </apply>
      <ci>d</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>𝐱</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I=\int_{\Omega}f(\overline{\mathbf{x}})\,d\overline{\mathbf{x}}
  </annotation>
 </semantics>
</math>

</p>

<p>where Ω, a subset of <strong>R</strong><sup><em>m</em></sup>, has volume</p>

<p>

<math display="block" id="Monte_Carlo_integration:1">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi mathvariant="normal">Ω</mi>
    </msub>
    <mrow>
     <mi>d</mi>
     <mover accent="true">
      <mi>𝐱</mi>
      <mo>¯</mo>
     </mover>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>V</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>normal-Ω</ci>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>𝐱</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V=\int_{\Omega}d\overline{\mathbf{x}}
  </annotation>
 </semantics>
</math>

</p>

<p>The naive Monte Carlo approach is to sample points uniformly on Ω:<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> given <em>N</em> uniform samples,</p>

<p>

<math display="block" id="Monte_Carlo_integration:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>𝐱</mi>
       <mo>¯</mo>
      </mover>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>,</mo>
     <msub>
      <mover accent="true">
       <mi>𝐱</mi>
       <mo>¯</mo>
      </mover>
      <mi>N</mi>
     </msub>
    </mrow>
    <mo>∈</mo>
    <mi mathvariant="normal">Ω</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <ci>𝐱</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¯</ci>
       <ci>𝐱</ci>
      </apply>
      <ci>N</ci>
     </apply>
    </list>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{\mathbf{x}}_{1},\cdots,\overline{\mathbf{x}}_{N}\in\Omega,
  </annotation>
 </semantics>
</math>

</p>

<p><em>I</em> can be approximated by</p>

<p>

<math display="block" id="Monte_Carlo_integration:3">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mo>≈</mo>
   <msub>
    <mi>Q</mi>
    <mi>N</mi>
   </msub>
   <mo>≡</mo>
   <mrow>
    <mi>V</mi>
    <mfrac>
     <mn>1</mn>
     <mi>N</mi>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mover accent="true">
         <mi>𝐱</mi>
         <mo>¯</mo>
        </mover>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>f</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <approx></approx>
     <ci>I</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>V</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>N</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-¯</ci>
          <ci>𝐱</ci>
         </apply>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>V</ci>
      <apply>
       <csymbol cd="latexml">delimited-⟨⟩</csymbol>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I\approx Q_{N}\equiv V\frac{1}{N}\sum_{i=1}^{N}f(\overline{\mathbf{x}}_{i})=V%
\langle f\rangle
  </annotation>
 </semantics>
</math>

.</p>

<p>This is because the <a href="law_of_large_numbers" title="wikilink">law of large numbers</a> ensures that</p>

<p>

<math display="block" id="Monte_Carlo_integration:4">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo movablelimits="false">lim</mo>
     <mrow>
      <mi>N</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </munder>
    <msub>
     <mi>Q</mi>
     <mi>N</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>N</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim_{N\to\infty}Q_{N}=I
  </annotation>
 </semantics>
</math>

.</p>

<p>Given the estimation of <em>I</em> from <em>Q<sub>N</sub></em>, the error bars of <em>Q<sub>N</sub></em> can be estimated by the <a href="Sample_variance#Population_variance_and_sample_variance" title="wikilink">sample variance</a> using the <a href="Bias_of_an_estimator#Sample_variance" title="wikilink">unbiased estimate of the variance</a>:</p>

<p>

<math display="block" id="Monte_Carlo_integration:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Var</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <msubsup>
     <mi>σ</mi>
     <mi>N</mi>
     <mn>2</mn>
    </msubsup>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mfrac>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>N</mi>
      </munderover>
      <msup>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mover accent="true">
             <mi>𝐱</mi>
             <mo>¯</mo>
            </mover>
            <mi>i</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mo stretchy="false">⟨</mo>
          <mi>f</mi>
          <mo stretchy="false">⟩</mo>
         </mrow>
        </mrow>
        <mo>)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <times></times>
      <ci>Var</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>N</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>f</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <ci>normal-¯</ci>
            <ci>𝐱</ci>
           </apply>
           <ci>i</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="latexml">delimited-⟨⟩</csymbol>
          <ci>f</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Var}(f)\equiv\sigma_{N}^{2}=\frac{1}{N-1}\sum_{i=1}^{N}\left(f(%
\overline{\mathbf{x}}_{i})-\langle f\rangle\right)^{2}.
  </annotation>
 </semantics>
</math>

</p>

<p>which leads to</p>

<p>

<math display="block" id="Monte_Carlo_integration:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>Var</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>Q</mi>
      <mi>N</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <msup>
      <mi>V</mi>
      <mn>2</mn>
     </msup>
     <msup>
      <mi>N</mi>
      <mn>2</mn>
     </msup>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <mi>Var</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>V</mi>
     <mn>2</mn>
    </msup>
    <mfrac>
     <mrow>
      <mi>Var</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mi>N</mi>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>V</mi>
     <mn>2</mn>
    </msup>
    <mfrac>
     <msubsup>
      <mi>σ</mi>
      <mi>N</mi>
      <mn>2</mn>
     </msubsup>
     <mi>N</mi>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>Var</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>N</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>V</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>N</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
       <apply>
        <times></times>
        <ci>Var</ci>
        <ci>f</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>V</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>Var</ci>
        <ci>f</ci>
       </apply>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>V</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <ci>N</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Var}(Q_{N})=\frac{V^{2}}{N^{2}}\sum_{i=1}^{N}\mathrm{Var}(f)=V^{2}%
\frac{\mathrm{Var}(f)}{N}=V^{2}\frac{\sigma_{N}^{2}}{N}
  </annotation>
 </semantics>
</math>

.</p>

<p>As long as the sequence</p>

<p>

<math display="block" id="Monte_Carlo_integration:7">
 <semantics>
  <mrow>
   <mo>{</mo>
   <msubsup>
    <mi>σ</mi>
    <mn>1</mn>
    <mn>2</mn>
   </msubsup>
   <mo>,</mo>
   <msubsup>
    <mi>σ</mi>
    <mn>2</mn>
    <mn>2</mn>
   </msubsup>
   <mo>,</mo>
   <msubsup>
    <mi>σ</mi>
    <mn>3</mn>
    <mn>2</mn>
   </msubsup>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">3</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{\sigma_{1}^{2},\sigma_{2}^{2},\sigma_{3}^{2},\ldots\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>is bounded, this variance decreases asymptotically to zero as 1/<em>N</em>. The estimation of the error of <em>Q<sub>N</sub></em> is thus</p>

<p>

<math display="block" id="Monte_Carlo_integration:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>δ</mi>
     <msub>
      <mi>Q</mi>
      <mi>N</mi>
     </msub>
    </mrow>
    <mo>≈</mo>
    <msqrt>
     <mrow>
      <mi>Var</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>Q</mi>
        <mi>N</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msqrt>
    <mo>=</mo>
    <mrow>
     <mi>V</mi>
     <mfrac>
      <msub>
       <mi>σ</mi>
       <mi>N</mi>
      </msub>
      <msqrt>
       <mi>N</mi>
      </msqrt>
     </mfrac>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <approx></approx>
     <apply>
      <times></times>
      <ci>δ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>N</ci>
      </apply>
     </apply>
     <apply>
      <root></root>
      <apply>
       <times></times>
       <ci>Var</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>V</ci>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <ci>N</ci>
       </apply>
       <apply>
        <root></root>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta Q_{N}\approx\sqrt{\mathrm{Var}(Q_{N})}=V\frac{\sigma_{N}}{\sqrt{N}},
  </annotation>
 </semantics>
</math>

</p>

<p>which decreases as 

<math display="inline" id="Monte_Carlo_integration:9">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <msqrt>
    <mi>N</mi>
   </msqrt>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <root></root>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{1}{\sqrt{N}}
  </annotation>
 </semantics>
</math>

. This result does not depend on the number of dimensions of the integral, which is the promised advantage of Monte Carlo integration against most deterministic methods that depend exponentially on the dimension.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> It is important to notice that, like in deterministic methods, the estimate of the error is not a strict error bound; random sampling may not uncover all the important features of the integrand that can result in an underestimate of the error.</p>

<p>While the naive Monte Carlo works for simple examples, this is not the case in most problems. A large part of the Monte Carlo literature is dedicated in developing strategies to improve the error estimates. In particular, stratified sampling - dividing the region in sub-domains -, and importance sampling - sampling from non-uniform distributions - are two of such techniques.</p>
<h3 id="example">Example</h3>
<figure><b>(Figure)</b>
<figcaption> as a function of the number of samples, showing the scaling 

<math display="inline" id="Monte_Carlo_integration:10">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <msqrt>
    <mi>N</mi>
   </msqrt>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <root></root>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{1}{\sqrt{N}}
  </annotation>
 </semantics>
</math>

</figcaption>
</figure>

<p>A paradigmatic example of a Monte Carlo integration is the estimation of π. Consider the function</p>

<p>

<math display="block" id="Monte_Carlo_integration:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo>(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <msup>
           <mi>x</mi>
           <mn>2</mn>
          </msup>
         </mrow>
         <mo>+</mo>
         <msup>
          <mi>y</mi>
          <mn>2</mn>
         </msup>
        </mrow>
        <mo>≤</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mtext>else</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <leq></leq>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <mtext>if</mtext>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">0</cn>
     <mtext>else</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H\left(x,y\right)=\begin{cases}1&\text{if }x^{2}+y^{2}\leq 1\\
0&\text{else}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>and the set Ω = [−1,1] × [−1,1] with <em>V</em> = 4. Notice that</p>

<p>

<math display="block" id="Monte_Carlo_integration:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>I</mi>
     <mi>π</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Ω</mi>
     </msub>
     <mrow>
      <mi>H</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
      <mi>d</mi>
      <mi>y</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>π</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>π</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Ω</ci>
      </apply>
      <apply>
       <times></times>
       <ci>H</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
       <ci>d</ci>
       <ci>x</ci>
       <ci>d</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>π</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{\pi}=\int_{\Omega}H(x,y)dxdy=\pi.
  </annotation>
 </semantics>
</math>

</p>

<p>Thus, a crude way of calculating the value of π with Monte Carlo integration is to pick <em>N</em> random numbers on Ω and compute</p>

<p>

<math display="block" id="Monte_Carlo_integration:13">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mi>N</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mn>4</mn>
    <mfrac>
     <mn>1</mn>
     <mi>N</mi>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <mi>H</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">4</cn>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <ci>H</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{N}=4\frac{1}{N}\sum_{i=1}^{N}H(x_{i},y_{i})
  </annotation>
 </semantics>
</math>

</p>

<p>In the figure on the right, the relative error 

<math display="inline" id="Monte_Carlo_integration:14">
 <semantics>
  <mfrac>
   <mrow>
    <msub>
     <mi>Q</mi>
     <mi>N</mi>
    </msub>
    <mo>-</mo>
    <mi>π</mi>
   </mrow>
   <mi>π</mi>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>N</ci>
     </apply>
     <ci>π</ci>
    </apply>
    <ci>π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{Q_{N}-\pi}{\pi}
  </annotation>
 </semantics>
</math>

 is measured as a function of <em>N</em>, confirming the 

<math display="inline" id="Monte_Carlo_integration:15">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <msqrt>
    <mi>N</mi>
   </msqrt>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <root></root>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{1}{\sqrt{N}}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="wolfram-mathematica-example">Wolfram Mathematica Example</h3>

<p>The code below describes a process of integrating the function</p>

<p>

<math display="block" id="Monte_Carlo_integration:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mi>sinh</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>log</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <cn type="integer">1</cn>
      <plus></plus>
      <sinh></sinh>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <cn type="integer">2</cn>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <log></log>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <cn type="integer">2</cn>
      </apply>
     </cerror>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=\frac{1}{1+\sinh(2x)\log(x)^{2}}
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Monte_Carlo_integration:17">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mi>a</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>a</ci>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{a}(f)
  </annotation>
 </semantics>
</math>

 from the above illustration was integrated within a unit square using the suggested algorithm. The sampled points were recorded and plotted. Clearly stratified sampling algorithm concentrates the points in the regions where the variation of the function is largest.]]</p>

<p><strong>Recursive stratified sampling</strong> is a generalization of one-dimensional <a href="adaptive_quadrature" title="wikilink">adaptive quadratures</a> to multi-dimensional integrals. On each recursion step the integral and the error are estimated using a plain Monte Carlo algorithm. If the error estimate is larger than the required accuracy the integration volume is divided into sub-volumes and the procedure is recursively applied to sub-volumes.</p>

<p>The ordinary 'dividing by two' strategy does not work for multi-dimensions as the number of sub-volumes grows far too quickly to keep track. Instead one estimates along which dimension a subdivision should bring the most dividends and only subdivides the volume along this dimension.</p>

<p>The stratified sampling algorithm concentrates the sampling points in the regions where the variance of the function is largest thus reducing the grand variance and making the sampling more effective, as shown on the illustration.</p>

<p>The popular MISER routine implements a similar algorithm.</p>
<h3 id="miser-monte-carlo">MISER Monte Carlo</h3>

<p>The MISER algorithm is based on recursive <a href="stratified_sampling" title="wikilink">stratified sampling</a>. This technique aims to reduce the overall integration error by concentrating integration points in the regions of highest variance.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>The idea of stratified sampling begins with the observation that for two <a href="Disjoint_sets" title="wikilink">disjoint</a> regions <em>a</em> and <em>b</em> with Monte Carlo estimates of the integral 

<math display="inline" id="Monte_Carlo_integration:18">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mi>b</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>b</ci>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{b}(f)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Monte_Carlo_integration:19">
 <semantics>
  <mrow>
   <msubsup>
    <mi>σ</mi>
    <mi>a</mi>
    <mn>2</mn>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>a</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{a}^{2}(f)
  </annotation>
 </semantics>
</math>

 and variances 

<math display="inline" id="Monte_Carlo_integration:20">
 <semantics>
  <mrow>
   <msubsup>
    <mi>σ</mi>
    <mi>b</mi>
    <mn>2</mn>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>b</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{b}^{2}(f)
  </annotation>
 </semantics>
</math>

 and 

<math display="block" id="Monte_Carlo_integration:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mstyle displaystyle="false">
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
    </mstyle>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>E</mi>
        <mi>a</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>f</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>E</mi>
        <mi>b</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>f</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <ci>a</ci>
       </apply>
       <ci>f</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <ci>b</ci>
       </apply>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(f)=\tfrac{1}{2}\left(E_{a}(f)+E_{b}(f)\right)
  </annotation>
 </semantics>
</math>

, the variance Var(<em>f</em>) of the combined estimate</p>

<p>

<math display="block" id="Monte_Carlo_integration:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>Var</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <msubsup>
       <mi>σ</mi>
       <mi>a</mi>
       <mn>2</mn>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mn>4</mn>
      <msub>
       <mi>N</mi>
       <mi>a</mi>
      </msub>
     </mrow>
    </mfrac>
    <mo>+</mo>
    <mfrac>
     <mrow>
      <msubsup>
       <mi>σ</mi>
       <mi>b</mi>
       <mn>2</mn>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mn>4</mn>
      <msub>
       <mi>N</mi>
       <mi>b</mi>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Var</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <ci>a</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>f</ci>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">4</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>N</ci>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <ci>b</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>f</ci>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">4</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>N</ci>
        <ci>b</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Var}(f)=\frac{\sigma_{a}^{2}(f)}{4N_{a}}+\frac{\sigma_{b}^{2}(f)}{4N_{%
b}}
  </annotation>
 </semantics>
</math>

 is given by,</p>

<p>

<math display="block" id="Monte_Carlo_integration:23">
 <semantics>
  <mrow>
   <mfrac>
    <msub>
     <mi>N</mi>
     <mi>a</mi>
    </msub>
    <mrow>
     <msub>
      <mi>N</mi>
      <mi>a</mi>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>N</mi>
      <mi>b</mi>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mi>σ</mi>
     <mi>a</mi>
    </msub>
    <mrow>
     <msub>
      <mi>σ</mi>
      <mi>a</mi>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>σ</mi>
      <mi>b</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{N_{a}}{N_{a}+N_{b}}=\frac{\sigma_{a}}{\sigma_{a}+\sigma_{b}}
  </annotation>
 </semantics>
</math>

</p>

<p>It can be shown that this variance is minimized by distributing the points such that,</p>

<p>

<math display="block" id="Monte_Carlo_integration:24">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>E</mi>
     <mi>g</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo>;</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo>(</mo>
     <mstyle displaystyle="false">
      <mfrac>
       <mi>f</mi>
       <mi>g</mi>
      </mfrac>
     </mstyle>
     <mo>;</mo>
     <mi>N</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>g</ci>
     </apply>
     <list>
      <ci>f</ci>
      <ci>N</ci>
     </list>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <list>
      <apply>
       <divide></divide>
       <ci>f</ci>
       <ci>g</ci>
      </apply>
      <ci>N</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{g}(f;N)=E\left(\tfrac{f}{g};N\right)
  </annotation>
 </semantics>
</math>

</p>

<p>Hence the smallest error estimate is obtained by allocating sample points in proportion to the standard deviation of the function in each sub-region.</p>

<p>The MISER algorithm proceeds by bisecting the integration region along one coordinate axis to give two sub-regions at each step. The direction is chosen by examining all <em>d</em> possible bisections and selecting the one which will minimize the combined variance of the two sub-regions. The variance in the sub-regions is estimated by sampling with a fraction of the total number of points available to the current step. The same procedure is then repeated recursively for each of the two half-spaces from the best bisection. The remaining sample points are allocated to the sub-regions using the formula for <em>N<sub>a</sub></em> and <em>N<sub>b</sub></em>. This recursive allocation of integration points continues down to a user-specified depth where each sub-region is integrated using a plain Monte Carlo estimate. These individual values and their error estimates are then combined upwards to give an overall result and an estimate of its error.</p>
<h2 id="importance-sampling">Importance sampling</h2>
<h3 id="vegas-monte-carlo">VEGAS Monte Carlo</h3>

<p>The VEGAS algorithm takes advantage of the information stored during the sampling, and uses it and importance sampling to efficiently estimate the integral <em>I</em>. It samples points from the probability distribution described by the function |<em>f</em>| so that the points are concentrated in the regions that make the largest contribution to the integral.</p>

<p>In general, if the Monte Carlo integral of <em>f</em> is sampled with points distributed according to a probability distribution described by the function <em>g</em>, we obtain an estimate:</p>

<p>

<math display="block" id="Monte_Carlo_integration:25">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Var</mi>
     <mi>g</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo>;</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>Var</mi>
    <mrow>
     <mo>(</mo>
     <mstyle displaystyle="false">
      <mfrac>
       <mi>f</mi>
       <mi>g</mi>
      </mfrac>
     </mstyle>
     <mo>;</mo>
     <mi>N</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Var</ci>
      <ci>g</ci>
     </apply>
     <list>
      <ci>f</ci>
      <ci>N</ci>
     </list>
    </apply>
    <apply>
     <times></times>
     <ci>Var</ci>
     <list>
      <apply>
       <divide></divide>
       <ci>f</ci>
       <ci>g</ci>
      </apply>
      <ci>N</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Var}_{g}(f;N)=\mathrm{Var}\left(\tfrac{f}{g};N\right)
  </annotation>
 </semantics>
</math>

</p>

<p>with a corresponding variance,</p>

<p>

<math display="block" id="Monte_Carlo_integration:26">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>=</mo>
   <mstyle displaystyle="false">
    <mfrac>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>f</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mrow>
      <mi>I</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>f</mi>
        <mo stretchy="false">|</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mstyle>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>g</ci>
    <apply>
     <divide></divide>
     <apply>
      <abs></abs>
      <ci>f</ci>
     </apply>
     <apply>
      <times></times>
      <ci>I</ci>
      <apply>
       <abs></abs>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g=\tfrac{|f|}{I(|f|)}
  </annotation>
 </semantics>
</math>

</p>

<p>If the probability distribution is chosen as</p>

<p>

<math display="inline" id="Monte_Carlo_integration:27">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mi>g</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo>;</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>g</ci>
    </apply>
    <list>
     <ci>f</ci>
     <ci>N</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{g}(f;N)
  </annotation>
 </semantics>
</math>

</p>

<p>then it can be shown that the variance 

<math display="block" id="Monte_Carlo_integration:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>g</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>g</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">…</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x_{1},x_{2},\ldots)=g_{1}(x_{1})g_{2}(x_{2})\ldots
  </annotation>
 </semantics>
</math>

 vanishes, and the error in the estimate will be zero. In practice it is not possible to sample from the exact distribution <em>g</em> for an arbitrary function, so importance sampling algorithms aim to produce efficient approximations to the desired distribution.</p>

<p>The VEGAS algorithm approximates the exact distribution by making a number of passes over the integration region which creates the histogram of the function <em>f</em>. Each histogram is used to define a sampling distribution for the next pass. Asymptotically this procedure converges to the desired distribution.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> In order to avoid the number of histogram bins growing like <em>K<sup>d</sup></em>, the probability distribution is approximated by a separable function:</p>

<p>

<math display="inline" id="Monte_Carlo_integration:29">
 <semantics>
  <mover accent="true">
   <mi>𝐱</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{\mathbf{x}}
  </annotation>
 </semantics>
</math>

</p>

<p>so that the number of bins required is only <em>Kd</em>. This is equivalent to locating the peaks of the function from the projections of the integrand onto the coordinate axes. The efficiency of VEGAS depends on the validity of this assumption. It is most efficient when the peaks of the integrand are well-localized. If an integrand can be rewritten in a form which is approximately separable this will increase the efficiency of integration with VEGAS.</p>

<p>VEGAS incorporates a number of additional features, and combines both stratified sampling and importance sampling.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The integration region is divided into a number of "boxes", with each box getting a fixed number of points (the goal is 2). Each box can then have a fractional number of bins, but if bins/box is less than two, Vegas switches to a kind variance reduction (rather than importance sampling).</p>

<p>This routines uses the VEGAS Monte Carlo algorithm to integrate the function <em>f</em> over the <em>dim</em>-dimensional hypercubic region defined by the lower and upper limits in the arrays <em>xl</em> and <em>xu</em>, each of size <em>dim</em>. The integration uses a fixed number of function calls. The result and its error estimate are based on a weighted average of independent samples.</p>

<p>The VEGAS algorithm computes a number of independent estimates of the integral internally, according to the iterations parameter described below, and returns their weighted average. Random sampling of the integrand can occasionally produce an estimate where the error is zero, particularly if the function is constant in some regions. An estimate with zero error causes the weighted average to break down and must be handled separately.</p>
<h3 id="importance-sampling-algorithm">Importance sampling algorithm</h3>

<p>Importance sampling provides a very important tool to perform Monte-Carlo integration.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> The main result of importance sampling to this method is that the uniform sampling of 

<math display="inline" id="Monte_Carlo_integration:30">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>𝐱</mi>
     <mo>¯</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>𝐱</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\overline{\mathbf{x}})
  </annotation>
 </semantics>
</math>

 is a particular case of a more generic choice, on which the samples are drawn from any distribution 

<math display="inline" id="Monte_Carlo_integration:31">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>𝐱</mi>
     <mo>¯</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>𝐱</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\overline{\mathbf{x}})
  </annotation>
 </semantics>
</math>

. The idea is that 

<math display="block" id="Monte_Carlo_integration:32">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>𝐱</mi>
     <mo>¯</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:</mo>
   <msub>
    <mover accent="true">
     <mi>𝐱</mi>
     <mo>¯</mo>
    </mover>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>,</mo>
   <msub>
    <mover accent="true">
     <mi>𝐱</mi>
     <mo>¯</mo>
    </mover>
    <mi>N</mi>
   </msub>
   <mo>∈</mo>
   <mi>V</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>𝐱</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>italic-</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <ci>𝐱</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-,</ci>
    <ci>normal-⋯</ci>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <ci>𝐱</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <in></in>
    <csymbol cd="unknown">V</csymbol>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\overline{\mathbf{x}}):\qquad\overline{\mathbf{x}}_{1},\cdots,\overline{%
\mathbf{x}}_{N}\in V,
  </annotation>
 </semantics>
</math>

 can be chosen to decrease the variance of the measurement <em>Q<sub>N</sub></em>.</p>

<p>Consider the following example where one would like to numerically integrate a gaussian function, centered at 0, with σ = 1, from −1000 to 1000. Naturally, if the samples are drawn uniformly on the interval [−1000, 1000], only a very small part of them would be significant to the integral. This can be improved by choosing a different distribution from where the samples are chosen, for instance by sampling according to a gaussian distribution centered at 0, with σ = 1. Of course the "right" choice strongly depends on the integrand.</p>

<p>Formally, given a set of samples chosen from a distribution</p>

<p>

<math display="block" id="Monte_Carlo_integration:33">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mi>N</mi>
   </msub>
   <mo>≡</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>N</mi>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mfrac>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mover accent="true">
          <mi>𝐱</mi>
          <mo>¯</mo>
         </mover>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mover accent="true">
          <mi>𝐱</mi>
          <mo>¯</mo>
         </mover>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-¯</ci>
          <ci>𝐱</ci>
         </apply>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>p</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-¯</ci>
          <ci>𝐱</ci>
         </apply>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{N}\equiv\frac{1}{N}\sum_{i=1}^{N}\frac{f(\overline{\mathbf{x}}_{i})}{p(%
\overline{\mathbf{x}}_{i})}
  </annotation>
 </semantics>
</math>

 the estimator for <em>I</em> is given by<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>

<math display="inline" id="Monte_Carlo_integration:34">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>𝐱</mi>
     <mo>¯</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>𝐱</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\overline{\mathbf{x}})
  </annotation>
 </semantics>
</math>

</p>

<p>Intuitively, this says that if we pick a particular sample twice as much as other samples, we weight it half as much as the other samples. This estimator is naturally valid for uniform sampling, the case where 

<math display="inline" id="Monte_Carlo_integration:35">
 <semantics>
  <mover accent="true">
   <mi>𝐱</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{\mathbf{x}}
  </annotation>
 </semantics>
</math>

 is constant.</p>

<p>The <a href="Metropolis-Hastings_algorithm" title="wikilink">Metropolis-Hastings algorithm</a> is one of the most used algorithms to generate 

<math display="inline" id="Monte_Carlo_integration:36">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>𝐱</mi>
     <mo>¯</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>𝐱</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\overline{\mathbf{x}})
  </annotation>
 </semantics>
</math>

 from <span class="LaTeX">$p(\overline{\mathbf{x}})$</span>,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> thus providing an efficient way of computing integrals.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Auxiliary_field_Monte_Carlo" title="wikilink">Auxiliary field Monte Carlo</a></li>
<li><a href="Monte_Carlo_method_in_statistical_physics" title="wikilink">Monte Carlo method in statistical physics</a></li>
<li><a href="Monte_Carlo_method" title="wikilink">Monte Carlo method</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li><a href="Russel_E._Caflisch" title="wikilink">R. E. Caflisch</a>, <em>Monte Carlo and quasi-Monte Carlo methods</em>, Acta Numerica vol. 7, Cambridge University Press, 1998, pp. 1–49.</li>
<li>S. Weinzierl, <em><a href="http://arxiv.org/abs/hep-ph/0006269/">Introduction to Monte Carlo methods</a></em>,</li>
<li>W.H. Press, G.R. Farrar, Recursive Stratified Sampling for Multidimensional Monte Carlo Integration, Computers in Physics, v4 (1990).</li>
<li>G.P. Lepage, A New Algorithm for Adaptive Multidimensional Integration, Journal of Computational Physics 27, 192-203, (1978)</li>
<li>G.P. Lepage, VEGAS: An Adaptive Multi-dimensional Integration Program, Cornell preprint CLNS 80-447, March 1980</li>
<li>J. M. Hammersley, D.C. Handscomb (1964) Monte Carlo Methods. Methuen. ISBN 0-416-52340-4</li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cafemath.fr/mathblog/article.php?page=MonteCarlo.php">Café math : Monte Carlo Integration</a> : A blog article describing Monte Carlo integration (principle, hypothesis, confidence interval)</li>
<li><a href="http://math.fullerton.edu/mathews/n2003/MonteCarloMod.html">Module for Monte Carlo Integration</a></li>
<li><a href="http://math.fullerton.edu/mathews/n2003/montecarlo/MonteCarloBib/Links/MonteCarloBib_lnk_1.html">Internet Resources for Monte Carlo Integration</a></li>
</ul>

<p>"</p>

<p><a href="Category:Monte_Carlo_methods" title="wikilink">Category:Monte Carlo methods</a> <a href="Category:Articles_with_example_code" title="wikilink">Category:Articles with example code</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Press et al, 2007, Chap. 4.<a href="#fnref1">↩</a></li>
<li id="fn2">Press et al, 2007, Chap. 7.<a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4">Newman, 1999, Chap. 1.<a href="#fnref4">↩</a></li>
<li id="fn5">Press et al, 2007<a href="#fnref5">↩</a></li>
<li id="fn6">Press, 1990, pp 190-195.<a href="#fnref6">↩</a></li>
<li id="fn7">Lepage, 1978<a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9">Newman, 1999, Chap. 2.<a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"></li>
</ol>
</section>
</body>
</html>
