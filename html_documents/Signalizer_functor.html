<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="192">Signalizer functor</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Signalizer functor</h1>
<hr>In mathematics, a '''signalizer functor''' gives the intersections of a potential subgroup of a finite group  with the [[centralizer]]s of nontrivial elements of an abelian group. The '''signalizer functor theorem''' gives conditions unde
<p>r which a signalizer functor comes from a subgroup. The idea is to try to construct a 

<math display="inline" id="Signalizer_functor:0">
 <semantics>
  <msup>
   <mi>p</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>p</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{\prime}
  </annotation>
 </semantics>
</math>

-subgroup of a finite group 

<math display="inline" id="Signalizer_functor:1">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, which has a good chance of being normal in 

<math display="inline" id="Signalizer_functor:2">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, by taking as generators certain 

<math display="inline" id="Signalizer_functor:3">
 <semantics>
  <msup>
   <mi>p</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>p</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{\prime}
  </annotation>
 </semantics>
</math>

-subgroups of the centralizers of nonidentity elements in one or several given noncyclic elementary abelian 

<math display="inline" id="Signalizer_functor:4">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

-subgroups of 

<math display="inline" id="Signalizer_functor:5">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G.
  </annotation>
 </semantics>
</math>

 The technique has origins in the <a href="Feit–Thompson_theorem" title="wikilink">Feit–Thompson theorem</a>, and was subsequently developed by many people including  who defined signalizer functors,  who proved the Solvable Signalizer Functor Theorem for solvable groups, and  who proved it for all groups. This theorem is needed to prove the so-called "dichotomy" stating that a given nonabelian finite <a href="simple_group" title="wikilink">simple group</a> either has local characteristic two, or is of component type. It thus plays a major role in the <a href="classification_of_finite_simple_groups" title="wikilink">classification of finite simple groups</a>.</p>
<h2 id="definition">Definition</h2>

<p>Let <em>A</em> be a noncyclic elementary abelian <a href="P-group" title="wikilink"><em>p</em>-subgroup</a> of the finite group <em>G.</em> An <strong>A-signalizer functor on <em>G</em></strong> or simply a <strong>signalizer functor</strong> when <em>A</em> and <em>G</em> are clear is a mapping <em>θ</em> from the set of nonidentity elements of <em>A</em> to the set of <em>A</em>-invariant <em>p′</em>-subgroups of <em>G</em> satisfying the following properties:</p>
<ul>
<li>For every nonidentity 

<math display="inline" id="Signalizer_functor:6">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∈</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in A
  </annotation>
 </semantics>
</math>

, the group 

<math display="inline" id="Signalizer_functor:7">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>θ</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta(a)
  </annotation>
 </semantics>
</math>

 is contained in 

<math display="inline" id="Signalizer_functor:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>C</mi>
     <mi>G</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>G</ci>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{G}(a).
  </annotation>
 </semantics>
</math>

</li>
<li>For every nonidentity 

<math display="inline" id="Signalizer_functor:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
   </mrow>
   <mo>∈</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>a</ci>
     <ci>b</ci>
    </list>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a,b\in A
  </annotation>
 </semantics>
</math>

, we have 

<math display="inline" id="Signalizer_functor:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>θ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∩</mo>
     <mrow>
      <msub>
       <mi>C</mi>
       <mi>G</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>⊆</mo>
    <mrow>
     <mi>θ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <intersect></intersect>
     <apply>
      <times></times>
      <ci>θ</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>G</ci>
      </apply>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>θ</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta(a)\cap C_{G}(b)\subseteq\theta(b).
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>The second condition above is called the <strong>balance condition.</strong> If the subgroups 

<math display="inline" id="Signalizer_functor:11">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>θ</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta(a)
  </annotation>
 </semantics>
</math>

 are all <a href="solvable_group" title="wikilink">solvable</a>, then the signalizer functor 

<math display="inline" id="Signalizer_functor:12">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 itself is said to be solvable.</p>
<h2 id="solvable-signalizer-functor-theorem">Solvable signalizer functor theorem</h2>

<p>Given 

<math display="inline" id="Signalizer_functor:13">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta,
  </annotation>
 </semantics>
</math>

 certain additional, relatively mild, assumptions allow one to prove that the subgroup 

<math display="inline" id="Signalizer_functor:14">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>θ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mrow>
      <mi>a</mi>
      <mo>∈</mo>
      <mi>A</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>a</mi>
      <mo>≠</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>W</ci>
    <apply>
     <csymbol cd="latexml">inner-product</csymbol>
     <apply>
      <times></times>
      <ci>θ</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <in></in>
       <ci>a</ci>
       <ci>A</ci>
      </apply>
      <apply>
       <neq></neq>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W=\langle\theta(a)\mid a\in A,a\neq 1\rangle
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Signalizer_functor:15">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 generated by the subgroups 

<math display="inline" id="Signalizer_functor:16">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>θ</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta(a)
  </annotation>
 </semantics>
</math>

 is in fact a 

<math display="inline" id="Signalizer_functor:17">
 <semantics>
  <msup>
   <mi>p</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>p</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{\prime}
  </annotation>
 </semantics>
</math>

-subgroup. The Solvable Signalizer Functor Theorem proved by Glauberman and mentioned above says that this will be the case if 

<math display="inline" id="Signalizer_functor:18">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 is solvable and 

<math display="inline" id="Signalizer_functor:19">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 has at least three generators. The theorem also states that under these assumptions, 

<math display="inline" id="Signalizer_functor:20">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 itself will be solvable.</p>

<p>Several earlier versions of the theorem were proven:  proved this under the stronger assumption that 

<math display="inline" id="Signalizer_functor:21">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 had rank at least 5.  proved this under the assumption that 

<math display="inline" id="Signalizer_functor:22">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 had rank at least 4 or was a 2-group of rank at least 3.  gave a simple proof for 2-groups using the <a href="ZJ_theorem" title="wikilink">ZJ theorem</a>, and a proof in a similar spirit has been given for all primes by .  gave the definitive result for solvable signalizer functors. Using the classification of finite simple groups,  showed that 

<math display="inline" id="Signalizer_functor:23">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 is a 

<math display="inline" id="Signalizer_functor:24">
 <semantics>
  <msup>
   <mi>p</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>p</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{\prime}
  </annotation>
 </semantics>
</math>

-group without the assumption that 

<math display="inline" id="Signalizer_functor:25">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 is solvable.</p>
<h3 id="completeness">Completeness</h3>

<p>The terminology of completeness is often used in discussions of signalizer functors. Let 

<math display="inline" id="Signalizer_functor:26">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 be a signalizer functor as above, and consider the set И of all 

<math display="inline" id="Signalizer_functor:27">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

-invariant 

<math display="inline" id="Signalizer_functor:28">
 <semantics>
  <msup>
   <mi>p</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>p</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{\prime}
  </annotation>
 </semantics>
</math>

-subgroups 

<math display="inline" id="Signalizer_functor:29">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Signalizer_functor:30">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 satisfying the following condition:</p>
<ul>
<li>

<math display="inline" id="Signalizer_functor:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mo>∩</mo>
    <mrow>
     <msub>
      <mi>C</mi>
      <mi>G</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>⊆</mo>
   <mrow>
    <mi>θ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <intersect></intersect>
     <ci>H</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>G</ci>
      </apply>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>θ</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H\cap C_{G}(a)\subseteq\theta(a)
  </annotation>
 </semantics>
</math>

 for all nonidentity 

<math display="inline" id="Signalizer_functor:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>∈</mo>
    <mi>A</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in A.
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>For example, the subgroups 

<math display="inline" id="Signalizer_functor:33">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>θ</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta(a)
  </annotation>
 </semantics>
</math>

 belong to И by the balance condition. The signalizer functor 

<math display="inline" id="Signalizer_functor:34">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 is said to be <strong>complete</strong> if И has a unique maximal element when ordered by containment. In this case, the unique maximal element can be shown to coincide with 

<math display="inline" id="Signalizer_functor:35">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 above, and 

<math display="inline" id="Signalizer_functor:36">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 is called the <strong>completion</strong> of 

<math display="inline" id="Signalizer_functor:37">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Signalizer_functor:38">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 is complete, and 

<math display="inline" id="Signalizer_functor:39">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 turns out to be solvable, then 

<math display="inline" id="Signalizer_functor:40">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 is said to be <strong>solvably complete.</strong></p>

<p>Thus, the Solvable Signalizer Functor Theorem can be rephrased by saying that if 

<math display="inline" id="Signalizer_functor:41">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 has at least three generators, then every solvable 

<math display="inline" id="Signalizer_functor:42">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

-signalizer functor on 

<math display="inline" id="Signalizer_functor:43">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is solvably complete.</p>
<h2 id="examples-of-signalizer-functors">Examples of signalizer functors</h2>

<p>The easiest way to obtain a signalizer functor is to start with an 

<math display="inline" id="Signalizer_functor:44">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

-invariant 

<math display="inline" id="Signalizer_functor:45">
 <semantics>
  <msup>
   <mi>p</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>p</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{\prime}
  </annotation>
 </semantics>
</math>

-subgroup 

<math display="inline" id="Signalizer_functor:46">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Signalizer_functor:47">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G,
  </annotation>
 </semantics>
</math>

 and define 

<math display="inline" id="Signalizer_functor:48">
 <semantics>
  <mrow>
   <mrow>
    <mi>θ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>M</mi>
    <mo>∩</mo>
    <mrow>
     <msub>
      <mi>C</mi>
      <mi>G</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>θ</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <intersect></intersect>
     <ci>M</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>G</ci>
      </apply>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta(a)=M\cap C_{G}(a)
  </annotation>
 </semantics>
</math>

 for all nonidentity 

<math display="inline" id="Signalizer_functor:49">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>∈</mo>
    <mi>A</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in A.
  </annotation>
 </semantics>
</math>

 In practice, however, one begins with 

<math display="inline" id="Signalizer_functor:50">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 and uses it to construct the 

<math display="inline" id="Signalizer_functor:51">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

-invariant 

<math display="inline" id="Signalizer_functor:52">
 <semantics>
  <msup>
   <mi>p</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>p</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{\prime}
  </annotation>
 </semantics>
</math>

-group.</p>

<p>The simplest signalizer functor used in practice is this: 

<math display="inline" id="Signalizer_functor:53">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>θ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>O</mi>
      <msup>
       <mi>p</mi>
       <mo>′</mo>
      </msup>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>C</mi>
        <mi>G</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>θ</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>O</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>G</ci>
      </apply>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta(a)=O_{p^{\prime}}(C_{G}(a)).
  </annotation>
 </semantics>
</math>

</p>

<p>A few words of caution are needed here. First, note that 

<math display="inline" id="Signalizer_functor:54">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>θ</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta(a)
  </annotation>
 </semantics>
</math>

 as defined above is indeed an 

<math display="inline" id="Signalizer_functor:55">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

-invariant 

<math display="inline" id="Signalizer_functor:56">
 <semantics>
  <msup>
   <mi>p</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>p</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{\prime}
  </annotation>
 </semantics>
</math>

-subgroup of 

<math display="inline" id="Signalizer_functor:57">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 because 

<math display="inline" id="Signalizer_functor:58">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is abelian. However, some additional assumptions are needed to show that this 

<math display="inline" id="Signalizer_functor:59">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 satisfies the balance condition. One sufficient criterion is that for each nonidentity 

<math display="inline" id="Signalizer_functor:60">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>∈</mo>
    <mi>A</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in A,
  </annotation>
 </semantics>
</math>

 the group 

<math display="inline" id="Signalizer_functor:61">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>G</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>G</ci>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{G}(a)
  </annotation>
 </semantics>
</math>

 is solvable (or 

<math display="inline" id="Signalizer_functor:62">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

-solvable or even 

<math display="inline" id="Signalizer_functor:63">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

-constrained). Verifying the balance condition for this 

<math display="inline" id="Signalizer_functor:64">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 under this assumption requires a famous lemma, known as <a href="John_G._Thompson" title="wikilink">Thompson's</a> 

<math display="inline" id="Signalizer_functor:65">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>×</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\times Q
  </annotation>
 </semantics>
</math>

-lemma. (Note, this lemma is also called Thompson's 

<math display="inline" id="Signalizer_functor:66">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>×</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\times B
  </annotation>
 </semantics>
</math>

-lemma, but the 

<math display="inline" id="Signalizer_functor:67">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 in this use must not be confused with the 

<math display="inline" id="Signalizer_functor:68">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 appearing in the definition of a signalizer functor!)</p>
<h2 id="coprime-action">Coprime action</h2>

<p>To obtain a better understanding of signalizer functors, it is essential to know the following general fact about finite groups:</p>
<ul>
<li>Let 

<math display="inline" id="Signalizer_functor:69">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 be an abelian noncyclic group acting on the finite group 

<math display="inline" id="Signalizer_functor:70">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X.
  </annotation>
 </semantics>
</math>

 Assume that the orders of 

<math display="inline" id="Signalizer_functor:71">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Signalizer_functor:72">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 are relatively prime. Then</li>
</ul>

<p>

<math display="inline" id="Signalizer_functor:73">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <msub>
      <mi>C</mi>
      <mi>X</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>E</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <msub>
      <mi>E</mi>
      <mn>0</mn>
     </msub>
     <mo>⊆</mo>
     <mrow>
      <mi>E</mi>
      <mo>,</mo>
      <mrow>
       <mrow>
        <mrow>
         <mtext>and</mtext>
         <mi>E</mi>
        </mrow>
        <mo>/</mo>
        <msub>
         <mi>E</mi>
         <mn>0</mn>
        </msub>
       </mrow>
       <mtext>cyclic</mtext>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <apply>
     <csymbol cd="latexml">inner-product</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>X</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <subset></subset>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <cn type="integer">0</cn>
      </apply>
      <list>
       <ci>E</ci>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <mtext>and</mtext>
          <ci>E</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>E</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <mtext>cyclic</mtext>
       </apply>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=\langle C_{X}(E_{0})\mid E_{0}\subseteq E,\text{ and }E/E_{0}\text{ cyclic }\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>To prove this fact, one uses the <a href="Schur–Zassenhaus_theorem" title="wikilink">Schur–Zassenhaus theorem</a> to show that for each prime 

<math display="inline" id="Signalizer_functor:74">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 dividing the order of 

<math display="inline" id="Signalizer_functor:75">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X,
  </annotation>
 </semantics>
</math>

 the group 

<math display="inline" id="Signalizer_functor:76">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 has an 

<math display="inline" id="Signalizer_functor:77">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

-invariant Sylow 

<math display="inline" id="Signalizer_functor:78">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

-subgroup. This reduces to the case where 

<math display="inline" id="Signalizer_functor:79">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is a 

<math display="inline" id="Signalizer_functor:80">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

-group. Then an argument by induction on the order of 

<math display="inline" id="Signalizer_functor:81">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 reduces the statement further to the case where 

<math display="inline" id="Signalizer_functor:82">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is elementary abelian with 

<math display="inline" id="Signalizer_functor:83">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 acting irreducibly. This forces the group 

<math display="inline" id="Signalizer_functor:84">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mo>/</mo>
    <msub>
     <mi>C</mi>
     <mi>E</mi>
    </msub>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>E</ci>
     </apply>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E/C_{E}(X)
  </annotation>
 </semantics>
</math>

 to be cyclic, and the result follows. See either of the books  or  for details.</p>

<p>This is used in both the proof and applications of the Solvable Signalizer Functor Theorem. To begin, notice that it quickly implies the claim that if 

<math display="inline" id="Signalizer_functor:85">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 is complete, then its completion is the group 

<math display="inline" id="Signalizer_functor:86">
 <semantics>
  <mi>W</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W
  </annotation>
 </semantics>
</math>

 defined above.</p>
<h2 id="normal-completion">Normal completion</h2>

<p>The completion of a signalizer functor has a "good chance" of being normal in 

<math display="inline" id="Signalizer_functor:87">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G,
  </annotation>
 </semantics>
</math>

 according to the top of the article. Here, the coprime action fact will be used to motivate this claim. Let 

<math display="inline" id="Signalizer_functor:88">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 be a complete 

<math display="inline" id="Signalizer_functor:89">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

-signalizer functor on 

<math display="inline" id="Signalizer_functor:90">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

</p>

<p>Let 

<math display="inline" id="Signalizer_functor:91">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 be a noncyclic subgroup of 

<math display="inline" id="Signalizer_functor:92">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A.
  </annotation>
 </semantics>
</math>

 Then the coprime action fact together with the balance condition imply that 

<math display="inline" id="Signalizer_functor:93">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>θ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mrow>
      <mi>a</mi>
      <mo>∈</mo>
      <mi>A</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>a</mi>
      <mo>≠</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>θ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mrow>
      <mi>b</mi>
      <mo>∈</mo>
      <mi>B</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>b</mi>
      <mo>≠</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>W</ci>
     <apply>
      <csymbol cd="latexml">inner-product</csymbol>
      <apply>
       <times></times>
       <ci>θ</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <in></in>
        <ci>a</ci>
        <ci>A</ci>
       </apply>
       <apply>
        <neq></neq>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">inner-product</csymbol>
      <apply>
       <times></times>
       <ci>θ</ci>
       <ci>b</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <in></in>
        <ci>b</ci>
        <ci>B</ci>
       </apply>
       <apply>
        <neq></neq>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W=\langle\theta(a)\mid a\in A,a\neq 1\rangle=\langle\theta(b)\mid b\in B,b\neq
1\rangle
  </annotation>
 </semantics>
</math>

.</p>

<p>To see this, observe that because 

<math display="inline" id="Signalizer_functor:94">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>θ</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta(a)
  </annotation>
 </semantics>
</math>

 is <em>B</em>-invariant, we have</p>

<p>

<math display="inline" id="Signalizer_functor:95">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>θ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mrow>
       <mi>θ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>∩</mo>
      <mrow>
       <msub>
        <mi>C</mi>
        <mi>G</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>b</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>∣</mo>
     <mrow>
      <mrow>
       <mi>b</mi>
       <mo>∈</mo>
       <mi>B</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>b</mi>
       <mo>≠</mo>
       <mn>1</mn>
      </mrow>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>⊆</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>θ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∣</mo>
     <mrow>
      <mrow>
       <mi>b</mi>
       <mo>∈</mo>
       <mi>B</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>b</mi>
       <mo>≠</mo>
       <mn>1</mn>
      </mrow>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>θ</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">inner-product</csymbol>
      <apply>
       <intersect></intersect>
       <apply>
        <times></times>
        <ci>θ</ci>
        <ci>a</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <ci>G</ci>
        </apply>
        <ci>b</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <in></in>
        <ci>b</ci>
        <ci>B</ci>
       </apply>
       <apply>
        <neq></neq>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">inner-product</csymbol>
      <apply>
       <times></times>
       <ci>θ</ci>
       <ci>b</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <in></in>
        <ci>b</ci>
        <ci>B</ci>
       </apply>
       <apply>
        <neq></neq>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta(a)=\langle\theta(a)\cap C_{G}(b)\mid b\in B,b\neq 1\rangle\subseteq%
\langle\theta(b)\mid b\in B,b\neq 1\rangle.
  </annotation>
 </semantics>
</math>

</p>

<p>The equality above uses the coprime action fact, and the containment uses the balance condition. Now, it is often the case that 

<math display="inline" id="Signalizer_functor:96">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 satisfies an "equivariance" condition, namely that for each 

<math display="inline" id="Signalizer_functor:97">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∈</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>g</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\in G
  </annotation>
 </semantics>
</math>

 and nonidentity 

<math display="inline" id="Signalizer_functor:98">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∈</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in A
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Signalizer_functor:99">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>θ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>a</mi>
       <mi>g</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>θ</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>g</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>θ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>g</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>θ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>g</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta(a^{g})=\theta(a)^{g}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>The superscript denotes conjugation by 

<math display="inline" id="Signalizer_functor:100">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g.
  </annotation>
 </semantics>
</math>

 For example, the mapping 

<math display="inline" id="Signalizer_functor:101">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>↦</mo>
   <mrow>
    <msub>
     <mi>O</mi>
     <msup>
      <mi>p</mi>
      <mo>′</mo>
     </msup>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>C</mi>
       <mi>G</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>a</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>O</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>G</ci>
      </apply>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\mapsto O_{p^{\prime}}(C_{G}(a))
  </annotation>
 </semantics>
</math>

 (which is often a signalizer functor!) satisfies this condition. If 

<math display="inline" id="Signalizer_functor:102">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 satisfies equivariance, <em>then the normalizer of 

<math display="inline" id="Signalizer_functor:103">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 will normalize 

<math display="inline" id="Signalizer_functor:104">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>W</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W.
  </annotation>
 </semantics>
</math>

</em> It follows that if 

<math display="inline" id="Signalizer_functor:105">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is generated by the normalizers of the noncyclic subgroups of 

<math display="inline" id="Signalizer_functor:106">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A,
  </annotation>
 </semantics>
</math>

 then the completion of 

<math display="inline" id="Signalizer_functor:107">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 (i.e. W) is normal in 

<math display="inline" id="Signalizer_functor:108">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Finite_groups" title="wikilink">Signalizer functor</a></p>
</hr></body>
</html>
