<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="800">Range tree</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Range tree</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, a <strong>range tree</strong> is an <a href="ordered_tree_data_structure" title="wikilink">ordered tree</a> <a href="data_structure" title="wikilink">data structure</a> to hold a list of points. It allows all points within a given range to be <a href="range_query" title="wikilink">reported</a> efficiently, and is typically used in two or higher dimensions. Range trees were introduced by <a href="Jon_Louis_Bentley" title="wikilink">Jon Louis Bentley</a> in 1979.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Similar data structures were discovered independently by Lueker,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Lee and Wong,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and Willard.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The range tree is an alternative to the <a href="k-d_tree" title="wikilink"><em>k</em>-d tree</a>. Compared to <em>k</em>-d trees, range trees offer faster query times of (in <a href="Big_O_notation" title="wikilink">Big O notation</a>) 

<math display="inline" id="Range_tree:0">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>log</mi>
       <mi>d</mi>
      </msup>
      <mi>n</mi>
     </mrow>
     <mo>+</mo>
     <mi>k</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <log></log>
       <ci>d</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log^{d}n+k)
  </annotation>
 </semantics>
</math>

 but worse storage of 

<math display="inline" id="Range_tree:1">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <msup>
       <mi>log</mi>
       <mrow>
        <mi>d</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <log></log>
       <apply>
        <minus></minus>
        <ci>d</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n\log^{d-1}n)
  </annotation>
 </semantics>
</math>

, where <em>n</em> is the number of points stored in the tree, <em>d</em> is the dimension of each point and <em>k</em> is the number of points reported by a given query.</p>

<p><a href="Bernard_Chazelle" title="wikilink">Bernard Chazelle</a> improved this to query time 

<math display="inline" id="Range_tree:2">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>log</mi>
       <mrow>
        <mi>d</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mi>n</mi>
     </mrow>
     <mo>+</mo>
     <mi>k</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <log></log>
       <apply>
        <minus></minus>
        <ci>d</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log^{d-1}n+k)
  </annotation>
 </semantics>
</math>

 and space complexity 

<math display="inline" id="Range_tree:3">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mi>n</mi>
     <msup>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mrow>
         <mi>log</mi>
         <mi>n</mi>
        </mrow>
        <mrow>
         <mi>log</mi>
         <mrow>
          <mi>log</mi>
          <mi>n</mi>
         </mrow>
        </mrow>
       </mfrac>
       <mo>)</mo>
      </mrow>
      <mrow>
       <mi>d</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <divide></divide>
       <apply>
        <log></log>
        <ci>n</ci>
       </apply>
       <apply>
        <log></log>
        <apply>
         <log></log>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>d</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(n\left(\frac{\log n}{\log\log n}\right)^{d-1}\right)
  </annotation>
 </semantics>
</math>


.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="description">Description</h2>

<p><a href="File:1-dimensional-range-tree.svg" title="wikilink">thumb|upright=2.0|alt=An example of a 1-dimensional range tree.|An example of a 1-dimensional range tree.</a></p>

<p>A range tree on a set of 1-dimensional points is a balanced <a href="binary_search_tree" title="wikilink">binary search tree</a> on those points. The points stored in the tree are stored in the leaves of the tree; each internal node stores the largest value contained in its left subtree. A range tree on a set of points in <em>d</em>-dimensions is a <a href="recursive_data_type" title="wikilink">recursively defined</a> multi-level <a href="binary_search_tree" title="wikilink">binary search tree</a>. Each level of the data structure is a binary search tree on one of the <em>d</em>-dimensions. The first level is a binary search tree on the first of the <em>d</em>-coordinates. Each vertex <em>v</em> of this tree contains an associated structure that is a (<em>d</em>−1)-dimensional range tree on the last (<em>d</em>−1)-coordinates of the points stored in the subtree of <em>v</em>.</p>
<h2 id="operations">Operations</h2>
<h3 id="construction">Construction</h3>

<p>A 1-dimensional range tree on a set of <em>n</em> points is a binary search tree, which can be constructed in O(<em>n</em> log <em>n</em>) time. Range trees in higher dimensions are constructed recursively by constructing a balanced binary search tree on the first coordinate of the points, and then, for each vertex <em>v</em> in this tree, constructing a (<em>d</em>−1)-dimensional range tree on the points contained in the subtree of <em>v</em>. Constructing a range tree this way would require O(<em>n</em> log<sup><em>d</em></sup><em>n</em>) time.</p>

<p>This can be improved by noticing that a range tree on a set 2-dimensional points can be constructed in O(<em>n</em> log <em>n</em>) time.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Let <em>S</em> be a set of <em>n</em> 2-dimensional points. If <em>S</em> contains only one point, return a leaf containing that point. Otherwise, construct the associated structure of <em>S</em>, a 1-dimensional range tree on the <em>y</em>-coordinates of the points in <em>S</em>. Let <em>x</em><sub>m</sub> be the median <em>x</em>-coordinate of the points. Let <em>S</em><sub>L</sub> be the set of points with <em>x</em>-coordinate less than or equal to <em>x</em><sub>m</sub> and let <em>S</em><sub>R</sub> be the set of points with <em>x</em>-coordinate greater than <em>x</em><sub>m</sub>. Recursively construct <em>v</em><sub>L</sub>, a 2-dimensional range tree on <em>S</em><sub>L</sub>, and <em>v</em><sub>R</sub>, a 2-dimensional range tree on <em>S</em><sub>R</sub>. Create a vertex <em>v</em> with left-child <em>v</em><sub>L</sub> and right-child <em>v</em><sub>R</sub>. If we sort the points by their <em>y</em>-coordinates at the start of the algorithm, and maintain this ordering when splitting the points by their <em>x</em>-coordinate, we can construct the associated structures of each subtree in linear time. This reduces the time to construct a 2-dimensional range tree to O(<em>n</em> log <em>n</em>), which also reduces the time to construct a <em>d</em>-dimensional range tree to O(<em>n</em> log<sup><em>d</em>−1</sup><em>n</em>).</p>
<h3 id="range-queries">Range queries</h3>

<p>[<a href="File:1-dimensional-range-query.svg|thumb|upright=1.0|alt=A">1-dimensional range query.|A 1-dimensional range query [<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub></a>. Points stored in the subtrees shaded in gray will be reported. find(<em>x</em><sub>1</sub>) and find(<em>x</em><sub>2</sub>) will be reported if they are inside the query interval.]]</p>

<p>Range trees can be used to find the set of points that lie inside a given interval. To report the points that lie in the interval [<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>], we start by searching for <em>x</em><sub>1</sub> and <em>x</em><sub>2</sub>. At some vertex in the tree, the search paths to <em>x</em><sub>1</sub> and <em>x</em><sub>2</sub> will diverge. Let <em>v</em><sub>split</sub> be the last vertex that these two search paths have in common. Continue searching for <em>x</em><sub>1</sub> in the range tree. For every vertex <em>v</em> in the search path from <em>v</em><sub>split</sub> to <em>x</em><sub>1</sub>, if the value stored at <em>v</em> is greater than <em>x</em><sub>1</sub>, report every point in the right-subtree of <em>v</em>. If <em>v</em> is a leaf, report the value stored at <em>v</em> if it is inside the query interval. Similarly, reporting all of the points stored in the left-subtrees of the vertices with values less than <em>x</em><sub>2</sub> along the search path from <em>v</em><sub>split</sub> to <em>x</em><sub>2</sub>, and report the leaf of this path if it lies within the query interval.</p>

<p>Since the range tree is a balanced binary tree, the search paths to <em>x</em><sub>1</sub> and <em>x</em><sub>2</sub> have length O(log <em>n</em>). Reporting all of the points stored in the subtree of a vertex can be done in linear time using any <a href="tree_traversal" title="wikilink">tree traversal</a> algorithm. It follows that the time to perform a range query is O(log <em>n</em> + <em>k</em>), where <em>k</em> is the number of points in the query interval.</p>

<p>Range queries in <em>d</em>-dimensions are similar. Instead of reporting all of the points stored in the subtrees of the search paths, perform a (<em>d</em>−1)-dimensional range query on the associated structure of each subtree. Eventually, a 1-dimensional range query will be performed and the correct points will be reported. Since a <em>d</em>-dimensional query consists of O(log <em>n</em>) (<em>d</em>−1)-dimensional range queries, it follows that the time required to perform a <em>d</em>-dimensional range query is O(log<sup><em>d</em></sup><em>n</em> + <em>k</em>), where <em>k</em> is the number of points in the query interval. This can be reduced to O(log<sup><em>d</em>−1</sup><em>n</em> + <em>k</em>) using the technique of <a href="fractional_cascading" title="wikilink">fractional cascading</a>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="k-d_tree" title="wikilink"><em>k</em>-d tree</a></li>
<li><a href="Segment_tree" title="wikilink">Segment tree</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cgal.org/Manual/latest/doc_html/cgal_manual/SearchStructures/Chapter_main.html">Range and Segment Trees</a> in <a class="uri" href="CGAL" title="wikilink">CGAL</a>, the Computational Geometry Algorithms Library.</li>
<li><a href="http://www.cs.uu.nl/docs/vakken/ga/slides5b.pdf">Lecture 8: Range Trees</a>, Marc van Kreveld.</li>
</ul>

<p>"</p>

<p><a href="Category:Trees_(data_structures)" title="wikilink">Category:Trees (data structures)</a> <a href="Category:Geometric_data_structures" title="wikilink">Category:Geometric data structures</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
</ol>
</section>
</body>
</html>
