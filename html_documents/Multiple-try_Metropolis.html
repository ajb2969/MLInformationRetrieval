<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="465">Multiple-try Metropolis</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Multiple-try Metropolis</h1>
<hr/>

<p>Multiple-try Metropolis is a <a href="sampling_method" title="wikilink">sampling method</a> that is a modified form of the <a class="uri" href="Metropolis-Hastings" title="wikilink">Metropolis-Hastings</a> method, first presented by Liu, Liang, and Wong in 2000. It is designed to help the sampling trajectory converge faster, by increasing both the step size and the acceptance rate.</p>
<h2 id="background">Background</h2>
<h3 id="problems-with-metropolis-hastings">Problems with Metropolis-Hastings</h3>

<p>In <a href="Markov_chain_Monte_Carlo" title="wikilink">Markov chain Monte Carlo</a>, the <a href="Metropolis–Hastings_algorithm" title="wikilink">Metropolis–Hastings algorithm</a> (MH) can be used to sample from a <a href="probability_distribution" title="wikilink">probability distribution</a> which is difficult to sample from directly. However, the MH algorithm requires the user to supply a proposal distribution, which can be relatively arbitrary. In many cases, one uses a Gaussian distribution centered on the current point in the probability space, of the form 

<math display="inline" id="Multiple-try_Metropolis:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mo>′</mo>
     </msup>
     <mo>;</mo>
     <msup>
      <mi>x</mi>
      <mi>t</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mi>t</mi>
     </msup>
     <mo>;</mo>
     <mrow>
      <msup>
       <mi>σ</mi>
       <mn>2</mn>
      </msup>
      <mi>I</mi>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <times></times>
     <ci>𝒩</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>σ</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>I</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x^{\prime};x^{t})=\mathcal{N}(x^{t};\sigma^{2}I)\,
  </annotation>
 </semantics>
</math>

. This proposal distribution is convenient to sample from and may be the best choice if one has little knowledge about the target distribution, 

<math display="inline" id="Multiple-try_Metropolis:1">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(x)\,
  </annotation>
 </semantics>
</math>

. If desired, one can use the more general <a href="multivariate_normal_distribution" title="wikilink">multivariate normal distribution</a>, 

<math display="inline" id="Multiple-try_Metropolis:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mo>′</mo>
     </msup>
     <mo>;</mo>
     <msup>
      <mi>x</mi>
      <mi>t</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mi>t</mi>
     </msup>
     <mo>;</mo>
     <mi>𝚺</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <times></times>
     <ci>𝒩</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
      <ci>𝚺</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x^{\prime};x^{t})=\mathcal{N}(x^{t};\mathbf{\Sigma})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Multiple-try_Metropolis:3">
 <semantics>
  <mi>𝚺</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚺</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\Sigma}
  </annotation>
 </semantics>
</math>

 is the covariance matrix which the user believes is similar to the target distribution.</p>

<p>Although this method must converge to the stationary distribution in the limit of infinite sample size, in practice the progress can be exceedingly slow. If 

<math display="inline" id="Multiple-try_Metropolis:4">
 <semantics>
  <mpadded width="+1.7pt">
   <msup>
    <mi>σ</mi>
    <mn>2</mn>
   </msup>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}\,
  </annotation>
 </semantics>
</math>

 is too large, almost all steps under the MH algorithm will be rejected. On the other hand, if 

<math display="inline" id="Multiple-try_Metropolis:5">
 <semantics>
  <mpadded width="+1.7pt">
   <msup>
    <mi>σ</mi>
    <mn>2</mn>
   </msup>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}\,
  </annotation>
 </semantics>
</math>

 is too small, almost all steps will be accepted, and the Markov chain will be similar to a random walk through the probability space. In the simpler case of 

<math display="inline" id="Multiple-try_Metropolis:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mo>′</mo>
     </msup>
     <mo>;</mo>
     <msup>
      <mi>x</mi>
      <mi>t</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mi>t</mi>
     </msup>
     <mo>;</mo>
     <mi>I</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <times></times>
     <ci>𝒩</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
      <ci>I</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x^{\prime};x^{t})=\mathcal{N}(x^{t};I)\,
  </annotation>
 </semantics>
</math>

, we see that 

<math display="inline" id="Multiple-try_Metropolis:7">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>N</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\,
  </annotation>
 </semantics>
</math>

 steps only takes us a distance of 

<math display="inline" id="Multiple-try_Metropolis:8">
 <semantics>
  <mpadded width="+1.7pt">
   <msqrt>
    <mi>N</mi>
   </msqrt>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{N}\,
  </annotation>
 </semantics>
</math>

. In this event, the Markov Chain will not fully explore the probability space in any reasonable amount of time. Thus the MH algorithm requires reasonable tuning of the scale parameter (

<math display="inline" id="Multiple-try_Metropolis:9">
 <semantics>
  <mpadded width="+1.7pt">
   <msup>
    <mi>σ</mi>
    <mn>2</mn>
   </msup>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}\,
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Multiple-try_Metropolis:10">
 <semantics>
  <mi>𝚺</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚺</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\Sigma}
  </annotation>
 </semantics>
</math>

).</p>
<h3 id="problems-with-high-dimensionality">Problems with high dimensionality</h3>

<p>Even if the scale parameter is well-tuned, as the dimensionality of the problem increases, progress can still remain exceedingly slow. To see this, again consider 

<math display="inline" id="Multiple-try_Metropolis:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mo>′</mo>
     </msup>
     <mo>;</mo>
     <msup>
      <mi>x</mi>
      <mi>t</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mi>t</mi>
     </msup>
     <mo>;</mo>
     <mi>I</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <times></times>
     <ci>𝒩</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
      <ci>I</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x^{\prime};x^{t})=\mathcal{N}(x^{t};I)\,
  </annotation>
 </semantics>
</math>

. In one dimension, this corresponds to a Gaussian distribution with mean 0 and variance 1. For one dimension, this distribution has a mean step of zero, however the mean squared step size is given by</p>

<p>

<math display="block" id="Multiple-try_Metropolis:12">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mo>-</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
     <mfrac>
      <mn>1</mn>
      <msqrt>
       <mrow>
        <mn>2</mn>
        <mi>π</mi>
       </mrow>
      </msqrt>
     </mfrac>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mfrac>
        <msup>
         <mi>x</mi>
         <mn>2</mn>
        </msup>
        <mn>2</mn>
       </mfrac>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <root></root>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>π</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <divide></divide>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>x</ci>
           <cn type="integer">2</cn>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x^{2}\rangle=\int_{-\infty}^{\infty}x^{2}\frac{1}{\sqrt{2\pi}}e^{-%
\frac{x^{2}}{2}}=1
  </annotation>
 </semantics>
</math>

</p>

<p>As the number of dimensions increases, the expected step size becomes larger and larger. In 

<math display="inline" id="Multiple-try_Metropolis:13">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>N</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\,
  </annotation>
 </semantics>
</math>

 dimensions, the probability of moving a radial distance 

<math display="inline" id="Multiple-try_Metropolis:14">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>n</ci>
    </apply>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{n}(r)\,
  </annotation>
 </semantics>
</math>

 is related to the <a href="Chi_distribution" title="wikilink">Chi distribution</a>, and is given by</p>

<p>

<math display="block" id="Multiple-try_Metropolis:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>P</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∝</mo>
   <mrow>
    <msup>
     <mi>r</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <msup>
        <mi>r</mi>
        <mn>2</mn>
       </msup>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proportional-to</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>n</ci>
     </apply>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>r</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>r</ci>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{n}(r)\propto r^{n-1}e^{-r^{2}/2}
  </annotation>
 </semantics>
</math>

</p>

<p>This distribution is peaked at 

<math display="inline" id="Multiple-try_Metropolis:16">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <msqrt>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msqrt>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <apply>
     <root></root>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=\sqrt{N-1}\,
  </annotation>
 </semantics>
</math>

 which is 

<math display="inline" id="Multiple-try_Metropolis:17">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≈</mo>
   <mpadded width="+1.7pt">
    <msqrt>
     <mi>N</mi>
    </msqrt>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <root></root>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \approx\sqrt{N}\,
  </annotation>
 </semantics>
</math>

 for large 

<math display="inline" id="Multiple-try_Metropolis:18">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>N</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\,
  </annotation>
 </semantics>
</math>

. This means that the step size will increase as the roughly the square root of the number of dimensions. For the MH algorithm, large steps will almost always land in regions of low probability, and therefore be rejected.</p>

<p>If we now add the scale parameter 

<math display="inline" id="Multiple-try_Metropolis:19">
 <semantics>
  <mpadded width="+1.7pt">
   <msup>
    <mi>σ</mi>
    <mn>2</mn>
   </msup>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}\,
  </annotation>
 </semantics>
</math>

 back in, we find that to retain a reasonable acceptance rate, we must make the transformation 

<math display="inline" id="Multiple-try_Metropolis:20">
 <semantics>
  <mrow>
   <msup>
    <mi>σ</mi>
    <mn>2</mn>
   </msup>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>σ</mi>
     <mn>2</mn>
    </msup>
    <mo>/</mo>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>σ</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}\rightarrow\sigma^{2}/N
  </annotation>
 </semantics>
</math>

. In this situation, the acceptance rate can now be made reasonable, but the exploration of the probability space becomes increasingly slow. To see this, consider a slice along any one dimension of the problem. By making the scale transformation above, the expected step size is any one dimension is not 

<math display="inline" id="Multiple-try_Metropolis:21">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>σ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\,
  </annotation>
 </semantics>
</math>

 but instead is 

<math display="inline" id="Multiple-try_Metropolis:22">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>/</mo>
   <msqrt>
    <mi>N</mi>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>σ</ci>
    <apply>
     <root></root>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma/\sqrt{N}
  </annotation>
 </semantics>
</math>

. As this step size is much smaller than the "true" scale of the probability distribution (assuming that 

<math display="inline" id="Multiple-try_Metropolis:23">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>σ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\,
  </annotation>
 </semantics>
</math>

 is somehow known a priori, which is the best possible case), the algorithm executes a random walk along every parameter.</p>
<h2 id="the-multiple-try-metropolis-algorithm">The Multiple-try Metropolis algorithm</h2>

<p>Suppose 

<math display="inline" id="Multiple-try_Metropolis:24">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo>,</mo>
    <mi>𝐲</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <interval closure="open">
     <ci>𝐱</ci>
     <ci>𝐲</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(\mathbf{x},\mathbf{y})
  </annotation>
 </semantics>
</math>

 is an arbitrary <a href="proposal_function" title="wikilink">proposal function</a>. We require that 

<math display="inline" id="Multiple-try_Metropolis:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo>,</mo>
     <mi>𝐲</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>Q</ci>
     <interval closure="open">
      <ci>𝐱</ci>
      <ci>𝐲</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(\mathbf{x},\mathbf{y})>0
  </annotation>
 </semantics>
</math>

 only if 

<math display="inline" id="Multiple-try_Metropolis:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐲</mi>
     <mo>,</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>Q</ci>
     <interval closure="open">
      <ci>𝐲</ci>
      <ci>𝐱</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(\mathbf{y},\mathbf{x})>0
  </annotation>
 </semantics>
</math>

. Additionally, 

<math display="inline" id="Multiple-try_Metropolis:27">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(\mathbf{x})
  </annotation>
 </semantics>
</math>

 is the likelihood function.</p>

<p>Define 

<math display="inline" id="Multiple-try_Metropolis:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo>,</mo>
     <mi>𝐲</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo>,</mo>
     <mi>𝐲</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>λ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo>,</mo>
     <mi>𝐲</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>w</ci>
     <interval closure="open">
      <ci>𝐱</ci>
      <ci>𝐲</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>π</ci>
     <ci>𝐱</ci>
     <ci>Q</ci>
     <interval closure="open">
      <ci>𝐱</ci>
      <ci>𝐲</ci>
     </interval>
     <ci>λ</ci>
     <interval closure="open">
      <ci>𝐱</ci>
      <ci>𝐲</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w(\mathbf{x},\mathbf{y})=\pi(\mathbf{x})Q(\mathbf{x},\mathbf{y})\lambda(%
\mathbf{x},\mathbf{y})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Multiple-try_Metropolis:29">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo>,</mo>
    <mi>𝐲</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>λ</ci>
    <interval closure="open">
     <ci>𝐱</ci>
     <ci>𝐲</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda(\mathbf{x},\mathbf{y})
  </annotation>
 </semantics>
</math>

 is a non-negative symmetric function in 

<math display="inline" id="Multiple-try_Metropolis:30">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Multiple-try_Metropolis:31">
 <semantics>
  <mi>𝐲</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐲</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}
  </annotation>
 </semantics>
</math>

 that can be chosen by the user.</p>

<p>Now suppose the current state is 

<math display="inline" id="Multiple-try_Metropolis:32">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

. The MTM algorithm is as follows:</p>

<p>1) Draw <em>k</em> independent trial proposals 

<math display="inline" id="Multiple-try_Metropolis:33">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐲</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>𝐲</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐲</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐲</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}_{1},\ldots,\mathbf{y}_{k}
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Multiple-try_Metropolis:34">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo>,</mo>
    <mo>.</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <ci>normal-.</ci>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(\mathbf{x},.)
  </annotation>
 </semantics>
</math>

. Compute the weights 

<math display="inline" id="Multiple-try_Metropolis:35">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>𝐲</mi>
     <mi>j</mi>
    </msub>
    <mo>,</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐲</ci>
      <ci>j</ci>
     </apply>
     <ci>𝐱</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w(\mathbf{y}_{j},\mathbf{x})
  </annotation>
 </semantics>
</math>

 for each of these.</p>

<p>2) Select 

<math display="inline" id="Multiple-try_Metropolis:36">
 <semantics>
  <mi>𝐲</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐲</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}
  </annotation>
 </semantics>
</math>

 from the 

<math display="inline" id="Multiple-try_Metropolis:37">
 <semantics>
  <msub>
   <mi>𝐲</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐲</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}_{i}
  </annotation>
 </semantics>
</math>

 with probability proportional to the weights.</p>

<p>3) Now produce a reference set by drawing 

<math display="inline" id="Multiple-try_Metropolis:38">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐱</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>𝐱</mi>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{1},\ldots,\mathbf{x}_{k-1}
  </annotation>
 </semantics>
</math>

 from the distribution 

<math display="inline" id="Multiple-try_Metropolis:39">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐲</mi>
    <mo>,</mo>
    <mo>.</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-,</ci>
     <ci>normal-.</ci>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(\mathbf{y},.)
  </annotation>
 </semantics>
</math>

. Set 

<math display="inline" id="Multiple-try_Metropolis:40">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐱</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mi>𝐱</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <ci>k</ci>
    </apply>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{k}=\mathbf{x}
  </annotation>
 </semantics>
</math>

 (the current point).</p>

<p>4) Accept 

<math display="inline" id="Multiple-try_Metropolis:41">
 <semantics>
  <mi>𝐲</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐲</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}
  </annotation>
 </semantics>
</math>

 with probability</p>

<p>

<math display="block" id="Multiple-try_Metropolis:42">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mrow>
    <mtext>min</mtext>
    <mrow>
     <mo>(</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mfrac>
      <mrow>
       <mrow>
        <mi>w</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>𝐲</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <mi>𝐱</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mi mathvariant="normal">…</mi>
       <mo>+</mo>
       <mrow>
        <mi>w</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>𝐲</mi>
          <mi>k</mi>
         </msub>
         <mo>,</mo>
         <mi>𝐱</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mrow>
       <mrow>
        <mi>w</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>𝐱</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <mi>𝐲</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mi mathvariant="normal">…</mi>
       <mo>+</mo>
       <mrow>
        <mi>w</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>𝐱</mi>
          <mi>k</mi>
         </msub>
         <mo>,</mo>
         <mi>𝐲</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <apply>
     <times></times>
     <mtext>min</mtext>
     <interval closure="open">
      <cn type="integer">1</cn>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>w</ci>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐲</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>𝐱</ci>
         </interval>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <times></times>
         <ci>w</ci>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐲</ci>
           <ci>k</ci>
          </apply>
          <ci>𝐱</ci>
         </interval>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>w</ci>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐱</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>𝐲</ci>
         </interval>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <times></times>
         <ci>w</ci>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐱</ci>
           <ci>k</ci>
          </apply>
          <ci>𝐲</ci>
         </interval>
        </apply>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=\text{min}\left(1,\frac{w(\mathbf{y}_{1},\mathbf{x})+\ldots+w(\mathbf{y}_{k}%
,\mathbf{x})}{w(\mathbf{x}_{1},\mathbf{y})+\ldots+w(\mathbf{x}_{k},\mathbf{y})%
}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>It can be shown that this method satisfies the <a href="detailed_balance" title="wikilink">detailed balance</a> property and therefore produces a reversible Markov chain with 

<math display="inline" id="Multiple-try_Metropolis:43">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(\mathbf{x})
  </annotation>
 </semantics>
</math>

 as the stationary distribution.</p>

<p>If 

<math display="inline" id="Multiple-try_Metropolis:44">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo>,</mo>
    <mi>𝐲</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <interval closure="open">
     <ci>𝐱</ci>
     <ci>𝐲</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(\mathbf{x},\mathbf{y})
  </annotation>
 </semantics>
</math>

 is symmetric (as is the case for the <a href="multivariate_normal_distribution" title="wikilink">multivariate normal distribution</a>), then one can choose 

<math display="inline" id="Multiple-try_Metropolis:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo>,</mo>
     <mi>𝐲</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐱</mi>
      <mo>,</mo>
      <mi>𝐲</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>λ</ci>
     <interval closure="open">
      <ci>𝐱</ci>
      <ci>𝐲</ci>
     </interval>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>Q</ci>
      <interval closure="open">
       <ci>𝐱</ci>
       <ci>𝐲</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda(\mathbf{x},\mathbf{y})=\frac{1}{Q(\mathbf{x},\mathbf{y})}
  </annotation>
 </semantics>
</math>

 which gives 

<math display="inline" id="Multiple-try_Metropolis:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo>,</mo>
     <mi>𝐲</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>w</ci>
     <interval closure="open">
      <ci>𝐱</ci>
      <ci>𝐲</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>π</ci>
     <ci>𝐱</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w(\mathbf{x},\mathbf{y})=\pi(\mathbf{x})
  </annotation>
 </semantics>
</math>

</p>
<h3 id="disadvantages">Disadvantages</h3>

<p>Multiple-try Metropolis needs to compute the energy of 

<math display="inline" id="Multiple-try_Metropolis:47">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>k</mi>
   </mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>k</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2k-1
  </annotation>
 </semantics>
</math>

 other states at every step. If the slow part of the process is calculating the energy, then this method can be slower. If the slow part of the process is finding neighbors of a given point, or generating random numbers, then again this method can be slower. It can be argued that this method only appears faster because it puts much more computation into a "single step" than Metropolis-Hastings does.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Markov_chain_Monte_Carlo" title="wikilink">Markov chain Monte Carlo</a></li>
<li><a href="Metropolis–Hastings_algorithm" title="wikilink">Metropolis–Hastings algorithm</a></li>
<li><a href="Detailed_balance" title="wikilink">Detailed balance</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Liu, J. S., Liang, F. and Wong, W. H. (2000). The multiple-try method and local optimization in Metropolis sampling, <em>Journal of the American Statistical Association</em>, <strong>95</strong>(449): 121-134 <a href="http://www.jstor.org/stable/2669532">JSTOR</a></li>
</ul>

<p>"</p>

<p><a href="Category:Monte_Carlo_methods" title="wikilink">Category:Monte Carlo methods</a> <a href="Category:Markov_chain_Monte_Carlo" title="wikilink">Category:Markov chain Monte Carlo</a></p>
</body>
</html>
