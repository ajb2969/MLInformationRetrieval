<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="314">Collocation method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Collocation method</h1>
<hr/>

<p>In mathematics, a <strong>collocation method</strong> is a method for the <a href="numerical_analysis" title="wikilink">numerical</a> solution of <a href="ordinary_differential_equation" title="wikilink">ordinary differential equations</a>, <a href="partial_differential_equation" title="wikilink">partial differential equations</a> and <a href="integral_equation" title="wikilink">integral equations</a>. The idea is to choose a finite-dimensional space of candidate solutions (usually, <a href="polynomial" title="wikilink">polynomials</a> up to a certain degree) and a number of points in the domain (called <em>collocation points</em>), and to select that solution which satisfies the given equation at the collocation points.</p>
<h2 id="ordinary-differential-equations">Ordinary differential equations</h2>

<p>Suppose that the <a href="ordinary_differential_equation" title="wikilink">ordinary differential equation</a></p>

<p>

<math display="block" id="Collocation_method:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>y</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <mrow>
        <mi>y</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>y</mi>
      <mn>0</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>t</ci>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>t</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}(t)=f(t,y(t)),\quad y(t_{0})=y_{0},
  </annotation>
 </semantics>
</math>

 is to be solved over the interval [<em>t</em><sub>0</sub>, <em>t</em><sub>0</sub> + <em>h</em>]. Choose 0 ≤ <em>c</em><sub>1</sub>2</p></body></html><em>n</em> ≤ 1.

<p>The corresponding (polynomial) collocation method approximates the solution <em>y</em> by the polynomial <em>p</em> of degree <em>n</em> which satisfies the initial condition <em>p</em>(<em>t</em><sub>0</sub>) = <em>y</em><sub>0</sub>, and the differential equation <em>p</em>'(<em>t</em>) = <em>f</em>(<em>t</em>,<em>p</em>(<em>t</em>)) at all points, called the <strong>collocation points,</strong> <em>t</em> = <em>t</em><sub>0</sub> + <em>c</em><sub><em>k</em></sub><em>h</em> where <em>k</em> = 1, …, <em>n</em>. This gives <em>n</em> + 1 conditions, which matches the <em>n</em> + 1 parameters needed to specify a polynomial of degree <em>n</em>.</p>

<p>All these collocation methods are in fact implicit <a href="Runge–Kutta_methods" title="wikilink">Runge–Kutta methods</a>. The coefficient <em>c</em><sub><em>k</em></sub> in the Butcher tableau of a Runge–Kutta method are the collocation points. However, not all implicit Runge–Kutta methods are collocation methods. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h3 id="example-the-trapezoidal-rule">Example: The trapezoidal rule</h3>

<p>Pick, as an example, the two collocation points <em>c</em><sub>1</sub> = 0 and <em>c</em><sub>2</sub> = 1 (so <em>n</em> = 2). The collocation conditions are</p>

<p>

<math display="block" id="Collocation_method:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>t</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>y</mi>
     <mn>0</mn>
    </msub>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(t_{0})=y_{0},\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Collocation_method:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>p</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>t</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>t</mi>
       <mn>0</mn>
      </msub>
      <mo>,</mo>
      <mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>t</mi>
         <mn>0</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <ci>p</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{\prime}(t_{0})=f(t_{0},p(t_{0})),\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Collocation_method:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>p</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mi>h</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mi>h</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>t</mi>
          <mn>0</mn>
         </msub>
         <mo>+</mo>
         <mi>h</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>h</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>h</ci>
      </apply>
      <apply>
       <times></times>
       <ci>p</ci>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>h</ci>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{\prime}(t_{0}+h)=f(t_{0}+h,p(t_{0}+h)).\,
  </annotation>
 </semantics>
</math>

</p>

<p>There are three conditions, so <em>p</em> should be a polynomial of degree 2. Write <em>p</em> in the form</p>

<p>

<math display="block" id="Collocation_method:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>α</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <msub>
         <mi>t</mi>
         <mn>0</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>β</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mpadded width="+1.7pt">
     <mi>γ</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>α</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>β</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
     <ci>γ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(t)=\alpha(t-t_{0})^{2}+\beta(t-t_{0})+\gamma\,
  </annotation>
 </semantics>
</math>

</p>

<p>to simplify the computations. Then the collocation conditions can be solved to give the coefficients</p>

<p>

<math display="inline" id="Collocation_method:5">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\alpha
  </annotation>
 </semantics>
</math>


</p>

<p>The collocation method is now given (implicitly) by</p>

<p>

<math display="block" id="Collocation_method:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo>+</mo>
       <mi>h</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
      <mi>h</mi>
      <mrow>
       <mo maxsize="160%" minsize="160%">(</mo>
       <mrow>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mi>t</mi>
            <mn>0</mn>
           </msub>
           <mo>+</mo>
           <mi>h</mi>
          </mrow>
          <mo>,</mo>
          <msub>
           <mi>y</mi>
           <mn>1</mn>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>t</mi>
           <mn>0</mn>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>y</mi>
           <mn>0</mn>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo maxsize="160%" minsize="160%">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>p</ci>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>h</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <ci>h</ci>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>f</ci>
         <interval closure="open">
          <apply>
           <plus></plus>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>t</ci>
            <cn type="integer">0</cn>
           </apply>
           <ci>h</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <cn type="integer">1</cn>
          </apply>
         </interval>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>t</ci>
           <cn type="integer">0</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <cn type="integer">0</cn>
          </apply>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1}=p(t_{0}+h)=y_{0}+\frac{1}{2}h\Big(f(t_{0}+h,y_{1})+f(t_{0},y_{0})\Big),\,
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>y</em><sub>1</sub> = <em>p</em>(<em>t</em><sub>0</sub> + <em>h</em>) is the approximate solution at <em>t</em> = <em>t</em><sub>0</sub> + <em>h</em>.</p>

<p>This method is known as the "<a href="trapezoidal_rule_(differential_equations)" title="wikilink">trapezoidal rule</a>" for differential equations. Indeed, this method can also be derived by rewriting the differential equation as</p>

<p>

<math display="block" id="Collocation_method:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mi>t</mi>
      </msubsup>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>τ</mi>
        <mo>,</mo>
        <mrow>
         <mi>y</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>τ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <mtext>d</mtext>
       <mi>τ</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <ci>τ</ci>
        <apply>
         <times></times>
         <ci>y</ci>
         <ci>τ</ci>
        </apply>
       </interval>
       <mtext>d</mtext>
       <ci>τ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(t)=y(t_{0})+\int_{t_{0}}^{t}f(\tau,y(\tau))\,\textrm{d}\tau,\,
  </annotation>
 </semantics>
</math>

</p>

<p>and approximating the integral on the right-hand side by the <a href="trapezoidal_rule" title="wikilink">trapezoidal rule</a> for integrals.</p>
<h3 id="other-examples">Other examples</h3>

<p>The <a href="Gauss–Legendre_method" title="wikilink">Gauss–Legendre methods</a> uses the points of <a href="Gauss–Legendre_quadrature" title="wikilink">Gauss–Legendre quadrature</a> as collocation points. The Gauss–Legendre method based on <em>s</em> points has order 2<em>s</em>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> All Gauss–Legendre methods are <a href="A-stability" title="wikilink">A-stable</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>In fact, one can show that the order of a collocation method corresponds to the order of the quadrature rule that one would get using the collocation points as weights.</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_differential_equations" title="wikilink">Category:Numerical differential equations</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">; <a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>


