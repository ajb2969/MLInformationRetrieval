<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="825">Universal code (data compression)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Universal code (data compression)</h1>
<hr/>

<p>  In <a href="data_compression" title="wikilink">data compression</a>, a <strong>universal code</strong> for integers is a <a href="prefix_code" title="wikilink">prefix code</a> that maps the positive integers onto binary codewords, with the additional property that whatever the true <a href="probability_distribution" title="wikilink">probability distribution</a> on integers, as long as the distribution is monotonic (i.e., <em>p</em>(<em>i</em>) ≥ <em>p</em>(<em>i</em> + 1) for all positive <em>i</em>), the <a href="expected_value" title="wikilink">expected</a> lengths of the codewords are within a constant factor of the expected lengths that the <a href="optimal_code" title="wikilink">optimal code</a> for that probability distribution would have assigned. A universal code is <em>asymptotically optimal</em> if the ratio between actual and optimal <a href="expected_value" title="wikilink">expected</a> lengths is bounded by a function of the <a href="information_entropy" title="wikilink">information entropy</a> of the code that, in addition to being bounded, approaches 1 as entropy approaches infinity.</p>

<p>In general, most prefix codes for integers assign longer codewords to larger integers. Such a code can be used to efficiently communicate a message drawn from a set of possible messages, by simply ordering the set of messages by decreasing probability and then sending the index of the intended message. Universal codes are generally not used for precisely known probability distributions, and no universal code is known to be optimal for any distribution used in practice.</p>

<p>A universal code should not be confused with <a href="universal_source_coding" title="wikilink">universal source coding</a>, in which the data compression method need not be a fixed prefix code and the ratio between actual and optimal expected lengths must approach one. However, note that an asymptotically optimal universal code can be used on <a href="Independent_identically-distributed_random_variables" title="wikilink">independent identically-distributed sources</a>, by using increasingly large <a href="block_code" title="wikilink">blocks</a>, as a method of universal source coding.</p>
<h2 id="universal-and-non-universal-codes">Universal and non-universal codes</h2>

<p>These are some universal codes for integers; an asterisk (<a href="Asterisk" title="wikilink">*</a>) indicates a code that can be trivially restated in <a href="lexicographical_order" title="wikilink">lexicographical order</a>, while a double dagger (<a class="uri" href="‡" title="wikilink">‡</a>) indicates a code that is asymptotically optimal:</p>
<ul>
<li><a href="Elias_gamma_coding" title="wikilink">Elias gamma coding</a> *</li>
<li><a href="Elias_delta_coding" title="wikilink">Elias delta coding</a> * ‡</li>
<li><a href="Elias_omega_coding" title="wikilink">Elias omega coding</a> * ‡</li>
<li><a href="Exponential-Golomb_coding" title="wikilink">Exp-Golomb coding</a> *, which has Elias gamma coding as a special case. (Used in <a href="H.264/MPEG-4_AVC" title="wikilink">H.264/MPEG-4 AVC</a>)</li>
<li><a href="Fibonacci_coding" title="wikilink">Fibonacci coding</a></li>
<li><a href="Levenshtein_coding" title="wikilink">Levenshtein coding</a> * ‡, the original universal coding technique <a href="http://www.compression.ru/download/articles/int/levenstein_1968_on_the_redundancy_and_delay.pdf">1</a></li>
<li><a href="Byte_coding" title="wikilink">Byte coding</a>, also known as <a href="comma_coding" title="wikilink">comma coding</a>, where a special bit pattern (with at least two bits) is used to mark the end of the code — for example, if an integer is encoded as a sequence of <a href="nibble" title="wikilink">nibbles</a> representing digits in <a href="base_15" title="wikilink">base 15</a> instead of the more natural <a href="base_16" title="wikilink">base 16</a>, then the highest nibble value (i.e., a sequence of four ones in binary) can be used to indicate the end of the integer.</li>
</ul>

<p>These are non-universal ones:</p>
<ul>
<li><a href="unary_coding" title="wikilink">unary coding</a>, which is used in Elias codes</li>
<li><a href="Golomb_coding" title="wikilink">Rice coding</a>, which is used in the <a class="uri" href="FLAC" title="wikilink">FLAC</a> <a href="audio_codec" title="wikilink">audio codec</a> and which has unary coding as a special case</li>
<li><a href="Golomb_coding" title="wikilink">Golomb coding</a>, which has Rice coding and unary coding as special cases.</li>
</ul>

<p>Their nonuniversality can be observed by noticing that, if any of these are used to code the <a href="Gauss–Kuzmin_distribution" title="wikilink">Gauss–Kuzmin distribution</a> or the <a href="Zeta_distribution" title="wikilink">Zeta distribution</a> with parameter s=2, expected codeword length is infinite. For example, using unary coding on the Zeta distribution yields an expected length of</p>

<p>

<math display="block" id="Universal_code_(data_compression):0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>6</mn>
      <msup>
       <mi>π</mi>
       <mn>2</mn>
      </msup>
     </mfrac>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>l</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi mathvariant="normal">∞</mi>
      </munderover>
      <mfrac>
       <mn>1</mn>
       <mi>l</mi>
      </mfrac>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>l</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">6</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>π</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>l</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <infinity></infinity>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>l</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(l)=\frac{6}{\pi^{2}}\sum_{l=1}^{\infty}\frac{1}{l}=\infty.\,
  </annotation>
 </semantics>
</math>

</p>

<p>On the other hand, using the universal Elias gamma coding for the Gauss–Kuzmin distribution results in an expected codeword length (about 3.51 bits) near entropy (about 3.43 bits)<a href="http://scholar.google.com/scholar?cluster=13442560459874106744">2</a>.</p>
<h2 id="relationship-to-practical-compression">Relationship to practical compression</h2>

<p><a href="Huffman_coding" title="wikilink">Huffman coding</a> and <a href="arithmetic_coding" title="wikilink">arithmetic coding</a> (when they can be used) give at least as good, and often better compression than any universal code.</p>

<p>However, universal codes are useful when Huffman coding cannot be used — for example, when one does not know the exact probability of each message, but only knows the rankings of their probabilities.</p>

<p>Universal codes are also useful when Huffman codes are inconvenient. For example, when the transmitter but not the receiver knows the probabilities of the messages, Huffman coding requires an overhead of transmitting those probabilities to the receiver. Using a universal code does not have that overhead.</p>

<p>Each universal code, like each other self-delimiting (prefix) binary code, has its own "implied probability distribution" given by <em>p</em>(<em>i</em>)=2<sup>−<em>l</em>(<em>i</em>)</sup> where <em>l</em>(<em>i</em>) is the length of the <em>i</em>th codeword and <em>p</em>(<em>i</em>) is the corresponding symbol's probability. If the actual message probabilities are <em>q</em>(<em>i</em>) and <a href="Kullback–Leibler_divergence" title="wikilink">Kullback–Leibler divergence</a> <em>D</em><sub>KL</sub>(<em>q</em>||<em>p</em>) is minimized by the code with <em>l</em>(<em>i</em>), then the optimal Huffman code for that set of messages will be equivalent to that code. Likewise, how close a code is to optimal can be measured by this divergence. Since universal codes are simpler and faster to encode and decode than Huffman codes (which is, in turn, simpler and faster than <a href="arithmetic_encoding" title="wikilink">arithmetic encoding</a>), the universal code would be preferable in cases where <em>D</em><sub>KL</sub>(<em>q</em>||<em>p</em>) is sufficiently small. <a href="http://www.cs.tut.fi/~albert/Dev/pucrunch/">3</a></p>

<p>For any <a href="geometric_distribution" title="wikilink">geometric distribution</a> (an exponential distribution on integers), a Golomb code is optimal. With universal codes, the implicit distribution is approximately a <a href="power_law" title="wikilink">power law</a> such as 

<math display="inline" id="Universal_code_(data_compression):1">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <msup>
    <mi>n</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/n^{2}
  </annotation>
 </semantics>
</math>

 (more precisely, a <a href="Zipf_distribution" title="wikilink">Zipf distribution</a>). For the <a href="Fibonacci_code" title="wikilink">Fibonacci code</a>, the implicit distribution is approximately 

<math display="inline" id="Universal_code_(data_compression):2">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <msup>
    <mi>n</mi>
    <mi>q</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/n^{q}
  </annotation>
 </semantics>
</math>

, with</p>

<p>

<math display="block" id="Universal_code_(data_compression):3">
 <semantics>
  <mrow>
   <mrow>
    <mi>q</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mrow>
      <msub>
       <mi>log</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>φ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>≃</mo>
    <mn>1.44</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>q</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <cn type="integer">2</cn>
       </apply>
       <ci>φ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">similar-to-or-equals</csymbol>
     <share href="#.cmml">
     </share>
     <cn type="float">1.44</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q=1/\log_{2}(\varphi)\simeq 1.44,
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Universal_code_(data_compression):4">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 is the <a href="golden_ratio" title="wikilink">golden ratio</a>. For the ternary <a href="comma_code" title="wikilink">comma code</a> (i.e., encoding in base 3, represented with 2 bits per symbol), the implicit distribution is a power law with 

<math display="inline" id="Universal_code_(data_compression):5">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>3</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>4</mn>
       <mo>/</mo>
       <mn>3</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≃</mo>
   <mn>1.26</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>q</ci>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">4</cn>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">similar-to-or-equals</csymbol>
     <share href="#.cmml">
     </share>
     <cn type="float">1.26</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q=1+\log_{3}(4/3)\simeq 1.26
  </annotation>
 </semantics>
</math>

. These distributions thus have near-optimal codes with their respective power laws.</p>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.ics.uci.edu/~dan/pubs/DC-Sec3.html">Data Compression</a>, by Debra A. Lelewer and Daniel S. Hirschberg (<a href="University_of_California,_Irvine" title="wikilink">University of California, Irvine</a>)</li>
<li><em><a href="http://www.inference.phy.cam.ac.uk/mackay/itila/">Information Theory, Inference, and Learning Algorithms</a></em>, by <a href="David_MacKay_(scientist)" title="wikilink">David MacKay</a>, has a chapter on codes for integers, including an introduction to Elias codes.</li>
<li><a href="http://www-lat.compression.ru/download/integers.html">Кодирование целых чисел</a> has mostly English-language papers on universal and other integer codes.</li>
</ul>

<p>"</p>

<p><a href="Category:Data_compression" title="wikilink">Category:Data compression</a> <a href="Category:Lossless_compression_algorithms" title="wikilink">Category:Lossless compression algorithms</a></p>
</body>
</html>
