<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1351">Extra element theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Extra element theorem</h1>
<hr/>

<p>The <strong>Extra Element Theorem</strong> (EET) is an analytic technique developed by <a href="R._D._Middlebrook" title="wikilink">R. D. Middlebrook</a> for simplifying the process of deriving driving point and <a href="transfer_function" title="wikilink">transfer functions</a> for linear <a href="electronic_circuits" title="wikilink">electronic circuits</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Much like <a href="Thévenin's_theorem" title="wikilink">Thévenin's theorem</a>, the extra element theorem breaks down one complicated problem into several simpler ones.</p>

<p>Driving point and transfer functions can generally be found using <a class="uri" href="KVL" title="wikilink">KVL</a> and <a href="KVL" title="wikilink">KCL</a> methods, however several complicated equations may result that offer little insight into the circuit's behavior. Using the extra element theorem, a circuit element (such as a <a class="uri" href="resistor" title="wikilink">resistor</a>) can be removed from a circuit and the desired driving point or transfer function found. By removing the element that most complicates the circuit (such as an element that creates <a class="uri" href="feedback" title="wikilink">feedback</a>), the desired function can be easier to obtain. Next two correctional factors must be found and combined with the previously derived function to find the exact expression.</p>

<p>The general form of the extra element theorem is called the N-extra element theorem and allows multiple circuit elements to be removed at once.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="general-formulation">General Formulation</h2>

<p>The (single) extra element theorem expresses any transfer function as a product of the transfer function with that element removed and a correction factor. The correction factor term consists of the <a href="Electrical_impedance" title="wikilink">impedance</a> of the extra element and two driving point impedances seen by the extra element: The double null injection driving point impedance and the single injection driving point impedance. Because an extra element can be removed in general by either short-circuiting or open-circuiting the element, there are two equivalent forms of the EET:<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>

<math display="block" id="Extra_element_theorem:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi mathvariant="normal">∞</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mfrac>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mfrac>
       <mrow>
        <msub>
         <mi>Z</mi>
         <mi>n</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>s</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mi>Z</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>s</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
     </mrow>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mfrac>
       <mrow>
        <msub>
         <mi>Z</mi>
         <mi>d</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>s</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mi>Z</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>s</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <infinity></infinity>
     </apply>
     <ci>s</ci>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Z</ci>
          <ci>n</ci>
         </apply>
         <ci>s</ci>
        </apply>
        <apply>
         <times></times>
         <ci>Z</ci>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Z</ci>
          <ci>d</ci>
         </apply>
         <ci>s</ci>
        </apply>
        <apply>
         <times></times>
         <ci>Z</ci>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(s)=H_{\infty}(s)\frac{1+\frac{Z_{n}(s)}{Z(s)}}{1+\frac{Z_{d}(s)}{Z(s)}}
  </annotation>
 </semantics>
</math>

</p>

<p>or,</p>

<p>

<math display="block" id="Extra_element_theorem:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mfrac>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mfrac>
       <mrow>
        <mi>Z</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>s</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <msub>
         <mi>Z</mi>
         <mi>n</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>s</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
     </mrow>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mfrac>
       <mrow>
        <mi>Z</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>s</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <msub>
         <mi>Z</mi>
         <mi>d</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>s</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>s</ci>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>Z</ci>
         <ci>s</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Z</ci>
          <ci>n</ci>
         </apply>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>Z</ci>
         <ci>s</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Z</ci>
          <ci>d</ci>
         </apply>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(s)=H_{0}(s)\frac{1+\frac{Z(s)}{Z_{n}(s)}}{1+\frac{Z(s)}{Z_{d}(s)}}
  </annotation>
 </semantics>
</math>

.</p>

<p>Where the <a href="Laplace_transform" title="wikilink">Laplace</a>-domain transfer functions and impedances in the above expressions are defined as follows: 

<math display="inline" id="Extra_element_theorem:2">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(s)
  </annotation>
 </semantics>
</math>

 is the transfer function with the extra element present. <mtpl></mtpl> is the transfer function with the extra element open-circuited. <mtpl></mtpl> is the transfer function with the extra element short-circuited. 

<math display="inline" id="Extra_element_theorem:3">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Z</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z(s)
  </annotation>
 </semantics>
</math>

 is the impedance of the extra element. <mtpl></mtpl> is the single-injection driving point impedance "seen" by the extra element. <mtpl></mtpl> is the double-null-injection driving point impedance "seen" by the extra element.</p>
<h2 id="driving-point-impedances">Driving Point Impedances</h2>
<h3 id="single-injection-driving-point-impedance">Single Injection Driving Point Impedance</h3>

<p><mtpl></mtpl> is found by making the input to the system's transfer function zero (short circuit a voltage source or open circuit a current source) and determining the impedance across the terminals to which the extra element will be connected with the extra element absent.</p>
<h3 id="double-null-injection-driving-point-impedance">Double Null Injection Driving Point Impedance</h3>

<p><mtpl></mtpl> is found by replacing the extra element with a second test signal source (either current source or voltage source as appropriate). Then, <mtpl></mtpl> is defined as the ratio of voltage across the terminals of this second test source to the current leaving its positive terminal when the output of the system's transfer function is nulled for any value of the primary input to the system's transfer function.</p>

<p>In practice, <mtpl></mtpl> can be found from working backwards from the facts that the output of the transfer function is made zero and that the primary input to the transfer function is unknown. Then using conventional circuit analysis techniques to express both the voltage across the extra element test source's terminals, <mtpl></mtpl>, and the current leaving the extra element test source's positive terminals, <mtpl></mtpl>, and calculating 

<math display="inline" id="Extra_element_theorem:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Z</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>v</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>/</mo>
     <msub>
      <mi>i</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <ci>n</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <ci>n</ci>
       </apply>
       <ci>s</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>i</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{n}(s)=v_{n}(s)/i_{n}(s)
  </annotation>
 </semantics>
</math>


. Although computation of <mtpl></mtpl> is an unfamiliar process for many engineers, its expressions are often much simpler than those for <mtpl></mtpl> because the nulling of the transfer function's output often leads to other voltages/currents in the circuit being zero, which may allow exclusion of certain components from analysis.</p>
<h2 id="special-case-with-transfer-function-as-a-self-impedance">Special Case With Transfer Function as a Self-Impedance</h2>

<p>As a special case, the EET can be used to find the input impedance of a network with the addition of an element designated as "extra". In this case, <mtpl></mtpl> is same as the impedance of the input test current source signal made zero or equivalently with the input open circuited. Likewise, since the transfer function output signal can be considered to be the voltage at the input terminals, <mtpl></mtpl> is found when the input voltage is zero i.e. the input terminals are short-circuited. Thus, for this particular application the EET can be written as:</p>

<p>

<math display="block" id="Extra_element_theorem:5">
 <semantics>
  <mrow>
   <msub>
    <mi>Z</mi>
    <mrow>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>Z</mi>
     <mrow>
      <mi>i</mi>
      <mi>n</mi>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mo>⋅</mo>
    <mfrac>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mfrac>
       <msubsup>
        <mi>Z</mi>
        <mi>e</mi>
        <mn>0</mn>
       </msubsup>
       <mi>Z</mi>
      </mfrac>
     </mrow>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mfrac>
       <msubsup>
        <mi>Z</mi>
        <mi>e</mi>
        <mi mathvariant="normal">∞</mi>
       </msubsup>
       <mi>Z</mi>
      </mfrac>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Z</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Z</ci>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>Z</ci>
          <cn type="integer">0</cn>
         </apply>
         <ci>e</ci>
        </apply>
        <ci>Z</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>Z</ci>
          <infinity></infinity>
         </apply>
         <ci>e</ci>
        </apply>
        <ci>Z</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{in}=Z^{\infty}_{in}\cdot\frac{1+\frac{Z^{0}_{e}}{Z}}{1+\frac{Z^{\infty}_{e}%
}{Z}}
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Extra_element_theorem:6">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 is the impedance chosen as the extra element</p>

<p>

<math display="block" id="Extra_element_theorem:7">
 <semantics>
  <msubsup>
   <mi>Z</mi>
   <mrow>
    <mi>i</mi>
    <mi>n</mi>
   </mrow>
   <mi mathvariant="normal">∞</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Z</ci>
     <infinity></infinity>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z^{\infty}_{in}
  </annotation>
 </semantics>
</math>

 is the input impedance with Z removed (or made infinite)</p>

<p>

<math display="block" id="Extra_element_theorem:8">
 <semantics>
  <msubsup>
   <mi>Z</mi>
   <mi>e</mi>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Z</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z^{0}_{e}
  </annotation>
 </semantics>
</math>

 is the impedance seen by the extra element Z with the input shorted (or made zero)</p>

<p>

<math display="block" id="Extra_element_theorem:9">
 <semantics>
  <msubsup>
   <mi>Z</mi>
   <mi>e</mi>
   <mi mathvariant="normal">∞</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Z</ci>
     <infinity></infinity>
    </apply>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z^{\infty}_{e}
  </annotation>
 </semantics>
</math>

 is the impedance seen by the extra element Z with the input open (or made infinite)</p>

<p>Computing these three terms may seem like extra effort, but they are often easier to compute than the overall input impedance.</p>
<h3 id="example">Example</h3>
<figure><b>(Figure)</b>
<figcaption>Figure 1: Simple RC circuit to demonstrate the EET. The capacitor (gray shading) is denoted the extra element</figcaption>
</figure>

<p>Consider the problem of finding 

<math display="inline" id="Extra_element_theorem:10">
 <semantics>
  <msub>
   <mi>Z</mi>
   <mrow>
    <mi>i</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Z</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{in}
  </annotation>
 </semantics>
</math>

 for the circuit in Figure 1 using the EET (note all component values are unity for simplicity). If the capacitor (gray shading) is denoted the extra element then</p>

<p>

<math display="block" id="Extra_element_theorem:11">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mi>s</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Z</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z=\frac{1}{s}
  </annotation>
 </semantics>
</math>

</p>

<p>Removing this capacitor from the circuit we find</p>

<p>

<math display="block" id="Extra_element_theorem:12">
 <semantics>
  <mrow>
   <msubsup>
    <mi>Z</mi>
    <mrow>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <mo>=</mo>
   <mn>2</mn>
   <mo>∥</mo>
   <mn>1</mn>
   <mo>+</mo>
   <mn>1</mn>
   <mo>=</mo>
   <mfrac>
    <mn>5</mn>
    <mn>3</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Z</ci>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <eq></eq>
    <cn type="integer">2</cn>
    <csymbol cd="latexml">parallel-to</csymbol>
    <cn type="integer">1</cn>
    <plus></plus>
    <cn type="integer">1</cn>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">5</cn>
     <cn type="integer">3</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z^{\infty}_{in}=2\|1+1=\frac{5}{3}
  </annotation>
 </semantics>
</math>

</p>

<p>Calculating the impedance seen by the capacitor with the input shorted we find</p>

<p>

<math display="block" id="Extra_element_theorem:13">
 <semantics>
  <mrow>
   <msubsup>
    <mi>Z</mi>
    <mi>e</mi>
    <mn>0</mn>
   </msubsup>
   <mo>=</mo>
   <mn>1</mn>
   <mo>∥</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>+</mo>
    <mn>1</mn>
    <mo>∥</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>3</mn>
    <mn>5</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Z</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>e</ci>
    </apply>
    <eq></eq>
    <cn type="integer">1</cn>
    <csymbol cd="latexml">parallel-to</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <plus></plus>
     <cn type="integer">1</cn>
     <csymbol cd="latexml">parallel-to</csymbol>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">3</cn>
     <cn type="integer">5</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z^{0}_{e}=1\|(1+1\|1)=\frac{3}{5}
  </annotation>
 </semantics>
</math>

</p>

<p>Calculating the impedance seen by the capacitor with the input open we find</p>

<p>

<math display="block" id="Extra_element_theorem:14">
 <semantics>
  <mrow>
   <msubsup>
    <mi>Z</mi>
    <mi>e</mi>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <mo>=</mo>
   <mn>2</mn>
   <mo>∥</mo>
   <mn>1</mn>
   <mo>+</mo>
   <mn>1</mn>
   <mo>=</mo>
   <mfrac>
    <mn>5</mn>
    <mn>3</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Z</ci>
      <infinity></infinity>
     </apply>
     <ci>e</ci>
    </apply>
    <eq></eq>
    <cn type="integer">2</cn>
    <csymbol cd="latexml">parallel-to</csymbol>
    <cn type="integer">1</cn>
    <plus></plus>
    <cn type="integer">1</cn>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">5</cn>
     <cn type="integer">3</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z^{\infty}_{e}=2\|1+1=\frac{5}{3}
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore using the EET, we find</p>

<p>

<math display="block" id="Extra_element_theorem:15">
 <semantics>
  <mrow>
   <msub>
    <mi>Z</mi>
    <mrow>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>5</mn>
     <mn>3</mn>
    </mfrac>
    <mo>⋅</mo>
    <mfrac>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <mn>3</mn>
        <mn>5</mn>
       </mfrac>
       <mi>s</mi>
      </mrow>
     </mrow>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <mn>5</mn>
        <mn>3</mn>
       </mfrac>
       <mi>s</mi>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mn>5</mn>
     <mo>+</mo>
     <mrow>
      <mn>3</mn>
      <mi>s</mi>
     </mrow>
    </mrow>
    <mrow>
     <mn>3</mn>
     <mo>+</mo>
     <mrow>
      <mn>5</mn>
      <mi>s</mi>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <divide></divide>
       <cn type="integer">5</cn>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <cn type="integer">3</cn>
          <cn type="integer">5</cn>
         </apply>
         <ci>s</ci>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <cn type="integer">5</cn>
          <cn type="integer">3</cn>
         </apply>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <cn type="integer">5</cn>
       <apply>
        <times></times>
        <cn type="integer">3</cn>
        <ci>s</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <cn type="integer">3</cn>
       <apply>
        <times></times>
        <cn type="integer">5</cn>
        <ci>s</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{in}=\frac{5}{3}\cdot\frac{1+\frac{3}{5}s}{1+\frac{5}{3}s}=\frac{5+3s}{3+5s}
  </annotation>
 </semantics>
</math>

</p>

<p>Note that this problem was solved by calculating three simple driving point impedances by inspection.</p>
<h2 id="feedback-amplifiers">Feedback amplifiers</h2>

<p>The EET is also useful for analyzing single and multi-loop feedback amplifiers. In this case the EET can take the form of the <a href="Asymptotic_gain_model" title="wikilink">Asymptotic gain model</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Asymptotic_gain_model" title="wikilink">Asymptotic gain model</a></li>
<li><a href="Blackman's_theorem" title="wikilink">Blackman's theorem</a></li>
<li><a href="Return_ratio" title="wikilink">Return ratio</a></li>
<li><a href="Signal-flow_graph" title="wikilink">Signal-flow graph</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.edn.com/archives/1995/080395/16df4.htm">Examples of applying the EET</a></li>
<li><a href="http://ece-www.colorado.edu/~ecen5807/course_material/slidesAppC.pdf">Derivation and examples</a></li>
</ul>

<p>"</p>

<p><a href="Category:Circuit_theorems" title="wikilink">Category:Circuit theorems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
