<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="343">Stochastic approximation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Stochastic approximation</h1>
<hr/>

<p><strong>Stochastic approximation</strong> methods are a family of iterative <a href="stochastic_optimization" title="wikilink">stochastic optimization</a> <a href="algorithm" title="wikilink">algorithms</a> that attempt to find zeroes or <a href="Extremum" title="wikilink">extrema</a> of functions which cannot be computed directly, but only estimated via noisy observations.</p>

<p>Mathematically, this refers to solving:</p>

<p>

<math display="block" id="Stochastic_approximation:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+2.8pt">
      <munder>
       <mi>min</mi>
       <mrow>
        <mi>x</mi>
        <mo>‚àà</mo>
        <mi mathvariant="normal">Œò</mi>
       </mrow>
      </munder>
     </mpadded>
     <mi>f</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munder>
      <mi>min</mi>
      <mrow>
       <mi>x</mi>
       <mo>‚àà</mo>
       <mi mathvariant="normal">Œò</mi>
      </mrow>
     </munder>
     <mi>ùîº</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>F</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>Œæ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <min></min>
       <apply>
        <in></in>
        <ci>x</ci>
        <ci>normal-Œò</ci>
       </apply>
      </apply>
      <ci>f</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <min></min>
       <apply>
        <in></in>
        <ci>x</ci>
        <ci>normal-Œò</ci>
       </apply>
      </apply>
      <ci>ùîº</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>F</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>Œæ</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min_{x\in\Theta}\;f(x)=\min_{x\in\Theta}\mathbb{E}[F(x,\xi)]
  </annotation>
 </semantics>
</math>

 where the objective is to find the parameter 

<math display="inline" id="Stochastic_approximation:1">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>‚àà</mo>
   <mi mathvariant="normal">Œò</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>normal-Œò</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\Theta
  </annotation>
 </semantics>
</math>

, which minimizes 

<math display="inline" id="Stochastic_approximation:2">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 for some unknown <a href="random_variable" title="wikilink">random variable</a>, 

<math display="inline" id="Stochastic_approximation:3">
 <semantics>
  <mi>Œæ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œæ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

. Denoting 

<math display="inline" id="Stochastic_approximation:4">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 as the dimension of the parameter 

<math display="inline" id="Stochastic_approximation:5">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, we can assume that while the domain 

<math display="inline" id="Stochastic_approximation:6">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Œò</mi>
   <mo>‚äÇ</mo>
   <msup>
    <mi>‚Ñù</mi>
    <mi>d</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>normal-Œò</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>‚Ñù</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta\subset\mathbb{R}^{d}
  </annotation>
 </semantics>
</math>

 is known, the objective function, 

<math display="inline" id="Stochastic_approximation:7">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

, cannot be computed exactly, but instead approximated via simulation. This can be intuitively explained as follows. 

<math display="inline" id="Stochastic_approximation:8">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 is the original function we want to minimize. However, due to noise, 

<math display="inline" id="Stochastic_approximation:9">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 can not be evaluated exactly. This situation is modeled by the function 

<math display="inline" id="Stochastic_approximation:10">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>Œæ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>Œæ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x,\xi)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Stochastic_approximation:11">
 <semantics>
  <mi>Œæ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œæ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

 represents the noise and is a random variable. Since 

<math display="inline" id="Stochastic_approximation:12">
 <semantics>
  <mi>Œæ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œæ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

 is a random variable, so is the value of 

<math display="inline" id="Stochastic_approximation:13">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>Œæ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>Œæ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x,\xi)
  </annotation>
 </semantics>
</math>

. The objective is then to minimize 

<math display="inline" id="Stochastic_approximation:14">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

, but through evaluating 

<math display="inline" id="Stochastic_approximation:15">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>Œæ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>Œæ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x,\xi)
  </annotation>
 </semantics>
</math>

. A reasonable way to do this is to minimize the expectation of 

<math display="inline" id="Stochastic_approximation:16">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>Œæ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>Œæ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x,\xi)
  </annotation>
 </semantics>
</math>

, i.e., 

<math display="inline" id="Stochastic_approximation:17">
 <semantics>
  <mrow>
   <mi>ùîº</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>Œæ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ùîº</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <times></times>
      <ci>F</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>Œæ</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}[F(x,\xi)]
  </annotation>
 </semantics>
</math>

.</p>

<p>The first, and prototypical, algorithms of this kind are the <strong>Robbins-Monro</strong> and <strong>Kiefer-Wolfowitz</strong> algorithms introduced respectively in 1951 and 1952.</p>
<h2 id="robbinsmonro-algorithm">Robbins‚ÄìMonro algorithm</h2>

<p>The Robbins‚ÄìMonro algorithm, introduced in 1951 by <a href="Herbert_Robbins" title="wikilink">Herbert Robbins</a> and Sutton Monro,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> presented a methodology for solving a root finding problem, where the function is represented as an expected value. Assume that we have a function 

<math display="inline" id="Stochastic_approximation:18">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M(x)
  </annotation>
 </semantics>
</math>

, and a constant 

<math display="inline" id="Stochastic_approximation:19">
 <semantics>
  <mi>Œ±</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ±</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

, such that the equation 

<math display="inline" id="Stochastic_approximation:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>Œ±</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>M</ci>
     <ci>x</ci>
    </apply>
    <ci>Œ±</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M(x)=\alpha
  </annotation>
 </semantics>
</math>

 has a unique root at 

<math display="inline" id="Stochastic_approximation:21">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>Œ∏</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <ci>Œ∏</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=\theta
  </annotation>
 </semantics>
</math>

. It is assumed that while we cannot directly observe the function 

<math display="inline" id="Stochastic_approximation:22">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M(x)
  </annotation>
 </semantics>
</math>

, we can instead obtain measurements of the random variable 

<math display="inline" id="Stochastic_approximation:23">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N(x)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Stochastic_approximation:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>ùîº</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>N</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>M</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ùîº</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>N</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>M</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}[N(x)]=M(x)
  </annotation>
 </semantics>
</math>

. The structure of the algorithm is to then generate iterates of the form:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Stochastic_approximation:25">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>Œ±</mi>
      <mo>-</mo>
      <mrow>
       <mi>N</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>Œ±</ci>
      <apply>
       <times></times>
       <ci>N</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n+1}-x_{n}=a_{n}(\alpha-N(x_{n}))
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Here, 

<math display="inline" id="Stochastic_approximation:26">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">‚Ä¶</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-‚Ä¶</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1},a_{2},\dots
  </annotation>
 </semantics>
</math>

 is a sequence of positive step sizes. <a href="Herbert_Robbins" title="wikilink">Robbins</a> and Monro proved <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><sup>, Theorem 2</sup> that 

<math display="inline" id="Stochastic_approximation:27">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}
  </annotation>
 </semantics>
</math>

 <a href="convergence_of_random_variables" title="wikilink">converges</a> in 

<math display="inline" id="Stochastic_approximation:28">
 <semantics>
  <msup>
   <mi>L</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>L</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{2}
  </annotation>
 </semantics>
</math>

 (and hence also in probability) to 

<math display="inline" id="Stochastic_approximation:29">
 <semantics>
  <mi>Œ∏</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ∏</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 provided that:</p>
<ul>
<li>

<math display="inline" id="Stochastic_approximation:30">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N(x)
  </annotation>
 </semantics>
</math>

 is uniformly bounded,</li>
<li>

<math display="inline" id="Stochastic_approximation:31">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M(x)
  </annotation>
 </semantics>
</math>

 is nondecreasing,</li>
<li>

<math display="inline" id="Stochastic_approximation:32">
 <semantics>
  <mrow>
   <msup>
    <mi>M</mi>
    <mo>‚Ä≤</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Œ∏</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>M</ci>
     <ci>normal-‚Ä≤</ci>
    </apply>
    <ci>Œ∏</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M^{\prime}(\theta)
  </annotation>
 </semantics>
</math>

 exists and is positive, and</li>
<li>The sequence 

<math display="inline" id="Stochastic_approximation:33">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{n}
  </annotation>
 </semantics>
</math>

 satisfies the following requirements:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Stochastic_approximation:34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msubsup>
       <mo largeop="true" lspace="22.5pt" symmetric="true">‚àë</mo>
       <mrow>
        <mi>n</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mi mathvariant="normal">‚àû</mi>
      </msubsup>
      <msub>
       <mi>a</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi mathvariant="normal">‚àû</mi>
      <mtext>and</mtext>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">‚àë</mo>
       <mrow>
        <mi>n</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mi mathvariant="normal">‚àû</mi>
      </msubsup>
      <msubsup>
       <mi>a</mi>
       <mi>n</mi>
       <mn>2</mn>
      </msubsup>
     </mrow>
     <mo><</mo>
     <mi mathvariant="normal">‚àû</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <sum></sum>
        <infinity></infinity>
       </apply>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <list>
      <infinity></infinity>
      <mtext>and</mtext>
     </list>
    </apply>
    <apply>
     <lt></lt>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <sum></sum>
        <infinity></infinity>
       </apply>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \qquad\sum^{\infty}_{n=0}a_{n}=\infty\quad\mbox{ and }\quad\sum^{\infty}_{n=0}%
a^{2}_{n}<\infty\quad
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>A particular sequence of steps which satisfy these conditions, and was suggested by Robbins‚ÄìMonro, have the form

<math display="block" id="Stochastic_approximation:35">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <divide></divide>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{n}=a/n
  </annotation>
 </semantics>
</math>

, for 

<math display="inline" id="Stochastic_approximation:36">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>a</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a>0
  </annotation>
 </semantics>
</math>

. Other series are possible but in order to average out the noise in 

<math display="inline" id="Stochastic_approximation:37">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N(x)
  </annotation>
 </semantics>
</math>

, the above condition must be met.</p>
<h3 id="complexity-results">Complexity results</h3>
<ol>
<li>If 

<math display="inline" id="Stochastic_approximation:38">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 is twice continuously differentiable, and strongly convex, and the minimizer of 

<math display="inline" id="Stochastic_approximation:39">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 belongs to the interior of 

<math display="inline" id="Stochastic_approximation:40">
 <semantics>
  <mi mathvariant="normal">Œò</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Œò</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta
  </annotation>
 </semantics>
</math>

, then the Robbins-Monro algorithm will achieve the asymptotically optimal convergence rate, with respect to the objective function, being 

<math display="inline" id="Stochastic_approximation:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>ùîº</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <msup>
       <mi>f</mi>
       <mo>*</mo>
      </msup>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ùîº</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}[f(x_{n})-f^{*}]=O(1/n)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Stochastic_approximation:42">
 <semantics>
  <msup>
   <mi>f</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>f</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{*}
  </annotation>
 </semantics>
</math>

 is the minimal value of 

<math display="inline" id="Stochastic_approximation:43">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 over 

<math display="inline" id="Stochastic_approximation:44">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>‚àà</mo>
   <mi mathvariant="normal">Œò</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>normal-Œò</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\Theta
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></li>
<li>Conversely, in the general convex case, where we lack both the assumption of smoothness and strong convexity, Nemirovski and Yudin <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> have shown that the asymptotically optimal convergence rate, with respect to the objective function values, is 

<math display="inline" id="Stochastic_approximation:45">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <msqrt>
      <mi>n</mi>
     </msqrt>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1/\sqrt{n})
  </annotation>
 </semantics>
</math>

. They have also proven that this rate cannot be improved.</li>
</ol>
<h3 id="subsequent-developments">Subsequent developments</h3>

<p>While the Robbins-Monro algorithm is theoretically able to achieve 

<math display="inline" id="Stochastic_approximation:46">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1/n)
  </annotation>
 </semantics>
</math>

 under the assumption of twice continuous differentiability and strong convexity, it can perform quite poorly upon implementation. This is primarily due to the fact that the algorithm is very sensitive to the choice of the step size sequence, and the supposed asymptotically optimal step size policy can be quite harmful in the beginning.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>To overcome this shortfall, Polyak and Juditsky,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> presented a method of accelerating Robbins-Monro through the use of longer steps, and averaging of the iterates. The algorithm would have the following structure:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Stochastic_approximation:47">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>b</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>Œ±</mi>
       <mo>-</mo>
       <mrow>
        <mi>N</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>n</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">¬Ø</mo>
     </mover>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>n</mi>
     </mfrac>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">‚àë</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>Œ±</ci>
       <apply>
        <times></times>
        <ci>N</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-¬Ø</ci>
       <ci>x</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>n</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <sum></sum>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n+1}-x_{n}=b_{n}(\alpha-N(x_{n})),\qquad\bar{x}_{n}=\frac{1}{n}\sum^{n-1}_{%
i=0}x_{i}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>The convergence of 

<math display="inline" id="Stochastic_approximation:48">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">¬Ø</mo>
   </mover>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-¬Ø</ci>
     <ci>x</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{x}_{n}
  </annotation>
 </semantics>
</math>

 to the unique root 

<math display="inline" id="Stochastic_approximation:49">
 <semantics>
  <mi>Œ∏</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ∏</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 relies on the condition that the step sequence 

<math display="inline" id="Stochastic_approximation:50">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>b</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{b_{n}\}
  </annotation>
 </semantics>
</math>

 decreases sufficiently slowly. That is</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Stochastic_approximation:51">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>b</mi>
     <mi>n</mi>
    </msub>
    <mo>‚Üí</mo>
    <mn>0</mn>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mfrac>
     <mrow>
      <msub>
       <mi>b</mi>
       <mi>n</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>b</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <msub>
      <mi>b</mi>
      <mi>n</mi>
     </msub>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <mi>o</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>b</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <ci>normal-‚Üí</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>n</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>o</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{n}\rightarrow 0,\qquad\frac{b_{n}-b_{n+1}}{b_{n}}=o(b_{n})
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Therefore, the sequence 

<math display="inline" id="Stochastic_approximation:52">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <msup>
    <mi>n</mi>
    <mrow>
     <mo>-</mo>
     <mi>Œ±</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <ci>Œ±</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{n}=n^{-\alpha}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Stochastic_approximation:53">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo><</mo>
   <mi>Œ±</mi>
   <mo><</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <ci>Œ±</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<\alpha<1
  </annotation>
 </semantics>
</math>

 satisfies this restriction, but 

<math display="inline" id="Stochastic_approximation:54">
 <semantics>
  <mrow>
   <mi>Œ±</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Œ±</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=1
  </annotation>
 </semantics>
</math>

 does not, hence the longer steps. Under the assumptions outlined in the Robbins-Monro algorithm, the resulting modification will result in the same asymptotically optimal convergence rate 

<math display="inline" id="Stochastic_approximation:55">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1/n)
  </annotation>
 </semantics>
</math>

 yet with a more robust step size policy.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>Prior to this, the idea of using longer steps and averaging the iterates had already been proposed by Nemirovski and Yudin <a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> for the cases of solving the stochastic optimization problem with continuous convex objectives and for convex-concave saddle point problems. These algorithms were observed to attain the nonasymptotic rate 

<math display="inline" id="Stochastic_approximation:56">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <msqrt>
      <mi>n</mi>
     </msqrt>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1/\sqrt{n})
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="kiefer-wolfowitz-algorithm">Kiefer-Wolfowitz algorithm</h2>

<p>The Kiefer-Wolfowitz algorithm,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> was introduced in 1952, and was motivated by the publication of the Robbins-Monro algorithm. However, the algorithm was presented as a method which would stochastically estimate the maximum of a function. Let 

<math display="inline" id="Stochastic_approximation:57">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M(x)
  </annotation>
 </semantics>
</math>

 be a function which has a maximum at the point 

<math display="inline" id="Stochastic_approximation:58">
 <semantics>
  <mi>Œ∏</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ∏</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

. It is assumed that 

<math display="inline" id="Stochastic_approximation:59">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M(x)
  </annotation>
 </semantics>
</math>

 is unknown, however, certain observations 

<math display="inline" id="Stochastic_approximation:60">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N(x)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Stochastic_approximation:61">
 <semantics>
  <mrow>
   <mrow>
    <mi>ùîº</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>N</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>M</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ùîº</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>N</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>M</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}[N(x)]=M(x)
  </annotation>
 </semantics>
</math>

, can be made at any point 

<math display="inline" id="Stochastic_approximation:62">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. The structure of the algorithm follows a gradient-like method, with the iterates being generated as follows:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Stochastic_approximation:63">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo maxsize="210%" minsize="210%">(</mo>
      <mfrac>
       <mrow>
        <mrow>
         <mi>N</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mi>x</mi>
            <mi>n</mi>
           </msub>
           <mo>+</mo>
           <msub>
            <mi>c</mi>
            <mi>n</mi>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>N</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mi>x</mi>
            <mi>n</mi>
           </msub>
           <mo>-</mo>
           <msub>
            <mi>c</mi>
            <mi>n</mi>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <msub>
        <mi>c</mi>
        <mi>n</mi>
       </msub>
      </mfrac>
      <mo maxsize="210%" minsize="210%">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>N</ci>
         <apply>
          <plus></plus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>n</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>c</ci>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>N</ci>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>n</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>c</ci>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n+1}=x_{n}+a_{n}\bigg(\frac{N(x_{n}+c_{n})-N(x_{n}-c_{n})}{c_{n}}\bigg)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where the gradient of 

<math display="inline" id="Stochastic_approximation:64">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M(x)
  </annotation>
 </semantics>
</math>

 is approximated using finite differences. The sequence 

<math display="inline" id="Stochastic_approximation:65">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>c</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{c_{n}\}
  </annotation>
 </semantics>
</math>

 specifies the sequence of finite difference widths used for the gradient approximation, while the sequence 

<math display="inline" id="Stochastic_approximation:66">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>a</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a_{n}\}
  </annotation>
 </semantics>
</math>

 specifies a sequence of positive step sizes taken along that direction. Kiefer and Wolfowitz proved that, if 

<math display="inline" id="Stochastic_approximation:67">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M(x)
  </annotation>
 </semantics>
</math>

 satisfied certain regularity conditions, then 

<math display="inline" id="Stochastic_approximation:68">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}
  </annotation>
 </semantics>
</math>

 will converge to 

<math display="inline" id="Stochastic_approximation:69">
 <semantics>
  <mi>Œ∏</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ∏</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 provided that:</p>
<ul>
<li>The function 

<math display="inline" id="Stochastic_approximation:70">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 has a unique point of maximum (minimum) and is strong concave (convex)
<ul>
<li>The algorithm was first presented with the requirement that the function 

<math display="inline" id="Stochastic_approximation:71">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>‚ãÖ</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>normal-‚ãÖ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\cdot)
  </annotation>
 </semantics>
</math>

 maintains strong global convexity (concavity) over the entire feasible space. Given this condition is too restrictive to impose over the entire domain, Kiefer and Wolfowitz proposed that it is sufficient to impose the condition over a compact set 

<math display="inline" id="Stochastic_approximation:72">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mn>0</mn>
   </msub>
   <mo>‚äÇ</mo>
   <msup>
    <mi>‚Ñù</mi>
    <mi>d</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>‚Ñù</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{0}\subset\mathbb{R}^{d}
  </annotation>
 </semantics>
</math>

 which is known to include the optimal solution.</li>
</ul></li>
<li>The selected sequences 

<math display="inline" id="Stochastic_approximation:73">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>a</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a_{n}\}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Stochastic_approximation:74">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>c</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{c_{n}\}
  </annotation>
 </semantics>
</math>

 must be infinite sequences of positive numbers such that:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Stochastic_approximation:75">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mtext>1.</mtext>
     <msub>
      <mi>c</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>‚Üí</mo>
    <mn>0</mn>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>n</mi>
     </msub>
     <mo>‚Üí</mo>
     <mrow>
      <mn>0</mn>
      <mtext>as</mtext>
     </mrow>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>‚Üí</mo>
     <mi mathvariant="normal">‚àû</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <ci>normal-‚Üí</ci>
     <list>
      <mtext>1.</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>n</ci>
      </apply>
     </list>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <ci>normal-‚Üí</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <list>
       <cn type="integer">0</cn>
       <mtext>as</mtext>
      </list>
     </apply>
     <apply>
      <ci>normal-‚Üí</ci>
      <ci>n</ci>
      <infinity></infinity>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{1. }\quad c_{n}\rightarrow 0,\quad a_{n}\rightarrow 0\quad\mbox{ as }%
\quad n\rightarrow\infty
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Stochastic_approximation:76">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mtext>2.</mtext>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">‚àë</mo>
       <mrow>
        <mi>n</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mi mathvariant="normal">‚àû</mi>
      </msubsup>
      <msub>
       <mi>a</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi mathvariant="normal">‚àû</mi>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi mathvariant="normal">‚àû</mi>
     </msubsup>
     <mfrac>
      <msubsup>
       <mi>a</mi>
       <mi>n</mi>
       <mn>2</mn>
      </msubsup>
      <msubsup>
       <mi>c</mi>
       <mi>n</mi>
       <mn>2</mn>
      </msubsup>
     </mfrac>
    </mrow>
    <mo><</mo>
    <mi mathvariant="normal">‚àû</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <list>
      <mtext>2.</mtext>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <sum></sum>
         <infinity></infinity>
        </apply>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </list>
     <infinity></infinity>
    </apply>
    <apply>
     <lt></lt>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <sum></sum>
        <infinity></infinity>
       </apply>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>a</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>c</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{2. }\quad\sum^{\infty}_{n=0}a_{n}=\infty,\qquad\sum^{\infty}_{n=0}\frac{%
a^{2}_{n}}{c^{2}_{n}}<\infty
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>A suitable choice of sequences, as recommended by Kiefer and Wolfowitz, would be 

<math display="inline" id="Stochastic_approximation:77">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{n}=1/n
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Stochastic_approximation:78">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <msup>
    <mi>n</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>3</mn>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{n}=n^{-1/3}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="subsequent-developments-and-important-issues">Subsequent developments and important issues</h3>
<ol>
<li>The Kiefer Wolfowitz algorithm requires that for each gradient computation, at least 

<math display="inline" id="Stochastic_approximation:79">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>d</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d+1
  </annotation>
 </semantics>
</math>

 different parameter values must be simulated for every iteration of the algorithm, where 

<math display="inline" id="Stochastic_approximation:80">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 is the dimension of the search space. This means that when 

<math display="inline" id="Stochastic_approximation:81">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 is large, the Kiefer-Wolfowitz algorithm will require substantial computational effort per iteration, leading to slow convergence.
<ol>
<li>To address this problem, Spall proposed the use of <a href="Simultaneous_perturbation_stochastic_approximation" title="wikilink">simultaneous perturbations</a> to estimate the gradient. This method would require only two simulations per iteration, regardless of the dimension 

<math display="inline" id="Stochastic_approximation:82">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></li>
</ol></li>
<li>In the conditions required for convergence, the ability to specify a predetermined compact set that fulfills strong convexity (or concavity) and contains the unique solution can be difficult to find. With respect to real world applications, if the domain is quite large, these assumptions can be fairly restrictive and highly unrealistic.</li>
</ol>
<h2 id="further-developments">Further developments</h2>

<p>An extensive theoretical literature has grown up around these algorithms, concerning conditions for convergence, rates of convergence, multivariate and other generalizations, proper choice of step size, possible noise models, and so on.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> These methods are also applied in <a href="control_theory" title="wikilink">control theory</a>, in which case the unknown function which we wish to optimize or find the zero of may vary in time. In this case, the step size 

<math display="inline" id="Stochastic_approximation:83">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{n}
  </annotation>
 </semantics>
</math>

 should not converge to zero but should be chosen so as to track the function.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><sup>, 2nd ed., chapter 3</sup></p>

<p><a href="C._Johan_Masreliez" title="wikilink">C. Johan Masreliez</a> and <a href="R._Douglas_Martin" title="wikilink">R. Douglas Martin</a> were the first to apply stochastic approximation to <a href="Robust_statistics" title="wikilink">robust</a> <a class="uri" href="estimation" title="wikilink">estimation</a>.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>The main tool for analyzing stochastic approximations algorithms (including the Robbins-Monro and the Kiefer-Wolfowitz algorithms) is the theorem by <a href="Aryeh_Dvoretzky" title="wikilink">Aryeh Dvoretzky</a> published in the proceedings of the third Berkeley symposium on mathematical statistics and probability, 1956.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Stochastic_gradient_descent" title="wikilink">Stochastic gradient descent</a></li>
<li><a href="Stochastic_optimization" title="wikilink">Stochastic optimization</a></li>
<li><a href="Simultaneous_perturbation_stochastic_approximation" title="wikilink">Simultaneous perturbation stochastic approximation</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Stochastic_optimization" title="wikilink">Category:Stochastic optimization</a> <a href="Category:Statistical_approximations" title="wikilink">Category:Statistical approximations</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">‚Ü©</a></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">‚Ü©</a></li>
<li id="fn4"><a href="#fnref4">‚Ü©</a></li>
<li id="fn5">Problem Complexity and Method Efficiency in Optimization, A. Nemirovski and D. Yudin, <em>Wiley -Intersci. Ser. Discrete Math</em> <strong>15</strong> <em>John Wiley</em> <em>New York</em> (1983) .<a href="#fnref5">‚Ü©</a></li>
<li id="fn6"></li>
<li id="fn7">Introduction to Stochastic Search and Optimization: Estimation, Simulation and Control, J.C. Spall, <em>John Wiley</em> <em>Hoboken, NJ</em>, (2003).<a href="#fnref7">‚Ü©</a></li>
<li id="fn8"><a href="#fnref8">‚Ü©</a></li>
<li id="fn9"></li>
<li id="fn10">On Cezari's convergence of the steepest descent method for approximating saddle points of convex-concave functions, A. Nemirovski and D. Yudin, <em>Dokl. Akad. Nauk SSR</em> <strong>2939</strong>, (1978 (Russian)), Soviet Math. Dokl. <strong>19</strong> (1978 (English)).<a href="#fnref10">‚Ü©</a></li>
<li id="fn11"><a href="#fnref11">‚Ü©</a></li>
<li id="fn12"><a href="#fnref12">‚Ü©</a></li>
<li id="fn13"><a href="#fnref13">‚Ü©</a></li>
<li id="fn14"><em>Stochastic Approximation and Recursive Estimation</em>, Mikhail Borisovich Nevel'son and Rafail Zalmanovich Has'minskiƒ≠, translated by Israel Program for Scientific Translations and B. Silver, Providence, RI: American Mathematical Society, 1973, 1976. ISBN 0-8218-1597-0.<a href="#fnref14">‚Ü©</a></li>
<li id="fn15"></li>
<li id="fn16"><a href="#fnref16">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
