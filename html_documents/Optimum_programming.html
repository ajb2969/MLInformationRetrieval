<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1418">Optimum programming</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Optimum programming</h1>
<hr/>

<p>In the history of computing, <strong>optimum programming</strong> is the practice of arranging a computer program's instructions in memory so as to minimize the time the machine spends waiting for instructions. It is of historical interest mainly due to the design of many early digital computers.</p>

<p>Most early computers used some form of serial memory (primarily <a href="delay_line_memory" title="wikilink">delay line memory</a>). Unlike the <a href="random_access_memory" title="wikilink">random access memory</a> of modern computers, words in serial memory are made available one at a time; the time required to access a particular word depends on the "distance" between it and the word currently being read. If a given line held <em>n</em> words, the average time to read a word would be 

<math display="inline" id="Optimum_programming:0">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n/2
  </annotation>
 </semantics>
</math>

 word times. Without optimum coding, such a machine would spend most of its time idly waiting for instructions and data.</p>

<p>To circumvent this problem, many machines, particularly the <a href="ACE_(computer)" title="wikilink">ACE</a> and its descendants, included in their instruction format a field specifying the address of the next instruction to be executed. Employing optimum coding, the programmer could locate an instruction such that it would be available in memory just as the preceding instruction had finished. For example, if a programmer had just coded an <strong>ADD</strong> instruction at address 400, and the <strong>ADD</strong> instruction required 4 word-times to execute, the programmer would set the "Next Address" field of the instruction to 404, and would place the next instruction there.</p>

<p>In the United States, optimum coding was most commonly employed on the <a href="IBM_650" title="wikilink">IBM 650</a> and the <a href="Bendix_G-15" title="wikilink">Bendix G-15</a>. Both machines had optimizing assemblers (SOAP for the IBM, POGO for Bendix) that could automate this task.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Mel_Kaye" title="wikilink">Mel Kaye</a>, who authored one particularity clever bit of optimum programming that has entered computer lore.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.bitsavers.org/pdf/ibm/650/32-7646-1_SOAPII.pdf">SOAP Manual</a></li>
</ul>

<p>"</p>

<p><a href="Category:Software_optimization" title="wikilink">Category:Software optimization</a></p>
</body>
</html>
