<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1747">PSPACE-complete</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>PSPACE-complete</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, a <a href="decision_problem" title="wikilink">decision problem</a> is <strong>PSPACE-complete</strong> if it can be solved using an amount of memory that is polynomial in the input length (<a href="PSPACE" title="wikilink">polynomial space</a>) and if every other problem that can be solved in polynomial space can be <a href="polynomial-time_many-one_reduction" title="wikilink">transformed to it in polynomial time</a>. The problems that are PSPACE-complete can be thought of as the hardest problems in <strong><a class="uri" href="PSPACE" title="wikilink">PSPACE</a></strong>, because a solution to any one such problem could easily be used to solve any other problem in <strong>PSPACE</strong>.</p>

<p>The PSPACE-complete problems are widely suspected to be outside of the more famous complexity classes <strong><a href="P_(complexity)" title="wikilink">P</a></strong> and <strong><a href="NP_(complexity)" title="wikilink">NP</a></strong>, but that is not known. It is known that they lie outside of the class <strong><a href="NC_(complexity)" title="wikilink">NC</a></strong> (a class of problems with highly efficient parallel algorithms), because problems in <strong>NC</strong> can be solved in an amount of space polynomial in the <a class="uri" href="logarithm" title="wikilink">logarithm</a> of the input size, and the class of problems solvable in such a small amount of space is strictly contained in <strong>PSPACE</strong> by the <a href="space_hierarchy_theorem" title="wikilink">space hierarchy theorem</a>.</p>
<h2 id="examples">Examples</h2>

<p>Below are descriptions of a few PSPACE-complete problems. More examples can be found at the <a href="list_of_PSPACE-complete_problems" title="wikilink">list of PSPACE-complete problems</a>.</p>
<h3 id="regular-expressions">Regular expressions</h3>

<p>Given a <a href="regular_expression" title="wikilink">regular expression</a> <em>R</em>, determining whether it generates every string over its alphabet is PSPACE-complete.</p>
<h3 id="context-sensitive-grammars">Context-sensitive grammars</h3>

<p>The first known <strong>PSPACE</strong>-complete problem was the <a href="word_problem_(computability)" title="wikilink">word problem</a> for <a href="deterministic_computation" title="wikilink">deterministic</a> <a href="context-sensitive_grammar" title="wikilink">context-sensitive grammars</a>. In the word problem for context-sensitive grammars, one is given a set of grammatical transformations which can increase, but cannot decrease, the length of a sentence, and wishes to determine if a given sentence could be produced by these transformations. The technical condition of "determinism" (implying roughly that each transformation makes it obvious that it was used) ensures that this process can be solved in polynomial space, and  showed that every (possibly non-deterministic) program computable in <a href="linear_space" title="wikilink">linear space</a> could be converted into the parsing of a context-sensitive grammar, in a way which preserves determinism. In 1970, <a href="Savitch's_theorem" title="wikilink">Savitch's theorem</a> showed that PSPACE is closed under nondeterminism, implying that even non-deterministic context-sensitive grammars are in PSPACE.</p>
<h3 id="quantified-boolean-formulas">Quantified Boolean formulas</h3>

<p>Nowadays, the archetypal PSPACE-complete problem is generally taken to be the <a href="quantified_Boolean_formula_problem" title="wikilink">quantified Boolean formula problem</a> (usually abbreviated to QBF or TQBF; the T stands for "true"), a generalization of the first known <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problem, the <a href="Boolean_satisfiability_problem" title="wikilink">Boolean satisfiability problem</a> (SAT). The satisfiability problem is the problem of whether there are assignments of <a href="truth_value" title="wikilink">truth values</a> to variables that make a Boolean expression true. For example, one instance of SAT would be the question of whether the following is true:</p>

<p>

<math display="block" id="PSPACE-complete:0">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
     </mpadded>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <mpadded width="+1.7pt">
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
       </mpadded>
       <mrow>
        <mo>∃</mo>
        <mrow>
         <mpadded width="+1.7pt">
          <msub>
           <mi>x</mi>
           <mn>3</mn>
          </msub>
         </mpadded>
         <mrow>
          <mo>∃</mo>
          <msub>
           <mi>x</mi>
           <mn>4</mn>
          </msub>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">¬</mi>
      <msub>
       <mi>x</mi>
       <mn>3</mn>
      </msub>
      <msub>
       <mi>x</mi>
       <mn>4</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <msub>
       <mi>x</mi>
       <mn>3</mn>
      </msub>
      <mi mathvariant="normal">¬</mi>
      <msub>
       <mi>x</mi>
       <mn>4</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <exists></exists>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <exists></exists>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <cn type="integer">3</cn>
          </apply>
          <apply>
           <exists></exists>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <cn type="integer">4</cn>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <not></not>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">4</cn>
      </apply>
     </apply>
     <ci>italic- and</ci>
     <apply>
      <times></times>
      <not></not>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <not></not>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">4</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x_{1}\,\exists x_{2}\,\exists x_{3}\,\exists x_{4}:(x_{1}\neg x_{3}x_{%
4})\and(\neg x_{2}x_{3}\neg x_{4})
  </annotation>
 </semantics>
</math>

</p>

<p>The quantified Boolean formula problem differs in allowing both universal and existential quantification over the values of the variables:</p>

<p>

<math display="block" id="PSPACE-complete:1">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
     </mpadded>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <mpadded width="+1.7pt">
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
       </mpadded>
       <mrow>
        <mo>∃</mo>
        <mrow>
         <mpadded width="+1.7pt">
          <msub>
           <mi>x</mi>
           <mn>3</mn>
          </msub>
         </mpadded>
         <mrow>
          <mo>∀</mo>
          <msub>
           <mi>x</mi>
           <mn>4</mn>
          </msub>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">¬</mi>
      <msub>
       <mi>x</mi>
       <mn>3</mn>
      </msub>
      <msub>
       <mi>x</mi>
       <mn>4</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <msub>
       <mi>x</mi>
       <mn>3</mn>
      </msub>
      <mi mathvariant="normal">¬</mi>
      <msub>
       <mi>x</mi>
       <mn>4</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <exists></exists>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <cn type="integer">3</cn>
          </apply>
          <apply>
           <csymbol cd="latexml">for-all</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <cn type="integer">4</cn>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <not></not>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">4</cn>
      </apply>
     </apply>
     <ci>italic- and</ci>
     <apply>
      <times></times>
      <not></not>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <not></not>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">4</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x_{1}\,\forall x_{2}\,\exists x_{3}\,\forall x_{4}:(x_{1}\neg x_{3}x_{%
4})\and(\neg x_{2}x_{3}\neg x_{4})
  </annotation>
 </semantics>
</math>

. The proof that QBF is a PSPACE-complete problem is essentially a restatement of the proof of <a href="Savitch's_theorem" title="wikilink">Savitch's theorem</a> in the language of logic, and is a bit more technical.</p>
<h3 id="puzzles-and-games">Puzzles and games</h3>

<p>The NP-complete problem In the previous section resembles typical puzzles: is there some way to plug in values that solves the problem? Correspondingly, the PSPACE-complete problem there resembles games: is there <em>some</em> move I can make, such that for <em>all</em> moves my opponent might make, there will then be <em>some</em> move I can make to win? The question alternates existential and universal quantifiers. Not surprisingly, many puzzles turn out to be NP-complete, and many games turn out to be PSPACE-complete.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Examples of games that are PSPACE-complete (when <a href="generalized_game" title="wikilink">generalized</a> so that they can be played on an <em>n</em> × <em>n</em> board) are the games <a href="Hex_(board_game)" title="wikilink">Hex</a> and <a class="uri" href="Reversi" title="wikilink">Reversi</a> and the solitaire games <a href="Rush_Hour_(board_game)" title="wikilink">Rush Hour</a>, <a href="Mahjong_solitaire" title="wikilink">Mahjong</a>, <a href="Atomix_(computer_game)" title="wikilink">Atomix</a>, and <a class="uri" href="Sokoban" title="wikilink">Sokoban</a>. Some other generalized games, such as <a class="uri" href="chess" title="wikilink">chess</a>, <a href="English_draughts" title="wikilink">checkers</a> (draughts), and <a href="Go_(board_game)" title="wikilink">Go</a> are <a class="uri" href="EXPTIME-complete" title="wikilink">EXPTIME-complete</a> because a game between two perfect players can be very long, so they are unlikely to be in PSPACE. But they will become <strong>PSPACE</strong>-complete if a polynomial bound on the number of moves is enforced.</p>

<p>Note that the definition of PSPACE-completeness is based on <em>asymptotic</em> complexity: the time it takes to solve a problem of size <em>n</em>, in the limit as <em>n</em> grows without bound. That means a game like checkers (which is played on an 8 × 8 board) could never be PSPACE-complete (in fact, they can be solved in constant time and space using a very large <a href="lookup_table" title="wikilink">lookup table</a>). That is why all the games were modified by playing them on an <em>n</em> × <em>n</em> board instead; in some cases, such as for Chess, these extensions are somewhat artificial and subjective.</p>

<p>See <a href="Game_complexity" title="wikilink">Game complexity</a> for more games whose completeness for PSPACE or other complexity classes has been determined.</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Complexity_classes" title="wikilink">Category:Complexity classes</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
