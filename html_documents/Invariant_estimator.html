<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="377">Invariant estimator</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Invariant estimator</h1>
<hr/>

<p>In <a class="uri" href="statistics" title="wikilink">statistics</a>, the concept of being an <strong>invariant estimator</strong> is a criterion that can be used to compare the properties of different <a href="estimator" title="wikilink">estimators</a> for the same quantity. It is a way of formalising the idea that an estimator should have certain intuitively appealing qualities. Strictly speaking, "invariant" would mean that the estimates themselves are unchanged when both the measurements and the parameters are transformed in a compatible way, but the meaning has been extended to allow the estimates to change in appropriate ways with such transformations.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The term <strong>equivariant estimator</strong> is used in formal mathematical contexts that include a precise description of the relation of the way the estimator changes in response to changes to the dataset and parameterisation: this corresponds to the use of "<a href="Equivariant_map" title="wikilink">equivariance</a>" in more general mathematics.</p>
<h2 id="general-setting">General setting</h2>
<h3 id="background">Background</h3>

<p>In <a href="statistical_inference" title="wikilink">statistical inference</a>, there are several approaches to <a href="estimation_theory" title="wikilink">estimation theory</a> that can be used to decide immediately what estimators should be used according to those approaches. For example, ideas from <a href="Bayesian_inference" title="wikilink">Bayesian inference</a> would lead directly to <a href="Bayesian_estimator" title="wikilink">Bayesian estimators</a>. Similarly, the theory of classical statistical inference can sometimes lead to strong conclusions about what estimator should be used. However, the usefulness of these theories depends on having a fully prescribed <a href="statistical_model" title="wikilink">statistical model</a> and may also depend on having a relevant loss function to determine the estimator. Thus a <a href="Bayesian_inference" title="wikilink">Bayesian analysis</a> might be undertaken, leading to a posterior distribution for relevant parameters, but the use of a specific utility or loss function may be unclear. Ideas of invariance can then be applied to the task of summarising the posterior distribution. In other cases, statistical analyses are undertaken without a fully defined statistical model or the classical theory of statistical inference cannot be readily applied because the family of models being considered are not amenable to such treatment. In addition to these cases where general theory does not prescribe an estimator, the concept of invariance of an estimator can be applied when seeking estimators of alternative forms, either for the sake of simplicity of application of the estimator or so that the estimator is <a href="Robust_statistics" title="wikilink">robust</a>.</p>

<p>The concept of invariance is sometimes used on its own as a way of choosing between estimators, but this is not necessarily definitive. For example, a requirement of invariance may be incompatible with the requirement that the <a href="Bias_of_an_estimator" title="wikilink">estimator be mean-unbiased</a>; on the other hand, the criterion of <a href="Median#Median-unbiased_estimators" title="wikilink">median-unbiasedness</a> is defined in terms of the estimator's sampling distribution and so is invariant under many transformations.</p>

<p>One use of the concept of invariance is where a class or family of estimators is proposed and a particular formulation must be selected amongst these. One procedure is to impose relevant invariance properties and then to find the formulation within this class that has the best properties, leading to what is called the optimal invariant estimator.</p>
<h3 id="some-classes-of-invariant-estimators">Some classes of invariant estimators</h3>

<p>There are several types of transformations that are usefully considered when dealing with invariant estimators. Each gives rise to a class of estimators which are invariant to those particular types of transformation.</p>
<ul>
<li>Shift invariance: Notionally, estimates of a <a href="location_parameter" title="wikilink">location parameter</a> should be invariant to simple shifts of the data values. If all data values are increased by a given amount, the estimate should change by the same amount. When considering estimation using a <a href="weighted_average" title="wikilink">weighted average</a>, this invariance requirement immediately implies that the weights should sum to one. While the same result is often derived from a requirement for unbiasedness, the use of "invariance" does not require that a mean value exists and makes no use of any probability distribution at all.</li>
<li>Scale invariance: Note that this topic about the invariance of the estimator scale parameter not to be confused with the more general <a href="scale_invariance" title="wikilink">scale invariance</a> about the behavior of systems under aggregate properties (in physics).</li>
<li>Parameter-transformation invariance: Here, the transformation applies to the parameters alone. The concept here is that essentially the same inference should be made from data and a model involving a parameter θ as would be made from the same data if the model used a parameter φ, where φ is a one-to-one transformation of θ, φ=<em>h</em>(θ). According to this type of invariance, results from transformation-invariant estimators should also be related by φ=<em>h</em>(θ). <a href="Maximum_likelihood_estimator" title="wikilink">Maximum likelihood estimators</a> have this property. Though the asymptotic properties of the estimator might be invariant, the small sample properties can be different, and a specific distribution needs to be derived.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></li>
<li>Permutation invariance: Where a set of data values can be represented by a statistical model that they are outcomes from <a href="independent_and_identically_distributed" title="wikilink">independent and identically distributed</a> <a href="random_variables" title="wikilink">random variables</a>, it is reasonable to impose the requirement that any estimator of any property of the common distribution should be permutation-invariant: specifically that the estimator, considered as a function of the set of data-values, should not change if items of data are swapped within the dataset.</li>
</ul>

<p>The combination of permutation invariance and location invariance for estimating a location parameter from an <a href="independent_and_identically_distributed" title="wikilink">independent and identically distributed</a> dataset using a weighted average implies that the weights should be identical and sum to one. Of course, estimators other than a weighted average may be preferable.</p>
<h3 id="optimal-invariant-estimators">Optimal invariant estimators</h3>

<p>Under this setting, we are given a set of measurements 

<math display="inline" id="Invariant_estimator:0">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 which contains information about an unknown parameter 

<math display="inline" id="Invariant_estimator:1">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

. The measurements 

<math display="inline" id="Invariant_estimator:2">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 are modelled as a <a href="random_vector" title="wikilink">vector random variable</a> having a <a href="probability_density_function" title="wikilink">probability density function</a> 

<math display="inline" id="Invariant_estimator:3">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x|\theta)
  </annotation>
 </semantics>
</math>

 which depends on a parameter vector 

<math display="inline" id="Invariant_estimator:4">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

.</p>

<p>The problem is to estimate 

<math display="inline" id="Invariant_estimator:5">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 given 

<math display="inline" id="Invariant_estimator:6">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. The estimate, denoted by 

<math display="inline" id="Invariant_estimator:7">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, is a function of the measurements and belongs to a set 

<math display="inline" id="Invariant_estimator:8">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. The quality of the result is defined by a <a href="loss_function" title="wikilink">loss function</a> 

<math display="inline" id="Invariant_estimator:9">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <apply>
     <times></times>
     <ci>L</ci>
     <interval closure="open">
      <ci>a</ci>
      <ci>θ</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=L(a,\theta)
  </annotation>
 </semantics>
</math>

 which determines a <a href="risk_function" title="wikilink">risk function</a> 

<math display="inline" id="Invariant_estimator:10">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mi>θ</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <eq></eq>
    <csymbol cd="unknown">R</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">E</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">L</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">θ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-|</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=R(a,\theta)=E[L(a,\theta)|\theta]
  </annotation>
 </semantics>
</math>

. The sets of possible values of 

<math display="inline" id="Invariant_estimator:11">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Invariant_estimator:12">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Invariant_estimator:13">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 are denoted by 

<math display="inline" id="Invariant_estimator:14">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Invariant_estimator:15">
 <semantics>
  <mi mathvariant="normal">Θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Invariant_estimator:16">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, respectively.</p>
<h3 id="in-classification">In classification</h3>

<p>In <a href="statistical_classification" title="wikilink">statistical classification</a>, the rule which assigns a class to a new data-item can be consider to be a special type of estimator. A number of invariance-type considerations can be brought to bear in formulating <a href="prior_knowledge_for_pattern_recognition" title="wikilink">prior knowledge for pattern recognition</a>.</p>
<h2 id="mathematical-setting">Mathematical setting</h2>
<h3 id="definition">Definition</h3>

<p>An invariant estimator is an estimator which obeys the following two rules:</p>
<ol>
<li>Principle of Rational Invariance: The action taken in a decision problem should not depend on transformation on the measurement used</li>
<li>Invariance Principle: If two decision problems have the same formal structure (in terms of 

<math display="inline" id="Invariant_estimator:17">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Invariant_estimator:18">
 <semantics>
  <mi mathvariant="normal">Θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Invariant_estimator:19">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x|\theta)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Invariant_estimator:20">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

), then the same decision rule should be used in each problem.</li>
</ol>

<p>To define an invariant or equivariant estimator formally, some definitions related to groups of transformations are needed first. Let 

<math display="inline" id="Invariant_estimator:21">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 denote the set of possible data-samples. A <a href="group_of_transformation" title="wikilink">group of transformations</a> of 

<math display="inline" id="Invariant_estimator:22">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

, to be denoted by 

<math display="inline" id="Invariant_estimator:23">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, is a set of (measurable) 1:1 and onto transformations of 

<math display="inline" id="Invariant_estimator:24">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 into itself, which satisfies the following conditions:</p>
<ol>
<li>If 

<math display="inline" id="Invariant_estimator:25">
 <semantics>
  <mrow>
   <msub>
    <mi>g</mi>
    <mn>1</mn>
   </msub>
   <mo>∈</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{1}\in G
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Invariant_estimator:26">
 <semantics>
  <mrow>
   <msub>
    <mi>g</mi>
    <mn>2</mn>
   </msub>
   <mo>∈</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{2}\in G
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Invariant_estimator:27">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>g</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>g</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>∈</mo>
   <mpadded width="+1.7pt">
    <mi>G</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{1}g_{2}\in G\,
  </annotation>
 </semantics>
</math>

</li>
<li>If 

<math display="inline" id="Invariant_estimator:28">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∈</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>g</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\in G
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Invariant_estimator:29">
 <semantics>
  <mrow>
   <msup>
    <mi>g</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>∈</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>g</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g^{-1}\in G
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Invariant_estimator:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>g</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mpadded width="+1.7pt">
     <mi>x</mi>
    </mpadded>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g^{-1}(g(x))=x\,.
  </annotation>
 </semantics>
</math>

 (That is, each transformation has an inverse within the group.)</li>
<li>

<math display="inline" id="Invariant_estimator:31">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>∈</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>e</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e\in G
  </annotation>
 </semantics>
</math>

 (i.e. there is an identity transformation 

<math display="inline" id="Invariant_estimator:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mi>x</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(x)=x\,
  </annotation>
 </semantics>
</math>

)</li>
</ol>

<p>Datasets 

<math display="inline" id="Invariant_estimator:33">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Invariant_estimator:34">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Invariant_estimator:35">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 are equivalent if 

<math display="inline" id="Invariant_estimator:36">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=g(x_{2})
  </annotation>
 </semantics>
</math>

 for some 

<math display="inline" id="Invariant_estimator:37">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∈</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>g</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\in G
  </annotation>
 </semantics>
</math>

. All the equivalent points form an <a href="equivalence_class" title="wikilink">equivalence class</a>. Such an equivalence class is called an <a href="orbit_(group_theory)" title="wikilink">orbit</a> (in 

<math display="inline" id="Invariant_estimator:38">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

). The 

<math display="inline" id="Invariant_estimator:39">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

 orbit, 

<math display="inline" id="Invariant_estimator:40">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(x_{0})
  </annotation>
 </semantics>
</math>

, is the set 

<math display="inline" id="Invariant_estimator:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mi>g</mi>
     <mo>∈</mo>
     <mi>G</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>X</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <ci>g</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <in></in>
      <ci>g</ci>
      <ci>G</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(x_{0})=\{g(x_{0}):g\in G\}
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Invariant_estimator:42">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 consists of a single orbit then 

<math display="inline" id="Invariant_estimator:43">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is said to be transitive.</p>

<p>A family of densities 

<math display="inline" id="Invariant_estimator:44">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is said to be invariant under the group 

<math display="inline" id="Invariant_estimator:45">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 if, for every 

<math display="inline" id="Invariant_estimator:46">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∈</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>g</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\in G
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Invariant_estimator:47">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Θ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>θ</ci>
    <ci>normal-Θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta\in\Theta
  </annotation>
 </semantics>
</math>

 there exists a unique 

<math display="inline" id="Invariant_estimator:48">
 <semantics>
  <mrow>
   <msup>
    <mi>θ</mi>
    <mo>*</mo>
   </msup>
   <mo>∈</mo>
   <mi mathvariant="normal">Θ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>θ</ci>
     <times></times>
    </apply>
    <ci>normal-Θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta^{*}\in\Theta
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Invariant_estimator:49">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Y</ci>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=g(x)
  </annotation>
 </semantics>
</math>

 has density 

<math display="inline" id="Invariant_estimator:50">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>θ</mi>
     <mo>*</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>θ</ci>
      <times></times>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(y|\theta^{*})
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Invariant_estimator:51">
 <semantics>
  <msup>
   <mi>θ</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>θ</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta^{*}
  </annotation>
 </semantics>
</math>

 will be denoted 

<math display="inline" id="Invariant_estimator:52">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>g</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-¯</ci>
     <ci>g</ci>
    </apply>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{g}(\theta)
  </annotation>
 </semantics>
</math>

.</p>

<p>If 

<math display="inline" id="Invariant_estimator:53">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is invariant under the group 

<math display="inline" id="Invariant_estimator:54">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 then the loss function 

<math display="inline" id="Invariant_estimator:55">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <interval closure="open">
     <ci>θ</ci>
     <ci>a</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(\theta,a)
  </annotation>
 </semantics>
</math>

 is said to be invariant under 

<math display="inline" id="Invariant_estimator:56">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 if for every 

<math display="inline" id="Invariant_estimator:57">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∈</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>g</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\in G
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Invariant_estimator:58">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∈</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in A
  </annotation>
 </semantics>
</math>

 there exists an 

<math display="inline" id="Invariant_estimator:59">
 <semantics>
  <mrow>
   <msup>
    <mi>a</mi>
    <mo>*</mo>
   </msup>
   <mo>∈</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <times></times>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{*}\in A
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Invariant_estimator:60">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>θ</mi>
     <mo>,</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mover accent="true">
       <mi>g</mi>
       <mo stretchy="false">¯</mo>
      </mover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>θ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <msup>
      <mi>a</mi>
      <mo>*</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <interval closure="open">
      <ci>θ</ci>
      <ci>a</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>L</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <apply>
        <ci>normal-¯</ci>
        <ci>g</ci>
       </apply>
       <ci>θ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <times></times>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(\theta,a)=L(\bar{g}(\theta),a^{*})
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Invariant_estimator:61">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Θ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>θ</ci>
    <ci>normal-Θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta\in\Theta
  </annotation>
 </semantics>
</math>

. The transformed value 

<math display="inline" id="Invariant_estimator:62">
 <semantics>
  <msup>
   <mi>a</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>a</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{*}
  </annotation>
 </semantics>
</math>

 will be denoted by 

<math display="inline" id="Invariant_estimator:63">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>g</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-~</ci>
     <ci>g</ci>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{g}(a)
  </annotation>
 </semantics>
</math>

.</p>

<p>In the above, 

<math display="inline" id="Invariant_estimator:64">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>G</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">¯</mo>
    </mover>
    <mo>:</mo>
    <mrow>
     <mi>g</mi>
     <mo>∈</mo>
     <mi>G</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¯</ci>
     <ci>G</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <ci>g</ci>
     </apply>
     <apply>
      <in></in>
      <ci>g</ci>
      <ci>G</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{G}=\{\bar{g}:g\in G\}
  </annotation>
 </semantics>
</math>

 is a group of transformations from 

<math display="inline" id="Invariant_estimator:65">
 <semantics>
  <mi mathvariant="normal">Θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta
  </annotation>
 </semantics>
</math>

 to itself and 

<math display="inline" id="Invariant_estimator:66">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>G</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>:</mo>
    <mrow>
     <mi>g</mi>
     <mo>∈</mo>
     <mi>G</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-~</ci>
     <ci>G</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>g</ci>
     </apply>
     <apply>
      <in></in>
      <ci>g</ci>
      <ci>G</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{G}=\{\tilde{g}:g\in G\}
  </annotation>
 </semantics>
</math>

 is a group of transformations from 

<math display="inline" id="Invariant_estimator:67">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 to itself.</p>

<p>An estimation problem is invariant(equivariant) under 

<math display="inline" id="Invariant_estimator:68">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 if there exist three groups 

<math display="inline" id="Invariant_estimator:69">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>,</mo>
   <mover accent="true">
    <mi>G</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mo>,</mo>
   <mover accent="true">
    <mi>G</mi>
    <mo stretchy="false">~</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>G</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>G</ci>
    </apply>
    <apply>
     <ci>normal-~</ci>
     <ci>G</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G,\bar{G},\tilde{G}
  </annotation>
 </semantics>
</math>

 as defined above.</p>

<p>For an estimation problem that is invariant under 

<math display="inline" id="Invariant_estimator:70">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, estimator 

<math display="inline" id="Invariant_estimator:71">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>δ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(x)
  </annotation>
 </semantics>
</math>

 is an invariant estimator under 

<math display="inline" id="Invariant_estimator:72">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 if, for all 

<math display="inline" id="Invariant_estimator:73">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Invariant_estimator:74">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∈</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>g</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\in G
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Invariant_estimator:75">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mover accent="true">
      <mi>g</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>δ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>δ</ci>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-~</ci>
      <ci>g</ci>
     </apply>
     <apply>
      <times></times>
      <ci>δ</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(g(x))=\tilde{g}(\delta(x)).
  </annotation>
 </semantics>
</math>

</p>
<h3 id="properties">Properties</h3>
<ol>
<li>The risk function of an invariant estimator, 

<math display="inline" id="Invariant_estimator:76">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

, is constant on orbits of 

<math display="inline" id="Invariant_estimator:77">
 <semantics>
  <mi mathvariant="normal">Θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta
  </annotation>
 </semantics>
</math>

. Equivalently 

<math display="inline" id="Invariant_estimator:78">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>θ</mi>
     <mo>,</mo>
     <mi>δ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mover accent="true">
       <mi>g</mi>
       <mo stretchy="false">¯</mo>
      </mover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>θ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>δ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <interval closure="open">
      <ci>θ</ci>
      <ci>δ</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>R</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <apply>
        <ci>normal-¯</ci>
        <ci>g</ci>
       </apply>
       <ci>θ</ci>
      </apply>
      <ci>δ</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(\theta,\delta)=R(\bar{g}(\theta),\delta)
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Invariant_estimator:79">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mo>∈</mo>
   <mi mathvariant="normal">Θ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>θ</ci>
    <ci>normal-Θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta\in\Theta
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Invariant_estimator:80">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>g</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mo>∈</mo>
   <mover accent="true">
    <mi>G</mi>
    <mo stretchy="false">¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <ci>normal-¯</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{g}\in\bar{G}
  </annotation>
 </semantics>
</math>

.</li>
<li>The risk function of an invariant estimator with transitive 

<math display="inline" id="Invariant_estimator:81">
 <semantics>
  <mover accent="true">
   <mi>g</mi>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{g}
  </annotation>
 </semantics>
</math>

 is constant.</li>
</ol>

<p>For a given problem, the invariant estimator with the lowest risk is termed the "best invariant estimator". Best invariant estimator cannot always be achieved. A special case for which it can be achieved is the case when 

<math display="inline" id="Invariant_estimator:82">
 <semantics>
  <mover accent="true">
   <mi>g</mi>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{g}
  </annotation>
 </semantics>
</math>

 is transitive.</p>
<h3 id="example-location-parameter">Example: Location parameter</h3>

<p>Suppose 

<math display="inline" id="Invariant_estimator:83">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 is a location parameter if the density of 

<math display="inline" id="Invariant_estimator:84">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is of the form 

<math display="inline" id="Invariant_estimator:85">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <mi>θ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <minus></minus>
     <ci>x</ci>
     <ci>θ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x-\theta)
  </annotation>
 </semantics>
</math>

. For 

<math display="inline" id="Invariant_estimator:86">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mo>=</mo>
   <mi>A</mi>
   <mo>=</mo>
   <msup>
    <mi>ℝ</mi>
    <mn>1</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>normal-Θ</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta=A=\mathbb{R}^{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Invariant_estimator:87">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mo>-</mo>
      <mi>θ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <apply>
     <times></times>
     <ci>L</ci>
     <apply>
      <minus></minus>
      <ci>a</ci>
      <ci>θ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=L(a-\theta)
  </annotation>
 </semantics>
</math>

, the problem is invariant under 

<math display="inline" id="Invariant_estimator:88">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>=</mo>
   <mover accent="true">
    <mi>g</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mo>=</mo>
   <mover accent="true">
    <mi>g</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>g</mi>
     <mi>c</mi>
    </msub>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mi>g</mi>
        <mi>c</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
       <mi>x</mi>
       <mo>+</mo>
       <mi>c</mi>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>c</mi>
      <mo>∈</mo>
      <mi>ℝ</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>g</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>g</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-~</ci>
      <ci>g</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>c</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>g</ci>
          <ci>c</ci>
         </apply>
         <ci>x</ci>
        </apply>
        <apply>
         <plus></plus>
         <ci>x</ci>
         <ci>c</ci>
        </apply>
       </apply>
       <apply>
        <in></in>
        <ci>c</ci>
        <ci>ℝ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g=\bar{g}=\tilde{g}=\{g_{c}:g_{c}(x)=x+c,c\in\mathbb{R}\}
  </annotation>
 </semantics>
</math>

. The invariant estimator in this case must satisfy</p>

<p>

<math display="block" id="Invariant_estimator:89">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>δ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>+</mo>
        <mi>c</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mi>δ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mi>c</mi>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mtext>for all</mtext>
      <mi>c</mi>
     </mrow>
     <mo>∈</mo>
     <mi>ℝ</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>δ</ci>
      <apply>
       <plus></plus>
       <ci>x</ci>
       <ci>c</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>δ</ci>
       <ci>x</ci>
      </apply>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <mtext>for all</mtext>
      <ci>c</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(x+c)=\delta(x)+c,\text{ for all }c\in\mathbb{R},
  </annotation>
 </semantics>
</math>

 thus it is of the form 

<math display="inline" id="Invariant_estimator:90">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mi>K</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>δ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <ci>K</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(x)=x+K
  </annotation>
 </semantics>
</math>

 (

<math display="inline" id="Invariant_estimator:91">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>∈</mo>
   <mi>ℝ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>K</ci>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\in\mathbb{R}
  </annotation>
 </semantics>
</math>

). 

<math display="inline" id="Invariant_estimator:92">
 <semantics>
  <mover accent="true">
   <mi>g</mi>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{g}
  </annotation>
 </semantics>
</math>

 is transitive on 

<math display="inline" id="Invariant_estimator:93">
 <semantics>
  <mi mathvariant="normal">Θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta
  </annotation>
 </semantics>
</math>

 so the risk does not vary with 

<math display="inline" id="Invariant_estimator:94">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

: that is, 

<math display="inline" id="Invariant_estimator:95">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>θ</mi>
     <mo>,</mo>
     <mi>δ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mi>δ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>E</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>X</mi>
        <mo>+</mo>
        <mi>K</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>θ</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>R</ci>
      <interval closure="open">
       <ci>θ</ci>
       <ci>δ</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>R</ci>
      <interval closure="open">
       <cn type="integer">0</cn>
       <ci>δ</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-E</ci>
      <apply>
       <times></times>
       <ci>L</ci>
       <apply>
        <plus></plus>
        <ci>X</ci>
        <ci>K</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <ci>θ</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(\theta,\delta)=R(0,\delta)=\operatorname{E}[L(X+K)|\theta=0]
  </annotation>
 </semantics>
</math>

. The best invariant estimator is the one that brings the risk 

<math display="inline" id="Invariant_estimator:96">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo>,</mo>
    <mi>δ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <interval closure="open">
     <ci>θ</ci>
     <ci>δ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(\theta,\delta)
  </annotation>
 </semantics>
</math>

 to minimum.</p>

<p>In the case that L is the squared error 

<math display="inline" id="Invariant_estimator:97">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <mrow>
      <mo>E</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>X</mi>
       <mo stretchy="false">|</mo>
       <mrow>
        <mi>θ</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>δ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>x</ci>
     <apply>
      <ci>normal-E</ci>
      <ci>X</ci>
      <apply>
       <eq></eq>
       <ci>θ</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(x)=x-\operatorname{E}[X|\theta=0].
  </annotation>
 </semantics>
</math>

</p>
<h3 id="pitman-estimator">Pitman estimator</h3>

<p>The estimation problem is that 

<math display="inline" id="Invariant_estimator:98">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=(X_{1},\dots,X_{n})
  </annotation>
 </semantics>
</math>

 has density 

<math display="inline" id="Invariant_estimator:99">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>-</mo>
     <mi>θ</mi>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mi>θ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <vector>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>θ</ci>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <ci>θ</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{1}-\theta,\dots,x_{n}-\theta)
  </annotation>
 </semantics>
</math>

, where <em>θ</em> is a parameter to be estimated, and where the <a href="loss_function" title="wikilink">loss function</a> is 

<math display="inline" id="Invariant_estimator:100">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>a</mi>
      <mo>-</mo>
      <mi>θ</mi>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <ci>a</ci>
      <ci>θ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(|a-\theta|)
  </annotation>
 </semantics>
</math>

. This problem is invariant with the following (additive) transformation groups:</p>

<p>

<math display="block" id="Invariant_estimator:101">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <msub>
      <mi>g</mi>
      <mi>c</mi>
     </msub>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mrow>
        <msub>
         <mi>g</mi>
         <mi>c</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>x</mi>
          <mn>1</mn>
         </msub>
         <mo>+</mo>
         <mi>c</mi>
        </mrow>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <mrow>
         <msub>
          <mi>x</mi>
          <mi>n</mi>
         </msub>
         <mo>+</mo>
         <mi>c</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>c</mi>
       <mo>∈</mo>
       <msup>
        <mi>ℝ</mi>
        <mn>1</mn>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <ci>c</ci>
        </apply>
        <ci>x</ci>
       </apply>
       <vector>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>c</ci>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>n</ci>
         </apply>
         <ci>c</ci>
        </apply>
       </vector>
      </apply>
      <apply>
       <in></in>
       <ci>c</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ℝ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=\{g_{c}:g_{c}(x)=(x_{1}+c,\dots,x_{n}+c),c\in\mathbb{R}^{1}\},
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Invariant_estimator:102">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>G</mi>
     <mo stretchy="false">¯</mo>
    </mover>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <msub>
      <mi>g</mi>
      <mi>c</mi>
     </msub>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mrow>
        <msub>
         <mi>g</mi>
         <mi>c</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>θ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mrow>
        <mi>θ</mi>
        <mo>+</mo>
        <mi>c</mi>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>c</mi>
       <mo>∈</mo>
       <msup>
        <mi>ℝ</mi>
        <mn>1</mn>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¯</ci>
     <ci>G</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <ci>c</ci>
        </apply>
        <ci>θ</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>θ</ci>
        <ci>c</ci>
       </apply>
      </apply>
      <apply>
       <in></in>
       <ci>c</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ℝ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{G}=\{g_{c}:g_{c}(\theta)=\theta+c,c\in\mathbb{R}^{1}\},
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Invariant_estimator:103">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>G</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <msub>
      <mi>g</mi>
      <mi>c</mi>
     </msub>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mrow>
        <msub>
         <mi>g</mi>
         <mi>c</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>a</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mrow>
        <mi>a</mi>
        <mo>+</mo>
        <mi>c</mi>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>c</mi>
       <mo>∈</mo>
       <msup>
        <mi>ℝ</mi>
        <mn>1</mn>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-~</ci>
     <ci>G</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <ci>c</ci>
        </apply>
        <ci>a</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>a</ci>
        <ci>c</ci>
       </apply>
      </apply>
      <apply>
       <in></in>
       <ci>c</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ℝ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{G}=\{g_{c}:g_{c}(a)=a+c,c\in\mathbb{R}^{1}\}.
  </annotation>
 </semantics>
</math>

</p>

<p>The best invariant estimator 

<math display="inline" id="Invariant_estimator:104">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>δ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(x)
  </annotation>
 </semantics>
</math>

 is the one that minimizes</p>

<p>

<math display="block" id="Invariant_estimator:105">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>δ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mi>θ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo>-</mo>
        <mi>θ</mi>
       </mrow>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo>-</mo>
        <mi>θ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>θ</mi>
     </mrow>
    </mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo>-</mo>
        <mi>θ</mi>
       </mrow>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo>-</mo>
        <mi>θ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>θ</mi>
     </mrow>
    </mrow>
   </mfrac>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>δ</ci>
        <ci>x</ci>
       </apply>
       <ci>θ</ci>
      </apply>
      <ci>f</ci>
      <vector>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>θ</ci>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <ci>θ</ci>
       </apply>
      </vector>
      <ci>d</ci>
      <ci>θ</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <vector>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>θ</ci>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <ci>θ</ci>
       </apply>
      </vector>
      <ci>d</ci>
      <ci>θ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\int_{-\infty}^{\infty}{L(\delta(x)-\theta)f(x_{1}-\theta,\dots,x_{n}-%
\theta)d\theta}}{\int_{-\infty}^{\infty}{f(x_{1}-\theta,\dots,x_{n}-\theta)d%
\theta}},
  </annotation>
 </semantics>
</math>

 and this is Pitman's estimator (1939).</p>

<p>For the squared error loss case, the result is</p>

<p>

<math display="block" id="Invariant_estimator:106">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mrow>
        <mo>-</mo>
        <mi mathvariant="normal">∞</mi>
       </mrow>
       <mi mathvariant="normal">∞</mi>
      </msubsup>
      <mrow>
       <mi>θ</mi>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>x</mi>
          <mn>1</mn>
         </msub>
         <mo>-</mo>
         <mi>θ</mi>
        </mrow>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <mrow>
         <msub>
          <mi>x</mi>
          <mi>n</mi>
         </msub>
         <mo>-</mo>
         <mi>θ</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>d</mi>
       <mi>θ</mi>
      </mrow>
     </mrow>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mrow>
        <mo>-</mo>
        <mi mathvariant="normal">∞</mi>
       </mrow>
       <mi mathvariant="normal">∞</mi>
      </msubsup>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>x</mi>
          <mn>1</mn>
         </msub>
         <mo>-</mo>
         <mi>θ</mi>
        </mrow>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <mrow>
         <msub>
          <mi>x</mi>
          <mi>n</mi>
         </msub>
         <mo>-</mo>
         <mi>θ</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>d</mi>
       <mi>θ</mi>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>δ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <ci>θ</ci>
       <ci>f</ci>
       <vector>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>θ</ci>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>n</ci>
         </apply>
         <ci>θ</ci>
        </apply>
       </vector>
       <ci>d</ci>
       <ci>θ</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <vector>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>θ</ci>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>n</ci>
         </apply>
         <ci>θ</ci>
        </apply>
       </vector>
       <ci>d</ci>
       <ci>θ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(x)=\frac{\int_{-\infty}^{\infty}{\theta f(x_{1}-\theta,\dots,x_{n}-%
\theta)d\theta}}{\int_{-\infty}^{\infty}{f(x_{1}-\theta,\dots,x_{n}-\theta)d%
\theta}}.
  </annotation>
 </semantics>
</math>

</p>

<p>If 

<math display="inline" id="Invariant_estimator:107">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∼</mo>
   <mrow>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>θ</mi>
      <msub>
       <mn>1</mn>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>,</mo>
     <mi>I</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <ci>x</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>θ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <cn type="integer">1</cn>
        <ci>n</ci>
       </apply>
      </apply>
      <ci>I</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\sim N(\theta 1_{n},I)\,\!
  </annotation>
 </semantics>
</math>

 (i.e. a <a href="multivariate_normal_distribution" title="wikilink">multivariate normal distribution</a> with independent, unit-variance components) then</p>

<p>

<math display="block" id="Invariant_estimator:108">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>δ</mi>
     <mrow>
      <mi>p</mi>
      <mi>i</mi>
      <mi>t</mi>
      <mi>m</mi>
      <mi>a</mi>
      <mi>n</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>δ</mi>
     <mrow>
      <mi>M</mi>
      <mi>L</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mo largeop="true" symmetric="true">∑</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mi>n</mi>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>i</ci>
       <ci>t</ci>
       <ci>m</ci>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <apply>
       <times></times>
       <ci>M</ci>
       <ci>L</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <sum></sum>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{pitman}=\delta_{ML}=\frac{\sum{x_{i}}}{n}.
  </annotation>
 </semantics>
</math>

</p>

<p>If 

<math display="inline" id="Invariant_estimator:109">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∼</mo>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>θ</mi>
      <msub>
       <mn>1</mn>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>I</mi>
      <msup>
       <mi>σ</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <ci>x</ci>
    <apply>
     <times></times>
     <ci>C</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>θ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <cn type="integer">1</cn>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>I</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>σ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\sim C(\theta 1_{n},I\sigma^{2})\,\!
  </annotation>
 </semantics>
</math>

 (independent components having a <a href="Cauchy_distribution" title="wikilink">Cauchy distribution</a> with scale parameter <em>σ</em>) then 

<math display="inline" id="Invariant_estimator:110">
 <semantics>
  <mrow>
   <msub>
    <mi>δ</mi>
    <mrow>
     <mi>p</mi>
     <mi>i</mi>
     <mi>t</mi>
     <mi>m</mi>
     <mi>a</mi>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>≠</mo>
   <msub>
    <mi>δ</mi>
    <mrow>
     <mi>M</mi>
     <mi>L</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>i</ci>
      <ci>t</ci>
      <ci>m</ci>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>L</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{pitman}\neq\delta_{ML}
  </annotation>
 </semantics>
</math>

,. However the result is</p>

<p>

<math display="block" id="Invariant_estimator:111">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>δ</mi>
      <mrow>
       <mi>p</mi>
       <mi>i</mi>
       <mi>t</mi>
       <mi>m</mi>
       <mi>a</mi>
       <mi>n</mi>
      </mrow>
     </msub>
     <mo>=</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>k</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>x</mi>
        <mi>k</mi>
       </msub>
       <mrow>
        <mo>[</mo>
        <mfrac>
         <mrow>
          <mi>R</mi>
          <mi>e</mi>
          <mrow>
           <mo stretchy="false">{</mo>
           <msub>
            <mi>w</mi>
            <mi>k</mi>
           </msub>
           <mo stretchy="false">}</mo>
          </mrow>
         </mrow>
         <mrow>
          <msubsup>
           <mo largeop="true" symmetric="true">∑</mo>
           <mrow>
            <mi>m</mi>
            <mo>=</mo>
            <mn>1</mn>
           </mrow>
           <mi>n</mi>
          </msubsup>
          <mrow>
           <mi>R</mi>
           <mi>e</mi>
           <mrow>
            <mo stretchy="false">{</mo>
            <msub>
             <mi>w</mi>
             <mi>k</mi>
            </msub>
            <mo stretchy="false">}</mo>
           </mrow>
          </mrow>
         </mrow>
        </mfrac>
        <mo>]</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="22.5pt">,</mo>
    <mrow>
     <mi>n</mi>
     <mo>></mo>
     <mn>1</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>i</ci>
       <ci>t</ci>
       <ci>m</ci>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>R</ci>
          <ci>e</ci>
          <set>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>w</ci>
            <ci>k</ci>
           </apply>
          </set>
         </apply>
         <apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <sum></sum>
            <apply>
             <eq></eq>
             <ci>m</ci>
             <cn type="integer">1</cn>
            </apply>
           </apply>
           <ci>n</ci>
          </apply>
          <apply>
           <times></times>
           <ci>R</ci>
           <ci>e</ci>
           <set>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>w</ci>
             <ci>k</ci>
            </apply>
           </set>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{pitman}=\sum_{k=1}^{n}{x_{k}\left[\frac{Re\{w_{k}\}}{\sum_{m=1}^{n}{Re%
\{w_{k}\}}}\right]},\qquad n>1,
  </annotation>
 </semantics>
</math>

 with</p>

<p>

<math display="block" id="Invariant_estimator:112">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>w</mi>
     <mi>k</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi>j</mi>
       <mo>≠</mo>
       <mi>k</mi>
      </mrow>
     </munder>
     <mrow>
      <mrow>
       <mo>[</mo>
       <mfrac>
        <mn>1</mn>
        <mrow>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <msub>
             <mi>x</mi>
             <mi>k</mi>
            </msub>
            <mo>-</mo>
            <msub>
             <mi>x</mi>
             <mi>j</mi>
            </msub>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mn>2</mn>
         </msup>
         <mo>+</mo>
         <mrow>
          <mn>4</mn>
          <msup>
           <mi>σ</mi>
           <mn>2</mn>
          </msup>
         </mrow>
        </mrow>
       </mfrac>
       <mo>]</mo>
      </mrow>
      <mrow>
       <mo>[</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <mfrac>
          <mrow>
           <mn>2</mn>
           <mi>σ</mi>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <msub>
             <mi>x</mi>
             <mi>k</mi>
            </msub>
            <mo>-</mo>
            <msub>
             <mi>x</mi>
             <mi>j</mi>
            </msub>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mfrac>
         <mi>i</mi>
        </mrow>
       </mrow>
       <mo>]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <neq></neq>
       <ci>j</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <minus></minus>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>k</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>j</ci>
           </apply>
          </apply>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">4</cn>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>σ</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <apply>
           <times></times>
           <cn type="integer">2</cn>
           <ci>σ</ci>
          </apply>
          <apply>
           <minus></minus>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>k</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>j</ci>
           </apply>
          </apply>
         </apply>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{k}=\prod_{j\neq k}\left[\frac{1}{(x_{k}-x_{j})^{2}+4\sigma^{2}}\right]\left%
[1-\frac{2\sigma}{(x_{k}-x_{j})}i\right].
  </annotation>
 </semantics>
</math>

 </p>
<h2 id="references">References</h2>
<ul>
<li>
</li>
<li>Freue, Gabriela V. Cohen (2007) "The Pitman estimator of the Cauchy location parameter", <em>Journal of Statistical Planning and Inference</em>, 137, 1900–1913 </li>
<li>Pitman, E.J.G. (1939) "The estimation of the location and scale parameters of a continuous population of any given form", <em><a class="uri" href="Biometrika" title="wikilink">Biometrika</a></em>, 30 (3/4), 391–421. </li>
<li>Pitman, E.J.G. (1939) "Tests of Hypotheses Concerning Location and Scale Parameters", <em><a class="uri" href="Biometrika" title="wikilink">Biometrika</a></em>, 31 (1/2), 200–215. </li>
</ul>

<p>"</p>

<p><a href="Category:Statistical_theory" title="wikilink">Category:Statistical theory</a> <a href="Category:Estimation_theory" title="wikilink">Category:Estimation theory</a> <a href="Category:Statistical_terminology" title="wikilink">Category:Statistical terminology</a> <a href="Category:Invariant_theory" title="wikilink">Category:Invariant theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">see section 5.2.1 in Gourieroux, C. and Monfort, A. (1995). Statistics and econometric models, volume 1. Cambridge University Press.<a href="#fnref1">↩</a></li>
<li id="fn2">Gourrieroux and Monfort (1995)<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
