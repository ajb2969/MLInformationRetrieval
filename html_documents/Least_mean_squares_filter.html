<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1967">Least mean squares filter</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Least mean squares filter</h1>
<hr/>

<p><strong>Least mean squares (LMS)</strong> algorithms are a class of <a href="adaptive_filter" title="wikilink">adaptive filter</a> used to mimic a desired filter by finding the filter coefficients that relate to producing the least mean squares of the error signal (difference between the desired and the actual signal). It is a <a href="stochastic_gradient_descent" title="wikilink">stochastic gradient descent</a> method in that the filter is only adapted based on the error at the current time. It was invented in 1960 by <a href="Stanford_University" title="wikilink">Stanford University</a> professor <a href="Bernard_Widrow" title="wikilink">Bernard Widrow</a> and his first Ph.D. student, <a href="Ted_Hoff" title="wikilink">Ted Hoff</a>.</p>
<h2 id="problem-formulation">Problem formulation</h2>
<figure><b>(Figure)</b>
<figcaption>LMS filter</figcaption>
</figure>
<h3 id="relationship-to-the-least-mean-squares-filter">Relationship to the least mean squares filter</h3>

<p>The realization of the causal Wiener filter looks a lot like the solution to the least squares estimate, except in the signal processing domain. The least squares solution, for input matrix 

<math display="inline" id="Least_mean_squares_filter:0">
 <semantics>
  <mi>𝐗</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐗</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathbf{X}
  </annotation>
 </semantics>
</math>

 and output vector 

<math display="inline" id="Least_mean_squares_filter:1">
 <semantics>
  <mi>𝐲</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐲</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathbf{y}
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="inline" id="Least_mean_squares_filter:2">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>𝜷</mi>
     <mo mathvariant="bold" stretchy="false">^</mo>
    </mover>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>𝐗</mi>
         <mi>𝐓</mi>
        </msup>
        <mi>𝐗</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <msup>
      <mi>𝐗</mi>
      <mi>𝐓</mi>
     </msup>
     <mi>𝒚</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>bold-^</ci>
     <ci>𝜷</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐗</ci>
        <ci>𝐓</ci>
       </apply>
       <ci>𝐗</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐗</ci>
      <ci>𝐓</ci>
     </apply>
     <ci>𝒚</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\hat{\beta}}=(\mathbf{X}^{\mathbf{T}}\mathbf{X})^{-1}\mathbf{X}^{%
\mathbf{T}}\boldsymbol{y}.
  </annotation>
 </semantics>
</math>

</p>

<p>The FIR least mean squares filter is related to the Wiener filter, but minimizing the error criterion of the former does not rely on cross-correlations or auto-correlations. Its solution converges to the Wiener filter solution. Most linear adaptive filtering problems can be formulated using the block diagram above. That is, an unknown system 

<math display="inline" id="Least_mean_squares_filter:3">
 <semantics>
  <mrow>
   <mi>𝐡</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐡</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{h}(n)
  </annotation>
 </semantics>
</math>


 is to be identified and the adaptive filter attempts to adapt the filter 

<math display="inline" id="Least_mean_squares_filter:4">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>𝐡</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>𝐡</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{h}}(n)
  </annotation>
 </semantics>
</math>

 to make it as close as possible to 

<math display="inline" id="Least_mean_squares_filter:5">
 <semantics>
  <mrow>
   <mi>𝐡</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐡</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{h}(n)
  </annotation>
 </semantics>
</math>

, while using only observable signals 

<math display="inline" id="Least_mean_squares_filter:6">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(n)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Least_mean_squares_filter:7">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(n)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Least_mean_squares_filter:8">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>e</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(n)
  </annotation>
 </semantics>
</math>


; but 

<math display="inline" id="Least_mean_squares_filter:9">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(n)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Least_mean_squares_filter:10">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>v</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(n)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Least_mean_squares_filter:11">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(n)
  </annotation>
 </semantics>
</math>

 are not directly observable. Its solution is closely related to the <a href="Wiener_filter" title="wikilink">Wiener filter</a>.</p>
<h3 id="definition-of-symbols">Definition of symbols</h3>

<p>

<math display="block" id="Least_mean_squares_filter:12">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the number of the current input sample</p>

<p>

<math display="block" id="Least_mean_squares_filter:13">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is the number of filter taps</p>

<p>

<math display="block" id="Least_mean_squares_filter:14">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">{</mo>
    <mo>⋅</mo>
    <mo stretchy="false">}</mo>
   </mrow>
   <mi>H</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <set>
     <ci>normal-⋅</ci>
    </set>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\cdot\}^{H}
  </annotation>
 </semantics>
</math>

 (<a href="Hermitian_transpose" title="wikilink">Hermitian transpose</a> or <a href="conjugate_transpose" title="wikilink">conjugate transpose</a>)</p>

<p>

<math display="block" id="Least_mean_squares_filter:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐱</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mi>p</mi>
        </mrow>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝐱</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <list>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <ci>p</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </list>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}(n)=\left[x(n),x(n-1),\dots,x(n-p+1)\right]^{T}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Least_mean_squares_filter:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝐡</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo>[</mo>
      <mrow>
       <msub>
        <mi>h</mi>
        <mn>0</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <msub>
        <mi>h</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mrow>
       <msub>
        <mi>h</mi>
        <mrow>
         <mi>p</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>]</mo>
     </mrow>
     <mi>T</mi>
    </msup>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mrow>
     <mi>𝐡</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <msup>
     <mi>ℂ</mi>
     <mi>p</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>𝐡</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <list>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>n</ci>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <apply>
          <minus></minus>
          <ci>p</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
      </list>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <ci>𝐡</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℂ</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{h}(n)=\left[h_{0}(n),h_{1}(n),\dots,h_{p-1}(n)\right]^{T},\quad\mathbf%
{h}(n)\in\mathbb{C}^{p}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Least_mean_squares_filter:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>𝐡</mi>
       <mi>H</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <mi>𝐱</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐡</ci>
        <ci>H</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <ci>𝐱</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(n)=\mathbf{h}^{H}(n)\cdot\mathbf{x}(n)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Least_mean_squares_filter:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>ν</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ν</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(n)=y(n)+\nu(n)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Least_mean_squares_filter:19">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>𝐡</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>𝐡</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{h}}(n)
  </annotation>
 </semantics>
</math>

 estimated filter; interpret as the estimation of the filter coefficients after 

<math display="inline" id="Least_mean_squares_filter:20">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 samples</p>

<p>

<math display="block" id="Least_mean_squares_filter:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mover accent="true">
      <mi>y</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mrow>
       <msup>
        <mover accent="true">
         <mi>𝐡</mi>
         <mo stretchy="false">^</mo>
        </mover>
        <mi>H</mi>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⋅</mo>
      <mi>𝐱</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-^</ci>
        <ci>y</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <ci>normal-^</ci>
           <ci>𝐡</ci>
          </apply>
          <ci>H</ci>
         </apply>
         <ci>n</ci>
        </apply>
        <ci>𝐱</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(n)=d(n)-\hat{y}(n)=d(n)-\hat{\mathbf{h}}^{H}(n)\cdot\mathbf{x}(n)
  </annotation>
 </semantics>
</math>

</p>
<h2 id="idea">Idea</h2>

<p>The basic idea behind LMS filter is to approach the optimum filter weights 

<math display="inline" id="Least_mean_squares_filter:22">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msup>
     <mi>R</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>P</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (R^{-1}P)
  </annotation>
 </semantics>
</math>

, by updating the filter weights in a manner to converge to the optimum filter weight. The algorithm starts by assuming a small weights (zero in most cases), and at each step, by finding the gradient of the mean square error, the weights are updated. That is, if the MSE-gradient is positive, it implies, the error would keep increasing positively, if the same weight is used for further iterations, which means we need to reduce the weights. In the same way, if the gradient is negative, we need to increase the weights. So, the basic weight update equation is :</p>

<p>

<math display="inline" id="Least_mean_squares_filter:23">
 <semantics>
  <mrow>
   <msub>
    <mi>W</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>W</mi>
     <mi>n</mi>
    </msub>
    <mo>-</mo>
    <mrow>
     <mi>μ</mi>
     <mrow>
      <mo>∇</mo>
      <mi>ε</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>μ</ci>
      <apply>
       <ci>normal-∇</ci>
       <ci>ε</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{n+1}=W_{n}-\mu\nabla\varepsilon[n]
  </annotation>
 </semantics>
</math>


,</p>

<p>where 

<math display="inline" id="Least_mean_squares_filter:24">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

 represents the mean-square error. The negative sign indicates that, we need to change the weights in a direction opposite to that of the gradient slope.</p>

<p>The mean-square error, as a function of filter weights is a quadratic function which means it has only one extrema, that minimises the mean-square error, which is the optimal weight. The LMS thus, approaches towards this optimal weights by ascending/descending down the mean-square-error vs filter weight curve.</p>
<h2 id="derivation">Derivation</h2>

<p>The idea behind LMS filters is to use <a href="steepest_descent" title="wikilink">steepest descent</a> to find filter weights 

<math display="inline" id="Least_mean_squares_filter:25">
 <semantics>
  <mrow>
   <mi>𝐡</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐡</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{h}(n)
  </annotation>
 </semantics>
</math>

 which minimize a <a href="Loss_function" title="wikilink">cost function</a>. We start by defining the cost function as</p>

<p>

<math display="block" id="Least_mean_squares_filter:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo>{</mo>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mi>e</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <set>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <apply>
         <times></times>
         <ci>e</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(n)=E\left\{|e(n)|^{2}\right\}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Least_mean_squares_filter:27">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>e</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(n)
  </annotation>
 </semantics>
</math>

 is the error at the current sample <em>n</em> and 

<math display="inline" id="Least_mean_squares_filter:28">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">{</mo>
    <mo>⋅</mo>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <set>
     <ci>normal-⋅</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\{\cdot\}
  </annotation>
 </semantics>
</math>


 denotes the <a href="expected_value" title="wikilink">expected value</a>.</p>

<p>This cost function (

<math display="inline" id="Least_mean_squares_filter:29">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(n)
  </annotation>
 </semantics>
</math>

) is the mean square error, and it is minimized by the LMS. This is where the LMS gets its name. Applying <a href="steepest_descent" title="wikilink">steepest descent</a> means to take the <a href="partial_derivative" title="wikilink">partial derivatives</a> with respect to the individual entries of the filter coefficient (weight) vector</p>

<p>

<math display="block" id="Least_mean_squares_filter:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo>∇</mo>
      <msup>
       <mover accent="true">
        <mi>𝐡</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mi>H</mi>
      </msup>
     </msub>
     <mi>C</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mo>∇</mo>
      <msup>
       <mover accent="true">
        <mi>𝐡</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mi>H</mi>
      </msup>
     </msub>
     <mi>E</mi>
    </mrow>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mi>e</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>e</mi>
       <mo>*</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mi>E</mi>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mrow>
       <mrow>
        <msub>
         <mo>∇</mo>
         <msup>
          <mover accent="true">
           <mi>𝐡</mi>
           <mo stretchy="false">^</mo>
          </mover>
          <mi>H</mi>
         </msup>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>e</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>n</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo rspace="4.2pt" stretchy="false">)</mo>
        </mrow>
       </mrow>
       <msup>
        <mi>e</mi>
        <mo>*</mo>
       </msup>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-∇</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <ci>normal-^</ci>
          <ci>𝐡</ci>
         </apply>
         <ci>H</ci>
        </apply>
       </apply>
       <ci>C</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-∇</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <ci>normal-^</ci>
          <ci>𝐡</ci>
         </apply>
         <ci>H</ci>
        </apply>
       </apply>
       <ci>E</ci>
      </apply>
      <set>
       <apply>
        <times></times>
        <ci>e</ci>
        <ci>n</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <times></times>
        </apply>
        <ci>n</ci>
       </apply>
      </set>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>E</ci>
      <set>
       <apply>
        <times></times>
        <apply>
         <apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>normal-∇</ci>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <ci>normal-^</ci>
             <ci>𝐡</ci>
            </apply>
            <ci>H</ci>
           </apply>
          </apply>
          <apply>
           <times></times>
           <ci>e</ci>
           <ci>n</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>e</ci>
          <times></times>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla_{\hat{\mathbf{h}}^{H}}C(n)=\nabla_{\hat{\mathbf{h}}^{H}}E\left\{e(n)\,e%
^{*}(n)\right\}=2E\left\{\nabla_{\hat{\mathbf{h}}^{H}}(e(n))\,e^{*}(n)\right\}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Least_mean_squares_filter:31">
 <semantics>
  <mo>∇</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-∇</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla
  </annotation>
 </semantics>
</math>

 is the <a class="uri" href="gradient" title="wikilink">gradient</a> operator</p>

<p>

<math display="block" id="Least_mean_squares_filter:32">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>∇</mo>
     <msup>
      <mover accent="true">
       <mi>𝐡</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mi>H</mi>
     </msup>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>e</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>∇</mo>
     <msup>
      <mover accent="true">
       <mi>𝐡</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mi>H</mi>
     </msup>
    </msub>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mi>d</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mrow>
        <msup>
         <mover accent="true">
          <mi>𝐡</mi>
          <mo stretchy="false">^</mo>
         </mover>
         <mi>H</mi>
        </msup>
        <mo>⋅</mo>
        <mi>𝐱</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>𝐱</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-∇</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>𝐡</ci>
        </apply>
        <ci>H</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>e</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-∇</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>𝐡</ci>
        </apply>
        <ci>H</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <ci>normal-⋅</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <ci>normal-^</ci>
           <ci>𝐡</ci>
          </apply>
          <ci>H</ci>
         </apply>
         <ci>𝐱</ci>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>𝐱</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla_{\hat{\mathbf{h}}^{H}}(e(n))=\nabla_{\hat{\mathbf{h}}^{H}}\left(d(n)-%
\hat{\mathbf{h}}^{H}\cdot\mathbf{x}(n)\right)=-\mathbf{x}(n)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Least_mean_squares_filter:33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∇</mo>
     <mi>C</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <mi>E</mi>
     <mrow>
      <mo>{</mo>
      <mrow>
       <mi>𝐱</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <msup>
        <mi>e</mi>
        <mo>*</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-∇</ci>
      <ci>C</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>E</ci>
      <set>
       <apply>
        <times></times>
        <ci>𝐱</ci>
        <ci>n</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <times></times>
        </apply>
        <ci>n</ci>
       </apply>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla C(n)=-2E\left\{\mathbf{x}(n)\,e^{*}(n)\right\}
  </annotation>
 </semantics>
</math>

 Now, 

<math display="inline" id="Least_mean_squares_filter:34">
 <semantics>
  <mrow>
   <mrow>
    <mo>∇</mo>
    <mi>C</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-∇</ci>
     <ci>C</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla C(n)
  </annotation>
 </semantics>
</math>

 is a vector which points towards the steepest ascent of the cost function. To find the minimum of the cost function we need to take a step in the opposite direction of 

<math display="inline" id="Least_mean_squares_filter:35">
 <semantics>
  <mrow>
   <mrow>
    <mo>∇</mo>
    <mi>C</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-∇</ci>
     <ci>C</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla C(n)
  </annotation>
 </semantics>
</math>

. To express that in mathematical terms</p>

<p>

<math display="block" id="Least_mean_squares_filter:36">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>𝐡</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>𝐡</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mfrac>
      <mi>μ</mi>
      <mn>2</mn>
     </mfrac>
     <mrow>
      <mo>∇</mo>
      <mi>C</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>𝐡</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>μ</mi>
     </mpadded>
     <mi>E</mi>
     <mrow>
      <mo>{</mo>
      <mrow>
       <mi>𝐱</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <msup>
        <mi>e</mi>
        <mo>*</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-^</ci>
       <ci>𝐡</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <ci>normal-^</ci>
        <ci>𝐡</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>μ</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <ci>normal-∇</ci>
        <ci>C</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <ci>normal-^</ci>
        <ci>𝐡</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>μ</ci>
       <ci>E</ci>
       <set>
        <apply>
         <times></times>
         <ci>𝐱</ci>
         <ci>n</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>e</ci>
          <times></times>
         </apply>
         <ci>n</ci>
        </apply>
       </set>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{h}}(n+1)=\hat{\mathbf{h}}(n)-\frac{\mu}{2}\nabla C(n)=\hat{%
\mathbf{h}}(n)+\mu\,E\left\{\mathbf{x}(n)\,e^{*}(n)\right\}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Least_mean_squares_filter:37">
 <semantics>
  <mfrac>
   <mi>μ</mi>
   <mn>2</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>μ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\mu}{2}
  </annotation>
 </semantics>
</math>

 is the step size(adaptation constant). That means we have found a sequential update algorithm which minimizes the cost function. Unfortunately, this algorithm is not realizable until we know 

<math display="inline" id="Least_mean_squares_filter:38">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo>{</mo>
    <mrow>
     <mi>𝐱</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>e</mi>
      <mo>*</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <set>
     <apply>
      <times></times>
      <ci>𝐱</ci>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <times></times>
      </apply>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\left\{\mathbf{x}(n)\,e^{*}(n)\right\}
  </annotation>
 </semantics>
</math>


.</p>

<p>Generally, the expectation above is not computed. Instead, to run the LMS in an online (updating after each new sample is received) environment, we use an instantaneous estimate of that expectation. See below.</p>
<h2 id="simplifications">Simplifications</h2>

<p>For most systems the expectation function 

<math display="inline" id="Least_mean_squares_filter:39">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo>{</mo>
    <mrow>
     <mi>𝐱</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>e</mi>
      <mo>*</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <set>
     <apply>
      <times></times>
      <ci>𝐱</ci>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <times></times>
      </apply>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {E}\left\{\mathbf{x}(n)\,e^{*}(n)\right\}
  </annotation>
 </semantics>
</math>

 must be approximated. This can be done with the following unbiased <a class="uri" href="estimator" title="wikilink">estimator</a></p>

<p>

<math display="block" id="Least_mean_squares_filter:40">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>E</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mi>𝐱</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>e</mi>
       <mo>*</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>N</mi>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </munderover>
     <mrow>
      <mi>𝐱</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>i</mi>
       </mrow>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>e</mi>
       <mo>*</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>i</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>E</ci>
     </apply>
     <set>
      <apply>
       <times></times>
       <ci>𝐱</ci>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <times></times>
       </apply>
       <ci>n</ci>
      </apply>
     </set>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>𝐱</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <times></times>
       </apply>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{E}\left\{\mathbf{x}(n)\,e^{*}(n)\right\}=\frac{1}{N}\sum_{i=0}^{N-1}%
\mathbf{x}(n-i)\,e^{*}(n-i)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Least_mean_squares_filter:41">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 indicates the number of samples we use for that estimate. The simplest case is 

<math display="inline" id="Least_mean_squares_filter:42">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Least_mean_squares_filter:43">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>E</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mi>𝐱</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>e</mi>
       <mo>*</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>𝐱</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
    <msup>
     <mi>e</mi>
     <mo>*</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>E</ci>
     </apply>
     <set>
      <apply>
       <times></times>
       <ci>𝐱</ci>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <times></times>
       </apply>
       <ci>n</ci>
      </apply>
     </set>
    </apply>
    <apply>
     <times></times>
     <ci>𝐱</ci>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <times></times>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{E}\left\{\mathbf{x}(n)\,e^{*}(n)\right\}=\mathbf{x}(n)\,e^{*}(n)
  </annotation>
 </semantics>
</math>

 For that simple case the update algorithm follows as</p>

<p>

<math display="block" id="Least_mean_squares_filter:44">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>𝐡</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>𝐡</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>μ</mi>
     <mi>𝐱</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>e</mi>
      <mo>*</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>𝐡</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-^</ci>
       <ci>𝐡</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>μ</ci>
      <ci>𝐱</ci>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <times></times>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{h}}(n+1)=\hat{\mathbf{h}}(n)+\mu\mathbf{x}(n)\,e^{*}(n)
  </annotation>
 </semantics>
</math>

 Indeed this constitutes the update algorithm for the LMS filter.</p>
<h2 id="lms-algorithm-summary">LMS algorithm summary</h2>

<p>The LMS algorithm for a 

<math display="inline" id="Least_mean_squares_filter:45">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

th order algorithm can be summarized as</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Parameters:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Least_mean_squares_filter:46">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=
  </annotation>
 </semantics>
</math>

 filter order</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Least_mean_squares_filter:47">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>μ</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu=
  </annotation>
 </semantics>
</math>

 step size</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Initialisation:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Least_mean_squares_filter:48">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>𝐡</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>zeros</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>𝐡</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <ci>zeros</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{h}}(0)=\operatorname{zeros}(p)
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Computation:</p></td>
<td style="text-align: left;">
<p>For 

<math display="inline" id="Least_mean_squares_filter:49">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=0,1,2,...
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Least_mean_squares_filter:50">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐱</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mi>p</mi>
        </mrow>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝐱</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <list>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <ci>p</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </list>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}(n)=\left[x(n),x(n-1),\dots,x(n-p+1)\right]^{T}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Least_mean_squares_filter:51">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msup>
      <mover accent="true">
       <mi>𝐡</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mi>H</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>𝐱</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>𝐡</ci>
       </apply>
       <ci>H</ci>
      </apply>
      <ci>n</ci>
      <ci>𝐱</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(n)=d(n)-\hat{\mathbf{h}}^{H}(n)\mathbf{x}(n)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Least_mean_squares_filter:52">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>𝐡</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>𝐡</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>μ</mi>
     </mpadded>
     <msup>
      <mi>e</mi>
      <mo>*</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>𝐱</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>𝐡</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-^</ci>
       <ci>𝐡</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>μ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <times></times>
      </apply>
      <ci>n</ci>
      <ci>𝐱</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{h}}(n+1)=\hat{\mathbf{h}}(n)+\mu\,e^{*}(n)\mathbf{x}(n)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
<h2 id="convergence-and-stability-in-the-mean">Convergence and stability in the mean</h2>

<p>As the LMS algorithm does not use the exact values of the expectations, the weights would never reach the optimal weights in the absolute sense, but a convergence is possible in mean. That is, even though the weights may change by small amounts, it changes about the optimal weights. However, if the variance with which the weights change, is large, convergence in mean would be misleading. This problem may occur, if the value of step-size 

<math display="inline" id="Least_mean_squares_filter:53">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>


 is not chosen properly.</p>

<p>If 

<math display="inline" id="Least_mean_squares_filter:54">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 is chosen to be large, the amount with which the weights change depends heavily on the gradient estimate, and so the weights may change by a large value so that gradient which was negative at the first instant may now become positive. And at the second instant, the weight may change in the opposite direction by a large amount because of the negative gradient and would thus keep oscillating with a large variance about the optimal weights. On the other hand if 

<math display="inline" id="Least_mean_squares_filter:55">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 is chosen to be too small, time to converge to the optimal weights will be too large.</p>

<p>Thus, an upper bound on 

<math display="inline" id="Least_mean_squares_filter:56">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 is needed which is given as 

<math display="inline" id="Least_mean_squares_filter:57">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo><</mo>
   <mi>μ</mi>
   <mo><</mo>
   <mfrac>
    <mn>2</mn>
    <msub>
     <mi>λ</mi>
     <mi>max</mi>
    </msub>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <ci>μ</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>max</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<\mu<\frac{2}{\lambda_{\mathrm{max}}}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Least_mean_squares_filter:58">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mi>max</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <max></max>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{\max}
  </annotation>
 </semantics>
</math>


 is the greatest eigenvalue of the <a class="uri" href="autocorrelation" title="wikilink">autocorrelation</a> matrix 

<math display="inline" id="Least_mean_squares_filter:59">
 <semantics>
  <mrow>
   <mi>𝐑</mi>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>𝐱</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>𝐱</mi>
       <mi>H</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐑</ci>
    <apply>
     <times></times>
     <ci>E</ci>
     <set>
      <apply>
       <times></times>
       <ci>𝐱</ci>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐱</ci>
        <ci>H</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{R}}=E\{{\mathbf{x}}(n){\mathbf{x}^{H}}(n)\}
  </annotation>
 </semantics>
</math>

. If this condition is not fulfilled, the algorithm becomes unstable and 

<math display="inline" id="Least_mean_squares_filter:60">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>h</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>h</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{h}(n)
  </annotation>
 </semantics>
</math>

 diverges.</p>

<p>Maximum convergence speed is achieved when</p>

<p>

<math display="block" id="Least_mean_squares_filter:61">
 <semantics>
  <mrow>
   <mrow>
    <mi>μ</mi>
    <mo>=</mo>
    <mfrac>
     <mn>2</mn>
     <mrow>
      <msub>
       <mi>λ</mi>
       <mi>max</mi>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>λ</mi>
       <mi>min</mi>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>μ</ci>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>max</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>min</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu=\frac{2}{\lambda_{\mathrm{max}}+\lambda_{\mathrm{min}}},
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Least_mean_squares_filter:62">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mi>min</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <min></min>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{\min}
  </annotation>
 </semantics>
</math>

 is the smallest eigenvalue of R. Given that 

<math display="inline" id="Least_mean_squares_filter:63">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>


 is less than or equal to this optimum, the convergence speed is determined by 

<math display="inline" id="Least_mean_squares_filter:64">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mi>min</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <min></min>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{\min}
  </annotation>
 </semantics>
</math>

, with a larger value yielding faster convergence. This means that faster convergence can be achieved when 

<math display="inline" id="Least_mean_squares_filter:65">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mi>max</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <max></max>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{\max}
  </annotation>
 </semantics>
</math>

 is close to 

<math display="inline" id="Least_mean_squares_filter:66">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mi>min</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <min></min>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{\min}
  </annotation>
 </semantics>
</math>

, that is, the maximum achievable convergence speed depends on the <a href="eigenvalue_spread" title="wikilink">eigenvalue spread</a> of 

<math display="inline" id="Least_mean_squares_filter:67">
 <semantics>
  <mi>𝐑</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{R}}
  </annotation>
 </semantics>
</math>

.</p>

<p>A <a href="white_noise" title="wikilink">white noise</a> signal has autocorrelation matrix 

<math display="inline" id="Least_mean_squares_filter:68">
 <semantics>
  <mrow>
   <mi>𝐑</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>σ</mi>
     <mn>2</mn>
    </msup>
    <mi>𝐈</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐑</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>𝐈</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{R}}=\sigma^{2}{\mathbf{I}}
  </annotation>
 </semantics>
</math>


 where 

<math display="inline" id="Least_mean_squares_filter:69">
 <semantics>
  <msup>
   <mi>σ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}
  </annotation>
 </semantics>
</math>

 is the variance of the signal. In this case all eigenvalues are equal, and the eigenvalue spread is the minimum over all possible matrices. The common interpretation of this result is therefore that the LMS converges quickly for white input signals, and slowly for colored input signals, such as processes with low-pass or high-pass characteristics.</p>

<p>It is important to note that the above upperbound on 

<math display="inline" id="Least_mean_squares_filter:70">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 only enforces stability in the mean, but the coefficients of 

<math display="inline" id="Least_mean_squares_filter:71">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>h</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>h</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{h}(n)
  </annotation>
 </semantics>
</math>

 can still grow infinitely large, i.e. divergence of the coefficients is still possible. A more practical bound is</p>

<p>

<math display="block" id="Least_mean_squares_filter:72">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo><</mo>
    <mi>μ</mi>
    <mo><</mo>
    <mfrac>
     <mn>2</mn>
     <mrow>
      <mi>tr</mi>
      <mrow>
       <mo>[</mo>
       <mi>𝐑</mi>
       <mo>]</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <ci>μ</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <apply>
       <times></times>
       <ci>tr</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>𝐑</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<\mu<\frac{2}{\mathrm{tr}\left[{\mathbf{R}}\right]},
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Least_mean_squares_filter:73">
 <semantics>
  <mrow>
   <mi>tr</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>𝐑</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>tr</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>𝐑</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{tr}[{\mathbf{R}}]
  </annotation>
 </semantics>
</math>


 denotes the trace of 

<math display="inline" id="Least_mean_squares_filter:74">
 <semantics>
  <mi>𝐑</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{R}}
  </annotation>
 </semantics>
</math>

. This bound guarantees that the coefficients of 

<math display="inline" id="Least_mean_squares_filter:75">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>h</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>h</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{h}(n)
  </annotation>
 </semantics>
</math>

 do not diverge (in practice, the value of 

<math display="inline" id="Least_mean_squares_filter:76">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 should not be chosen close to this upper bound, since it is somewhat optimistic due to approximations and assumptions made in the derivation of the bound).</p>
<h2 id="normalised-least-mean-squares-filter-nlms">Normalised least mean squares filter (NLMS)</h2>

<p>The main drawback of the "pure" LMS algorithm is that it is sensitive to the scaling of its input 

<math display="inline" id="Least_mean_squares_filter:77">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(n)
  </annotation>
 </semantics>
</math>

. This makes it very hard (if not impossible) to choose a learning rate 

<math display="inline" id="Least_mean_squares_filter:78">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>


 that guarantees stability of the algorithm (Haykin 2002). The <em>Normalised least mean squares filter</em> (NLMS) is a variant of the LMS algorithm that solves this problem by normalising with the power of the input. The NLMS algorithm can be summarised as:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Parameters:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Least_mean_squares_filter:79">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=
  </annotation>
 </semantics>
</math>

 filter order</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Least_mean_squares_filter:80">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>μ</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu=
  </annotation>
 </semantics>
</math>

 step size</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Initialization:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Least_mean_squares_filter:81">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>𝐡</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>zeros</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>𝐡</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <ci>zeros</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{h}}(0)=\operatorname{zeros}(p)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Computation:</p></td>
<td style="text-align: left;">
<p>For 

<math display="inline" id="Least_mean_squares_filter:82">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=0,1,2,...
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Least_mean_squares_filter:83">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐱</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mi>p</mi>
        </mrow>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝐱</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <list>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <ci>p</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </list>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}(n)=\left[x(n),x(n-1),\dots,x(n-p+1)\right]^{T}
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Least_mean_squares_filter:84">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msup>
      <mover accent="true">
       <mi>𝐡</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mi>H</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>𝐱</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>𝐡</ci>
       </apply>
       <ci>H</ci>
      </apply>
      <ci>n</ci>
      <ci>𝐱</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(n)=d(n)-\hat{\mathbf{h}}^{H}(n)\mathbf{x}(n)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Least_mean_squares_filter:85">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>𝐡</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>𝐡</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mfrac>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>μ</mi>
      </mpadded>
      <msup>
       <mi>e</mi>
       <mo>*</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>𝐱</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <msup>
       <mi>𝐱</mi>
       <mi>H</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>𝐱</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>𝐡</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-^</ci>
       <ci>𝐡</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>μ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <times></times>
       </apply>
       <ci>n</ci>
       <ci>𝐱</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐱</ci>
        <ci>H</ci>
       </apply>
       <ci>n</ci>
       <ci>𝐱</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{h}}(n+1)=\hat{\mathbf{h}}(n)+\frac{\mu\,e^{*}(n)\mathbf{x}(n)}{%
\mathbf{x}^{H}(n)\mathbf{x}(n)}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
<h3 id="optimal-learning-rate">Optimal learning rate</h3>

<p>It can be shown that if there is no interference (

<math display="inline" id="Least_mean_squares_filter:86">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>n</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(n)=0
  </annotation>
 </semantics>
</math>

), then the optimal learning rate for the NLMS algorithm is</p>

<p>

<math display="block" id="Least_mean_squares_filter:87">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mrow>
     <mi>o</mi>
     <mi>p</mi>
     <mi>t</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>p</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{opt}=1
  </annotation>
 </semantics>
</math>

 and is independent of the input 

<math display="inline" id="Least_mean_squares_filter:88">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(n)
  </annotation>
 </semantics>
</math>


 and the real (unknown) impulse response 

<math display="inline" id="Least_mean_squares_filter:89">
 <semantics>
  <mrow>
   <mi>𝐡</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐡</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{h}(n)
  </annotation>
 </semantics>
</math>

. In the general case with interference (

<math display="inline" id="Least_mean_squares_filter:90">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>n</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(n)\neq 0
  </annotation>
 </semantics>
</math>

), the optimal learning rate is</p>

<p>

<math display="block" id="Least_mean_squares_filter:91">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mrow>
     <mi>o</mi>
     <mi>p</mi>
     <mi>t</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo>[</mo>
      <msup>
       <mrow>
        <mo>|</mo>
        <mrow>
         <mrow>
          <mi>y</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>n</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mover accent="true">
           <mi>y</mi>
           <mo stretchy="false">^</mo>
          </mover>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>n</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>|</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mo>]</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo>[</mo>
      <msup>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <mi>e</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>p</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <abs></abs>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <ci>y</ci>
           <ci>n</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <ci>normal-^</ci>
            <ci>y</ci>
           </apply>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <abs></abs>
         <apply>
          <times></times>
          <ci>e</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{opt}=\frac{E\left[\left|y(n)-\hat{y}(n)\right|^{2}\right]}{E\left[|e(n)|^%
{2}\right]}
  </annotation>
 </semantics>
</math>

</p>

<p>The results above assume that the signals 

<math display="inline" id="Least_mean_squares_filter:92">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>v</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(n)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Least_mean_squares_filter:93">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(n)
  </annotation>
 </semantics>
</math>


 are uncorrelated to each other, which is generally the case in practice.</p>
<h3 id="proof">Proof</h3>

<p>Let the filter misalignment be defined as 

<math display="inline" id="Least_mean_squares_filter:94">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Λ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo>|</mo>
     <mrow>
      <mrow>
       <mi>𝐡</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mover accent="true">
        <mi>𝐡</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>|</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Λ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>𝐡</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <ci>normal-^</ci>
         <ci>𝐡</ci>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda(n)=\left|\mathbf{h}(n)-\hat{\mathbf{h}}(n)\right|^{2}
  </annotation>
 </semantics>
</math>

, we can derive the expected misalignment for the next sample as:</p>

<p>

<math display="block" id="Least_mean_squares_filter:95">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mi mathvariant="normal">Λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo>[</mo>
     <msup>
      <mrow>
       <mo>|</mo>
       <mrow>
        <mrow>
         <mrow>
          <mover accent="true">
           <mi>𝐡</mi>
           <mo stretchy="false">^</mo>
          </mover>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>n</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>+</mo>
         <mfrac>
          <mrow>
           <mpadded width="+1.7pt">
            <mi>μ</mi>
           </mpadded>
           <msup>
            <mi>e</mi>
            <mo>*</mo>
           </msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
           </mrow>
           <mi>𝐱</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mrow>
           <msup>
            <mi>𝐱</mi>
            <mi>H</mi>
           </msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
           </mrow>
           <mi>𝐱</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mfrac>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>𝐡</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>normal-Λ</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <apply>
         <minus></minus>
         <apply>
          <plus></plus>
          <apply>
           <times></times>
           <apply>
            <ci>normal-^</ci>
            <ci>𝐡</ci>
           </apply>
           <ci>n</ci>
          </apply>
          <apply>
           <divide></divide>
           <apply>
            <times></times>
            <ci>μ</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>e</ci>
             <times></times>
            </apply>
            <ci>n</ci>
            <ci>𝐱</ci>
            <ci>n</ci>
           </apply>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>𝐱</ci>
             <ci>H</ci>
            </apply>
            <ci>n</ci>
            <ci>𝐱</ci>
            <ci>n</ci>
           </apply>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>𝐡</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\left[\Lambda(n+1)\right]=E\left[\left|\hat{\mathbf{h}}(n)+\frac{\mu\,e^{*}(n%
)\mathbf{x}(n)}{\mathbf{x}^{H}(n)\mathbf{x}(n)}-\mathbf{h}(n)\right|^{2}\right]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Least_mean_squares_filter:96">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mi mathvariant="normal">Λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo>[</mo>
     <msup>
      <mrow>
       <mo>|</mo>
       <mrow>
        <mrow>
         <mrow>
          <mover accent="true">
           <mi>𝐡</mi>
           <mo stretchy="false">^</mo>
          </mover>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>n</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>+</mo>
         <mfrac>
          <mrow>
           <mpadded width="+1.7pt">
            <mi>μ</mi>
           </mpadded>
           <mrow>
            <mo>(</mo>
            <mrow>
             <mrow>
              <mrow>
               <msup>
                <mi>v</mi>
                <mo>*</mo>
               </msup>
               <mrow>
                <mo stretchy="false">(</mo>
                <mi>n</mi>
                <mo stretchy="false">)</mo>
               </mrow>
              </mrow>
              <mo>+</mo>
              <mrow>
               <msup>
                <mi>y</mi>
                <mo>*</mo>
               </msup>
               <mrow>
                <mo stretchy="false">(</mo>
                <mi>n</mi>
                <mo stretchy="false">)</mo>
               </mrow>
              </mrow>
             </mrow>
             <mo>-</mo>
             <mrow>
              <msup>
               <mover accent="true">
                <mi>y</mi>
                <mo stretchy="false">^</mo>
               </mover>
               <mo>*</mo>
              </msup>
              <mrow>
               <mo stretchy="false">(</mo>
               <mi>n</mi>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
            </mrow>
            <mo>)</mo>
           </mrow>
           <mi>𝐱</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mrow>
           <msup>
            <mi>𝐱</mi>
            <mi>H</mi>
           </msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
           </mrow>
           <mi>𝐱</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mfrac>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>𝐡</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>normal-Λ</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <apply>
         <minus></minus>
         <apply>
          <plus></plus>
          <apply>
           <times></times>
           <apply>
            <ci>normal-^</ci>
            <ci>𝐡</ci>
           </apply>
           <ci>n</ci>
          </apply>
          <apply>
           <divide></divide>
           <apply>
            <times></times>
            <ci>μ</ci>
            <apply>
             <minus></minus>
             <apply>
              <plus></plus>
              <apply>
               <times></times>
               <apply>
                <csymbol cd="ambiguous">superscript</csymbol>
                <ci>v</ci>
                <times></times>
               </apply>
               <ci>n</ci>
              </apply>
              <apply>
               <times></times>
               <apply>
                <csymbol cd="ambiguous">superscript</csymbol>
                <ci>y</ci>
                <times></times>
               </apply>
               <ci>n</ci>
              </apply>
             </apply>
             <apply>
              <times></times>
              <apply>
               <csymbol cd="ambiguous">superscript</csymbol>
               <apply>
                <ci>normal-^</ci>
                <ci>y</ci>
               </apply>
               <times></times>
              </apply>
              <ci>n</ci>
             </apply>
            </apply>
            <ci>𝐱</ci>
            <ci>n</ci>
           </apply>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>𝐱</ci>
             <ci>H</ci>
            </apply>
            <ci>n</ci>
            <ci>𝐱</ci>
            <ci>n</ci>
           </apply>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>𝐡</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\left[\Lambda(n+1)\right]=E\left[\left|\hat{\mathbf{h}}(n)+\frac{\mu\,\left(v%
^{*}(n)+y^{*}(n)-\hat{y}^{*}(n)\right)\mathbf{x}(n)}{\mathbf{x}^{H}(n)\mathbf{%
x}(n)}-\mathbf{h}(n)\right|^{2}\right]
  </annotation>
 </semantics>
</math>

</p>

<p>Let 

<math display="inline" id="Least_mean_squares_filter:97">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>𝐡</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>𝐡</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>δ</ci>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-^</ci>
       <ci>𝐡</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>𝐡</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\delta}=\hat{\mathbf{h}}(n)-\mathbf{h}(n)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Least_mean_squares_filter:98">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>y</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <ci>normal-^</ci>
       <ci>y</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(n)=\hat{y}(n)-y(n)
  </annotation>
 </semantics>
</math>


</p>

<p>

<math display="block" id="Least_mean_squares_filter:99">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mi mathvariant="normal">Λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo>[</mo>
     <msup>
      <mrow>
       <mo>|</mo>
       <mrow>
        <mrow>
         <mi>δ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mfrac>
         <mrow>
          <mpadded width="+1.7pt">
           <mi>μ</mi>
          </mpadded>
          <mrow>
           <mo>(</mo>
           <mrow>
            <mrow>
             <mi>v</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>n</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo>+</mo>
            <mrow>
             <mi>r</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>n</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
           </mrow>
           <mo>)</mo>
          </mrow>
          <mi>𝐱</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>n</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mrow>
          <msup>
           <mi>𝐱</mi>
           <mi>H</mi>
          </msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>n</mi>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>𝐱</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>n</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mfrac>
       </mrow>
       <mo>|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>normal-Λ</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>δ</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <divide></divide>
          <apply>
           <times></times>
           <ci>μ</ci>
           <apply>
            <plus></plus>
            <apply>
             <times></times>
             <ci>v</ci>
             <ci>n</ci>
            </apply>
            <apply>
             <times></times>
             <ci>r</ci>
             <ci>n</ci>
            </apply>
           </apply>
           <ci>𝐱</ci>
           <ci>n</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>𝐱</ci>
            <ci>H</ci>
           </apply>
           <ci>n</ci>
           <ci>𝐱</ci>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\left[\Lambda(n+1)\right]=E\left[\left|\mathbf{\delta}(n)-\frac{\mu\,\left(v(%
n)+r(n)\right)\mathbf{x}(n)}{\mathbf{x}^{H}(n)\mathbf{x}(n)}\right|^{2}\right]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Least_mean_squares_filter:100">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mi mathvariant="normal">Λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo>[</mo>
     <mrow>
      <msup>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mrow>
          <mi>δ</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>n</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mfrac>
          <mrow>
           <mpadded width="+1.7pt">
            <mi>μ</mi>
           </mpadded>
           <mrow>
            <mo>(</mo>
            <mrow>
             <mrow>
              <mi>v</mi>
              <mrow>
               <mo stretchy="false">(</mo>
               <mi>n</mi>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
             <mo>+</mo>
             <mrow>
              <mi>r</mi>
              <mrow>
               <mo stretchy="false">(</mo>
               <mi>n</mi>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
            </mrow>
            <mo>)</mo>
           </mrow>
           <mi>𝐱</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mrow>
           <msup>
            <mi>𝐱</mi>
            <mi>H</mi>
           </msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
           </mrow>
           <mi>𝐱</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mfrac>
        </mrow>
        <mo>)</mo>
       </mrow>
       <mi>H</mi>
      </msup>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mrow>
         <mi>δ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mfrac>
         <mrow>
          <mpadded width="+1.7pt">
           <mi>μ</mi>
          </mpadded>
          <mrow>
           <mo>(</mo>
           <mrow>
            <mrow>
             <mi>v</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>n</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo>+</mo>
            <mrow>
             <mi>r</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>n</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
           </mrow>
           <mo>)</mo>
          </mrow>
          <mi>𝐱</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>n</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mrow>
          <msup>
           <mi>𝐱</mi>
           <mi>H</mi>
          </msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>n</mi>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>𝐱</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>n</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mfrac>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>normal-Λ</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>δ</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <divide></divide>
          <apply>
           <times></times>
           <ci>μ</ci>
           <apply>
            <plus></plus>
            <apply>
             <times></times>
             <ci>v</ci>
             <ci>n</ci>
            </apply>
            <apply>
             <times></times>
             <ci>r</ci>
             <ci>n</ci>
            </apply>
           </apply>
           <ci>𝐱</ci>
           <ci>n</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>𝐱</ci>
            <ci>H</ci>
           </apply>
           <ci>n</ci>
           <ci>𝐱</ci>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
        <ci>H</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>δ</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>μ</ci>
          <apply>
           <plus></plus>
           <apply>
            <times></times>
            <ci>v</ci>
            <ci>n</ci>
           </apply>
           <apply>
            <times></times>
            <ci>r</ci>
            <ci>n</ci>
           </apply>
          </apply>
          <ci>𝐱</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>𝐱</ci>
           <ci>H</ci>
          </apply>
          <ci>n</ci>
          <ci>𝐱</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\left[\Lambda(n+1)\right]=E\left[\left(\mathbf{\delta}(n)-\frac{\mu\,\left(v(%
n)+r(n)\right)\mathbf{x}(n)}{\mathbf{x}^{H}(n)\mathbf{x}(n)}\right)^{H}\left(%
\mathbf{\delta}(n)-\frac{\mu\,\left(v(n)+r(n)\right)\mathbf{x}(n)}{\mathbf{x}^%
{H}(n)\mathbf{x}(n)}\right)\right]
  </annotation>
 </semantics>
</math>

</p>

<p>Assuming independence, we have:</p>

<p>

<math display="block" id="Least_mean_squares_filter:101">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mi mathvariant="normal">Λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi mathvariant="normal">Λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo>[</mo>
       <mrow>
        <msup>
         <mrow>
          <mo>(</mo>
          <mfrac>
           <mrow>
            <mpadded width="+1.7pt">
             <mi>μ</mi>
            </mpadded>
            <mrow>
             <mo>(</mo>
             <mrow>
              <mrow>
               <mi>v</mi>
               <mrow>
                <mo stretchy="false">(</mo>
                <mi>n</mi>
                <mo stretchy="false">)</mo>
               </mrow>
              </mrow>
              <mo>-</mo>
              <mrow>
               <mi>r</mi>
               <mrow>
                <mo stretchy="false">(</mo>
                <mi>n</mi>
                <mo stretchy="false">)</mo>
               </mrow>
              </mrow>
             </mrow>
             <mo>)</mo>
            </mrow>
            <mi>𝐱</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>n</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mrow>
            <msup>
             <mi>𝐱</mi>
             <mi>H</mi>
            </msup>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>n</mi>
             <mo stretchy="false">)</mo>
            </mrow>
            <mi>𝐱</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>n</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mfrac>
          <mo>)</mo>
         </mrow>
         <mi>H</mi>
        </msup>
        <mrow>
         <mo>(</mo>
         <mfrac>
          <mrow>
           <mpadded width="+1.7pt">
            <mi>μ</mi>
           </mpadded>
           <mrow>
            <mo>(</mo>
            <mrow>
             <mrow>
              <mi>v</mi>
              <mrow>
               <mo stretchy="false">(</mo>
               <mi>n</mi>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
             <mo>-</mo>
             <mrow>
              <mi>r</mi>
              <mrow>
               <mo stretchy="false">(</mo>
               <mi>n</mi>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
            </mrow>
            <mo>)</mo>
           </mrow>
           <mi>𝐱</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mrow>
           <msup>
            <mi>𝐱</mi>
            <mi>H</mi>
           </msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
           </mrow>
           <mi>𝐱</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mfrac>
         <mo>)</mo>
        </mrow>
       </mrow>
       <mo>]</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <mi>E</mi>
     <mrow>
      <mo>[</mo>
      <mfrac>
       <mrow>
        <mi>μ</mi>
        <msup>
         <mrow>
          <mo stretchy="false">|</mo>
          <mrow>
           <mi>r</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo stretchy="false">|</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mrow>
       <mrow>
        <msup>
         <mi>𝐱</mi>
         <mi>H</mi>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>𝐱</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>normal-Λ</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>normal-Λ</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>E</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <divide></divide>
           <apply>
            <times></times>
            <ci>μ</ci>
            <apply>
             <minus></minus>
             <apply>
              <times></times>
              <ci>v</ci>
              <ci>n</ci>
             </apply>
             <apply>
              <times></times>
              <ci>r</ci>
              <ci>n</ci>
             </apply>
            </apply>
            <ci>𝐱</ci>
            <ci>n</ci>
           </apply>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>𝐱</ci>
             <ci>H</ci>
            </apply>
            <ci>n</ci>
            <ci>𝐱</ci>
            <ci>n</ci>
           </apply>
          </apply>
          <ci>H</ci>
         </apply>
         <apply>
          <divide></divide>
          <apply>
           <times></times>
           <ci>μ</ci>
           <apply>
            <minus></minus>
            <apply>
             <times></times>
             <ci>v</ci>
             <ci>n</ci>
            </apply>
            <apply>
             <times></times>
             <ci>r</ci>
             <ci>n</ci>
            </apply>
           </apply>
           <ci>𝐱</ci>
           <ci>n</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>𝐱</ci>
            <ci>H</ci>
           </apply>
           <ci>n</ci>
           <ci>𝐱</ci>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>μ</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <abs></abs>
           <apply>
            <times></times>
            <ci>r</ci>
            <ci>n</ci>
           </apply>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>𝐱</ci>
          <ci>H</ci>
         </apply>
         <ci>n</ci>
         <ci>𝐱</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\left[\Lambda(n+1)\right]=\Lambda(n)+E\left[\left(\frac{\mu\,\left(v(n)-r(n)%
\right)\mathbf{x}(n)}{\mathbf{x}^{H}(n)\mathbf{x}(n)}\right)^{H}\left(\frac{%
\mu\,\left(v(n)-r(n)\right)\mathbf{x}(n)}{\mathbf{x}^{H}(n)\mathbf{x}(n)}%
\right)\right]-2E\left[\frac{\mu|r(n)|^{2}}{\mathbf{x}^{H}(n)\mathbf{x}(n)}\right]
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Least_mean_squares_filter:102">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mi mathvariant="normal">Λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi mathvariant="normal">Λ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mfrac>
      <mrow>
       <msup>
        <mi>μ</mi>
        <mn>2</mn>
       </msup>
       <mi>E</mi>
       <mrow>
        <mo>[</mo>
        <msup>
         <mrow>
          <mo stretchy="false">|</mo>
          <mrow>
           <mi>e</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo stretchy="false">|</mo>
         </mrow>
         <mn>2</mn>
        </msup>
        <mo>]</mo>
       </mrow>
      </mrow>
      <mrow>
       <msup>
        <mi>𝐱</mi>
        <mi>H</mi>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>𝐱</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mn>2</mn>
      <mi>μ</mi>
      <mi>E</mi>
      <mrow>
       <mo>[</mo>
       <msup>
        <mrow>
         <mo stretchy="false">|</mo>
         <mrow>
          <mi>r</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>n</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">|</mo>
        </mrow>
        <mn>2</mn>
       </msup>
       <mo>]</mo>
      </mrow>
     </mrow>
     <mrow>
      <msup>
       <mi>𝐱</mi>
       <mi>H</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>𝐱</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>normal-Λ</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>normal-Λ</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>μ</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>E</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <abs></abs>
           <apply>
            <times></times>
            <ci>e</ci>
            <ci>n</ci>
           </apply>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝐱</ci>
         <ci>H</ci>
        </apply>
        <ci>n</ci>
        <ci>𝐱</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>μ</ci>
       <ci>E</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <abs></abs>
          <apply>
           <times></times>
           <ci>r</ci>
           <ci>n</ci>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐱</ci>
        <ci>H</ci>
       </apply>
       <ci>n</ci>
       <ci>𝐱</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\left[\Lambda(n+1)\right]=\Lambda(n)+\frac{\mu^{2}E\left[|e(n)|^{2}\right]}{%
\mathbf{x}^{H}(n)\mathbf{x}(n)}-\frac{2\mu E\left[|r(n)|^{2}\right]}{\mathbf{x%
}^{H}(n)\mathbf{x}(n)}
  </annotation>
 </semantics>
</math>

</p>

<p>The optimal learning rate is found at 

<math display="inline" id="Least_mean_squares_filter:103">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>d</mi>
     <mi>E</mi>
     <mrow>
      <mo>[</mo>
      <mrow>
       <mi mathvariant="normal">Λ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>]</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>d</mi>
     <mi>μ</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>normal-Λ</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>μ</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{dE\left[\Lambda(n+1)\right]}{d\mu}=0
  </annotation>
 </semantics>
</math>


, which leads to:</p>

<p>

<math display="block" id="Least_mean_squares_filter:104">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>μ</mi>
     <mi>E</mi>
     <mrow>
      <mo>[</mo>
      <msup>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <mi>e</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mo>]</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <mi>E</mi>
     <mrow>
      <mo>[</mo>
      <msup>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <mi>r</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>μ</ci>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <abs></abs>
         <apply>
          <times></times>
          <ci>e</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <abs></abs>
         <apply>
          <times></times>
          <ci>r</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\mu E\left[|e(n)|^{2}\right]-2E\left[|r(n)|^{2}\right]=0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Least_mean_squares_filter:105">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo>[</mo>
      <msup>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <mi>r</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mo>]</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo>[</mo>
      <msup>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <mi>e</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>μ</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <abs></abs>
         <apply>
          <times></times>
          <ci>r</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <abs></abs>
         <apply>
          <times></times>
          <ci>e</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu=\frac{E\left[|r(n)|^{2}\right]}{E\left[|e(n)|^{2}\right]}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Recursive_least_squares" title="wikilink">Recursive least squares</a></li>
<li>For statistical techniques relevant to LMS filter see <a href="Least_squares" title="wikilink">Least squares</a>.</li>
<li><a href="Similarities_between_Wiener_and_LMS" title="wikilink">Similarities between Wiener and LMS</a></li>
<li><a href="Multidelay_block_frequency_domain_adaptive_filter" title="wikilink">Multidelay block frequency domain adaptive filter</a></li>
<li><a href="Zero_forcing_equalizer" title="wikilink">Zero forcing equalizer</a></li>
<li><a href="Kernel_adaptive_filter" title="wikilink">Kernel adaptive filter</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Monson H. Hayes: <em>Statistical Digital Signal Processing and Modeling,</em> Wiley, 1996, ISBN 0-471-59431-8</li>
<li>Simon Haykin: <em>Adaptive Filter Theory,</em> Prentice Hall, 2002, ISBN 0-13-048434-2</li>
<li>Simon S. Haykin, Bernard Widrow (Editor): <em>Least-Mean-Square Adaptive Filters,</em> Wiley, 2003, ISBN 0-471-21570-8</li>
<li>Bernard Widrow, Samuel D. Stearns: <em>Adaptive Signal Processing,</em> Prentice Hall, 1985, ISBN 0-13-004029-0</li>
<li>Weifeng Liu, Jose Principe and Simon Haykin: <em>Kernel Adaptive Filtering: A Comprehensive Introduction,</em> John Wiley, 2010, ISBN 0-470-44753-2</li>
<li>Paulo S.R. Diniz: <em>Adaptive Filtering: Algorithms and Practical Implementation,</em> Kluwer Academic Publishers, 1997, ISBN 0-7923-9912-9</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.antenna-theory.com/arrays/weights/lms.php">LMS Algorithm in Adaptive Antenna Arrays</a> www.antenna-theory.com</li>
<li><a href="http://www.advsolned.com/example_ale_nc.html">LMS Noise cancellation demo</a> www.advsolned.com</li>
</ul>

<p>"</p>

<p><a href="Category:Digital_signal_processing" title="wikilink">Category:Digital signal processing</a> <a href="Category:Filter_theory" title="wikilink">Category:Filter theory</a> <a href="Category:Stochastic_algorithms" title="wikilink">Category:Stochastic algorithms</a></p>
</body>
</html>
