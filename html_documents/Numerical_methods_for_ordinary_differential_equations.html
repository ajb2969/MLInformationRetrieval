<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1604">Numerical methods for ordinary differential equations</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Numerical methods for ordinary differential equations</h1>
<hr/>

<p> </p>

<p><strong>Numerical methods for ordinary differential equations</strong> are methods used to find <a href="Numerical_analysis" title="wikilink">numerical</a> approximations to the solutions of <a href="ordinary_differential_equation" title="wikilink">ordinary differential equations</a> (ODEs). Their use is also known as "<a href="numerical_integration" title="wikilink">numerical integration</a>", although this term is sometimes taken to mean the computation of <a href="integral" title="wikilink">integrals</a>.</p>

<p>Many differential equations cannot be solved using <a href="symbolic_computation" title="wikilink">symbolic computation</a> ("analysis"). For practical purposes, however – such as in engineering – a numeric approximation to the solution is often sufficient. The <a href="algorithm" title="wikilink">algorithms</a> studied here can be used to compute such an approximation. An alternative method is to use techniques from <a class="uri" href="calculus" title="wikilink">calculus</a> to obtain a <a href="series_expansion" title="wikilink">series expansion</a> of the solution.</p>

<p>Ordinary differential equations occur in many scientific disciplines, for instance in <a class="uri" href="physics" title="wikilink">physics</a>, <a class="uri" href="chemistry" title="wikilink">chemistry</a>, <a class="uri" href="biology" title="wikilink">biology</a>, and <a class="uri" href="economics" title="wikilink">economics</a>. In addition, some methods in <a href="numerical_partial_differential_equations" title="wikilink">numerical partial differential equations</a> convert the <a href="partial_differential_equation" title="wikilink">partial differential equation</a> into an ordinary differential equation, which must then be solved.</p>
<h2 id="the-problem">The problem</h2>

<p>A first-order differential equation is an <a href="Initial_value_problem" title="wikilink">Initial value problem</a> (IVP) of the form,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>y</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo>,</mo>
      <mrow>
       <mi>y</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>t</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mn>0</mn>
     </msub>
     <mo rspace="42.5pt">,</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>t</ci>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>t</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">1</cn>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}(t)=f(t,y(t)),\qquad y(t_{0})=y_{0},\qquad\qquad(1)
  </annotation>
 </semantics>
</math>

 where <em>f</em> is a function that maps [<em>t</em><sub>0</sub>,∞) × <strong>R</strong><sup>d</sup> to <strong>R</strong><sup>d</sup>, and the initial condition <em>y</em><sub>0</sub> ∈ <strong>R</strong><sup>d</sup> is a given vector. <em>First-order</em> means that only the first derivative of <em>y</em> appears in the equation, and higher derivatives are absent.</p>

<p>Without loss of generality to higher-order systems, we restrict ourselves to <em>first-order</em> differential equations, because a higher-order ODE can be converted into a larger system of first-order equations by introducing extra variables. For example, the second-order equation <em>y</em>'' = −<em>y</em> can be rewritten as two first-order equations: <em>y</em>' = <em>z</em> and <em>z</em>' = −<em>y</em>.</p>

<p>In this section, we describe numerical methods for IVPs, and remark that <em><a href="boundary_value_problem" title="wikilink">boundary value problems</a></em> (BVPs) require a different set of tools. In a BVP, one defines values, or components of the solution <em>y</em> at more than one point. Because of this, different methods need to be used to solve BVPs. For example, the <a href="shooting_method" title="wikilink">shooting method</a> (and its variants) or global methods like <a href="finite_difference" title="wikilink">finite differences</a>, <a href="Galerkin_method" title="wikilink">Galerkin methods</a>, or <a href="collocation_method" title="wikilink">collocation methods</a> are appropriate for that class of problems.</p>

<p>The <a href="Picard–Lindelöf_theorem" title="wikilink">Picard–Lindelöf theorem</a> states that there is a unique solution, provided <em>f</em> is <a href="Lipschitz_continuity" title="wikilink">Lipschitz-continuous</a>.</p>
<h2 id="methods">Methods</h2>

<p>Numerical methods for solving first-order IVPs often fall into one of two large categories: <a href="linear_multistep_method" title="wikilink">linear multistep methods</a>, or <a href="Runge-Kutta_methods" title="wikilink">Runge-Kutta methods</a>. A further division can be realized by dividing methods into those that are explicit and those that are implicit. For example, implicit <a href="linear_multistep_method" title="wikilink">linear multistep methods</a> include <a href="Linear_multistep_method#Adams–Moulton_methods" title="wikilink">Adams-Moulton methods</a>, and <a href="Backward_differentiation_formula" title="wikilink">backward differentiation methods</a> (BDF), whereas <a href="Runge-Kutta_methods#Implicit_Runge–Kutta_methods" title="wikilink">implicit Runge-Kutta methods</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> include <a href="diagonally_implicit_Runge-Kutta" title="wikilink">diagonally implicit Runge-Kutta</a> (DIRK), <a href="singly_diagonally_implicit_runge_kutta" title="wikilink">singly diagonally implicit runge kutta</a> (SDIRK), and <a class="uri" href="Gauss-Radau" title="wikilink">Gauss-Radau</a> (based on <a href="Gaussian_quadrature" title="wikilink">Gaussian quadrature</a>) numerical methods. Explicit examples from the <a href="Linear_multistep_method" title="wikilink">linear multistep family</a> include the <a href="Linear_multistep_method#Adams–Bashforth_methods" title="wikilink">Adams-Bashforth methods</a>, and any Runge-Kutta method with a lower diagonal <a href="Butcher_tableau" title="wikilink">Butcher tableau</a> is <a href="List_of_Runge–Kutta_methods#Explicit_methods" title="wikilink">explicit</a>. A loose rule of thumb dictates that <em>stiff</em> differential equations require the use of implicit schemes, whereas non-stiff problems can be solved more efficiently with explicit schemes.</p>

<p>The so-called <a href="general_linear_methods" title="wikilink">general linear methods</a> (GLMs) are a generalization of the above two large classes of methods.</p>
<h3 id="euler-method">Euler method</h3>

<p>From any point on a curve, you can find an approximation of a nearby point on the curve by moving a short distance along a line <a class="uri" href="tangent" title="wikilink">tangent</a> to the curve.</p>

<p>Starting with the differential equation (1), we replace the derivative <em>y</em>' by the <a href="finite_difference" title="wikilink">finite difference</a> approximation</p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:1">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>y</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mrow>
       <mi>y</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>t</mi>
         <mo>+</mo>
         <mi>h</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>y</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mi>h</mi>
    </mfrac>
    <mo rspace="42.5pt">,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <list>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>y</ci>
        <apply>
         <plus></plus>
         <ci>t</ci>
         <ci>h</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <ci>h</ci>
     </apply>
     <cn type="integer">2</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}(t)\approx\frac{y(t+h)-y(t)}{h},\qquad\qquad(2)
  </annotation>
 </semantics>
</math>

 which when re-arranged yields the following formula</p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>+</mo>
       <mi>h</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≈</mo>
    <mrow>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>h</mi>
      <msup>
       <mi>y</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <ci>h</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(t+h)\approx y(t)+hy^{\prime}(t)\qquad\qquad
  </annotation>
 </semantics>
</math>

 and using (1) gives:</p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:3">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo>+</mo>
    <mi>h</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≈</mo>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>h</mi>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>3</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <plus></plus>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <approx></approx>
    <csymbol cd="unknown">y</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">h</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">y</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <ci>italic-</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">3</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(t+h)\approx y(t)+hf(t,y(t)).\qquad\qquad(3)
  </annotation>
 </semantics>
</math>

 This formula is usually applied in the following way. We choose a step size <em>h</em>, and we construct the sequence <em>t</em><sub>0</sub>, <em>t</em><sub>1</sub> = <em>t</em><sub>0</sub> + <em>h</em>, <em>t</em><sub>2</sub> = <em>t</em><sub>0</sub> + 2<em>h</em>, … We denote by <em>y</em><sub><em>n</em></sub> a numerical estimate of the exact solution <em>y</em>(<em>t</em><sub><em>n</em></sub>). Motivated by (3), we compute these estimates by the following <a href="recursion" title="wikilink">recursive</a> scheme</p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:4">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>y</mi>
    <mi>n</mi>
   </msub>
   <mo>+</mo>
   <mi>h</mi>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mi>n</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>4</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
    <plus></plus>
    <csymbol cd="unknown">h</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <ci>italic-</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">4</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+1}=y_{n}+hf(t_{n},y_{n}).\qquad\qquad(4)
  </annotation>
 </semantics>
</math>

 This is the <em><a href="Euler_method" title="wikilink">Euler method</a></em> (or <em><a href="forward_Euler_method" title="wikilink">forward Euler method</a></em>, in contrast with the <em>backward Euler method</em>, to be described below). The method is named after <a href="Leonhard_Euler" title="wikilink">Leonhard Euler</a> who described it in 1768.</p>

<p>The Euler method is an example of an <a href="explicit_and_implicit_methods" title="wikilink"><em>explicit</em></a> method. This means that the new value <em>y</em><sub><em>n+1</em></sub> is defined in terms of things that are already known, like <em>y</em><sub><em>n</em></sub>.</p>
<h3 id="backward-euler-method">Backward Euler method</h3>

<p>If, instead of (2), we use the approximation</p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:5">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>y</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mrow>
       <mi>y</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>y</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>t</mi>
         <mo>-</mo>
         <mi>h</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mi>h</mi>
    </mfrac>
    <mo rspace="42.5pt">,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>5</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <list>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <ci>y</ci>
        <apply>
         <minus></minus>
         <ci>t</ci>
         <ci>h</ci>
        </apply>
       </apply>
      </apply>
      <ci>h</ci>
     </apply>
     <cn type="integer">5</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}(t)\approx\frac{y(t)-y(t-h)}{h},\qquad\qquad(5)
  </annotation>
 </semantics>
</math>

 we get the <em>backward Euler method</em>:</p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:6">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>y</mi>
    <mi>n</mi>
   </msub>
   <mo>+</mo>
   <mi>h</mi>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>6</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
    <plus></plus>
    <csymbol cd="unknown">h</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <ci>italic-</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">6</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+1}=y_{n}+hf(t_{n+1},y_{n+1}).\qquad\qquad(6)
  </annotation>
 </semantics>
</math>

 The backward Euler method is an <a href="explicit_and_implicit_methods" title="wikilink"><em>implicit</em></a> method, meaning that we have to solve an equation to find <em>y</em><sub><em>n</em>+1</sub>. One often uses <a href="fixed_point_iteration" title="wikilink">fixed point iteration</a> or (some modification of) the <a href="Newton's_method" title="wikilink">Newton–Raphson method</a> to achieve this.</p>

<p>It costs more time to solve this equation than explicit methods; this cost must be taken into consideration when one selects the method to use. The advantage of implicit methods such as (6) is that they are usually more stable for solving a <a href="stiff_equation" title="wikilink">stiff equation</a>, meaning that a larger step size <em>h</em> can be used.</p>
<h3 id="first-order-exponential-integrator-method">First-order exponential integrator method</h3>

<p>Exponential integrators describe a large class of integrators that have recently seen a lot of development.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> They date back to at least the 1960s.</p>

<p>In place of (1), we assume the differential equation is either of the form</p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:7">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>y</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mpadded width="+1.7pt">
        <mi>A</mi>
       </mpadded>
       <mi>y</mi>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi class="ltx_font_mathcaligraphic">𝒩</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="62.5pt">,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>7</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <list>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>y</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>𝒩</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <cn type="integer">7</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}(t)=-A\,y+\mathcal{N}(y),\qquad\qquad\qquad(7)
  </annotation>
 </semantics>
</math>

 or it has been locally linearize about a background state to produce a linear term 

<math display="inline" id="Numerical_methods_for_ordinary_differential_equations:8">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mrow>
    <mi>A</mi>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -Ay
  </annotation>
 </semantics>
</math>

 and a nonlinear term 

<math display="inline" id="Numerical_methods_for_ordinary_differential_equations:9">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒩</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}(y)
  </annotation>
 </semantics>
</math>

.</p>

<p>Exponential integrators are constructed by multiplying (7) by 

<math display="inline" id="Numerical_methods_for_ordinary_differential_equations:10">
 <semantics>
  <msup>
   <mi>e</mi>
   <mrow>
    <mi>A</mi>
    <mi>t</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>e</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{At}
  </annotation>
 </semantics>
</math>

, and exactly integrating the result over a time interval 

<math display="inline" id="Numerical_methods_for_ordinary_differential_equations:11">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>t</mi>
      <mi>n</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>t</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>t</mi>
      <mi>n</mi>
     </msub>
     <mo>+</mo>
     <mi>h</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </list>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>n</ci>
      </apply>
      <ci>h</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [t_{n},t_{n+1}=t_{n}+h]
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>e</mi>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>A</mi>
         <mi>h</mi>
        </mrow>
       </mrow>
      </msup>
      <msub>
       <mi>y</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mn>0</mn>
       <mi>h</mi>
      </msubsup>
      <mrow>
       <msup>
        <mi>e</mi>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>h</mi>
            <mo>-</mo>
            <mi>τ</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>A</mi>
         </mrow>
        </mrow>
       </msup>
       <mi class="ltx_font_mathcaligraphic">𝒩</mi>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mi>y</mi>
         <mrow>
          <mo>(</mo>
          <mrow>
           <msub>
            <mi>t</mi>
            <mi>n</mi>
           </msub>
           <mo>+</mo>
           <mi>τ</mi>
          </mrow>
          <mo>)</mo>
         </mrow>
        </mrow>
        <mo rspace="4.2pt">)</mo>
       </mrow>
       <mi>d</mi>
       <mi>τ</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>h</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <cn type="integer">0</cn>
       </apply>
       <ci>h</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <minus></minus>
           <ci>h</ci>
           <ci>τ</ci>
          </apply>
          <ci>A</ci>
         </apply>
        </apply>
       </apply>
       <ci>𝒩</ci>
       <apply>
        <times></times>
        <ci>y</ci>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>t</ci>
          <ci>n</ci>
         </apply>
         <ci>τ</ci>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>τ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+1}=e^{-Ah}y_{n}+\int_{0}^{h}e^{-(h-\tau)A}\mathcal{N}\left(y\left(t_{n}+%
\tau\right)\right)\,d\tau.
  </annotation>
 </semantics>
</math>

 This approximation is exact, but it doesn't define the integral.</p>

<p>The first-order exponential integrator can be realized by holding 

<math display="inline" id="Numerical_methods_for_ordinary_differential_equations:13">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>t</mi>
        <mi>n</mi>
       </msub>
       <mo>+</mo>
       <mi>τ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒩</ci>
    <apply>
     <times></times>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>n</ci>
      </apply>
      <ci>τ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{N}(y(t_{n}+\tau))
  </annotation>
 </semantics>
</math>

 constant over the full interval:</p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:14">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>A</mi>
      <mi>h</mi>
     </mrow>
    </mrow>
   </msup>
   <msub>
    <mi>y</mi>
    <mi>n</mi>
   </msub>
   <mo>+</mo>
   <msup>
    <mi>A</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>-</mo>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>A</mi>
       <mi>h</mi>
      </mrow>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>t</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>8</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>h</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>h</ci>
       </apply>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">N</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>n</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <ci>italic-</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">8</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+1}=e^{-Ah}y_{n}+A^{-1}(1-e^{-Ah})\mathcal{N}(y(t_{n}))\ .\qquad\qquad(8)
  </annotation>
 </semantics>
</math>

</p>
<h3 id="generalizations">Generalizations</h3>

<p>The Euler method is often not accurate enough. In more precise terms, it only has order one (the concept of <em>order</em> is explained below). This caused mathematicians to look for higher-order methods.</p>

<p>One possibility is to use not only the previously computed value <em>y</em><sub><em>n</em></sub> to determine <em>y</em><sub><em>n</em>+1</sub>, but to make the solution depend on more past values. This yields a so-called <em>multistep method</em>. Perhaps the simplest is the <a href="Leapfrog_method" title="wikilink">Leapfrog method</a> which is second order and (roughly speaking) relies on two time values.</p>

<p>Almost all practical multistep methods fall within the family of <a href="linear_multistep_method" title="wikilink">linear multistep methods</a>, which have the form</p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>α</mi>
     <mi>k</mi>
    </msub>
    <msub>
     <mi>y</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mi>k</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msub>
     <mi>α</mi>
     <mrow>
      <mi>k</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <msub>
     <mi>y</mi>
     <mrow>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mi>k</mi>
      </mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
   <mo>+</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>+</mo>
   <mrow>
    <msub>
     <mi>α</mi>
     <mn>0</mn>
    </msub>
    <msub>
     <mi>y</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{k}y_{n+k}+\alpha_{k-1}y_{n+k-1}+\cdots+\alpha_{0}y_{n}
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd><math> = h \left[ \beta_k f(t_{n+k},y_{n+k}) + \beta_{k-1}
</math></dd>
</dl>
</dd>
</dl>

<p>f(t_{n+k-1},y_{n+k-1}) + \cdots + \beta_0 f(t_n,y_n) \right]. </p>

<p>Another possibility is to use more points in the interval [<em>t</em><sub><em>n</em></sub>,<em>t</em><sub><em>n</em>+1</sub>]. This leads to the family of <a href="Runge–Kutta_method" title="wikilink">Runge–Kutta methods</a>, named after <a href="Carl_David_Tolmé_Runge" title="wikilink">Carl Runge</a> and <a href="Martin_Wilhelm_Kutta" title="wikilink">Martin Kutta</a>. One of their fourth-order methods is especially popular.</p>
<h3 id="advanced-features">Advanced features</h3>

<p>A good implementation of one of these methods for solving an ODE entails more than the time-stepping formula.</p>

<p>It is often inefficient to use the same step size all the time, so <em>variable step-size methods</em> have been developed. Usually, the step size is chosen such that the (local) error per step is below some tolerance level. This means that the methods must also compute an <em>error indicator</em>, an estimate of the local error.</p>

<p>An extension of this idea is to choose dynamically between different methods of different orders (this is called a <em>variable order method</em>). Methods based on <a href="Richardson_extrapolation" title="wikilink">Richardson extrapolation</a>, such as the <a href="Bulirsch–Stoer_algorithm" title="wikilink">Bulirsch–Stoer algorithm</a>, are often used to construct various methods of different orders.</p>

<p>Other desirable features include:</p>
<ul>
<li><em>dense output</em>: cheap numerical approximations for the whole integration interval, and not only at the points <em>t</em><sub>0</sub>, <em>t</em><sub>1</sub>, <em>t</em><sub>2</sub>, ...</li>
<li><em>event location</em>: finding the times where, say, a particular function vanishes. This typically requires the use of a <a href="root-finding_algorithm" title="wikilink">root-finding algorithm</a>.</li>
<li>support for <a href="parallel_computing" title="wikilink">parallel computing</a>.</li>
<li>when used for integrating with respect to time, time reversibility</li>
</ul>
<h3 id="alternative-methods">Alternative methods</h3>

<p>Many methods do not fall within the framework discussed here. Some classes of alternative methods are:</p>
<ul>
<li><em>multiderivative methods</em>, which use not only the function <em>f</em> but also its derivatives. This class includes <em>Hermite–Obreschkoff methods</em> and <em><a href="Runge–Kutta–Fehlberg_method" title="wikilink">Fehlberg methods</a></em>, as well as methods like the <a href="Parker–Sochacki_method" title="wikilink">Parker–Sochacki method</a> or <a href="Bychkov-Scherbakov_method" title="wikilink">Bychkov-Scherbakov method</a>, which compute the coefficients of the <a href="Taylor_series" title="wikilink">Taylor series</a> of the solution <em>y</em> recursively.</li>
<li><em>methods for second order ODEs</em>. We said that all higher-order ODEs can be transformed to first-order ODEs of the form (1). While this is certainly true, it may not be the best way to proceed. In particular, <em><a href="Nyström_method" title="wikilink">Nyström methods</a></em> work directly with second-order equations.</li>
<li><em><a href="geometric_integrator" title="wikilink">geometric integration methods</a></em> are especially designed for special classes of ODEs (e.g., <a href="symplectic_integrator" title="wikilink">symplectic integrators</a> for the solution of <a href="Hamiltonian_mechanics" title="wikilink">Hamiltonian equations</a>). They take care that the numerical solution respects the underlying structure or geometry of these classes.</li>
<li><em><a href="Quantized_State_Systems_Methods" title="wikilink">Quantized State Systems Methods</a></em> are a family of ODE integration methods based on the idea of state quantization. They are efficient when simulating sparse systems with frequent discontinuities.</li>
</ul>
<h2 id="analysis">Analysis</h2>

<p><a href="Numerical_analysis" title="wikilink">Numerical analysis</a> is not only the design of numerical methods, but also their analysis. Three central concepts in this analysis are:</p>
<ul>
<li><em>convergence</em>: whether the method approximates the solution,</li>
<li><em>order</em>: how well it approximates the solution, and</li>
<li><a href="numerical_stability" title="wikilink"><em>stability</em></a>: whether errors are damped out.</li>
</ul>
<h3 id="convergence">Convergence</h3>

<p>A numerical method is said to be <em>convergent</em> if the numerical solution approaches the exact solution as the step size <em>h</em> goes to 0. More precisely, we require that for every ODE (1) with a <a href="Lipschitz_continuous" title="wikilink">Lipschitz</a> function <em>f</em> and every <em>t</em><sup>*</sup> &gt; 0,</p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:16">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo movablelimits="false">lim</mo>
     <mrow>
      <mi>h</mi>
      <mo>→</mo>
      <mrow>
       <mn>0</mn>
       <mo>+</mo>
      </mrow>
     </mrow>
    </munder>
    <mrow>
     <munder>
      <mi>max</mi>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mrow>
        <mn>0</mn>
        <mo>,</mo>
        <mn>1</mn>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <mrow>
         <mo stretchy="false">⌊</mo>
         <mrow>
          <msup>
           <mi>t</mi>
           <mo>*</mo>
          </msup>
          <mo>/</mo>
          <mi>h</mi>
         </mrow>
         <mo stretchy="false">⌋</mo>
        </mrow>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mrow>
         <mi>n</mi>
         <mo>,</mo>
         <mi>h</mi>
        </mrow>
       </msub>
       <mo>-</mo>
       <mrow>
        <mi>y</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>t</mi>
          <mi>n</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>∥</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>h</ci>
       <apply>
        <csymbol cd="latexml">limit-from</csymbol>
        <cn type="integer">0</cn>
        <plus></plus>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <list>
         <cn type="integer">0</cn>
         <cn type="integer">1</cn>
         <ci>normal-…</ci>
         <apply>
          <floor></floor>
          <apply>
           <divide></divide>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>t</ci>
            <times></times>
           </apply>
           <ci>h</ci>
          </apply>
         </apply>
        </list>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <list>
          <ci>n</ci>
          <ci>h</ci>
         </list>
        </apply>
        <apply>
         <times></times>
         <ci>y</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>t</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim_{h\to 0+}\max_{n=0,1,\dots,\lfloor t^{*}/h\rfloor}\|y_{n,h}-y(t_{n})\|=0.
  </annotation>
 </semantics>
</math>

</p>

<p>All the methods mentioned above are convergent. In fact, a numerical scheme has to be convergent to be of any use.</p>
<h3 id="consistency-and-order">Consistency and order</h3>

<p>Suppose the numerical method is</p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:17">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mi>k</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi mathvariant="normal">Ψ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>t</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mi>k</mi>
       </mrow>
      </msub>
      <mo>;</mo>
      <msub>
       <mi>y</mi>
       <mi>n</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mrow>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mi>k</mi>
        </mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>;</mo>
      <mi>h</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Ψ</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <apply>
        <minus></minus>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <ci>k</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>h</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{n+k}=\Psi(t_{n+k};y_{n},y_{n+1},\dots,y_{n+k-1};h).\,
  </annotation>
 </semantics>
</math>

</p>

<p>The <em>local (truncation) error</em> of the method is the error committed by one step of the method. That is, it is the difference between the result given by the method, assuming that no error was made in earlier steps, and the exact solution:</p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:18">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>δ</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mi>k</mi>
     </mrow>
     <mi>h</mi>
    </msubsup>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi mathvariant="normal">Ψ</mi>
      <mrow>
       <mo>(</mo>
       <msub>
        <mi>t</mi>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mi>k</mi>
        </mrow>
       </msub>
       <mo>;</mo>
       <mrow>
        <mi>y</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>t</mi>
          <mi>n</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>y</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>t</mi>
          <mrow>
           <mi>n</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <mrow>
        <mi>y</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>t</mi>
          <mrow>
           <mrow>
            <mi>n</mi>
            <mo>+</mo>
            <mi>k</mi>
           </mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>;</mo>
       <mi>h</mi>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mi>k</mi>
        </mrow>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>δ</ci>
      <ci>h</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>normal-Ψ</ci>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>y</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>y</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <times></times>
        <ci>y</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <apply>
          <minus></minus>
          <apply>
           <plus></plus>
           <ci>n</ci>
           <ci>k</ci>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <ci>h</ci>
      </list>
     </apply>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta^{h}_{n+k}=\Psi\left(t_{n+k};y(t_{n}),y(t_{n+1}),\dots,y(t_{n+k-1});h%
\right)-y(t_{n+k}).
  </annotation>
 </semantics>
</math>

</p>

<p>The method is said to be <em>consistent</em> if</p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:19">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo movablelimits="false">lim</mo>
     <mrow>
      <mi>h</mi>
      <mo>→</mo>
      <mn>0</mn>
     </mrow>
    </munder>
    <mfrac>
     <msubsup>
      <mi>δ</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mi>k</mi>
      </mrow>
      <mi>h</mi>
     </msubsup>
     <mi>h</mi>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>h</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>δ</ci>
        <ci>h</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <ci>h</ci>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim_{h\to 0}\frac{\delta^{h}_{n+k}}{h}=0.
  </annotation>
 </semantics>
</math>

 The method has <em>order</em> 

<math display="inline" id="Numerical_methods_for_ordinary_differential_equations:20">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 if</p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:21">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>δ</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mi>k</mi>
     </mrow>
     <mi>h</mi>
    </msubsup>
    <mo>=</mo>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>h</mi>
       <mrow>
        <mi>p</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mtext>as</mtext>
     <mi>h</mi>
    </mrow>
    <mo>→</mo>
    <mn>0.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>δ</ci>
       <ci>h</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <apply>
        <plus></plus>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <mtext>as</mtext>
      <ci>h</ci>
     </apply>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta^{h}_{n+k}=O(h^{p+1})\quad\mbox{as }h\to 0.
  </annotation>
 </semantics>
</math>

 Hence a method is consistent if it has an order greater than 0. The (forward) Euler method (4) and the backward Euler method (6) introduced above both have order 1, so they are consistent. Most methods being used in practice attain higher order. Consistency is a necessary condition for convergence, but not sufficient; for a method to be convergent, it must be both consistent and <a class="uri" href="zero-stable" title="wikilink">zero-stable</a>.</p>

<p>A related concept is the <em>global (truncation) error</em>, the error sustained in all the steps one needs to reach a fixed time <em>t</em>. Explicitly, the global error at time <em>t</em> is <em>y</em><sub><em>N</em></sub> − <em>y</em>(<em>t</em>) where <em>N</em> = (<em>t</em>−<em>t</em><sub>0</sub>)/<em>h</em>. The global error of a <em>p</em>th order one-step method is O(<em>h</em><sup><em>p</em></sup>); in particular, such a method is convergent. This statement is not necessarily true for multi-step methods.</p>
<h3 id="stability-and-stiffness">Stability and stiffness</h3>

<p>For some differential equations, application of standard methods —such as the Euler method, explicit <a href="Runge–Kutta_methods" title="wikilink">Runge–Kutta methods</a>, or <a href="multistep_method" title="wikilink">multistep methods</a> (e.g., Adams–Bashforth methods)— exhibit instability in the solutions, though other methods may produce stable solutions. This "difficult behaviour" in the equation (which may not necessarily be complex itself) is described as <em>stiffness</em>, and is often caused by the presence of different time scales in the underlying problem. For example, a collision in a mechanical system like in an <a href="impact_oscillator" title="wikilink">impact oscillator</a> typically occurs at much smaller time scale than the time for the motion of objects; this discrepancy makes for very "sharp turns" in the curves of the state parameters.</p>

<p>Stiff problems are ubiquitous in <a href="chemical_kinetics" title="wikilink">chemical kinetics</a>, <a href="control_theory" title="wikilink">control theory</a>, <a href="solid_mechanics" title="wikilink">solid mechanics</a>, <a href="weather_forecasting" title="wikilink">weather forecasting</a>, <a class="uri" href="biology" title="wikilink">biology</a>, <a href="plasma_physics" title="wikilink">plasma physics</a>, and <a class="uri" href="electronics" title="wikilink">electronics</a>. One way to overcome stiffness is to extend the notion of differential equation to that of <a href="differential_inclusion" title="wikilink">differential inclusion</a>, which allows for and models non-smoothness.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="history">History</h2>

<p>Below is a <a href="Chronology" title="wikilink">timeline</a> of some important developments in this field.</p>
<ul>
<li>1768 - <a href="Leonhard_Euler" title="wikilink">Leonhard Euler</a> publishes his method.</li>
<li>1824 - <a href="Augustin_Louis_Cauchy" title="wikilink">Augustin Louis Cauchy</a> proves convergence of the Euler method. In this proof, Cauchy uses the implicit Euler method.</li>
<li>1855 - First mention of the <a href="multistep_method" title="wikilink">multistep methods</a> of <a href="John_Couch_Adams" title="wikilink">John Couch Adams</a> in a letter written by <a href="F._Bashforth" title="wikilink">F. Bashforth</a>.</li>
<li>1895 - <a href="Carl_David_Tolmé_Runge" title="wikilink">Carl Runge</a> publishes the first <a href="Runge–Kutta_method" title="wikilink">Runge–Kutta method</a>.</li>
<li>1905 - <a href="Martin_Wilhelm_Kutta" title="wikilink">Martin Kutta</a> describes the popular fourth-order <a href="Runge–Kutta_method" title="wikilink">Runge–Kutta method</a>.</li>
<li>1910 - <a href="Lewis_Fry_Richardson" title="wikilink">Lewis Fry Richardson</a> announces his <a href="extrapolation_method" title="wikilink">extrapolation method</a>, <a href="Richardson_extrapolation" title="wikilink">Richardson extrapolation</a>.</li>
<li>1952 - <a href="Charles_F._Curtiss" title="wikilink">Charles F. Curtiss</a> and <a href="Joseph_Oakland_Hirschfelder" title="wikilink">Joseph Oakland Hirschfelder</a> coin the term <em><a href="stiff_equation" title="wikilink">stiff equations</a></em>.</li>
<li>1963 - <a href="Germund_Dahlquist" title="wikilink">Germund Dahlquist</a> introduces <em><a href="Stiff_equation#A-stability" title="wikilink">A-stability</a></em> of integration methods.</li>
</ul>
<h2 id="numerical-solutions-to-second-order-one-dimensional-boundary-value-problems">Numerical solutions to second-order one-dimensional boundary value problems</h2>

<p>Boundary value problems (BVPs) are usually solved numerically by solving an approximately equivalent matrix problem obtained by discretizing the original BVP. The most commonly used method for numerically solving BVPs in one dimension is called the <a href="Finite_Difference_Method" title="wikilink">Finite Difference Method</a>. This method takes advantage of linear combinations of point values to construct <a href="finite_difference_coefficient" title="wikilink">finite difference coefficients</a> that describe derivatives of the function. For example, the second-order <a href="central_difference" title="wikilink">central difference</a> approximation to the first derivative is given by:</p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:22">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <msub>
       <mi>u</mi>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>u</mi>
       <mrow>
        <mi>i</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <mrow>
      <mn>2</mn>
      <mi>h</mi>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>u</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi class="ltx_font_mathcaligraphic">𝒪</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>h</mi>
        <mn>2</mn>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>h</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>u</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>𝒪</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{u_{i+1}-u_{i-1}}{2h}=u^{\prime}(x_{i})+\mathcal{O}(h^{2}),
  </annotation>
 </semantics>
</math>

</p>

<p>and the second-order <a href="central_difference" title="wikilink">central difference</a> for the second derivative is given by:</p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:23">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <mrow>
       <msub>
        <mi>u</mi>
        <mrow>
         <mi>i</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mo>-</mo>
       <mrow>
        <mn>2</mn>
        <msub>
         <mi>u</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mrow>
      <mo>+</mo>
      <msub>
       <mi>u</mi>
       <mrow>
        <mi>i</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <msup>
      <mi>h</mi>
      <mn>2</mn>
     </msup>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>u</mi>
       <mi>′′</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi class="ltx_font_mathcaligraphic">𝒪</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>h</mi>
        <mn>2</mn>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>h</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>u</ci>
       <ci>′′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>𝒪</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>h</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{u_{i+1}-2u_{i}+u_{i-1}}{h^{2}}=u^{\prime\prime}(x_{i})+\mathcal{O}(h^{2}).
  </annotation>
 </semantics>
</math>

</p>

<p>In both of these formulae, 

<math display="inline" id="Numerical_methods_for_ordinary_differential_equations:24">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>h</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h=x_{i}-x_{i-1}
  </annotation>
 </semantics>
</math>

 is the distance between neighbouring <em>x</em> values on the discretized domain. One then constructs a linear system that can then be solved by standard <a href="numerical_linear_algebra" title="wikilink">matrix methods</a>. For instance, suppose the equation to be solved is:</p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mrow>
       <msup>
        <mi>d</mi>
        <mn>2</mn>
       </msup>
       <mi>u</mi>
      </mrow>
      <mrow>
       <mi>d</mi>
       <msup>
        <mi>x</mi>
        <mn>2</mn>
       </msup>
      </mrow>
     </mfrac>
     <mo>-</mo>
     <mi>u</mi>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>d</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>u</ci>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <ci>u</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{d^{2}u}{dx^{2}}-u=0,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>u</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>u</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(0)=0,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>u</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="float">1.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(1)=1.
  </annotation>
 </semantics>
</math>

</p>

<p>The next step would be to discretize the problem and use linear derivative approximations such as</p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:28">
 <semantics>
  <mrow>
   <msubsup>
    <mi>u</mi>
    <mi>i</mi>
    <mi>′′</mi>
   </msubsup>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <msub>
       <mi>u</mi>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <msub>
        <mi>u</mi>
        <mi>i</mi>
       </msub>
      </mrow>
     </mrow>
     <mo>+</mo>
     <msub>
      <mi>u</mi>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <msup>
     <mi>h</mi>
     <mn>2</mn>
    </msup>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>u</ci>
      <ci>′′</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>h</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u^{\prime\prime}_{i}=\frac{u_{i+1}-2u_{i}+u_{i-1}}{h^{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>and solve the resulting system of linear equations. This would lead to equations such as:</p>

<p>

<math display="block" id="Numerical_methods_for_ordinary_differential_equations:29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mrow>
       <mrow>
        <msub>
         <mi>u</mi>
         <mrow>
          <mi>i</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo>-</mo>
        <mrow>
         <mn>2</mn>
         <msub>
          <mi>u</mi>
          <mi>i</mi>
         </msub>
        </mrow>
       </mrow>
       <mo>+</mo>
       <msub>
        <mi>u</mi>
        <mrow>
         <mi>i</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
      <msup>
       <mi>h</mi>
       <mn>2</mn>
      </msup>
     </mfrac>
     <mo>-</mo>
     <msub>
      <mi>u</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mn>3</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1.</mn>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>u</ci>
          <apply>
           <plus></plus>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>u</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <apply>
          <minus></minus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>h</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>i</ci>
     </apply>
     <list>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
      <ci>normal-…</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="float">1.</cn>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{u_{i+1}-2u_{i}+u_{i-1}}{h^{2}}-u_{i}=0,\quad\forall i={1,2,3,...,n-1}.
  </annotation>
 </semantics>
</math>

</p>

<p>On first viewing, this system of equations appears to have difficulty associated with the fact that the equation involves no terms that are not multiplied by variables, but in fact this is false. At <em>i</em> = 1 and <em>n</em> − 1 there is a term involving the boundary values 

<math display="inline" id="Numerical_methods_for_ordinary_differential_equations:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>u</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>u</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(0)=u_{0}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Numerical_methods_for_ordinary_differential_equations:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>u</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>u</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(1)=u_{n}
  </annotation>
 </semantics>
</math>

 and since these two values are known, one can simply substitute them into this equation and as a result have a non-homogeneous linear system of equations that has non-trivial solutions.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Courant–Friedrichs–Lewy_condition" title="wikilink">Courant–Friedrichs–Lewy condition</a></li>
<li><a href="Energy_drift" title="wikilink">Energy drift</a></li>
<li><a href="General_linear_methods" title="wikilink">General linear methods</a></li>
<li><a href="List_of_numerical_analysis_topics#Numerical_methods_for_ordinary_differential_equations" title="wikilink">List of numerical analysis topics#Numerical methods for ordinary differential equations</a></li>
<li><a href="Reversible_reference_system_propagation_algorithm" title="wikilink">Reversible reference system propagation algorithm</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li><a href="John_C._Butcher" title="wikilink">J. C. Butcher</a>, <em>Numerical methods for ordinary differential equations</em>, ISBN 0-471-96758-0</li>
<li>Ernst Hairer, Syvert Paul Nørsett and Gerhard Wanner, <em>Solving ordinary differential equations I: Nonstiff problems,</em> second edition, Springer Verlag, Berlin, 1993. ISBN 3-540-56670-8.</li>
<li>Ernst Hairer and Gerhard Wanner, <em>Solving ordinary differential equations II: Stiff and differential-algebraic problems,</em> second edition, Springer Verlag, Berlin, 1996. ISBN 3-540-60452-9.<br/>
<em>(This two-volume monograph systematically covers all aspects of the field.)</em></li>
<li></li>
<li>Arieh Iserles, <em>A First Course in the Numerical Analysis of Differential Equations,</em> Cambridge University Press, 1996. ISBN 0-521-55376-8 (hardback), ISBN 0-521-55655-4 (paperback).<br/>
<em>(Textbook, targeting advanced undergraduate and postgraduate students in mathematics, which also discusses <a href="numerical_partial_differential_equations" title="wikilink">numerical partial differential equations</a>.)</em></li>
<li>John Denholm Lambert, <em>Numerical Methods for Ordinary Differential Systems,</em> John Wiley &amp; Sons, Chichester, 1991. ISBN 0-471-92990-5.<br/>
<em>(Textbook, slightly more demanding than the book by Iserles.)</em></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>Joseph W. Rudmin, <em><a href="http://csma31.csm.jmu.edu/physics/rudmin/ps.pdf">Application of the Parker–Sochacki Method to Celestial Mechanics</a></em>, 1998.</li>
<li>Dominique Tournès, <em><a href="http://www.reunion.iufm.fr/dep/mathematiques/calculsavant/Equipe/tournes.html">L'intégration approchée des équations différentielles ordinaires (1671-1914)</a></em>, thèse de doctorat de l'université Paris 7 - Denis Diderot, juin 1996. Réimp. Villeneuve d'Ascq : Presses universitaires du Septentrion, 1997, 468 p. (Extensive online material on ODE numerical analysis history, for English-language material on the history of ODE numerical analysis, see e.g. the paper books by Chabert and Goldstine quoted by him.)</li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_differential_equations" title="wikilink"> </a> <a href="Category:Ordinary_differential_equations" title="wikilink">Category:Ordinary differential equations</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"> This is a modern and extensive review paper for exponential integrators<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
