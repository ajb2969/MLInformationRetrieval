<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="598">Dominator (graph theory)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Dominator (graph theory)</h1>
<hr/>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">

<p>1</p></th>
<th style="text-align: left;">

<p>dom    </p></th>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
<th style="text-align: left;">

<p>3</p></th>
<th style="text-align: left;">

<p>4</p></th>
<th style="text-align: left;">

<p>5</p></th>
<th style="text-align: left;">

<p>6</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>2</p></td>
<td style="text-align: left;">

<p>dom</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>3</p></td>
<td style="text-align: left;">

<p>dom</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>4</p></td>
<td style="text-align: left;">

<p>dom</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>5</p></td>
<td style="text-align: left;">

<p>dom</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>6</p></td>
<td style="text-align: left;">

<p>dom</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>Corresponding domination relation</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>are not strictly dominated</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>are immediately dominated</p></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Example control flow graph with entry node 1.</figcaption>
</figure></td>
</tr>
</tbody>
</table>

<p>In <a href="computer_science" title="wikilink">computer science</a>, in <a href="control_flow_graph" title="wikilink">control flow graphs</a>, a <a href="basic_block" title="wikilink">node</a> <strong>d</strong> <em>dominates</em> a node <strong>n</strong> if every path from the <em>entry node</em> to <strong>n</strong> must go through <strong>d</strong>. Notationally, this is written as <strong>d</strong> dom <strong>n</strong> (or sometimes <strong>d</strong>
<math display="inline" id="Dominator_(graph_theory):0">
<semantics>
<mo>≫</mo>
<annotation-xml encoding="MathML-Content">
<csymbol cd="latexml">much-greater-than</csymbol>
</annotation-xml>
<annotation encoding="application/x-tex">
   \gg
  </annotation>
</semantics>
</math>
<strong>n</strong>). By definition, every node dominates itself.</p>

<p>There are a number of related concepts:</p>
<ul>
<li>A node d <em>strictly dominates</em> a node n if d dominates n and d does not equal n.</li>
<li>The <em>immediate dominator</em> or <strong>idom</strong> of a node <em>n</em> is the unique node that strictly dominates <em>n</em> but does not strictly dominate any other node that strictly dominates <em>n</em>. Every node, except the entry node, has an immediate dominator.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></li>
<li>The <em>dominance frontier</em> of a node d is the set of all nodes n such that d dominates an immediate predecessor of n, but d does not strictly dominate n. It is the set of nodes where d's dominance stops.</li>
<li>A <em>dominator tree</em> is a <a href="tree_(graph_theory)" title="wikilink">tree</a> where each node's children are those nodes it immediately dominates. Because the immediate dominator is unique, it is a tree. The start node is the root of the tree.</li>
</ul>
<h2 id="history">History</h2>

<p>Dominance was first introduced by Reese T. Prosser in a 1959 paper on analysis of flow diagrams.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Prosser did not present an algorithm for computing dominance, which had to wait ten years for Edward S. Lowry and C. W. Medlock.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Ron Cytron <em>et al.</em> rekindled interest in dominance in 1989 when they applied it to efficient computation of φ functions, which are used in <a href="static_single_assignment_form" title="wikilink">static single assignment form</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="applications">Applications</h2>

<p>Dominators, and dominance frontiers particularly, have applications in <a href="compiler" title="wikilink">compilers</a> for computing <a href="static_single_assignment_form" title="wikilink">static single assignment form</a>. A number of compiler optimizations can also benefit from dominators. The flow graph in this case comprises <a href="basic_block" title="wikilink">basic blocks</a>.</p>

<p>Automatic parallelization benefits from postdominance frontiers. This is an efficient method of computing control dependence, which is critical to the analysis.</p>

<p>Memory usage analysis can benefit from the dominator tree to easily find leaks and identify high memory usage.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>In hardware systems, dominators are used for computing signal probabilities for test generation, estimating switching activities for power and noise analysis, and selecting cut points in equivalence checking.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> In software systems, they are used for reducing the size of the test set in structural testing techniques such as statement and branch coverage.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="algorithms">Algorithms</h2>

<p>The dominators of a node n are given by the maximal solution to the following data-flow equations:</p>

<p>
<math display="block" id="Dominator_(graph_theory):1">
<semantics>
<mrow>
<mrow>
<mo>Dom</mo>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>n</mi>
<mi>o</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo>{</mo>
<msub>
<mi>n</mi>
<mi>o</mi>
</msub>
<mo>}</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<ci>Dom</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<ci>o</ci>
</apply>
</apply>
<set>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<ci>o</ci>
</apply>
</set>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Dom}(n_{o})=\left\{n_{o}\right\}
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Dominator_(graph_theory):2">
<semantics>
<mrow>
<mrow>
<mo>Dom</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mo>(</mo>
<mrow>
<munder>
<mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋂</mo>
<mrow>
<mi>p</mi>
<mo>∈</mo>
<mrow>
<mtext>preds</mtext>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</munder>
<mrow>
<mo>Dom</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>p</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
<mrow>
<mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋃</mo>
<mrow>
<mo>{</mo>
<mi>n</mi>
<mo>}</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<ci>Dom</ci>
<ci>n</ci>
</apply>
<apply>
<times></times>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<intersect></intersect>
<apply>
<in></in>
<ci>p</ci>
<apply>
<times></times>
<mtext>preds</mtext>
<ci>n</ci>
</apply>
</apply>
</apply>
<apply>
<ci>Dom</ci>
<ci>p</ci>
</apply>
</apply>
<apply>
<union></union>
<set>
<ci>n</ci>
</set>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Dom}(n)=\left(\bigcap_{p\in\text{preds}(n)}\operatorname{Dom}(p)%
\right)\bigcup\left\{n\right\}
  </annotation>
</semantics>
</math>
</p>

<p>where 

<math display="inline" id="Dominator_(graph_theory):3">
<semantics>
<msub>
<mi>n</mi>
<mi>o</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>n</ci>
<ci>o</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n_{o}
  </annotation>
</semantics>
</math>

 is the start node.</p>

<p>The dominator of the start node is the start node itself. The set of dominators for any other node n is the intersection of the set of dominators for all predecessors p of n. The node n is also in the set of dominators for n.</p>

<p>An algorithm for direct solution is:</p>

<p><code> // dominator of the start node is the start itself</code><br/>
<code> Dom(n</code><sub><code>0</code></sub><code>) = {n</code><sub><code>0</code></sub><code>}</code><br/>
<code> // for all other nodes, set all nodes as the dominators</code><br/>
<code> </code><strong><code>for</code> <code>each</code></strong><code> n </code><strong><code>in</code></strong><code> N - {n</code><sub><code>0</code></sub><code>}</code><br/>
<code>     Dom(n) = N;</code><br/>
<code> // iteratively eliminate nodes that are not dominators</code><br/>
<code> </code><strong><code>while</code></strong><code> changes in any Dom(n)</code><br/>
<code>     </code><strong><code>for</code> <code>each</code></strong><code> n </code><strong><code>in</code></strong><code> N - {n</code><sub><code>0</code></sub><code>}:</code><br/>
<code>         Dom(n) = {n} union with intersection over Dom(p) for all p in pred(n)</code></p>

<p>Direct solution is <a href="quadratic_growth" title="wikilink">quadratic</a> in the number of nodes, or O(n<sup>2</sup>). <a href="Thomas_Lengauer" title="wikilink">Lengauer</a> and <a href="Robert_Endre_Tarjan" title="wikilink">Tarjan</a> developed an algorithm which is almost linear, but its implementation tends to be complex and time consuming for a graph of several hundred nodes or fewer.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>Keith D. Cooper, Timothy J. Harvey, and Ken Kennedy of <a href="Rice_University" title="wikilink">Rice University</a> describe an algorithm that essentially solves the above data flow equations but uses well engineered data structures to improve performance.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="postdominance">Postdominance</h2>

<p>Analogous to the definition of dominance above, a node <em>z</em> is said to <strong>post-dominate</strong> a node <em>n</em> if all paths to the exit node of the graph starting at <em>n</em> must go through <em>z</em>. Similarly, the <strong>immediate post-dominator</strong> of a node <em>n</em> is the postdominator of <em>n</em> that doesn't strictly postdominate any other strict postdominators of <em>n</em>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Control_flow_graph" title="wikilink">Control flow graph</a></li>
<li><a href="Interval_(graph_theory)" title="wikilink">Interval (graph theory)</a></li>
<li><a href="Static_single_assignment_form" title="wikilink">Static single assignment form</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.eecs.harvard.edu/hube/software/nci/cfa.html">The Machine-SUIF Control Flow Analysis Library</a></li>
</ul>

<p>"</p>

<p><a href="Category:Graph_theory" title="wikilink">Category:Graph theory</a> <a href="Category:Compiler_construction" title="wikilink">Category:Compiler construction</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
</ol>
</section>
</body>
</html>
