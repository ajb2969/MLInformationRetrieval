<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="510">Polynomial-time reduction</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Polynomial-time reduction</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, a <strong>polynomial-time reduction</strong> is a method of solving one problem by means of a hypothetical <a class="uri" href="subroutine" title="wikilink">subroutine</a> for solving a different problem (that is, a <a href="Reduction_(complexity)" title="wikilink">reduction</a>), that uses <a href="polynomial_time" title="wikilink">polynomial time</a> excluding the time within the subroutine. There are several different types of polynomial-time reduction, depending on the details of how the subroutine is used. Intuitively, a polynomial-time reduction proves that the first problem is no more difficult than the second one, because whenever an efficient <a class="uri" href="algorithm" title="wikilink">algorithm</a> exists for the second problem, one exists for the first problem as well. Polynomial-time reductions are frequently used in complexity theory for defining both <a href="complexity_class" title="wikilink">complexity classes</a> and <a href="complete_problem" title="wikilink">complete problems</a> for those classes.</p>
<h2 id="types-of-reduction">Types of reduction</h2>

<p>The three most common types of polynomial-time reduction, from the most to the least restrictive, are polynomial-time many-one reductions, truth-table reductions, and Turing reductions.</p>
<ul>
<li>A polynomial-time <a href="many-one_reduction" title="wikilink">many-one reduction</a> from a problem <em>A</em> to a problem <em>B</em> (both of which are usually required to be <a href="decision_problem" title="wikilink">decision problems</a>) is a polynomial-time algorithm for transforming inputs to problem <em>A</em> into inputs to problem <em>B</em>, such that the transformed problem has the same output as the original problem. An instance <em>x</em> of problem <em>A</em> can be solved by applying this transformation to produce an instance <em>y</em> of problem <em>B</em>, giving <em>y</em> as the input to an algorithm for problem <em>B</em>, and returning its output. Polynomial-time many-one reductions may also be known as <strong><a href="polynomial_transformations" title="wikilink">polynomial transformations</a></strong> or <strong>Karp reductions</strong>, named after <a href="Richard_Karp" title="wikilink">Richard Karp</a>. A reduction of this type may be denoted by the expression 

<math display="inline" id="Polynomial-time_reduction:0">
 <semantics>
  <mrow>
   <mi>A</mi>
   <msubsup>
    <mo>≤</mo>
    <mi>m</mi>
    <mi>P</mi>
   </msubsup>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <leq></leq>
      <ci>m</ci>
     </apply>
     <ci>P</ci>
    </apply>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\leq_{m}^{P}B
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></li>
<li>A polynomial-time <a href="truth-table_reduction" title="wikilink">truth-table reduction</a> from a problem <em>A</em> to a problem <em>B</em> (both decision problems) is a polynomial time algorithm for transforming inputs to problem <em>A</em> into a fixed number of inputs to problem <em>B</em>, such that the output for the original problem can be expressed as a function of the outputs for <em>B</em>. The function that maps outputs for <em>B</em> into the output for <em>A</em> must be the same for all inputs, so that it can be expressed by a <a href="truth_table" title="wikilink">truth table</a>. A reduction of this type may be denoted by the expression 

<math display="inline" id="Polynomial-time_reduction:1">
 <semantics>
  <mrow>
   <mi>A</mi>
   <msubsup>
    <mo>≤</mo>
    <mrow>
     <mi>t</mi>
     <mi>t</mi>
    </mrow>
    <mi>P</mi>
   </msubsup>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <leq></leq>
      <apply>
       <times></times>
       <ci>t</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <ci>P</ci>
    </apply>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\leq_{tt}^{P}B
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></li>
<li>A polynomial-time <a href="Turing_reduction" title="wikilink">Turing reduction</a> from a problem <em>A</em> to a problem <em>B</em> is an <a class="uri" href="algorithm" title="wikilink">algorithm</a> that solves problem <em>A</em> using a polynomial number of calls to a subroutine for problem <em>B</em>, and polynomial time outside of those subroutine calls. Polynomial-time Turing reductions are also known as <strong>Cook reductions</strong>, named after <a href="Stephen_Cook" title="wikilink">Stephen Cook</a>. A reduction of this type may be denoted by the expression 

<math display="inline" id="Polynomial-time_reduction:2">
 <semantics>
  <mrow>
   <mi>A</mi>
   <msubsup>
    <mo>≤</mo>
    <mi>T</mi>
    <mi>P</mi>
   </msubsup>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <leq></leq>
      <ci>T</ci>
     </apply>
     <ci>P</ci>
    </apply>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\leq_{T}^{P}B
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
</ul>

<p>The most frequently used of these are the many-one reductions, and in some cases the phrase "polynomial-time reduction" may be used to mean a polynomial-time many-one reduction.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="completeness">Completeness</h2>

<p>A <a href="complete_problem" title="wikilink">complete problem</a> for a given complexity class <strong>C</strong> and reduction ≤ is a problem <em>P</em> that belongs to <strong>C</strong>, such that every problem <em>A</em> in <strong>C</strong> has a reduction <em>A</em> ≤ <em>P</em>. For instance, a problem is <a href="NP-complete" title="wikilink"><strong>NP</strong>-complete</a> if it belongs to <a href="NP_(complexity)" title="wikilink"><strong>NP</strong></a> and all problems in <strong>NP</strong> have polynomial-time many-one reductions to it. A problem that belongs to <strong>NP</strong> can be proven to be <strong>NP</strong>-complete by finding a single polynomial-time many-one reduction to it from a known <strong>NP</strong>-complete problem.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Polynomial-time many-one reductions have been used to define complete problems for other complexity classes, including the <a href="PSPACE-complete" title="wikilink"><strong>PSPACE</strong>-complete</a> languages and <a href="EXPTIME" title="wikilink"><strong>EXPTIME</strong>-complete</a> languages.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Every decision problem in <a href="P_(complexity)" title="wikilink"><strong>P</strong></a> (the class of polynomial-time decision problems, where nontrivial means that not every input has the same output) may be reduced to every other nontrivial decision problem, by a polynomial-time many-one reduction. To transform an instance of problem <em>A</em> to <em>B</em>, solve <em>A</em> in polynomial time, and then use the solution to choose one of two instances of problem <em>B</em> with different answers. Therefore, for complexity classes within <strong>P</strong> such as <a href="L_(complexity)" title="wikilink"><strong>L</strong></a>, <a href="NL_(complexity)" title="wikilink"><strong>NL</strong></a>, <a href="NC_(complexity)" title="wikilink"><strong>NC</strong></a>, and <strong>P</strong> itself, polynomial-time reductions cannot be used to define complete languages: if they were used in this way, every nontrivial problem in <strong>P</strong> would be complete. Instead, weaker reductions such as <a href="log-space_reduction" title="wikilink">log-space reductions</a> or <a href="NC_(complexity)" title="wikilink"><strong>NC</strong></a> reductions are used for defining classes of complete problems for these classes, such as the <a href="P-complete" title="wikilink"><strong>P</strong>-complete</a> problems.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="defining-complexity-classes">Defining complexity classes</h2>

<p>The definitions of the complexity classes <strong>NP</strong>, <strong>PSPACE</strong>, and <strong>EXPTIME</strong> do not involve reductions: reductions come into their study only in the definition of complete languages for these classes. However, in some cases a complexity class may be defined by reductions. If <em>C</em> is any <a href="decision_problem" title="wikilink">decision problem</a>, then one can define a complexity class <strong>C</strong> consisting of the languages <em>A</em> for which 

<math display="inline" id="Polynomial-time_reduction:3">
 <semantics>
  <mrow>
   <mi>A</mi>
   <msubsup>
    <mo>≤</mo>
    <mi>m</mi>
    <mi>P</mi>
   </msubsup>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <leq></leq>
      <ci>m</ci>
     </apply>
     <ci>P</ci>
    </apply>
    <ci>A</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\leq_{m}^{P}C
  </annotation>
 </semantics>
</math>

. In this case, <em>C</em> will automatically be complete for <strong>C</strong>, but <strong>C</strong> may have other complete problems as well.</p>

<p>An example of this is the complexity class 

<math display="inline" id="Polynomial-time_reduction:4">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mi>ℝ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists\mathbb{R}
  </annotation>
 </semantics>
</math>


 defined from the <a href="existential_theory_of_the_reals" title="wikilink">existential theory of the reals</a>, a computational problem that is known to be <a href="NP-hard" title="wikilink"><strong>NP</strong>-hard</a> and in <strong><a class="uri" href="PSPACE" title="wikilink">PSPACE</a></strong>, but is not known to be complete for <strong>NP</strong>, <strong>PSPACE</strong>, or any language in the <a href="polynomial_hierarchy" title="wikilink">polynomial hierarchy</a>. 

<math display="inline" id="Polynomial-time_reduction:5">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mi>ℝ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists\mathbb{R}
  </annotation>
 </semantics>
</math>

 is the set of problems having a polynomial-time many-one reduction to the existential theory of the reals; it has several other complete problems such as determining the <a href="Crossing_number_(graph_theory)" title="wikilink">rectilinear crossing number</a> of an <a href="undirected_graph" title="wikilink">undirected graph</a>. Each problem in 

<math display="inline" id="Polynomial-time_reduction:6">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mi>ℝ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists\mathbb{R}
  </annotation>
 </semantics>
</math>

 inherits the property of belonging to <strong>PSPACE</strong>, and each 

<math display="inline" id="Polynomial-time_reduction:7">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mi>ℝ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists\mathbb{R}
  </annotation>
 </semantics>
</math>

-complete problem is <strong>NP</strong>-hard.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>Similarly, the complexity class <a href="GI_(complexity)" title="wikilink"><strong>GI</strong></a> consists of the problems that can be reduced to the <a href="graph_isomorphism_problem" title="wikilink">graph isomorphism problem</a>. Since graph isomorphism is known to belong both to <strong>NP</strong> and co-<a href="AM_(complexity)" title="wikilink"><strong>AM</strong></a>, the same is true for every problem in this class. A problem is <strong>GI</strong>-complete if it is complete for this class; the graph isomorphism problem itself is <strong>GI</strong>-complete, as are several other related problems.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Karp's_21_NP-complete_problems" title="wikilink">Karp's 21 NP-complete problems</a></li>
</ul>
<h2 id="references">References</h2>

<p><a href="he:רדוקציה_פולינומית" title="wikilink">he:רדוקציה פולינומית</a>"</p>

<p><a href="Category:Computational_complexity_theory" title="wikilink">Category:Computational complexity theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4">.<a href="#fnref4">↩</a></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6">. See in particular p. 255.<a href="#fnref6">↩</a></li>
<li id="fn7">. In particular, for the argument that every nontrivial problem in P has a polynomial-time many-one reduction to every other nontrivial problem, see p. 48.<a href="#fnref7">↩</a></li>
<li id="fn8">.<a href="#fnref8">↩</a></li>
<li id="fn9">.<a href="#fnref9">↩</a></li>
</ol>
</section>
</body>
</html>
