<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1709">Dimension theory (algebra)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Dimension theory (algebra)</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <strong>dimension theory</strong> is a branch of <a href="commutative_algebra" title="wikilink">commutative algebra</a> studying the notion of the <a href="Krull_dimension" title="wikilink">dimension</a> of a <a href="commutative_ring" title="wikilink">commutative ring</a>, and by extension that of a <a href="Scheme_(mathematics)" title="wikilink">scheme</a>.</p>

<p>The theory is much simpler for an <a href="affine_ring" title="wikilink">affine ring</a>; i.e., an integral domain that is a finitely generated algebra over a field. By <a href="Noether's_normalization_lemma" title="wikilink">Noether's normalization lemma</a>, the Krull dimension of such a ring is the <a href="transcendence_degree" title="wikilink">transcendence degree</a> over the base field and the theory runs in parallel with the counterpart in algebraic geometry; cf. <a href="Dimension_of_an_algebraic_variety" title="wikilink">Dimension of an algebraic variety</a>. The general theory tends to be less geometrical; in particular, very little works/is known for non-noetherian rings. (Kaplansky's commutative rings gives a good account of the non-noetherian case.) Today, a standard approach is essentially that of Bourbaki and EGA, which makes essential use of <a href="graded_module" title="wikilink">graded modules</a> and, among other things, emphasizes the role of <a href="multiplicity_of_an_ideal" title="wikilink">multiplicities</a>, the generalization of the degree of a projective variety. In this approach, <a href="Krull's_principal_ideal_theorem" title="wikilink">Krull's principal ideal theorem</a> appears as a corollary.</p>

<p>Throughout the article, 

<math display="inline" id="Dimension_theory_(algebra):0">
 <semantics>
  <mo>dim</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>dim</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{dim}
  </annotation>
 </semantics>
</math>

 denotes <a href="Krull_dimension" title="wikilink">Krull dimension</a> of a ring and 

<math display="inline" id="Dimension_theory_(algebra):1">
 <semantics>
  <mo>ht</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>ht</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{ht}
  </annotation>
 </semantics>
</math>

 the <a href="height_(ring_theory)" title="wikilink">height</a> of a prime ideal (i.e., the Krull dimension of the localization at that prime ideal.) Rings are assumed to be commutative except in the last section on dimensions of non-commutative rings.</p>
<h2 id="basic-results">Basic results</h2>

<p>Let <em>R</em> be a noetherian ring or <a href="valuation_ring" title="wikilink">valuation ring</a>. Then</p>

<p>

<math display="block" id="Dimension_theory_(algebra):2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>dim</mo>
     <mi>R</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>dim</mo>
     <mi>R</mi>
    </mrow>
    <mo>+</mo>
    <mn>1.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>dim</ci>
      <ci>R</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <ci>dim</ci>
      <ci>R</ci>
     </apply>
     <cn type="float">1.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{dim}R[x]=\operatorname{dim}R+1.
  </annotation>
 </semantics>
</math>

 If <em>R</em> is noetherian, this follows from the fundamental theorem below (in particular, <a href="Krull's_principal_ideal_theorem" title="wikilink">Krull's principal ideal theorem</a>.) But it is also a consequence of the more precise result. For any prime ideal 

<math display="inline" id="Dimension_theory_(algebra):3">
 <semantics>
  <mi>𝔭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}
  </annotation>
 </semantics>
</math>

 in <em>R</em>,</p>

<p>

<math display="block" id="Dimension_theory_(algebra):4">
 <semantics>
  <mrow>
   <mrow>
    <mo>ht</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>𝔭</mi>
      <mi>R</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>x</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>ht</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝔭</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>ht</ci>
     <apply>
      <times></times>
      <ci>𝔭</ci>
      <ci>R</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>ht</ci>
     <ci>𝔭</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{ht}(\mathfrak{p}R[x])=\operatorname{ht}(\mathfrak{p})
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Dimension_theory_(algebra):5">
 <semantics>
  <mrow>
   <mrow>
    <mo>ht</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝔮</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>ht</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝔭</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>ht</ci>
     <ci>𝔮</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <ci>ht</ci>
      <ci>𝔭</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{ht}(\mathfrak{q})=\operatorname{ht}(\mathfrak{p})+1
  </annotation>
 </semantics>
</math>

 for any prime ideal 

<math display="inline" id="Dimension_theory_(algebra):6">
 <semantics>
  <mrow>
   <mi>𝔮</mi>
   <mo>⊋</mo>
   <mrow>
    <mi>𝔭</mi>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <prsubset></prsubset>
    <apply>
     <times></times>
     <ci>𝔭</ci>
     <ci>R</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>x</ci>
     </apply>
    </apply>
    <ci>𝔮</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{q}\supsetneq\mathfrak{p}R[x]
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Dimension_theory_(algebra):7">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R[x]
  </annotation>
 </semantics>
</math>

 that contracts to 

<math display="inline" id="Dimension_theory_(algebra):8">
 <semantics>
  <mi>𝔭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}
  </annotation>
 </semantics>
</math>

. This can be shown within basic ring theory (cf. Kaplansky, commutative rings). By the way, it says in particular that in each fiber of 

<math display="inline" id="Dimension_theory_(algebra):9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>Spec</mo>
     <mi>R</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo>Spec</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <apply>
      <ci>Spec</ci>
      <ci>R</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <ci>Spec</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Spec}R[x]\to\operatorname{Spec}R
  </annotation>
 </semantics>
</math>

, one cannot have a chain of primes ideals of length 

<math display="inline" id="Dimension_theory_(algebra):10">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≥</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <csymbol cd="latexml">absent</csymbol>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \geq 2
  </annotation>
 </semantics>
</math>

.</p>

<p>Since an artinian ring (e.g., a field) has dimension zero, by induction, one gets the formula: for an artinian ring <em>R</em>,</p>

<p>

<math display="block" id="Dimension_theory_(algebra):11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>dim</mo>
      <mi>R</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>n</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>dim</ci>
      <ci>R</ci>
     </apply>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </list>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{dim}R[x_{1},\dots,x_{n}]=n.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="local-rings">Local rings</h2>
<h3 id="fundamental-theorem">Fundamental theorem</h3>

<p>Let 

<math display="inline" id="Dimension_theory_(algebra):12">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>R</mi>
   <mo>,</mo>
   <mi>𝔪</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>R</ci>
    <ci>𝔪</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (R,\mathfrak{m})
  </annotation>
 </semantics>
</math>

 be a noetherian local ring and <em>I</em> a 

<math display="inline" id="Dimension_theory_(algebra):13">
 <semantics>
  <mi>𝔪</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔪</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}
  </annotation>
 </semantics>
</math>

-<a href="primary_ideal" title="wikilink">primary ideal</a> (i.e., it sits between some power of 

<math display="inline" id="Dimension_theory_(algebra):14">
 <semantics>
  <mi>𝔪</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔪</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dimension_theory_(algebra):15">
 <semantics>
  <mi>𝔪</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔪</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}
  </annotation>
 </semantics>
</math>

). Let 

<math display="inline" id="Dimension_theory_(algebra):16">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(t)
  </annotation>
 </semantics>
</math>

 be the <a href="Hilbert–Poincaré_series" title="wikilink">Poincaré series</a> of the <a href="associated_graded_ring" title="wikilink">associated graded ring</a> 

<math display="inline" id="Dimension_theory_(algebra):17">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>gr</mo>
     <mi>I</mi>
    </msub>
    <mi>R</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo>⊕</mo>
     <mn>0</mn>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <msup>
      <mi>I</mi>
      <mi>n</mi>
     </msup>
     <mo>/</mo>
     <msup>
      <mi>I</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>gr</ci>
      <ci>I</ci>
     </apply>
     <ci>R</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">direct-sum</csymbol>
       <cn type="integer">0</cn>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>I</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>I</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{gr}_{I}R=\oplus_{0}^{\infty}I^{n}/I^{n+1}
  </annotation>
 </semantics>
</math>

. That is,</p>

<p>

<math display="block" id="Dimension_theory_(algebra):18">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mn>0</mn>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mrow>
     <mi mathvariant="normal">ℓ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>I</mi>
        <mi>n</mi>
       </msup>
       <mo>/</mo>
       <msup>
        <mi>I</mi>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>t</mi>
      <mi>n</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <cn type="integer">0</cn>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>normal-ℓ</ci>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>I</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>I</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(t)=\sum_{0}^{\infty}\ell(I^{n}/I^{n+1})t^{n}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Dimension_theory_(algebra):19">
 <semantics>
  <mi mathvariant="normal">ℓ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-ℓ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

 refers to the <a href="length_of_a_module" title="wikilink">length of a module</a> (over an artinian ring 

<math display="inline" id="Dimension_theory_(algebra):20">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mo>gr</mo>
       <mi>I</mi>
      </msub>
      <mi>R</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mo>/</mo>
    <mi>I</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>gr</ci>
       <ci>I</ci>
      </apply>
      <ci>R</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <divide></divide>
     <ci>R</ci>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\operatorname{gr}_{I}R)_{0}=R/I
  </annotation>
 </semantics>
</math>

). If 

<math display="inline" id="Dimension_theory_(algebra):21">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>s</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>s</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\dots,x_{s}
  </annotation>
 </semantics>
</math>

 generate <em>I</em>, then their image in 

<math display="inline" id="Dimension_theory_(algebra):22">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mo>/</mo>
   <msup>
    <mi>I</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>I</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>I</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I/I^{2}
  </annotation>
 </semantics>
</math>

 have degree 1 and generate 

<math display="inline" id="Dimension_theory_(algebra):23">
 <semantics>
  <mrow>
   <msub>
    <mo>gr</mo>
    <mi>I</mi>
   </msub>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>gr</ci>
     <ci>I</ci>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{gr}_{I}R
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Dimension_theory_(algebra):24">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>/</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>R</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R/I
  </annotation>
 </semantics>
</math>

-algebra. By the <a href="Hilbert–Serre_theorem" title="wikilink">Hilbert–Serre theorem</a>, <em>F</em> is a rational function with exactly one pole at 

<math display="inline" id="Dimension_theory_(algebra):25">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=1
  </annotation>
 </semantics>
</math>

 of order 

<math display="inline" id="Dimension_theory_(algebra):26">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>≤</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>d</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\leq s
  </annotation>
 </semantics>
</math>

. Since</p>

<p>

<math display="block" id="Dimension_theory_(algebra):27">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>t</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mi>d</mi>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mn>0</mn>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mtable columnspacing="0.4em" rowspacing="0.2ex">
       <mtr>
        <mtd>
         <mrow>
          <mrow>
           <mi>d</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo>+</mo>
          <mi>j</mi>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd>
         <mrow>
          <mi>d</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <msup>
      <mi>t</mi>
      <mi>j</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>t</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>d</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <cn type="integer">0</cn>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">binomial</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <minus></minus>
         <ci>d</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>j</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>d</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1-t)^{-d}=\sum_{0}^{\infty}{\left({{d-1+j}\atop{d-1}}\right)}t^{j}
  </annotation>
 </semantics>
</math>

, we find that the coefficient of 

<math display="inline" id="Dimension_theory_(algebra):28">
 <semantics>
  <msup>
   <mi>t</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>t</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{n}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Dimension_theory_(algebra):29">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>t</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
    </msup>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>t</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mi>d</mi>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>t</ci>
      </apply>
      <ci>d</ci>
     </apply>
     <ci>F</ci>
     <ci>t</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>t</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>d</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(t)=(1-t)^{d}F(t)(1-t)^{-d}
  </annotation>
 </semantics>
</math>

 is of the form</p>

<p>

<math display="block" id="Dimension_theory_(algebra):30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mn>0</mn>
      <mi>N</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>k</mi>
      </msub>
      <mrow>
       <mo>(</mo>
       <mtable columnspacing="0.4em" rowspacing="0.2ex">
        <mtr>
         <mtd>
          <mrow>
           <mrow>
            <mrow>
             <mi>d</mi>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
            <mo>+</mo>
            <mi>n</mi>
           </mrow>
           <mo>-</mo>
           <mi>k</mi>
          </mrow>
         </mtd>
        </mtr>
        <mtr>
         <mtd>
          <mrow>
           <mi>d</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mrow>
        <mrow>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mn>1</mn>
            <mo>-</mo>
            <mi>t</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>d</mi>
         </msup>
         <mi>F</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo fence="true">|</mo>
       </mrow>
       <mrow>
        <mi>t</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mfrac>
       <msup>
        <mi>n</mi>
        <mrow>
         <mi>d</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mrow>
        <mi>d</mi>
        <mo>-</mo>
        <mrow>
         <mn>1</mn>
         <mo lspace="0pt" rspace="3.5pt">!</mo>
        </mrow>
       </mrow>
      </mfrac>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>n</mi>
        <mrow>
         <mi>d</mi>
         <mo>-</mo>
         <mn>2</mn>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <cn type="integer">0</cn>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">binomial</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <plus></plus>
         <apply>
          <minus></minus>
          <ci>d</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>n</ci>
        </apply>
        <ci>k</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>d</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">evaluated-at</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <ci>t</ci>
         </apply>
         <ci>d</ci>
        </apply>
        <ci>F</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <eq></eq>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <apply>
         <minus></minus>
         <ci>d</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>d</ci>
        <apply>
         <factorial></factorial>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <apply>
        <minus></minus>
        <ci>d</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{0}^{N}a_{k}{\left({{d-1+n-k}\atop{d-1}}\right)}=(1-t)^{d}F(t)|_{t=1}{n^{%
d-1}\over{d-1}!}+O(n^{d-2}).
  </annotation>
 </semantics>
</math>

 That is to say, 

<math display="inline" id="Dimension_theory_(algebra):31">
 <semantics>
  <mrow>
   <mi mathvariant="normal">ℓ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>I</mi>
      <mi>n</mi>
     </msup>
     <mo>/</mo>
     <msup>
      <mi>I</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-ℓ</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>I</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>I</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell(I^{n}/I^{n+1})
  </annotation>
 </semantics>
</math>

 is a polynomial 

<math display="inline" id="Dimension_theory_(algebra):32">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 in <em>n</em> of degree 

<math display="inline" id="Dimension_theory_(algebra):33">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>d</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d-1
  </annotation>
 </semantics>
</math>

. <em>P</em> is called the <a href="Hilbert_polynomial" title="wikilink">Hilbert polynomial</a> of 

<math display="inline" id="Dimension_theory_(algebra):34">
 <semantics>
  <mrow>
   <msub>
    <mo>gr</mo>
    <mi>I</mi>
   </msub>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>gr</ci>
     <ci>I</ci>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{gr}_{I}R
  </annotation>
 </semantics>
</math>

.</p>

<p>We set 

<math display="inline" id="Dimension_theory_(algebra):35">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>R</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>R</ci>
    </apply>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(R)=d
  </annotation>
 </semantics>
</math>

. We also set 

<math display="inline" id="Dimension_theory_(algebra):36">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>δ</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(R)
  </annotation>
 </semantics>
</math>

 to be the minimum number of elements of <em>R</em> that can generate a 

<math display="inline" id="Dimension_theory_(algebra):37">
 <semantics>
  <mi>𝔪</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔪</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}
  </annotation>
 </semantics>
</math>

-primary ideal of <em>R</em>. Our ambition is to prove the <strong>fundamental theorem</strong>:</p>

<p>

<math display="block" id="Dimension_theory_(algebra):38">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>R</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>R</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>dim</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>δ</ci>
      <ci>R</ci>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>R</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">dimension</csymbol>
      <ci>R</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(R)=d(R)=\dim R
  </annotation>
 </semantics>
</math>

. Since we can take <em>s</em> to be 

<math display="inline" id="Dimension_theory_(algebra):39">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>δ</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(R)
  </annotation>
 </semantics>
</math>

, we already have 

<math display="inline" id="Dimension_theory_(algebra):40">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>R</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>R</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>δ</ci>
     <ci>R</ci>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(R)\geq d(R)
  </annotation>
 </semantics>
</math>

 from the above. Next we prove 

<math display="inline" id="Dimension_theory_(algebra):41">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>R</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mo>dim</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>R</ci>
    </apply>
    <apply>
     <ci>dim</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(R)\geq\operatorname{dim}R
  </annotation>
 </semantics>
</math>

 by induction on 

<math display="inline" id="Dimension_theory_(algebra):42">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(R)
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Dimension_theory_(algebra):43">
 <semantics>
  <mrow>
   <msub>
    <mi>𝔭</mi>
    <mn>0</mn>
   </msub>
   <mo>⊊</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>⊊</mo>
   <msub>
    <mi>𝔭</mi>
    <mi>m</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <prsubset></prsubset>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔭</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <prsubset></prsubset>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔭</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}_{0}\subsetneq\cdots\subsetneq\mathfrak{p}_{m}
  </annotation>
 </semantics>
</math>

 be a chain of prime ideals in <em>R</em>. Let 

<math display="inline" id="Dimension_theory_(algebra):44">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mo>/</mo>
    <msub>
     <mi>𝔭</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <apply>
     <divide></divide>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔭</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=R/\mathfrak{p}_{0}
  </annotation>
 </semantics>
</math>

 and <em>x</em> a nonzero nonunit element in <em>D</em>. Since <em>x</em> is not a zero-divisor, we have the exact sequence</p>

<p>

<math display="block" id="Dimension_theory_(algebra):45">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mrow>
    <mi>D</mi>
    <mover accent="true">
     <mo>→</mo>
     <mo>𝑥</mo>
    </mover>
    <mi>D</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mi>D</mi>
     <mo>/</mo>
     <mi>x</mi>
    </mrow>
    <mi>D</mi>
   </mrow>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <ci>D</ci>
      <apply>
       <ci>x</ci>
       <ci>normal-→</ci>
      </apply>
      <ci>D</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>D</ci>
       <ci>x</ci>
      </apply>
      <ci>D</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\to D\overset{x}{\to}D\to D/xD\to 0
  </annotation>
 </semantics>
</math>

. The degree bound of the Hilbert-Samuel polynomial now implies that 

<math display="inline" id="Dimension_theory_(algebra):46">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>D</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>D</mi>
       <mo>/</mo>
       <mi>x</mi>
      </mrow>
      <mi>D</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>R</mi>
      <mo>/</mo>
      <msub>
       <mi>𝔭</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <gt></gt>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>D</ci>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>D</ci>
        <ci>x</ci>
       </apply>
       <ci>D</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>d</ci>
      <apply>
       <divide></divide>
       <ci>R</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝔭</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(D)>d(D/xD)\geq d(R/\mathfrak{p}_{1})
  </annotation>
 </semantics>
</math>

. (This essentially follows from the <a href="Artin-Rees_lemma" title="wikilink">Artin-Rees lemma</a>; see <a href="Hilbert-Samuel_function" title="wikilink">Hilbert-Samuel function</a> for the statement and the proof.) In 

<math display="inline" id="Dimension_theory_(algebra):47">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>/</mo>
   <msub>
    <mi>𝔭</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>R</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝔭</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R/\mathfrak{p}_{1}
  </annotation>
 </semantics>
</math>

, the chain 

<math display="inline" id="Dimension_theory_(algebra):48">
 <semantics>
  <msub>
   <mi>𝔭</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝔭</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}_{i}
  </annotation>
 </semantics>
</math>

 becomes a chain of length 

<math display="inline" id="Dimension_theory_(algebra):49">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>m</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m-1
  </annotation>
 </semantics>
</math>

 and so, by inductive hypothesis and again by the degree estimate,</p>

<p>

<math display="block" id="Dimension_theory_(algebra):50">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mo>dim</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>R</mi>
      <mo>/</mo>
      <msub>
       <mi>𝔭</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>R</mi>
      <mo>/</mo>
      <msub>
       <mi>𝔭</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>D</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>R</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <minus></minus>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <ci>dim</ci>
      <apply>
       <divide></divide>
       <ci>R</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝔭</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>d</ci>
      <apply>
       <divide></divide>
       <ci>R</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝔭</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>D</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>R</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m-1\leq\operatorname{dim}(R/\mathfrak{p}_{1})\leq d(R/\mathfrak{p}_{1})\leq d(%
D)-1\leq d(R)-1
  </annotation>
 </semantics>
</math>

. The claim follows. It now remains to show 

<math display="inline" id="Dimension_theory_(algebra):51">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>dim</mo>
     <mi>R</mi>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mi>δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>R</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <ci>dim</ci>
     <ci>R</ci>
    </apply>
    <apply>
     <times></times>
     <ci>δ</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{dim}R\geq\delta(R).
  </annotation>
 </semantics>
</math>

 More precisely, we shall show:</p>
<dl>
<dd><strong>Lemma</strong>: <em>R</em> contains elements 

<math display="inline" id="Dimension_theory_(algebra):52">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>s</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>s</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\dots,x_{s}
  </annotation>
 </semantics>
</math>

 such that, for any <em>i</em>, any prime ideal containing 

<math display="inline" id="Dimension_theory_(algebra):53">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},\dots,x_{i})
  </annotation>
 </semantics>
</math>

 has height 

<math display="inline" id="Dimension_theory_(algebra):54">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≥</mo>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <csymbol cd="latexml">absent</csymbol>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \geq i
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>

<p>(Notice

<math display="block" id="Dimension_theory_(algebra):55">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>s</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>s</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},\dots,x_{s})
  </annotation>
 </semantics>
</math>

 is then 

<math display="inline" id="Dimension_theory_(algebra):56">
 <semantics>
  <mi>𝔪</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔪</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}
  </annotation>
 </semantics>
</math>

-primary.) The proof is omitted. It appears, for example, in Atiyah–MacDonald. But it can also be supplied privately; the idea is to use <a href="prime_avoidance" title="wikilink">prime avoidance</a>.</p>
<h3 id="consequences-of-the-fundamental-theorem">Consequences of the fundamental theorem</h3>

<p>Let 

<math display="inline" id="Dimension_theory_(algebra):57">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>R</mi>
   <mo>,</mo>
   <mi>𝔪</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>R</ci>
    <ci>𝔪</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (R,\mathfrak{m})
  </annotation>
 </semantics>
</math>

 be a noetherian local ring and put 

<math display="inline" id="Dimension_theory_(algebra):58">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mo>/</mo>
    <mi>𝔪</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <divide></divide>
     <ci>R</ci>
     <ci>𝔪</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=R/\mathfrak{m}
  </annotation>
 </semantics>
</math>

. Then</p>
<ul>
<li>

<math display="inline" id="Dimension_theory_(algebra):59">
 <semantics>
  <mrow>
   <mrow>
    <mo>dim</mo>
    <mi>R</mi>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <msub>
     <mo>dim</mo>
     <mi>k</mi>
    </msub>
    <mrow>
     <mi>𝔪</mi>
     <mo>/</mo>
     <msup>
      <mi>𝔪</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <ci>dim</ci>
     <ci>R</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>dim</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>𝔪</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝔪</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{dim}R\leq\operatorname{dim}_{k}\mathfrak{m}/\mathfrak{m}^{2}
  </annotation>
 </semantics>
</math>

, since a basis of 

<math display="inline" id="Dimension_theory_(algebra):60">
 <semantics>
  <mrow>
   <mi>𝔪</mi>
   <mo>/</mo>
   <msup>
    <mi>𝔪</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>𝔪</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝔪</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}/\mathfrak{m}^{2}
  </annotation>
 </semantics>
</math>

 lifts to a generating set of 

<math display="inline" id="Dimension_theory_(algebra):61">
 <semantics>
  <mi>𝔪</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔪</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}
  </annotation>
 </semantics>
</math>

 by Nakayama. If the equality holds, then <em>R</em> is called a <a href="regular_local_ring" title="wikilink">regular local ring</a>.</li>
<li>

<math display="inline" id="Dimension_theory_(algebra):62">
 <semantics>
  <mrow>
   <mrow>
    <mo>dim</mo>
    <mover accent="true">
     <mi>R</mi>
     <mo>^</mo>
    </mover>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>dim</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>dim</ci>
     <apply>
      <ci>normal-^</ci>
      <ci>R</ci>
     </apply>
    </apply>
    <apply>
     <ci>dim</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{dim}\widehat{R}=\operatorname{dim}R
  </annotation>
 </semantics>
</math>

, since 

<math display="inline" id="Dimension_theory_(algebra):63">
 <semantics>
  <mrow>
   <mrow>
    <mo>gr</mo>
    <mi>R</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>gr</mo>
    <mover accent="true">
     <mi>R</mi>
     <mo>^</mo>
    </mover>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>gr</ci>
     <ci>R</ci>
    </apply>
    <apply>
     <ci>gr</ci>
     <apply>
      <ci>normal-^</ci>
      <ci>R</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{gr}R=\operatorname{gr}\widehat{R}
  </annotation>
 </semantics>
</math>

.</li>
<li>(<a href="Krull's_principal_ideal_theorem" title="wikilink">Krull's principal ideal theorem</a>) The height of the ideal generated by elements 

<math display="inline" id="Dimension_theory_(algebra):64">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>s</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>s</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\dots,x_{s}
  </annotation>
 </semantics>
</math>

 in a noetherian ring is at most <em>s</em>. Conversely, a prime ideal of height <em>s</em> can be generated by <em>s</em> elements. (Proof: Let 

<math display="inline" id="Dimension_theory_(algebra):65">
 <semantics>
  <mi>𝔭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}
  </annotation>
 </semantics>
</math>

 be a prime ideal minimal over such an ideal. Then 

<math display="inline" id="Dimension_theory_(algebra):66">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>≥</mo>
   <mrow>
    <mo>dim</mo>
    <msub>
     <mi>R</mi>
     <mi>𝔭</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>ht</mo>
    <mi>𝔭</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <geq></geq>
     <ci>s</ci>
     <apply>
      <ci>dim</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>𝔭</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>ht</ci>
      <ci>𝔭</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\geq\operatorname{dim}R_{\mathfrak{p}}=\operatorname{ht}\mathfrak{p}
  </annotation>
 </semantics>
</math>

. The converse was shown in the course of the proof of the fundamental theorem.)</li>
</ul>

<p>Proof: Let 

<math display="inline" id="Dimension_theory_(algebra):67">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\dots,x_{n}
  </annotation>
 </semantics>
</math>

 generate a 

<math display="inline" id="Dimension_theory_(algebra):68">
 <semantics>
  <msub>
   <mi>𝔪</mi>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝔪</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}_{A}
  </annotation>
 </semantics>
</math>

-primary ideal and 

<math display="inline" id="Dimension_theory_(algebra):69">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mi>m</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>m</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1},\dots,y_{m}
  </annotation>
 </semantics>
</math>

 be such that their images generate a 

<math display="inline" id="Dimension_theory_(algebra):70">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝔪</mi>
     <mi>B</mi>
    </msub>
    <mo>/</mo>
    <msub>
     <mi>𝔪</mi>
     <mi>A</mi>
    </msub>
   </mrow>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔪</ci>
      <ci>B</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔪</ci>
      <ci>A</ci>
     </apply>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}_{B}/\mathfrak{m}_{A}B
  </annotation>
 </semantics>
</math>

-primary ideal. Then 

<math display="inline" id="Dimension_theory_(algebra):71">
 <semantics>
  <mrow>
   <mmultiscripts>
    <mi>𝔪</mi>
    <mi>B</mi>
    <none></none>
    <none></none>
    <mi>s</mi>
   </mmultiscripts>
   <mo>⊂</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mi>m</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>𝔪</mi>
      <mi>A</mi>
     </msub>
     <mi>B</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔪</ci>
      <ci>B</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <apply>
     <plus></plus>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>m</ci>
      </apply>
     </vector>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝔪</ci>
       <ci>A</ci>
      </apply>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathfrak{m}_{B}}^{s}\subset(y_{1},\dots,y_{m})+\mathfrak{m}_{A}B
  </annotation>
 </semantics>
</math>

 for some <em>s</em>. Raising both sides to higher powers, we see some power of 

<math display="inline" id="Dimension_theory_(algebra):72">
 <semantics>
  <msub>
   <mi>𝔪</mi>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝔪</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}_{B}
  </annotation>
 </semantics>
</math>

 is contained in 

<math display="inline" id="Dimension_theory_(algebra):73">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mi>m</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (y_{1},\dots,y_{m},x_{1},\dots,x_{n})
  </annotation>
 </semantics>
</math>

; i.e., the latter ideal is 

<math display="inline" id="Dimension_theory_(algebra):74">
 <semantics>
  <msub>
   <mi>𝔪</mi>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝔪</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}_{B}
  </annotation>
 </semantics>
</math>

-primary; thus, 

<math display="inline" id="Dimension_theory_(algebra):75">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <mo>+</mo>
    <mi>n</mi>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mo>dim</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <plus></plus>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">dimension</csymbol>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m+n\geq\dim B
  </annotation>
 </semantics>
</math>

. The equality is a straightforward application of the going-down property. 

<math display="inline" id="Dimension_theory_(algebra):76">
 <semantics>
  <mi mathvariant="normal">□</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-□</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \square
  </annotation>
 </semantics>
</math>

</p>

<p>Proof: If 

<math display="inline" id="Dimension_theory_(algebra):77">
 <semantics>
  <mrow>
   <msub>
    <mi>𝔭</mi>
    <mn>0</mn>
   </msub>
   <mo>⊊</mo>
   <msub>
    <mi>𝔭</mi>
    <mn>1</mn>
   </msub>
   <mo>⊊</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>⊊</mo>
   <msub>
    <mi>𝔭</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <prsubset></prsubset>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔭</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔭</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <prsubset></prsubset>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <prsubset></prsubset>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝔭</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}_{0}\subsetneq\mathfrak{p}_{1}\subsetneq\cdots\subsetneq\mathfrak{%
p}_{n}
  </annotation>
 </semantics>
</math>

 are a chain of prime ideals in <em>R</em>, then 

<math display="inline" id="Dimension_theory_(algebra):78">
 <semantics>
  <mrow>
   <msub>
    <mi>𝔭</mi>
    <mi>i</mi>
   </msub>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝔭</ci>
     <ci>i</ci>
    </apply>
    <ci>R</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}_{i}R[x]
  </annotation>
 </semantics>
</math>

 are a chain of prime ideals in 

<math display="inline" id="Dimension_theory_(algebra):79">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R[x]
  </annotation>
 </semantics>
</math>

 while 

<math display="inline" id="Dimension_theory_(algebra):80">
 <semantics>
  <mrow>
   <msub>
    <mi>𝔭</mi>
    <mi>n</mi>
   </msub>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝔭</ci>
     <ci>n</ci>
    </apply>
    <ci>R</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}_{n}R[x]
  </annotation>
 </semantics>
</math>

 is not a maximal ideal. Thus, 

<math display="inline" id="Dimension_theory_(algebra):81">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>dim</mo>
     <mi>R</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mo>dim</mo>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">dimension</csymbol>
      <ci>R</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">dimension</csymbol>
     <apply>
      <times></times>
      <ci>R</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dim R+1\leq\dim R[x]
  </annotation>
 </semantics>
</math>

. For the reverse inequality, let 

<math display="inline" id="Dimension_theory_(algebra):82">
 <semantics>
  <mi>𝔪</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔪</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}
  </annotation>
 </semantics>
</math>

 be a maximal ideal of 

<math display="inline" id="Dimension_theory_(algebra):83">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R[x]
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dimension_theory_(algebra):84">
 <semantics>
  <mrow>
   <mi>𝔭</mi>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mo>∩</mo>
    <mi>𝔪</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝔭</ci>
    <apply>
     <intersect></intersect>
     <ci>R</ci>
     <ci>𝔪</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}=R\cap\mathfrak{m}
  </annotation>
 </semantics>
</math>

. Clearly, 

<math display="inline" id="Dimension_theory_(algebra):85">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi>𝔪</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>𝔭</mi>
    </msub>
    <msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi>𝔪</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
      <ci>𝔪</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>𝔭</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
      <ci>𝔪</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R[x]_{\mathfrak{m}}=R_{\mathfrak{p}}[x]_{\mathfrak{m}}
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Dimension_theory_(algebra):86">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>R</mi>
      <msub>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>x</mi>
        <mo stretchy="false">]</mo>
       </mrow>
       <mi>𝔪</mi>
      </msub>
     </mrow>
     <mo>/</mo>
     <mi>𝔭</mi>
    </mrow>
    <msub>
     <mi>R</mi>
     <mi>𝔭</mi>
    </msub>
    <mi>R</mi>
    <msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi>𝔪</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>R</mi>
        <mi>𝔭</mi>
       </msub>
       <mo>/</mo>
       <mi>𝔭</mi>
      </mrow>
      <msub>
       <mi>R</mi>
       <mi>𝔭</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi>𝔪</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>R</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>x</ci>
        </apply>
        <ci>𝔪</ci>
       </apply>
      </apply>
      <ci>𝔭</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>𝔭</ci>
     </apply>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
      <ci>𝔪</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>𝔭</ci>
       </apply>
       <ci>𝔭</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>𝔭</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
      <ci>𝔪</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R[x]_{\mathfrak{m}}/\mathfrak{p}R_{\mathfrak{p}}R[x]_{\mathfrak{m}}=(R_{%
\mathfrak{p}}/\mathfrak{p}R_{\mathfrak{p}})[x]_{\mathfrak{m}}
  </annotation>
 </semantics>
</math>

 is then a localization of a principal ideal domain and has dimension at most one, we get 

<math display="inline" id="Dimension_theory_(algebra):87">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <mo>dim</mo>
     <mi>R</mi>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <mo>dim</mo>
     <msub>
      <mi>R</mi>
      <mi>𝔭</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mrow>
     <mo>dim</mo>
     <mi>R</mi>
    </mrow>
    <msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi>𝔪</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <geq></geq>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <ci>dim</ci>
       <ci>R</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <ci>dim</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>𝔭</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <ci>dim</ci>
       <ci>R</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>x</ci>
       </apply>
       <ci>𝔪</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+\operatorname{dim}R\geq 1+\operatorname{dim}R_{\mathfrak{p}}\geq%
\operatorname{dim}R[x]_{\mathfrak{m}}
  </annotation>
 </semantics>
</math>

 by the previous inequality. Since 

<math display="inline" id="Dimension_theory_(algebra):88">
 <semantics>
  <mi>𝔪</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔪</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}
  </annotation>
 </semantics>
</math>

 is arbitrary, it follows 

<math display="inline" id="Dimension_theory_(algebra):89">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <mo>dim</mo>
     <mi>R</mi>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mrow>
     <mo>dim</mo>
     <mi>R</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <ci>dim</ci>
      <ci>R</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>dim</ci>
      <ci>R</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+\operatorname{dim}R\geq\operatorname{dim}R[x]
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Dimension_theory_(algebra):90">
 <semantics>
  <mi mathvariant="normal">□</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-□</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \square
  </annotation>
 </semantics>
</math>

</p>
<h3 id="nagatas-altitude-formula">Nagata's altitude formula</h3>

<p>{R'/\mathfrak{p}'} \le \dim R_{\mathfrak{p}} + \operatorname{tr.deg}_{R} {R'} where the equality holds if either (a) <em>R</em> is <a href="universally_catenary" title="wikilink">universally catenary</a> and <em>R{{'}}</em> is finitely generated <em>R</em>-algebra or (b) <em>R{{'}}</em> is a polynomial ring over <em>R</em>.}}</p>

<p>Proof:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> First suppose 

<math display="inline" id="Dimension_theory_(algebra):91">
 <semantics>
  <msup>
   <mi>R</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{\prime}
  </annotation>
 </semantics>
</math>

 is a polynomial ring. By induction on the number of variables, it is enough to consider the case 

<math display="inline" id="Dimension_theory_(algebra):92">
 <semantics>
  <mrow>
   <msup>
    <mi>R</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>R</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{\prime}=R[x]
  </annotation>
 </semantics>
</math>

. Since <em>R{{'}}</em> is flat over <em>R</em>,</p>

<p>

<math display="block" id="Dimension_theory_(algebra):93">
 <semantics>
  <mrow>
   <mrow>
    <mo>dim</mo>
    <msubsup>
     <mi>R</mi>
     <msup>
      <mi>𝔭</mi>
      <mo>′</mo>
     </msup>
     <mo>′</mo>
    </msubsup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>dim</mo>
     <msub>
      <mi>R</mi>
      <mi>𝔭</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo>dim</mo>
     <mrow>
      <mrow>
       <mi>κ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>𝔭</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <msub>
       <mo>⊗</mo>
       <mi>R</mi>
      </msub>
      <mmultiscripts>
       <mi>R</mi>
       <none></none>
       <mo>′</mo>
       <msup>
        <mi>𝔭</mi>
        <mo>′</mo>
       </msup>
       <none></none>
      </mmultiscripts>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">dimension</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝔭</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">dimension</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>𝔭</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">dimension</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>R</ci>
       </apply>
       <apply>
        <times></times>
        <ci>κ</ci>
        <ci>𝔭</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>R</ci>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝔭</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dim R^{\prime}_{\mathfrak{p^{\prime}}}=\dim R_{\mathfrak{p}}+\dim\kappa(%
\mathfrak{p})\otimes_{R}{R^{\prime}}_{\mathfrak{p}^{\prime}}
  </annotation>
 </semantics>
</math>

. By <a href="Noether's_normalization_lemma" title="wikilink">Noether's normalization lemma</a>, the second term on the right side is:</p>

<p>

<math display="block" id="Dimension_theory_(algebra):94">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>dim</mo>
      <mrow>
       <mrow>
        <mi>κ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>𝔭</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <msub>
        <mo>⊗</mo>
        <mi>R</mi>
       </msub>
       <msup>
        <mi>R</mi>
        <mo>′</mo>
       </msup>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mo>dim</mo>
      <mrow>
       <mrow>
        <mrow>
         <mi>κ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>𝔭</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <msub>
         <mo>⊗</mo>
         <mi>R</mi>
        </msub>
        <msup>
         <mi>R</mi>
         <mo>′</mo>
        </msup>
       </mrow>
       <mo>/</mo>
       <msup>
        <mi>𝔭</mi>
        <mo>′</mo>
       </msup>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <mrow>
       <msub>
        <mrow>
         <mi>tr</mi>
         <mo>.</mo>
         <mi>deg</mi>
        </mrow>
        <mrow>
         <mi>κ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>𝔭</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </msub>
       <mi>κ</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>𝔭</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mrow>
        <mi>tr</mi>
        <mo>.</mo>
        <mi>deg</mi>
       </mrow>
       <mi>R</mi>
      </msub>
      <msup>
       <mi>R</mi>
       <mo>′</mo>
      </msup>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>tr</mi>
        <mo>.</mo>
        <mi>deg</mi>
       </mrow>
       <mi>κ</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>𝔭</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="latexml">dimension</csymbol>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <csymbol cd="latexml">tensor-product</csymbol>
         <ci>R</ci>
        </apply>
        <apply>
         <times></times>
         <ci>κ</ci>
         <ci>𝔭</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>R</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">dimension</csymbol>
       <apply>
        <divide></divide>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <csymbol cd="latexml">tensor-product</csymbol>
          <ci>R</ci>
         </apply>
         <apply>
          <times></times>
          <ci>κ</ci>
          <ci>𝔭</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>R</ci>
          <ci>normal-′</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝔭</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">formulae-sequence</csymbol>
          <ci>tr</ci>
          <ci>deg</ci>
         </apply>
         <apply>
          <times></times>
          <ci>κ</ci>
          <ci>𝔭</ci>
         </apply>
        </apply>
        <ci>κ</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝔭</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">formulae-sequence</csymbol>
         <ci>tr</ci>
         <ci>deg</ci>
        </apply>
        <ci>R</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>R</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">formulae-sequence</csymbol>
         <ci>tr</ci>
         <ci>deg</ci>
        </apply>
        <ci>κ</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝔭</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dim\kappa(\mathfrak{p})\otimes_{R}R^{\prime}-\dim\kappa(\mathfrak{p})\otimes_%
{R}R^{\prime}/\mathfrak{p}^{\prime}=1-\operatorname{tr.deg}_{\kappa(\mathfrak{%
p})}\kappa(\mathfrak{p}^{\prime})=\operatorname{tr.deg}_{R}R^{\prime}-%
\operatorname{tr.deg}\kappa(\mathfrak{p}^{\prime}).
  </annotation>
 </semantics>
</math>

 Next, suppose 

<math display="inline" id="Dimension_theory_(algebra):95">
 <semantics>
  <msup>
   <mi>R</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{\prime}
  </annotation>
 </semantics>
</math>

 is generated by a single element; thus, 

<math display="inline" id="Dimension_theory_(algebra):96">
 <semantics>
  <mrow>
   <msup>
    <mi>R</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>x</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi>I</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>R</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{\prime}=R[x]/I
  </annotation>
 </semantics>
</math>

. If <em>I</em> = 0, then we are already done. Suppose not. Then 

<math display="inline" id="Dimension_theory_(algebra):97">
 <semantics>
  <msup>
   <mi>R</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{\prime}
  </annotation>
 </semantics>
</math>

 is algebraic over <em>R</em> and so 

<math display="inline" id="Dimension_theory_(algebra):98">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mi>tr</mi>
      <mo>.</mo>
      <mi>deg</mi>
     </mrow>
     <mi>R</mi>
    </msub>
    <msup>
     <mi>R</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <ci>tr</ci>
       <ci>deg</ci>
      </apply>
      <ci>R</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{tr.deg}_{R}R^{\prime}=0
  </annotation>
 </semantics>
</math>

. Since <em>R</em> is a subring of <em>R{{'}}</em>, 

<math display="inline" id="Dimension_theory_(algebra):99">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mo>∩</mo>
    <mi>R</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <intersect></intersect>
     <ci>I</ci>
     <ci>R</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I\cap R=0
  </annotation>
 </semantics>
</math>

 and so 

<math display="inline" id="Dimension_theory_(algebra):100">
 <semantics>
  <mrow>
   <mrow>
    <mo>ht</mo>
    <mi>I</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>dim</mo>
    <mrow>
     <mi>R</mi>
     <msub>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>x</mi>
       <mo stretchy="false">]</mo>
      </mrow>
      <mi>I</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>dim</mo>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>R</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>x</mi>
       <mo stretchy="false">]</mo>
      </mrow>
      <mi>I</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mrow>
      <msub>
       <mrow>
        <mi>tr</mi>
        <mo>.</mo>
        <mi>deg</mi>
       </mrow>
       <mrow>
        <mi>Q</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>R</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msub>
      <mi>κ</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>I</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>ht</ci>
      <ci>I</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">dimension</csymbol>
      <apply>
       <times></times>
       <ci>R</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>x</ci>
        </apply>
        <ci>I</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">dimension</csymbol>
      <apply>
       <times></times>
       <ci>Q</ci>
       <ci>R</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>x</ci>
        </apply>
        <ci>I</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">formulae-sequence</csymbol>
          <ci>tr</ci>
          <ci>deg</ci>
         </apply>
         <apply>
          <times></times>
          <ci>Q</ci>
          <ci>R</ci>
         </apply>
        </apply>
        <ci>κ</ci>
       </apply>
       <ci>I</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{ht}I=\dim R[x]_{I}=\dim Q(R)[x]_{I}=1-\operatorname{tr.deg}_{Q(R%
)}\kappa(I)=1
  </annotation>
 </semantics>
</math>

 since 

<math display="inline" id="Dimension_theory_(algebra):101">
 <semantics>
  <mrow>
   <mrow>
    <mi>κ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>I</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>R</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>κ</ci>
     <ci>I</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa(I)=Q(R^{\prime})
  </annotation>
 </semantics>
</math>

 is algebraic over 

<math display="inline" id="Dimension_theory_(algebra):102">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(R)
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Dimension_theory_(algebra):103">
 <semantics>
  <msup>
   <mi>𝔭</mi>
   <mrow>
    <mi mathvariant="normal">′</mi>
    <mi>c</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝔭</ci>
    <list>
     <ci>normal-′</ci>
     <ci>c</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}^{\prime c}
  </annotation>
 </semantics>
</math>

 denote the pre-image in 

<math display="inline" id="Dimension_theory_(algebra):104">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R[x]
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Dimension_theory_(algebra):105">
 <semantics>
  <msup>
   <mi>𝔭</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝔭</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}^{\prime}
  </annotation>
 </semantics>
</math>

. Then, as 

<math display="inline" id="Dimension_theory_(algebra):106">
 <semantics>
  <mrow>
   <mrow>
    <mi>κ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>𝔭</mi>
      <mrow>
       <mi mathvariant="normal">′</mi>
       <mi>c</mi>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>κ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝔭</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>κ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝔭</ci>
      <list>
       <ci>normal-′</ci>
       <ci>c</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>κ</ci>
     <ci>𝔭</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa(\mathfrak{p}^{\prime c})=\kappa(\mathfrak{p})
  </annotation>
 </semantics>
</math>

, by the polynomial case,</p>

<p>

<math display="block" id="Dimension_theory_(algebra):107">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>ht</mo>
     <msup>
      <mi>𝔭</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>ht</mo>
     <mrow>
      <msup>
       <mi>𝔭</mi>
       <mrow>
        <mi mathvariant="normal">′</mi>
        <mi>c</mi>
       </mrow>
      </msup>
      <mo>/</mo>
      <mi>I</mi>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mrow>
      <mo>ht</mo>
      <msup>
       <mi>𝔭</mi>
       <mrow>
        <mi mathvariant="normal">′</mi>
        <mi>c</mi>
       </mrow>
      </msup>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mo>ht</mo>
      <mi>I</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>dim</mo>
      <msub>
       <mi>R</mi>
       <mi>𝔭</mi>
      </msub>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <msub>
        <mrow>
         <mi>tr</mi>
         <mo>.</mo>
         <mi>deg</mi>
        </mrow>
        <mrow>
         <mi>κ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>𝔭</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </msub>
       <mi>κ</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>𝔭</mi>
        <mo>′</mo>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>ht</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝔭</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <ci>ht</ci>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝔭</ci>
        <list>
         <ci>normal-′</ci>
         <ci>c</ci>
        </list>
       </apply>
       <ci>I</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <ci>ht</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝔭</ci>
        <list>
         <ci>normal-′</ci>
         <ci>c</ci>
        </list>
       </apply>
      </apply>
      <apply>
       <ci>ht</ci>
       <ci>I</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="latexml">dimension</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>𝔭</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">formulae-sequence</csymbol>
          <ci>tr</ci>
          <ci>deg</ci>
         </apply>
         <apply>
          <times></times>
          <ci>κ</ci>
          <ci>𝔭</ci>
         </apply>
        </apply>
        <ci>κ</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝔭</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{ht}{\mathfrak{p}^{\prime}}=\operatorname{ht}{\mathfrak{p}^{%
\prime c}/I}\leq\operatorname{ht}{\mathfrak{p}^{\prime c}}-\operatorname{ht}{I%
}=\dim R_{\mathfrak{p}}-\operatorname{tr.deg}_{\kappa(\mathfrak{p})}\kappa(%
\mathfrak{p}^{\prime}).
  </annotation>
 </semantics>
</math>

 Here, note that the inequality is the equality if <em>R{{'}}</em> is catenary. Finally, working with a chain of prime ideals, it is straightforward to reduce the general case to the above case. 

<math display="inline" id="Dimension_theory_(algebra):108">
 <semantics>
  <mi mathvariant="normal">□</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-□</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \square
  </annotation>
 </semantics>
</math>

</p>
<h2 id="homological-methods">Homological methods</h2>
<h3 id="regular-rings">Regular rings</h3>

<p>Let <em>R</em> be a noetherian ring. The <a href="projective_dimension" title="wikilink">projective dimension</a> of a finite <em>R</em>-module <em>M</em> is the shortest length of any projective resolution of <em>R</em> (possibly infinite) and is denoted by 

<math display="inline" id="Dimension_theory_(algebra):109">
 <semantics>
  <mrow>
   <msub>
    <mo>pd</mo>
    <mi>R</mi>
   </msub>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>pd</ci>
     <ci>R</ci>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pd}_{R}M
  </annotation>
 </semantics>
</math>

. We set 

<math display="inline" id="Dimension_theory_(algebra):110">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>gl</mi>
     <mo>.</mo>
     <mi>dim</mi>
    </mrow>
    <mi>R</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>sup</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <msub>
       <mo>pd</mo>
       <mi>R</mi>
      </msub>
      <mi>M</mi>
     </mrow>
     <mo stretchy="false">|</mo>
     <mtext>M is a finite module</mtext>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <ci>gl</ci>
      <ci>dim</ci>
     </apply>
     <ci>R</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">supremum</csymbol>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>pd</ci>
        <ci>R</ci>
       </apply>
       <ci>M</ci>
      </apply>
      <mtext>M is a finite module</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{gl.dim}R=\sup\{\operatorname{pd}_{R}M|\text{M is a finite module}\}
  </annotation>
 </semantics>
</math>

; it is called the <a href="global_dimension" title="wikilink">global dimension</a> of <em>R</em>.</p>

<p>Assume <em>R</em> is local with residue field <em>k</em>.</p>

<p>Proof: We claim: for any finite <em>R</em>-module <em>M</em>,</p>

<p>

<math display="block" id="Dimension_theory_(algebra):111">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo>pd</mo>
      <mi>R</mi>
     </msub>
     <mi>M</mi>
    </mrow>
    <mo>≤</mo>
    <mi>n</mi>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mo>Tor</mo>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mi>R</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo>,</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <leq></leq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>pd</ci>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Tor</ci>
        <ci>R</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>M</ci>
      <ci>k</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pd}_{R}M\leq n\Leftrightarrow\operatorname{Tor}^{R}_{n+1}(M,k)=0
  </annotation>
 </semantics>
</math>

. By dimension shifting (cf. the proof of Theorem of Serre below), it is enough to prove this for 

<math display="inline" id="Dimension_theory_(algebra):112">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=0
  </annotation>
 </semantics>
</math>

. But then, by the <a href="local_criterion_for_flatness" title="wikilink">local criterion for flatness</a>, 

<math display="inline" id="Dimension_theory_(algebra):113">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo>Tor</mo>
     <mn>1</mn>
     <mi>R</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo>,</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
   <mo>⇒</mo>
   <mrow>
    <mi>M</mi>
    <mtext>flat</mtext>
   </mrow>
   <mo>⇒</mo>
   <mrow>
    <mi>M</mi>
    <mtext>free</mtext>
   </mrow>
   <mo>⇒</mo>
   <mrow>
    <msub>
     <mo>pd</mo>
     <mi>R</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Tor</ci>
        <ci>R</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <ci>M</ci>
      <ci>k</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>M</ci>
      <mtext>flat</mtext>
     </apply>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>M</ci>
      <mtext>free</mtext>
     </apply>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>pd</ci>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Tor}^{R}_{1}(M,k)=0\Rightarrow M\text{ flat }\Rightarrow M\text{%
 free }\Rightarrow\operatorname{pd}_{R}(M)\leq 0.
  </annotation>
 </semantics>
</math>

 Now,</p>

<p>

<math display="block" id="Dimension_theory_(algebra):114">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>gl</mi>
      <mo>.</mo>
      <mi>dim</mi>
     </mrow>
     <mi>R</mi>
    </mrow>
    <mo>≤</mo>
    <mi>n</mi>
    <mo>⇒</mo>
    <mrow>
     <msub>
      <mo>pd</mo>
      <mi>R</mi>
     </msub>
     <mi>k</mi>
    </mrow>
    <mo>≤</mo>
    <mi>n</mi>
    <mo>⇒</mo>
    <mrow>
     <msubsup>
      <mo>Tor</mo>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mi>R</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>-</mo>
      <mo>,</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
    <mo>⇒</mo>
    <mrow>
     <msub>
      <mo>pd</mo>
      <mi>R</mi>
     </msub>
     <mo>-</mo>
    </mrow>
    <mo>≤</mo>
    <mi>n</mi>
    <mo>⇒</mo>
    <mrow>
     <mrow>
      <mi>gl</mi>
      <mo>.</mo>
      <mi>dim</mi>
     </mrow>
     <mi>R</mi>
    </mrow>
    <mo>≤</mo>
    <mi>n</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <ci>gl</ci>
       <ci>dim</ci>
      </apply>
      <ci>R</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>pd</ci>
       <ci>R</ci>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Tor</ci>
        <ci>R</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <minus></minus>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">limit-from</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>pd</ci>
       <ci>R</ci>
      </apply>
      <minus></minus>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <ci>gl</ci>
       <ci>dim</ci>
      </apply>
      <ci>R</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{gl.dim}R\leq n\Rightarrow\operatorname{pd}_{R}k\leq n\Rightarrow%
\operatorname{Tor}^{R}_{n+1}(-,k)=0\Rightarrow\operatorname{pd}_{R}-\leq n%
\Rightarrow\operatorname{gl.dim}R\leq n,
  </annotation>
 </semantics>
</math>

 completing the proof. 

<math display="inline" id="Dimension_theory_(algebra):115">
 <semantics>
  <mi mathvariant="normal">□</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-□</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \square
  </annotation>
 </semantics>
</math>

</p>

<p><strong>Remark</strong>: The proof also shows that 

<math display="inline" id="Dimension_theory_(algebra):116">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>pd</mo>
     <mi>R</mi>
    </msub>
    <mi>K</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mo>pd</mo>
      <mi>R</mi>
     </msub>
     <mi>M</mi>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>pd</ci>
      <ci>R</ci>
     </apply>
     <ci>K</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>pd</ci>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pd}_{R}K=\operatorname{pd}_{R}M-1
  </annotation>
 </semantics>
</math>

 if <em>M</em> is not free and 

<math display="inline" id="Dimension_theory_(algebra):117">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 is the kernel of some surjection from a free module to <em>M</em>.</p>

<p>Proof: If 

<math display="inline" id="Dimension_theory_(algebra):118">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>pd</mo>
     <mi>R</mi>
    </msub>
    <mi>M</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>pd</ci>
      <ci>R</ci>
     </apply>
     <ci>M</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pd}_{R}M=0
  </annotation>
 </semantics>
</math>

, then <em>M</em> is <em>R</em>-free and thus 

<math display="inline" id="Dimension_theory_(algebra):119">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>⊗</mo>
   <msub>
    <mi>R</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <ci>M</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\otimes R_{1}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Dimension_theory_(algebra):120">
 <semantics>
  <msub>
   <mi>R</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{1}
  </annotation>
 </semantics>
</math>

-free. Next suppose 

<math display="inline" id="Dimension_theory_(algebra):121">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>pd</mo>
     <mi>R</mi>
    </msub>
    <mi>M</mi>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>pd</ci>
      <ci>R</ci>
     </apply>
     <ci>M</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pd}_{R}M>0
  </annotation>
 </semantics>
</math>

. Then we have

<math display="block" id="Dimension_theory_(algebra):122">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>pd</mo>
     <mi>R</mi>
    </msub>
    <mi>K</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mo>pd</mo>
      <mi>R</mi>
     </msub>
     <mi>M</mi>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>pd</ci>
      <ci>R</ci>
     </apply>
     <ci>K</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>pd</ci>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pd}_{R}K=\operatorname{pd}_{R}M-1
  </annotation>
 </semantics>
</math>

 as in the remark above. Thus, by induction, it is enough to consider the case 

<math display="inline" id="Dimension_theory_(algebra):123">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>pd</mo>
     <mi>R</mi>
    </msub>
    <mi>M</mi>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>pd</ci>
      <ci>R</ci>
     </apply>
     <ci>M</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pd}_{R}M=1
  </annotation>
 </semantics>
</math>

. Then there is a projective resolution

<math display="block" id="Dimension_theory_(algebra):124">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <msub>
    <mi>P</mi>
    <mn>1</mn>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>P</mi>
    <mn>0</mn>
   </msub>
   <mo>→</mo>
   <mi>M</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>M</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\to P_{1}\to P_{0}\to M\to 0
  </annotation>
 </semantics>
</math>

, which gives:</p>

<p>

<math display="block" id="Dimension_theory_(algebra):125">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo>Tor</mo>
     <mn>1</mn>
     <mi>R</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo>,</mo>
     <msub>
      <mi>R</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>P</mi>
     <mn>1</mn>
    </msub>
    <mo>⊗</mo>
    <msub>
     <mi>R</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>P</mi>
     <mn>0</mn>
    </msub>
    <mo>⊗</mo>
    <msub>
     <mi>R</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>M</mi>
    <mo>⊗</mo>
    <msub>
     <mi>R</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Tor</ci>
        <ci>R</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <ci>M</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>M</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Tor}^{R}_{1}(M,R_{1})\to P_{1}\otimes R_{1}\to P_{0}\otimes R_{1%
}\to M\otimes R_{1}\to 0
  </annotation>
 </semantics>
</math>

. But 

<math display="inline" id="Dimension_theory_(algebra):126">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo>Tor</mo>
     <mn>1</mn>
     <mi>R</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo>,</mo>
     <msub>
      <mi>R</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mmultiscripts>
    <mi>M</mi>
    <mprescripts></mprescripts>
    <mi>f</mi>
    <none></none>
   </mmultiscripts>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>m</mi>
     <mo>∈</mo>
     <mi>M</mi>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mi>m</mi>
     </mrow>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Tor</ci>
        <ci>R</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <ci>M</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <in></in>
       <ci>m</ci>
       <ci>M</ci>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>m</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Tor}^{R}_{1}(M,R_{1})={}_{f}M=\{m\in M|fm=0\}=0.
  </annotation>
 </semantics>
</math>

 Hence, 

<math display="inline" id="Dimension_theory_(algebra):127">
 <semantics>
  <mrow>
   <msub>
    <mo>pd</mo>
    <mi>R</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>M</mi>
     <mo>⊗</mo>
     <msub>
      <mi>R</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>pd</ci>
     <ci>R</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>M</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pd}_{R}(M\otimes R_{1})
  </annotation>
 </semantics>
</math>

 is at most 1. 

<math display="inline" id="Dimension_theory_(algebra):128">
 <semantics>
  <mi mathvariant="normal">□</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-□</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \square
  </annotation>
 </semantics>
</math>

</p>

<p>Proof:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> If <em>R</em> is regular, we can write 

<math display="inline" id="Dimension_theory_(algebra):129">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>f</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>f</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <divide></divide>
     <ci>R</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=R/(f_{1},\dots,f_{n})
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Dimension_theory_(algebra):130">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}
  </annotation>
 </semantics>
</math>

 a regular system of parameters. An exact sequence 

<math display="inline" id="Dimension_theory_(algebra):131">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mrow>
    <mi>M</mi>
    <mover accent="true">
     <mo>→</mo>
     <mo>𝑓</mo>
    </mover>
    <mi>M</mi>
   </mrow>
   <mo>→</mo>
   <msub>
    <mi>M</mi>
    <mn>1</mn>
   </msub>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <ci>M</ci>
      <apply>
       <ci>f</ci>
       <ci>normal-→</ci>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\to M\overset{f}{\to}M\to M_{1}\to 0
  </annotation>
 </semantics>
</math>

, some <em>f</em> in the maximal ideal, of finite modules, 

<math display="inline" id="Dimension_theory_(algebra):132">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>pd</mo>
     <mi>R</mi>
    </msub>
    <mi>M</mi>
   </mrow>
   <mo><</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>pd</ci>
      <ci>R</ci>
     </apply>
     <ci>M</ci>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pd}_{R}M<\infty
  </annotation>
 </semantics>
</math>

, gives us:</p>

<p>

<math display="block" id="Dimension_theory_(algebra):133">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mn>0</mn>
     <mo>=</mo>
     <mrow>
      <msubsup>
       <mo>Tor</mo>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mi>R</mi>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>M</mi>
       <mo>,</mo>
       <mi>k</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>→</mo>
     <mrow>
      <msubsup>
       <mo>Tor</mo>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mi>R</mi>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>M</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi>k</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>→</mo>
     <mrow>
      <mrow>
       <msubsup>
        <mo>Tor</mo>
        <mi>i</mi>
        <mi>R</mi>
       </msubsup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>M</mi>
        <mo>,</mo>
        <mi>k</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mover accent="true">
       <mo>→</mo>
       <mo>𝑓</mo>
      </mover>
      <mrow>
       <msubsup>
        <mo>Tor</mo>
        <mi>i</mi>
        <mi>R</mi>
       </msubsup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>M</mi>
        <mo>,</mo>
        <mi>k</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mi>i</mi>
     <mo>≥</mo>
     <mrow>
      <msub>
       <mo>pd</mo>
       <mi>R</mi>
      </msub>
      <mi>M</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <cn type="integer">0</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>Tor</ci>
         <ci>R</ci>
        </apply>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>M</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>Tor</ci>
         <ci>R</ci>
        </apply>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>Tor</ci>
          <ci>R</ci>
         </apply>
         <ci>i</ci>
        </apply>
        <ci>M</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <ci>f</ci>
        <ci>normal-→</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>Tor</ci>
          <ci>R</ci>
         </apply>
         <ci>i</ci>
        </apply>
        <ci>M</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <ci>i</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>pd</ci>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0=\operatorname{Tor}^{R}_{i+1}(M,k)\to\operatorname{Tor}^{R}_{i+1}(M_{1},k)\to%
\operatorname{Tor}^{R}_{i}(M,k)\overset{f}{\to}\operatorname{Tor}^{R}_{i}(M,k)%
,\quad i\geq\operatorname{pd}_{R}M.
  </annotation>
 </semantics>
</math>

 But <em>f</em> here is zero since it kills <em>k</em>. Thus, 

<math display="inline" id="Dimension_theory_(algebra):134">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo>Tor</mo>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mi>R</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>M</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≃</mo>
   <mrow>
    <msubsup>
     <mo>Tor</mo>
     <mi>i</mi>
     <mi>R</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo>,</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to-or-equals</csymbol>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Tor</ci>
       <ci>R</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Tor</ci>
       <ci>R</ci>
      </apply>
      <ci>i</ci>
     </apply>
     <ci>M</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Tor}^{R}_{i+1}(M_{1},k)\simeq\operatorname{Tor}^{R}_{i}(M,k)
  </annotation>
 </semantics>
</math>

 and consequently 

<math display="inline" id="Dimension_theory_(algebra):135">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>pd</mo>
     <mi>R</mi>
    </msub>
    <msub>
     <mi>M</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <msub>
      <mo>pd</mo>
      <mi>R</mi>
     </msub>
     <mi>M</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>pd</ci>
      <ci>R</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>pd</ci>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pd}_{R}M_{1}=1+\operatorname{pd}_{R}M
  </annotation>
 </semantics>
</math>

. Using this, we get:</p>

<p>

<math display="block" id="Dimension_theory_(algebra):136">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo>pd</mo>
      <mi>R</mi>
     </msub>
     <mi>k</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <msub>
       <mo>pd</mo>
       <mi>R</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>R</mi>
        <mo>/</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>f</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo>,</mo>
         <msub>
          <mi>f</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>=</mo>
    <mi>n</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>pd</ci>
       <ci>R</ci>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>pd</ci>
        <ci>R</ci>
       </apply>
       <apply>
        <divide></divide>
        <ci>R</ci>
        <vector>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <apply>
           <minus></minus>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </vector>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pd}_{R}k=1+\operatorname{pd}_{R}(R/(f_{1},\dots,f_{n-1}))=\cdots%
=n.
  </annotation>
 </semantics>
</math>

 The proof of the converse is by induction on 

<math display="inline" id="Dimension_theory_(algebra):137">
 <semantics>
  <mrow>
   <mo>dim</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>dim</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{dim}R
  </annotation>
 </semantics>
</math>

. We begin with the inductive step. Set 

<math display="inline" id="Dimension_theory_(algebra):138">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mo>/</mo>
     <msub>
      <mi>f</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>R</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{1}=R/f_{1}R
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Dimension_theory_(algebra):139">
 <semantics>
  <msub>
   <mi>f</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1}
  </annotation>
 </semantics>
</math>

 among a system of parameters. To show <em>R</em> is regular, it is enough to show 

<math display="inline" id="Dimension_theory_(algebra):140">
 <semantics>
  <msub>
   <mi>R</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{1}
  </annotation>
 </semantics>
</math>

 is regular. But, since 

<math display="inline" id="Dimension_theory_(algebra):141">
 <semantics>
  <mrow>
   <mrow>
    <mo>dim</mo>
    <msub>
     <mi>R</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo><</mo>
   <mrow>
    <mo>dim</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="latexml">dimension</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">dimension</csymbol>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dim R_{1}<\dim R
  </annotation>
 </semantics>
</math>

, by inductive hypothesis and the preceding lemma with 

<math display="inline" id="Dimension_theory_(algebra):142">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mi>𝔪</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <ci>𝔪</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=\mathfrak{m}
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Dimension_theory_(algebra):143">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>gl</mi>
      <mo>.</mo>
      <mi>dim</mi>
     </mrow>
     <mi>R</mi>
    </mrow>
    <mo><</mo>
    <mi mathvariant="normal">∞</mi>
    <mo>⇒</mo>
    <mrow>
     <mrow>
      <mi>gl</mi>
      <mo>.</mo>
      <mi>dim</mi>
     </mrow>
     <msub>
      <mi>R</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo>pd</mo>
      <msub>
       <mi>R</mi>
       <mn>1</mn>
      </msub>
     </msub>
     <mi>k</mi>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <msub>
      <mo>pd</mo>
      <msub>
       <mi>R</mi>
       <mn>1</mn>
      </msub>
     </msub>
     <mrow>
      <mrow>
       <mi>𝔪</mi>
       <mo>/</mo>
       <msub>
        <mi>f</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mi>𝔪</mi>
     </mrow>
    </mrow>
    <mo><</mo>
    <mi mathvariant="normal">∞</mi>
    <mo>⇒</mo>
    <mrow>
     <msub>
      <mi>R</mi>
      <mn>1</mn>
     </msub>
     <mtext>regular</mtext>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <ci>gl</ci>
       <ci>dim</ci>
      </apply>
      <ci>R</ci>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <ci>gl</ci>
       <ci>dim</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>pd</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>pd</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>𝔪</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>𝔪</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <infinity></infinity>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <cn type="integer">1</cn>
      </apply>
      <mtext>regular</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{gl.dim}R<\infty\Rightarrow\operatorname{gl.dim}R_{1}=%
\operatorname{pd}_{R_{1}}k\leq\operatorname{pd}_{R_{1}}\mathfrak{m}/f_{1}%
\mathfrak{m}<\infty\Rightarrow R_{1}\text{ regular}.
  </annotation>
 </semantics>
</math>

</p>

<p>The basic step remains. Suppose 

<math display="inline" id="Dimension_theory_(algebra):144">
 <semantics>
  <mrow>
   <mrow>
    <mo>dim</mo>
    <mi>R</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>dim</ci>
     <ci>R</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{dim}R=0
  </annotation>
 </semantics>
</math>

. We claim 

<math display="inline" id="Dimension_theory_(algebra):145">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>gl</mi>
     <mo>.</mo>
     <mi>dim</mi>
    </mrow>
    <mi>R</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <ci>gl</ci>
      <ci>dim</ci>
     </apply>
     <ci>R</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{gl.dim}R=0
  </annotation>
 </semantics>
</math>

 if it is finite. (This would imply that <em>R</em> is a <a href="semisimple_local_ring" title="wikilink">semisimple local ring</a>; i.e., a field.) If that is not the case, then there is some finite module 

<math display="inline" id="Dimension_theory_(algebra):146">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Dimension_theory_(algebra):147">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo><</mo>
   <mrow>
    <msub>
     <mo>pd</mo>
     <mi>R</mi>
    </msub>
    <mi>M</mi>
   </mrow>
   <mo><</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>pd</ci>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<\operatorname{pd}_{R}M<\infty
  </annotation>
 </semantics>
</math>

 and thus in fact we can find <em>M</em> with 

<math display="inline" id="Dimension_theory_(algebra):148">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>pd</mo>
     <mi>R</mi>
    </msub>
    <mi>M</mi>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>pd</ci>
      <ci>R</ci>
     </apply>
     <ci>M</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pd}_{R}M=1
  </annotation>
 </semantics>
</math>

. By Nakayama's lemma, there is a surjection 

<math display="inline" id="Dimension_theory_(algebra):149">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>→</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>F</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\to M
  </annotation>
 </semantics>
</math>

 from a free module <em>F</em> to <em>M</em> whose kernel <em>K</em> is contained in 

<math display="inline" id="Dimension_theory_(algebra):150">
 <semantics>
  <mrow>
   <mi>𝔪</mi>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝔪</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}F
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Dimension_theory_(algebra):151">
 <semantics>
  <mrow>
   <mrow>
    <mo>dim</mo>
    <mi>R</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>dim</ci>
     <ci>R</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{dim}R=0
  </annotation>
 </semantics>
</math>

, the maximal ideal 

<math display="inline" id="Dimension_theory_(algebra):152">
 <semantics>
  <mi>𝔪</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔪</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}
  </annotation>
 </semantics>
</math>

 is an <a href="associated_prime" title="wikilink">associated prime</a> of <em>R</em>; i.e., 

<math display="inline" id="Dimension_theory_(algebra):153">
 <semantics>
  <mrow>
   <mi>𝔪</mi>
   <mo>=</mo>
   <mrow>
    <mo>ann</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝔪</ci>
    <apply>
     <ci>ann</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}=\operatorname{ann}(s)
  </annotation>
 </semantics>
</math>

 for some nonzero <em>s</em> in <em>R</em>. Since 

<math display="inline" id="Dimension_theory_(algebra):154">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>⊂</mo>
   <mrow>
    <mi>𝔪</mi>
    <mi>F</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>K</ci>
    <apply>
     <times></times>
     <ci>𝔪</ci>
     <ci>F</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\subset\mathfrak{m}F
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Dimension_theory_(algebra):155">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mi>K</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>K</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   sK=0
  </annotation>
 </semantics>
</math>

. Since <em>K</em> is not zero and is free, this implies 

<math display="inline" id="Dimension_theory_(algebra):156">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=0
  </annotation>
 </semantics>
</math>

, which is absurd. 

<math display="inline" id="Dimension_theory_(algebra):157">
 <semantics>
  <mi mathvariant="normal">□</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-□</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \square
  </annotation>
 </semantics>
</math>

 </p>

<p>Proof: Let <em>R</em> be a regular local ring. Then 

<math display="inline" id="Dimension_theory_(algebra):158">
 <semantics>
  <mrow>
   <mrow>
    <mo>gr</mo>
    <mi>R</mi>
   </mrow>
   <mo>≃</mo>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>d</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to-or-equals</csymbol>
    <apply>
     <ci>gr</ci>
     <ci>R</ci>
    </apply>
    <apply>
     <times></times>
     <ci>k</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>d</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{gr}R\simeq k[x_{1},\dots,x_{d}]
  </annotation>
 </semantics>
</math>

, which is an integrally closed domain. It is a standard algebra exercise to show this implies that <em>R</em> is an integrally closed domain. Now, we need to show every <a href="divisorial_ideal" title="wikilink">divisorial ideal</a> is principal; i.e., the divisor class group of <em>R</em> vanishes. But, according to Bourbaki, <em>Algèbre commutative,</em> chapitre 7, §. 4. Corollary 2 to Proposition 16, a divisorial ideal is principal if it admits a finite free resolution, which is indeed the case by the theorem. 

<math display="inline" id="Dimension_theory_(algebra):159">
 <semantics>
  <mi mathvariant="normal">□</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-□</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \square
  </annotation>
 </semantics>
</math>

</p>
<h3 id="depths">Depths</h3>

<p>Let <em>R</em> be a ring and <em>M</em> a module over it. A sequence of elements 

<math display="inline" id="Dimension_theory_(algebra):160">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\dots,x_{n}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Dimension_theory_(algebra):161">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is called an <em>M</em>-<a href="regular_sequence" title="wikilink">regular sequence</a> if 

<math display="inline" id="Dimension_theory_(algebra):162">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 is not a zero-divisor on 

<math display="inline" id="Dimension_theory_(algebra):163">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dimension_theory_(algebra):164">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 is not a zero divisor on 

<math display="inline" id="Dimension_theory_(algebra):165">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>M</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </vector>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M/(x_{1},\dots,x_{i-1})M
  </annotation>
 </semantics>
</math>

 for each 

<math display="inline" id="Dimension_theory_(algebra):166">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=2,\dots,n
  </annotation>
 </semantics>
</math>

. <em>A priori</em>, it is not obvious whether any permutation of a regular sequence is still regular (see the section below for some positive answer.)</p>

<p>Let <em>R</em> be a local Noetherian ring with maximal ideal 

<math display="inline" id="Dimension_theory_(algebra):167">
 <semantics>
  <mi>𝔪</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔪</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}
  </annotation>
 </semantics>
</math>

 and put 

<math display="inline" id="Dimension_theory_(algebra):168">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mo>/</mo>
    <mi>𝔪</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <divide></divide>
     <ci>R</ci>
     <ci>𝔪</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=R/\mathfrak{m}
  </annotation>
 </semantics>
</math>

. Then, by definition, the <a href="depth_(ring_theory)" title="wikilink">depth</a> of a finite <em>R</em>-module <em>M</em> is the supremum of the lengths of all <em>M</em>-regular sequences in 

<math display="inline" id="Dimension_theory_(algebra):169">
 <semantics>
  <mi>𝔪</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔪</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}
  </annotation>
 </semantics>
</math>

. For example, we have 

<math display="inline" id="Dimension_theory_(algebra):170">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>depth</mo>
     <mi>M</mi>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>⇔</mo>
   <mi>𝔪</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <eq></eq>
     <apply>
      <ci>depth</ci>
      <ci>M</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <ci>𝔪</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{depth}M=0\Leftrightarrow\mathfrak{m}
  </annotation>
 </semantics>
</math>

 consists of zerodivisors on <em>M</em> 

<math display="inline" id="Dimension_theory_(algebra):171">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⇔</mo>
   <mi>𝔪</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <csymbol cd="latexml">absent</csymbol>
    <ci>𝔪</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Leftrightarrow\mathfrak{m}
  </annotation>
 </semantics>
</math>

 is associated with <em>M</em>. By induction, we find</p>

<p>

<math display="block" id="Dimension_theory_(algebra):172">
 <semantics>
  <mrow>
   <mrow>
    <mo>depth</mo>
    <mi>M</mi>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mo>dim</mo>
    <mrow>
     <mi>R</mi>
     <mo>/</mo>
     <mi>𝔭</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <ci>depth</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">dimension</csymbol>
     <apply>
      <divide></divide>
      <ci>R</ci>
      <ci>𝔭</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{depth}M\leq\dim R/{\mathfrak{p}}
  </annotation>
 </semantics>
</math>

 for any associated primes 

<math display="inline" id="Dimension_theory_(algebra):173">
 <semantics>
  <mi>𝔭</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔭</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{p}
  </annotation>
 </semantics>
</math>

 of <em>M</em>. In particular, 

<math display="inline" id="Dimension_theory_(algebra):174">
 <semantics>
  <mrow>
   <mrow>
    <mo>depth</mo>
    <mi>M</mi>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mo>dim</mo>
    <mi>M</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <ci>depth</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <ci>dim</ci>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{depth}M\leq\operatorname{dim}M
  </annotation>
 </semantics>
</math>

. If the equality holds for <em>M</em> = <em>R</em>, <em>R</em> is called a <a href="Cohen–Macaulay_ring" title="wikilink">Cohen–Macaulay ring</a>.</p>

<p><strong>Example</strong>: A regular Noetherian local ring is Cohen–Macaulay (since a regular system of parameters is an <em>R</em>-regular sequence.)</p>

<p>In general, a Noetherian ring is called a Cohen–Macaulay ring if the localizations at all maximal ideals are Cohen–Macaulay. We note that a Cohen–Macaulay ring is universally catenary. This implies for example that a polynomial ring 

<math display="inline" id="Dimension_theory_(algebra):175">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>d</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>d</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k[x_{1},\dots,x_{d}]
  </annotation>
 </semantics>
</math>

 is universally catenary since it is regular and thus Cohen–Macaulay.</p>

<p>Proof: We first prove by induction on <em>n</em> the following statement: for every <em>R</em>-module <em>M</em> and every <em>M</em>-regular sequence 

<math display="inline" id="Dimension_theory_(algebra):176">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\dots,x_{n}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Dimension_theory_(algebra):177">
 <semantics>
  <mi>𝔪</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔪</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}
  </annotation>
 </semantics>
</math>

,</p>
<dl>
<dd>(*) 

<math display="inline" id="Dimension_theory_(algebra):178">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mo>Ext</mo>
      <mi>R</mi>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>N</mi>
      <mo>,</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≃</mo>
    <mrow>
     <msub>
      <mo>Hom</mo>
      <mi>R</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>N</mi>
      <mo>,</mo>
      <mrow>
       <mrow>
        <mi>M</mi>
        <mo>/</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo>,</mo>
         <msub>
          <mi>x</mi>
          <mi>n</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mi>M</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to-or-equals</csymbol>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Ext</ci>
       <ci>R</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <ci>N</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Hom</ci>
      <ci>R</ci>
     </apply>
     <ci>N</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>M</ci>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </vector>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Ext}_{R}^{n}(N,M)\simeq\operatorname{Hom}_{R}(N,M/(x_{1},\dots,x%
_{n})M).
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>The basic step <em>n</em> = 0 is trivial. Next, by inductive hypothesis, 

<math display="inline" id="Dimension_theory_(algebra):179">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo>Ext</mo>
     <mi>R</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≃</mo>
   <mrow>
    <msub>
     <mo>Hom</mo>
     <mi>R</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mi>M</mi>
       <mo>/</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mi>M</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to-or-equals</csymbol>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Ext</ci>
       <ci>R</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>N</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Hom</ci>
      <ci>R</ci>
     </apply>
     <ci>N</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>M</ci>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </vector>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Ext}_{R}^{n-1}(N,M)\simeq\operatorname{Hom}_{R}(N,M/(x_{1},\dots%
,x_{n-1})M)
  </annotation>
 </semantics>
</math>

. But the latter is zero since the annihilator of <em>N</em> contains some power of 

<math display="inline" id="Dimension_theory_(algebra):180">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}
  </annotation>
 </semantics>
</math>

. Thus, from the exact sequence 

<math display="inline" id="Dimension_theory_(algebra):181">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mrow>
    <mi>M</mi>
    <mover accent="true">
     <mo>→</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
    </mover>
    <mi>M</mi>
   </mrow>
   <mo>→</mo>
   <msub>
    <mi>M</mi>
    <mn>1</mn>
   </msub>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <ci>M</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-→</ci>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\to M\overset{x_{1}}{\to}M\to M_{1}\to 0
  </annotation>
 </semantics>
</math>

 and the fact that 

<math display="inline" id="Dimension_theory_(algebra):182">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 kills <em>N</em>, using the inductive hypothesis again, we get</p>

<p>

<math display="block" id="Dimension_theory_(algebra):183">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo>Ext</mo>
     <mi>R</mi>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≃</mo>
   <mrow>
    <msubsup>
     <mo>Ext</mo>
     <mi>R</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mi>M</mi>
       <mo>/</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mi>M</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≃</mo>
   <mrow>
    <msub>
     <mo>Hom</mo>
     <mi>R</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mi>M</mi>
       <mo>/</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mi>M</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">similar-to-or-equals</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Ext</ci>
        <ci>n</ci>
       </apply>
       <ci>R</ci>
      </apply>
      <ci>N</ci>
      <ci>M</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Ext</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>R</ci>
      </apply>
      <ci>N</ci>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>M</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>M</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">similar-to-or-equals</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Hom</ci>
       <ci>R</ci>
      </apply>
      <ci>N</ci>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>M</ci>
        <vector>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>n</ci>
         </apply>
        </vector>
       </apply>
       <ci>M</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Ext}^{n}_{R}(N,M)\simeq\operatorname{Ext}^{n-1}_{R}(N,M/x_{1}M)%
\simeq\operatorname{Hom}_{R}(N,M/(x_{1},\dots,x_{n})M)
  </annotation>
 </semantics>
</math>

, proving (*). Now, if 

<math display="inline" id="Dimension_theory_(algebra):184">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo><</mo>
   <mrow>
    <mo>depth</mo>
    <mi>M</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>n</ci>
    <apply>
     <ci>depth</ci>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n<\operatorname{depth}M
  </annotation>
 </semantics>
</math>

, then we can find an <em>M</em>-regular sequence of length more than <em>n</em> and so by (*) we see 

<math display="inline" id="Dimension_theory_(algebra):185">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo>Ext</mo>
     <mi>R</mi>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Ext</ci>
       <ci>R</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <ci>N</ci>
     <ci>M</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Ext}_{R}^{n}(N,M)=0
  </annotation>
 </semantics>
</math>

. It remains to show 

<math display="inline" id="Dimension_theory_(algebra):186">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo>Ext</mo>
     <mi>R</mi>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Ext</ci>
       <ci>R</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <ci>N</ci>
     <ci>M</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Ext}_{R}^{n}(N,M)\neq 0
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Dimension_theory_(algebra):187">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mo>depth</mo>
    <mi>M</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <ci>depth</ci>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=\operatorname{depth}M
  </annotation>
 </semantics>
</math>

. By (*) we can assume <em>n</em> = 0. Then 

<math display="inline" id="Dimension_theory_(algebra):188">
 <semantics>
  <mi>𝔪</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔪</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}
  </annotation>
 </semantics>
</math>

 is associated with <em>M</em>; thus is in the support of <em>M</em>. On the other hand, 

<math display="inline" id="Dimension_theory_(algebra):189">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝔪</mi>
    <mo>∈</mo>
    <mrow>
     <mo>Supp</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>N</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>𝔪</ci>
    <apply>
     <ci>Supp</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}\in\operatorname{Supp}(N).
  </annotation>
 </semantics>
</math>

 It follows by linear algebra that there is a nonzero homomorphism from <em>N</em> to <em>M</em> modulo 

<math display="inline" id="Dimension_theory_(algebra):190">
 <semantics>
  <mi>𝔪</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝔪</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}
  </annotation>
 </semantics>
</math>

; hence, one from <em>N</em> to <em>M</em> by Nakayama's lemma. 

<math display="inline" id="Dimension_theory_(algebra):191">
 <semantics>
  <mi mathvariant="normal">□</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-□</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \square
  </annotation>
 </semantics>
</math>

</p>

<p>The <a href="Auslander–Buchsbaum_formula" title="wikilink">Auslander–Buchsbaum formula</a> relates depth and projective dimension.</p>

<p>Proof: We argue by induction on 

<math display="inline" id="Dimension_theory_(algebra):192">
 <semantics>
  <mrow>
   <msub>
    <mo>pd</mo>
    <mi>R</mi>
   </msub>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>pd</ci>
     <ci>R</ci>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pd}_{R}M
  </annotation>
 </semantics>
</math>

, the basic case (i.e., <em>M</em> free) being trivial. By Nakayama's lemma, we have the exact sequence 

<math display="inline" id="Dimension_theory_(algebra):193">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mrow>
    <mi>K</mi>
    <mover accent="true">
     <mo>→</mo>
     <mo>𝑓</mo>
    </mover>
    <mi>F</mi>
   </mrow>
   <mo>→</mo>
   <mi>M</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <ci>K</ci>
      <apply>
       <ci>f</ci>
       <ci>normal-→</ci>
      </apply>
      <ci>F</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>M</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\to K\overset{f}{\to}F\to M\to 0
  </annotation>
 </semantics>
</math>

 where <em>F</em> is free and the image of <em>f</em> is contained in 

<math display="inline" id="Dimension_theory_(algebra):194">
 <semantics>
  <mrow>
   <mi>𝔪</mi>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝔪</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}F
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Dimension_theory_(algebra):195">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo>pd</mo>
      <mi>R</mi>
     </msub>
     <mi>K</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mo>pd</mo>
       <mi>R</mi>
      </msub>
      <mi>M</mi>
     </mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>pd</ci>
      <ci>R</ci>
     </apply>
     <ci>K</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>pd</ci>
       <ci>R</ci>
      </apply>
      <ci>M</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{pd}_{R}K=\operatorname{pd}_{R}M-1,
  </annotation>
 </semantics>
</math>

 what we need to show is 

<math display="inline" id="Dimension_theory_(algebra):196">
 <semantics>
  <mrow>
   <mrow>
    <mo>depth</mo>
    <mi>K</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>depth</mo>
     <mi>M</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>depth</ci>
     <ci>K</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <ci>depth</ci>
      <ci>M</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{depth}K=\operatorname{depth}M+1
  </annotation>
 </semantics>
</math>

. Since <em>f</em> kills <em>k</em>, the exact sequence yields: for any <em>i</em>,</p>

<p>

<math display="block" id="Dimension_theory_(algebra):197">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo>Ext</mo>
     <mi>R</mi>
     <mi>i</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo>,</mo>
     <mi>F</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msubsup>
     <mo>Ext</mo>
     <mi>R</mi>
     <mi>i</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msubsup>
     <mo>Ext</mo>
     <mi>R</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo>,</mo>
     <mi>K</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Ext</ci>
        <ci>R</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <ci>k</ci>
      <ci>F</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Ext</ci>
        <ci>R</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <ci>k</ci>
      <ci>M</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Ext</ci>
        <ci>R</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>k</ci>
      <ci>K</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Ext}_{R}^{i}(k,F)\to\operatorname{Ext}_{R}^{i}(k,M)\to%
\operatorname{Ext}_{R}^{i+1}(k,K)\to 0.
  </annotation>
 </semantics>
</math>

 Note the left-most term is zero if 

<math display="inline" id="Dimension_theory_(algebra):198">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo><</mo>
   <mrow>
    <mo>depth</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>i</ci>
    <apply>
     <ci>depth</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i<\operatorname{depth}R
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Dimension_theory_(algebra):199">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo><</mo>
   <mrow>
    <mrow>
     <mo>depth</mo>
     <mi>K</mi>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>i</ci>
    <apply>
     <minus></minus>
     <apply>
      <ci>depth</ci>
      <ci>K</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i<\operatorname{depth}K-1
  </annotation>
 </semantics>
</math>

, then since 

<math display="inline" id="Dimension_theory_(algebra):200">
 <semantics>
  <mrow>
   <mrow>
    <mo>depth</mo>
    <mi>K</mi>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mo>depth</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <ci>depth</ci>
     <ci>K</ci>
    </apply>
    <apply>
     <ci>depth</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{depth}K\leq\operatorname{depth}R
  </annotation>
 </semantics>
</math>

 by inductive hypothesis, we see 

<math display="inline" id="Dimension_theory_(algebra):201">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo>Ext</mo>
     <mi>R</mi>
     <mi>i</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Ext</ci>
       <ci>R</ci>
      </apply>
      <ci>i</ci>
     </apply>
     <ci>k</ci>
     <ci>M</ci>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Ext}_{R}^{i}(k,M)=0.
  </annotation>
 </semantics>
</math>

 If 

<math display="inline" id="Dimension_theory_(algebra):202">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>depth</mo>
     <mi>K</mi>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <apply>
     <minus></minus>
     <apply>
      <ci>depth</ci>
      <ci>K</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=\operatorname{depth}K-1
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Dimension_theory_(algebra):203">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo>Ext</mo>
     <mi>R</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo>,</mo>
     <mi>K</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Ext</ci>
       <ci>R</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>k</ci>
     <ci>K</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Ext}_{R}^{i+1}(k,K)\neq 0
  </annotation>
 </semantics>
</math>

 and it must be 

<math display="inline" id="Dimension_theory_(algebra):204">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo>Ext</mo>
     <mi>R</mi>
     <mi>i</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Ext</ci>
       <ci>R</ci>
      </apply>
      <ci>i</ci>
     </apply>
     <ci>k</ci>
     <ci>M</ci>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Ext}_{R}^{i}(k,M)\neq 0.
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Dimension_theory_(algebra):205">
 <semantics>
  <mi mathvariant="normal">□</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-□</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \square
  </annotation>
 </semantics>
</math>

</p>

<p>As a matter of notation, for any <em>R</em>-module <em>M</em>, we let</p>

<p>

<math display="block" id="Dimension_theory_(algebra):206">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi mathvariant="normal">Γ</mi>
      <mi>𝔪</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>s</mi>
      <mo>∈</mo>
      <mi>M</mi>
     </mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mrow>
       <mo>supp</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⊂</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>𝔪</mi>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>s</mi>
      <mo>∈</mo>
      <mi>M</mi>
     </mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mrow>
       <msup>
        <mi>𝔪</mi>
        <mi>j</mi>
       </msup>
       <mi>s</mi>
      </mrow>
      <mo>=</mo>
      <mrow>
       <mn>0</mn>
       <mtext>for some</mtext>
       <mi>j</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Γ</ci>
       <ci>𝔪</ci>
      </apply>
      <ci>M</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <in></in>
       <ci>s</ci>
       <ci>M</ci>
      </apply>
      <apply>
       <subset></subset>
       <apply>
        <ci>supp</ci>
        <ci>s</ci>
       </apply>
       <set>
        <ci>𝔪</ci>
       </set>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <in></in>
       <ci>s</ci>
       <ci>M</ci>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝔪</ci>
         <ci>j</ci>
        </apply>
        <ci>s</ci>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">0</cn>
        <mtext>for some</mtext>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma_{\mathfrak{m}}(M)=\{s\in M|\operatorname{supp}(s)\subset\{\mathfrak{m}%
\}\}=\{s\in M|\mathfrak{m}^{j}s=0\text{ for some }j\}.
  </annotation>
 </semantics>
</math>

 One sees without difficulty that 

<math display="inline" id="Dimension_theory_(algebra):207">
 <semantics>
  <msub>
   <mi mathvariant="normal">Γ</mi>
   <mi>𝔪</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Γ</ci>
    <ci>𝔪</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma_{\mathfrak{m}}
  </annotation>
 </semantics>
</math>

 is a left-exact functor and then let 

<math display="inline" id="Dimension_theory_(algebra):208">
 <semantics>
  <mrow>
   <msubsup>
    <mi>H</mi>
    <mi>𝔪</mi>
    <mi>j</mi>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>R</mi>
     <mi>j</mi>
    </msup>
    <msub>
     <mi mathvariant="normal">Γ</mi>
     <mi>𝔪</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>j</ci>
     </apply>
     <ci>𝔪</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Γ</ci>
      <ci>𝔪</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{j}_{\mathfrak{m}}=R^{j}\Gamma_{\mathfrak{m}}
  </annotation>
 </semantics>
</math>

 be its <em>j</em>-th <a href="right_derived_functor" title="wikilink">right derived functor</a>, called the <a href="local_cohomology" title="wikilink">local cohomology</a> of <em>R</em>. Since 

<math display="inline" id="Dimension_theory_(algebra):209">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Γ</mi>
     <mi>𝔪</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder accentunder="true">
     <mo>lim</mo>
     <mo>→</mo>
    </munder>
    <mrow>
     <msub>
      <mo>Hom</mo>
      <mi>R</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>R</mi>
       <mo>/</mo>
       <msup>
        <mi>𝔪</mi>
        <mi>j</mi>
       </msup>
      </mrow>
      <mo>,</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Γ</ci>
      <ci>𝔪</ci>
     </apply>
     <ci>M</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">injective-limit</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Hom</ci>
       <ci>R</ci>
      </apply>
      <apply>
       <divide></divide>
       <ci>R</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝔪</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma_{\mathfrak{m}}(M)=\underrightarrow{\lim}\operatorname{Hom}_{R}(R/%
\mathfrak{m}^{j},M)
  </annotation>
 </semantics>
</math>

, via abstract nonsense,</p>

<p>

<math display="block" id="Dimension_theory_(algebra):210">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>H</mi>
     <mi>𝔪</mi>
     <mi>i</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder accentunder="true">
     <mo movablelimits="false">lim</mo>
     <mo>→</mo>
    </munder>
    <mrow>
     <msubsup>
      <mo>Ext</mo>
      <mi>R</mi>
      <mi>i</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>R</mi>
       <mo>/</mo>
       <msup>
        <mi>𝔪</mi>
        <mi>j</mi>
       </msup>
      </mrow>
      <mo>,</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <ci>i</ci>
      </apply>
      <ci>𝔪</ci>
     </apply>
     <ci>M</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">injective-limit</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Ext</ci>
        <ci>i</ci>
       </apply>
       <ci>R</ci>
      </apply>
      <apply>
       <divide></divide>
       <ci>R</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝔪</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{i}_{\mathfrak{m}}(M)=\underrightarrow{\lim}\operatorname{Ext}^{i}_{R}(R/{%
\mathfrak{m}}^{j},M)
  </annotation>
 </semantics>
</math>

. This observation proves the first part of the theorem below. (M) = 0, i .</p>
<ol>
<li>

<math display="inline" id="Dimension_theory_(algebra):211">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>H</mi>
      <mi>𝔪</mi>
      <mi>i</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>i</mi>
    <mo>></mo>
    <mrow>
     <mo>dim</mo>
     <mi>M</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <ci>𝔪</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <ci>M</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <gt></gt>
     <ci>i</ci>
     <apply>
      <csymbol cd="latexml">dimension</csymbol>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{\mathfrak{m}}^{i}(M)=0,i>\dim M
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dimension_theory_(algebra):212">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <csymbol cd="latexml">absent</csymbol>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neq 0
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Dimension_theory_(algebra):213">
 <semantics>
  <mrow>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mrow>
     <mo>dim</mo>
     <mi>M</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <apply>
     <csymbol cd="latexml">dimension</csymbol>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=\dim M.
  </annotation>
 </semantics>
</math>

</li>
<li>If <em>R</em> is complete and <em>d</em> its Krull dimension and if <em>E</em> is the <a href="injective_hull" title="wikilink">injective hull</a> of <em>k</em>, then

<p>

<math display="block" id="Dimension_theory_(algebra):214">
 <semantics>
  <mrow>
   <msub>
    <mo>Hom</mo>
    <mi>R</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msubsup>
      <mi>H</mi>
      <mi>𝔪</mi>
      <mi>d</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>-</mo>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Hom</ci>
     <ci>R</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>H</ci>
       <ci>d</ci>
      </apply>
      <ci>𝔪</ci>
     </apply>
     <minus></minus>
    </apply>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Hom}_{R}(H^{d}_{\mathfrak{m}}(-),E)
  </annotation>
 </semantics>
</math>

</p></li>
</ol>
<dl>
<dd><dl>
<dd>is representable (the representing object is sometimes called the <a href="canonical_module" title="wikilink">canonical module</a> especially if <em>R</em> is Cohen–Macaulay.)
</dd>
</dl>
</dd>
</dl>

<p>}} Proof: 1. is already noted (except to show the nonvanishing at the degree equal to the depth of <em>M</em>; use induction to see this) and 3. is a general fact by abstract nonsense. 2. is a consequence of an explicit computation of a local cohomology by means of Koszul complexes (see below). 

<math display="inline" id="Dimension_theory_(algebra):215">
 <semantics>
  <mi mathvariant="normal">□</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-□</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \square
  </annotation>
 </semantics>
</math>

</p>
<h3 id="koszul-complex">Koszul complex</h3>

<p>Let <em>R</em> be a ring and <em>x</em> an element in it. We form the <a href="chain_complex" title="wikilink">chain complex</a> <em>K</em>(<em>x</em>) given by 

<math display="inline" id="Dimension_theory_(algebra):216">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x)_{i}=R
  </annotation>
 </semantics>
</math>

 for <em>i</em> = 0, 1 and 

<math display="inline" id="Dimension_theory_(algebra):217">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x)_{i}=0
  </annotation>
 </semantics>
</math>

 for any other <em>i</em> with the differential</p>

<p>

<math display="block" id="Dimension_theory_(algebra):218">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mi>K</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>R</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>→</mo>
      <mrow>
       <msub>
        <mi>K</mi>
        <mn>0</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>R</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo rspace="4.2pt">,</mo>
     <mrow>
      <mi>r</mi>
      <mo>↦</mo>
      <mrow>
       <mi>x</mi>
       <mi>r</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>d</ci>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>R</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>R</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <ci>r</ci>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>r</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d:K_{1}(R)\to K_{0}(R),\,r\mapsto xr.
  </annotation>
 </semantics>
</math>

 For any <em>R</em>-module <em>M</em>, we then get the complex 

<math display="inline" id="Dimension_theory_(algebra):219">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <msub>
     <mo>⊗</mo>
     <mi>R</mi>
    </msub>
    <mi>M</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>M</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>R</ci>
     </apply>
     <apply>
      <times></times>
      <ci>K</ci>
      <ci>x</ci>
     </apply>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x,M)=K(x)\otimes_{R}M
  </annotation>
 </semantics>
</math>

 with the differential 

<math display="inline" id="Dimension_theory_(algebra):220">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>⊗</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <ci>d</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\otimes 1
  </annotation>
 </semantics>
</math>

 and let 

<math display="inline" id="Dimension_theory_(algebra):221">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>H</mo>
     <mo>*</mo>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>H</mo>
     <mo>*</mo>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>K</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>M</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-H</ci>
      <times></times>
     </apply>
     <ci>x</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-H</ci>
      <times></times>
     </apply>
     <apply>
      <times></times>
      <ci>K</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>M</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{H}_{*}(x,M)=\operatorname{H}_{*}(K(x,M))
  </annotation>
 </semantics>
</math>

 be its homology. Note:</p>

<p>

<math display="block" id="Dimension_theory_(algebra):222">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>H</mo>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>M</mi>
     <mo>/</mo>
     <mi>x</mi>
    </mrow>
    <mi>M</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-H</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>x</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>M</ci>
      <ci>x</ci>
     </apply>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{H}_{0}(x,M)=M/xM
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Dimension_theory_(algebra):223">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>H</mo>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mmultiscripts>
    <mi>M</mi>
    <mprescripts></mprescripts>
    <mi>x</mi>
    <none></none>
   </mmultiscripts>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>m</mi>
     <mo>∈</mo>
     <mi>M</mi>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>x</mi>
      <mi>m</mi>
     </mrow>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-H</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>x</ci>
      <ci>M</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <in></in>
       <ci>m</ci>
       <ci>M</ci>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>m</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{H}_{1}(x,M)={}_{x}M=\{m\in M|xm=0\}
  </annotation>
 </semantics>
</math>

.</p>

<p>More generally, given a finite sequence 

<math display="inline" id="Dimension_theory_(algebra):224">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\dots,x_{n}
  </annotation>
 </semantics>
</math>

 of elements in a ring <em>R</em>, we form the <a href="tensor_product_of_complexes" title="wikilink">tensor product of complexes</a>:</p>

<p>

<math display="block" id="Dimension_theory_(algebra):225">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>K</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⊗</mo>
     <mi mathvariant="normal">…</mi>
     <mo>⊗</mo>
     <mi>K</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <times></times>
       <ci>K</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <ci>K</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x_{1},\dots,x_{n})=K(x_{1})\otimes\dots\otimes K(x_{n})
  </annotation>
 </semantics>
</math>

 and let 

<math display="inline" id="Dimension_theory_(algebra):226">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>H</mo>
     <mo>*</mo>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>H</mo>
     <mo>*</mo>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>K</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo>,</mo>
       <mi>M</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-H</ci>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <ci>M</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-H</ci>
      <times></times>
     </apply>
     <apply>
      <times></times>
      <ci>K</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
       <ci>M</ci>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{H}_{*}(x_{1},\dots,x_{n},M)=\operatorname{H}_{*}(K(x_{1},\dots,x%
_{n},M))
  </annotation>
 </semantics>
</math>

 its homology. As before,</p>

<p>

<math display="block" id="Dimension_theory_(algebra):227">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>H</mo>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <munder accentunder="true">
      <mi>x</mi>
      <mo>¯</mo>
     </munder>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>M</mi>
     <mo>/</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mi>M</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-H</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <ci>normal-¯</ci>
      <ci>x</ci>
     </apply>
     <ci>M</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>M</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </vector>
     </apply>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{H}_{0}(\underline{x},M)=M/(x_{1},\dots,x_{n})M
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Dimension_theory_(algebra):228">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>H</mo>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <munder accentunder="true">
      <mi>x</mi>
      <mo>¯</mo>
     </munder>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>Ann</mo>
     <mi>M</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-H</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <ci>normal-¯</ci>
      <ci>x</ci>
     </apply>
     <ci>M</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Ann</ci>
      <ci>M</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{H}_{n}(\underline{x},M)=\operatorname{Ann}_{M}((x_{1},\dots,x_{n%
}))
  </annotation>
 </semantics>
</math>

.</p>

<p>We now have the homological characterization of a regular sequence. </p>

<p><mtpl></mtpl> <mtpl></mtpl></p>

<p>A Koszul complex is a powerful computational tool. For instance, it follows from the theorem and the corollary</p>

<p>

<math display="block" id="Dimension_theory_(algebra):229">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo>H</mo>
     <mi>𝔪</mi>
     <mi>i</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≃</mo>
   <mrow>
    <munder accentunder="true">
     <mo movablelimits="false">lim</mo>
     <mo>→</mo>
    </munder>
    <mrow>
     <msup>
      <mo>H</mo>
      <mi>i</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>K</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msubsup>
         <mi>x</mi>
         <mn>1</mn>
         <mi>j</mi>
        </msubsup>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msubsup>
         <mi>x</mi>
         <mi>n</mi>
         <mi>j</mi>
        </msubsup>
        <mo>;</mo>
        <mi>M</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to-or-equals</csymbol>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-H</ci>
       <ci>i</ci>
      </apply>
      <ci>𝔪</ci>
     </apply>
     <ci>M</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">injective-limit</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-H</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <ci>K</ci>
       <vector>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>j</ci>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>n</ci>
         </apply>
         <ci>j</ci>
        </apply>
        <ci>M</ci>
       </vector>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{H}^{i}_{\mathfrak{m}}(M)\simeq\underrightarrow{\lim}%
\operatorname{H}^{i}(K(x_{1}^{j},\dots,x_{n}^{j};M))
  </annotation>
 </semantics>
</math>

 (Here, one uses the self-duality of a Koszul complex; see Proposition 17.15. of Eisenbud, <em>Commutative Algebra with a View Toward Algebraic Geometry</em>.)</p>

<p>Another instance would be </p>

<p><strong>Remark</strong>: The theorem can be used to give a second quick proof of Serre's theorem, that <em>R</em> is regular if and only if it has finite global dimension. Indeed, by the above theorem, 

<math display="inline" id="Dimension_theory_(algebra):230">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo>Tor</mo>
     <mi>s</mi>
     <mi>R</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo>,</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Tor</ci>
       <ci>R</ci>
      </apply>
      <ci>s</ci>
     </apply>
     <ci>k</ci>
     <ci>k</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Tor}^{R}_{s}(k,k)\neq 0
  </annotation>
 </semantics>
</math>

 and thus 

<math display="inline" id="Dimension_theory_(algebra):231">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>gl</mi>
     <mo>.</mo>
     <mi>dim</mi>
    </mrow>
    <mi>R</mi>
   </mrow>
   <mo>≥</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <ci>gl</ci>
      <ci>dim</ci>
     </apply>
     <ci>R</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{gl.dim}R\geq s
  </annotation>
 </semantics>
</math>

. On the other hand, as 

<math display="inline" id="Dimension_theory_(algebra):232">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>gl</mi>
     <mo>.</mo>
     <mi>dim</mi>
    </mrow>
    <mi>R</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>pd</mo>
     <mi>R</mi>
    </msub>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <ci>gl</ci>
      <ci>dim</ci>
     </apply>
     <ci>R</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>pd</ci>
      <ci>R</ci>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{gl.dim}R=\operatorname{pd}_{R}k
  </annotation>
 </semantics>
</math>

, the Auslander–Buchsbaum formula gives 

<math display="inline" id="Dimension_theory_(algebra):233">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>gl</mi>
     <mo>.</mo>
     <mi>dim</mi>
    </mrow>
    <mi>R</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>dim</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <ci>gl</ci>
      <ci>dim</ci>
     </apply>
     <ci>R</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">dimension</csymbol>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{gl.dim}R=\dim R
  </annotation>
 </semantics>
</math>

. Hence, 

<math display="inline" id="Dimension_theory_(algebra):234">
 <semantics>
  <mrow>
   <mrow>
    <mo>dim</mo>
    <mi>R</mi>
   </mrow>
   <mo>≤</mo>
   <mi>s</mi>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mi>gl</mi>
     <mo>.</mo>
     <mi>dim</mi>
    </mrow>
    <mi>R</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>dim</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <csymbol cd="latexml">dimension</csymbol>
      <ci>R</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <ci>gl</ci>
       <ci>dim</ci>
      </apply>
      <ci>R</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">dimension</csymbol>
      <ci>R</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dim R\leq s\leq\operatorname{gl.dim}R=\dim R
  </annotation>
 </semantics>
</math>

.</p>

<p>We next use a Koszul homology to define and study <a href="complete_intersection_ring" title="wikilink">complete intersection rings</a>. Let <em>R</em> be a Noetherian local ring. By definition, the <a href="first_deviation" title="wikilink">first deviation</a> of <em>R</em> is the vector space dimension</p>

<p>

<math display="block" id="Dimension_theory_(algebra):235">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ϵ</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>R</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>dim</mo>
     <mi>k</mi>
    </msub>
    <mrow>
     <msub>
      <mo>H</mo>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <munder accentunder="true">
       <mi>x</mi>
       <mo>¯</mo>
      </munder>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϵ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>R</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">dimension</csymbol>
      <ci>k</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-H</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <ci>normal-¯</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{1}(R)=\dim_{k}\operatorname{H}_{1}(\underline{x})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Dimension_theory_(algebra):236">
 <semantics>
  <mrow>
   <munder accentunder="true">
    <mi>x</mi>
    <mo>¯</mo>
   </munder>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>d</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¯</ci>
     <ci>x</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>d</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underline{x}=(x_{1},\dots,x_{d})
  </annotation>
 </semantics>
</math>

 is a system of parameters. By definition, <em>R</em> is a complete intersection ring if 

<math display="inline" id="Dimension_theory_(algebra):237">
 <semantics>
  <mrow>
   <mrow>
    <mo>dim</mo>
    <mi>R</mi>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msub>
     <mi>ϵ</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>R</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="latexml">dimension</csymbol>
     <ci>R</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϵ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dim R+\epsilon_{1}(R)
  </annotation>
 </semantics>
</math>

 is the dimension of the tangent space. (See Hartshorne for a geometric meaning.)</p>
<h3 id="injective-dimension-and-tor-dimensions">Injective dimension and Tor dimensions</h3>

<p>Let <em>R</em> be a ring. The <a href="injective_dimension" title="wikilink">injective dimension</a> of an <em>R</em>-module <em>M</em> denoted by 

<math display="inline" id="Dimension_theory_(algebra):238">
 <semantics>
  <mrow>
   <msub>
    <mo>id</mo>
    <mi>R</mi>
   </msub>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>id</ci>
     <ci>R</ci>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{id}_{R}M
  </annotation>
 </semantics>
</math>

 is defined just like a projective dimension: it is the minimal length of an injective resolution of <em>M</em>. Let 

<math display="inline" id="Dimension_theory_(algebra):239">
 <semantics>
  <msub>
   <mo>Mod</mo>
   <mi>R</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Mod</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Mod}_{R}
  </annotation>
 </semantics>
</math>

 be the category of <em>R</em>-modules.</p>

<p>Proof: Suppose 

<math display="inline" id="Dimension_theory_(algebra):240">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>gl</mi>
     <mo>.</mo>
     <mi>dim</mi>
    </mrow>
    <mi>R</mi>
   </mrow>
   <mo>≤</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <ci>gl</ci>
      <ci>dim</ci>
     </apply>
     <ci>R</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{gl.dim}R\leq n
  </annotation>
 </semantics>
</math>

. Let <em>M</em> be an <em>R</em>-module and consider a resolution</p>

<p>

<math display="block" id="Dimension_theory_(algebra):241">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mi>M</mi>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>I</mi>
     <mn>0</mn>
    </msub>
    <mover accent="true">
     <mo>→</mo>
     <msub>
      <mi>ϕ</mi>
      <mn>0</mn>
     </msub>
    </mover>
    <msub>
     <mi>I</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>→</mo>
   <mi mathvariant="normal">…</mi>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>I</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mover accent="true">
     <mo>→</mo>
     <msub>
      <mi>ϕ</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mover>
    <mi>N</mi>
   </mrow>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <ci>M</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϕ</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>normal-→</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-…</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϕ</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-→</ci>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\to M\to I_{0}\overset{\phi_{0}}{\to}I_{1}\to\dots\to I_{n-1}\overset{\phi_{n%
-1}}{\to}N\to 0
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Dimension_theory_(algebra):242">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{i}
  </annotation>
 </semantics>
</math>

 are injective modules. For any ideal <em>I</em>,</p>

<p>

<math display="block" id="Dimension_theory_(algebra):243">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mo>Ext</mo>
      <mi>R</mi>
      <mn>1</mn>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>R</mi>
       <mo>/</mo>
       <mi>I</mi>
      </mrow>
      <mo>,</mo>
      <mi>N</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≃</mo>
    <mrow>
     <msubsup>
      <mo>Ext</mo>
      <mi>R</mi>
      <mn>2</mn>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>R</mi>
       <mo>/</mo>
       <mi>I</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mo>ker</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>ϕ</mi>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≃</mo>
    <mi mathvariant="normal">…</mi>
    <mo>≃</mo>
    <mrow>
     <msubsup>
      <mo>Ext</mo>
      <mi>R</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>R</mi>
       <mo>/</mo>
       <mi>I</mi>
      </mrow>
      <mo>,</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">similar-to-or-equals</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Ext</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>R</ci>
      </apply>
      <apply>
       <divide></divide>
       <ci>R</ci>
       <ci>I</ci>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Ext</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>R</ci>
      </apply>
      <apply>
       <divide></divide>
       <ci>R</ci>
       <ci>I</ci>
      </apply>
      <apply>
       <ci>ker</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϕ</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">similar-to-or-equals</csymbol>
     <share href="#.cmml">
     </share>
     <ci>normal-…</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">similar-to-or-equals</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Ext</ci>
        <ci>R</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <ci>R</ci>
       <ci>I</ci>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Ext}^{1}_{R}(R/I,N)\simeq\operatorname{Ext}^{2}_{R}(R/I,%
\operatorname{ker}(\phi_{n-1}))\simeq\dots\simeq\operatorname{Ext}_{R}^{n+1}(R%
/I,M),
  </annotation>
 </semantics>
</math>

 which is zero since 

<math display="inline" id="Dimension_theory_(algebra):244">
 <semantics>
  <mrow>
   <msubsup>
    <mo>Ext</mo>
    <mi>R</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>R</mi>
     <mo>/</mo>
     <mi>I</mi>
    </mrow>
    <mo>,</mo>
    <mo>-</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Ext</ci>
      <ci>R</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <ci>R</ci>
     <ci>I</ci>
    </apply>
    <minus></minus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Ext}_{R}^{n+1}(R/I,-)
  </annotation>
 </semantics>
</math>

 is computed via a projective resolution of 

<math display="inline" id="Dimension_theory_(algebra):245">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>/</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>R</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R/I
  </annotation>
 </semantics>
</math>

. Thus, by <a href="Baer's_criterion" title="wikilink">Baer's criterion</a>, <em>N</em> is injective. We conclude that 

<math display="inline" id="Dimension_theory_(algebra):246">
 <semantics>
  <mrow>
   <mrow>
    <mo>sup</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <msub>
       <mo>id</mo>
       <mi>R</mi>
      </msub>
      <mi>M</mi>
     </mrow>
     <mo stretchy="false">|</mo>
     <mi>M</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="latexml">supremum</csymbol>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>id</ci>
        <ci>R</ci>
       </apply>
       <ci>M</ci>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sup\{\operatorname{id}_{R}M|M\}\leq n
  </annotation>
 </semantics>
</math>

. Essentially by reversing the arrows, one can also prove the implication in the other way. 

<math display="inline" id="Dimension_theory_(algebra):247">
 <semantics>
  <mi mathvariant="normal">□</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-□</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \square
  </annotation>
 </semantics>
</math>

</p>

<p>The theorem suggests that we consider a sort of a dual of a global dimension:</p>

<p>

<math display="block" id="Dimension_theory_(algebra):248">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">w</mi>
    <mo>.</mo>
    <mi>gl</mi>
    <mo>.</mo>
    <mi>dim</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo movablelimits="false">inf</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>n</mi>
     <mo stretchy="false">|</mo>
     <mrow>
      <mrow>
       <mrow>
        <msubsup>
         <mo>Tor</mo>
         <mi>i</mi>
         <mi>R</mi>
        </msubsup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>M</mi>
         <mo>,</mo>
         <mi>N</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mo rspace="4.2pt">,</mo>
      <mrow>
       <mrow>
        <mi>i</mi>
        <mo>></mo>
        <mrow>
         <mi>n</mi>
         <mo>,</mo>
         <mi>M</mi>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>N</mi>
        <mo>∈</mo>
        <msub>
         <mo>Mod</mo>
         <mi>R</mi>
        </msub>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <ci>normal-w</ci>
     <ci>gl</ci>
     <ci>dim</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">infimum</csymbol>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <eq></eq>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>Tor</ci>
           <ci>R</ci>
          </apply>
          <ci>i</ci>
         </apply>
         <ci>M</ci>
         <ci>N</ci>
        </apply>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <gt></gt>
         <ci>i</ci>
         <list>
          <ci>n</ci>
          <ci>M</ci>
         </list>
        </apply>
        <apply>
         <in></in>
         <ci>N</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Mod</ci>
          <ci>R</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{w.gl.dim}=\inf\{n|\operatorname{Tor}^{R}_{i}(M,N)=0,\,i>n,M,N\in%
\operatorname{Mod}_{R}\}
  </annotation>
 </semantics>
</math>

. It was originally called the weak global dimension of <em>R</em> but today it is more commonly called the <a href="Tor_dimension" title="wikilink">Tor dimension</a> of <em>R</em>.</p>

<p><strong>Remark:</strong> for any ring <em>R</em>, 

<math display="inline" id="Dimension_theory_(algebra):249">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">w</mi>
     <mo>.</mo>
     <mi>gl</mi>
     <mo>.</mo>
     <mi>dim</mi>
    </mrow>
    <mi>R</mi>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mi>gl</mi>
     <mo>.</mo>
     <mi>dim</mi>
    </mrow>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <ci>normal-w</ci>
      <ci>gl</ci>
      <ci>dim</ci>
     </apply>
     <ci>R</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <ci>gl</ci>
      <ci>dim</ci>
     </apply>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{w.gl.dim}R\leq\operatorname{gl.dim}R
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="multiplicity-theory">Multiplicity theory</h2>
<h2 id="dimensions-of-non-commutative-rings">Dimensions of non-commutative rings</h2>

<p>Let <em>A</em> be a graded algebra over a field <em>k</em>. If <em>V</em> is a finite-dimensional generating subspace of <em>A</em>, then we let 

<math display="inline" id="Dimension_theory_(algebra):250">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>dim</mo>
     <mi>k</mi>
    </msub>
    <msup>
     <mi>V</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">dimension</csymbol>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)=\dim_{k}V^{n}
  </annotation>
 </semantics>
</math>

 and then put</p>

<p>

<math display="block" id="Dimension_theory_(algebra):251">
 <semantics>
  <mrow>
   <mrow>
    <mo>gk</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo movablelimits="false">lim sup</mo>
     <mrow>
      <mi>n</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </munder>
    <mfrac>
     <mrow>
      <mrow>
       <mi>log</mi>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>gk</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">limit-supremum</csymbol>
      <apply>
       <ci>normal-→</ci>
       <ci>n</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <log></log>
        <ci>f</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{gk}(A)=\limsup_{n\to\infty}{\log f(n)\over\log n}
  </annotation>
 </semantics>
</math>

. It is called the <a href="Gelfand–Kirillov_dimension" title="wikilink">Gelfand–Kirillov dimension</a> of <em>A</em>. It is easy to show 

<math display="inline" id="Dimension_theory_(algebra):252">
 <semantics>
  <mrow>
   <mo>gk</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>gk</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{gk}(A)
  </annotation>
 </semantics>
</math>

 is independent of a choice of <em>V</em>.</p>

<p><strong>Example</strong>: If <em>A</em> is finite-dimensional, then gk(<em>A</em>) = 0. If <em>A</em> is an affine ring, then gk(<em>A</em>) = Krull dimension of <em>A</em>.</p>

<p>See also: <a href="Goldie_dimension" title="wikilink">Goldie dimension</a>, <a href="Krull–Gabriel_dimension" title="wikilink">Krull–Gabriel dimension</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Bass_number" title="wikilink">Bass number</a></li>
<li><a href="Perfect_complex" title="wikilink">Perfect complex</a></li>
<li><a class="uri" href="amplitude" title="wikilink">amplitude</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>Part II of .</li>
<li>Chapter 10 of .</li>
<li><a href="Irving_Kaplansky" title="wikilink">Kaplansky, Irving</a>, <em>Commutative rings</em>, Allyn and Bacon, 1970.</li>
<li>H. Matsumura <em>Commutative ring theory.</em> Translated from the Japanese by M. Reid. Second edition. Cambridge Studies in Advanced Mathematics, 8.</li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Dimension" title="wikilink">Category:Dimension</a> <a href="Category:Commutative_algebra" title="wikilink">Category:Commutative algebra</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
