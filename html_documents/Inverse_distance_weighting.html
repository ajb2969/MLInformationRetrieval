<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="594">Inverse distance weighting</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Inverse distance weighting</h1>
<hr/>

<p><strong>Inverse Distance Weighting</strong> (<strong>IDW</strong>) is a type of <a href="Deterministic_algorithm" title="wikilink">deterministic method</a> for <a href="multivariate_interpolation" title="wikilink">multivariate interpolation</a> with a known scattered set of points. The assigned values to unknown points are calculated with a <a href="Weighted_mean" title="wikilink">weighted average</a> of the values available at the known points.</p>

<p>The name given to this type of methods was motivated by the <a href="Weighted_mean" title="wikilink">weighted average</a> applied, since it resorts to the inverse of the distance to each known point ("amount of proximity") when assigning weights.</p>
<h2 id="definition-of-the-problem">Definition of the Problem</h2>

<p>The expected result is a discrete assignment of the unknown function 

<math display="inline" id="Inverse_distance_weighting:0">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>


 in a study region:</p>

<p>

<math display="inline" id="Inverse_distance_weighting:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mo>‚Üí</mo>
     <mi>‚Ñù</mi>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mi>x</mi>
     <mo>‚àà</mo>
     <mrow>
      <mi>ùêÉ</mi>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\sub</mtext>
      </merror>
      <msup>
       <mi>‚Ñù</mi>
       <mi>n</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>u</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <ci>normal-‚Üí</ci>
      <ci>x</ci>
      <ci>‚Ñù</ci>
     </apply>
     <apply>
      <in></in>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>ùêÉ</ci>
       <mtext>\sub</mtext>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>‚Ñù</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(x):x\rightarrow\mathbb{R},\quad x\in\mathbf{D}\sub\mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Inverse_distance_weighting:2">
 <semantics>
  <mi>ùêÉ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêÉ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{D}
  </annotation>
 </semantics>
</math>

 is the study region.</p>

<p>The set of 

<math display="inline" id="Inverse_distance_weighting:3">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 known data points can be described as a list of <a href="tuple" title="wikilink">tuples</a>:</p>

<p>

<math display="inline" id="Inverse_distance_weighting:4">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>u</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>u</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">‚Ä¶</mi>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>N</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>u</mi>
     <mi>N</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
    <ci>normal-‚Ä¶</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>N</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>N</ci>
     </apply>
    </interval>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [(x_{1},u_{1}),(x_{2},u_{2}),...,(x_{N},u_{N})]
  </annotation>
 </semantics>
</math>

</p>

<p>The function is to be "smooth" (continuous and once differentiable), to be exact (

<math display="inline" id="Inverse_distance_weighting:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>u</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>u</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(x_{i})=u_{i}
  </annotation>
 </semantics>
</math>


) and to meet the user's intuitive expectations about the phenomenon under investigation. Furthermore, the function should be suitable for a computer application at a reasonable cost (nowadays, a basic implementation will probably make use of <a href="parallel_computing" title="wikilink">parallel resources</a>).</p>
<h2 id="shepards-method">Shepard's method</h2>
<h3 id="historical-reference">Historical Reference</h3>

<p>At the Harvard Laboratory for Computer Graphics and Spatial Analysis, beginning in 1965, a varied collection of scientists converged to rethink, among other things, what we now call <a href="geographic_information_system" title="wikilink">geographic information systems</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The motive force behind the Laboratory, Howard Fisher, conceived an improved computer mapping program that he called SYMAP, which, from the start, Fisher wanted to improve on the interpolation. He showed Harvard College freshmen his work on SYMAP, and many of them participated in Laboratory events. One freshman, Donald Shepard, decided to overhaul the interpolation in SYMAP, resulting in his famous article from 1968.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Shepard‚Äôs algorithm was also influenced by the theoretical approach of William Warntz and others at the Lab who worked with spatial analysis. He conducted a number of experiments with the exponent of distance, deciding on something closer to the gravity model (exponent of -2). Shepard implemented not just basic inverse distance weighting, but also he allowed barriers (permeable and absolute) to interpolation.</p>

<p>Other research centers were working on interpolation at this time, particularly University of Kansas and their SURFACE II program. Still, the features of SYMAP were state-of-the-art, even though programmed by an undergraduate.</p>
<h3 id="basic-form">Basic Form</h3>
<figure><b>(Figure)</b>
<figcaption>Shepard's interpolation for different power parameters <em>p</em>, from scattered points on the surface 

<math display="inline" id="Inverse_distance_weighting:6">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo>-</mo>
       <msup>
        <mi>x</mi>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo>-</mo>
      <msup>
       <mi>y</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>z</ci>
    <apply>
     <exp></exp>
     <apply>
      <minus></minus>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=\exp(-x^{2}-y^{2})
  </annotation>
 </semantics>
</math>

.</figcaption>
</figure>

<p>A general form of finding an interpolated value 

<math display="inline" id="Inverse_distance_weighting:7">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 at a given point 

<math display="inline" id="Inverse_distance_weighting:8">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 based on samples 

<math display="inline" id="Inverse_distance_weighting:9">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>u</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}=u(x_{i})
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Inverse_distance_weighting:10">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-‚Ä¶</ci>
     <ci>N</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,2,...,N
  </annotation>
 </semantics>
</math>


 using IDW is an interpolating function:</p>

<p>

<math display="block" id="Inverse_distance_weighting:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùê±</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mstyle displaystyle="false">
         <mfrac>
          <mrow>
           <mstyle displaystyle="true">
            <munderover>
             <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
             <mrow>
              <mi>i</mi>
              <mo>=</mo>
              <mn>1</mn>
             </mrow>
             <mi>N</mi>
            </munderover>
           </mstyle>
           <mrow>
            <msub>
             <mi>w</mi>
             <mi>i</mi>
            </msub>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>ùê±</mi>
             <mo stretchy="false">)</mo>
            </mrow>
            <msub>
             <mi>u</mi>
             <mi>i</mi>
            </msub>
           </mrow>
          </mrow>
          <mrow>
           <mstyle displaystyle="true">
            <munderover>
             <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
             <mrow>
              <mi>i</mi>
              <mo>=</mo>
              <mn>1</mn>
             </mrow>
             <mi>N</mi>
            </munderover>
           </mstyle>
           <mrow>
            <msub>
             <mi>w</mi>
             <mi>i</mi>
            </msub>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>ùê±</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mrow>
         </mfrac>
        </mstyle>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>d</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>ùê±</mi>
          <mo>,</mo>
          <msub>
           <mi>ùê±</mi>
           <mi>i</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>‚â†</mo>
        <mrow>
         <mn>0</mn>
         <mtext>for all</mtext>
         <mi>i</mi>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <msub>
         <mi>u</mi>
         <mi>i</mi>
        </msub>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>d</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>ùê±</mi>
          <mo>,</mo>
          <msub>
           <mi>ùê±</mi>
           <mi>i</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mn>0</mn>
         <mtext>for some</mtext>
         <mi>i</mi>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>u</ci>
     <ci>ùê±</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <divide></divide>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <ci>i</ci>
        </apply>
        <ci>ùê±</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <ci>i</ci>
        </apply>
        <ci>ùê±</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <neq></neq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>d</ci>
       <interval closure="open">
        <ci>ùê±</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ùê±</ci>
         <ci>i</ci>
        </apply>
       </interval>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">0</cn>
       <mtext>for all</mtext>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>d</ci>
       <interval closure="open">
        <ci>ùê±</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ùê±</ci>
         <ci>i</ci>
        </apply>
       </interval>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">0</cn>
       <mtext>for some</mtext>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(\mathbf{x})=\begin{cases}\frac{\displaystyle\sum_{i=1}^{N}{w_{i}(\mathbf{x})%
u_{i}}}{\displaystyle\sum_{i=1}^{N}{w_{i}(\mathbf{x})}},&\text{if }d(\mathbf{x%
},\mathbf{x}_{i})\neq 0\text{ for all }i\\
u_{i},&\text{if }d(\mathbf{x},\mathbf{x}_{i})=0\text{ for some }i\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Inverse_distance_weighting:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>w</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùê±</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>d</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ùê±</mi>
       <mo>,</mo>
       <msub>
        <mi>ùê±</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>p</mi>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>i</ci>
     </apply>
     <ci>ùê±</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>d</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <interval closure="open">
        <ci>ùê±</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ùê±</ci>
         <ci>i</ci>
        </apply>
       </interval>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}(\mathbf{x})=\frac{1}{d(\mathbf{x},\mathbf{x}_{i})^{p}}
  </annotation>
 </semantics>
</math>

</p>

<p>is a simple IDW weighting function, as defined by Shepard,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <strong>x</strong> denotes an interpolated (arbitrary) point, <strong>x</strong><sub><em>i</em></sub> is an interpolating (known) point, 

<math display="inline" id="Inverse_distance_weighting:13">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 is a given distance (<a href="Metric_(mathematics)" title="wikilink">metric</a> operator) from the known point <strong>x</strong><sub><em>i</em></sub> to the unknown point <strong>x</strong>, <em>N</em> is the total number of known points used in interpolation and 

<math display="inline" id="Inverse_distance_weighting:14">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is a positive real number, called the power parameter.</p>

<p>Here weight decreases as distance increases from the interpolated points. Greater values of 

<math display="inline" id="Inverse_distance_weighting:15">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>


 assign greater influence to values closest to the interpolated point, with the result turning into a mosaic of tiles (a <a href="Voronoi_diagram" title="wikilink">Voronoi diagram</a>) with nearly constant interpolated value for large values of <em>p</em>. For two dimensions, power parameters 

<math display="inline" id="Inverse_distance_weighting:16">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>‚â§</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>p</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\leq 2
  </annotation>
 </semantics>
</math>

 cause the interpolated values to be dominated by points far away, since with a density 

<math display="inline" id="Inverse_distance_weighting:17">
 <semantics>
  <mi>œÅ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>œÅ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

 of data points and neighboring points between distances 

<math display="inline" id="Inverse_distance_weighting:18">
 <semantics>
  <msub>
   <mi>r</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{0}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Inverse_distance_weighting:19">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

, the summed weight is approximately</p>

<p>

<math display="block" id="Inverse_distance_weighting:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mi>j</mi>
     </munder>
     <msub>
      <mi>w</mi>
      <mi>j</mi>
     </msub>
    </mrow>
    <mo>‚âà</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">‚à´</mo>
      <msub>
       <mi>r</mi>
       <mn>0</mn>
      </msub>
      <mi>R</mi>
     </msubsup>
     <mfrac>
      <mrow>
       <mn>2</mn>
       <mi>œÄ</mi>
       <mi>r</mi>
       <mi>œÅ</mi>
       <mi>d</mi>
       <mi>r</mi>
      </mrow>
      <msup>
       <mi>r</mi>
       <mi>p</mi>
      </msup>
     </mfrac>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>2</mn>
     <mi>œÄ</mi>
     <mi>œÅ</mi>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">‚à´</mo>
       <msub>
        <mi>r</mi>
        <mn>0</mn>
       </msub>
       <mi>R</mi>
      </msubsup>
      <mrow>
       <msup>
        <mi>r</mi>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mi>p</mi>
        </mrow>
       </msup>
       <mi>d</mi>
       <mi>r</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <approx></approx>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>R</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>œÄ</ci>
        <ci>r</ci>
        <ci>œÅ</ci>
        <ci>d</ci>
        <ci>r</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>r</ci>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>œÄ</ci>
      <ci>œÅ</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <ci>R</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>r</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <ci>p</ci>
         </apply>
        </apply>
        <ci>d</ci>
        <ci>r</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{j}w_{j}\approx\int_{r_{0}}^{R}\frac{2\pi r\rho dr}{r^{p}}=2\pi\rho\int_{%
r_{0}}^{R}r^{1-p}dr,
  </annotation>
 </semantics>
</math>

 which diverges for 

<math display="inline" id="Inverse_distance_weighting:21">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>‚Üí</mo>
   <mi mathvariant="normal">‚àû</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-‚Üí</ci>
    <ci>R</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\rightarrow\infty
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Inverse_distance_weighting:22">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>‚â§</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>p</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\leq 2
  </annotation>
 </semantics>
</math>

. For <em>N</em> dimensions, the same argument holds for 

<math display="inline" id="Inverse_distance_weighting:23">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>‚â§</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>p</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\leq N
  </annotation>
 </semantics>
</math>

. For the choice of value for <em>p</em>, one can consider the degree of smoothing desired in the interpolation, the density and distribution of samples being interpolated, and the maximum distance over which an individual sample is allowed to influence the surrounding ones.</p>

<p><em>Shepard's method</em> is a consequence of minimization of a functional related to a measure of deviations between <a href="tuple" title="wikilink">tuples</a> of interpolating points {<strong>x</strong>, <em>u</em>} and <em>i</em> tuples of interpolated points {<strong>x</strong><sub><em>i</em></sub>, <em>u<sub>i</sub></em>}, defined as:</p>

<p>

<math display="block" id="Inverse_distance_weighting:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>œï</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ùê±</mi>
      <mo>,</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mi>N</mi>
       </munderover>
       <mfrac>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>u</mi>
           <mo>-</mo>
           <msub>
            <mi>u</mi>
            <mi>i</mi>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>2</mn>
        </msup>
        <mrow>
         <mi>d</mi>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>ùê±</mi>
           <mo>,</mo>
           <msub>
            <mi>ùê±</mi>
            <mi>i</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>p</mi>
         </msup>
        </mrow>
       </mfrac>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mfrac>
      <mn>1</mn>
      <mi>p</mi>
     </mfrac>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>œï</ci>
     <interval closure="open">
      <ci>ùê±</ci>
      <ci>u</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>u</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>u</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <ci>d</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <interval closure="open">
          <ci>ùê±</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ùê±</ci>
           <ci>i</ci>
          </apply>
         </interval>
         <ci>p</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(\mathbf{x},u)=\left(\sum_{i=0}^{N}{\frac{(u-u_{i})^{2}}{d(\mathbf{x},%
\mathbf{x}_{i})^{p}}}\right)^{\frac{1}{p}},
  </annotation>
 </semantics>
</math>

 derived from the minimizing condition:</p>

<p>

<math display="block" id="Inverse_distance_weighting:25">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mtext>
      P
                          a
                          r
                          t
                          ¬†
                          I
                        
                        œï
                      
                      
                        
                          I
                        
                        œï
     </mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ùê±</mi>
      <mo>,</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mtext>
     P
                        a
                        r
                        t
                        ¬†
                        I
                        I
                      
                      u
                    
                    
                      
                        I
                        I
                      
                      u
    </mtext>
   </mfrac>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <mtext>
       P
                          a
                          r
                          t
                          ¬†
                          I
                        
                        œï
                      
                      
                        
                          I
                        
                        œï
      </mtext>
      <interval closure="open">
       <ci>ùê±</ci>
       <ci>u</ci>
      </interval>
     </apply>
     <mtext>
      P
                        a
                        r
                        t
                        ¬†
                        I
                        I
                      
                      u
                    
                    
                      
                        I
                        I
                      
                      u
     </mtext>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\@@section{part}{Pt1}{I}{Part~I}{{\@tag[][]{I}\phi}}{{\@tag[][]{Part~I}%
\phi}}(\mathbf{x},u)}{\@@section{part}{Pt2}{II}{Part~II}{{\@tag[][]{II}u}}{{%
\@tag[][]{Part~II}u}}}=0.
  </annotation>
 </semantics>
</math>

</p>

<p>The method can easily be extended to other dimensional spaces and it is in fact a generalization of Lagrange approximation into a multidimensional spaces. A modified version of the algorithm designed for trivariate interpolation was developed by Robert J. Renka and is available in <a class="uri" href="Netlib" title="wikilink">Netlib</a> as algorithm 661 in the toms library.</p>
<h3 id="example-in-1-dimension">Example in 1 Dimension</h3>
<figure><b>(Figure)</b>
<figcaption>Shepard's interpolation in 1 dimension, from 4 scattered points and using <em>p=2</em>.</figcaption>
</figure>
<h3 id="≈Çukaszyk-karmowski-metric">≈Åukaszyk-Karmowski metric</h3>

<p>Yet another modification of the Shepard's method was proposed by ≈Åukaszyk<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> also in applications to experimental mechanics. The proposed weighting function had the form:</p>

<p>

<math display="block" id="Inverse_distance_weighting:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>w</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ùê±</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>D</mi>
         <mrow>
          <mi></mi>
          <mo>*</mo>
          <mo>*</mo>
         </mrow>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>ùê±</mi>
         <mo>,</mo>
         <msub>
          <mi>ùê±</mi>
          <mi>k</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </msup>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>k</ci>
     </apply>
     <ci>ùê±</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>D</ci>
        <apply>
         <times></times>
         <csymbol cd="latexml">absent</csymbol>
         <times></times>
        </apply>
       </apply>
       <interval closure="open">
        <ci>ùê±</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ùê±</ci>
         <ci>k</ci>
        </apply>
       </interval>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{k}(\mathbf{x})=\frac{1}{(D_{**}(\mathbf{x},\mathbf{x}_{k}))^{\frac{1}{2}}},
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Inverse_distance_weighting:27">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mrow>
     <mi></mi>
     <mo>*</mo>
     <mo>*</mo>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ùê±</mi>
    <mo>,</mo>
    <msub>
     <mi>ùê±</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <apply>
      <times></times>
      <csymbol cd="latexml">absent</csymbol>
      <times></times>
     </apply>
    </apply>
    <interval closure="open">
     <ci>ùê±</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùê±</ci>
      <ci>k</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{**}(\mathbf{x},\mathbf{x}_{k})
  </annotation>
 </semantics>
</math>

 is the <a href="≈Åukaszyk‚ÄìKarmowski_metric" title="wikilink">≈Åukaszyk‚ÄìKarmowski metric</a> chosen also with regard to the <a href="statistical_error" title="wikilink">statistical error</a> <a href="probability_distribution" title="wikilink">probability distributions</a> of measurement of the interpolated points.</p>
<h3 id="modified-shepards-method">Modified Shepard's Method</h3>

<p>Another modification of Shepard's method calculates interpolated value using only nearest neighbors within R-sphere (instead of full sample). Weights are slightly modified in this case:</p>

<p>

<math display="block" id="Inverse_distance_weighting:28">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>w</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùê±</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mrow>
       <mi>max</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo>,</mo>
        <mrow>
         <mi>R</mi>
         <mo>-</mo>
         <mrow>
          <mi>d</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>ùê±</mi>
           <mo>,</mo>
           <msub>
            <mi>ùê±</mi>
            <mi>k</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>R</mi>
       <mi>d</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ùê±</mi>
        <mo>,</mo>
        <msub>
         <mi>ùê±</mi>
         <mi>k</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
     <mo>)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>k</ci>
     </apply>
     <ci>ùê±</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <divide></divide>
      <apply>
       <max></max>
       <cn type="integer">0</cn>
       <apply>
        <minus></minus>
        <ci>R</ci>
        <apply>
         <times></times>
         <ci>d</ci>
         <interval closure="open">
          <ci>ùê±</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ùê±</ci>
           <ci>k</ci>
          </apply>
         </interval>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>R</ci>
       <ci>d</ci>
       <interval closure="open">
        <ci>ùê±</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ùê±</ci>
         <ci>k</ci>
        </apply>
       </interval>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{k}(\mathbf{x})=\left(\frac{\max(0,R-d(\mathbf{x},\mathbf{x}_{k}))}{Rd(%
\mathbf{x},\mathbf{x}_{k})}\right)^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>When combined with fast spatial search structure (like <a class="uri" href="kd-tree" title="wikilink">kd-tree</a>) it becomes efficient N*logN interpolation method suitable for large-scale problems.</p>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Multivariate_interpolation" title="wikilink">Multivariate interpolation</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Geostatistics" title="wikilink">Category:Geostatistics</a> <a href="Category:Multivariate_interpolation" title="wikilink">Category:Multivariate interpolation</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">‚Ü©</a></li>
<li id="fn2"><a href="#fnref2">‚Ü©</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
