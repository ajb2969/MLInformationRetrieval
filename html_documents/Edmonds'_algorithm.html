<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1553">Edmonds' algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Edmonds' algorithm</h1>
<hr/>

<p>In <a href="graph_theory" title="wikilink">graph theory</a>, a branch of mathematics, <strong>Edmonds' algorithm</strong> or <strong>Chu–Liu/Edmonds' algorithm</strong> is an <a class="uri" href="algorithm" title="wikilink">algorithm</a> for finding a <a href="spanning_subgraph" title="wikilink">spanning</a> <a href="Arborescence_(graph_theory)" title="wikilink">arborescence</a> of minimum weight (sometimes called an <em>optimum branching</em>). It is the <a href="Directed_graph" title="wikilink">directed</a> analog of the <a href="minimum_spanning_tree" title="wikilink">minimum spanning tree</a> problem. The algorithm was proposed independently first by Yoeng-jin Chu and Tseng-hong Liu (1965) and then by <a href="Jack_Edmonds" title="wikilink">Jack Edmonds</a> (1967).</p>
<h2 id="algorithm">Algorithm</h2>
<h3 id="description">Description</h3>

<p>The algorithm takes as input a directed graph 

<math display="inline" id="Edmonds'_algorithm:0">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <list>
     <ci>V</ci>
     <ci>E</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=\langle V,E\rangle
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Edmonds'_algorithm:1">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is the set of nodes and 

<math display="inline" id="Edmonds'_algorithm:2">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 is the set of directed edges, a distinguished vertex 

<math display="inline" id="Edmonds'_algorithm:3">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>∈</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>r</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\in V
  </annotation>
 </semantics>
</math>


 called the <em>root</em>, and a real-valued weight 

<math display="inline" id="Edmonds'_algorithm:4">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w(e)
  </annotation>
 </semantics>
</math>

 for each edge 

<math display="inline" id="Edmonds'_algorithm:5">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>∈</mo>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>e</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e\in E
  </annotation>
 </semantics>
</math>

. It returns a spanning arborescence 

<math display="inline" id="Edmonds'_algorithm:6">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 rooted at 

<math display="inline" id="Edmonds'_algorithm:7">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 of minimum weight, where the weight of an arborescence is defined to be the sum of its edge weights, 

<math display="inline" id="Edmonds'_algorithm:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>e</mi>
      <mo>∈</mo>
      <mi>A</mi>
     </mrow>
    </msub>
    <mrow>
     <mi>w</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>e</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>w</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>e</ci>
       <ci>A</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>w</ci>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w(A)=\sum_{e\in A}{w(e)}
  </annotation>
 </semantics>
</math>


.</p>

<p>The algorithm has a recursive description. Let 

<math display="inline" id="Edmonds'_algorithm:9">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>r</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <vector>
     <ci>D</ci>
     <ci>r</ci>
     <ci>w</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(D,r,w)
  </annotation>
 </semantics>
</math>

 denote the function which returns a spanning arborescence rooted at 

<math display="inline" id="Edmonds'_algorithm:10">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 of minimum weight. We first remove any edge from 

<math display="inline" id="Edmonds'_algorithm:11">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 whose destination is 

<math display="inline" id="Edmonds'_algorithm:12">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

. We may also replace any set of parallel edges (edges between the same pair of vertices in the same direction) by a single edge with weight equal to the minimum of the weights of these parallel edges.</p>

<p>Now, for each node 

<math display="inline" id="Edmonds'_algorithm:13">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>


 other than the root, find the edge incoming to 

<math display="inline" id="Edmonds'_algorithm:14">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 of lowest weight (with ties broken arbitrarily). Denote the source of this edge by 

<math display="inline" id="Edmonds'_algorithm:15">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>π</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi(v)
  </annotation>
 </semantics>
</math>

. If the set of edges 

<math display="inline" id="Edmonds'_algorithm:16">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>π</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mi>v</mi>
     <mo>∈</mo>
     <mrow>
      <mi>V</mi>
      <mo>∖</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>r</mi>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>π</ci>
       <ci>v</ci>
      </apply>
      <ci>v</ci>
     </interval>
     <apply>
      <in></in>
      <ci>v</ci>
      <apply>
       <setdiff></setdiff>
       <ci>V</ci>
       <set>
        <ci>r</ci>
       </set>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=\{(\pi(v),v)\mid v\in V\setminus\{r\}\}
  </annotation>
 </semantics>
</math>

 does not contain any cycles, then 

<math display="inline" id="Edmonds'_algorithm:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>D</mi>
     <mo>,</mo>
     <mi>r</mi>
     <mo>,</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <ci>D</ci>
      <ci>r</ci>
      <ci>w</ci>
     </vector>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(D,r,w)=P
  </annotation>
 </semantics>
</math>

.</p>

<p>Otherwise, 

<math display="inline" id="Edmonds'_algorithm:18">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>


 contains at least one cycle. Arbitrarily choose one of these cycles and call it 

<math display="inline" id="Edmonds'_algorithm:19">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

. We now define a new weighted directed graph 

<math display="inline" id="Edmonds'_algorithm:20">
 <semantics>
  <mrow>
   <msup>
    <mi>D</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msup>
     <mi>V</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>E</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>D</ci>
     <ci>normal-′</ci>
    </apply>
    <list>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>E</ci>
      <ci>normal-′</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D^{\prime}=\langle V^{\prime},E^{\prime}\rangle
  </annotation>
 </semantics>
</math>

 in which the cycle 

<math display="inline" id="Edmonds'_algorithm:21">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is "contracted" into one node as follows:</p>

<p>The nodes of 

<math display="inline" id="Edmonds'_algorithm:22">
 <semantics>
  <msup>
   <mi>V</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>V</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{\prime}
  </annotation>
 </semantics>
</math>

 are the nodes of 

<math display="inline" id="Edmonds'_algorithm:23">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>


 not in 

<math display="inline" id="Edmonds'_algorithm:24">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 plus a <em>new</em> node denoted 

<math display="inline" id="Edmonds'_algorithm:25">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>C</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{C}
  </annotation>
 </semantics>
</math>

.</p>

<p>If 

<math display="inline" id="Edmonds'_algorithm:26">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>u</mi>
   <mo>,</mo>
   <mi>v</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>u</ci>
    <ci>v</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u,v)
  </annotation>
 </semantics>
</math>

 is an edge in 

<math display="inline" id="Edmonds'_algorithm:27">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Edmonds'_algorithm:28">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>∉</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>u</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\notin C
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Edmonds'_algorithm:29">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in C
  </annotation>
 </semantics>
</math>

, then include in 

<math display="inline" id="Edmonds'_algorithm:30">
 <semantics>
  <msup>
   <mi>E</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>E</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E^{\prime}
  </annotation>
 </semantics>
</math>

 a new edge 

<math display="inline" id="Edmonds'_algorithm:31">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mi>C</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>e</ci>
    <interval closure="open">
     <ci>u</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>C</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e=(u,v_{C})
  </annotation>
 </semantics>
</math>

, and define 

<math display="inline" id="Edmonds'_algorithm:32">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>w</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>w</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>w</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>π</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>v</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>w</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>e</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>w</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>w</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>π</ci>
        <ci>v</ci>
       </apply>
       <ci>v</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}(e)=w(u,v)-w(\pi(v),v)
  </annotation>
 </semantics>
</math>

.</p>

<p>If 

<math display="inline" id="Edmonds'_algorithm:33">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>u</mi>
   <mo>,</mo>
   <mi>v</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>u</ci>
    <ci>v</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u,v)
  </annotation>
 </semantics>
</math>


 is an edge in 

<math display="inline" id="Edmonds'_algorithm:34">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Edmonds'_algorithm:35">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>∈</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>u</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\in C
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Edmonds'_algorithm:36">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∉</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>v</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\notin C
  </annotation>
 </semantics>
</math>

, then include in 

<math display="inline" id="Edmonds'_algorithm:37">
 <semantics>
  <msup>
   <mi>E</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>E</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E^{\prime}
  </annotation>
 </semantics>
</math>

 a new edge 

<math display="inline" id="Edmonds'_algorithm:38">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mi>C</mi>
    </msub>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>e</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>C</ci>
     </apply>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e=(v_{C},v)
  </annotation>
 </semantics>
</math>


, and define 

<math display="inline" id="Edmonds'_algorithm:39">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>w</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>w</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>e</ci>
    </apply>
    <apply>
     <times></times>
     <ci>w</ci>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}(e)=w(u,v)
  </annotation>
 </semantics>
</math>

.</p>

<p>If 

<math display="inline" id="Edmonds'_algorithm:40">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>u</mi>
   <mo>,</mo>
   <mi>v</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>u</ci>
    <ci>v</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u,v)
  </annotation>
 </semantics>
</math>

 is an edge in 

<math display="inline" id="Edmonds'_algorithm:41">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Edmonds'_algorithm:42">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>∉</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>u</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\notin C
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Edmonds'_algorithm:43">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∉</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>v</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\notin C
  </annotation>
 </semantics>
</math>


, then include in 

<math display="inline" id="Edmonds'_algorithm:44">
 <semantics>
  <msup>
   <mi>E</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>E</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E^{\prime}
  </annotation>
 </semantics>
</math>

 a new edge 

<math display="inline" id="Edmonds'_algorithm:45">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>e</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e=(u,v)
  </annotation>
 </semantics>
</math>

, and define 

<math display="inline" id="Edmonds'_algorithm:46">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>w</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>w</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>w</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>e</ci>
    </apply>
    <apply>
     <times></times>
     <ci>w</ci>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}(e)=w(u,v)
  </annotation>
 </semantics>
</math>

.</p>

<p>For each edge in 

<math display="inline" id="Edmonds'_algorithm:47">
 <semantics>
  <msup>
   <mi>E</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>E</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E^{\prime}
  </annotation>
 </semantics>
</math>

, we remember which edge in 

<math display="inline" id="Edmonds'_algorithm:48">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>


 it corresponds to.</p>

<p>Now find a minimum spanning arborescence 

<math display="inline" id="Edmonds'_algorithm:49">
 <semantics>
  <msup>
   <mi>A</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>A</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{\prime}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Edmonds'_algorithm:50">
 <semantics>
  <msup>
   <mi>D</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>D</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D^{\prime}
  </annotation>
 </semantics>
</math>

 using a call to 

<math display="inline" id="Edmonds'_algorithm:51">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>D</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <mi>r</mi>
    <mo>,</mo>
    <msup>
     <mi>w</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>D</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>r</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>w</ci>
      <ci>normal-′</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(D^{\prime},r,w^{\prime})
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Edmonds'_algorithm:52">
 <semantics>
  <msup>
   <mi>A</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>A</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{\prime}
  </annotation>
 </semantics>
</math>

 is a spanning arborescence, each vertex has exactly one incoming edge. Let 

<math display="inline" id="Edmonds'_algorithm:53">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>u</mi>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mi>C</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>u</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>C</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u,v_{C})
  </annotation>
 </semantics>
</math>


 be the unique incoming edge to 

<math display="inline" id="Edmonds'_algorithm:54">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>C</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{C}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Edmonds'_algorithm:55">
 <semantics>
  <msup>
   <mi>A</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>A</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{\prime}
  </annotation>
 </semantics>
</math>

. This edge corresponds to an edge 

<math display="inline" id="Edmonds'_algorithm:56">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u,v)\in E
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Edmonds'_algorithm:57">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in C
  </annotation>
 </semantics>
</math>

. Remove the edge 

<math display="inline" id="Edmonds'_algorithm:58">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi>v</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <times></times>
     <ci>π</ci>
     <ci>v</ci>
    </apply>
    <ci>v</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\pi(v),v)
  </annotation>
 </semantics>
</math>


 from 

<math display="inline" id="Edmonds'_algorithm:59">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

, breaking the cycle. Mark each remaining edge in 

<math display="inline" id="Edmonds'_algorithm:60">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

. For each edge in 

<math display="inline" id="Edmonds'_algorithm:61">
 <semantics>
  <msup>
   <mi>A</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>A</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{\prime}
  </annotation>
 </semantics>
</math>

, mark its corresponding edge in 

<math display="inline" id="Edmonds'_algorithm:62">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

. Now we define 

<math display="inline" id="Edmonds'_algorithm:63">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>r</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <vector>
     <ci>D</ci>
     <ci>r</ci>
     <ci>w</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(D,r,w)
  </annotation>
 </semantics>
</math>


 to be the set of marked edges, which form a minimum spanning arborescence.</p>

<p>Observe that 

<math display="inline" id="Edmonds'_algorithm:64">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>r</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <vector>
     <ci>D</ci>
     <ci>r</ci>
     <ci>w</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(D,r,w)
  </annotation>
 </semantics>
</math>

 is defined in terms of 

<math display="inline" id="Edmonds'_algorithm:65">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>D</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <mi>r</mi>
    <mo>,</mo>
    <msup>
     <mi>w</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>D</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>r</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>w</ci>
      <ci>normal-′</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(D^{\prime},r,w^{\prime})
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Edmonds'_algorithm:66">
 <semantics>
  <msup>
   <mi>D</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>D</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D^{\prime}
  </annotation>
 </semantics>
</math>

 having strictly fewer vertices than 

<math display="inline" id="Edmonds'_algorithm:67">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

. Finding 

<math display="inline" id="Edmonds'_algorithm:68">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>r</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <vector>
     <ci>D</ci>
     <ci>r</ci>
     <ci>w</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(D,r,w)
  </annotation>
 </semantics>
</math>


 for a single-vertex graph is trivial (it is just 

<math display="inline" id="Edmonds'_algorithm:69">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 itself), so the recursive algorithm is guaranteed to terminate.</p>
<h2 id="running-time">Running time</h2>

<p>The running time of this algorithm is 

<math display="inline" id="Edmonds'_algorithm:70">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>E</mi>
     <mi>V</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(EV)
  </annotation>
 </semantics>
</math>

. A faster implementation of the algorithm due to <a href="Robert_Tarjan" title="wikilink">Robert Tarjan</a> runs in time 

<math display="inline" id="Edmonds'_algorithm:71">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mi>log</mi>
      <mi>V</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <log></log>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(E\log V)
  </annotation>
 </semantics>
</math>

 for <a href="sparse_graph" title="wikilink">sparse graphs</a> and 

<math display="inline" id="Edmonds'_algorithm:72">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>V</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(V^{2})
  </annotation>
 </semantics>
</math>

 for dense graphs. This is as fast as <a href="Prim's_algorithm" title="wikilink">Prim's algorithm</a> for an undirected minimum spanning tree. In 1986, Gabow, Galil, Spencer, and Tarjan produced a faster implementation, with running time 

<math display="inline" id="Edmonds'_algorithm:73">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>E</mi>
     <mo>+</mo>
     <mrow>
      <mi>V</mi>
      <mrow>
       <mi>log</mi>
       <mi>V</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <ci>E</ci>
     <apply>
      <times></times>
      <ci>V</ci>
      <apply>
       <log></log>
       <ci>V</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(E+V\log V)
  </annotation>
 </semantics>
</math>


.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://edmonds-alg.sourceforge.net/">Edmonds's algorithm ( edmonds-alg )</a> – An <a href="open_source" title="wikilink">open source</a> implementation of Edmonds's algorithm written in <a class="uri" href="C++" title="wikilink">C++</a> and licensed under the <a href="MIT_License" title="wikilink">MIT License</a>. This source is using Tarjan's implementation for the dense graph.</li>
</ul>

<p>"</p>

<p><a href="Category:Graph_algorithms" title="wikilink">Category:Graph algorithms</a></p>
</body>
</html>
