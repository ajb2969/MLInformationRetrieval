<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1159">Term (logic)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Term (logic)</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In analogy to natural language, where a <a href="noun_phrase" title="wikilink">noun phrase</a> refers to an object and a whole <a href="Sentence_(linguistics)" title="wikilink">sentence</a> refers to a fact, in <a href="mathematical_logic" title="wikilink">mathematical logic</a>, a <strong>term</strong> denotes a mathematical object and a <a href="Formula_(mathematical_logic)" title="wikilink">formula</a> denotes a mathematical fact. In particular, terms appear as components of a formula.</p>

<p>A first-order term is <a href="recursive_definition" title="wikilink">recursively constructed</a> from constant symbols, <a href="Variable_(mathematics)" title="wikilink">variables</a> and <a href="function_symbol_(logic)" title="wikilink">function symbols</a>. An expression formed by applying a <a href="predicate_(logic)" title="wikilink">predicate symbol</a> to an appropriate number of terms is called an <a href="atomic_formula" title="wikilink">atomic formula</a>, which evaluates to <a href="Truth#Truth_in_mathematics" title="wikilink">true</a> or <a href="False_(logic)" title="wikilink">false</a> in <a href="Principle_of_bivalence" title="wikilink">bivalent logics</a>, given an <a href="interpretation_(logic)" title="wikilink">interpretation</a>. For example, (<em>x</em>+1)*(<em>x</em>+1) is a term built from the constant 1, the variable <em>x</em>, and the binary function symbols + and *; it is part of the atomic formula (<em>x</em>+1)*(<em>x</em>+1) ≥ 0 which evaluates to true for each <a href="real_number" title="wikilink">real-numbered</a> value of <em>x</em>.</p>

<p>Besides in <a class="uri" href="logic" title="wikilink">logic</a>, terms play important roles in <a href="universal_algebra" title="wikilink">universal algebra</a>, and <a href="rewriting_system" title="wikilink">rewriting systems</a>.</p>
<h2 id="elementary-mathematics">Elementary mathematics</h2>

<p>In the context of <a href="polynomial" title="wikilink">polynomials</a>, sometimes <em>term</em> is used for a <a class="uri" href="monomial" title="wikilink">monomial</a> with a <a class="uri" href="coefficient" title="wikilink">coefficient</a>: to 'collect <a href="Like_and_unlike_terms" title="wikilink">like terms</a>' in a polynomial is the <a href="Operation_(mathematics)" title="wikilink">operation</a> of making it a <a href="linear_combination" title="wikilink">linear combination</a> of <a class="uri" href="distinct" title="wikilink">distinct</a> monomials. Terms, in this sense, are things that are added or subtracted. A <a href="Series_(mathematics)" title="wikilink">series</a> is often represented as the sum of a <a class="uri" href="sequence" title="wikilink">sequence</a> of terms. Individual factors in an expression representing a product are <a href="Multiplication#Notation_and_terminology" title="wikilink">multiplicative terms</a>. For example, in 6 + 3<em>x</em> − 2, 6, 3<em>x</em>, and −2 are all terms.</p>

<p>In elementary mathematics,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<ul>
<li>each argument term of the addition operator + is called an <em><a class="uri" href="addend" title="wikilink">addend</a></em>,</li>
<li>the first and second argument term of the subtraction operator - is called a <em><a class="uri" href="minuend" title="wikilink">minuend</a></em> and <em><a class="uri" href="subtrahend" title="wikilink">subtrahend</a></em>, respectively,</li>
<li>each argument term of the multiplication operator ⋅ is called a <em>factor</em>, the first and second argument term is also called <em>multiplicand</em> and <em>multiplier</em>, respectively,</li>
<li>the first and second argument term of the division operator / is called <em>dividend</em> and <em><a class="uri" href="divisor" title="wikilink">divisor</a></em>, respectively,</li>
<li>if the division operator is written as <a href="Fraction_(mathematics)#Common.2C_vulgar.2C_or_simple_fractions" title="wikilink">fraction bar</a>, the top and bottom terms are called <em>numerator</em> and <em>denominator</em>, respectively.</li>
</ul>
<h2 id="formal-definition">Formal definition</h2>
<figure><b>(Figure)</b>
<figcaption>Tree structure of terms (<em>n</em>⋅(<em>n</em>+1))/2 and <em>n</em>⋅((<em>n</em>+1)/2)</figcaption>
</figure>

<p>Given a set <em>V</em> of variable symbols, a set <em>C</em> of constant symbols and sets <em>F</em><sub><em>n</em></sub> of <em>n</em>-ary function symbols, also called operator symbols, for each natural number <em>n</em> ≥ 1, the set of (unsorted first-order) terms <em>T</em> is <a href="recursive_definition" title="wikilink">recursively defined</a> to be the smallest set with the following properties:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<ul>
<li>every variable symbol is a term: <em>V</em> ⊆ <em>T</em>,</li>
<li>every constant symbol is a term: <em>C</em> ⊆ <em>T</em>,</li>
<li>from every <em>n</em> terms <em>t</em><sub>1</sub>,...,<em>t</em><sub><em>n</em></sub>, and every <em>n</em>-ary function symbol <em>f</em> ∈ <em>F</em><sub><em>n</em></sub>, a larger term <em>f</em>(<em>t</em><sub>1</sub>, ..., <em>t</em><sub><em>n</em></sub>) can be built.</li>
</ul>

<p>Using an intuitive, pseudo-<a href="Grammar_formalism#Formal_definition" title="wikilink">grammatical</a> notation, this is sometimes written as: <em>t</em> ::= <em>x</em> | <em>c</em> | <em>f</em>(<em>t</em><sub>1</sub>, ..., <em>t</em><sub><em>n</em></sub>). Usually, only the first few function symbol sets <em>F</em><sub><em>n</em></sub> are inhabited. Well-known examples are the unary function symbols <em>sin</em>, <em>cos</em> ∈ <em>F</em><sub>1</sub>, and the binary function symbols +, −, ⋅, / ∈ <em>F</em><sub>2</sub>, while <a href="ternary_operation" title="wikilink">ternary operations</a> are less known, let alone higher-arity functions. Many authors consider constant symbols as 0-ary function symbols <em>F</em><sub>0</sub>, thus needing no special syntactic class for them.</p>

<p>A term denotes a mathematical object from the <a href="domain_of_discourse" title="wikilink">domain of discourse</a>. A constant <em>c</em> denotes a named object from that domain, a variable <em>x</em> ranges over the objects in that domain, and an <em>n</em>-ary function <em>f</em> maps <em>n</em>-<a href="tuple" title="wikilink">tuples</a> of objects to objects. For example, if <em>n</em> ∈ <em>V</em> is a variable symbol, 1 ∈ <em>C</em> is a constant symbol, and <em>add</em> ∈ <em>F</em><sub>2</sub> is a binary function symbol, then <em>n</em> ∈ <em>T</em>, 1 ∈ <em>T</em>, and (hence) <em>add</em>(<em>n</em>, 1) ∈ <em>T</em> by the first, second, and third term building rule, respectively. The latter term is usually written as <em>n</em>+1, using <a href="infix_notation" title="wikilink">infix notation</a> and the more common operator symbol + for convenience.</p>
<h3 id="term-structure-vs.-representation">Term structure vs. representation</h3>

<p>Originally, logicians defined a term to be a <em>character string</em> adhering to certain building rules.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> However, since the concept of <a href="Tree_(data_structure)" title="wikilink">tree</a> became popular in computer science, it turned out to be more convenient to think of a term as a tree. For example, several distinct character strings, like "(<em>n</em>⋅(<em>n</em>+1))/2", "((<em>n</em>⋅(<em>n</em>+1)))/2", and "

<math display="inline" id="Term_(logic):0">
 <semantics>
  <mfrac>
   <mrow>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mn>2</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{n(n+1)}{2}
  </annotation>
 </semantics>
</math>

", denote the same term and correspond to the same tree, viz. the left tree in the above picture. Separating the tree structure of a term from its graphical representation on paper, it is also easy to account for parentheses (being only representation, not structure) and invisible multiplication operators (existing only in structure, not in representation).</p>
<h3 id="structural-equality">Structural equality</h3>

<p>Two terms are said to be <strong>structurally</strong>, <strong>literally</strong>, or <strong>syntactically</strong> equal if they correspond to the same tree. For example, the left and the right tree in the above picture are structurally <strong>un</strong>equal terms, although they might be considered "<strong>semantically equal</strong>" as they always evaluate to the same value in <a href="Rational_number#Arithmetic" title="wikilink">rational arithmetic</a>. While structural equality can be checked without any knowledge about the meaning of the symbols, semantic equality cannot. If the function / is e.g. interpreted not as rational but as <a href="integer_division#Of_integers" title="wikilink">truncating integer</a> division, then at <em>n</em>=2 the left and right term evaluates to 3 and 2, respectively. Structural equal terms need to agree in their variable names.</p>

<p>In contrast, a term <em>t</em> is called a <strong>renaming</strong>, or a <strong>variant</strong>, of a term <em>u</em> if the latter resulted from consistently renaming all variables of the former, i.e. if <em>u</em> = <em>tσ</em> for some <a href="Substitution_(logic)#First-order_logic" title="wikilink">renaming substitution</a> σ. In that case, <em>u</em> is a renaming of <em>t</em>, too, since a renaming substitution σ has an inverse σ<sup>−1</sup>, and <em>t</em> = uσ<sup>−1</sup>. Both terms are then also said to be <strong>equal modulo renaming</strong>. In many contexts, the particular variable names in a term don't matter, e.g. the commutativity axiom for addition can be stated as <em>x</em>+<em>y</em>=<em>y</em>+<em>x</em> or as <em>a</em>+<em>b</em>=<em>b</em>+<em>a</em>; in such cases the whole term may be replaced by a renamed term, while an arbitrary subterm usually may not, e.g. <em>x</em>+<em>y</em>=<em>b</em>+<em>a</em> is not a valid version of the commutativity axiom. <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="ground-and-linear-terms">Ground and linear terms</h3>

<p>The set of variables of a term <em>t</em> is denoted by <em>vars</em>(<em>t</em>). A term that doesn't contain any variables is called a <strong><a href="ground_term" title="wikilink">ground term</a></strong>; a term that doesn't contain multiple occurrences of a variable is called a <strong>linear term</strong>. For example, 2+2 is a ground term and hence also a linear term, <em>x</em>⋅(<em>n</em>+1) is a linear term, <em>n</em>⋅(<em>n</em>+1) is a non-linear term. These properties are important e.g. in <a href="term_rewriting" title="wikilink">term rewriting</a>.</p>

<p>Given a <a href="signature_(logic)" title="wikilink">signature</a> for the function symbols, the set of all terms forms the <strong><a href="Free_object" title="wikilink">free</a> <a href="term_algebra" title="wikilink">term algebra</a></strong>. The set of all ground terms forms the <strong><a href="initial_algebra" title="wikilink">initial</a> term algebra</strong>.</p>

<p>Abbreviating the number of constants as <em>f</em><sub>0</sub>, and the number of <em>i</em>-ary function symbols as <em>f</em><sub><em>i</em></sub>, the <strong>number θ<sub><em>h</em></sub> of distinct ground terms</strong> of a height up to <em>h</em> can be computed by the following recursion formula:</p>
<ul>
<li>θ<sub>0</sub> = <em>f</em><sub>0</sub>, since a ground term of height 0 can only be a constant,</li>
<li>

<math display="inline" id="Term_(logic):1">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mrow>
     <mi>h</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>i</mi>
     </msub>
     <mo>⋅</mo>
     <msubsup>
      <mi>θ</mi>
      <mi>h</mi>
      <mi>i</mi>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <apply>
      <plus></plus>
      <ci>h</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <ci>h</ci>
       </apply>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{h+1}=\sum_{i=0}^{\infty}f_{i}\cdot\theta_{h}^{i}
  </annotation>
 </semantics>
</math>

, since a ground term of height up to <em>h</em>+1 can be obtained by composing any <em>i</em> ground terms of height up to <em>h</em>, using an <em>i</em>-ary root function symbol. The sum has a finite value if <em>f</em><sub><em>i</em></sub> = 0 for all <em>i</em> beyond a maximal arity, which is usually the case.</li>
</ul>
<h3 id="building-formulas-from-terms">Building formulas from terms</h3>

<p>Given a set <em>R</em><sub><em>n</em></sub> of <em>n</em>-ary relation symbols for each natural number <em>n</em> ≥ 1, an (unsorted first-order) atomic formula is obtained by applying an <em>n</em>-ary relation symbol to <em>n</em> terms. As for function symbols, a relation symbol set <em>R</em><sub><em>n</em></sub> is usually non-empty only for small <em>n</em>. In mathematical logic, more complex <a href="First-order_logic#Formulas" title="wikilink">formulas</a> are built from atomic formulas using <a href="logical_connective" title="wikilink">logical connectives</a> and <a href="Quantifier_(logic)" title="wikilink">quantifiers</a>. For example, letting ℝ denote the set of <a href="real_number" title="wikilink">real numbers</a>, ∀<em>x</em>: <em>x</em> ∈ ℝ ⇒ (<em>x</em>+1)⋅(<em>x</em>+1) ≥ 0 is a mathematical formula evaluating to true in the algebra of <a href="complex_number" title="wikilink">complex numbers</a>. An atomic formula is called ground if it is build entirely from ground terms; all ground atomic formulas composable from a given set of function and predicate symbols make up the <a href="Herbrand_universe#Herbrand_base" title="wikilink">Herbrand universe</a> for these symbol sets.</p>
<h2 id="operations-with-terms">Operations with terms</h2>
<figure><b>(Figure)</b>
<figcaption>Tree structure of black example term 

<math display="inline" id="Term_(logic):2">
 <semantics>
  <mfrac>
   <mrow>
    <mi>a</mi>
    <mo>*</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>a</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>*</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>a</mi>
        <mo>+</mo>
        <mn>2</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mrow>
    <mn>1</mn>
    <mo>*</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>2</mn>
      <mo>*</mo>
      <mn>3</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>a</ci>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <plus></plus>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{a*((a+1)*(a+2))}{1*(2*3)}
  </annotation>
 </semantics>
</math>

, with blue redex <em>x</em>*(<em>y</em>*<em>z</em>)</figcaption>
</figure>
<ul>
<li>Since a term has the structure of a tree hierarchy, to each of its nodes a <strong>position</strong>, or <strong>path</strong>, can be assigned, that is, a string of decimal numbers indicating the node's place in the hierarchy. The empty string, commonly denoted by ε, is assigned to the root node. Position strings within the black term are indicated in red in the picture.</li>
<li>At each position <em>p</em> of a term <em>t</em>, a unique <strong>subterm</strong> starts, which is commonly denoted by <em>t</em>|<sub><em>p</em></sub>. For example, at position 122 of the black term in the picture, the subterm <em>a</em>+2 has its root. The relation <em>"is a subterm of"</em> is a <a href="partial_order" title="wikilink">partial order</a> on the set of terms; it is <a href="reflexive_relation" title="wikilink">reflexive</a> since each term is trivially a subterm of itself.</li>
<li>The term obtained by <strong>replacing</strong> in a term <em>t</em> the subterm at a position <em>p</em> by a new term <em>u</em> is commonly denoted by <em>t</em>[<em>u</em>]<sub><em>p</em></sub>. That term <em>t</em>[<em>u</em>]<sub><em>p</em></sub> can also be viewed as resulting from a generalized concatenation of the term <em>u</em> with a term-like object <em>t</em>[.]; the latter is called a <strong>context</strong>, or a <strong>term with a hole</strong> (indicated by "."; its position being <em>p</em>), in which <em>u</em> is said to be <strong>embedded</strong>. For example, if <em>t</em> is the black term in the picture, then <em>t</em>[<em>b</em>+1]<sub>12</sub> results in the term 

<math display="inline" id="Term_(logic):3">
 <semantics>
  <mfrac>
   <mrow>
    <mi>a</mi>
    <mo>*</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mrow>
    <mn>1</mn>
    <mo>*</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>2</mn>
      <mo>*</mo>
      <mn>3</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>a</ci>
     <apply>
      <plus></plus>
      <ci>b</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{a*(b+1)}{1*(2*3)}
  </annotation>
 </semantics>
</math>

. The latter term also results from embedding the term <em>b</em>+1 into the context 

<math display="inline" id="Term_(logic):4">
 <semantics>
  <mfrac>
   <mrow>
    <mi>a</mi>
    <mo>*</mo>
    <mrow>
     <mo rspace="5.3pt" stretchy="false">(</mo>
     <mo rspace="5.3pt">.</mo>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mrow>
    <mn>1</mn>
    <mo>*</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>2</mn>
      <mo>*</mo>
      <mn>3</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <times></times>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <ci>normal-.</ci>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{a*(\;.\;)}{1*(2*3)}
  </annotation>
 </semantics>
</math>

. In an informal sense, the operations of <a href="substitution_(logic)#First-order_logic" title="wikilink">instantiating</a> and embedding are converse to each other: while the former appends function symbols at the bottom of the term, the latter appends them at the top. The <a href="encompassment_ordering" title="wikilink">encompassment ordering</a> relates a term and any result of appends at either sides.</li>
<li>To each node of a term, its <strong>depth</strong> (called <strong>height</strong> by some authors) can be assigned, i.e. its distance (number of edges) from the root. In this setting, the depth of a node always equals the length of its position string. In the picture, depth levels in the black term are indicated in green.</li>
<li>The <strong>size</strong> of a term commonly refers to the number of its nodes, or, equivalently, to the length of the term's written representation, counting symbols without parentheses. The black and the blue term in the picture has the size 15 and 5, respectively.</li>
<li>A term <em>u</em> <strong>matches</strong> a term <em>t</em>, if an instance of <em>u</em> structurally equals a subterm of <em>t</em>, or formally, if <em>u</em>σ = <em>t</em>|<sub><em>p</em></sub> for some position <em>p</em> in <em>t</em> and some substitution σ. In this case, <em>u</em>, <em>t</em>, and σ is called the <strong>pattern term</strong>, the <strong>subject term</strong>, and the <strong>matching substitution</strong>, respectively. In the picture, the blue pattern term <em>x</em>*(<em>y</em>*<em>z</em>) matches the black subject term at position 1, with the matching substitution  indicated by blue variables immediately left to their black substitutes. Intuitively, the pattern, except for its variables, must be contained in the subject; if a variable occurs multiply in the pattern, equal subterms are required at the respective positions of the subject.</li>
<li><a href="Unification_(computer_science)#Syntactic_unification_of_first-order_terms" title="wikilink">unifying terms</a></li>
<li><a href="Term_rewriting#Term_rewriting_systems" title="wikilink">term rewriting</a></li>
</ul>
<h2 id="related-concepts">Related concepts</h2>
<h3 id="sorted-terms">Sorted terms</h3>

<p>When the domain of discourse contains elements of basically different kinds, it is useful to split the set of all terms accordingly. To this end, a <strong>sort</strong> (sometimes also called <strong>type</strong>) is assigned to each variable and each constant symbol, and a declaration <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> of domain sorts and range sort to each function symbol. A <strong>sorted term</strong> <em>f</em>(<em>t</em><sub>1</sub>,...,<em>t</em><sub><em>n</em></sub>) may be composed from sorted subterms <em>t</em><sub>1</sub>,...,<em>t</em><sub><em>n</em></sub> only if the <em>i</em>th subterm's sort matches the declared <em>i</em>th domain sort of <em>f</em>. Such a term is also called <strong>well-sorted</strong>; any other term (i.e. obeying the <a href="#formal_definition" title="wikilink">unsorted rules</a> only) is called <strong>ill-sorted</strong>.</p>

<p>For example, a <a href="vector_space#Definition" title="wikilink">vector space</a> comes with an associated <a href="field_(mathematics)" title="wikilink">field</a> of scalar numbers. Let <em>W</em> and <em>N</em> denote the sort of vectors and numbers, respectively, let <em>V</em><sub><em>W</em></sub> and <em>V</em><sub><em>N</em></sub> be the set of vector and number variables, respectively, and <em>C</em><sub><em>W</em></sub> and <em>C</em><sub><em>N</em></sub> the set of vector and number constants, respectively. Then e.g. 

<math display="inline" id="Term_(logic):5">
 <semantics>
  <mover accent="true">
   <mn>0</mn>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{0}
  </annotation>
 </semantics>
</math>

 ∈ <em>C</em><sub><em>W</em></sub> and 0 ∈ <em>C</em><sub><em>N</em></sub>, and the vector addition, the scalar multiplication, and the inner product is declared as +:<em>W</em>×<em>W</em>→<em>W</em>, *:<em>W</em>×<em>N</em>→<em>W</em>, and ⟨.,.⟩:<em>W</em>×<em>W</em>→<em>N</em>, respectively. Assuming variable symbols 

<math display="inline" id="Term_(logic):6">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>v</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mo>,</mo>
   <mover accent="true">
    <mi>w</mi>
    <mo stretchy="false">→</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <ci>normal-→</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>w</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{v},\vec{w}
  </annotation>
 </semantics>
</math>

 ∈ <em>V</em><sub><em>W</em></sub> and <em>a</em>,<em>b</em> ∈ <em>V</em><sub><em>N</em></sub>, the term 

<math display="inline" id="Term_(logic):7">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mover accent="true">
       <mi>v</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo>+</mo>
      <mover accent="true">
       <mn>0</mn>
       <mo stretchy="false">→</mo>
      </mover>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
    <mi>a</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mover accent="true">
     <mi>w</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo>*</mo>
    <mi>b</mi>
   </mrow>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <ci>normal-→</ci>
       <ci>v</ci>
      </apply>
      <apply>
       <ci>normal-→</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-→</ci>
      <ci>w</ci>
     </apply>
     <ci>b</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle(\vec{v}+\vec{0})*a,\vec{w}*b\rangle
  </annotation>
 </semantics>
</math>

 is well-sorted, while 

<math display="inline" id="Term_(logic):8">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>v</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mo>+</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <ci>normal-→</ci>
     <ci>v</ci>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{v}+a
  </annotation>
 </semantics>
</math>

 is not (since + doesn't accept a term of sort <em>N</em> as 2nd argument). In order to make 

<math display="inline" id="Term_(logic):9">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>*</mo>
   <mover accent="true">
    <mi>v</mi>
    <mo stretchy="false">→</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a*\vec{v}
  </annotation>
 </semantics>
</math>

 a well-sorted term, an additional declaration *:<em>N</em>×<em>W</em>→<em>W</em> is required. Function symbols having several declarations are called <strong>overloaded</strong>.</p>

<p>See <a href="many-sorted_logic" title="wikilink">many-sorted logic</a> for more information, including extensions of the <strong>many-sorted framework</strong> described here.</p>
<h3 id="lambda-terms">Lambda terms</h3>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Terms with bound variables</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Notation<br/>
 example</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>lim<sub><em>n</em>→∞</sub> <em>x</em>/<em>n</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Term_(logic):10">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>n</mi>
   </msubsup>
   <msup>
    <mi>i</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>i</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{n}i^{2}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Term_(logic):11">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <mi>a</mi>
    <mi>b</mi>
   </msubsup>
   <mrow>
    <mrow>
     <mi>sin</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>k</mi>
       <mo>⋅</mo>
       <mi>t</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mi>d</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>a</ci>
     </apply>
     <ci>b</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <sin></sin>
      <apply>
       <ci>normal-⋅</ci>
       <ci>k</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <ci>d</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{a}^{b}\sin(k\cdot t)dt
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
<h4 id="motivation">Motivation</h4>

<p>Mathematical notations as shown in the table do not fit into the scheme of a first-order term as defined <a href="#formal_definition" title="wikilink">above</a>, as they all introduce an own <strong>local</strong>, or <strong>bound</strong>, variable that may not appear outside the notation's scope, e.g. 

<math display="inline" id="Term_(logic):12">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>⋅</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi>a</mi>
     <mi>b</mi>
    </msubsup>
    <mrow>
     <mrow>
      <mi>sin</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>k</mi>
        <mo>⋅</mo>
        <mi>t</mi>
       </mrow>
       <mo rspace="5.3pt" stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mi>d</mi>
     <mi>t</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>t</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>a</ci>
      </apply>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <sin></sin>
       <apply>
        <ci>normal-⋅</ci>
        <ci>k</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\cdot\int_{a}^{b}\sin(k\cdot t)\;dt
  </annotation>
 </semantics>
</math>

 doesn't make sense. In contrast, the other variables, referred to as <strong>free</strong>, behave like ordinary first-order term variables, e.g. 

<math display="inline" id="Term_(logic):13">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>⋅</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi>a</mi>
     <mi>b</mi>
    </msubsup>
    <mrow>
     <mrow>
      <mi>sin</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>k</mi>
        <mo>⋅</mo>
        <mi>t</mi>
       </mrow>
       <mo rspace="5.3pt" stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mi>d</mi>
     <mi>t</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>k</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>a</ci>
      </apply>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <sin></sin>
       <apply>
        <ci>normal-⋅</ci>
        <ci>k</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\cdot\int_{a}^{b}\sin(k\cdot t)\;dt
  </annotation>
 </semantics>
</math>

 does make sense.</p>

<p>All these operators can be viewed as taking a function rather than a value term as one of their arguments. For example, the <em>lim</em> operator is applied to a sequence, i.e. to a mapping from positive integer to e.g. real numbers. As another example, a <a href="C_(programming_language)" title="wikilink">C</a> function to implement the second example from the table, ∑, would have a function pointer argument (see box below).</p>

<p><strong><a href="Lambda_term" title="wikilink">Lambda terms</a></strong> can be used to denote <strong><a href="anonymous_function" title="wikilink">anonymous functions</a></strong> to be supplied as arguments to <em>lim</em>, ∑, ∫, etc.</p>

<p>For example, the function <em>square</em> from the C program below can be written anonymously as a lambda term λ<em>i</em>. <em>i</em><sup>2</sup>. The general sum operator ∑ can then be considered as a ternary function symbol taking a lower bound value, an upper bound value and a function to be summed-up. Due to its latter argument, the ∑ operator is called a <strong>second-order function symbol</strong>. As another example, the lambda term λ<em>n</em>. <em>x</em>/<em>n</em> denotes a function that maps 1, 2, 3, ... to <em>x</em>/1, <em>x</em>/2, <em>x</em>/3, ..., respectively, that is, it denotes the <a href="Sequence#Definition" title="wikilink">sequence</a> (<em>x</em>/1, <em>x</em>/2, <em>x</em>/3, ...). The <em>lim</em> operator takes such a sequence and returns its limit (if defined).</p>

<p>The rightmost column of the table indicates how each mathematical notation example can be represented by a lambda term, also converting common <a href="Infix_notation" title="wikilink">infix</a> operators into <a href="Polish_notation" title="wikilink">prefix</a> form.</p>
<div class="sourceCode"><pre class="sourceCode C"><code class="sourceCode c"><span class="dt">int</span> sum(<span class="dt">int</span> lwb, <span class="dt">int</span> upb, <span class="dt">int</span> fct(<span class="dt">int</span>)) {    <span class="co">// implements general sum operator</span>
    <span class="dt">int</span> res = <span class="dv">0</span>;
    <span class="kw">for</span> (<span class="dt">int</span> i=lwb; i&lt;=upb; ++i)
        res += fct(i);
    <span class="kw">return</span> res;
}

<span class="dt">int</span> square(<span class="dt">int</span> i) { <span class="kw">return</span> i*i; }            <span class="co">// implements anonymous function (lambda i. i*i); however, C requires a name for it</span>

<span class="ot">#include <stdio.h></stdio.h></span>
<span class="dt">int</span> main(<span class="dt">void</span>) {
    <span class="dt">int</span> n;
    scanf(<span class="st">" %d"</span>,&amp;n;);
    printf(<span class="st">"%d</span><span class="ch">\n</span><span class="st">"</span>, sum(<span class="dv">1</span>,n,square) );        <span class="co">// applies sum operator to sum up squares</span>
    <span class="kw">return</span> <span class="dv">0</span>;
}
</code></pre></div></body>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Equation" title="wikilink">Equation</a></li>
<li><a href="Expression_(mathematics)" title="wikilink">Expression (mathematics)</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Mathematical_logic" title="wikilink">Category:Mathematical logic</a> <a href="Category:Rewriting_systems" title="wikilink">Category:Rewriting systems</a> <a href="Category:Elementary_mathematics" title="wikilink">Category:Elementary mathematics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">; here: Sect.1.3<a href="#fnref2">↩</a></li>
<li id="fn3">; here: Sect.II.1.3<a href="#fnref3">↩</a></li>
<li id="fn4">Strictly speaking, <em>x</em>+<em>y</em>=<em>y</em>+<em>x</em> is an atomic formula, not a term, since = is a predicate, not a function symbol. However, since atomic formulas can be viewed as trees, too, and renaming is essentially a concept on trees, atomic (and, more generally, <a href="Quantifier-free_formula#Predicate_logic" title="wikilink">quantifier-free</a>) formulas can be renamed in a similar way as terms. In fact, some authors consider a quantifier-free formula as a term (of type <em>bool</em> rather than e.g. <em>int</em>, cf. <a href="#Sorted_terms" title="wikilink">#Sorted terms</a> below).<a href="#fnref4">↩</a></li>
<li id="fn5">Renaming of the commutativity axiom can be viewed as <a href="Lambda_calculus#.CE.B1-conversion" title="wikilink">alpha-conversion</a> on the <a href="Universal_quantification#Universal_closure" title="wikilink">universal closure</a> of the axiom: "<em>x</em>+<em>y</em>=<em>y</em>+<em>x</em>" actually means "∀<em>x</em>,<em>y</em>: <em>x</em>+<em>y</em>=<em>y</em>+<em>x</em>", which is synonymous to "∀<em>a</em>,<em>b</em>: <em>a</em>+<em>b</em>=<em>b</em>+<em>a</em>"; see also <a href="#Lambda_terms" title="wikilink">#Lambda terms</a> below.<a href="#fnref5">↩</a></li>
<li id="fn6">called "symbol type" in the <a href="Signature_(logic)#Many-sorted_signatures" title="wikilink">Signature (logic)#Many-sorted signatures</a> article<a href="#fnref6">↩</a></li>
</ol>
</section>


