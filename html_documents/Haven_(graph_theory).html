<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="62">Haven (graph theory)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Haven (graph theory)</h1>
<hr/>

<p>In <a href="graph_theory" title="wikilink">graph theory</a>, a <strong>haven</strong> is a certain type of function on sets of <a href="vertex_(graph_theory)" title="wikilink">vertices</a> in an <a href="undirected_graph" title="wikilink">undirected graph</a>. If a haven exists, it can be used by an evader to win a <a class="uri" href="pursuit-evasion" title="wikilink">pursuit-evasion</a> game on the graph, by consulting the function at each step of the game to determine a safe set of vertices to move into. Havens were first introduced by  as a tool for characterizing the <a class="uri" href="treewidth" title="wikilink">treewidth</a> of graphs.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Their other applications include proving the existence of <a href="planar_separator_theorem" title="wikilink">small separators</a> on <a href="Robertson–Seymour_theorem" title="wikilink">minor-closed families of graphs</a>,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and characterizing the <a href="End_(graph_theory)" title="wikilink">ends</a> and <a href="clique_(graph_theory)" title="wikilink">clique</a> <a href="minor_(graph_theory)" title="wikilink">minors</a> of <a href="infinite_graph" title="wikilink">infinite graphs</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="definition">Definition</h2>

<p>If <em>G</em> is an undirected graph, and <em>X</em> is a set of vertices, then an <em>X</em>-flap is a nonempty <a href="connected_component_(graph_theory)" title="wikilink">connected component</a> of the subgraph of <em>G</em> formed by deleting <em>X</em>. A <strong>haven</strong> of order <em>k</em> in <em>G</em> is a function <em>β</em> that assigns an <em>X</em>-flap <em>β</em>(<em>X</em>) to every set <em>X</em> of fewer than <em>k</em> vertices. This function must also satisfy additional constraints which are given differently by different authors. The number <em>k</em> is called the <em>order</em> of the haven.<ref name="JRST">{{ citation</ref></p>

<p><code>| last1 = Johnson | first1 = Thor. | author1-link = Thor Johnson</code><br/>
<code>| last2 = Robertson | first2 = Neil. | author2-link = Neil Robertson (mathematician)</code><br/>
<code>| last3 = Seymor | first3 = P.D. | author3-link = Paul Seymour (mathematician)</code><br/>
<code>| last4 = Thomas | first4 = Robin | author4-link = Robin Thomas (mathematician)</code><br/>
<code>| doi = 10.1006/jctb.2000.2031</code><br/>
<code>| issue = 1</code><br/>
<code>| journal = </code><a href="Journal_of_Combinatorial_Theory" title="wikilink"> <code>Journal</code> <code>of</code> <code>Combinatorial</code> <code>Theory,</code> <code>Series</code> <code>B</code></a><code> </code><br/>
<code>| pages = 138–155</code><br/>
<code>| title = Directed Tree Width</code><br/>
<code>| volume = 82</code><br/>
<code>| year = 2001}}.</code></p>

<p>In the original definition of Seymour and Thomas,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> a haven is required to satisfy the property that every two flaps <em>β</em>(<em>X</em>) and <em>β</em>(<em>Y</em>) must touch each other: either they share a common vertex or there exists an edge with one endpoint in each flap. In the definition used later by Alon, Seymour, and Thomas,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> havens are instead required to satisfy a weaker <a class="uri" href="monotonicity" title="wikilink">monotonicity</a> property: if , and both <em>X</em> and <em>Y</em> have fewer than <em>k</em> vertices, then . The touching property implies the monotonicity property, but not necessarily vice versa. However, it follows from the results of Seymour and Thomas<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> that, in finite graphs, if a haven with the monotonicity property exists, then one with the same order and the touching property also exists.</p>

<p> Havens with the touching definition are closely related to <a href="bramble_(graph_theory)" title="wikilink">brambles</a>, families of connected subgraphs of a given graph that all touch each other. The order of a bramble is the minimum number of vertices needed in a set of vertices that hits all of the subgraphs in the family. The set of flaps <em>β</em>(<em>X</em>) for a haven of order <em>k</em> (with the touching definition) forms a bramble of order at least <em>k</em>, because any set <em>Y</em> of fewer than <em>k</em> vertices fails to hit the subgraph <em>β</em>(<em>Y</em>). Conversely, from any bramble of order <em>k</em>, one may construct a haven of the same order, by defining <em>β</em>(<em>X</em>) (for each choice of <em>X</em>) to be the <em>X</em>-flap that includes all of the subgraphs in the bramble that are disjoint from <em>X</em>. The requirement that the subgraphs in the bramble all touch each other can be used to show that this <em>X</em>-flap exists, and that all of the flaps <em>β</em>(<em>X</em>) chosen in this way touch each other. Thus, a graph has a bramble of order <em>k</em> if and only if it has a haven of order <em>k</em>.</p>
<h2 id="example">Example</h2>

<p>As an example, let <em>G</em> be a nine-vertex <a href="grid_graph" title="wikilink">grid graph</a>. Define a haven of order 4 in <em>G</em>, mapping each set <em>X</em> of three or fewer vertices to an <em>X</em>-flap <em>β</em>(<em>X</em>), as follows:</p>
<ul>
<li>If there is a unique <em>X</em>-flap that is larger than any of the other <em>X</em>-flaps, let <em>β</em>(<em>X</em>) be that unique large <em>X</em>-flap.</li>
<li>Otherwise, choose <em>β</em>(<em>X</em>) arbitrarily to be any <em>X</em>-flap.</li>
</ul>

<p>It is straightforward to verify by a <a href="case_analysis" title="wikilink">case analysis</a> that this function <em>β</em> satisfies the required monotonicity property of a haven. If  and <em>X</em> has fewer than two vertices, or <em>X</em> has two vertices that are not the two neighbors of a corner vertex of the grid, then there is only one <em>X</em>-flap and it contains every <em>Y</em>-flap. In the remaining case, <em>X</em> consists of the two neighbors of a corner vertex and has two <em>X</em>-flaps: one consisting of that corner vertex, and another (chosen as <em>β</em>(<em>X</em>)) consisting of the six remaining vertices. No matter which vertex is added to <em>X</em> to form <em>Y</em>, there will be a <em>Y</em>-flap with at least four vertices, which must be the unique largest flap since it contains more than half of the vertices not in <em>Y</em>. This large <em>Y</em>-flap will be chosen as <em>β</em>(<em>Y</em>) and will be a subset of <em>β</em>(<em>X</em>). Thus in each case monotonicity holds.</p>
<h2 id="pursuit-evasion">Pursuit-evasion</h2>

<p>Havens model a certain class of strategies for an evader in a <a class="uri" href="pursuit-evasion" title="wikilink">pursuit-evasion</a> game in which fewer than <em>k</em> pursuers attempt to capture a single evader, the pursuers and evader are both restricted to the vertices of a given undirected graph, and the positions of the pursuers and evader are known to both players. At each move of the game, a new pursuer may be added to an arbitrary vertex of the graph (as long as fewer than <em>k</em> pursuers are placed on the graph at any time) or one of the already-added pursuers may be removed from the graph. However, before a new pursuer is added, the evader is first informed of its new location and may move along the edges of the graph to any unoccupied vertex. While moving, the evader may not pass through any vertex that is already occupied by any of the pursuers.</p>

<p>If a <em>k</em>-haven (with the monotonicity property) exists, then the evader may avoid being captured indefinitely, and win the game, by always moving to a vertex of <em>β</em>(<em>X</em>) where <em>X</em> is the set of vertices that will be occupied by pursuers at the end of the move. The monotonicity property of a haven guarantees that, when a new pursuer is added to a vertex of the graph, the vertices in <em>β</em>(<em>X</em>) are always reachable from the current position of the evader.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>For instance, an evader can win this game against three pursuers on a  grid by following this strategy with the haven of order 4 described in the example. However, on the same graph, four pursuers can always capture the evader, by first moving onto three vertices that split the grid onto two three-vertex paths, then moving into the center of the path containing the evader, forcing the evader into one of the corner vertices, and finally removing one of the pursuers that is not adjacent to this corner and placing it onto the evader. Therefore, the  grid can have no haven of order 5.</p>

<p>Havens with the touching property allow the evader to win the game against more powerful pursuers that may simultaneously jump from one set of occupied vertices to another.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="connections-to-treewidth-separators-and-minors">Connections to treewidth, separators, and minors</h2>

<p>Havens may be used to characterize the <a class="uri" href="treewidth" title="wikilink">treewidth</a> of graphs: a graph has a haven of order <em>k</em> if and only if it has treewidth at least . A tree decomposition may be used to describe a winning strategy for the pursuers in the same pursuit-evasion game, so it is also true that a graph has a haven of order <em>k</em> if and only if the evader wins with best play against fewer than <em>k</em> pursuers. In games won by the evader, there is always an optimal strategy in the form described by a haven, and in games won by the pursuer, there is always an optimal strategy in the form described by a tree decomposition.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> For instance, because the  grid has a haven of order 4, but does not have a haven of order 5, it must have treewidth exactly 3. The same min-max theorem can be generalized to <a href="infinite_graph" title="wikilink">infinite graphs</a> of finite treewidth, with a definition of treewidth in which the underlying tree is required to be rayless (that is, having no <a href="end_(graph_theory)" title="wikilink">ends</a>).<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>Havens are also closely related to the existence of <a href="planar_separator_theorem" title="wikilink">separators</a>, small sets <em>X</em> of vertices in an <em>n</em>-vertex graph such that every <em>X</em>-flap has at most 2<em>n</em>/3 vertices. If a graph <em>G</em> does not have a <em>k</em>-vertex separator, then every set <em>X</em> of at most <em>k</em> vertices has a (unique) <em>X</em>-flap with more than 2<em>n</em>/3 vertices. In this case, <em>G</em> has a haven of order , in which <em>β</em>(<em>X</em>) is defined to be this unique large <em>X</em>-flap. That is, every graph has either a small separator or a haven of high order.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>If a graph <em>G</em> has a haven of order <em>k</em>, with <mtpl></mtpl> for some integer <em>h</em>, then <em>G</em> must also have a <a href="complete_graph" title="wikilink">complete graph</a> <em>K</em><sub><em>h</em></sub> as a <a href="Minor_(graph_theory)" title="wikilink">minor</a>. In other words, the <a href="Hadwiger_number" title="wikilink">Hadwiger number</a> of an <em>n</em>-vertex graph with a haven of order <em>k</em> is at least <em>k</em><sup>2/3</sup><em>n</em><sup>−1/3</sup>. As a consequence, the <em>K</em><sub><em>h</em></sub>-minor-free graphs have treewidth less than <em>h</em><sup>3/2</sup><em>n</em><sup>1/2</sup> and separators of size less than <em>h</em><sup>3/2</sup><em>n</em><sup>1/2</sup>. More generally an O(√<em>n</em>) bound on treewidth and separator size holds for any nontrivial family of graphs that can be characterized by <a href="forbidden_minor" title="wikilink">forbidden minors</a>, because for any such family there is a constant <em>h</em> such that the family does not include <em>K</em><sub><em>h</em></sub>.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="in-infinite-graphs">In infinite graphs</h2>

<p>If a graph <em>G</em> contains a ray, a semi-infinite simple path with a starting vertex but no ending vertex, then it has a haven of order <a href="Aleph_number" title="wikilink">ℵ<sub>0</sub></a>: that is, a function <em>β</em> that maps each finite set <em>X</em> of vertices to an <em>X</em>-flap, satisfying the consistency condition for havens. Namely, define <em>β</em>(<em>X</em>) to be the unique <em>X</em>-flap that contains infinitely many vertices of the ray. Thus, in the case of infinite graphs the connection between treewidth and havens breaks down: a single ray, despite itself being a tree, has havens of all finite orders and even more strongly a haven of order ℵ<sub>0</sub>. Two rays of an infinite graph are considered to be equivalent if there is no finite set of vertices that <a href="vertex_separator" title="wikilink">separates</a> infinitely many vertices of one ray from infinitely many vertices of the other ray; this is an <a href="equivalence_relation" title="wikilink">equivalence relation</a>, and its <a href="equivalence_class" title="wikilink">equivalence classes</a> are called <a href="End_(graph_theory)" title="wikilink">ends</a> of the graph.</p>

<p>The ends of any graph are in one-to-one correspondence with its havens of order ℵ<sub>0</sub>. For, every ray determines a haven, and every two equivalent rays determine the same haven.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Conversely, every haven is determined by a ray in this way, as can be shown by the following case analysis:</p>
<ul>
<li>If the haven has the property that the intersection 

<math display="inline" id="Haven_(graph_theory):0">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋂</mo>
     <mi>X</mi>
    </msub>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mi>β</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>∪</mo>
      <mi>X</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <intersect></intersect>
      <ci>X</ci>
     </apply>
     <apply>
      <union></union>
      <apply>
       <times></times>
       <ci>β</ci>
       <ci>X</ci>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\bigcap_{X}\left(\beta(X)\cup X\right)
  </annotation>
 </semantics>
</math>

 ( where the intersection ranges over all finite sets <em>X</em>) is itself an infinite set <em>S</em>, then every finite simple path that ends in a vertex of <em>S</em> can be extended to reach an additional vertex of <em>S</em>, and repeating this extension process produces a ray passing through infinitely many vertices of <em>S</em>. This ray determines the given haven.</li>
<li>On the other hand, if <em>S</em> is finite, then (by working in the subgraph <em>G</em> \ <em>S</em>) it can be assumed to be empty. In this case, for each finite set <em>X</em><sub><em>i</em></sub> of vertices there is a set <em>X</em><sub><em>i</em> + 1</sub> with the property that <em>X</em><sub><em>i</em></sub> is disjoint from 

<math display="inline" id="Haven_(graph_theory):1">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>∪</mo>
   <mrow>
    <mi>β</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>X</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>β</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i+1}\cup\beta(X_{i+1})
  </annotation>
 </semantics>
</math>

. If a robber follows the evasion strategy determined by the haven, and the police follow a strategy given by this sequence of sets, then the path followed by the robber forms a ray that determines the haven.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></li>
</ul>

<p>Thus, every equivalence class of rays defines a unique haven, and every haven is defined by an equivalence class of rays.</p>

<p>For any <a href="cardinal_number" title="wikilink">cardinal number</a> 

<math display="inline" id="Haven_(graph_theory):2">
 <semantics>
  <mrow>
   <mi>κ</mi>
   <mo>≥</mo>
   <msub>
    <mi mathvariant="normal">ℵ</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>κ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-ℵ</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa\geq\aleph_{1}
  </annotation>
 </semantics>
</math>

, an infinite graph <em>G</em> has a haven of order κ if and only if it has a <a href="clique_(graph_theory)" title="wikilink">clique</a> <a href="minor_(graph_theory)" title="wikilink">minor</a> of order κ. That is, for uncountable cardinalities, the largest order of a haven in <em>G</em> is the <a href="Hadwiger_number" title="wikilink">Hadwiger number</a> of <em>G</em>.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Graph_theory_objects" title="wikilink">Category:Graph theory objects</a> <a href="Category:Graph_minor_theory" title="wikilink">Category:Graph minor theory</a> <a href="Category:Game_theory" title="wikilink">Category:Game theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4">.<a href="#fnref4">↩</a></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12">.<a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
</ol>
</section>
</body>
</html>
