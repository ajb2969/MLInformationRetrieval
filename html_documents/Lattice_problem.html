<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="921">Lattice problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Lattice problem</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, <strong>lattice problems</strong> are a class of optimization problems on <a href="Lattice_(group)" title="wikilink">lattices</a>. The conjectured intractability of such problems is central to construction of secure <a href="Lattice-based_cryptography" title="wikilink">lattice-based</a> <a class="uri" href="cryptosystems" title="wikilink">cryptosystems</a>. For applications in such cryptosystems, lattices over vector spaces (often 

<math display="inline" id="Lattice_problem:0">
 <semantics>
  <msup>
   <mi>‚Ñö</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>‚Ñö</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Q}^{n}
  </annotation>
 </semantics>
</math>

) or free modules (often 

<math display="inline" id="Lattice_problem:1">
 <semantics>
  <msup>
   <mi>‚Ñ§</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>‚Ñ§</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}^{n}
  </annotation>
 </semantics>
</math>

) are generally considered.</p>

<p>For all the problems below, assume that we are given (in addition to other more specific inputs) a basis for the vector space <em>V</em> and a <a href="Norm_(mathematics)" title="wikilink">norm</a> <em>N</em>. The norms usually considered are <a href="Norm_(mathematics)#Euclidean_norm" title="wikilink"><em>L</em><sup>2</sup></a>. However, other norms (such as <a href="Norm_(mathematics)#p-norm" title="wikilink"><em>L</em><sup>p</sup></a>) are also considered and show up in a variety of results.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Let 

<math display="inline" id="Lattice_problem:2">
 <semantics>
  <mrow>
   <mi>Œª</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>L</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Œª</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda(L)
  </annotation>
 </semantics>
</math>

 denote the length of the shortest non-zero vector in the lattice <em>L</em>, that is,</p>

<p>

<math display="block" id="Lattice_problem:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>Œª</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>L</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mi>min</mi>
     <mrow>
      <mi>v</mi>
      <mo>‚àà</mo>
      <mrow>
       <mi>L</mi>
       <mo>‚àñ</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mn>ùüé</mn>
        <mo stretchy="false">}</mo>
       </mrow>
      </mrow>
     </mrow>
    </munder>
    <msub>
     <mrow>
      <mo>‚à•</mo>
      <mi>v</mi>
      <mo>‚à•</mo>
     </mrow>
     <mi>N</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Œª</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <apply>
       <in></in>
       <ci>v</ci>
       <apply>
        <setdiff></setdiff>
        <ci>L</ci>
        <set>
         <cn type="integer">0</cn>
        </set>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>v</ci>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda(L)=\min_{v\in L\setminus\{\mathbf{0}\}}\|v\|_{N}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="shortest-vector-problem-svp">Shortest vector problem (SVP)</h2>

<p>In SVP, a <a href="Basis_(linear_algebra)" title="wikilink">basis</a> of a <a href="vector_space" title="wikilink">vector space</a> <em>V</em> and a <a href="Norm_(mathematics)" title="wikilink">norm</a> <em>N</em> (often <a href="Norm_(mathematics)#Euclidean_norm" title="wikilink"><em>L</em><sup>2</sup></a>) are given for a lattice <em>L</em> and one must find the shortest non-zero vector in <em>V</em>, as measured by <em>N</em>, in <em>L</em>. In other words, the algorithm should output a non-zero vector <em>v</em> such that 

<math display="inline" id="Lattice_problem:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>Œª</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>L</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Œª</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N(v)=\lambda(L)
  </annotation>
 </semantics>
</math>

.</p>

<p>In the 

<math display="inline" id="Lattice_problem:5">
 <semantics>
  <mi>Œ≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

-approximation version 

<math display="inline" id="Lattice_problem:6">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mi>Œ≥</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>Œ≥</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SVP_{\gamma}
  </annotation>
 </semantics>
</math>

, one must find a non-zero lattice vector of length at most 

<math display="inline" id="Lattice_problem:7">
 <semantics>
  <mrow>
   <mi>Œ≥</mi>
   <mi>Œª</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>L</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Œ≥</ci>
    <ci>Œª</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma\lambda(L)
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="known-results">Known results</h3>

<p>The exact version of the problem is only known to be <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> for randomized reductions.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>By contrast, the equivalent problem with respect to the <a href="uniform_norm" title="wikilink">uniform norm</a> is known to be <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Approach techniques: <a href="Lenstra‚ÄìLenstra‚ÄìLov√°sz_lattice_basis_reduction_algorithm" title="wikilink">Lenstra‚ÄìLenstra‚ÄìLov√°sz lattice basis reduction algorithm</a> produces a "relatively short vector" in polynomial time, but does not solve the problem. Kannan's HKZ basis reduction algorithm solves the problem in 

<math display="inline" id="Lattice_problem:8">
 <semantics>
  <msup>
   <mi>n</mi>
   <mrow>
    <mfrac>
     <mi>n</mi>
     <mrow>
      <mn>2</mn>
      <mi>e</mi>
     </mrow>
    </mfrac>
    <mo>+</mo>
    <mrow>
     <mi>o</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>e</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{\frac{n}{2e}+o(n)}
  </annotation>
 </semantics>
</math>

 time where n is the dimension. Lastly, Schnorr presented a technique that interpolates between LLL and HKZ called Block Reduction. Block reduction works with HKZ bases and if the number of blocks is chosen to be larger than the dimension, the resulting algorithm Kannan's full HKZ basis reduction.</p>
<h2 id="gapsvp">GapSVP</h2>

<p>The problem 

<math display="inline" id="Lattice_problem:9">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>a</mi>
   <mi>p</mi>
   <mi>S</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mi>Œ≤</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>a</ci>
    <ci>p</ci>
    <ci>S</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>Œ≤</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GapSVP_{\beta}
  </annotation>
 </semantics>
</math>

 consists of differentiating between the instances of SVP in which the answer is at most 1 or larger than 

<math display="inline" id="Lattice_problem:10">
 <semantics>
  <mi>Œ≤</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ≤</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Lattice_problem:11">
 <semantics>
  <mi>Œ≤</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ≤</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 can be a fixed function of 

<math display="inline" id="Lattice_problem:12">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, the number of vectors. Given a basis for the lattice, the algorithm must decide whether 

<math display="inline" id="Lattice_problem:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>Œª</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>L</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚â§</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>Œª</ci>
     <ci>L</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda(L)\leq 1
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Lattice_problem:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>Œª</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>L</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mi>Œ≤</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>Œª</ci>
     <ci>L</ci>
    </apply>
    <ci>Œ≤</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda(L)>\beta
  </annotation>
 </semantics>
</math>

. Like other <a href="promise_problem" title="wikilink">promise problems</a>, the algorithm is allowed to err on all other cases.</p>

<p>Yet another version of the problem is 

<math display="inline" id="Lattice_problem:15">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>a</mi>
   <mi>p</mi>
   <mi>S</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mrow>
     <mi>Œ∂</mi>
     <mo>,</mo>
     <mi>Œ≥</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>a</ci>
    <ci>p</ci>
    <ci>S</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <list>
      <ci>Œ∂</ci>
      <ci>Œ≥</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GapSVP_{\zeta,\gamma}
  </annotation>
 </semantics>
</math>

 for some functions 

<math display="inline" id="Lattice_problem:16">
 <semantics>
  <mrow>
   <mi>Œ∂</mi>
   <mo>,</mo>
   <mi>Œ≥</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>Œ∂</ci>
    <ci>Œ≥</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \zeta,\gamma
  </annotation>
 </semantics>
</math>

. The input to the algorithm is a basis 

<math display="inline" id="Lattice_problem:17">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 and a number 

<math display="inline" id="Lattice_problem:18">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

. It is assured that all the vectors in the <a href="Gram‚ÄìSchmidt_orthogonalization" title="wikilink">Gram‚ÄìSchmidt orthogonalization</a> are of length at least 1, and that 

<math display="inline" id="Lattice_problem:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>Œª</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>B</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚â§</mo>
   <mrow>
    <mi>Œ∂</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>Œª</ci>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>Œ∂</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda(L(B))\leq\zeta(n)
  </annotation>
 </semantics>
</math>

 and that 

<math display="inline" id="Lattice_problem:20">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>‚â§</mo>
   <mi>d</mi>
   <mo>‚â§</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>Œ∂</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>/</mo>
     <mi>Œ≥</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>d</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>Œ∂</ci>
        <ci>n</ci>
       </apply>
       <ci>Œ≥</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq d\leq\zeta(n)/\gamma(n)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Lattice_problem:21">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the dimension. The algorithm must accept if 

<math display="inline" id="Lattice_problem:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>Œª</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>B</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚â§</mo>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>Œª</ci>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda(L(B))\leq d
  </annotation>
 </semantics>
</math>

, and reject if 

<math display="inline" id="Lattice_problem:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Œª</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>L</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>B</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>‚â•</mo>
    <mrow>
     <mi>Œ≥</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <geq></geq>
     <apply>
      <times></times>
      <ci>Œª</ci>
      <apply>
       <times></times>
       <ci>L</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>Œ≥</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda(L(B))\geq\gamma(n).d
  </annotation>
 </semantics>
</math>

. For large 

<math display="inline" id="Lattice_problem:24">
 <semantics>
  <mi>Œ∂</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ∂</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \zeta
  </annotation>
 </semantics>
</math>

 (

<math display="inline" id="Lattice_problem:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>Œ∂</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>n</mi>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>Œ∂</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \zeta(n)>2^{n/2}
  </annotation>
 </semantics>
</math>

), the problem is equivalent to 

<math display="inline" id="Lattice_problem:26">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>a</mi>
   <mi>p</mi>
   <mi>S</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mi>Œ≥</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>a</ci>
    <ci>p</ci>
    <ci>S</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>Œ≥</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GapSVP_{\gamma}
  </annotation>
 </semantics>
</math>

 because<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> a preprocessing done using the <a href="LLL_algorithm" title="wikilink">LLL algorithm</a> makes the second condition (and hence, 

<math display="inline" id="Lattice_problem:27">
 <semantics>
  <mi>Œ∂</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ∂</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \zeta
  </annotation>
 </semantics>
</math>

) redundant.</p>
<h2 id="closest-vector-problem-cvp">Closest vector problem (CVP)</h2>

<p>Image:Svp09.png|The SVP by example Image:Cvp3.png|The CVP by example</p>

<p>In CVP, a basis of a vector space <em>V</em> and a <a href="Metric_(mathematics)" title="wikilink">metric</a> <em>M</em> (often <a href="Euclidean_distance" title="wikilink"><em>L</em><sup>2</sup></a>) are given for a lattice <em>L</em>, as well as a vector <em>v</em> in <em>V</em> but not necessarily in <em>L</em>. It is desired to find the vector in <em>L</em> closest to <em>v</em> (as measured by <em>M</em>). In the 

<math display="inline" id="Lattice_problem:28">
 <semantics>
  <mi>Œ≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

-approximation version 

<math display="inline" id="Lattice_problem:29">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mi>Œ≥</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>Œ≥</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   CVP_{\gamma}
  </annotation>
 </semantics>
</math>

, one must find a lattice vector at distance at most 

<math display="inline" id="Lattice_problem:30">
 <semantics>
  <mi>Œ≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="relationship-with-svp">Relationship with SVP</h3>

<p>The closest vector problem is a generalization of the shortest vector problem. It is easy to show that given an oracle for 

<math display="inline" id="Lattice_problem:31">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mi>Œ≥</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>Œ≥</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   CVP_{\gamma}
  </annotation>
 </semantics>
</math>

 (defined below), one can solve 

<math display="inline" id="Lattice_problem:32">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mi>Œ≥</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>Œ≥</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SVP_{\gamma}
  </annotation>
 </semantics>
</math>

 by making some queries to the oracle.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The naive method to find the shortest vector by calling the 

<math display="inline" id="Lattice_problem:33">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mi>Œ≥</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>Œ≥</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   CVP_{\gamma}
  </annotation>
 </semantics>
</math>

 oracle to find the closest vector to 0 does not work because 0 is itself a lattice vector and the algorithm could potentially output 0.</p>

<p>The reduction from 

<math display="inline" id="Lattice_problem:34">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mi>Œ≥</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>Œ≥</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SVP_{\gamma}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Lattice_problem:35">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mi>Œ≥</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>Œ≥</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   CVP_{\gamma}
  </annotation>
 </semantics>
</math>

 is as follows: Suppose that the input to the 

<math display="inline" id="Lattice_problem:36">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mi>Œ≥</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>Œ≥</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SVP_{\gamma}
  </annotation>
 </semantics>
</math>

 problem is the basis for lattice 

<math display="inline" id="Lattice_problem:37">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>b</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>b</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msub>
     <mi>b</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>B</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>n</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B=[b_{1},b_{2},\ldots,b_{n}]
  </annotation>
 </semantics>
</math>

. Consider the basis 

<math display="inline" id="Lattice_problem:38">
 <semantics>
  <mrow>
   <msup>
    <mi>B</mi>
    <mi>i</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>b</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <mrow>
     <mn>2</mn>
     <msub>
      <mi>b</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msub>
     <mi>b</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <ci>i</ci>
    </apply>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>n</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{i}=[b_{1},\ldots,2b_{i},\ldots,b_{n}]
  </annotation>
 </semantics>
</math>

 and let 

<math display="inline" id="Lattice_problem:39">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 be the vector returned by 

<math display="inline" id="Lattice_problem:40">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mi>Œ≥</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>B</mi>
     <mi>i</mi>
    </msup>
    <mo>,</mo>
    <msub>
     <mi>b</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>Œ≥</ci>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>i</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   CVP_{\gamma}(B^{i},b_{i})
  </annotation>
 </semantics>
</math>

. The claim is that the shortest vector in the set 

<math display="inline" id="Lattice_problem:41">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>b</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x_{i}-b_{i}\}
  </annotation>
 </semantics>
</math>

 is the shortest vector in the given lattice.</p>
<h3 id="known-results-1">Known results</h3>

<p>Goldreich et al. showed that any hardness of SVP implies the same hardness for CVP.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Using <a href="Probabilistically_checkable_proof_(complexity)" title="wikilink">PCP</a> tools, <a href="Sanjeev_Arora" title="wikilink">Arora</a> et al. showed that CVP is hard to approximate within factor 

<math display="inline" id="Lattice_problem:42">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <msup>
     <mi>log</mi>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>œµ</mi>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <log></log>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>œµ</ci>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{\log^{1-\epsilon}(n)}
  </annotation>
 </semantics>
</math>

 unless 

<math display="inline" id="Lattice_problem:43">
 <semantics>
  <mrow>
   <mo>NP</mo>
   <mo>‚äÜ</mo>
   <mrow>
    <mo>DTIME</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mn>2</mn>
      <mrow>
       <mi>p</mi>
       <mi>o</mi>
       <mi>l</mi>
       <mi>y</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>log</mi>
         <mi>n</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>NP</ci>
    <apply>
     <ci>DTIME</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>o</ci>
       <ci>l</ci>
       <ci>y</ci>
       <apply>
        <log></log>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{NP}\subseteq\operatorname{DTIME}(2^{poly(\log n)})
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Dinur et al. strengthened this by giving a NP-hardness result with 

<math display="inline" id="Lattice_problem:44">
 <semantics>
  <mrow>
   <mi>œµ</mi>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>œµ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <log></log>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon=(\log\log n)^{c}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Lattice_problem:45">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo><</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>c</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c<1/2
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h3 id="sphere-decoding">Sphere decoding</h3>

<p>The algorithm for CVP, especially the Fincke and Pohst variant,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> have been used for data detection in multiple-input multiple-output (<a class="uri" href="MIMO" title="wikilink">MIMO</a>) wireless communication systems (for coded and uncoded signals).<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> In this context it is called <em>sphere decoding</em> due to the radius used internal to many CVP solutions.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>It has been applied in the field of the integer ambiguity resolution of carrier-phase GNSS (GPS).<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> It is called <em>LAMBDA method</em> in that field.</p>
<h2 id="gapcvp">GapCVP</h2>

<p>This problem is similar to the GapSVP problem. For 

<math display="inline" id="Lattice_problem:46">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>a</mi>
   <mi>p</mi>
   <mi>C</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mi>Œ≤</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>a</ci>
    <ci>p</ci>
    <ci>C</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>Œ≤</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GapCVP_{\beta}
  </annotation>
 </semantics>
</math>

, the input consists of a lattice basis and a vector 

<math display="inline" id="Lattice_problem:47">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 and the algorithm must answer whether</p>
<ul>
<li>there is a lattice vector such that the distance between it and 

<math display="inline" id="Lattice_problem:48">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 is at most 1.</li>
<li>every lattice vector is at a distance greater than 

<math display="inline" id="Lattice_problem:49">
 <semantics>
  <mi>Œ≤</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ≤</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 away from 

<math display="inline" id="Lattice_problem:50">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<h3 id="known-results-2">Known results</h3>

<p>The problem is trivially contained in <a href="NP_(complexity)" title="wikilink">NP</a> for any approximation factor.</p>

<p><a href="Claus_P._Schnorr" title="wikilink">Schnorr</a>, in 1987, showed that deterministic polynomial time algorithms can solve the problem for 

<math display="inline" id="Lattice_problem:51">
 <semantics>
  <mrow>
   <mi>Œ≤</mi>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>n</mi>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>log</mi>
           <mrow>
            <mi>log</mi>
            <mi>n</mi>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mrow>
       <mo>/</mo>
       <mrow>
        <mi>log</mi>
        <mi>n</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Œ≤</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>n</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <log></log>
          <apply>
           <log></log>
           <ci>n</ci>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <log></log>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta=2^{O(n(\log\log n)^{2}/\log n)}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> Ajtai et al. showed that probabilistic algorithms can achieve a slightly better approximation factor of 

<math display="inline" id="Lattice_problem:52">
 <semantics>
  <mrow>
   <mi>Œ≤</mi>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mrow>
        <mi>log</mi>
        <mrow>
         <mi>log</mi>
         <mrow>
          <mi>n</mi>
          <mo>/</mo>
          <mrow>
           <mi>log</mi>
           <mi>n</mi>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Œ≤</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <log></log>
        <apply>
         <log></log>
         <apply>
          <divide></divide>
          <ci>n</ci>
          <apply>
           <log></log>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta=2^{O(n\log\log n/\log n)}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>In 1993, Banaszczyk showed that 

<math display="inline" id="Lattice_problem:53">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mi>a</mi>
   <mi>p</mi>
   <mi>C</mi>
   <mi>V</mi>
   <msub>
    <mi>P</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <ci>a</ci>
    <ci>p</ci>
    <ci>C</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GapCVP_{n}
  </annotation>
 </semantics>
</math>

 is in 

<math display="inline" id="Lattice_problem:54">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <mi>P</mi>
   </mrow>
   <mo>‚à©</mo>
   <mrow>
    <mi>c</mi>
    <mi>o</mi>
    <mi>N</mi>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <intersect></intersect>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>P</ci>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>o</ci>
     <ci>N</ci>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   NP\cap coNP
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> In 2000, Goldreich and Goldwasser showed that 

<math display="inline" id="Lattice_problem:55">
 <semantics>
  <mrow>
   <mi>Œ≤</mi>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <mi>n</mi>
     <mo>/</mo>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Œ≤</ci>
    <apply>
     <root></root>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta=\sqrt{n/\log n}
  </annotation>
 </semantics>
</math>

 puts the problem in both NP and <a class="uri" href="coAM" title="wikilink">coAM</a>.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> In 2005, Aharonov and Regev showed that for some constant 

<math display="inline" id="Lattice_problem:56">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

, the problem with 

<math display="inline" id="Lattice_problem:57">
 <semantics>
  <mrow>
   <mi>Œ≤</mi>
   <mo>=</mo>
   <mrow>
    <mi>c</mi>
    <msqrt>
     <mi>n</mi>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Œ≤</ci>
    <apply>
     <times></times>
     <ci>c</ci>
     <apply>
      <root></root>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta=c\sqrt{n}
  </annotation>
 </semantics>
</math>

 is in 

<math display="inline" id="Lattice_problem:58">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <mi>P</mi>
   </mrow>
   <mo>‚à©</mo>
   <mrow>
    <mi>c</mi>
    <mi>o</mi>
    <mi>N</mi>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <intersect></intersect>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>P</ci>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>o</ci>
     <ci>N</ci>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   NP\cap coNP
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>For lower bounds, Dinur et al. showed in 1998 that the problem is NP-hard for 

<math display="inline" id="Lattice_problem:59">
 <semantics>
  <mrow>
   <mi>Œ≤</mi>
   <mo>=</mo>
   <msup>
    <mi>n</mi>
    <mrow>
     <mi>o</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mrow>
        <mi>log</mi>
        <mrow>
         <mi>log</mi>
         <mi>n</mi>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Œ≤</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <log></log>
        <apply>
         <log></log>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta=n^{o(1/\log{\log{n}})}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h2 id="shortest-independent-vectors-problem-sivp">Shortest independent vectors problem (SIVP)</h2>

<p>Given a lattice L of dimension n, the algorithm must output n <a href="linearly_independent" title="wikilink">linearly independent</a> 

<math display="inline" id="Lattice_problem:60">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">‚Ä¶</mi>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-‚Ä¶</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{1},v_{2},\ldots,v_{n}
  </annotation>
 </semantics>
</math>

 so that 

<math display="inline" id="Lattice_problem:61">
 <semantics>
  <mrow>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mo>‚à•</mo>
     <msub>
      <mi>v</mi>
      <mi>i</mi>
     </msub>
     <mo>‚à•</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <msub>
     <mi>max</mi>
     <mi>B</mi>
    </msub>
    <mrow>
     <mo>‚à•</mo>
     <msub>
      <mi>b</mi>
      <mi>i</mi>
     </msub>
     <mo>‚à•</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <max></max>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <ci>B</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max\|v_{i}\|<\max_{B}\|b_{i}\|
  </annotation>
 </semantics>
</math>

 where the right hand side considers all basis 

<math display="inline" id="Lattice_problem:62">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>b</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msub>
     <mi>b</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>B</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B=\{b_{1},\ldots,b_{n}\}
  </annotation>
 </semantics>
</math>

 of the lattice.</p>

<p>In the 

<math display="inline" id="Lattice_problem:63">
 <semantics>
  <mi>Œ≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

-approximate version, given a lattice L with dimension n, find n <a href="linearly_independent" title="wikilink">linearly independent</a> vectors 

<math display="inline" id="Lattice_problem:64">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">‚Ä¶</mi>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-‚Ä¶</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{1},v_{2},\ldots,v_{n}
  </annotation>
 </semantics>
</math>

 of length max ||

<math display="inline" id="Lattice_problem:65">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

|| ‚â§ 

<math display="inline" id="Lattice_problem:66">
 <semantics>
  <mrow>
   <mi>Œ≥</mi>
   <msub>
    <mi>Œª</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>L</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Œ≥</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Œª</ci>
     <ci>n</ci>
    </apply>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma\lambda_{n}(L)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Lattice_problem:67">
 <semantics>
  <mrow>
   <msub>
    <mi>Œª</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>L</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Œª</ci>
     <ci>n</ci>
    </apply>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{n}(L)
  </annotation>
 </semantics>
</math>

 is the 

<math display="inline" id="Lattice_problem:68">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

'th successive minimum of 

<math display="inline" id="Lattice_problem:69">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="bounded-distance-decoding">Bounded distance decoding</h2>

<p>This problem is similar to CVP. Given a vector such that its distance from the lattice is at most 

<math display="inline" id="Lattice_problem:70">
 <semantics>
  <mrow>
   <mrow>
    <mi>Œª</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>L</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>Œª</ci>
     <ci>L</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda(L)/2
  </annotation>
 </semantics>
</math>

, the algorithm must output the closest lattice vector to it.</p>
<h2 id="covering-radius-problem">Covering radius problem</h2>

<p>Given a basis for the lattice, the algorithm must find the largest distance (or in some versions, its approximation) from any vector to the lattice.</p>
<h2 id="shortest-basis-problem">Shortest basis problem</h2>

<p>Many problems become easier if the input basis consists of short vectors. An algorithm that solves the Shortest Basis Problem (SBP) must, given a lattice basis

<math display="inline" id="Lattice_problem:71">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

, output an equivalent basis 

<math display="inline" id="Lattice_problem:72">
 <semantics>
  <msup>
   <mi>B</mi>
   <mo>‚Ä≤</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>B</ci>
    <ci>normal-‚Ä≤</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{\prime}
  </annotation>
 </semantics>
</math>

 such that the length of the longest vector in 

<math display="inline" id="Lattice_problem:73">
 <semantics>
  <msup>
   <mi>B</mi>
   <mo>‚Ä≤</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>B</ci>
    <ci>normal-‚Ä≤</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{\prime}
  </annotation>
 </semantics>
</math>

 is as short as possible.</p>

<p>The approximation version 

<math display="inline" id="Lattice_problem:74">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mi>B</mi>
   <msub>
    <mi>P</mi>
    <mi>Œ≥</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>B</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>Œ≥</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   SBP_{\gamma}
  </annotation>
 </semantics>
</math>

 problem consist of finding a basis whose longest vector is at most 

<math display="inline" id="Lattice_problem:75">
 <semantics>
  <mi>Œ≥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ≥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

 times longer than the longest vector in the shortest basis.</p>
<h2 id="use-in-cryptography">Use in cryptography</h2>

<p><a href="Average_case" title="wikilink">Average case</a> hardness of problems forms a basis for proofs-of-security for most cryptographic schemes. However, experimental evidence suggests that most NP-hard problems lack this property: they are probably only worst case hard. Many lattice problems have been conjectured or proven to be average-case hard, making them an attractive class of problems to base cryptographic schemes on. Moreover, worst-case hardness of some lattice problems have been used to create secure cryptographic schemes. The use of worst-case hardness in such schemes makes them among the very few schemes that are very likely secure even against <a href="quantum_computers" title="wikilink">quantum computers</a>.</p>

<p>The above lattice problems are easy to solve if the algorithm is provided with a "good" basis. <a href="Lattice_reduction" title="wikilink">Lattice reduction</a> algorithms aim, given a basis for a lattice, to output a new basis consisting of relatively short, nearly orthogonal vectors. The <a href="Lenstra‚ÄìLenstra‚ÄìLov√°sz_lattice_basis_reduction_algorithm" title="wikilink">Lenstra‚ÄìLenstra‚ÄìLov√°sz lattice basis reduction algorithm</a> (LLL) was an early efficient algorithm for this problem which could output an almost reduced lattice basis in polynomial time.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> This algorithm and its further refinements were used to break several cryptographic schemes, establishing its status as a very important tool in cryptanalysis. The success of LLL on experimental data led to a belief that lattice reduction might be an easy problem in practice. However, this belief was challenged when in the late 1990s, several new results on the hardness of lattice problems were obtained, starting with the result of <a href="Mikl√≥s_Ajtai" title="wikilink">Ajtai</a>.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p>In his seminal papers, Ajtai showed that the SVP problem was NP-hard and discovered some connections between the worst-case complexity and <a href="average-case_complexity" title="wikilink">average-case complexity</a> of some lattice problems.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a><a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> Building on these results, Ajtai and <a href="Cynthia_Dwork" title="wikilink">Dwork</a> created a <a href="public-key_cryptosystem" title="wikilink">public-key cryptosystem</a> whose security could be proven using only the worst case hardness of a certain version of SVP,<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> thus making it the first result to have used worst-case hardness to create secure systems.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Learning_with_errors" title="wikilink">Learning with errors</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Computational_hardness_assumptions" title="wikilink">Category:Computational hardness assumptions</a> <a href="Category:Lattice-based_cryptography" title="wikilink">Category:Lattice-based cryptography</a> <a href="Category:Mathematical_problems" title="wikilink">Category:Mathematical problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">‚Ü©</a></li>
<li id="fn2"></li>
<li id="fn3"><mtpl></mtpl><a href="#fnref3">‚Ü©</a></li>
<li id="fn4"><a href="#fnref4">‚Ü©</a></li>
<li id="fn5"><a href="#fnref5">‚Ü©</a></li>
<li id="fn6"><a href="#fnref6">‚Ü©</a></li>
<li id="fn7"><a href="#fnref7">‚Ü©</a></li>
<li id="fn8"><a href="#fnref8">‚Ü©</a></li>
<li id="fn9"><a href="#fnref9">‚Ü©</a></li>
<li id="fn10"><a href="#fnref10">‚Ü©</a></li>
<li id="fn11"><a href="#fnref11">‚Ü©</a></li>
<li id="fn12"><a href="#fnref12">‚Ü©</a></li>
<li id="fn13"><a href="#fnref13">‚Ü©</a></li>
<li id="fn14"><a href="#fnref14">‚Ü©</a></li>
<li id="fn15"><a href="#fnref15">‚Ü©</a></li>
<li id="fn16"><a href="#fnref16">‚Ü©</a></li>
<li id="fn17"><a href="#fnref17">‚Ü©</a></li>
<li id="fn18"><a href="#fnref18">‚Ü©</a></li>
<li id="fn19"><mtpl></mtpl><a href="#fnref19">‚Ü©</a></li>
<li id="fn20"><a href="#fnref20">‚Ü©</a></li>
<li id="fn21"><a href="#fnref21">‚Ü©</a></li>
<li id="fn22"><a href="#fnref22">‚Ü©</a></li>
<li id="fn23"></li>
<li id="fn24"><mtpl></mtpl><a href="#fnref24">‚Ü©</a></li>
<li id="fn25"><a href="#fnref25">‚Ü©</a></li>
<li id="fn26"><a href="#fnref26">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
