<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="834">Deductive lambda calculus</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Deductive lambda calculus</h1>
<hr/>

<p><strong>Deductive lambda calculus</strong> considers what happens when <a href="Lambda_calculus#Definition" title="wikilink">lambda terms</a> are regarded as mathematical expressions. One interpretation of the <a href="Lambda_calculus" title="wikilink">untyped lambda calculus</a> is as a programming language where evaluation proceeds by performing reductions on an expression until it is in normal form. In this interpretation, if the expression never reduces to normal form then the program never terminates, and the value is undefined. Considered as a mathematical <a href="deductive_system" title="wikilink">deductive system</a>, each reduction would not alter the value of the expression. The expression would equal the reduction of the expression.</p>
<h2 id="history">History</h2>

<p><a href="Alonzo_Church" title="wikilink">Alonzo Church</a> invented the lambda calculus in the 1930s, originally to provide a new and simpler basis for mathematics.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> However soon after inventing it major logic problems were identified with the definition of the lambda abstraction.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p><a href="Haskell_Curry" title="wikilink">Haskell Curry</a> studied of illative (deductive) <a href="combinatory_logic" title="wikilink">combinatory logic</a> in 1941.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Combinatory logic is closely related to lambda calculus.</p>

<p>The <a href="Kleene–Rosser_paradox" title="wikilink">Kleene–Rosser paradox</a> is an implementation of <a href="Richard's_paradox" title="wikilink">Richard's paradox</a> in <a href="Combinatory_logic" title="wikilink">Combinatory logic</a>. Combinatory Logic is closely related to Lambda Calculus. <a href="Haskell_Curry" title="wikilink">Haskell Curry</a> found that the key step in this paradox could be used to implement the simpler <a href="Curry's_Paradox" title="wikilink">Curry's Paradox</a>. The existence of this paradox meant that the Combinatory Logic, and lambda calculus, could not be both consistent and complete as a <a href="deductive_system" title="wikilink">deductive system</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>Later the Lambda Calculus was resurrected as a definition of a programming language.</p>
<h2 id="introduction">Introduction</h2>

<p>Lambda calculus is the model and inspiration for the development of <a href="functional_programming" title="wikilink">functional programming</a> languages. These languages implement the lambda abstraction, and use it in conjunction with application of functions, and types.</p>

<p>The use of lambda abstractions, which are then embedded into other mathematical systems, and used as a deductive system, leads to a number of problems, such as <a href="Curry's_paradox" title="wikilink">Curry's paradox</a>. The problems are related to the definition of the lambda abstraction and the definition and use of functions as the basic type in <a href="lambda_calculus" title="wikilink">lambda calculus</a>. This article describes these problems and how they arise.</p>

<p>This is not a criticism of pure lambda calculus, and lambda calculus as a pure system is not the primary topic here. The problems arise with the interaction of lambda calculus with other mathematical systems. Being aware of the problems allows them to be avoided in some cases.</p>
<h2 id="terminology">Terminology</h2>

<p>For this discussion, the lambda abstraction is added as an extra operator in mathematics. The usual domains, such as <a href="Boolean_algebra" title="wikilink">Boolean</a> and <a href="Real_number" title="wikilink">real</a> will be available. Mathematical equality will be applied to these domains. The purpose is to see what problems arise from this definition.</p>

<p>Function application will be represented using the lambda calculus syntax. So multiplication will be represented by a dot. Also, for some examples, the <a href="let_expression" title="wikilink">let expression</a> will be used.</p>

<p>The following table summarizes;</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Name</p></th>
<th style="text-align: left;">
<p>Notation</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Lambda abstraction.</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Deductive_lambda_calculus:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>v</mi>
   </mrow>
   <mo>.</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>v</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda v.y
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Application of the function <em>f</em> to <em>x</em></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Deductive_lambda_calculus:1">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ x
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Multiplication of <em>a</em> by <em>b</em></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Deductive_lambda_calculus:2">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>⋅</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\cdot b
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Let <em>x</em> in <em>y</em></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Deductive_lambda_calculus:3">
 <semantics>
  <mrow>
   <mrow>
    <mo>let</mo>
    <mi>x</mi>
   </mrow>
   <mrow>
    <mo>in</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>let</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>in</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{let}x\operatorname{in}y
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Mathematical equality</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Deductive_lambda_calculus:4">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=n
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Beta reducible equality</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Deductive_lambda_calculus:5">
 <semantics>
  <mrow>
   <mi>m</mi>
   <msub>
    <mo>=</mo>
    <mi>β</mi>
   </msub>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <eq></eq>
     <ci>β</ci>
    </apply>
    <ci>m</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=_{\beta}n
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
<h2 id="interpretation-of-lambda-calculus-as-mathematics">Interpretation of lambda calculus as mathematics</h2>

<p>In the <a href="Mathematics" title="wikilink">mathematical</a> interpretation, lambda terms represent values. <a href="Beta_reduction#Reduction" title="wikilink">Eta and beta reductions</a> are deductive steps that do not alter the values of expressions.</p>

<p>

<math display="block" id="Deductive_lambda_calculus:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>eta</mi>
     <mo>-</mo>
     <mi>reduct</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <minus></minus>
      <ci>eta</ci>
      <ci>reduct</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{eta-reduct}[X]=X
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>beta</mi>
     <mo>-</mo>
     <mi>reduct</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <minus></minus>
      <ci>beta</ci>
      <ci>reduct</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{beta-reduct}[X]=X
  </annotation>
 </semantics>
</math>

</p>
<h3 id="eta-reduction-as-mathematics">Eta reduction as mathematics</h3>

<p>An eta-reduct is defined by,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:8">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <mo>FV</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>eta</mi>
    <mo>-</mo>
    <mi>reduct</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <notin></notin>
    <ci>FV</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <apply>
     <minus></minus>
     <ci>eta</ci>
     <ci>reduct</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">f</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\in\operatorname{FV}(f)\to\operatorname{eta-reduct}[\lambda x.(f\ x)]=f
  </annotation>
 </semantics>
</math>

</p>

<p>In the mathematical interpretation,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>eta</mi>
     <mo>-</mo>
     <mi>reduct</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <minus></minus>
      <ci>eta</ci>
      <ci>reduct</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{eta-reduct}[X]=X
  </annotation>
 </semantics>
</math>

</p>

<p>Taking f to be a variable then,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>f</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.(f\ x)=f
  </annotation>
 </semantics>
</math>

 or by letting 

<math display="inline" id="Deductive_lambda_calculus:11">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ x=y
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:12">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mi>x</mi>
   <mo>=</mo>
   <mi>y</mi>
   <mo>⇔</mo>
   <mi>f</mi>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">y</csymbol>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ x=y\iff f=\lambda x.y
  </annotation>
 </semantics>
</math>

</p>

<p>This definition defines 

<math display="inline" id="Deductive_lambda_calculus:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.y
  </annotation>
 </semantics>
</math>

 to be the solution for <em>f</em> in the equation,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:14">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ x=y
  </annotation>
 </semantics>
</math>

</p>
<h3 id="beta-reduction-as-mathematics">Beta reduction as mathematics</h3>

<p>A beta reduct is,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>beta</mi>
    <mo>-</mo>
    <mi>reduct</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mi>b</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>z</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>b</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>z</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <minus></minus>
     <ci>beta</ci>
     <ci>reduct</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">b</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{beta-reduct}[(\lambda x.b)\ z]=b[x:=z]
  </annotation>
 </semantics>
</math>

 and as,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>beta</mi>
     <mo>-</mo>
     <mi>reduct</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <minus></minus>
      <ci>beta</ci>
      <ci>reduct</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{beta-reduct}[X]=X
  </annotation>
 </semantics>
</math>

 then,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:17">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>b</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mi>b</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>z</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">z</csymbol>
    <eq></eq>
    <csymbol cd="unknown">b</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.b)\ z=b[x:=z]
  </annotation>
 </semantics>
</math>

</p>

<p>This rule is implied by the <a href="Universal_instantiation" title="wikilink">instantiation</a> of <a href="Universal_quantification" title="wikilink">quantified</a> variables. If,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:18">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>x</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
    </mrow>
    <mo>=</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>x</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x:f\ x=y
  </annotation>
 </semantics>
</math>

</p>

<p>then 

<math display="inline" id="Deductive_lambda_calculus:19">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ z
  </annotation>
 </semantics>
</math>

 is the expression y with the quantified variable x instantiated as z.</p>

<p>

<math display="block" id="Deductive_lambda_calculus:20">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mi>z</mi>
   <mo>=</mo>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>z</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="unknown">z</csymbol>
    <eq></eq>
    <csymbol cd="unknown">y</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ z=y[x:=z]
  </annotation>
 </semantics>
</math>

 so,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:21">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>y</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>z</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">z</csymbol>
    <eq></eq>
    <csymbol cd="unknown">y</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.y)\ z=y[x:=z]
  </annotation>
 </semantics>
</math>

</p>

<p>As beta reduction is implied from eta reduction, there is no contradiction between the two definitions.</p>
<h2 id="logical-inconsistency">Logical inconsistency</h2>

<p>From eta reduction,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:22">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mi>x</mi>
   <mo>=</mo>
   <mi>y</mi>
   <mo>⇔</mo>
   <mi>f</mi>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">y</csymbol>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ x=y\iff f=\lambda x.y
  </annotation>
 </semantics>
</math>

</p>

<p>This rule may be interpreted as defining 

<math display="inline" id="Deductive_lambda_calculus:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.y
  </annotation>
 </semantics>
</math>

 to be the solution of the equation 

<math display="inline" id="Deductive_lambda_calculus:24">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ x=y
  </annotation>
 </semantics>
</math>

. In defining the solution to the equation in terms of <em>x</em> and <em>y</em> the definition implicitly assumes that there is one and only function <em>f</em> that satisfies the equation. However, for some equations there may be none or multiple solutions. The definition may be compared with defining 

<math display="inline" id="Deductive_lambda_calculus:25">
 <semantics>
  <msqrt>
   <mi></mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{}
  </annotation>
 </semantics>
</math>

 by,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mo>=</mo>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <msqrt>
     <mi>y</mi>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <apply>
     <eq></eq>
     <ci>y</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>x</ci>
     <apply>
      <root></root>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=x^{2}\iff x=\sqrt{y}
  </annotation>
 </semantics>
</math>

</p>

<p>This is not a valid definition as the equation 

<math display="inline" id="Deductive_lambda_calculus:27">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=x^{2}
  </annotation>
 </semantics>
</math>

 has two solutions. The proper definition is,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:28">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>=</mo>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mi mathvariant="italic">and</mi>
    <mi>x</mi>
    <mo>≥</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇔</mo>
   <mi>x</mi>
   <mo>=</mo>
   <msqrt>
    <mi>y</mi>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <geq></geq>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <apply>
     <root></root>
     <ci>y</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (y=x^{2}\and x>=0)\iff x=\sqrt{y}
  </annotation>
 </semantics>
</math>

</p>

<p>An expression in mathematics may represent multiple values if it has <a href="Free_variables_and_bound_variables" title="wikilink">free variables</a>. The variables may be <a href="Existential_quantification" title="wikilink">existentially quantified</a>. Existential quantification turns an equation into a <a href="Logical_disjunction" title="wikilink">disjunction</a> of equations, with each variable populated with a single value in each equation.</p>

<p>The solution set for 

<math display="inline" id="Deductive_lambda_calculus:29">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Deductive_lambda_calculus:30">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ x=y
  </annotation>
 </semantics>
</math>

 is,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:31">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
    </mrow>
    <mo>=</mo>
    <mi>y</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <ci>f</ci>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{f:f\ x=y\}
  </annotation>
 </semantics>
</math>

</p>

<p>For the definition 

<math display="inline" id="Deductive_lambda_calculus:32">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mi>x</mi>
   <mo>=</mo>
   <mi>y</mi>
   <mo>⇔</mo>
   <mi>f</mi>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">y</csymbol>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f\ x=y\iff f=\lambda x.y)
  </annotation>
 </semantics>
</math>

 to be valid there must be only one solution in this solution set.</p>

<p>

<math display="block" id="Deductive_lambda_calculus:33">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>f</mi>
    <mo>:</mo>
    <mi>f</mi>
    <mo>=</mo>
    <mi>y</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mo>=</mo>
   <mn>1</mn>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
    <mo>=</mo>
    <mpadded width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mi>x</mi>
    <mo>⇔</mo>
    <mi>f</mi>
    <mo>=</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">f</csymbol>
     <eq></eq>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-|</ci>
    <eq></eq>
    <cn type="integer">1</cn>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">f</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">iff</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <eq></eq>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\{f:f=y\}|=1\equiv(f\ x=y\ x\iff f=\lambda x.y\ x)
  </annotation>
 </semantics>
</math>

</p>

<p>The mathematical (or extensional) definition of function equality is that two functions are equal if they perform the same mapping;</p>

<p>

<math display="block" id="Deductive_lambda_calculus:34">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <mi>g</mi>
   <mo>⇔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
    <mo>=</mo>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <eq></eq>
    <csymbol cd="unknown">g</csymbol>
    <csymbol cd="latexml">iff</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">g</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=g\iff(\forall xf\ x=g\ x)
  </annotation>
 </semantics>
</math>

</p>

<p>So,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:35">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>f</mi>
    <mo>:</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
    <mo>=</mo>
    <mpadded width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mi>x</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mo>=</mo>
   <mn>1</mn>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
    <mo>=</mo>
    <mpadded width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mi>x</mi>
    <mo>⇔</mo>
    <mi>f</mi>
    <mo>=</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-|</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-|</ci>
    <eq></eq>
    <cn type="integer">1</cn>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">f</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">iff</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <eq></eq>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\{f:\forall xf\ x=y\ x\}|=1\equiv(f\ x=y\ x\iff f=\lambda x.y\ x)
  </annotation>
 </semantics>
</math>

</p>

<p>The left condition is,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:36">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>f</mi>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mo>∀</mo>
       <mrow>
        <mi>x</mi>
        <mpadded width="+5pt">
         <mi>f</mi>
        </mpadded>
        <mi>x</mi>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>y</mi>
       </mpadded>
       <mi>x</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <ci>f</ci>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>f</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\{f:\forall xf\ x=y\ x\}|=1
  </annotation>
 </semantics>
</math>

</p>

<p>The next step is to chop this condition up so that the cardinality is tested for each value of 

<math display="inline" id="Deductive_lambda_calculus:37">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, For any condition 

<math display="inline" id="Deductive_lambda_calculus:38">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

, the following result holds,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:39">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>f</mi>
     <mo>:</mo>
     <mi>c</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
   <mo>≡</mo>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <mo stretchy="false">{</mo>
         <mi>z</mi>
         <mo>:</mo>
         <mrow>
          <mi>z</mi>
          <mo>=</mo>
          <mrow>
           <mpadded width="+5pt">
            <mi>f</mi>
           </mpadded>
           <mi>x</mi>
           <mi mathvariant="italic">and</mi>
           <mi>c</mi>
          </mrow>
         </mrow>
         <mo stretchy="false">}</mo>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="latexml">conditional-set</csymbol>
       <ci>f</ci>
       <ci>c</ci>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <ci>x</ci>
         <apply>
          <abs></abs>
          <apply>
           <csymbol cd="latexml">conditional-set</csymbol>
           <ci>z</ci>
           <apply>
            <eq></eq>
            <ci>z</ci>
            <apply>
             <times></times>
             <ci>f</ci>
             <ci>x</ci>
             <ci>italic- and</ci>
             <ci>c</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\{f:c\}|=1\equiv\exists f\forall x|\{z:z=f\ x\and c\}|=1
  </annotation>
 </semantics>
</math>

</p>

<p>Apply this formula gives,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:40">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <mo stretchy="false">{</mo>
         <mi>z</mi>
         <mo>:</mo>
         <mrow>
          <mi>z</mi>
          <mo>=</mo>
          <mrow>
           <mpadded width="+5pt">
            <mi>f</mi>
           </mpadded>
           <mi>x</mi>
           <mi mathvariant="italic">and</mi>
           <mrow>
            <mo>∀</mo>
            <mrow>
             <mpadded width="+5pt">
              <mi>w</mi>
             </mpadded>
             <mpadded width="+5pt">
              <mi>f</mi>
             </mpadded>
             <mi>w</mi>
            </mrow>
           </mrow>
          </mrow>
          <mo>=</mo>
          <mrow>
           <mpadded width="+5pt">
            <mi>y</mi>
           </mpadded>
           <mi>w</mi>
          </mrow>
         </mrow>
         <mo stretchy="false">}</mo>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <times></times>
        <ci>x</ci>
        <apply>
         <abs></abs>
         <apply>
          <csymbol cd="latexml">conditional-set</csymbol>
          <ci>z</ci>
          <apply>
           <and></and>
           <apply>
            <eq></eq>
            <ci>z</ci>
            <apply>
             <times></times>
             <ci>f</ci>
             <ci>x</ci>
             <ci>italic- and</ci>
             <apply>
              <csymbol cd="latexml">for-all</csymbol>
              <apply>
               <times></times>
               <ci>w</ci>
               <ci>f</ci>
               <ci>w</ci>
              </apply>
             </apply>
            </apply>
           </apply>
           <apply>
            <eq></eq>
            <share href="#.cmml">
            </share>
            <apply>
             <times></times>
             <ci>y</ci>
             <ci>w</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists f\forall x|\{z:z=f\ x\and\forall w\ f\ w=y\ w\}|=1
  </annotation>
 </semantics>
</math>

</p>

<p>The inner condition only constrains 

<math display="inline" id="Deductive_lambda_calculus:41">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ x
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Deductive_lambda_calculus:42">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=w
  </annotation>
 </semantics>
</math>

. So,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:43">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∃</mo>
    <mi>f</mi>
    <mo>∀</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>z</mi>
     <mo>:</mo>
     <mi>z</mi>
     <mo>=</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
     <mi mathvariant="italic">and</mi>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
     <mo>=</mo>
     <mpadded width="+5pt">
      <mi>y</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
    <mo>=</mo>
    <mpadded width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mi>x</mi>
    <mo>⇔</mo>
    <mi>f</mi>
    <mo>=</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">f</csymbol>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">z</csymbol>
      <eq></eq>
      <csymbol cd="unknown">f</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <eq></eq>
      <csymbol cd="unknown">y</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-|</ci>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">f</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">iff</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <eq></eq>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\exists f\forall x|\{z:z=f\ x\and f\ x=y\ x\}|=1)\equiv(f\ x=y\ x\iff f=%
\lambda x.y\ x)
  </annotation>
 </semantics>
</math>

</p>
<h3 id="the-structure-of-y">The structure of y</h3>

<p>The condition is,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:44">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <mo stretchy="false">{</mo>
         <mi>z</mi>
         <mo>:</mo>
         <mrow>
          <mi>z</mi>
          <mo>=</mo>
          <mrow>
           <mpadded width="+5pt">
            <mi>f</mi>
           </mpadded>
           <mi>x</mi>
           <mi mathvariant="italic">and</mi>
           <mpadded width="+5pt">
            <mi>f</mi>
           </mpadded>
           <mi>x</mi>
          </mrow>
          <mo>=</mo>
          <mrow>
           <mpadded width="+5pt">
            <mi>y</mi>
           </mpadded>
           <mi>x</mi>
          </mrow>
         </mrow>
         <mo stretchy="false">}</mo>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <times></times>
        <ci>x</ci>
        <apply>
         <abs></abs>
         <apply>
          <csymbol cd="latexml">conditional-set</csymbol>
          <ci>z</ci>
          <apply>
           <and></and>
           <apply>
            <eq></eq>
            <ci>z</ci>
            <apply>
             <times></times>
             <ci>f</ci>
             <ci>x</ci>
             <ci>italic- and</ci>
             <ci>f</ci>
             <ci>x</ci>
            </apply>
           </apply>
           <apply>
            <eq></eq>
            <share href="#.cmml">
            </share>
            <apply>
             <times></times>
             <ci>y</ci>
             <ci>x</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists f\forall x|\{z:z=f\ x\and f\ x=y\ x\}|=1
  </annotation>
 </semantics>
</math>

</p>

<p>Where 

<math display="inline" id="Deductive_lambda_calculus:45">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is not a function of 

<math display="inline" id="Deductive_lambda_calculus:46">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Deductive_lambda_calculus:47">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>f</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=y
  </annotation>
 </semantics>
</math>

 and the cardinality is 1. This leaves only the case where 

<math display="inline" id="Deductive_lambda_calculus:48">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is a function of 

<math display="inline" id="Deductive_lambda_calculus:49">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:50">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mi>f</mi>
   <mo>∀</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∃</mo>
    <mpadded width="+5pt">
     <mi>a</mi>
    </mpadded>
    <mi>x</mi>
    <mo>=</mo>
    <mpadded width="+5pt">
     <mi>a</mi>
    </mpadded>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mo stretchy="false">|</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>z</mi>
    <mo>:</mo>
    <mi>z</mi>
    <mo>=</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
    <mi mathvariant="italic">and</mi>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
    <mo>=</mo>
    <mpadded width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mi>x</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <exists></exists>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <ci>normal-|</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">z</csymbol>
     <eq></eq>
     <csymbol cd="unknown">f</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-|</ci>
    <eq></eq>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists f\forall x(\exists a\ x=a\ f)\to|\{z:z=f\ x\and f\ x=y\ x\}|=1
  </annotation>
 </semantics>
</math>

</p>

<p>The 

<math display="inline" id="Deductive_lambda_calculus:51">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ x=y\ x
  </annotation>
 </semantics>
</math>

 may be written,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:52">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>a</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>a</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>y</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ (a\ f)=y\ (a\ f)
  </annotation>
 </semantics>
</math>

</p>

<p>If a condition on 

<math display="inline" id="Deductive_lambda_calculus:53">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>a</mi>
     </mpadded>
     <mi>f</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ (a\ f)
  </annotation>
 </semantics>
</math>

 is to be formed then 

<math display="inline" id="Deductive_lambda_calculus:54">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 must be in the form of a function of 

<math display="inline" id="Deductive_lambda_calculus:55">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>a</mi>
     </mpadded>
     <mi>f</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ (a\ f)
  </annotation>
 </semantics>
</math>

. Call this function 

<math display="inline" id="Deductive_lambda_calculus:56">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:57">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>a</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>a</mi>
        </mpadded>
        <mi>f</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ (a\ f)=g\ (f\ (a\ f))
  </annotation>
 </semantics>
</math>

</p>

<p>As 

<math display="inline" id="Deductive_lambda_calculus:58">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>a</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>z</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=f\ (a\ f)
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Deductive_lambda_calculus:59">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mi>z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>z</ci>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=g\ z
  </annotation>
 </semantics>
</math>

</p>

<p>Then 

<math display="inline" id="Deductive_lambda_calculus:60">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Deductive_lambda_calculus:61">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 are related by,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:62">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>a</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>a</mi>
        </mpadded>
        <mi>f</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\ (a\ f)=g\ (f\ (a\ f))
  </annotation>
 </semantics>
</math>

</p>

<p>The 

<math display="inline" id="Deductive_lambda_calculus:63">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 function must use some mechanism to construct 

<math display="inline" id="Deductive_lambda_calculus:64">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>a</mi>
     </mpadded>
     <mi>f</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ (a\ f)
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Deductive_lambda_calculus:65">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>a</mi>
   </mpadded>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\ f
  </annotation>
 </semantics>
</math>

. For this to be true for any 

<math display="inline" id="Deductive_lambda_calculus:66">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 there must be some way of extracting 

<math display="inline" id="Deductive_lambda_calculus:67">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Deductive_lambda_calculus:68">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>a</mi>
   </mpadded>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\ f
  </annotation>
 </semantics>
</math>

. Call this function 

<math display="inline" id="Deductive_lambda_calculus:69">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

, defined by,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:70">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>m</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>b</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>a</mi>
       </mpadded>
       <mi>m</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>b</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall m\ b\ (a\ m)=m
  </annotation>
 </semantics>
</math>

</p>

<p>Then 

<math display="inline" id="Deductive_lambda_calculus:71">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Deductive_lambda_calculus:72">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 are related by,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:73">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>n</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>y</mi>
     </mpadded>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>b</mi>
        </mpadded>
        <mi>n</mi>
       </mrow>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall n\ y\ n=g\ ((b\ n)\ n)
  </annotation>
 </semantics>
</math>

</p>

<p>Plugging the results back in and simplifying gives,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:74">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>∃</mo>
   <mpadded width="+5pt">
    <mi>g</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∃</mo>
    <mi>a</mi>
    <mo>∃</mo>
    <mpadded width="+5pt">
     <mi>b</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>∀</mo>
     <mpadded width="+5pt">
      <mi>n</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>y</mi>
     </mpadded>
     <mi>n</mi>
     <mo>=</mo>
     <mpadded width="+5pt">
      <mi>g</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mpadded width="+5pt">
        <mi>b</mi>
       </mpadded>
       <mi>n</mi>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>∀</mo>
     <mpadded width="+5pt">
      <mi>m</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>b</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>a</mi>
      </mpadded>
      <mi>m</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>=</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mo stretchy="false">|</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>z</mi>
    <mo>:</mo>
    <mi>z</mi>
    <mo>=</mo>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mi>z</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mo>=</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <exists></exists>
    <csymbol cd="unknown">g</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">a</csymbol>
     <exists></exists>
     <csymbol cd="unknown">b</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">n</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <csymbol cd="unknown">n</csymbol>
      <eq></eq>
      <csymbol cd="unknown">g</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">b</csymbol>
        <csymbol cd="unknown">n</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">m</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">a</csymbol>
       <csymbol cd="unknown">m</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <eq></eq>
      <csymbol cd="unknown">m</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <ci>normal-|</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">z</csymbol>
     <eq></eq>
     <csymbol cd="unknown">g</csymbol>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-|</ci>
    <eq></eq>
    <cn type="integer">1</cn>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\exists g\ (\exists a\exists b\ (\forall n\ y\ n=g\ ((b\ n)\ n))\and(\forall m%
\ b\ (a\ m)=m))\to|\{z:z=g\ z\}|=1)
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Deductive_lambda_calculus:75">
 <semantics>
  <mrow>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
    <mo>=</mo>
    <mpadded width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mi>x</mi>
    <mo>⇔</mo>
    <mi>f</mi>
    <mo>=</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">f</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">iff</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <eq></eq>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">y</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \equiv(f\ x=y\ x\iff f=\lambda x.y\ x)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h3 id="no-solutions">No solutions</h3>

<p>Starting with 

<math display="inline" id="Deductive_lambda_calculus:76">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mi>z</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\ z=\neg z
  </annotation>
 </semantics>
</math>

, where z is a <a href="Boolean_algebra_(structure)" title="wikilink">Boolean</a>, an equation with no solutions is formed,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:77">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>z</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=\neg z
  </annotation>
 </semantics>
</math>

</p>

<p>Then letting 

<math display="inline" id="Deductive_lambda_calculus:78">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Deductive_lambda_calculus:79">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 be the identity function,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:80">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mi>n</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>n</mi>
      </mpadded>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <not></not>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\ n=\neg(n\ n)
  </annotation>
 </semantics>
</math>

</p>

<p>As,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:81">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>z</mi>
     <mo>:</mo>
     <mrow>
      <mi>z</mi>
      <mo>=</mo>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>z</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <ci>z</ci>
      <apply>
       <eq></eq>
       <ci>z</ci>
       <apply>
        <times></times>
        <not></not>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\{z:z=\neg z\}|=0
  </annotation>
 </semantics>
</math>

</p>

<p>then it is not true that,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:82">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mi>x</mi>
   <mo>=</mo>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇔</mo>
   <mi>f</mi>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <not></not>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <not></not>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ x=\neg(x\ x)\iff f=\lambda x.\neg(x\ x)
  </annotation>
 </semantics>
</math>

</p>

<p>If we go ahead anyway,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:83">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <not></not>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=\lambda x.\neg(x\ x)
  </annotation>
 </semantics>
</math>

</p>

<p>And then,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:84">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ f
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:85">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <not></not>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <not></not>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =(\lambda x.\neg(x\ x))(\lambda x.\neg(x\ x))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:86">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mi mathvariant="normal">¬</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mi mathvariant="normal">¬</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <not></not>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <not></not>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <not></not>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\neg((\lambda x.\neg(x\ x))(\lambda x.\neg(x\ x)))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:87">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <not></not>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\neg(f\ f)
  </annotation>
 </semantics>
</math>

</p>

<p>Then 

<math display="inline" id="Deductive_lambda_calculus:88">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ f
  </annotation>
 </semantics>
</math>

 is neither true or false, and as 

<math display="inline" id="Deductive_lambda_calculus:89">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ x
  </annotation>
 </semantics>
</math>

 is a Boolean value then this violates the <a href="principle_of_bivalence" title="wikilink">principle of bivalence</a>.</p>
<h3 id="multiple-solutions">Multiple solutions</h3>

<p>Also it is possible to construct lambda expressions for which there are multiple values. In the <a href="real_number" title="wikilink">real number</a> domain, starting with,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:90">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mi>n</mi>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>4</mn>
    <mi>n</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">4</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\ n=\frac{4}{n}
  </annotation>
 </semantics>
</math>

</p>

<p>then,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:91">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mfrac>
    <mn>4</mn>
    <mi>z</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>z</ci>
    <apply>
     <divide></divide>
     <cn type="integer">4</cn>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=\frac{4}{z}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:92">
 <semantics>
  <mrow>
   <msup>
    <mi>z</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>z</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{2}=4
  </annotation>
 </semantics>
</math>

</p>

<p>Then letting 

<math display="inline" id="Deductive_lambda_calculus:93">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Deductive_lambda_calculus:94">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 be the identity function,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:95">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>y</mi>
    </mpadded>
    <mi>n</mi>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>4</mn>
    <mrow>
     <mpadded width="+5pt">
      <mi>n</mi>
     </mpadded>
     <mi>n</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">4</cn>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\ n=\frac{4}{n\ n}
  </annotation>
 </semantics>
</math>

</p>

<p>As,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:96">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>z</mi>
     <mo>:</mo>
     <mrow>
      <mi>z</mi>
      <mo>=</mo>
      <mfrac>
       <mn>4</mn>
       <mi>z</mi>
      </mfrac>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <ci>z</ci>
      <apply>
       <eq></eq>
       <ci>z</ci>
       <apply>
        <divide></divide>
        <cn type="integer">4</cn>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\{z:z=\frac{4}{z}\}|=2
  </annotation>
 </semantics>
</math>

</p>

<p>then it is not true that,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:97">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mi>x</mi>
   <mo>=</mo>
   <mfrac>
    <mn>4</mn>
    <mrow>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
    </mrow>
   </mfrac>
   <mo>⇔</mo>
   <mi>f</mi>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mfrac>
    <mn>4</mn>
    <mrow>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">4</cn>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <apply>
     <divide></divide>
     <cn type="integer">4</cn>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ x=\frac{4}{x\ x}\iff f=\lambda x.\frac{4}{x\ x}
  </annotation>
 </semantics>
</math>

</p>

<p>If we go ahead anyway,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:98">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mfrac>
    <mn>4</mn>
    <mrow>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">4</cn>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=\lambda x.\frac{4}{x\ x}
  </annotation>
 </semantics>
</math>

</p>

<p>And then,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:99">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ f
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:100">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mfrac>
     <mn>4</mn>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
    </mfrac>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mfrac>
     <mn>4</mn>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
    </mfrac>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <apply>
      <divide></divide>
      <cn type="integer">4</cn>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <apply>
      <divide></divide>
      <cn type="integer">4</cn>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =(\lambda x.\frac{4}{x\ x})(\lambda x.\frac{4}{x\ x})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:101">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mfrac>
    <mn>4</mn>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>x</mi>
      <mo>.</mo>
      <mfrac>
       <mn>4</mn>
       <mrow>
        <mpadded width="+5pt">
         <mi>x</mi>
        </mpadded>
        <mi>x</mi>
       </mrow>
      </mfrac>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>x</mi>
      <mo>.</mo>
      <mfrac>
       <mn>4</mn>
       <mrow>
        <mpadded width="+5pt">
         <mi>x</mi>
        </mpadded>
        <mi>x</mi>
       </mrow>
      </mfrac>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <divide></divide>
     <cn type="integer">4</cn>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-.</ci>
       <apply>
        <divide></divide>
        <cn type="integer">4</cn>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-.</ci>
       <apply>
        <divide></divide>
        <cn type="integer">4</cn>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\frac{4}{(\lambda x.\frac{4}{x\ x})(\lambda x.\frac{4}{x\ x})}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:102">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mfrac>
    <mn>4</mn>
    <mrow>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>f</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <divide></divide>
     <cn type="integer">4</cn>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\frac{4}{f\ f}
  </annotation>
 </semantics>
</math>

</p>

<p>and,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:103">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>f</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f\ f)^{2}=4
  </annotation>
 </semantics>
</math>

</p>

<p>Having an equation with multiple solutions is not an inconsistency. However the derivation demonstrated that, for all 

<math display="inline" id="Deductive_lambda_calculus:104">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>f</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f\ f)
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:105">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mn>4</mn>
   <mo>⟹</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mfrac>
     <mn>4</mn>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
    </mfrac>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mfrac>
     <mn>4</mn>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
    </mfrac>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">f</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cn type="integer">2</cn>
    </apply>
    <eq></eq>
    <cn type="integer">4</cn>
    <implies></implies>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">f</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <apply>
      <divide></divide>
      <cn type="integer">4</cn>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <apply>
      <divide></divide>
      <cn type="integer">4</cn>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f\ f)^{2}=4\implies(f\ f)=(\lambda x.\frac{4}{x\ x})\ (\lambda x.\frac{4}{x\ %
x})
  </annotation>
 </semantics>
</math>

</p>

<p>Then substituting 

<math display="inline" id="Deductive_lambda_calculus:106">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>f</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f\ f)
  </annotation>
 </semantics>
</math>

 with 2 gives,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:107">
 <semantics>
  <mrow>
   <mo>true</mo>
   <mo>⟹</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mfrac>
     <mn>4</mn>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
    </mfrac>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mfrac>
     <mn>4</mn>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
    </mfrac>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>true</ci>
    <implies></implies>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <apply>
      <divide></divide>
      <cn type="integer">4</cn>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <apply>
      <divide></divide>
      <cn type="integer">4</cn>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">2</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{true}\implies(\lambda x.\frac{4}{x\ x})\ (\lambda x.\frac{4}{x\ %
x})=2
  </annotation>
 </semantics>
</math>

</p>

<p>Substituting 

<math display="inline" id="Deductive_lambda_calculus:108">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>f</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f\ f)
  </annotation>
 </semantics>
</math>

 with -2 gives,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:109">
 <semantics>
  <mrow>
   <mo>true</mo>
   <mo>⟹</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mfrac>
     <mn>4</mn>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
    </mfrac>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mfrac>
     <mn>4</mn>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
    </mfrac>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo>-</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>true</ci>
    <implies></implies>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <apply>
      <divide></divide>
      <cn type="integer">4</cn>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <apply>
      <divide></divide>
      <cn type="integer">4</cn>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <minus></minus>
    <cn type="integer">2</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{true}\implies(\lambda x.\frac{4}{x\ x})\ (\lambda x.\frac{4}{x\ %
x})=-2
  </annotation>
 </semantics>
</math>

</p>

<p>Then,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:110">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mfrac>
     <mn>4</mn>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
    </mfrac>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mfrac>
     <mn>4</mn>
     <mrow>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
    </mfrac>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>2</mn>
   <mo>=</mo>
   <mo>-</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <apply>
      <divide></divide>
      <cn type="integer">4</cn>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <apply>
      <divide></divide>
      <cn type="integer">4</cn>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">2</cn>
    <eq></eq>
    <minus></minus>
    <cn type="integer">2</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.\frac{4}{x\ x})\ (\lambda x.\frac{4}{x\ x})=2=-2
  </annotation>
 </semantics>
</math>

</p>

<p>which is a contradiction, because the values 2 and -2 are defined not equal in the real domain.</p>
<h2 id="intensional-versus-extensional-equality">Intensional versus extensional equality</h2>

<p>Another difficulty for the interpretation of lambda calculus as a deductive system is the representation of values as lambda terms, which represent functions. The untyped lambda calculus is implemented by performing reductions on a lambda term, until the term is in normal form. The <a href="Extensionality" title="wikilink">intensional</a> interpretation<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> of equality is that the reduction of a lambda term to normal form is the value of the lambda term.</p>

<p>This interpretation considers the identify of a lambda expression to be its structure. Two lambda terms are equal if they are alpha convertible.</p>

<p>One way to describe this is that extensional equality describes equality of functions, where as intensional equality describes equality of function implementations.</p>

<p>The mathematical (or <a href="Extensionality" title="wikilink">extensional</a>) definition of function equality is that two functions are equal if they perform the same mapping;</p>

<p>

<math display="block" id="Deductive_lambda_calculus:111">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <mi>g</mi>
   <mo>⇔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
    <mo>=</mo>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <eq></eq>
    <csymbol cd="unknown">g</csymbol>
    <csymbol cd="latexml">iff</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">g</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=g\iff(\forall xf\ x=g\ x)
  </annotation>
 </semantics>
</math>

</p>

<p>The extensional definition of equality is incompatible with the intensional definition. This can be seen in the example below, where applying a mathematical law changes a function to an equivalent function, yet the intensional interpretation of equality says that the two functions are not equal. This shows the untyped lambda calculus with intensional equality is inconsistent with mathematics as a deductive system.</p>

<p>This incompatibly is created by considering lambda terms as values. In <a href="typed_lambda_calculus" title="wikilink">typed lambda calculus</a> this is not a significant problem, because built-in types may be added to carry values that are in a <a href="canonical_form" title="wikilink">canonical form</a> and have both extensional and intensional equality.</p>
<h3 id="example">Example</h3>

<p>In <a class="uri" href="arithmetic" title="wikilink">arithmetic</a>, the <a href="Distributive_property" title="wikilink">distributive law</a> implies that 

<math display="inline" id="Deductive_lambda_calculus:112">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mo>*</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>r</mi>
      <mo>+</mo>
      <mi>s</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mo>*</mo>
     <mi>r</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mo>*</mo>
     <mi>s</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <plus></plus>
      <ci>r</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>r</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2*(r+s)=2*r+2*s
  </annotation>
 </semantics>
</math>

. Using the <a href="Church_encoding#Church_numerals" title="wikilink">Church encoding of numerals</a> the left and right hand sides may be represented as lambda terms.</p>

<p>So the distributive law says that the two functions,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:113">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>r</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>λ</mi>
      <mi>s</mi>
      <mn>.2</mn>
     </mrow>
     <mo>*</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>r</mi>
       <mo>+</mo>
       <mi>s</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>r</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>λ</mi>
      <mi>s</mi>
      <mn>.2</mn>
     </mrow>
     <mo>*</mo>
     <mi>r</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mo>*</mo>
     <mi>s</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>λ</ci>
       <ci>s</ci>
       <cn type="float">.2</cn>
      </apply>
      <apply>
       <plus></plus>
       <ci>r</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>λ</ci>
       <ci>s</ci>
       <cn type="float">.2</cn>
      </apply>
      <ci>r</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda r.\lambda s.2*(r+s)=\lambda r.\lambda s.2*r+2*s
  </annotation>
 </semantics>
</math>

</p>

<p>are equal. The distributive law should apply if the church numerals provided a satisfactory implementation of numbers.</p>

<p>Left hand side;</p>

<p>

<math display="block" id="Deductive_lambda_calculus:114">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>r</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>s</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo>mult</mo>
     <mpadded width="+5pt">
      <mn>2</mn>
     </mpadded>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo rspace="7.5pt">plus</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>r</mi>
       </mpadded>
       <mi>s</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>mult</ci>
      <cn type="float">2</cn>
     </apply>
     <apply>
      <ci>plus</ci>
      <apply>
       <times></times>
       <ci>r</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda r.\lambda s.\operatorname{mult}\ 2\ (\operatorname{plus}\ r\ s)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:115">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>r</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>s</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>m</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>n</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>m</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>n</mi>
     </mpadded>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>m</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>n</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>m</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>n</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mpadded width="+5pt">
     <mi>r</mi>
    </mpadded>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">m</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">f</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">m</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">m</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda r.\lambda s.(\lambda m.\lambda n.\lambda f.m\ (n\ f))\ (\lambda f.%
\lambda x.f\ (f\ x))\ ((\lambda m.\lambda n.\lambda f.\lambda x.m\ f\ (n\ f\ x%
))\ r\ s)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:116">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>r</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>s</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>r</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>s</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>r</mi>
        </mpadded>
        <mpadded width="+5pt">
         <mi>f</mi>
        </mpadded>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mpadded width="+5pt">
           <mi>s</mi>
          </mpadded>
          <mpadded width="+5pt">
           <mi>f</mi>
          </mpadded>
          <mi>x</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>r</ci>
       <ci>f</ci>
       <apply>
        <times></times>
        <ci>s</ci>
        <ci>f</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda r.\lambda s.\lambda f.\lambda x.r\ f\ (s\ f\ (r\ f\ (s\ f\ x)))
  </annotation>
 </semantics>
</math>

</p>

<p>Right hand side;</p>

<p>

<math display="block" id="Deductive_lambda_calculus:117">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>r</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>s</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo rspace="7.5pt">plus</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>mult</mo>
       <mrow>
        <mpadded width="+5pt">
         <mn>2</mn>
        </mpadded>
        <mi>r</mi>
       </mrow>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>mult</mo>
      <mrow>
       <mpadded width="+5pt">
        <mn>2</mn>
       </mpadded>
       <mi>s</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <apply>
      <ci>plus</ci>
      <apply>
       <ci>mult</ci>
       <apply>
        <times></times>
        <cn type="float">2</cn>
        <ci>r</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>mult</ci>
      <apply>
       <times></times>
       <cn type="float">2</cn>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda r.\lambda s.\operatorname{plus}\ (\operatorname{mult}\ 2\ r)\ (%
\operatorname{mult}\ 2\ s)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:118">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>r</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>s</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>m</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>n</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>m</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>n</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>m</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>n</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>m</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>n</mi>
      </mpadded>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>r</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>m</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>n</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>m</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>n</mi>
      </mpadded>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>f</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">m</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">m</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">m</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">m</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">f</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">m</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">m</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">f</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda r.\lambda s.(\lambda m.\lambda n.\lambda f.\lambda x.m\ f\ (n\ f\ x))%
\ ((\lambda m.\lambda n.\lambda f.m\ (n\ f))\ (\lambda f.\lambda x.f\ (f\ x))%
\ r)\ ((\lambda m.\lambda n.\lambda f.m\ (n\ f))\ (\lambda f.\lambda x.f\ (f\ %
x))\ s)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:119">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>r</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>s</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>r</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>r</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>s</mi>
        </mpadded>
        <mpadded width="+5pt">
         <mi>f</mi>
        </mpadded>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mpadded width="+5pt">
           <mi>s</mi>
          </mpadded>
          <mpadded width="+5pt">
           <mi>f</mi>
          </mpadded>
          <mi>x</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>f</ci>
       <apply>
        <times></times>
        <ci>s</ci>
        <ci>f</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda r.\lambda s.\lambda f.\lambda x.r\ f\ (r\ f\ (s\ f\ (s\ f\ x)))
  </annotation>
 </semantics>
</math>

</p>

<p>Comparison;</p>

<p>

<math display="block" id="Deductive_lambda_calculus:120">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>r</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>s</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>r</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>s</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>r</mi>
        </mpadded>
        <mpadded width="+5pt">
         <mi>f</mi>
        </mpadded>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mpadded width="+5pt">
           <mi>s</mi>
          </mpadded>
          <mpadded width="+5pt">
           <mi>f</mi>
          </mpadded>
          <mi>x</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>r</ci>
       <ci>f</ci>
       <apply>
        <times></times>
        <ci>s</ci>
        <ci>f</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda r.\lambda s.\lambda f.\lambda x.r\ f\ (s\ f\ (r\ f\ (s\ f\ x)))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:121">
 <semantics>
  <mrow>
   <mrow>
    <mi>λ</mi>
    <mi>r</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>s</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>f</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>r</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>r</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>s</mi>
        </mpadded>
        <mpadded width="+5pt">
         <mi>f</mi>
        </mpadded>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mpadded width="+5pt">
           <mi>s</mi>
          </mpadded>
          <mpadded width="+5pt">
           <mi>f</mi>
          </mpadded>
          <mi>x</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>f</ci>
       <apply>
        <times></times>
        <ci>s</ci>
        <ci>f</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda r.\lambda s.\lambda f.\lambda x.r\ f\ (r\ f\ (s\ f\ (s\ f\ x)))
  </annotation>
 </semantics>
</math>

</p>

<p>The two terms beta reduce to similar expressions. Still they are not alpha convertible, so according to intensional equality, the left hand side and the right hand side are different functions, and are not equal. But according to the distributive law the two functions are the same. If the two functions are applied to the same Church numerals they produce the same result, so in that sense the distributive law holds. But the functions themselves are not equal.</p>

<p>This a significant problem because all values in the untyped lambda calculus are terms that define functions. So any mathematically correct transformation of a lambda calculus program may change the meaning of the program.</p>
<h2 id="set-theoretic-domain">Set theoretic domain</h2>

<p>Lambda abstractions are functions of functions. A natural step is to define a domain for the lambda abstraction as a set of all functions.</p>

<p>The set of all functions from a domain <em>D</em> to a range <em>R</em> is given by <em>K</em> in,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:122">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>∈</mo>
   <mi>K</mi>
   <mo>⇔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mo>:</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>D</mi>
    <mo>⟹</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <in></in>
    <csymbol cd="unknown">K</csymbol>
    <csymbol cd="latexml">iff</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">D</csymbol>
     <implies></implies>
     <csymbol cd="unknown">f</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\in K\iff(\forall x:x\in D\implies f\ x\in R)
  </annotation>
 </semantics>
</math>

</p>

<p>Then the definition of the set of all functions of functions is given by <em>F</em> in,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:123">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>∈</mo>
   <mi>F</mi>
   <mo>⇔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mo>:</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>F</mi>
    <mo>⟹</mo>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <in></in>
    <csymbol cd="unknown">F</csymbol>
    <csymbol cd="latexml">iff</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">F</csymbol>
     <implies></implies>
     <csymbol cd="unknown">f</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\in F\iff(\forall x:x\in F\implies f\ x\in F)
  </annotation>
 </semantics>
</math>

</p>

<p>This definition is an unsolved equation for <em>F</em>. If there exists no function that may not be applied to itself, then there is a set F that satisfies the above definition of "all functions". This is the case with lambda calculus, as there are no restriction on the domain of parameters.</p>

<p>However consider the <a href="Church_numerals" title="wikilink">Church numerals</a>. If the functions on Church numerals, such as <em>plus</em>, <em>minus</em>, <em>times</em> and <em>divide</em> were restricted so that they only apply to Church numerals then these are functions that may not be applied to them self. This restriction is desirable because the Church arithmetic functions do not meaningful apply to functions other than Church numerals.</p>

<p>However then we get a version of <a href="Russell's_paradox" title="wikilink">Russell's paradox</a>. See also <a href="Rice's_theorem" title="wikilink">Rice's theorem</a>, which relates to <a href="Partial_function" title="wikilink">partial functions</a>.</p>

<p>To show this assume <em>g</em> is a function that may not be applied to itself,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:124">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mi>g</mi>
   </mrow>
   <mo>∉</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>g</ci>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\ g\not\in F
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:125">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≠</mo>
   <mi>g</mi>
   <mo>⟹</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <neq></neq>
     <ci>x</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <implies></implies>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <ci>F</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\neq g\implies g\ x\in F
  </annotation>
 </semantics>
</math>

</p>

<p>Firstly assume <em>g</em> is in <em>F</em>. This will be used to deduce a falsehood.</p>

<p>

<math display="block" id="Deductive_lambda_calculus:126">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∈</mo>
   <mi>F</mi>
   <mo>⇔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mo>:</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>F</mi>
    <mo>⟹</mo>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">g</csymbol>
    <in></in>
    <csymbol cd="unknown">F</csymbol>
    <csymbol cd="latexml">iff</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">F</csymbol>
     <implies></implies>
     <csymbol cd="unknown">g</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\in F\iff(\forall x:x\in F\implies g\ x\in F)
  </annotation>
 </semantics>
</math>

 instantiate <em>x</em> as <em>g</em>.</p>

<p>

<math display="block" id="Deductive_lambda_calculus:127">
 <semantics>
  <mrow>
   <mo>⟹</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>g</mi>
    <mo>∈</mo>
    <mi>F</mi>
    <mo>⟹</mo>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mi>g</mi>
    <mo>∈</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <implies></implies>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">g</csymbol>
     <in></in>
     <csymbol cd="unknown">F</csymbol>
     <implies></implies>
     <csymbol cd="unknown">g</csymbol>
     <csymbol cd="unknown">g</csymbol>
     <in></in>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \implies(g\in F\implies g\ g\in F)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:128">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⟹</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mi>g</mi>
   </mrow>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <implies></implies>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>g</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <ci>F</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \implies g\ g\in F
  </annotation>
 </semantics>
</math>

</p>

<p>which is false because.</p>

<p>

<math display="block" id="Deductive_lambda_calculus:129">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mi>g</mi>
   </mrow>
   <mo>∉</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>g</ci>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\ g\not\in F
  </annotation>
 </semantics>
</math>

</p>

<p>Secondly assume <em>g</em> not in <em>F</em>. Again this will be used to deduce a falsehood. Starting with,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:130">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∉</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>g</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\not\in F
  </annotation>
 </semantics>
</math>

</p>

<p>From the definition of all functions of functions, it can be shown that,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:131">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mo>:</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>F</mi>
    <mo>⟹</mo>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⟹</mo>
   <mi>g</mi>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">F</csymbol>
     <implies></implies>
     <csymbol cd="unknown">g</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <implies></implies>
    <csymbol cd="unknown">g</csymbol>
    <in></in>
    <csymbol cd="unknown">F</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall x:x\in F\implies g\ x\in F)\implies g\in F
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:132">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mo>:</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>F</mi>
    <mo>⟹</mo>
    <mi>g</mi>
    <mo>≠</mo>
    <mi>x</mi>
    <mo>⟹</mo>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>F</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⟹</mo>
   <mi>g</mi>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">F</csymbol>
     <implies></implies>
     <csymbol cd="unknown">g</csymbol>
     <neq></neq>
     <csymbol cd="unknown">x</csymbol>
     <implies></implies>
     <csymbol cd="unknown">g</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <implies></implies>
    <csymbol cd="unknown">g</csymbol>
    <in></in>
    <csymbol cd="unknown">F</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall x:x\in F\implies g\neq x\implies g\ x\in F)\implies g\in F
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:133">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mo>:</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>F</mi>
    <mo>⟹</mo>
    <mo>true</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⟹</mo>
   <mi>g</mi>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">F</csymbol>
     <implies></implies>
     <ci>true</ci>
     <ci>normal-)</ci>
    </cerror>
    <implies></implies>
    <csymbol cd="unknown">g</csymbol>
    <in></in>
    <csymbol cd="unknown">F</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall x:x\in F\implies\operatorname{true})\implies g\in F
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:134">
 <semantics>
  <mrow>
   <mo>true</mo>
   <mo>⟹</mo>
   <mi>g</mi>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <implies></implies>
     <ci>true</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <ci>F</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{true}\implies g\in F
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:135">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>g</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\in F
  </annotation>
 </semantics>
</math>

</p>

<p>which is false because we assumed,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:136">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∉</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>g</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\not\in F
  </annotation>
 </semantics>
</math>

</p>

<p>So <em>g</em> is an element of <em>F</em> and not an element of <em>F</em>.</p>

<p>Therefore, if there exists a function that may not be applied to itself, then there is no set <em>F</em> satisfying the above definition of "all functions". This result limits what can be done with the set theoretic approach to lambda calculus, while not actually ruling out the lambda calculus domain. The lambda calculus domain is OK, defined as a set, but any modification to it may cause problems. The usual approach to defining sets of functions is to build a <a href="Von_Neumann_universe" title="wikilink">Von Neumann universe</a>. However, because the only type in the untyped lambda calculus is the function, it is not clear how to do this.</p>
<h2 id="domain-of-lambda-calculus">Domain of lambda calculus</h2>

<p>The problems with lambda abstraction arose when a domain was imposed on it. If the lambda abstraction is allowed to define the domain, instead of imposing the domain upon the lambda abstraction, these problems no longer appear.</p>

<p>Lambda calculus is defined by beta reductions and eta reductions. Interpreting reduction as defining equality gives an implicit domain for the lambda calculus. The rules are,</p>
<ul>
<li>Every lambda abstraction has one value.</li>
<li>The beta reduction of a lambda term has the same value.</li>
<li>The eta reduction of a lambda term has the same value.</li>
<li>Alpha convertible lambda terms are equal.</li>
<li>If two lambda terms can not be shown to be equal, they are not equal.</li>
</ul>

<p>If lambda terms may be reduced to normal form then the <a href="Church–Rosser_theorem" title="wikilink">Church–Rosser theorem</a> may be used to show that lambda terms are equal if their normal forms are alpha convertible.</p>

<p>If not then the <a href="Lambda_calculus#Undecidability_of_equivalence" title="wikilink">undecidability of equivalence</a> shows that in general there is no algorithm to determine if two lambda terms are equal. In general this makes it impossible to know what the distinct elements of the lambda calculus domain are.</p>
<h3 id="example-no-solutions---one-solution">Example: No solutions -&gt; one solution</h3>

<p>For example the equation 

<math display="inline" id="Deductive_lambda_calculus:137">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=\neg x
  </annotation>
 </semantics>
</math>

 may be coded with <a href="Church_encoding" title="wikilink">Church encoding</a> and using <a href="Fixed-point_combinator#Fixed_point_combinators_in_lambda_calculus" title="wikilink">Curry's Y combinator</a> as,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:138">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>not</mo>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>p</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>a</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <mi>b</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>b</mi>
    </mpadded>
    <mi>a</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>not</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>b</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{not}_{1}=\lambda p.\lambda a.\lambda b.p\ b\ a
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:139">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>f</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>a</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>b</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>b</mi>
    </mpadded>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x)))(\lambda p.\lambda a.%
\lambda b.p\ b\ a)
  </annotation>
 </semantics>
</math>

</p>

<p>And the recursion is,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:140">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>p</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>a</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>b</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>b</mi>
     </mpadded>
     <mi>a</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>p</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>a</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>b</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>b</mi>
     </mpadded>
     <mi>a</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.(\lambda p.\lambda a.\lambda b.p\ b\ a)\ (x\ x))\ (\lambda x.(%
\lambda p.\lambda a.\lambda b.p\ b\ a)\ (x\ x))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:141">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>p</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>a</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>b</mi>
    <mo>.</mo>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mi>b</mi>
    </mpadded>
    <mi>a</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>p</mi>
      <mo>.</mo>
      <mi>λ</mi>
      <mi>a</mi>
      <mo>.</mo>
      <mi>λ</mi>
      <mi>b</mi>
      <mo>.</mo>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>b</mi>
      </mpadded>
      <mi>a</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>p</mi>
      <mo>.</mo>
      <mi>λ</mi>
      <mi>a</mi>
      <mo>.</mo>
      <mi>λ</mi>
      <mi>b</mi>
      <mo>.</mo>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>b</mi>
      </mpadded>
      <mi>a</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">a</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">b</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">b</csymbol>
       <csymbol cd="unknown">a</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">a</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">b</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">b</csymbol>
       <csymbol cd="unknown">a</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda p.\lambda a.\lambda b.p\ b\ a)\ ((\lambda x.(\lambda p.\lambda a.%
\lambda b.p\ b\ a)\ (x\ x))\ (\lambda x.(\lambda p.\lambda a.\lambda b.p\ b\ a%
)\ (x\ x)))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deductive_lambda_calculus:142">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>a</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>b</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>p</mi>
      <mo>.</mo>
      <mi>λ</mi>
      <mi>a</mi>
      <mo>.</mo>
      <mi>λ</mi>
      <mi>b</mi>
      <mo>.</mo>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>b</mi>
      </mpadded>
      <mi>a</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>x</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>p</mi>
      <mo>.</mo>
      <mi>λ</mi>
      <mi>a</mi>
      <mo>.</mo>
      <mi>λ</mi>
      <mi>b</mi>
      <mo>.</mo>
      <mpadded width="+5pt">
       <mi>p</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>b</mi>
      </mpadded>
      <mi>a</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mpadded width="+5pt">
       <mi>x</mi>
      </mpadded>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mpadded width="+5pt">
    <mi>b</mi>
   </mpadded>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">a</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">b</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">b</csymbol>
       <csymbol cd="unknown">a</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">a</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">b</csymbol>
       <ci>normal-.</ci>
       <csymbol cd="unknown">p</csymbol>
       <csymbol cd="unknown">b</csymbol>
       <csymbol cd="unknown">a</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">b</csymbol>
    <csymbol cd="unknown">a</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda a.\lambda b.((\lambda x.(\lambda p.\lambda a.\lambda b.p\ b\ a)\ (x\ x%
))\ (\lambda x.(\lambda p.\lambda a.\lambda b.p\ b\ a)\ (x\ x)))\ b\ a
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd>...
</dd>
<dd>

<math display="inline" id="Deductive_lambda_calculus:143">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mi>a</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <mi>b</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>a</mi>
    <mo>.</mo>
    <mi>λ</mi>
    <mi>b</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>x</mi>
      <mo>.</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>λ</mi>
       <mi>p</mi>
       <mo>.</mo>
       <mi>λ</mi>
       <mi>a</mi>
       <mo>.</mo>
       <mi>λ</mi>
       <mi>b</mi>
       <mo>.</mo>
       <mpadded width="+5pt">
        <mi>p</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>b</mi>
       </mpadded>
       <mi>a</mi>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mpadded width="+5pt">
        <mi>x</mi>
       </mpadded>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>λ</mi>
      <mi>x</mi>
      <mo>.</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>λ</mi>
       <mi>p</mi>
       <mo>.</mo>
       <mi>λ</mi>
       <mi>a</mi>
       <mo>.</mo>
       <mi>λ</mi>
       <mi>b</mi>
       <mo>.</mo>
       <mpadded width="+5pt">
        <mi>p</mi>
       </mpadded>
       <mpadded width="+5pt">
        <mi>b</mi>
       </mpadded>
       <mi>a</mi>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mpadded width="+5pt">
        <mi>x</mi>
       </mpadded>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mpadded width="+5pt">
     <mi>b</mi>
    </mpadded>
    <mi>a</mi>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mpadded width="+5pt">
    <mi>b</mi>
   </mpadded>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-.</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">λ</csymbol>
        <csymbol cd="unknown">p</csymbol>
        <ci>normal-.</ci>
        <csymbol cd="unknown">λ</csymbol>
        <csymbol cd="unknown">a</csymbol>
        <ci>normal-.</ci>
        <csymbol cd="unknown">λ</csymbol>
        <csymbol cd="unknown">b</csymbol>
        <ci>normal-.</ci>
        <csymbol cd="unknown">p</csymbol>
        <csymbol cd="unknown">b</csymbol>
        <csymbol cd="unknown">a</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">x</csymbol>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">λ</csymbol>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-.</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">λ</csymbol>
        <csymbol cd="unknown">p</csymbol>
        <ci>normal-.</ci>
        <csymbol cd="unknown">λ</csymbol>
        <csymbol cd="unknown">a</csymbol>
        <ci>normal-.</ci>
        <csymbol cd="unknown">λ</csymbol>
        <csymbol cd="unknown">b</csymbol>
        <ci>normal-.</ci>
        <csymbol cd="unknown">p</csymbol>
        <csymbol cd="unknown">b</csymbol>
        <csymbol cd="unknown">a</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">x</csymbol>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">b</csymbol>
    <csymbol cd="unknown">a</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda a.\lambda b.(\lambda a.\lambda b.((\lambda x.(\lambda p.\lambda a.%
\lambda b.p\ b\ a)\ (x\ x))\ (\lambda x.(\lambda p.\lambda a.\lambda b.p\ b\ a%
)\ (x\ x)))\ b\ a)\ b\ a
  </annotation>
 </semantics>
</math>


</dd>
<dd>... (beta and then eta reduction)
</dd>
<dd>

<math display="inline" id="Deductive_lambda_calculus:144">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>p</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>a</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>b</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>b</mi>
     </mpadded>
     <mi>a</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mi>p</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>a</mi>
     <mo>.</mo>
     <mi>λ</mi>
     <mi>b</mi>
     <mo>.</mo>
     <mpadded width="+5pt">
      <mi>p</mi>
     </mpadded>
     <mpadded width="+5pt">
      <mi>b</mi>
     </mpadded>
     <mi>a</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+5pt">
      <mi>x</mi>
     </mpadded>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">λ</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">b</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.(\lambda p.\lambda a.\lambda b.p\ b\ a)\ (x\ x))\ (\lambda x.(%
\lambda p.\lambda a.\lambda b.p\ b\ a)\ (x\ x))
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>Which is the first line and will recurse indefinitely. The expression never reduces to normal form. However every lambda term in the reduction represents the same value. This value is distinct from the encodings for <em>true</em> or <em>false</em>. It is not part of the Boolean domain but it exists in the lambda calculus domain.</p>
<h3 id="example-multiple-solutions---one-solution">Example: Multiple solutions -&gt; one solution</h3>

<p>Using <a href="Church_encoding#Division" title="wikilink">division</a> and <a href="Church_encoding#Signed_numbers" title="wikilink">signed numbers</a>, the <em>Y</em> combinator may be used to define an expression representing a whole number square root. The Church encoding may also be extended further to <a class="uri" href="rational" title="wikilink">rational</a> and <a href="Real_number" title="wikilink">real</a> numbers, so that a real square root may be defined. The <a href="Church-Turing_thesis" title="wikilink">Church-Turing thesis</a> implies that any computable operator (and its operands) can be represented in lambda calculus.</p>

<p>Using such an encoding,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:145">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mi>n</mi>
   <mo>⇒</mo>
   <mi>x</mi>
   <mo>=</mo>
   <mfrac>
    <mi>n</mi>
    <mi>x</mi>
   </mfrac>
   <mo>⇒</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mi>n</mi>
     <mi>x</mi>
    </mfrac>
    <mi mathvariant="italic">and</mi>
    <mpadded width="+5pt">
     <mi>Y</mi>
    </mpadded>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <ci>x</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <ci>x</ci>
      </apply>
      <ci>italic- and</ci>
      <ci>Y</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}=n\Rightarrow x=\frac{n}{x}\Rightarrow f\ x=\frac{n}{x}\and Y\ f=x
  </annotation>
 </semantics>
</math>

</p>

<p>Using the implementation of <a href="Church_encoding#Division" title="wikilink">divide</a> then,</p>

<p>

<math display="block" id="Deductive_lambda_calculus:146">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>divide</mo>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Y</ci>
    <apply>
     <ci>divide</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y(\operatorname{divide}n)
  </annotation>
 </semantics>
</math>

</p>

<p>represents two values in the domain of the signed numbers, if <em>n</em> is not equal to zero. However it is a lambda expression so has only one value in the lambda calculus domain. Beta reduction of this lambda term never reaches normal form. However it represents a value, so a single value in the lambda calculus domain represents two values in the signed number domain.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Lambda_calculus" title="wikilink">Lambda calculus</a></li>
<li><a href="Let_expression" title="wikilink">Let expression</a></li>
<li><a href="Church_encoding" title="wikilink">Church encoding</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Lambda_calculus" title="wikilink">Category:Lambda calculus</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">A. Church, "A set of postulates for the foundation of logic", <em>Annals of Mathematics</em>, Series 2, 33:346–366 (1932).<a href="#fnref1">↩</a></li>
<li id="fn2">For a full history, see Cardone and Hindley's "History of Lambda-calculus and Combinatory Logic" (2006).<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">The Inconsistency of Certain Formal Logic Haskell B. Curry The Journal of Symbolic Logic Vol. 7, No. 3 (Sep., 1942), pp. 115-117 Published by: Association for Symbolic Logic Article Stable URL: <a class="uri" href="http://www.jstor.org/stable/2269292">http://www.jstor.org/stable/2269292</a><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
