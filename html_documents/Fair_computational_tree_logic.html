<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="417">Fair computational tree logic</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Fair computational tree logic</h1>
<hr/>

<p><strong>Fair computational tree logic</strong> is conventional <a href="computational_tree_logic" title="wikilink">computational tree logic</a> studied with explicit fairness constraints.</p>
<h2 id="weak-fairness-justice">Weak fairness / justice</h2>

<p>This declares conditions such as all processes are executing infinitely often. If you consider the processes to be P<sub>i</sub>, then the condition becomes:</p>

<p>

<math display="block" id="Fair_computational_tree_logic:0">
 <semantics>
  <mrow>
   <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
   <mrow>
    <mi>G</mi>
    <mi>F</mi>
    <msub>
     <mi>P</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigwedge GFP_{i}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="strong-fairness-compassion">Strong fairness / compassion</h2>

<p>Here, if a process is requesting a resource infinitely often (R), it should be allowed to get the resource (C) infinitely often:</p>

<p>

<math display="block" id="Fair_computational_tree_logic:1">
 <semantics>
  <mrow>
   <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mi>F</mi>
    <mi>R</mi>
    <mo>⟶</mo>
    <mi>G</mi>
    <mi>F</mi>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">G</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-⟶</ci>
     <csymbol cd="unknown">G</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigwedge(GFR\longrightarrow GFC)
  </annotation>
 </semantics>
</math>

</p>
<h2 id="model-checking-for-fair-ctl">Model checking for fair CTL</h2>

<p>If you consider a Kripke Model, the fair Kripke Model has a set of States F. A path 

<math display="inline" id="Fair_computational_tree_logic:2">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>s</mi>
     <mi>o</mi>
    </msub>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>s</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>π</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>o</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi=s_{o},s_{1}\dots
  </annotation>
 </semantics>
</math>

 is considered a fair path, if and only if the path includes all members of F infinitely often.<br/>
Fair CTL model checking restricts the checks to only fair paths. There are two kinds:</p>
<dl>
<dd>1. M<sub>f</sub>,s<sub>i</sub> |= A

<math display="inline" id="Fair_computational_tree_logic:3">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Fair_computational_tree_logic:4">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 holds in ALL fair paths.
</dd>
</dl>
<dl>
<dd>2. M<sub>f</sub>,s<sub>i</sub> |= E

<math display="inline" id="Fair_computational_tree_logic:5">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Fair_computational_tree_logic:6">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 holds in one or more fair paths.
</dd>
</dl>

<p>A fair state is one from which at least one fair path originates. This translates to M<sub>f</sub>,s |= EGtrue.</p>
<h2 id="scc-based-approach">SCC-based approach</h2>

<p>The <a href="strongly_connected_component" title="wikilink">strongly connected component</a> (SCC) of a directed graph is a maximally connected graph - all the nodes are reachable from each other. A fair SCC is one that has an edge into at least one node for each of the fair conditions.</p>

<p>To check for fair EG for any formula,</p>
<ol>
<li>Compute what is called the <em>denotation</em> of the formula. Basically all the states such that M, s |= formula.</li>
<li>restrict the model to the denotation.</li>
<li>Find the fair SCC.</li>
<li>Obtain the union of all 3(above).</li>
<li>Compute the states that can reach the union.</li>
</ol>
<h2 id="emerson-lei-algorithm">Emerson Lei algorithm</h2>

<p>The fix point characterization of Exist Globally is given by: [EGφ] = νZ .([φ] ∩ [EXZ ]), which is basically the limit applied according to Kleene's theorem. To fair paths, it becomes [Ef Gφ] = νZ .([φ] ∩<sub>Fi ∈FT</sub> [EX[E(Z U(Z ∧ Fi ))]) which means the formula holds in the current state and the next states and the next to next states until it meets all the members of the fair conditions. This means that, the condition is equivalent to a sort of accepting point where the accepting condition is the entire set of Fair conditions.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Temporal_logic" title="wikilink">Category:Temporal logic</a></p>
</body>
</html>
