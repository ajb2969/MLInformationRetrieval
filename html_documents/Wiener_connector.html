<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1669">Wiener connector</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Wiener connector</h1>
<hr>In mathematics applied to the study of networks, the '''Wiener connector''', named in honor of chemist [[Harry Wiener]] who first introduced the [[Wiener Index]], is a means of maximizing efficiency in connecting specified "query vertices" in a network. Given a [[connected
<p><code>graph|connected]], </code><a href="undirected_graph" title="wikilink"><code>undirected</code> <code>graph</code></a><code> and a set of query vertices in a graph, the </code><strong><code>minimum</code> <code>Wiener</code> <code>connector</code></strong><code> is a vertices-induced </code><a href="subgraph" title="wikilink"><code>subgraph</code></a><code> that connects the query vertices and minimizes the sum of </code><a href="shortest_path" title="wikilink"><code>shortest</code> <code>path</code></a><code> distances among all pairs of vertices in the subgraph. In </code><a href="combinatorial_optimization" title="wikilink"><code>combinatorial</code> <code>optimization</code></a><code>, the </code><strong><code>minimum</code> <code>Wiener</code> <code>connector</code> <code>problem</code></strong><code> is the problem of finding the minimum Wiener connector. It can be thought of as a version of the classic </code><a href="Steiner_tree_problem" title="wikilink"><code>Steiner</code> <code>tree</code> <code>problem</code></a><code> (one of </code><a href="Karp's_21_NP-complete_problems" title="wikilink"><code>Karp's</code> <code>21</code> <code>NP-complete</code> <code>problems</code></a><code>), where instead of minimizing the size of the tree, the objective is to minimize the distances in the subgraph.</code><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>The minimum Wiener connector was first presented by Ruchansky, et. al. in 2015.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>The minimum Wiener connector has applications in many domains where there is a graph structure and an interest in learning about connections between sets of individuals. For example, given a set of patients infected with a viral disease, which other patients should be checked to find the culprit? Or given a set of proteins of interest, which other proteins participate in pathways with them?</p>
<h2 id="problem-definition">Problem definition</h2>

<p>The <a href="Wiener_index" title="wikilink">Wiener index</a> is the sum of shortest path distances in a (sub)graph. Using 

<math display="inline" id="Wiener_connector:0">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(u,v)
  </annotation>
 </semantics>
</math>

 to denote the shortest path between 

<math display="inline" id="Wiener_connector:1">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Wiener_connector:2">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

, the Wiener index of a (sub)graph 

<math display="inline" id="Wiener_connector:3">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>


, denoted 

<math display="inline" id="Wiener_connector:4">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W(S)
  </annotation>
 </semantics>
</math>

, is defined as</p>

<p>

<math display="block" id="Wiener_connector:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>W</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>S</mi>
     </mrow>
    </munder>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>W</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <interval closure="open">
        <ci>u</ci>
        <ci>v</ci>
       </interval>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W(S)=\sum_{(u,v)\in S}d(u,v)
  </annotation>
 </semantics>
</math>

.</p>

<p>The minimum Wiener connector problem is defined as follows. Given an undirected and unweighted graph with vertex set 

<math display="inline" id="Wiener_connector:6">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 and edge set 

<math display="inline" id="Wiener_connector:7">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 and a set of query vertices 

<math display="inline" id="Wiener_connector:8">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>⊆</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>Q</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q\subseteq V
  </annotation>
 </semantics>
</math>


, find a connector 

<math display="inline" id="Wiener_connector:9">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>⊆</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>H</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H\subseteq V
  </annotation>
 </semantics>
</math>

 of minimum Wiener index. More formally, the problem is to compute</p>

<p>

<math display="block" id="Wiener_connector:10">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>arg</mi>
      </mpadded>
      <mi>min</mi>
     </mrow>
     <mi>H</mi>
    </munder>
    <mi>W</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>H</mi>
     <mo>∪</mo>
     <mi>Q</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <times></times>
       <ci>arg</ci>
       <ci>min</ci>
      </apply>
      <ci>H</ci>
     </apply>
     <ci>W</ci>
    </apply>
    <apply>
     <union></union>
     <ci>H</ci>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname*{arg\,min}_{H}W(H\cup Q)
  </annotation>
 </semantics>
</math>

, that is, find a connector 

<math display="inline" id="Wiener_connector:11">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 that minimizes the sum of shortest paths in 

<math display="inline" id="Wiener_connector:12">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="relationship-to-steiner-tree">Relationship to Steiner tree</h2>

<p><a href="File:SteinerExample_nicer.pdf" title="wikilink">thumb|upright=2.0|The optimal solutions to the Steiner tree problem and the minimum Wiener connector can differ. Define the set of query vertices <em>Q</em> by <em>Q</em> = {<em>v</em><sub>1</sub>, …, <em>v</em><sub>10</sub>}. The unique optimal solution to the Steiner tree problem is <em>Q</em> itself, which has Wiener index 165, whereas the optimal solution for the minimum Wiener connector problem is <em>Q</em> ∪ {<em>r</em><sub>1</sub>, <em>r</em><sub>2</sub>}, which has Wiener index 142.</a> The minimum Wiener connector problem is related to the <a href="Steiner_tree_problem" title="wikilink">Steiner tree problem</a>. In the former, the <a href="objective_function" title="wikilink">objective function</a> in the minimization is the Wiener index of the connector, whereas in the latter, the objective function is the sum of the weights of the edges in the connector. The optimum solutions to these problems may differ, given the same graph and set of query vertices. In fact, a solution for the Steiner tree problem may be arbitrarily bad for the minimum Wiener connector problem; the graph on the right provides an example.</p>
<h2 id="computational-complexity">Computational complexity</h2>
<h3 id="hardness">Hardness</h3>

<p>The problem is <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>, and does not admit a <a href="polynomial-time_approximation_scheme" title="wikilink">polynomial-time approximation scheme</a> unless <a href="P_=_NP" title="wikilink"><strong>P</strong> = <strong>NP</strong></a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> This can be proven using the <a class="uri" href="inapproximability" title="wikilink">inapproximability</a> of <a href="vertex_cover" title="wikilink">vertex cover</a> in bounded degree graphs.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Although there is no polynomial-time approximation scheme, there is a polynomial-time constant-factor approximation—an algorithm that finds a connector whose Wiener index is within a constant multiplicative factor of the Wiener index of the optimum connector. In terms of <a href="complexity_class" title="wikilink">complexity classes</a>, the minimum Wiener connector problem is in <strong><a class="uri" href="APX" title="wikilink">APX</a></strong> but is not in <strong>PTAS</strong> unless <strong>P</strong> = <strong>NP</strong>.</p>
<h3 id="exact-algorithms">Exact algorithms</h3>

<p>An exhaustive search over all possible subsets of vertices to find the one that induces the connector of minimum Wiener index yields an algorithm that finds the optimum solution in 

<math display="inline" id="Wiener_connector:13">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <ci>O</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{O(n)}
  </annotation>
 </semantics>
</math>


 time (that is, <a href="exponential_time" title="wikilink">exponential time</a>) on graphs with <em>n</em> vertices. In the special case that there are exactly two query vertices, the optimum solution is the <a href="shortest_path" title="wikilink">shortest path</a> joining the two vertices, so the problem can be solved in <a href="polynomial_time" title="wikilink">polynomial time</a> by computing the shortest path. In fact, for any fixed constant number of query vertices, an optimum solution can be found in polynomial time.</p>
<h3 id="approximation-algorithms">Approximation algorithms</h3>

<p>There is a constant-factor approximation algorithm for the minimum Wiener connector problem that runs in time 

<math display="inline" id="Wiener_connector:14">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>m</mi>
        <mrow>
         <mi>log</mi>
         <mi>n</mi>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>n</mi>
        <mrow>
         <msup>
          <mi>log</mi>
          <mn>2</mn>
         </msup>
         <mi>n</mi>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>q</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>m</ci>
       <apply>
        <log></log>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <log></log>
         <cn type="integer">2</cn>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(q(m\log n+n\log^{2}n))
  </annotation>
 </semantics>
</math>

 on a graph with <em>n</em> vertices, <em>m</em> edges, and <em>q</em> query vertices, roughly the same time it takes to compute shortest-path distances from the query vertices to every other vertex in the graph.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The central approach of this algorithm is to reduce the problem to the vertex-weighted Steiner tree problem, which admits a constant-factor approximation in particular instances related to the minimum Wiener connector problem.</p>
<h2 id="behavior">Behavior</h2>

<p>The minimum Wiener connector behaves like <a href="Centrality#Betweenness_centrality" title="wikilink">betweenness centrality</a>.</p>

<p>When the query vertices belong to the same community, the non-query vertices that form the minimum Wiener connector tend to belong to the same community and have high centrality within the community. Such vertices are likely to be <a class="uri" href="influential" title="wikilink">influential</a> vertices playing leadership roles in the community. In a <a href="social_network" title="wikilink">social network</a>, these influential vertices might be good users for spreading information or to target in a viral marketing campaign.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>When the query vertices belong to different communities, the non-query vertices that form the minimum Wiener connector contain vertices adjacent to edges that bridge the different communities. These vertices span a <a href="Social_Network#Structural_holes" title="wikilink">structural hole</a> in the graph and are important.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="applications">Applications</h2>

<p>The minimum Wiener connector is useful in applications in which one wishes to learn about the relationship between a set of vertices in a graph. For example,</p>
<ul>
<li>in <a class="uri" href="biology" title="wikilink">biology</a>, it provides insight into how a set of proteins in a <a href="protein–protein_interaction" title="wikilink">protein–protein interaction</a> network are related,</li>
<li>in <a href="social_network" title="wikilink">social networks</a> (like <a class="uri" href="Twitter" title="wikilink">Twitter</a>), it demonstrates the communities to which a set of users belong and how these communities are related,</li>
<li>in <a href="computer_network" title="wikilink">computer networks</a>, it may be useful in identifying an efficient way to route a <a class="uri" href="multicast" title="wikilink">multicast</a> message to a set of destinations.</li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:NP-complete_problems" title="wikilink">Category:NP-complete problems</a> <a href="Category:Trees_(graph_theory)" title="wikilink">Category:Trees (graph theory)</a> <a href="Category:Computational_problems_in_graph_theory" title="wikilink">Category:Computational problems in graph theory</a> <a href="Category:Geometric_algorithms" title="wikilink">Category:Geometric algorithms</a> <a href="Category:Geometric_graphs" title="wikilink">Category:Geometric graphs</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://dimacs11.cs.princeton.edu/"><code>DIMACS</code> <code>Steiner</code> <code>Tree</code> <code>Challenge</code></a><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
</ol>
</section>
</hr></body>
</html>
