<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1190">LL grammar</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>LL grammar</h1>
<hr/>

<p>In <a href="formal_language_theory" title="wikilink">formal language theory</a>, an <strong>LL grammar</strong> is a <a href="formal_grammar" title="wikilink">formal grammar</a> that can be <a href="parsing" title="wikilink">parsed</a> by an <a href="LL_parser" title="wikilink">LL parser</a>, which parses the input from <strong>L</strong>eft to right, and constructs a <a href="Context-free_grammar#Derivations_and_syntax_trees" title="wikilink"><strong>L</strong>eftmost derivation</a> of the sentence (hence LL, compared with <a href="LR_parser" title="wikilink">LR parser</a> that constructs a rightmost derivation). A language that has an LL grammar is known as an <strong>LL language</strong>. These form subsets of <a href="deterministic_context-free_grammar" title="wikilink">deterministic context-free grammars</a> (DCFGs) and <a href="deterministic_context-free_language" title="wikilink">deterministic context-free languages</a> (DCFLs), respectively. One says that a given grammar or language "is an LL grammar/language" or simply "is LL" to indicate that it is in this class.</p>

<p>LL parsers are table-based parsers, similar to LR parsers. LL grammars can alternatively be characterized as precisely those that can be parsed by a <a href="predictive_parser" title="wikilink">predictive parser</a> – a <a href="recursive_descent_parser" title="wikilink">recursive descent parser</a> without <a class="uri" href="backtracking" title="wikilink">backtracking</a> – and these can be readily written by hand. This article is about the formal properties of LL grammars; for parsing, see <a href="LL_parser" title="wikilink">LL parser</a> or <a href="recursive_descent_parser" title="wikilink">recursive descent parser</a>.</p>
<h2 id="relation-to-ll-parsers">Relation to LL parsers</h2>

<p>There is a separate LL(<em>k</em>) parser for each natural number <em>k</em> (0, 1, 2, ...). A LL parser is called a LL(<em>k</em>) parser if it uses <em>k</em> <a href="token_(parser)" title="wikilink">tokens</a> of <a href="Parsing#Lookahead" title="wikilink">lookahead</a> when parsing a sentence. A LL(<em>k</em>) parser recognizes the languages generated by some <em>ε</em>-free LL(<em>k</em>) grammar. As allowing more tokens of lookahead makes the parser strictly more powerful, the languages that can be recognized with a LL(<em>k</em>) parser are a strict subset of the languages that can be recognized by a LL(<em>k+n</em>), <em>n &gt; 0</em> parser. This creates a strictly increasing sequence of sets: LL(0) ⊊ LL(1) ⊊ LL(2) ⊊ …. Since these are all DCFLs, a corollary is that for any fixed <em>k</em>, there are DCFLs that cannot be recognized by a LL(<em>k</em>) parser.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>An LL parser is called an LL(*) parser if it is not restricted to a finite <em>k</em> tokens of lookahead, but can make parsing decisions by recognizing whether the following tokens belong to a <a href="regular_language" title="wikilink">regular language</a> (for example by use of a <a href="Deterministic_Finite_Automaton" title="wikilink">Deterministic Finite Automaton</a>), and accordingly there are the set of LL(*) grammars and the set of LL(*) languages.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Although <em>ε</em>-free LL(<em>k</em>) grammars are considered for LL(<em>k</em>) parsers, allowing <em>ε</em>-rules increases the expressive power of the grammar: For every <em>ε</em>-free LL(<em>k+1</em>) grammar, there exists a LL(<em>k</em>) grammar with <em>ε</em>-rules that generates the same language.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="relation-to-other-grammar-classes">Relation to other grammar classes</h2>

<p>Every LL(<em>k</em>) grammar is also a LR(<em>k</em>) grammar. It is also decidable if a given LR(<em>k</em>) grammar is also a LL(<em>m</em>) grammar for some <em>m</em>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> A <em>ε</em>-free LL(1) grammar is also a SLR(1) grammar. A LL(1) grammar with symbols that have both empty and non-empty derivations is also a LALR(1) grammar. A LL(1) grammar with symbols that have only the empty derivation may or may not be LALR(1).<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>LL grammars cannot have rules <a href="left_recursion" title="wikilink">left recursion</a>. Removing left recursion from a context-free grammar is always possible. However, the resulting grammar may be bigger, require more lookahead tokens than preferred to be an LL grammar, or not be an LL grammar at all. LL(<em>k</em>) grammars that are ε-free can be transformed into <a href="Greibach_normal_form" title="wikilink">Greibach normal form</a> (which by definition do not have rules with left recursion) without increasing the lookeahead tokens.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h3 id="simple-deterministic-languages">Simple deterministic languages</h3>

<p>The class of languages having an ε-free LL(1) grammar equals the class of simple deterministic languages,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> the languages generated by <em>simple</em> context-free grammars, which are the context-free grammars in <a href="Greibach_normal_form" title="wikilink">Greibach normal form</a> (i.e. for which each rule has the form 

<math display="inline" id="LL_grammar:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>Z</mi>
    <mo>→</mo>
    <mrow>
     <mi>a</mi>
     <msub>
      <mi>Y</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>Y</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>n</mi>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <ci>normal-→</ci>
     <ci>Z</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Y</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z\rightarrow aY_{1}\ldots Y_{n},n\geq 0
  </annotation>
 </semantics>
</math>

) such that different right hand sides for the same nonterminal 

<math display="inline" id="LL_grammar:1">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 always start with different terminals 

<math display="inline" id="LL_grammar:2">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

.</p>

<p>This language class includes the regular sets with end-markers.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Equivalence is decidable for it, while inclusion is not.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="applications">Applications</h2>

<p>LL grammars, particularly LL(1) grammars, are of great practical interest, as they are easy to parse, either by LL parsers or by recursive descent parsers, and many <a href="computer_language" title="wikilink">computer languages</a> are designed to be LL(1) for this reason. Languages based on grammars with a high value of <em>k</em> have traditionally been considered  to be difficult to parse, although this is less true now given the availability and widespread use  of parser generators supporting LL(<em>k</em>) grammars for arbitrary <em>k</em>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="LR_grammar" title="wikilink">LR grammar</a></li>
<li><a href="Comparison_of_parser_generators" title="wikilink">Comparison of parser generators</a> for a list of LL(k) and LL(*) parsers</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
</ol>
</section>
</body>
</html>
