<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="633">System F</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>System F</h1>
<hr/>

<p><strong>System F</strong>, also known as the <strong>(Girard–Reynolds) polymorphic lambda calculus</strong> or the <strong>second-order lambda calculus</strong>, is a <a href="typed_lambda_calculus" title="wikilink">typed lambda calculus</a> that differs from the <a href="simply_typed_lambda_calculus" title="wikilink">simply typed lambda calculus</a> by the introduction of a mechanism of universal quantification over types. System F thus formalizes the notion of <a href="parametric_polymorphism" title="wikilink">parametric polymorphism</a> in <a href="programming_language" title="wikilink">programming languages</a>, and forms a theoretical basis for languages such as <a href="Haskell_(programming_language)" title="wikilink">Haskell</a> and <a href="ML_(programming_language)" title="wikilink">ML</a>. System F was discovered independently by <a class="uri" href="logician" title="wikilink">logician</a> <a href="Jean-Yves_Girard" title="wikilink">Jean-Yves Girard</a> (1972) and <a href="computer_scientist" title="wikilink">computer scientist</a> <a href="John_C._Reynolds" title="wikilink">John C. Reynolds</a> (1974).</p>

<p>Whereas <a href="simply_typed_lambda_calculus" title="wikilink">simply typed lambda calculus</a> has variables ranging over functions, and binders for them, System F additionally has variables ranging over <em>types</em>, and binders for them. As an example, the fact that the identity function can have any type of the form A→ A would be formalized in System F as the judgment</p>

<p>

<math display="block" id="System_F:0">
 <semantics>
  <mrow>
   <mo>⊢</mo>
   <mi mathvariant="normal">Λ</mi>
   <mi>α</mi>
   <mo>.</mo>
   <mi>λ</mi>
   <msup>
    <mi>x</mi>
    <mi>α</mi>
   </msup>
   <mo>.</mo>
   <mi>x</mi>
   <mo>:</mo>
   <mo>∀</mo>
   <mi>α</mi>
   <mo>.</mo>
   <mi>α</mi>
   <mo>→</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="unknown">Λ</csymbol>
    <csymbol cd="unknown">α</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">λ</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>α</ci>
    </apply>
    <ci>normal-.</ci>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">α</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">α</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">α</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash\Lambda\alpha.\lambda x^{\alpha}.x:\forall\alpha.\alpha\to\alpha
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="System_F:1">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is a <strong><a href="type_variable" title="wikilink">type variable</a></strong>. The upper-case 

<math display="inline" id="System_F:2">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda
  </annotation>
 </semantics>
</math>

 is traditionally used to denote type-level functions, as opposed to the lower-case 

<math display="inline" id="System_F:3">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 which is used for value-level functions. (The superscripted 

<math display="inline" id="System_F:4">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 means that the bound <em>x</em> is of type 

<math display="inline" id="System_F:5">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

; the expression after the colon is the type of the lambda expression preceding it.)</p>

<p>As a <a href="term_rewriting_system" title="wikilink">term rewriting system</a>, System F is <a href="Normalization_property_(lambda-calculus)" title="wikilink">strongly normalizing</a>. However, type inference in System F (without explicit type annotations) is undecidable. Under the <a href="Curry–Howard_isomorphism" title="wikilink">Curry–Howard isomorphism</a>, System F corresponds to the fragment of second-order <a href="intuitionistic_logic" title="wikilink">intuitionistic logic</a> that uses only universal quantification. System F can be seen as part of the <a href="lambda_cube" title="wikilink">lambda cube</a>, together with even more expressive typed lambda calculi, including those with <a href="dependent_types" title="wikilink">dependent types</a>.</p>
<h2 id="logic-and-predicates">Logic and predicates</h2>

<p>The 

<math display="inline" id="System_F:6">
 <semantics>
  <mi>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathsf{Boolean}
  </annotation>
 </semantics>
</math>

 type is defined as: 

<math display="inline" id="System_F:7">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>α</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>α</mi>
    <mo>→</mo>
    <mi>α</mi>
    <mo>→</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>α</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <ci>α</ci>
      <ci>α</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <ci>α</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\forall\alpha.\alpha\to\alpha\to\alpha
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="System_F:8">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\alpha
  </annotation>
 </semantics>
</math>

 is a <a href="type_variable" title="wikilink">type variable</a>. This means

<math display="block" id="System_F:9">
 <semantics>
  <mi>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathsf{Boolean}
  </annotation>
 </semantics>
</math>

 is the type of all functions which take as input a type α and two expressions of type α, and produce as output an expression of type α (note that we consider 

<math display="inline" id="System_F:10">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>

 to be right-associative.)</p>

<p>The following two definitions for the boolean values 

<math display="inline" id="System_F:11">
 <semantics>
  <mi>𝐓</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐓</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathbf{T}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="System_F:12">
 <semantics>
  <mi>𝐅</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐅</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathbf{F}
  </annotation>
 </semantics>
</math>

 are used, extending the definition of <a href="Church_encoding#Church_Booleans" title="wikilink">Church booleans</a>:</p>

<p>

<math display="block" id="System_F:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐓</mi>
    <mo>=</mo>
    <mrow>
     <mi mathvariant="normal">Λ</mi>
     <mi>α</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <msup>
     <mi>x</mi>
     <mi>α</mi>
    </msup>
    <mi>λ</mi>
    <msup>
     <mi>y</mi>
     <mi>α</mi>
    </msup>
   </mrow>
   <mo>.</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>𝐓</ci>
     <apply>
      <times></times>
      <ci>normal-Λ</ci>
      <ci>α</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>α</ci>
     </apply>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>α</ci>
     </apply>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{T}=\Lambda\alpha{.}\lambda x^{\alpha}\lambda y^{\alpha}{.}x
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="System_F:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐅</mi>
    <mo>=</mo>
    <mrow>
     <mi mathvariant="normal">Λ</mi>
     <mi>α</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <msup>
     <mi>x</mi>
     <mi>α</mi>
    </msup>
    <mi>λ</mi>
    <msup>
     <mi>y</mi>
     <mi>α</mi>
    </msup>
   </mrow>
   <mo>.</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>𝐅</ci>
     <apply>
      <times></times>
      <ci>normal-Λ</ci>
      <ci>α</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>α</ci>
     </apply>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>α</ci>
     </apply>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{F}=\Lambda\alpha{.}\lambda x^{\alpha}\lambda y^{\alpha}{.}y
  </annotation>
 </semantics>
</math>

</p>

<p>(Note that the above two functions require <em>three</em> — not two — parameters. The latter two should be lambda expressions, but the first one should be a type. This fact is reflected in the fact that the type of these expressions is 

<math display="inline" id="System_F:15">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>α</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>α</mi>
    <mo>→</mo>
    <mi>α</mi>
    <mo>→</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>α</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <ci>α</ci>
      <ci>α</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <ci>α</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\forall\alpha.\alpha\to\alpha\to\alpha
  </annotation>
 </semantics>
</math>

; the universal quantifier binding the α corresponds to the Λ binding the alpha in the lambda expression itself. Also, note that 

<math display="inline" id="System_F:16">
 <semantics>
  <mi>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathsf{Boolean}
  </annotation>
 </semantics>
</math>

 is a convenient shorthand for 

<math display="inline" id="System_F:17">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>α</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>α</mi>
    <mo>→</mo>
    <mi>α</mi>
    <mo>→</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>α</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <ci>α</ci>
      <ci>α</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <ci>α</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\forall\alpha.\alpha\to\alpha\to\alpha
  </annotation>
 </semantics>
</math>

, but it is not a symbol of System F itself, but rather a "meta-symbol". Likewise, 

<math display="inline" id="System_F:18">
 <semantics>
  <mi>𝐓</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐓</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathbf{T}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="System_F:19">
 <semantics>
  <mi>𝐅</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐅</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathbf{F}
  </annotation>
 </semantics>
</math>

 are also "meta-symbols", convenient shorthands, of System F "assemblies" (in the [<a class="uri" href="http://books.google.com/books?id=IL-SI67hjI4C&amp;printsec">http://books.google.com/books?id=IL-SI67hjI4C&amp;printsec;</a>;=frontcover&amp;dq;=Nicolas+Bourbaki&amp;source;=bl&amp;ots;=nbfmxi9gJK&amp;sig;=4nPo8EFXrQYwAC2y0pD0uGv-EGY&amp;hl;=en&amp;sa;=X&amp;ei;=3sYBUOukIMLW2AX4t_inCw&amp;ved;=0CD8Q6AEwAg#v=onepage&amp;q;=Nicolas%20Bourbaki&amp;f;=false Bourbaki sense]); otherwise, if such functions could be named (within System F), then there would be no need for the lambda-expressive apparatus capable of defining functions anonymously.)</p>

<p>Then, with these two 

<math display="inline" id="System_F:20">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\lambda
  </annotation>
 </semantics>
</math>

-terms, we can define some logic operators (which are of type 

<math display="inline" id="System_F:21">
 <semantics>
  <mrow>
   <mi>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</mi>
   <mo>→</mo>
   <mi>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</mi>
   <mo>→</mo>
   <mi>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <ci>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</ci>
     <ci>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathsf{Boolean}\rightarrow\mathsf{Boolean}\rightarrow\mathsf{Boolean}
  </annotation>
 </semantics>
</math>

):</p>

<p>

<math display="block" id="System_F:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>AND</mi>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <msup>
      <mi>x</mi>
      <mi>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</mi>
     </msup>
     <mi>λ</mi>
     <msup>
      <mi>y</mi>
      <mi>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>x</mi>
    </mpadded>
    <mpadded width="+1.7pt">
     <mi>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</mi>
    </mpadded>
    <mpadded width="+1.7pt">
     <mi>y</mi>
    </mpadded>
    <mi>𝐅</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>AND</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</ci>
      </apply>
      <ci>λ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</ci>
     <ci>y</ci>
     <ci>𝐅</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{AND}=\lambda x^{\mathsf{Boolean}}\lambda y^{\mathsf{Boolean}}{.}x\,%
\mathsf{Boolean}\,y\,\mathbf{F}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="System_F:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>OR</mi>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <msup>
      <mi>x</mi>
      <mi>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</mi>
     </msup>
     <mi>λ</mi>
     <msup>
      <mi>y</mi>
      <mi>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>x</mi>
    </mpadded>
    <mpadded width="+1.7pt">
     <mi>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</mi>
    </mpadded>
    <mpadded width="+1.7pt">
     <mi>𝐓</mi>
    </mpadded>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>OR</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</ci>
      </apply>
      <ci>λ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</ci>
     <ci>𝐓</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{OR}=\lambda x^{\mathsf{Boolean}}\lambda y^{\mathsf{Boolean}}{.}x\,%
\mathsf{Boolean}\,\mathbf{T}\,y
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="System_F:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>NOT</mi>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <msup>
      <mi>x</mi>
      <mi>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>x</mi>
    </mpadded>
    <mpadded width="+1.7pt">
     <mi>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</mi>
    </mpadded>
    <mpadded width="+1.7pt">
     <mi>𝐅</mi>
    </mpadded>
    <mi>𝐓</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>NOT</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</ci>
     <ci>𝐅</ci>
     <ci>𝐓</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{NOT}=\lambda x^{\mathsf{Boolean}}{.}x\,\mathsf{Boolean}\,\mathbf{F}\,%
\mathbf{T}
  </annotation>
 </semantics>
</math>

</p>

<p>As in Church encodings, there is no need for an <code>IFTHENELSE</code> function as one can just use raw 

<math display="inline" id="System_F:25">
 <semantics>
  <mi>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathsf{Boolean}
  </annotation>
 </semantics>
</math>

-typed terms as decision functions. However, if one is requested:</p>

<p>

<math display="block" id="System_F:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>IFTHENELSE</mi>
    <mo>=</mo>
    <mrow>
     <mi mathvariant="normal">Λ</mi>
     <mi>α</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <msup>
     <mi>x</mi>
     <mi>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</mi>
    </msup>
    <mi>λ</mi>
    <msup>
     <mi>y</mi>
     <mi>α</mi>
    </msup>
    <mi>λ</mi>
    <msup>
     <mi>z</mi>
     <mi>α</mi>
    </msup>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>x</mi>
    <mi>α</mi>
    <mi>y</mi>
    <mi>z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>IFTHENELSE</ci>
     <apply>
      <times></times>
      <ci>normal-Λ</ci>
      <ci>α</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</ci>
     </apply>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>α</ci>
     </apply>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <ci>α</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>α</ci>
     <ci>y</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{IFTHENELSE}=\Lambda\alpha.\lambda x^{\mathsf{Boolean}}\lambda y^{%
\alpha}\lambda z^{\alpha}.x\alpha yz
  </annotation>
 </semantics>
</math>

 will do. A <em>predicate</em> is a function which returns a 

<math display="inline" id="System_F:27">
 <semantics>
  <mi>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathsf{Boolean}
  </annotation>
 </semantics>
</math>

-typed value. The most fundamental predicate is <code>ISZERO</code> which returns 

<math display="inline" id="System_F:28">
 <semantics>
  <mi>𝐓</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐓</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathbf{T}
  </annotation>
 </semantics>
</math>

 if and only if its argument is the <a href="Church_encoding#Church_numerals" title="wikilink">Church numeral</a> <code>0</code>:</p>

<p>

<math display="block" id="System_F:29">
 <semantics>
  <mrow>
   <mi>ISZERO</mi>
   <mo>=</mo>
   <mi>λ</mi>
   <msup>
    <mi>n</mi>
    <mrow>
     <mo>∀</mo>
     <mi>α</mi>
     <mo>.</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>α</mi>
      <mo>→</mo>
      <mi>α</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>→</mo>
     <mi>α</mi>
     <mo>→</mo>
     <mi>α</mi>
    </mrow>
   </msup>
   <mo>.</mo>
   <mpadded width="+1.7pt">
    <mi>n</mi>
   </mpadded>
   <mpadded width="+1.7pt">
    <mi>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <msup>
     <mi>x</mi>
     <mi>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</mi>
    </msup>
    <mo>.</mo>
    <mi>𝐅</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
   <mi>𝐓</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">ISZERO</csymbol>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">α</csymbol>
      <ci>normal-.</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">α</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">α</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <csymbol cd="unknown">α</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">α</csymbol>
     </cerror>
    </apply>
    <ci>normal-.</ci>
    <csymbol cd="unknown">n</csymbol>
    <csymbol cd="unknown">Boolean</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>𝖡𝗈𝗈𝗅𝖾𝖺𝗇</ci>
     </apply>
     <ci>normal-.</ci>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">T</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{ISZERO}=\lambda n^{\forall\alpha.(\alpha\rightarrow\alpha)\rightarrow%
\alpha\rightarrow\alpha}{.}n\,\mathsf{Boolean}\,(\lambda x^{\mathsf{Boolean}}{%
.}\mathbf{F})\,\mathbf{T}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="system-f-structures">System F Structures</h2>

<p>System F allows recursive constructions to be embedded in a natural manner, related to that in <a href="Martin-Löf's_type_theory" title="wikilink">Martin-Löf's type theory</a>. Abstract structures (S) are created using <em>constructors</em>. These are functions typed as:</p>

<p>

<math display="block" id="System_F:30">
 <semantics>
  <mrow>
   <msub>
    <mi>K</mi>
    <mn>1</mn>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>K</mi>
    <mn>2</mn>
   </msub>
   <mo>→</mo>
   <mi mathvariant="normal">…</mi>
   <mo>→</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-…</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{1}\rightarrow K_{2}\rightarrow\dots\rightarrow S
  </annotation>
 </semantics>
</math>

.</p>

<p>Recursivity is manifested when 

<math display="inline" id="System_F:31">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 itself appears within one of the types 

<math display="inline" id="System_F:32">
 <semantics>
  <msub>
   <mi>K</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{i}
  </annotation>
 </semantics>
</math>

. If you have 

<math display="inline" id="System_F:33">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 of these constructors, you can define the type of 

<math display="inline" id="System_F:34">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 as:</p>

<p>

<math display="block" id="System_F:35">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>α</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>K</mi>
     <mn>1</mn>
     <mn>1</mn>
    </msubsup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>α</mi>
     <mo>/</mo>
     <mi>S</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>→</mo>
    <mi mathvariant="normal">…</mi>
    <mo>→</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal">…</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>K</mi>
     <mn>1</mn>
     <mi>m</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>α</mi>
     <mo>/</mo>
     <mi>S</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>→</mo>
    <mi mathvariant="normal">…</mi>
    <mo>→</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">α</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">α</csymbol>
      <divide></divide>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-→</ci>
     <ci>normal-…</ci>
     <ci>normal-→</ci>
     <csymbol cd="unknown">α</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-…</ci>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>m</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">α</csymbol>
      <divide></divide>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-→</ci>
     <ci>normal-…</ci>
     <ci>normal-→</ci>
     <csymbol cd="unknown">α</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">α</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\alpha.(K_{1}^{1}[\alpha/S]\rightarrow\dots\rightarrow\alpha)\dots%
\rightarrow(K_{1}^{m}[\alpha/S]\rightarrow\dots\rightarrow\alpha)\rightarrow\alpha
  </annotation>
 </semantics>
</math>

</p>

<p>For instance, the natural numbers can be defined as an inductive datatype 

<math display="inline" id="System_F:36">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 with constructors</p>

<p>

<math display="block" id="System_F:37">
 <semantics>
  <mrow>
   <mi>𝑧𝑒𝑟𝑜</mi>
   <mo>:</mo>
   <mi mathvariant="normal">N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>𝑧𝑒𝑟𝑜</ci>
    <ci>normal-N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{zero}:\mathrm{N}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="System_F:38">
 <semantics>
  <mrow>
   <mi>𝑠𝑢𝑐𝑐</mi>
   <mo>:</mo>
   <mrow>
    <mi mathvariant="normal">N</mi>
    <mo>→</mo>
    <mi mathvariant="normal">N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>𝑠𝑢𝑐𝑐</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>normal-N</ci>
     <ci>normal-N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{succ}:\mathrm{N}\rightarrow\mathrm{N}
  </annotation>
 </semantics>
</math>

 The System F type corresponding to this structure is 

<math display="inline" id="System_F:39">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>α</mi>
   <mo>.</mo>
   <mi>α</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo>→</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">α</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">α</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">α</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">α</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">α</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\alpha.\alpha\to(\alpha\to\alpha)\to\alpha
  </annotation>
 </semantics>
</math>

. The terms of this type comprise a typed version of the <a href="Church_numeral" title="wikilink">Church numerals</a>, the first few of which are:</p>
<dl>
<dd><code>0 := </code>

<math display="inline" id="System_F:40">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Λ</mi>
    <mi>α</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <msup>
     <mi>x</mi>
     <mi>α</mi>
    </msup>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <msup>
     <mi>f</mi>
     <mrow>
      <mi>α</mi>
      <mo>→</mo>
      <mi>α</mi>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>normal-Λ</ci>
     <ci>α</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>α</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>α</ci>
       <ci>α</ci>
      </apply>
     </apply>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda\alpha.\lambda x^{\alpha}.\lambda f^{\alpha\to\alpha}.x
  </annotation>
 </semantics>
</math>


</dd>
<dd><code>1 := </code>

<math display="inline" id="System_F:41">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Λ</mi>
    <mi>α</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <msup>
     <mi>x</mi>
     <mi>α</mi>
    </msup>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <msup>
     <mi>f</mi>
     <mrow>
      <mi>α</mi>
      <mo>→</mo>
      <mi>α</mi>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>f</mi>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>normal-Λ</ci>
     <ci>α</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>α</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>α</ci>
       <ci>α</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda\alpha.\lambda x^{\alpha}.\lambda f^{\alpha\to\alpha}.fx
  </annotation>
 </semantics>
</math>


</dd>
<dd><code>2 := </code>

<math display="inline" id="System_F:42">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Λ</mi>
    <mi>α</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <msup>
     <mi>x</mi>
     <mi>α</mi>
    </msup>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <msup>
     <mi>f</mi>
     <mrow>
      <mi>α</mi>
      <mo>→</mo>
      <mi>α</mi>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>normal-Λ</ci>
     <ci>α</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>α</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>α</ci>
       <ci>α</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda\alpha.\lambda x^{\alpha}.\lambda f^{\alpha\to\alpha}.f(fx)
  </annotation>
 </semantics>
</math>


</dd>
<dd><code>3 := </code>

<math display="inline" id="System_F:43">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Λ</mi>
    <mi>α</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <msup>
     <mi>x</mi>
     <mi>α</mi>
    </msup>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>λ</mi>
    <msup>
     <mi>f</mi>
     <mrow>
      <mi>α</mi>
      <mo>→</mo>
      <mi>α</mi>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>f</mi>
        <mi>x</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>normal-Λ</ci>
     <ci>α</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>α</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>α</ci>
       <ci>α</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda\alpha.\lambda x^{\alpha}.\lambda f^{\alpha\to\alpha}.f(f(fx))
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>If we reverse the order of the curried arguments (<em>i.e.,</em> 

<math display="inline" id="System_F:44">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>α</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo>→</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>α</mi>
   <mo>→</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">α</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">α</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">α</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">α</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">α</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\alpha.(\alpha\rightarrow\alpha)\rightarrow\alpha\rightarrow\alpha
  </annotation>
 </semantics>
</math>

), then the Church numeral for 

<math display="inline" id="System_F:45">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is a function that takes a function <code>''f''</code> as argument and returns the 

<math display="inline" id="System_F:46">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

<sup>th</sup> power of <code>''f''</code>. That is to say, a Church numeral is a <a href="higher-order_function" title="wikilink">higher-order function</a> – it takes a single-argument function <code>''f''</code>, and returns another single-argument function.</p>
<h2 id="use-in-programming-languages">Use in programming languages</h2>

<p>The version of System F used in this article is as an explicitly typed, or Church-style, calculus. The typing information contained in λ-terms makes <a class="uri" href="type-checking" title="wikilink">type-checking</a> straightforward. <a href="Joe_Wells" title="wikilink">Joe Wells</a> (1994) settled an "embarrassing open problem" by proving that type checking is <a href="decision_problem" title="wikilink">undecidable</a> for a Curry-style variant of System F, that is, one that lacks explicit typing annotations.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Wells' result implies that <a href="type_inference" title="wikilink">type inference</a> for System F is impossible. A restriction of System F known as "<a class="uri" href="Hindley–Milner" title="wikilink">Hindley–Milner</a>", or simply "HM", does have an easy type inference algorithm and is used for many <a href="statically_typed" title="wikilink">statically typed</a> <a href="functional_programming_languages" title="wikilink">functional programming languages</a> such as <a href="Haskell_(programming_language)" title="wikilink">Haskell 98</a> and <a href="ML_programming_language" title="wikilink">ML</a>. Over time, as the restrictions of HM-style type systems have become apparent, languages have steadily moved to more expressive logics for their type systems. As of 2008, <a href="Glasgow_Haskell_Compiler" title="wikilink">GHC</a>, a Haskell compiler, goes beyond HM, and now uses System F extended with non-syntactic type equality, for example.</p>
<h2 id="system-fω">System F<sub>ω</sub></h2>

<p>While System F corresponds to the first axis of the Barendregt's <a href="lambda_cube" title="wikilink">lambda cube</a>, <strong>System F<sub>ω</sub></strong> or the <strong>higher-order polymorphic lambda calculus</strong> combines the first axis (polymorphism) with the second axis (<a href="type_operator" title="wikilink">type operators</a>); it is a different, more complex system.</p>

<p>System F<sub>ω</sub> can be defined inductively on a family of systems, where induction is based on the <a href="Kind_(type_theory)" title="wikilink">kinds</a> permitted in each system:</p>
<ul>
<li>

<math display="inline" id="System_F:47">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{n}
  </annotation>
 </semantics>
</math>

 permits kinds:
<ul>
<li>

<math display="inline" id="System_F:48">
 <semantics>
  <mo>⋆</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⋆</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \star
  </annotation>
 </semantics>
</math>

 (the kind of types) and</li>
<li>

<math display="inline" id="System_F:49">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mo>⇒</mo>
   <mi>K</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇒</ci>
    <ci>J</ci>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J\Rightarrow K
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="System_F:50">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mo>∈</mo>
   <msub>
    <mi>F</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>J</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J\in F_{n-1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="System_F:51">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>∈</mo>
   <msub>
    <mi>F</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>K</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\in F_{n}
  </annotation>
 </semantics>
</math>

 (the kind of functions from types to types, where the argument type is of a lower order)</li>
</ul></li>
</ul>

<p>In the limit, we can define system 

<math display="inline" id="System_F:52">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>ω</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{\omega}
  </annotation>
 </semantics>
</math>

 to be</p>
<ul>
<li>

<math display="inline" id="System_F:53">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mi>ω</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munder accentunder="true">
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋃</mo>
     <mrow>
      <mn>1</mn>
      <mo>≤</mo>
      <mi>i</mi>
     </mrow>
    </munder>
    <msub>
     <mi>F</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>ω</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <leq></leq>
       <cn type="integer">1</cn>
       <ci>i</ci>
      </apply>
      <union></union>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{\omega}=\underset{1\leq i}{\bigcup}F_{i}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>That is, F<sub>ω</sub> is the system which allows functions from types to types where the argument (and result) may be of any order.</p>

<p>Note that although F<sub>ω</sub> places no restrictions on the <em>order</em> of the arguments in these mappings, it does restrict the <em>universe</em> of the arguments for these mappings: they must be types rather than values. System F<sub>ω</sub> does not permit mappings from values to types (<a href="Dependent_types" title="wikilink">Dependent types</a>), though it does permit mappings from values to values (

<math display="inline" id="System_F:54">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 abstraction), mappings from types to values (

<math display="inline" id="System_F:55">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda
  </annotation>
 </semantics>
</math>

 abstraction, sometimes written 

<math display="inline" id="System_F:56">
 <semantics>
  <mo>∀</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">for-all</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall
  </annotation>
 </semantics>
</math>

) and mappings from types to types (

<math display="inline" id="System_F:57">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 abstraction at the level of types)</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Existential_types" title="wikilink">Existential types</a> are the <a href="existentially_quantified" title="wikilink">existentially quantified</a> counterparts of universal types.</li>
<li><a href="System_F-sub" title="wikilink">System F<sub>&lt;:&gt;<!--:--></sub></a> extends system F with <a class="uri" href="subtyping" title="wikilink">subtyping</a>, bringing it a lot closer to actual programming languages from the ML family.</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>

<p>.</p></li>
<li></li>
<li>Girard, Lafont and Taylor, <a href="http://www.PaulTaylor.EU/stable/Proofs%2BTypes.html"><em>Proofs and Types</em></a>. Cambridge University Press, 1989, ISBN 0-521-37181-3.</li>
<li>J. B. Wells. "Typability and type checking in the second-order lambda-calculus are equivalent and undecidable." In <em>Proceedings of the 9th Annual <a class="uri" href="IEEE" title="wikilink">IEEE</a> Symposium on Logic in Computer Science (LICS),</em> pages 176–185, 1994. <a href="http://www.macs.hw.ac.uk/~jbw/papers/Wells:Typability-and-Type-Checking-in-the-Second-Order-Lambda-Calculus-Are-Equivalent-and-Undecidable:LICS-1994.ps.gz">1</a></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>

<p>, Chapter 23: Universal Types, and Chapter 25: An ML Implementation of System F</p></li>
</ul>

<p>{{-}}</p>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.site.uottawa.ca/~fbinard/Intuitionism/TypeTheory/SystemF/">Summary of System F</a> by Franck Binard.</li>
<li><a href="http://www.eecs.harvard.edu/~greg/cs256sp2005/lec16.txt">System F<sub>ω</sub>: the workhorse of modern compilers</a> by <a href="Greg_Morrisett" title="wikilink">Greg Morrisett</a></li>
</ul>

<p>"</p>

<p><a href="Category:1971_in_computer_science" title="wikilink">Category:1971 in computer science</a> <a href="Category:1974_in_computer_science" title="wikilink">Category:1974 in computer science</a> <a href="Category:Lambda_calculus" title="wikilink">Category:Lambda calculus</a> <a href="Category:Type_theory" title="wikilink">Category:Type theory</a> <a href="Category:Polymorphism_(computer_science)" title="wikilink">Category:Polymorphism (computer science)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a class="uri" href="http://www.macs.hw.ac.uk/~jbw/research-summary.html">http://www.macs.hw.ac.uk/~jbw/research-summary.html</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a class="uri" href="http://web.archive.org/web/20070929211126/http://www.church-project.org/reports/Wells:APAL-1999-v98-no-note.html">http://web.archive.org/web/20070929211126/http://www.church-project.org/reports/Wells:APAL-1999-v98-no-note.html</a><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
