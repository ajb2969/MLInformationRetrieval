<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1424">Projection (linear algebra)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Projection (linear algebra)</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>The transformation <em>P</em> is the orthogonal projection onto the line <em>m</em>.</figcaption>
</figure>

<p>In <a href="linear_algebra" title="wikilink">linear algebra</a> and <a href="functional_analysis" title="wikilink">functional analysis</a>, a <strong>projection</strong> is a <a href="linear_transformation" title="wikilink">linear transformation</a> <em>P</em> from a <a href="vector_space" title="wikilink">vector space</a> to itself such that <mtpl></mtpl>. That is, whenever <em>P</em> is applied twice to any value, it gives the same result as if it were applied once (<a href="Idempotence" title="wikilink">idempotent</a>). It leaves its image unchanged.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Though abstract, this definition of "projection" formalizes and generalizes the idea of <a href="graphical_projection" title="wikilink">graphical projection</a>. One can also consider the effect of a projection on a <a href="geometry" title="wikilink">geometrical</a> object by examining the effect of the projection on <a href="point_(geometry)" title="wikilink">points</a> in the object.</p>
<h2 id="simple-example">Simple example</h2>
<h3 id="orthogonal-projection">Orthogonal projection</h3>

<p>For example, the function which maps the point  in three-dimensional space <strong>R</strong><sup>3</sup> to the point  is an orthogonal projection onto the <em>x</em>–<em>y</em> plane. This function is represented by the <a href="matrix_(mathematics)" title="wikilink">matrix</a></p>

<p>

<math display="block" id="Projection_(linear_algebra):0">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=\begin{bmatrix}1&0&0\\
0&1&0\\
0&0&0\end{bmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>The action of this matrix on an arbitrary vector is</p>

<p>

<math display="block" id="Projection_(linear_algebra):1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mi>x</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi>y</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi>z</mi>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mi>x</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi>y</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <matrix>
      <matrixrow>
       <ci>x</ci>
      </matrixrow>
      <matrixrow>
       <ci>y</ci>
      </matrixrow>
      <matrixrow>
       <ci>z</ci>
      </matrixrow>
     </matrix>
    </apply>
    <matrix>
     <matrixrow>
      <ci>x</ci>
     </matrixrow>
     <matrixrow>
      <ci>y</ci>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\begin{pmatrix}x\\
y\\
z\end{pmatrix}=\begin{pmatrix}x\\
y\\
0\end{pmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>To see that <em>P</em> is indeed a projection, i.e., <mtpl></mtpl>, we compute</p>

<p>

<math display="block" id="Projection_(linear_algebra):2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>P</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mi>x</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi>y</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi>z</mi>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mi>x</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi>y</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mi>x</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi>y</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mi>x</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi>y</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi>z</mi>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>P</ci>
       <cn type="integer">2</cn>
      </apply>
      <matrix>
       <matrixrow>
        <ci>x</ci>
       </matrixrow>
       <matrixrow>
        <ci>y</ci>
       </matrixrow>
       <matrixrow>
        <ci>z</ci>
       </matrixrow>
      </matrix>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <matrix>
       <matrixrow>
        <ci>x</ci>
       </matrixrow>
       <matrixrow>
        <ci>y</ci>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <ci>x</ci>
      </matrixrow>
      <matrixrow>
       <ci>y</ci>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>P</ci>
      <matrix>
       <matrixrow>
        <ci>x</ci>
       </matrixrow>
       <matrixrow>
        <ci>y</ci>
       </matrixrow>
       <matrixrow>
        <ci>z</ci>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{2}\begin{pmatrix}x\\
y\\
z\end{pmatrix}=P\begin{pmatrix}x\\
y\\
0\end{pmatrix}=\begin{pmatrix}x\\
y\\
0\end{pmatrix}=P\begin{pmatrix}x\\
y\\
z\end{pmatrix}.
  </annotation>
 </semantics>
</math>

</p>
<h3 id="oblique-projection">Oblique projection</h3>

<p>A simple example of a non-orthogonal (oblique) projection (for definition see below) is</p>

<p>

<math display="block" id="Projection_(linear_algebra):3">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi>α</mi>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <ci>α</ci>
      <cn type="integer">1</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=\begin{bmatrix}0&0\\
\alpha&1\end{bmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>Via <a href="matrix_multiplication" title="wikilink">matrix multiplication</a>, one sees that</p>

<p>

<math display="block" id="Projection_(linear_algebra):4">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>P</mi>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi>α</mi>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi>α</mi>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi>α</mi>
       </mtd>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mo>=</mo>
    <mi>P</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <matrix>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <ci>α</ci>
        <cn type="integer">1</cn>
       </matrixrow>
      </matrix>
      <matrix>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <ci>α</ci>
        <cn type="integer">1</cn>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{2}=\begin{bmatrix}0&0\\
\alpha&1\end{bmatrix}\begin{bmatrix}0&0\\
\alpha&1\end{bmatrix}=\begin{bmatrix}0&0\\
\alpha&1\end{bmatrix}=P.
  </annotation>
 </semantics>
</math>

</p>

<p>proving that <em>P</em> is indeed a projection.</p>

<p>The projection P is orthogonal if and only if .</p>
<h2 id="properties-and-classification">Properties and classification</h2>
<figure><b>(Figure)</b>
<figcaption>The transformation <em>T</em> is the projection along <em>k</em> onto <em>m</em>. The range of <em>T</em> is <em>m</em> and the null space is <em>k</em>.</figcaption>
</figure>

<p>Let <em>W</em> be a finite dimensional vector space and <em>P</em> be a projection on <em>W</em>. Suppose the <a href="Linear_subspace" title="wikilink">subspaces</a> <em>U</em> and <em>V</em> are the <a href="range_of_a_matrix" title="wikilink">range</a> and <a href="null_space" title="wikilink">kernel</a> of <em>P</em> respectively. Then <em>P</em> has the following basic properties:</p>
<ol>
<li>By definition, <em>P</em> is <a class="uri" href="idempotent" title="wikilink">idempotent</a> (i.e. <mtpl></mtpl>).</li>
<li><em>P</em> is the identity operator <em>I</em> on <em>U</em>

<p>

<math display="block" id="Projection_(linear_algebra):5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>x</mi>
    </mrow>
    <mo>∈</mo>
    <mi>U</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mi>x</mi>
    </mrow>
    <mo>=</mo>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>x</ci>
     </apply>
     <ci>U</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>x</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\in U:Px=x
  </annotation>
 </semantics>
</math>

.</p></li>
<li>We have a <a href="direct_sum_of_vector_spaces" title="wikilink">direct sum</a> . Every vector <em>x</em> in <em>W</em> may be decomposed uniquely as  with  and , and where <em>u</em> is in <em>U</em> and <em>v</em> is in <em>V</em>.</li>
</ol>

<p>The range and kernel of a projection are <em>complementary</em>, as are <em>P</em> and . The operator <em>Q</em> is also a projection and the range and kernel of P become the kernel and range of Q and vice versa. We say <em>P</em> is a projection along <em>V</em> onto <em>U</em> (kernel/range) and <em>Q</em> is a projection along <em>U</em> onto <em>V</em>.</p>

<p>In infinite dimensional vector spaces <a href="Spectrum_(functional_analysis)" title="wikilink">spectrum</a> of a projection is contained in {0, 1}, as</p>

<p>

<math display="block" id="Projection_(linear_algebra):6">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>λ</mi>
       <mi>I</mi>
      </mrow>
      <mo>-</mo>
      <mi>P</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>λ</mi>
     </mfrac>
     <mi>I</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mi>λ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>λ</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
     <mi>P</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>λ</ci>
       <ci>I</ci>
      </apply>
      <ci>P</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>λ</ci>
      </apply>
      <ci>I</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>λ</ci>
        <apply>
         <minus></minus>
         <ci>λ</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda I-P)^{-1}=\frac{1}{\lambda}I+\frac{1}{\lambda(\lambda-1)}P
  </annotation>
 </semantics>
</math>

. Only 0 and 1 can be an <a class="uri" href="eigenvalue" title="wikilink">eigenvalue</a> of a projection. The corresponding eigenspaces are (respectively) the kernel and range of the projection. Decomposition of a vector space into direct sums is not unique in general. Therefore, given a subspace <em>V</em>, there may be many projections whose range (or kernel) is <em>V</em>.</p>

<p>If a projection is nontrivial it has <a href="minimal_polynomial_(linear_algebra)" title="wikilink">minimal polynomial</a> <mtpl></mtpl>, which factors into distinct roots, and thus <em>P</em> is <a class="uri" href="diagonalizable" title="wikilink">diagonalizable</a>.</p>

<p>The product of projections is not, in general, a projection, even if they are orthogonal. If projections commute, then their product is a projection.</p>
<h3 id="orthogonal-projections">Orthogonal projections</h3>

<p>When the vector space <em>W</em> has an <a href="inner_product" title="wikilink">inner product</a> and is <a href="complete_metric_space" title="wikilink">complete</a> (is a <a href="Hilbert_space" title="wikilink">Hilbert space</a>) the concept of <a class="uri" href="orthogonality" title="wikilink">orthogonality</a> can be used. An <strong>orthogonal projection</strong> is a projection for which the range <em>U</em> and the null space <em>V</em> are <a href="orthogonality" title="wikilink">orthogonal subspaces</a>. Thus, for every <em>x</em> and <em>y</em> in <em>W</em>, 

<math display="inline" id="Projection_(linear_algebra):7">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>P</mi>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>y</mi>
      <mo>-</mo>
      <mrow>
       <mi>P</mi>
       <mi>y</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mrow>
       <mi>P</mi>
       <mi>x</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>P</mi>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>y</ci>
       <apply>
        <times></times>
        <ci>P</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </list>
     <list>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>P</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>y</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle Px,(y-Py)\rangle=\langle(x-Px),Py\rangle=0
  </annotation>
 </semantics>
</math>

. Equivalently:</p>

<p>

<math display="block" id="Projection_(linear_algebra):8">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mrow>
     <mi>P</mi>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>P</mi>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>P</mi>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>P</mi>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <list>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>y</ci>
      </apply>
     </list>
     <list>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>y</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <list>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>x</ci>
      </apply>
      <ci>y</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x,Py\rangle=\langle Px,Py\rangle=\langle Px,y\rangle
  </annotation>
 </semantics>
</math>

.</p>

<p>A projection is orthogonal if and only if it is <a href="self-adjoint_operator" title="wikilink">self-adjoint</a>. Using the self-adjoint and idempotent properties of <em>P</em>, for any <em>x</em> and <em>y</em> in <em>W</em> we have , , and</p>

<p>

<math display="block" id="Projection_(linear_algebra):9">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>P</mi>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>y</mi>
     <mo>-</mo>
     <mrow>
      <mi>P</mi>
      <mi>y</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <msup>
      <mi>P</mi>
      <mn>2</mn>
     </msup>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>y</mi>
     <mo>-</mo>
     <mrow>
      <mi>P</mi>
      <mi>y</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>P</mi>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>I</mi>
       <mo>-</mo>
       <mi>P</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>P</mi>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>P</mi>
       <mo>-</mo>
       <msup>
        <mi>P</mi>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>y</ci>
       <apply>
        <times></times>
        <ci>P</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </list>
     <list>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>P</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>y</ci>
       <apply>
        <times></times>
        <ci>P</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <list>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <minus></minus>
        <ci>I</ci>
        <ci>P</ci>
       </apply>
       <ci>y</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <list>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <ci>P</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>P</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>y</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle Px,y-Py\rangle=\langle P^{2}x,y-Py\rangle=\langle Px,P(I-P)y\rangle=%
\langle Px,(P-P^{2})y\rangle=0\,
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Projection_(linear_algebra):10">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mo>⋅</mo>
   <mo>,</mo>
   <mo>⋅</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>normal-⋅</ci>
    <ci>normal-⋅</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\cdot,\cdot\rangle
  </annotation>
 </semantics>
</math>

 is the <a href="inner_product" title="wikilink">inner product</a> associated with <em>W</em>. Therefore, <em>Px</em> and  are orthogonal.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The other direction, namely that if <em>P</em> is orthogonal then it is self-adjoint, follows from</p>

<p>

<math display="block" id="Projection_(linear_algebra):11">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mrow>
     <mi>P</mi>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>P</mi>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mrow>
     <msup>
      <mi>P</mi>
      <mo>*</mo>
     </msup>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <list>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>y</ci>
      </apply>
     </list>
     <list>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>x</ci>
      </apply>
      <ci>y</ci>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <list>
      <ci>x</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>P</ci>
        <times></times>
       </apply>
       <ci>y</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x,Py\rangle=\langle Px,y\rangle=\langle x,P^{*}y\rangle
  </annotation>
 </semantics>
</math>

 for every <em>x</em> and <em>y</em> in <em>W</em>; thus <mtpl></mtpl>.</p>
<dl>
<dd>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Proof of existence</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Let <em>H</em> be a complete metric space with an <a href="inner_product" title="wikilink">inner product</a>, and let <em>U</em> be a closed <a href="linear_subspace" title="wikilink">linear subspace</a> of <em>H</em> (and hence complete as well). For every <em>x</em> the following set of non-negative <a href="Normed_vector_space" title="wikilink">norms</a> 

<math display="inline" id="Projection_(linear_algebra):12">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo>∥</mo>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <mi>u</mi>
    </mrow>
    <mo>∥</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi>u</mi>
    <mo>∈</mo>
    <mi>U</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <ci>u</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>u</ci>
     <ci>U</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\|x-u\||u\in U\}
  </annotation>
 </semantics>
</math>

 has an <a class="uri" href="infimum" title="wikilink">infimum</a>, and due to the completeness of <em>U</em> it is a <a class="uri" href="minimum" title="wikilink">minimum</a>. We define <em>Px</em> as the point in <em>U</em> were this minimum is obtained. Obviously <em>Px</em> is in <em>U</em>. It remains to show that <em>Px</em> satisfies  and that it is linear. Let us define 

<math display="inline" id="Projection_(linear_algebra):13">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>-</mo>
    <mrow>
     <mi>P</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <apply>
     <minus></minus>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=x-Px
  </annotation>
 </semantics>
</math>

. For every non-zero <em>v</em> in <em>U</em>, the following holds:</p>

<p>

<math display="block" id="Projection_(linear_algebra):14">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>a</mi>
      <mo>-</mo>
      <mrow>
       <mfrac>
        <mrow>
         <mo stretchy="false">⟨</mo>
         <mi>a</mi>
         <mo>,</mo>
         <mi>v</mi>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <msup>
         <mrow>
          <mo>∥</mo>
          <mi>v</mi>
          <mo>∥</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mfrac>
       <mi>v</mi>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo>∥</mo>
      <mi>a</mi>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mfrac>
     <msup>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>a</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <msup>
      <mrow>
       <mo>∥</mo>
       <mi>v</mi>
       <mo>∥</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <ci>a</ci>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <list>
          <ci>a</ci>
          <ci>v</ci>
         </list>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="latexml">norm</csymbol>
           <ci>v</ci>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <ci>v</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>a</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <list>
        <ci>a</ci>
        <ci>v</ci>
       </list>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>v</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|a-\frac{\langle a,v\rangle}{\|v\|^{2}}v\|^{2}=\|a\|^{2}-\frac{{\langle a,v%
\rangle}^{2}}{\|v\|^{2}}
  </annotation>
 </semantics>
</math>

 By defining 

<math display="inline" id="Projection_(linear_algebra):15">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <mi>a</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <msup>
       <mrow>
        <mo>∥</mo>
        <mi>v</mi>
        <mo>∥</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mfrac>
     <mi>v</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>w</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <list>
        <ci>a</ci>
        <ci>v</ci>
       </list>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <ci>v</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w=Px+\frac{\langle a,v\rangle}{\|v\|^{2}}v
  </annotation>
 </semantics>
</math>

 we see that 

<math display="inline" id="Projection_(linear_algebra):16">
 <semantics>
  <mrow>
   <mrow>
    <mo>∥</mo>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <mi>w</mi>
    </mrow>
    <mo>∥</mo>
   </mrow>
   <mo><</mo>
   <mrow>
    <mo>∥</mo>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <mrow>
      <mi>P</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>∥</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <ci>w</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|x-w\|<\|x-Px\|
  </annotation>
 </semantics>
</math>

 unless 

<math display="inline" id="Projection_(linear_algebra):17">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>v</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>a</ci>
    <ci>v</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle a,v\rangle
  </annotation>
 </semantics>
</math>

 vanishes. Since <em>Px</em> was chosen as the minimum of the abovementioned set, it follows that 

<math display="inline" id="Projection_(linear_algebra):18">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>v</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>a</ci>
    <ci>v</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle a,v\rangle
  </annotation>
 </semantics>
</math>

 indeed vanishes. In particular, (for )

<math display="block" id="Projection_(linear_algebra):19">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <mrow>
      <mi>P</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>P</mi>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>x</ci>
     </apply>
    </list>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x-Px,Px\rangle=0
  </annotation>
 </semantics>
</math>

. Linearity follows from the vanishing of 

<math display="inline" id="Projection_(linear_algebra):20">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mrow>
    <mi>x</mi>
    <mo>-</mo>
    <mrow>
     <mi>P</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi>v</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <minus></minus>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <ci>v</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x-Px,v\rangle
  </annotation>
 </semantics>
</math>

 for every <em>v</em> in <em>U</em>:</p>

<p>

<math display="block" id="Projection_(linear_algebra):21">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mrow>
    <mo>(</mo>
    <mi>x</mi>
    <mo>+</mo>
    <mi>y</mi>
    <mo>)</mo>
   </mrow>
   <mo>-</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>(</mo>
     <mi>x</mi>
     <mo>+</mo>
     <mi>y</mi>
     <mo>)</mo>
    </mrow>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-⟨</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <plus></plus>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <minus></minus>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <plus></plus>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">0</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\left(x+y\right)-P(\left(x+y\right),v\rangle=0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Projection_(linear_algebra):22">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mrow>
        <mi>P</mi>
        <mi>x</mi>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>y</mi>
       <mo>-</mo>
       <mrow>
        <mi>P</mi>
        <mi>y</mi>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>P</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>y</ci>
       <apply>
        <times></times>
        <ci>P</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
     <ci>v</ci>
    </list>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\left(x-Px\right)+\left(y-Py\right),v\rangle=0
  </annotation>
 </semantics>
</math>

 By taking the difference between the equations we have</p>

<p>

<math display="block" id="Projection_(linear_algebra):23">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>P</mi>
   <mi>x</mi>
   <mo>+</mo>
   <mi>P</mi>
   <mi>y</mi>
   <mo>-</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>(</mo>
     <mi>x</mi>
     <mo>+</mo>
     <mi>y</mi>
     <mo>)</mo>
    </mrow>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-⟨</ci>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <plus></plus>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <minus></minus>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <plus></plus>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">0</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle Px+Py-P(\left(x+y\right),v\rangle=0
  </annotation>
 </semantics>
</math>

 But since we may choose  (as it is itself in <em>U</em>) it follows that . Similarly we have  for every <a href="Scalar_(mathematics)" title="wikilink">scalar</a> <em>λ</em>.</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<h4 id="properties-and-special-cases">Properties and special cases</h4>

<p>An orthogonal projection is a <a href="bounded_operator" title="wikilink">bounded operator</a>. This is because for every <em>v</em> in the vector space we have, by <a href="Cauchy–Schwarz_inequality" title="wikilink">Cauchy–Schwarz inequality</a>:</p>

<p>

<math display="block" id="Projection_(linear_algebra):24">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>P</mi>
      <mi>v</mi>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>P</mi>
     <mi>v</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>P</mi>
     <mi>v</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>P</mi>
     <mi>v</mi>
    </mrow>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>P</mi>
      <mi>v</mi>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mo>⋅</mo>
    <mrow>
     <mo>∥</mo>
     <mi>v</mi>
     <mo>∥</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <times></times>
        <ci>P</ci>
        <ci>v</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <list>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>v</ci>
      </apply>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>v</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <list>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>v</ci>
      </apply>
      <ci>v</ci>
     </list>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <times></times>
        <ci>P</ci>
        <ci>v</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|Pv\|^{2}=\langle Pv,Pv\rangle=\langle Pv,v\rangle\leq\|Pv\|\cdot\|v\|
  </annotation>
 </semantics>
</math>

 Thus 

<math display="inline" id="Projection_(linear_algebra):25">
 <semantics>
  <mrow>
   <mrow>
    <mo>∥</mo>
    <mrow>
     <mi>P</mi>
     <mi>v</mi>
    </mrow>
    <mo>∥</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mo>∥</mo>
    <mi>v</mi>
    <mo>∥</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|Pv\|\leq\|v\|
  </annotation>
 </semantics>
</math>

.</p>

<p>For finite dimensional complex or real vector spaces, the <a href="standard_inner_product" title="wikilink">standard inner product</a> can be substituted for 

<math display="inline" id="Projection_(linear_algebra):26">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mo>⋅</mo>
   <mo>,</mo>
   <mo>⋅</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>normal-⋅</ci>
    <ci>normal-⋅</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\cdot,\cdot\rangle
  </annotation>
 </semantics>
</math>

.</p>
<h5 id="formulas">Formulas</h5>

<p>A simple case occurs when the orthogonal projection is onto a line. If <em>u</em> is a <a href="unit_vector" title="wikilink">unit vector</a> on the line, then the projection is given by the <a href="outer_product" title="wikilink">outer product</a></p>

<p>

<math display="block" id="Projection_(linear_algebra):27">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>P</mi>
     <mi>u</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>u</mi>
     <msup>
      <mi>u</mi>
      <mi mathvariant="normal">T</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>u</ci>
    </apply>
    <apply>
     <times></times>
     <ci>u</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>u</ci>
      <ci>normal-T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{u}=uu^{\mathrm{T}}.\,
  </annotation>
 </semantics>
</math>

 This operator leaves <em>u</em> invariant, and it annihilates all vectors orthogonal to <em>u</em>, proving that it is indeed the orthogonal projection onto the line containing <em>u</em>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> A simple way to see this is to consider an arbitrary vector 

<math display="inline" id="Projection_(linear_algebra):28">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 as the sum of a component on the line (i.e. the projected vector we seek) and another perpendicular to it, 

<math display="inline" id="Projection_(linear_algebra):29">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mo>∥</mo>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>x</mi>
     <mo>⟂</mo>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <csymbol cd="latexml">parallel-to</csymbol>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <csymbol cd="latexml">perpendicular-to</csymbol>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=x_{\parallel}+x_{\perp}
  </annotation>
 </semantics>
</math>

. Applying projection, we get</p>

<p>

<math display="block" id="Projection_(linear_algebra):30">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>P</mi>
     <mi>u</mi>
    </msub>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>u</mi>
     <msup>
      <mi>u</mi>
      <mi mathvariant="normal">T</mi>
     </msup>
     <msub>
      <mi>x</mi>
      <mo>∥</mo>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>u</mi>
     <msup>
      <mi>u</mi>
      <mi mathvariant="normal">T</mi>
     </msup>
     <msub>
      <mi>x</mi>
      <mo>⟂</mo>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>u</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>sign</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msup>
          <mi>u</mi>
          <mi mathvariant="normal">T</mi>
         </msup>
         <msub>
          <mi>x</mi>
          <mo>∥</mo>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>∥</mo>
        <msub>
         <mi>x</mi>
         <mo>∥</mo>
        </msub>
        <mo>∥</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>u</mi>
     <mo>⋅</mo>
     <mover accent="true">
      <mn>0</mn>
      <mo stretchy="false">→</mo>
     </mover>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mo>∥</mo>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>u</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>u</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>u</ci>
        <ci>normal-T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <csymbol cd="latexml">parallel-to</csymbol>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>u</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>u</ci>
        <ci>normal-T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <csymbol cd="latexml">perpendicular-to</csymbol>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>u</ci>
       <apply>
        <times></times>
        <ci>sign</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>u</ci>
          <ci>normal-T</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <csymbol cd="latexml">parallel-to</csymbol>
         </apply>
        </apply>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <csymbol cd="latexml">parallel-to</csymbol>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <ci>u</ci>
       <apply>
        <ci>normal-→</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <csymbol cd="latexml">parallel-to</csymbol>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{u}x=uu^{\mathrm{T}}x_{\parallel}+uu^{\mathrm{T}}x_{\perp}=u(\mathrm{sign}(u%
^{\mathrm{T}}x_{\parallel})\|x_{\parallel}\|)+u\cdot\vec{0}=x_{\parallel}
  </annotation>
 </semantics>
</math>

 by the properties of the <a href="dot_product" title="wikilink">dot product</a> of parallel and perpendicular vectors.</p>

<p>This formula can be generalized to orthogonal projections on a subspace of arbitrary dimension. Let <mtpl></mtpl> be an <a href="orthonormal_basis" title="wikilink">orthonormal basis</a> of the subspace <em>U</em>, and let <em>A</em> denote the <em>n</em>-by-<em>k</em> matrix whose columns are <mtpl></mtpl>. Then the projection is given by</p>

<p>

<math display="block" id="Projection_(linear_algebra):31">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>A</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <msup>
     <mi>A</mi>
     <mi mathvariant="normal">T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>normal-T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{A}=AA^{\mathrm{T}}
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> which can be rewritten as</p>

<p>

<math display="block" id="Projection_(linear_algebra):32">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>P</mi>
     <mi>A</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <mrow>
      <mrow>
       <mo stretchy="false">⟨</mo>
       <msub>
        <mi>u</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <mo>⋅</mo>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <msub>
       <mi>u</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-⋅</ci>
      </list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{A}=\sum_{i}\langle u_{i},\cdot\rangle u_{i}.
  </annotation>
 </semantics>
</math>

</p>

<p>The matrix <em>A</em><sup>T</sup> is the <a href="partial_isometry" title="wikilink">partial isometry</a> that vanishes on the orthogonal complement of <em>U</em> and <em>A</em> is the isometry that embeds <em>U</em> into the underlying vector space. The range of <em>P<sub>A</sub></em> is therefore the <em>final space</em> of <em>A</em>. It is also clear that <em>A</em>·<em>A</em><sup>T</sup> is the identity operator on <em>U</em>.</p>

<p>The orthonormality condition can also be dropped. If <mtpl></mtpl> is a (not necessarily orthonormal) basis, and <em>A</em> is the matrix with these vectors as columns, then the projection is</p>

<p>

<math display="block" id="Projection_(linear_algebra):33">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>P</mi>
     <mi>A</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>A</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>A</mi>
         <mi mathvariant="normal">T</mi>
        </msup>
        <mi>A</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <msup>
      <mi>A</mi>
      <mi mathvariant="normal">T</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <ci>normal-T</ci>
       </apply>
       <ci>A</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>normal-T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{A}=A(A^{\mathrm{T}}A)^{-1}A^{\mathrm{T}}.
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>The matrix <em>A</em> still embeds <em>U</em> into the underlying vector space but is no longer an isometry in general. The matrix (<em>A</em><sup>T</sup><em>A</em>)<sup>−1</sup> is a "normalizing factor" that recovers the norm. For example, the rank-1 operator <em>uu</em><sup>T</sup> is not a projection if ||<em>u</em>|| ≠ 1. After dividing by <em>u</em><sup>T</sup><em>u</em> = ||<em>u</em>||<sup>2</sup>, we obtain the projection <em>u</em>(<em>u</em><sup>T</sup><em>u</em>)<sup>−1</sup><em>u</em><sup>T</sup> onto the subspace spanned by <em>u</em>.</p>

<p>When the range space of the projection is generated by a <a href="Frame_of_a_vector_space" title="wikilink">frame</a> (i.e. the number of generators is greater than its dimension), the formula for the projection takes the form: 

<math display="inline" id="Projection_(linear_algebra):34">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>A</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>A</mi>
        <mi mathvariant="normal">T</mi>
       </msup>
       <mi>A</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
    </msup>
    <msup>
     <mi>A</mi>
     <mi mathvariant="normal">T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <ci>normal-T</ci>
       </apply>
       <ci>A</ci>
      </apply>
      <plus></plus>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>normal-T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{A}=A(A^{\mathrm{T}}A)^{+}A^{\mathrm{T}}
  </annotation>
 </semantics>
</math>

. Here <em>A</em><sup>+</sup> stands for the <a href="Moore–Penrose_pseudoinverse" title="wikilink">Moore–Penrose pseudoinverse</a>. This is just one of many ways to construct the projection operator.</p>

<p>If a matrix 

<math display="inline" id="Projection_(linear_algebra):35">
 <semantics>
  <mrow>
   <mo lspace="4.2pt" stretchy="false">[</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>A</mi>
    </mpadded>
    <mi>B</mi>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,[A\ B]
  </annotation>
 </semantics>
</math>

 is non-singular and <mtpl></mtpl> (i.e., <em>B</em> is the <a href="null_space" title="wikilink">null space</a> matrix of <em>A</em>),<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> the following holds:</p>

<p>

<math display="inline" id="Projection_(linear_algebra):36">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle I
  </annotation>
 </semantics>
</math>


.</p>

<p>If the orthogonal condition is enhanced to <mtpl></mtpl> with <em>W</em> being non-singular, the following holds:</p>

<p>

<math display="block" id="Projection_(linear_algebra):37">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mi>A</mi>
        </mtd>
        <mtd columnalign="center">
         <mi>B</mi>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <msup>
              <mi>A</mi>
              <mi mathvariant="normal">T</mi>
             </msup>
             <mi>W</mi>
             <mi>A</mi>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
           <mrow>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msup>
          <msup>
           <mi>A</mi>
           <mi mathvariant="normal">T</mi>
          </msup>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <msup>
              <mi>B</mi>
              <mi mathvariant="normal">T</mi>
             </msup>
             <mi>W</mi>
             <mi>B</mi>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
           <mrow>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msup>
          <msup>
           <mi>B</mi>
           <mi mathvariant="normal">T</mi>
          </msup>
         </mrow>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
     <mi>W</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>I</ci>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <ci>A</ci>
       <ci>B</ci>
      </matrixrow>
     </matrix>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>A</ci>
           <ci>normal-T</ci>
          </apply>
          <ci>W</ci>
          <ci>A</ci>
         </apply>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>A</ci>
         <ci>normal-T</ci>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>B</ci>
           <ci>normal-T</ci>
          </apply>
          <ci>W</ci>
          <ci>B</ci>
         </apply>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>B</ci>
         <ci>normal-T</ci>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
     <ci>W</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I=\begin{bmatrix}A&B\end{bmatrix}\begin{bmatrix}(A^{\mathrm{T}}WA)^{-1}A^{%
\mathrm{T}}\\
(B^{\mathrm{T}}WB)^{-1}B^{\mathrm{T}}\end{bmatrix}W.
  </annotation>
 </semantics>
</math>

</p>

<p>All these formulas also hold for complex inner product spaces, provided that the <a href="conjugate_transpose" title="wikilink">conjugate transpose</a> is used instead of the transpose.</p>
<h3 id="oblique-projections">Oblique projections</h3>

<p>The term <em>oblique projections</em> is sometimes used to refer to non-orthogonal projections. These projections are also used to represent spatial figures in two-dimensional drawings (see <a href="oblique_projection" title="wikilink">oblique projection</a>), though not as frequently as orthogonal projections.</p>

<p>Oblique projections are defined by their range and null space. A formula for the matrix representing the projection with a given range and null space can be found as follows. Let the vectors <em>u</em><sub>1</sub>, ..., <em>u</em><sub><em>k</em></sub> form a basis for the range of the projection, and assemble these vectors in the <em>n</em>-by-<em>k</em> matrix <em>A</em>. The range and the null space are complementary spaces, so the null space has dimension . It follows that the <a href="orthogonal_complement" title="wikilink">orthogonal complement</a> of the null space has dimension <em>k</em>. Let <em>v</em><sub>1</sub>, ..., <em>v</em><sub><em>k</em></sub> form a basis for the orthogonal complement of the null space of the projection, and assemble these vectors in the matrix <em>B</em>. Then the projection is defined by</p>

<p>

<math display="block" id="Projection_(linear_algebra):38">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mo>=</mo>
    <mrow>
     <mi>A</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>B</mi>
         <mi mathvariant="normal">T</mi>
        </msup>
        <mi>A</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <msup>
      <mi>B</mi>
      <mi mathvariant="normal">T</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>B</ci>
        <ci>normal-T</ci>
       </apply>
       <ci>A</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>normal-T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=A(B^{\mathrm{T}}A)^{-1}B^{\mathrm{T}}.
  </annotation>
 </semantics>
</math>

 This expression generalizes the formula for orthogonal projections given above.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="canonical-forms">Canonical forms</h2>

<p>Any projection <mtpl> <em>P</em><sup>2</sup>}}</mtpl> on a vector space of dimension <em>d</em> over a field is a <a href="diagonalizable_matrix" title="wikilink">diagonalizable matrix</a>, since its <a href="minimal_polynomial_(linear_algebra)" title="wikilink">minimal polynomial</a> is <mtpl></mtpl>, which splits into distinct linear factors. Thus there exists a basis in which <em>P</em> has the form</p>

<p>

<math display="block" id="Projection_(linear_algebra):39">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>I</mi>
     <mi>r</mi>
    </msub>
    <mo>⊕</mo>
    <msub>
     <mn>0</mn>
     <mrow>
      <mi>d</mi>
      <mo>-</mo>
      <mi>r</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>r</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">0</cn>
      <apply>
       <minus></minus>
       <ci>d</ci>
       <ci>r</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=I_{r}\oplus 0_{d-r}
  </annotation>
 </semantics>
</math>

 where <em>r</em> is the rank of <em>P</em>. Here <em>I</em><sub><em>r</em></sub> is the identity matrix of size <em>r</em>, and 0<sub><em>d</em>−<em>r</em></sub> is the zero matrix of size . If the vector space is complex and equipped with an <a href="inner_product" title="wikilink">inner product</a>, then there is an <em>orthonormal</em> basis in which the matrix of <em>P</em> is<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>

<math display="block" id="Projection_(linear_algebra):40">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>σ</mi>
         <mn>1</mn>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mo>⊕</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>⊕</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>σ</mi>
         <mi>k</mi>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mo>⊕</mo>
    <msub>
     <mi>I</mi>
     <mi>m</mi>
    </msub>
    <mo>⊕</mo>
    <msub>
     <mn>0</mn>
     <mi>s</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
     </matrix>
     <ci>normal-⋯</ci>
     <matrix>
      <matrixrow>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <ci>k</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
     </matrix>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">0</cn>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=\begin{bmatrix}1&\sigma_{1}\\
0&0\end{bmatrix}\oplus\cdots\oplus\begin{bmatrix}1&\sigma_{k}\\
0&0\end{bmatrix}\oplus I_{m}\oplus 0_{s}
  </annotation>
 </semantics>
</math>

 .</p>

<p>where <mtpl></mtpl>. The integers <em>k</em>, <em>s</em>, <em>m</em> and the real numbers 

<math display="inline" id="Projection_(linear_algebra):41">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{i}
  </annotation>
 </semantics>
</math>

 are uniquely determined. Note that . The factor <mtpl></mtpl> corresponds to the maximal invariant subspace on which <em>P</em> acts as an <em>orthogonal</em> projection (so that <em>P</em> itself is orthogonal if and only if ) and the <em>σ</em><sub><em>i</em></sub>-blocks correspond to the <em>oblique</em> components.</p>
<h2 id="projections-on-normed-vector-spaces">Projections on normed vector spaces</h2>

<p>When the underlying vector space <em>X</em> is a (not necessarily finite-dimensional) <a href="normed_vector_space" title="wikilink">normed vector space</a>, analytic questions, irrelevant in the finite-dimensional case, need to be considered. Assume now <em>X</em> is a <a href="Banach_space" title="wikilink">Banach space</a>.</p>

<p>Many of the algebraic notions discussed above survive the passage to this context. A given direct sum decomposition of <em>X</em> into complementary subspaces still specifies a projection, and vice versa. If <em>X</em> is the direct sum , then the operator defined by  is still a projection with range <em>U</em> and kernel <em>V</em>. It is also clear that <mtpl></mtpl>. Conversely, if <em>P</em> is projection on <em>X</em>, i.e. <mtpl></mtpl>, then it is easily verified that <mtpl></mtpl>. In other words,  is also a projection. The relation  implies <em>X</em> is the direct sum .</p>

<p>However, in contrast to the finite-dimensional case, projections need not be <a href="bounded_linear_operator" title="wikilink">continuous</a> in general. If a subspace <em>U</em> of <em>X</em> is not closed in the norm topology, then projection onto <em>U</em> is not continuous. In other words, the range of a continuous projection <em>P</em> must be a closed subspace. Furthermore, the kernel of a continuous projection (in fact, a continuous linear operator in general) is closed. Thus a <em>continuous</em> projection <em>P</em> gives a decomposition of <em>X</em> into two complementary <em>closed</em> subspaces: .</p>

<p>The converse holds also, with an additional assumption. Suppose <em>U</em> is a closed subspace of <em>X</em>. <em>If</em> there exists a closed subspace <em>V</em> such that , then the projection <em>P</em> with range <em>U</em> and kernel <em>V</em> is continuous. This follows from the <a href="closed_graph_theorem" title="wikilink">closed graph theorem</a>. Suppose <mtpl></mtpl> and <mtpl></mtpl>. One needs to show that . Since <em>U</em> is closed and , <em>y</em> lies in <em>U</em>, i.e. . Also, <mtpl></mtpl>. Because <em>V</em> is closed and , we have , i.e. , which proves the claim.</p>

<p>The above argument makes use of the assumption that both <em>U</em> and <em>V</em> are closed. In general, given a closed subspace <em>U</em>, there need not exist a complementary closed subspace <em>V</em>, although for <a href="Hilbert_space" title="wikilink">Hilbert spaces</a> this can always be done by taking the <a href="orthogonal_complement" title="wikilink">orthogonal complement</a>. For Banach spaces, a one-dimensional subspace always has a closed complementary subspace. This is an immediate consequence of <a href="Hahn–Banach_theorem" title="wikilink">Hahn–Banach theorem</a>. Let <em>U</em> be the linear span of <em>u</em>. By Hahn–Banach, there exists a bounded linear functional <em>φ</em> such that . The operator  satisfies <mtpl></mtpl>, i.e. it is a projection. Boundedness of <em>φ</em> implies continuity of <em>P</em> and therefore  is a closed complementary subspace of <em>U</em>.</p>
<h2 id="applications-and-further-considerations">Applications and further considerations</h2>

<p>Projections (orthogonal and otherwise) play a major role in <a href="algorithm" title="wikilink">algorithms</a> for certain linear algebra problems:</p>
<ul>
<li><a href="QR_decomposition" title="wikilink">QR decomposition</a> (see <a href="Householder_transformation" title="wikilink">Householder transformation</a> and <a href="Gram–Schmidt_decomposition" title="wikilink">Gram–Schmidt decomposition</a>);</li>
<li><a href="Singular_value_decomposition" title="wikilink">Singular value decomposition</a></li>
<li>Reduction to <a href="Hessenberg_matrix" title="wikilink">Hessenberg</a> form (the first step in many <a href="eigenvalue_algorithm" title="wikilink">eigenvalue algorithms</a>).</li>
<li><a href="Linear_regression" title="wikilink">Linear regression</a></li>
</ul>

<p>As stated above, projections are a special case of idempotents. Analytically, orthogonal projections are non-commutative generalizations of <a href="characteristic_polynomial" title="wikilink">characteristic functions</a>. Idempotents are used in classifying, for instance, <a href="semisimple_algebra" title="wikilink">semisimple algebras</a>, while measure theory begins with considering characteristic functions of measurable sets. Therefore, as one can imagine, projections are very often encountered in the context <a href="operator_algebra" title="wikilink">operator algebras</a>. In particular, a <a href="von_Neumann_algebra" title="wikilink">von Neumann algebra</a> is generated by its complete <a href="lattice_(order)" title="wikilink">lattice</a> of projections.</p>
<h2 id="generalizations">Generalizations</h2>

<p>More generally, given a map between normed vector spaces 

<math display="inline" id="Projection_(linear_algebra):42">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mo>:</mo>
    <mrow>
     <mi>V</mi>
     <mo>→</mo>
     <mi>W</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>T</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>V</ci>
     <ci>W</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\colon V\to W,
  </annotation>
 </semantics>
</math>


 one can analogously ask for this map to be an isometry on the orthogonal complement of the kernel: that 

<math display="inline" id="Projection_(linear_algebra):43">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ker</mi>
      <mi>T</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⟂</mo>
   </msup>
   <mo>→</mo>
   <mi>W</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">kernel</csymbol>
      <ci>T</ci>
     </apply>
     <csymbol cd="latexml">perpendicular-to</csymbol>
    </apply>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\ker T)^{\perp}\to W
  </annotation>
 </semantics>
</math>

 be an isometry (compare <a href="Partial_isometry" title="wikilink">Partial isometry</a>); in particular it must be onto. The case of an orthogonal projection is when <em>W</em> is a subspace of <em>V.</em> In <a href="Riemannian_geometry" title="wikilink">Riemannian geometry</a>, this is used in the definition of a <a href="Riemannian_submersion" title="wikilink">Riemannian submersion</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Centering_matrix" title="wikilink">Centering matrix</a>, which is an example of a projection matrix.</li>
<li><a class="uri" href="Orthogonalization" title="wikilink">Orthogonalization</a></li>
<li><a href="Invariant_subspace" title="wikilink">Invariant subspace</a></li>
<li><a href="Trace_(linear_algebra)#Properties" title="wikilink">Properties of trace</a></li>
<li><a href="Dykstra's_projection_algorithm" title="wikilink">Dykstra's projection algorithm</a> to compute the projection onto an intersection of sets</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>[<a class="uri" href="http://www.youtube.com/watch?v=osh80YCg_GM&amp;feature">http://www.youtube.com/watch?v=osh80YCg_GM&amp;feature;</a>;=PlayList&amp;p;=38823D6325151CED&amp;index;=16 MIT Linear Algebra Lecture on Projection Matrices] at Google Video, from MIT OpenCourseWare</li>
<li><a href="https://www.cs.mtsu.edu/~jhankins/pages/planeview3D/tutorial.html">Planar Geometric Projections Tutorial</a> – a simple-to-follow tutorial explaining the different types of planar geometric projections.</li>
</ul>

<p>"</p>

<p><a href="Category:Functional_analysis" title="wikilink">Category:Functional analysis</a> <a href="Category:Linear_algebra" title="wikilink">Category:Linear algebra</a> <a href="Category:Linear_operators" title="wikilink">Category:Linear operators</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Meyer, pp 386+387<a href="#fnref1">↩</a></li>
<li id="fn2">Meyer, p. 433<a href="#fnref2">↩</a></li>
<li id="fn3">Meyer, p. 431<a href="#fnref3">↩</a></li>
<li id="fn4">Meyer, equation (5.13.4)<a href="#fnref4">↩</a></li>
<li id="fn5">Meyer, equation (5.13.3)<a href="#fnref5">↩</a></li>
<li id="fn6">See also <a href="Linear_least_squares_(mathematics)#Properties_of_the_least-squares_estimators" title="wikilink">Linear least squares (mathematics) § Properties of the least-squares estimators</a>.<a href="#fnref6">↩</a></li>
<li id="fn7">Meyer, equation (7.10.39)<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
</ol>
</section>
</body>
</html>
