<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1711">Wave front set</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Wave front set</h1>
<hr/>

<p>In <a href="mathematical_analysis" title="wikilink">mathematical analysis</a>, more precisely in <a href="microlocal_analysis" title="wikilink">microlocal analysis</a>, the <strong>wave front (set)</strong> WF(<em>f</em>) characterizes the <a href="Mathematical_singularity" title="wikilink">singularities</a> of a <a href="generalized_function" title="wikilink">generalized function</a> <em>f</em>, not only in <a class="uri" href="space" title="wikilink">space</a>, but also with respect to its <a href="Fourier_transform" title="wikilink">Fourier transform</a> at each point. The term "wave front" was coined by <a href="Lars_Hörmander" title="wikilink">Lars Hörmander</a> around 1970.</p>
<h2 id="introduction">Introduction</h2>

<p>In more familiar terms, WF(<em>f</em>) tells not only <em>where</em> the function <em>f</em> is singular (which is already described by its <a href="singular_support" title="wikilink">singular support</a>), but also <em>how</em> or <em>why</em> it is singular, by being more exact about the direction in which the singularity occurs. This concept is mostly useful in dimension at least two, since in one dimension there are only two possible directions. The complementary notion of a function being non-singular in a direction is <em>microlocal smoothness</em>.</p>

<p>Intuitively, as an example, consider a function ƒ whose singular support is concentrated on a smooth curve in the plane at which the function has a jump discontinuity. In the direction tangent to the curve, the function remains smooth. By contrast, in the direction normal to the curve, the function has a singularity. To decide on whether the function is smooth in another direction <em>v</em>, one can try to smooth the function out by averaging in directions perpendicular to <em>v</em>. If the resulting function is smooth, then we regard ƒ to be smooth in the direction of <em>v</em>. Otherwise, <em>v</em> is in the wavefront set.</p>

<p>Formally, in <a href="Euclidean_space" title="wikilink">Euclidean space</a>, the <strong>wave front set</strong> of ƒ is defined as the <a href="Complement_(set_theory)" title="wikilink">complement</a> of the set of all pairs (<em>x</em><sub>0</sub>,<em>v</em>) such that there exists a test function 

<math display="inline" id="Wave_front_set:0">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>∈</mo>
   <msubsup>
    <mi>C</mi>
    <mn>0</mn>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ϕ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <cn type="integer">0</cn>
     </apply>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\in C_{0}^{\infty}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Wave_front_set:1">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

(<em>x</em><sub>0</sub>) ≠ 0 and an open <a href="Cone_(linear_algebra)" title="wikilink">cone</a> Γ containing <em>v</em> such that the estimate</p>

<p>

<math display="block" id="Wave_front_set:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>ϕ</mi>
         <mi>f</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>∧</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ξ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <msub>
      <mi>C</mi>
      <mi>N</mi>
     </msub>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mrow>
         <mo stretchy="false">|</mo>
         <mi>ξ</mi>
         <mo stretchy="false">|</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mi>N</mi>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mpadded width="+5pt">
      <mtext>for all</mtext>
     </mpadded>
     <mi>ξ</mi>
    </mrow>
    <mo>∈</mo>
    <mi mathvariant="normal">Γ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <times></times>
         <ci>ϕ</ci>
         <ci>f</ci>
        </apply>
        <and></and>
       </apply>
       <ci>ξ</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>N</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <abs></abs>
         <ci>ξ</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <mtext>for all</mtext>
      <ci>ξ</ci>
     </apply>
     <ci>normal-Γ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |(\phi f)^{\wedge}(\xi)|\leq C_{N}(1+|\xi|)^{-N}\quad\mbox{for all }\ \xi\in\Gamma
  </annotation>
 </semantics>
</math>

 holds for all positive integers <em>N</em>. Here 

<math display="inline" id="Wave_front_set:3">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>ϕ</mi>
     <mi>f</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <ci>f</ci>
    </apply>
    <and></and>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi f)^{\wedge}
  </annotation>
 </semantics>
</math>

 denotes the Fourier transform. Observe that the wavefront set is <a href="cone_(linear_algebra)" title="wikilink">conical</a> in the sense that if (<em>x</em>,<em>v</em>) ∈ Wf(ƒ), then (<em>x</em>,λ<em>v</em>) ∈ Wf(ƒ) for all λ &gt; 0. In the example discussed in the previous paragraph, the wavefront set is the set-theoretic complement of the image of the tangent bundle of the curve inside the tangent bundle of the plane.</p>

<p>Because the definition involves cutoff by a compactly supported function, the notion of a wave front set can be transported to any <a href="differentiable_manifold" title="wikilink">differentiable manifold</a> <em>X</em>. In this more general situation, the wave front set is a closed conical subset of the <a href="cotangent_bundle" title="wikilink">cotangent bundle</a> <em>T</em><sup>*</sup>(<em>X</em>), since the ξ variable naturally localizes to a <a class="uri" href="covector" title="wikilink">covector</a> rather than a vector. The wave front set is defined such that its projection on <em>X</em> is equal to the <a href="singular_support" title="wikilink">singular support</a> of the function.</p>
<h2 id="definition">Definition</h2>

<p>In Euclidean space, the wave front set of a <a href="distribution_(mathematics)" title="wikilink">distribution</a> ƒ is defined as</p>

<p>

<math display="block" id="Wave_front_set:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>WF</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>ξ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mrow>
      <msup>
       <mi>ℝ</mi>
       <mi>n</mi>
      </msup>
      <mo>×</mo>
      <msup>
       <mi>ℝ</mi>
       <mi>n</mi>
      </msup>
     </mrow>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mi>ξ</mi>
     <mo>∈</mo>
     <mrow>
      <msub>
       <mi mathvariant="normal">Σ</mi>
       <mi>x</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>WF</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <interval closure="open">
       <ci>x</ci>
       <ci>ξ</ci>
      </interval>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ℝ</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ℝ</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <in></in>
      <ci>ξ</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Σ</ci>
        <ci>x</ci>
       </apply>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm WF}(f)=\{(x,\xi)\in\mathbb{R}^{n}\times\mathbb{R}^{n}\mid\xi\in\Sigma_{x}%
(f)\}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Wave_front_set:5">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Σ</mi>
    <mi>x</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <ci>x</ci>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{x}(f)
  </annotation>
 </semantics>
</math>

 is the singular fibre of ƒ at <em>x</em>. The singular fibre is defined to be the <a href="complement_(set_theory)" title="wikilink">complement</a> of all directions 

<math display="inline" id="Wave_front_set:6">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

 such that the Fourier transform of <em>f</em>, localized at <em>x</em>, is sufficiently regular when restricted to an open cone containing 

<math display="inline" id="Wave_front_set:7">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

. More precisely, a direction <em>v</em> is in the complement of 

<math display="inline" id="Wave_front_set:8">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Σ</mi>
    <mi>x</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <ci>x</ci>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{x}(f)
  </annotation>
 </semantics>
</math>

 if there is a compactly supported smooth function φ with φ(<em>x</em>) ≠ 0 and an open cone Γ containing <em>v</em> such that the following estimate holds for each positive integer <em>N</em>:</p>

<p>

<math display="block" id="Wave_front_set:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>ϕ</mi>
         <mi>f</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>∧</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ξ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo><</mo>
     <mrow>
      <msub>
       <mi>c</mi>
       <mi>N</mi>
      </msub>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>+</mo>
         <mrow>
          <mo stretchy="false">|</mo>
          <mi>ξ</mi>
          <mo stretchy="false">|</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mi>N</mi>
       </mrow>
      </msup>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mpadded width="+5pt">
       <mi>forall</mi>
      </mpadded>
      <mi>ξ</mi>
     </mrow>
     <mo>∈</mo>
     <mi mathvariant="normal">Γ</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <lt></lt>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <ci>ϕ</ci>
        <ci>f</ci>
       </apply>
       <and></and>
      </apply>
      <ci>ξ</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>N</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <abs></abs>
         <ci>ξ</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <ci>forall</ci>
      <ci>ξ</ci>
     </apply>
     <ci>normal-Γ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi f)^{\wedge}(\xi)<c_{N}(1+|\xi|)^{-N}\quad{\rm forall}\ \xi\in\Gamma.
  </annotation>
 </semantics>
</math>

</p>

<p>Once such an estimate holds for a particular cutoff function φ at <em>x</em>, it also holds for all cutoff functions with smaller support, possibly for a different open cone containing <em>v</em>.</p>

<p>On a <a href="differentiable_manifold" title="wikilink">differentiable manifold</a> <em>M</em>, using local coordinates 

<math display="inline" id="Wave_front_set:10">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>,</mo>
   <mi>ξ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <ci>ξ</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,\xi
  </annotation>
 </semantics>
</math>

 on the <a href="cotangent_bundle" title="wikilink">cotangent bundle</a>, the wave front set WF(<em>f</em>) of a distribution ƒ can be defined in the following general way:</p>

<p>

<math display="block" id="Wave_front_set:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>WF</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>ξ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mrow>
      <msup>
       <mi>T</mi>
       <mo>*</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mi>ξ</mi>
     <mo>∈</mo>
     <mrow>
      <msub>
       <mi mathvariant="normal">Σ</mi>
       <mi>x</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>WF</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <interval closure="open">
       <ci>x</ci>
       <ci>ξ</ci>
      </interval>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>T</ci>
        <times></times>
       </apply>
       <ci>X</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <ci>ξ</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Σ</ci>
        <ci>x</ci>
       </apply>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm WF}(f)=\{(x,\xi)\in T^{*}(X)\mid\xi\in\Sigma_{x}(f)\}
  </annotation>
 </semantics>
</math>

</p>

<p>where the singular fibre 

<math display="inline" id="Wave_front_set:12">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Σ</mi>
    <mi>x</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <ci>x</ci>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{x}(f)
  </annotation>
 </semantics>
</math>

 is again the complement of all directions 

<math display="inline" id="Wave_front_set:13">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

 such that the Fourier transform of <em>f</em>, localized at <em>x</em>, is sufficiently regular when restricted to a conical neighbourhood of 

<math display="inline" id="Wave_front_set:14">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

. The problem of regularity is local, and so it can be checked in the local coordinate system, using the Fourier transform on the <em>x</em> variables. The required regularity estimate transforms well under <a class="uri" href="diffeomorphism" title="wikilink">diffeomorphism</a>, and so the notion of regularity is independent of the choice of local coordinates.</p>
<h3 id="generalizations">Generalizations</h3>

<p>The notion of a wave front set can be adapted to accommodate other notions of regularity of a function. Localized can here be expressed by saying that <em>f</em> is truncated by some <a href="Smooth_function#Smoothness" title="wikilink">smooth</a> <a href="cutoff_function" title="wikilink">cutoff function</a> not vanishing at <em>x</em>. (The localization process could be done in a more elegant fashion, using <a href="germ_(mathematics)" title="wikilink">germs</a>.)</p>

<p>More concretely, this can be expressed as</p>

<p>

<math display="block" id="Wave_front_set:15">
 <semantics>
  <mrow>
   <mi>ξ</mi>
   <mo>∉</mo>
   <msub>
    <mi mathvariant="normal">Σ</mi>
    <mi>x</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇔</mo>
   <mi>ξ</mi>
   <mo>=</mo>
   <mn>0</mn>
   <mtext>or</mtext>
   <mo>∃</mo>
   <mi>ϕ</mi>
   <mo>∈</mo>
   <msub>
    <mi class="ltx_font_mathcaligraphic">𝒟</mi>
    <mi>x</mi>
   </msub>
   <mo rspace="7.5pt">,</mo>
   <mo>∃</mo>
   <mi>V</mi>
   <mo>∈</mo>
   <msub>
    <mi class="ltx_font_mathcaligraphic">𝒱</mi>
    <mi>ξ</mi>
   </msub>
   <mo>:</mo>
   <mover accent="true">
    <mrow>
     <mi>ϕ</mi>
     <mi>f</mi>
    </mrow>
    <mo>^</mo>
   </mover>
   <msub>
    <mo stretchy="false">|</mo>
    <mi>V</mi>
   </msub>
   <mo>∈</mo>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">ξ</csymbol>
    <notin></notin>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <ci>x</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="unknown">ξ</csymbol>
    <eq></eq>
    <cn type="integer">0</cn>
    <mtext>or</mtext>
    <exists></exists>
    <csymbol cd="unknown">ϕ</csymbol>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒟</ci>
     <ci>x</ci>
    </apply>
    <ci>normal-,</ci>
    <exists></exists>
    <csymbol cd="unknown">V</csymbol>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝒱</ci>
     <ci>ξ</ci>
    </apply>
    <ci>normal-:</ci>
    <apply>
     <ci>normal-^</ci>
     <apply>
      <times></times>
      <ci>ϕ</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-|</ci>
     <ci>V</ci>
    </apply>
    <in></in>
    <csymbol cd="unknown">O</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi\notin\Sigma_{x}(f)\iff\xi=0\text{ or }\exists\phi\in\mathcal{D}_{x},\ %
\exists V\in\mathcal{V}_{\xi}:\widehat{\phi f}|_{V}\in O(V)
  </annotation>
 </semantics>
</math>

 where</p>
<ul>
<li>

<math display="inline" id="Wave_front_set:16">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">𝒟</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝒟</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{D}_{x}
  </annotation>
 </semantics>
</math>

 are <a href="compactly_supported" title="wikilink">compactly supported</a> <a href="smooth_function" title="wikilink">smooth functions</a> not vanishing at <em>x</em>,</li>
<li>

<math display="inline" id="Wave_front_set:17">
 <semantics>
  <msub>
   <mi class="ltx_font_mathcaligraphic">𝒱</mi>
   <mi>ξ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝒱</ci>
    <ci>ξ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{V}_{\xi}
  </annotation>
 </semantics>
</math>

 are <em>conical neighbourhoods</em> of 

<math display="inline" id="Wave_front_set:18">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

, i.e. <a href="neighbourhood_(mathematics)" title="wikilink">neighbourhoods</a> <em>V</em> such that 

<math display="inline" id="Wave_front_set:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mo>⋅</mo>
    <mi>V</mi>
   </mrow>
   <mo>⊂</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <ci>normal-⋅</ci>
     <ci>c</ci>
     <ci>V</ci>
    </apply>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\cdot V\subset V
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Wave_front_set:20">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>c</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c>0
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Wave_front_set:21">
 <semantics>
  <msub>
   <mrow>
    <mover accent="true">
     <mi>u</mi>
     <mo>^</mo>
    </mover>
    <mo fence="true">|</mo>
   </mrow>
   <mi>V</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">evaluated-at</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>u</ci>
    </apply>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{u}|_{V}
  </annotation>
 </semantics>
</math>

 denotes the <a href="Fourier_transform" title="wikilink">Fourier transform</a> of the (compactly supported generalized) function <em>u</em>, restricted to <em>V</em>,</li>
<li>

<math display="inline" id="Wave_front_set:22">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mo>:</mo>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mo>→</mo>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi mathvariant="normal">Ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>O</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>normal-Ω</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>normal-Ω</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O:\Omega\to O(\Omega)
  </annotation>
 </semantics>
</math>

 is a fixed <a href="Presheaf#Presheaves" title="wikilink">presheaf</a> of functions (or distributions) whose choice enforces the desired regularity of the Fourier transform.</li>
</ul>

<p>Typically, sections of <em>O</em> are required to satisfy some growth (or decrease) condition at infinity, e.g. such that 

<math display="inline" id="Wave_front_set:23">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>ξ</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>s</mi>
   </msup>
   <mi>v</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ξ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <abs></abs>
       <ci>ξ</ci>
      </apply>
     </apply>
     <ci>s</ci>
    </apply>
    <ci>v</ci>
    <ci>ξ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1+|\xi|)^{s}v(\xi)
  </annotation>
 </semantics>
</math>

 belong to some <a href="Lp_space" title="wikilink">L<sup>p</sup> space</a>. This definition makes sense, because the Fourier transform becomes more regular (in terms of growth at infinity) when <em>f</em> is truncated with the smooth cutoff 

<math display="inline" id="Wave_front_set:24">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

.</p>

<p>The most difficult "problem", from a theoretical point of view, is finding the adequate sheaf <em>O</em> characterizing functions belonging to a given subsheaf <em>E</em> of the space <em>G</em> of generalized functions.</p>
<h3 id="example">Example</h3>

<p>If we take <em>G</em> = <em>D</em>′ the space of <a href="Schwartz_distribution" title="wikilink">Schwartz distributions</a> and want to characterize distributions which are locally 

<math display="inline" id="Wave_front_set:25">
 <semantics>
  <msup>
   <mi>C</mi>
   <mi mathvariant="normal">∞</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>C</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{\infty}
  </annotation>
 </semantics>
</math>

 functions, we must take for <em>O</em>(Ω) the classical function spaces called <em>O</em>′<sub><em>M</em></sub>(Ω) in the literature.</p>

<p>Then the projection on the first component of a distribution's wave front set is nothing else than its classical <a href="singular_support" title="wikilink">singular support</a>, i.e. the complement of the set on which its restriction would be a <a href="smooth_function" title="wikilink">smooth function</a>.</p>
<h3 id="applications">Applications</h3>

<p>The wave front set is useful, among others, when studying <a href="wave_propagation" title="wikilink">propagation</a> of <a href="Mathematical_singularity" title="wikilink">singularities</a> by <a href="pseudodifferential_operator" title="wikilink">pseudodifferential operators</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="FBI_transform" title="wikilink">FBI transform</a></li>
<li><a href="Singular_spectrum" title="wikilink">Singular spectrum</a></li>
<li><a href="Essential_support" title="wikilink">Essential support</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><a href="Lars_Hörmander" title="wikilink">Lars Hörmander</a>, <em>Fourier integral operators I</em>, Acta Math. <strong>127</strong> (1971), pp. 79-183.</li>
<li>

<p>Chapter VIII, Spectral Analysis of Singularities</p></li>
</ul>

<p>"</p>

<p><a href="Category:Mathematical_analysis" title="wikilink">Category:Mathematical analysis</a> <a href="Category:Generalized_functions" title="wikilink">Category:Generalized functions</a></p>
</body>
</html>
