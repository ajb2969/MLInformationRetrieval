<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="811">Modularity (networks)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Modularity (networks)</h1>
<hr/>

<p><strong>Modularity</strong> is one measure of the structure of <a href="Complex_network" title="wikilink">networks</a> or <a href="Graph_(mathematics)" title="wikilink">graphs</a>. It was designed to measure the strength of division of a network into modules (also called groups, clusters or communities). Networks with high modularity have dense connections between the nodes within modules but sparse connections between nodes in different modules. Modularity is often used in optimization methods for detecting <a href="community_structure" title="wikilink">community structure</a> in networks. However, it has been shown that modularity suffers a resolution limit and, therefore, it is unable to detect small communities. Biological networks, including animal brains, exhibit a high degree of modularity.</p>
<h2 id="motivation">Motivation</h2>

<p>Many scientifically important problems can be represented and empirically studied using networks. For example, biological and social patterns, the World Wide Web, metabolic networks, food webs, neural networks and pathological networks are real world problems that can be mathematically represented and topologically studied to reveal some unexpected structural features.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Most of these networks possess a certain community structure that has substantial importance in building an understanding regarding the dynamics of the network. For instance, a closely connected social community will imply a faster rate of transmission of information or rumor among them than a loosely connected community. Thus, if a network is represented by a number of individual nodes connected by links which signify a certain degree of interaction between the nodes, communities are defined as groups of densely interconnected nodes that are only sparsely connected with the rest of the network. Hence, it may be imperative to identify the communities in networks since the communities may have quite different properties such as node degree, clustering coefficient, betweenness, centrality.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> etc., from that of the average network. Modularity is one such measure, which when maximized, leads to the appearance of communities in a given network.</p>
<h2 id="definition">Definition</h2>

<p>Modularity is the fraction of the edges that fall within the given groups minus the expected such fraction if edges were distributed at random. The value of the modularity lies in the range [−1/2,1). It is positive if the number of edges within groups exceeds the number expected on the basis of chance. For a given division of the network's vertices into some modules, modularity reflects the concentration of edges within modules compared with random distribution of links between all nodes regardless of modules.</p>

<p>There are different methods for calculating modularity.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> In the most common version of the concept, the randomization of the edges is done so as to preserve the <a href="Degree_(graph_theory)" title="wikilink">degree</a> of each vertex. Let us consider a graph with 

<math display="inline" id="Modularity_(networks):0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 <a href="Vertex_(graph_theory)" title="wikilink">nodes</a> and 

<math display="inline" id="Modularity_(networks):1">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 links (<a href="Edge_(graph_theory)#Graph" title="wikilink">edges</a>) such that the graph can be partitioned into two communities using a membership variable 

<math display="inline" id="Modularity_(networks):2">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

. If a node 

<math display="inline" id="Modularity_(networks):3">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 belongs to community 1, 

<math display="inline" id="Modularity_(networks):4">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>v</mi>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>v</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{v}=1
  </annotation>
 </semantics>
</math>

, or if 

<math display="inline" id="Modularity_(networks):5">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 belongs to community 2, 

<math display="inline" id="Modularity_(networks):6">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>v</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{v}=-1
  </annotation>
 </semantics>
</math>

. Let the <a href="adjacency_matrix" title="wikilink">adjacency matrix</a> for the network be represented by 

<math display="inline" id="Modularity_(networks):7">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Modularity_(networks):8">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mrow>
     <mi>v</mi>
     <mi>w</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>v</ci>
      <ci>w</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{vw}=0
  </annotation>
 </semantics>
</math>

 means there's no edge (no interaction) between nodes 

<math display="inline" id="Modularity_(networks):9">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Modularity_(networks):10">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Modularity_(networks):11">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mrow>
     <mi>v</mi>
     <mi>w</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>v</ci>
      <ci>w</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{vw}=1
  </annotation>
 </semantics>
</math>

 means there is an edge between the two. Also for simplicity we consider an undirected network. Thus 

<math display="inline" id="Modularity_(networks):12">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mrow>
     <mi>v</mi>
     <mi>w</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>A</mi>
    <mrow>
     <mi>w</mi>
     <mi>v</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>v</ci>
      <ci>w</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>w</ci>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{vw}=A_{wv}
  </annotation>
 </semantics>
</math>

. (It is important to note that multiple edges may exist between two nodes, but here we assess the simplest case).</p>

<p>Modularity Q is then defined as the fraction of edges that fall within group 1 or 2, minus the expected number of edges within groups 1 and 2 for a random graph with the same node degree distribution as the given network.</p>

<p>The expected number of edges shall be computed using the concept of Configuration Models.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The configuration model is a randomized realization of a particular network. Given a network with <em>n</em> nodes, where each node <em>v</em> has a node degree <em>k</em><sub><em>v</em></sub>, the configuration model cuts each edge into two halves, and then each half edge, called a stub, is rewired randomly with any other stub in the network even allowing self loops. Thus, even though the node degree distribution of the graph remains intact, the configuration model results in a completely random network.</p>

<p>Let the total number of stubs be <em>l</em><sub><em>n</em></sub></p>

<p>Now, if we randomly select two nodes <em>v</em> and <em>w</em> with node degrees <em>k</em><sub><em>v</em></sub> and <em>k</em><sub><em>w</em></sub> respectively and rewire the stubs for these two nodes, then, /{ \text{(Total number of rewiring possibilities)}} |<mtpl><eqref>2<eqref></eqref></eqref></mtpl>}} Total number of rewirings possible = number of stubs remaining after choosing a particular stub</p>

<p><code>                    = </code><em><code>l</code></em><sub><em><code>n-1</code></em></sub><code>= </code><em><code>l</code></em><sub><em><code>n</code></em></sub><code> for large </code><em><code>n</code></em></p>

<p>Thus, Expected [Number of full edges between <em>v</em> and <em>w</em>]=(<em>k</em><sub><em>v</em></sub>* <em>k</em><sub><em>w</em></sub>)/<em>l</em><sub><em>n</em></sub> =(<em>k</em><sub><em>v</em></sub> <em>k</em><sub><em>w</em></sub>)/2<em>m</em>.</p>

<p>Hence, the actual number of edges between <em>v</em> and <em>w</em> minus expected number of edges between them is <em>A</em><sub><em>vw</em></sub>-(<em>k</em><sub><em>v</em></sub> <em>k</em><sub><em>w</em></sub>)/2<em>m</em>. Thus using <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>It is important to note that  holds good for partitioning into two communities only. Hierarchical partitioning (i.e. partitioning into two communities, then the two sub-communities further partitioned into two smaller sub communities only to maximize <em>Q</em>) is a possible approach to identify multiple communities in a network. Additionally, (3) can be generalized for partitioning a network into <em>c</em> communities.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>{2m} - \frac{k_v*k_w}{(2m)(2m)} \right] \delta(c_{v}, c_{w})</p>

<p><code> =\sum_{i=1}^{c} (e_{ii}-a_{i}^2) </code></p>

<p>|<mtpl><eqref>4<eqref></eqref></eqref></mtpl>}}</p>

<p>where <em>e</em><sub><em>ij</em></sub> is the fraction of edges with one end vertices in community <em>i</em> and the other in community <em>j</em>:</p>

<p>

<math display="block" id="Modularity_(networks):13">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>v</mi>
      <mi>w</mi>
     </mrow>
    </munder>
    <mrow>
     <mfrac>
      <msub>
       <mi>A</mi>
       <mrow>
        <mi>v</mi>
        <mi>w</mi>
       </mrow>
      </msub>
      <mrow>
       <mn>2</mn>
       <mi>m</mi>
      </mrow>
     </mfrac>
     <msub>
      <mn>1</mn>
      <mrow>
       <mi>v</mi>
       <mo>∈</mo>
       <msub>
        <mi>c</mi>
        <mi>i</mi>
       </msub>
      </mrow>
     </msub>
     <msub>
      <mn>1</mn>
      <mrow>
       <mi>w</mi>
       <mo>∈</mo>
       <msub>
        <mi>c</mi>
        <mi>j</mi>
       </msub>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <times></times>
       <ci>v</ci>
       <ci>w</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <apply>
         <times></times>
         <ci>v</ci>
         <ci>w</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>m</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <cn type="integer">1</cn>
       <apply>
        <in></in>
        <ci>v</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>c</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <cn type="integer">1</cn>
       <apply>
        <in></in>
        <ci>w</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>c</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{ij}=\sum_{vw}\frac{A_{vw}}{2m}1_{v\in c_{i}}1_{w\in c_{j}}
  </annotation>
 </semantics>
</math>

</p>

<p>and <em>a</em><sub><em>i</em></sub> is the fraction of ends of edges that are attached to vertices in community <em>i</em>:</p>

<p>

<math display="block" id="Modularity_(networks):14">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mi>k</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mn>2</mn>
     <mi>m</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>j</mi>
    </munder>
    <msub>
     <mi>e</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}=\frac{k_{i}}{2m}=\sum_{j}e_{ij}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="example-of-multiple-community-detection">Example of multiple community detection</h2>

<p>We consider an undirected network with 10 nodes and 12 edges and the following adjacency matrix.  </p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Node ID</p></th>
<th style="text-align: left;">
<p>1</p></th>
<th style="text-align: left;">
<p>2</p></th>
<th style="text-align: left;">
<p>3</p></th>
<th style="text-align: left;">
<p>4</p></th>
<th style="text-align: left;">
<p>5</p></th>
<th style="text-align: left;">
<p>6</p></th>
<th style="text-align: left;">
<p>7</p></th>
<th style="text-align: left;">
<p>8</p></th>
<th style="text-align: left;">
<p>9</p></th>
<th style="text-align: left;">
<p>10</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>9</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>10</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
</tbody>
</table>

<p>The communities in the graph are represented by the red, green and blue node clusters in Fig 1. The optimal community partitions are depicted in Fig 2.</p>
<h2 id="matrix-formulation">Matrix formulation</h2>

<p>An alternative formulation of the modularity, useful particularly in spectral optimization algorithms, is as follows.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Define <em>S</em><sub><em>vr</em></sub> to be 1 if vertex <em>v</em> belongs to group <em>r</em> and zero otherwise. Then</p>

<p>

<math display="block" id="Modularity_(networks):15">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>c</mi>
      <mi>v</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>c</mi>
      <mi>w</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>r</mi>
    </munder>
    <mrow>
     <msub>
      <mi>S</mi>
      <mrow>
       <mi>v</mi>
       <mi>r</mi>
      </mrow>
     </msub>
     <msub>
      <mi>S</mi>
      <mrow>
       <mi>w</mi>
       <mi>r</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>δ</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>v</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>w</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>r</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <times></times>
        <ci>v</ci>
        <ci>r</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <times></times>
        <ci>w</ci>
        <ci>r</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(c_{v},c_{w})=\sum_{r}S_{vr}S_{wr}
  </annotation>
 </semantics>
</math>

</p>

<p>and hence</p>

<p>

<math display="block" id="Modularity_(networks):16">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>2</mn>
       <mi>m</mi>
      </mrow>
     </mfrac>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>v</mi>
        <mi>w</mi>
       </mrow>
      </munder>
      <mrow>
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mi>r</mi>
       </munder>
       <mrow>
        <mrow>
         <mo>[</mo>
         <mrow>
          <msub>
           <mi>A</mi>
           <mrow>
            <mi>v</mi>
            <mi>w</mi>
           </mrow>
          </msub>
          <mo>-</mo>
          <mfrac>
           <mrow>
            <msub>
             <mi>k</mi>
             <mi>v</mi>
            </msub>
            <msub>
             <mi>k</mi>
             <mi>w</mi>
            </msub>
           </mrow>
           <mrow>
            <mn>2</mn>
            <mi>m</mi>
           </mrow>
          </mfrac>
         </mrow>
         <mo>]</mo>
        </mrow>
        <msub>
         <mi>S</mi>
         <mrow>
          <mi>v</mi>
          <mi>r</mi>
         </mrow>
        </msub>
        <msub>
         <mi>S</mi>
         <mrow>
          <mi>w</mi>
          <mi>r</mi>
         </mrow>
        </msub>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>2</mn>
       <mi>m</mi>
      </mrow>
     </mfrac>
     <mi>Tr</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>𝐒</mi>
        <mi mathvariant="normal">T</mi>
       </msup>
       <mi>𝐁𝐒</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>Q</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>m</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <times></times>
         <ci>v</ci>
         <ci>w</ci>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <ci>r</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <minus></minus>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>A</ci>
            <apply>
             <times></times>
             <ci>v</ci>
             <ci>w</ci>
            </apply>
           </apply>
           <apply>
            <divide></divide>
            <apply>
             <times></times>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>k</ci>
              <ci>v</ci>
             </apply>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>k</ci>
              <ci>w</ci>
             </apply>
            </apply>
            <apply>
             <times></times>
             <cn type="integer">2</cn>
             <ci>m</ci>
            </apply>
           </apply>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>S</ci>
          <apply>
           <times></times>
           <ci>v</ci>
           <ci>r</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>S</ci>
          <apply>
           <times></times>
           <ci>w</ci>
           <ci>r</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>m</ci>
       </apply>
      </apply>
      <ci>Tr</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐒</ci>
        <ci>normal-T</ci>
       </apply>
       <ci>𝐁𝐒</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=\frac{1}{2m}\sum_{vw}\sum_{r}\left[A_{vw}-\frac{k_{v}k_{w}}{2m}\right]S_{vr}%
S_{wr}=\frac{1}{2m}\mathrm{Tr}(\mathbf{S}^{\mathrm{T}}\mathbf{BS}),
  </annotation>
 </semantics>
</math>

</p>

<p>where <strong>S</strong> is the (non-square) matrix having elements <em>S</em><sub><em>vr</em></sub> and <strong>B</strong> is the so-called modularity matrix, which has elements</p>

<p>

<math display="block" id="Modularity_(networks):17">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>B</mi>
     <mrow>
      <mi>v</mi>
      <mi>w</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>A</mi>
      <mrow>
       <mi>v</mi>
       <mi>w</mi>
      </mrow>
     </msub>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <msub>
        <mi>k</mi>
        <mi>v</mi>
       </msub>
       <msub>
        <mi>k</mi>
        <mi>w</mi>
       </msub>
      </mrow>
      <mrow>
       <mn>2</mn>
       <mi>m</mi>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <apply>
      <times></times>
      <ci>v</ci>
      <ci>w</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <apply>
       <times></times>
       <ci>v</ci>
       <ci>w</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <ci>v</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <ci>w</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{vw}=A_{vw}-\frac{k_{v}k_{w}}{2m}.
  </annotation>
 </semantics>
</math>

</p>

<p>All rows and columns of the modularity matrix sum to zero, which means that the modularity of an undivided network is also always zero.</p>

<p>For networks divided into just two communities, one can alternatively define <em>s</em><sub><em>v</em></sub> = ±1 to indicate the community to which node <em>v</em> belongs, which then leads to</p>

<p>

<math display="block" id="Modularity_(networks):18">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>2</mn>
       <mi>m</mi>
      </mrow>
     </mfrac>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>v</mi>
        <mi>w</mi>
       </mrow>
      </munder>
      <mrow>
       <msub>
        <mi>B</mi>
        <mrow>
         <mi>v</mi>
         <mi>w</mi>
        </mrow>
       </msub>
       <msub>
        <mi>s</mi>
        <mi>v</mi>
       </msub>
       <msub>
        <mi>s</mi>
        <mi>w</mi>
       </msub>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>2</mn>
       <mi>m</mi>
      </mrow>
     </mfrac>
     <msup>
      <mi>𝐬</mi>
      <mi mathvariant="normal">T</mi>
     </msup>
     <mi>𝐁𝐬</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>Q</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>m</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <times></times>
         <ci>v</ci>
         <ci>w</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>B</ci>
         <apply>
          <times></times>
          <ci>v</ci>
          <ci>w</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <ci>v</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <ci>w</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>m</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐬</ci>
       <ci>normal-T</ci>
      </apply>
      <ci>𝐁𝐬</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q={1\over 2m}\sum_{vw}B_{vw}s_{v}s_{w}={1\over 2m}\mathbf{s}^{\mathrm{T}}%
\mathbf{Bs},
  </annotation>
 </semantics>
</math>

</p>

<p>where <strong>s</strong> is the column vector with elements <em>s</em><sub><em>v</em></sub>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>This function has the same form as the <a href="Hamiltonian_(quantum_mechanics)" title="wikilink">Hamiltonian</a> of an Ising <a href="spin_glass" title="wikilink">spin glass</a>, a connection that has been exploited to create simple computer algorithms, for instance using <a href="simulated_annealing" title="wikilink">simulated annealing</a>, to maximize the modularity. The general form of the modularity for arbitrary numbers of communities is equivalent to a Potts spin glass and similar algorithms can be developed for this case also.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="resolution-limit">Resolution limit</h2>

<p>Modularity compares the number of edges inside a cluster with the expected number of edges that one would find in the cluster if the network were a random network with the same number of nodes and where each node keeps its degree, but edges are otherwise randomly attached. This random null model implicitly assumes that each node can get attached to any other node of the network. This assumption is however unreasonable if the network is very large, as the horizon of a node includes a small part of the network, ignoring most of it. Moreover, this implies that the expected number of edges between two groups of nodes decreases if the size of the network increases. So, if a network is large enough, the expected number of edges between two groups of nodes in modularity's null model may be smaller than one. If this happens, a single edge between the two clusters would be interpreted by modularity as a sign of a strong correlation between the two clusters, and optimizing modularity would lead to the merging of the two clusters, independently of the clusters' features. So, even weakly interconnected complete graphs, which have the highest possible density of internal edges, and represent the best identifiable communities, would be merged by modularity optimization if the network were sufficiently large.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> For this reason, optimizing modularity in large networks would fail to resolve small communities, even when they are well defined. This bias is inevitable for methods like modularity optimization, which rely on a global null model.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h2 id="multiresolution-methods">Multiresolution methods</h2>

<p>There are two main approaches which try to solve the resolution limit within the modularity context: the addition of a resistance <em>r</em> to every node, in the form of a <a class="uri" href="self-loop" title="wikilink">self-loop</a>, which increases (<em>r&gt;0</em>) or decreases (''r or the addition of a parameter <em>γ&gt;0</em> in front of the null-case term in the definition of modularity, which controls the relative importance between internal links of the communities and the null model.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Optimizing modularity for values of these parameters in their respective appropriate ranges, it is possible to recover the whole mesoscale of the network, from the macroscale in which all nodes belong to the same community, to the microscale in which every node forms its own community, hence the name <em>multiresolution methods</em>. However, it has recently been demonstrated that these methods are intrinsically deficient and their use will not produce reliable solutions.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> <a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Complex_network" title="wikilink">Complex network</a></li>
<li><a href="Community_structure" title="wikilink">Community structure</a></li>
<li><a href="Null_model" title="wikilink">Null model</a></li>
<li><a href="Surprise_(networks)" title="wikilink">Surprise</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Network_theory" title="wikilink">Category:Network theory</a> <a href="Category:Algebraic_graph_theory" title="wikilink">Category:Algebraic graph theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
</ol>
</section>
</body>
</html>
