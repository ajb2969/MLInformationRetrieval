<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="982">Rabin cryptosystem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Rabin cryptosystem</h1>
<hr/>

<p>The <strong>Rabin cryptosystem</strong> is an asymmetric <a class="uri" href="cryptographic" title="wikilink">cryptographic</a> technique, whose security, like that of <a href="RSA_(algorithm)" title="wikilink">RSA</a>, is related to the difficulty of <a class="uri" href="factorization" title="wikilink">factorization</a>. However the Rabin cryptosystem has the advantage that the problem on which it relies has been proved to be as hard as <a href="integer_factorization" title="wikilink">integer factorization</a>, which is not currently known to be true of the <a href="RSA_problem" title="wikilink">RSA problem</a>. It has the disadvantage that each output of the Rabin function can be generated by any of four possible inputs; if each output is a ciphertext, extra complexity is required on decryption to identify which of the four possible inputs was the true plaintext.</p>
<h2 id="history">History</h2>

<p>The process was published in January 1979 by <a href="Michael_O._Rabin" title="wikilink">Michael O. Rabin</a>. The Rabin cryptosystem was the first asymmetric cryptosystem where recovering the entire plaintext from the ciphertext could be proven to be as hard as factoring.</p>
<h2 id="key-generation">Key generation</h2>

<p>As with all asymmetric cryptosystems, the Rabin system uses both a <a href="public_key" title="wikilink">public</a> and a <a href="private_key" title="wikilink">private key</a>. The public key is necessary for later encryption and can be published, while the private key must be possessed only by the recipient of the message.</p>

<p>The precise key-generation process follows:</p>
<ul>
<li>Choose two large distinct primes <em>p</em> and <em>q</em>. One may choose 

<math display="inline" id="Rabin_cryptosystem:0">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>≡</mo>
   <mi>q</mi>
   <mo>≡</mo>
   <mrow>
    <mn>3</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>4</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <ci>p</ci>
     <ci>q</ci>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <cn type="integer">3</cn>
      <apply>
       <ci>pmod</ci>
       <cn type="integer">4</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\equiv q\equiv 3\;\;(\mathop{{\rm mod}}4)
  </annotation>
 </semantics>
</math>

 to simplify the computation of square roots modulo <em>p</em> and <em>q</em> (see below). But the scheme works with any primes.</li>
<li>Let 

<math display="inline" id="Rabin_cryptosystem:1">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mi>p</mi>
    <mo>⋅</mo>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <ci>normal-⋅</ci>
     <ci>p</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=p\cdot q
  </annotation>
 </semantics>
</math>

. Then <em>n</em> is the public key. The primes <em>p</em> and <em>q</em> are the private key.</li>
</ul>

<p>To encrypt a message only the public key <em>n</em> is needed. To decrypt a ciphertext the factors <em>p</em> and <em>q</em> of <em>n</em> are necessary.</p>

<p>As a (non-real-world) example, if 

<math display="inline" id="Rabin_cryptosystem:2">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <mn>7</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <cn type="integer">7</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=7
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Rabin_cryptosystem:3">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>=</mo>
   <mn>11</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>q</ci>
    <cn type="integer">11</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q=11
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Rabin_cryptosystem:4">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>77</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">77</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=77
  </annotation>
 </semantics>
</math>

. The public key, 77, would be released, and the message encoded using this key. And, in order to decode the message, the private keys, 7 and 11, would have to be known (of course, this would be a poor choice of keys, as the factorization of 77 is trivial; in reality much larger numbers would be used).</p>
<h2 id="encryption">Encryption</h2>

<p>For the encryption, only the public key <em>n</em> is used, thus producing a ciphertext out of the plaintext. The process follows:</p>

<p>Let 

<math display="inline" id="Rabin_cryptosystem:5">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <set>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=\{0,\dots,n-1\}
  </annotation>
 </semantics>
</math>

 be the plaintext space (consisting of numbers) and 

<math display="inline" id="Rabin_cryptosystem:6">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>∈</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>m</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\in P
  </annotation>
 </semantics>
</math>

 be the <a class="uri" href="plaintext" title="wikilink">plaintext</a>. Now the <a class="uri" href="ciphertext" title="wikilink">ciphertext</a> 

<math display="inline" id="Rabin_cryptosystem:7">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 is determined by</p>

<p>

<math display="block" id="Rabin_cryptosystem:8">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <msup>
      <mi>m</mi>
      <mn>2</mn>
     </msup>
    </mpadded>
    <mo lspace="2.5pt" rspace="4.2pt">mod</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=m^{2}\,\bmod\,n
  </annotation>
 </semantics>
</math>

.</p>

<p>That is, <em>c</em> is the quadratic remainder of the square of the plaintext, modulo the key-number <em>n</em>.</p>

<p>In our simple example, 

<math display="inline" id="Rabin_cryptosystem:9">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mn>76</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <set>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <cn type="integer">76</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=\{0,\dots,76\}
  </annotation>
 </semantics>
</math>

 is our plaintext space. We will take 

<math display="inline" id="Rabin_cryptosystem:10">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mn>20</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <cn type="integer">20</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=20
  </annotation>
 </semantics>
</math>

 as our plaintext. The ciphertext is thus 

<math display="inline" id="Rabin_cryptosystem:11">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <msup>
      <mi>m</mi>
      <mn>2</mn>
     </msup>
    </mpadded>
    <mo lspace="2.5pt" rspace="4.2pt">mod</mo>
    <mi>n</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mn>400</mn>
    </mpadded>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mn>77</mn>
   </mrow>
   <mo>=</mo>
   <mn>15</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>c</ci>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>m</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <cn type="integer">400</cn>
      <cn type="float">77</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">15</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=m^{2}\,\bmod\,n=400\,\bmod\,77=15
  </annotation>
 </semantics>
</math>

.</p>

<p>For exactly four different values of <em>m</em>, the ciphertext 15 is produced, i.e. for 

<math display="inline" id="Rabin_cryptosystem:12">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>13</mn>
    <mo>,</mo>
    <mn>20</mn>
    <mo>,</mo>
    <mn>57</mn>
    <mo>,</mo>
    <mn>64</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>m</ci>
    <set>
     <cn type="integer">13</cn>
     <cn type="integer">20</cn>
     <cn type="integer">57</cn>
     <cn type="integer">64</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\in\{13,20,57,64\}
  </annotation>
 </semantics>
</math>

. This is true for most ciphertexts produced by the Rabin algorithm, i.e. it is a four-to-one function.</p>
<h2 id="decryption">Decryption</h2>

<p>To decode the ciphertext, the private keys are necessary. The process follows:</p>

<p>If <em>c</em> and <em>n</em> are known, the plaintext is then 

<math display="inline" id="Rabin_cryptosystem:13">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>m</ci>
    <set>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\in\{0,\dots,n-1\}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Rabin_cryptosystem:14">
 <semantics>
  <mrow>
   <msup>
    <mi>m</mi>
    <mn>2</mn>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mi>c</mi>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <ci>c</ci>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m^{2}\equiv c\;\;(\mathop{{\rm mod}}n)
  </annotation>
 </semantics>
</math>

. For a <a href="Composite_number" title="wikilink">composite</a> <em>n</em> (that is, like the Rabin algorithm's 

<math display="inline" id="Rabin_cryptosystem:15">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mi>p</mi>
    <mo>⋅</mo>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <ci>normal-⋅</ci>
     <ci>p</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=p\cdot q
  </annotation>
 </semantics>
</math>

) there is no efficient method known for the finding of <em>m</em>. If, however 

<math display="inline" id="Rabin_cryptosystem:16">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is prime (as are <em>p</em> and <em>q</em> in the Rabin algorithm), the <a href="Chinese_remainder_theorem" title="wikilink">Chinese remainder theorem</a> can be applied to solve for <em>m</em>.</p>

<p>Thus the <a href="square_root" title="wikilink">square roots</a></p>

<p>

<math display="block" id="Rabin_cryptosystem:17">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mi>p</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <msqrt>
      <mi>c</mi>
     </msqrt>
    </mpadded>
    <mo lspace="2.5pt" rspace="4.2pt">mod</mo>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <root></root>
      <ci>c</ci>
     </apply>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{p}=\sqrt{c}\,\bmod\,p
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Rabin_cryptosystem:18">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mi>q</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <msqrt>
      <mi>c</mi>
     </msqrt>
    </mpadded>
    <mo lspace="2.5pt" rspace="4.2pt">mod</mo>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>q</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <root></root>
      <ci>c</ci>
     </apply>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{q}=\sqrt{c}\,\bmod\,q
  </annotation>
 </semantics>
</math>

</p>

<p>must be calculated (see section below).</p>

<p>In our example we get 

<math display="inline" id="Rabin_cryptosystem:19">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mi>p</mi>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>p</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{p}=1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Rabin_cryptosystem:20">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mi>q</mi>
   </msub>
   <mo>=</mo>
   <mn>9</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>q</ci>
    </apply>
    <cn type="integer">9</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{q}=9
  </annotation>
 </semantics>
</math>

.</p>

<p>By applying the <a href="extended_Euclidean_algorithm" title="wikilink">extended Euclidean algorithm</a>, we wish to find 

<math display="inline" id="Rabin_cryptosystem:21">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{p}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Rabin_cryptosystem:22">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{q}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Rabin_cryptosystem:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>p</mi>
     </msub>
     <mo>⋅</mo>
     <mi>p</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>q</mi>
     </msub>
     <mo>⋅</mo>
     <mi>q</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>p</ci>
      </apply>
      <ci>p</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>q</ci>
      </apply>
      <ci>q</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{p}\cdot p+y_{q}\cdot q=1
  </annotation>
 </semantics>
</math>

. In our example, we have 

<math display="inline" id="Rabin_cryptosystem:24">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>p</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>3</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{p}=-3
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Rabin_cryptosystem:25">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>q</mi>
   </msub>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>q</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{q}=2
  </annotation>
 </semantics>
</math>

.</p>

<p>Now, by invocation of the Chinese remainder theorem, the four square roots 

<math display="inline" id="Rabin_cryptosystem:26">
 <semantics>
  <mrow>
   <mo>+</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   +r
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Rabin_cryptosystem:27">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -r
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Rabin_cryptosystem:28">
 <semantics>
  <mrow>
   <mo>+</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   +s
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Rabin_cryptosystem:29">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -s
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Rabin_cryptosystem:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mo>+</mo>
    <mrow>
     <mi>n</mi>
     <mi>ℤ</mi>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mrow>
     <mi>ℤ</mi>
     <mo>/</mo>
     <mi>n</mi>
    </mrow>
    <mi>ℤ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <plus></plus>
     <ci>c</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>ℤ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>ℤ</ci>
      <ci>n</ci>
     </apply>
     <ci>ℤ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c+n\mathbb{Z}\in\mathbb{Z}/n\mathbb{Z}
  </annotation>
 </semantics>
</math>

 are calculated (

<math display="inline" id="Rabin_cryptosystem:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>n</ci>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/n\mathbb{Z}
  </annotation>
 </semantics>
</math>

 here stands for the <a href="modular_arithmetic#Ring_of_congruence_classes" title="wikilink">ring of congruence classes</a> modulo <em>n</em>). The four square roots are in the set 

<math display="inline" id="Rabin_cryptosystem:32">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">0</cn>
    <ci>normal-…</ci>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{0,\dots,n-1\}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Rabin_cryptosystem:33">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="center">
     <mi>r</mi>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>y</mi>
          <mi>p</mi>
         </msub>
         <mo>⋅</mo>
         <mi>p</mi>
         <mo>⋅</mo>
         <msub>
          <mi>m</mi>
          <mi>q</mi>
         </msub>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msub>
          <mi>y</mi>
          <mi>q</mi>
         </msub>
         <mo>⋅</mo>
         <mi>q</mi>
         <mo>⋅</mo>
         <msub>
          <mi>m</mi>
          <mi>p</mi>
         </msub>
        </mrow>
       </mrow>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mo lspace="2.5pt" rspace="4.2pt">mod</mo>
      <mi>n</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mrow>
      <mo>-</mo>
      <mi>r</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mi>r</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mi>s</mi>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>y</mi>
          <mi>p</mi>
         </msub>
         <mo>⋅</mo>
         <mi>p</mi>
         <mo>⋅</mo>
         <msub>
          <mi>m</mi>
          <mi>q</mi>
         </msub>
        </mrow>
        <mo>-</mo>
        <mrow>
         <msub>
          <mi>y</mi>
          <mi>q</mi>
         </msub>
         <mo>⋅</mo>
         <mi>q</mi>
         <mo>⋅</mo>
         <msub>
          <mi>m</mi>
          <mi>p</mi>
         </msub>
        </mrow>
       </mrow>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mo lspace="2.5pt" rspace="4.2pt">mod</mo>
      <mi>n</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mrow>
      <mo>-</mo>
      <mi>s</mi>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mi>s</mi>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <ci>r</ci>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>p</ci>
        </apply>
        <ci>p</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <ci>q</ci>
        </apply>
       </apply>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>q</ci>
        </apply>
        <ci>q</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <ci>p</ci>
        </apply>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <minus></minus>
      <ci>r</ci>
     </apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>r</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <ci>s</ci>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>p</ci>
        </apply>
        <ci>p</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <ci>q</ci>
        </apply>
       </apply>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>q</ci>
        </apply>
        <ci>q</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <ci>p</ci>
        </apply>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <minus></minus>
      <ci>s</ci>
     </apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>s</ci>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{matrix}r&=&(y_{p}\cdot p\cdot m_{q}+y_{q}\cdot q\cdot m_{p})\,\bmod\,n%
\\
-r&=&n-r\\
s&=&(y_{p}\cdot p\cdot m_{q}-y_{q}\cdot q\cdot m_{p})\,\bmod\,n\\
-s&=&n-s\end{matrix}
  </annotation>
 </semantics>
</math>

</p>

<p>One of these square roots 

<math display="inline" id="Rabin_cryptosystem:34">
 <semantics>
  <mrow>
   <mi></mi>
   <mo lspace="2.5pt" rspace="4.2pt">mod</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">modulo</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mod\,n
  </annotation>
 </semantics>
</math>

 is the original plaintext <em>m</em>. In our example, 

<math display="inline" id="Rabin_cryptosystem:35">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>64</mn>
    <mo>,</mo>
    <mn>𝟐𝟎</mn>
    <mo>,</mo>
    <mn>13</mn>
    <mo>,</mo>
    <mn>57</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>m</ci>
    <set>
     <cn type="integer">64</cn>
     <cn type="integer">20</cn>
     <cn type="integer">13</cn>
     <cn type="integer">57</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\in\{64,\mathbf{20},13,57\}
  </annotation>
 </semantics>
</math>

.</p>

<p>Rabin pointed out in his paper, that if someone is able to compute <strong>both</strong>, 

<math display="inline" id="Rabin_cryptosystem:36">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Rabin_cryptosystem:37">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

, then he is also able to find the factorization of 

<math display="inline" id="Rabin_cryptosystem:38">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 because:</p>
<dl>
<dd>either 

<math display="inline" id="Rabin_cryptosystem:39">
 <semantics>
  <mrow>
   <mrow>
    <mi>gcd</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>r</mi>
       <mo>-</mo>
       <mi>s</mi>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <gcd></gcd>
     <apply>
      <abs></abs>
      <apply>
       <minus></minus>
       <ci>r</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gcd(|r-s|,n)=p
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Rabin_cryptosystem:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>gcd</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>r</mi>
       <mo>-</mo>
       <mi>s</mi>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <gcd></gcd>
     <apply>
      <abs></abs>
      <apply>
       <minus></minus>
       <ci>r</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gcd(|r-s|,n)=q
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Rabin_cryptosystem:41">
 <semantics>
  <mi>gcd</mi>
  <annotation-xml encoding="MathML-Content">
   <gcd></gcd>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gcd
  </annotation>
 </semantics>
</math>

 means <a href="Greatest_common_divisor" title="wikilink">Greatest common divisor</a>.
</dd>
</dl>

<p>Since the <a href="Greatest_common_divisor" title="wikilink">Greatest common divisor</a> can be calculated efficiently you are able to find the factorization of 

<math display="inline" id="Rabin_cryptosystem:42">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 efficiently if you know 

<math display="inline" id="Rabin_cryptosystem:43">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Rabin_cryptosystem:44">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

. In our example (picking 

<math display="inline" id="Rabin_cryptosystem:45">
 <semantics>
  <mn>57</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">57</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   57
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Rabin_cryptosystem:46">
 <semantics>
  <mn>13</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">13</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   13
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Rabin_cryptosystem:47">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Rabin_cryptosystem:48">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

):</p>

<p>

<math display="block" id="Rabin_cryptosystem:49">
 <semantics>
  <mrow>
   <mrow>
    <mi>gcd</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>57</mn>
      <mo>-</mo>
      <mn>13</mn>
     </mrow>
     <mo>,</mo>
     <mn>77</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>gcd</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>44</mn>
     <mo>,</mo>
     <mn>77</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>11</mn>
   <mo>=</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <gcd></gcd>
      <apply>
       <minus></minus>
       <cn type="integer">57</cn>
       <cn type="integer">13</cn>
      </apply>
      <cn type="integer">77</cn>
     </apply>
     <apply>
      <gcd></gcd>
      <cn type="integer">44</cn>
      <cn type="integer">77</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">11</cn>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gcd(57-13,77)=\gcd(44,77)=11=q
  </annotation>
 </semantics>
</math>

</p>
<h2 id="computing-square-roots">Computing square roots</h2>

<p>The decryption requires to compute square roots of the ciphertext <em>c</em> modulo the primes <em>p</em> and <em>q</em>. Choosing 

<math display="inline" id="Rabin_cryptosystem:50">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>≡</mo>
   <mi>q</mi>
   <mo>≡</mo>
   <mrow>
    <mn>3</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>4</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <ci>p</ci>
     <ci>q</ci>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <cn type="integer">3</cn>
      <apply>
       <ci>pmod</ci>
       <cn type="integer">4</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\equiv q\equiv 3\;\;(\mathop{{\rm mod}}4)
  </annotation>
 </semantics>
</math>

 allows to compute square roots more easily by</p>

<p>

<math display="block" id="Rabin_cryptosystem:51">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mi>p</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <msup>
      <mi>c</mi>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mn>4</mn>
       </mfrac>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>p</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
    </mpadded>
    <mo lspace="2.5pt" rspace="4.2pt">mod</mo>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">4</cn>
       </apply>
       <apply>
        <plus></plus>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{p}=c^{\frac{1}{4}(p+1)}\,\bmod\,p
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Rabin_cryptosystem:52">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mi>q</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <msup>
      <mi>c</mi>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mn>4</mn>
       </mfrac>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>q</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
    </mpadded>
    <mo lspace="2.5pt" rspace="4.2pt">mod</mo>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>q</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">4</cn>
       </apply>
       <apply>
        <plus></plus>
        <ci>q</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{q}=c^{\frac{1}{4}(q+1)}\,\bmod\,q
  </annotation>
 </semantics>
</math>

.</p>

<p>We can show that this method works for <em>p</em> as follows. First 

<math display="inline" id="Rabin_cryptosystem:53">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>≡</mo>
   <mrow>
    <mpadded width="-5.1pt">
     <mn>3</mn>
    </mpadded>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>4</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>p</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">3</cn>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\equiv 3\!\!\!\;\;(\mathop{{\rm mod}}4)
  </annotation>
 </semantics>
</math>

 implies that (<em>p</em>+1)/4 is an integer. The assumption is trivial for <em>c</em>≡0 (mod <em>p</em>). Thus we may assume that <em>p</em> does not divide <em>c</em>. Then</p>

<p>

<math display="block" id="Rabin_cryptosystem:54">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>m</mi>
     <mi>p</mi>
     <mn>2</mn>
    </msubsup>
    <mo>≡</mo>
    <msup>
     <mi>c</mi>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>p</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
    <mo>≡</mo>
    <mrow>
     <mi>c</mi>
     <mo>⋅</mo>
     <msup>
      <mi>c</mi>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mn>2</mn>
       </mfrac>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>p</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mrow>
      <mi>c</mi>
      <mo>⋅</mo>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mi>c</mi>
        <mi>p</mi>
       </mfrac>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>p</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>p</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <plus></plus>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <ci>c</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>c</ci>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>p</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <apply>
       <ci>normal-⋅</ci>
       <ci>c</ci>
       <apply>
        <divide></divide>
        <ci>c</ci>
        <ci>p</ci>
       </apply>
      </apply>
      <apply>
       <ci>pmod</ci>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{p}^{2}\equiv c^{\frac{1}{2}(p+1)}\equiv c\cdot c^{\frac{1}{2}(p-1)}\equiv c%
\cdot\left({c\over p}\right)\;\;(\mathop{{\rm mod}}p),
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Rabin_cryptosystem:55">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mfrac>
    <mi>c</mi>
    <mi>p</mi>
   </mfrac>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>c</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left({c\over p}\right)
  </annotation>
 </semantics>
</math>

 is a <a href="Legendre_symbol" title="wikilink">Legendre symbol</a>.</p>

<p>From 

<math display="inline" id="Rabin_cryptosystem:56">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>≡</mo>
   <mrow>
    <msup>
     <mi>m</mi>
     <mn>2</mn>
    </msup>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mrow>
       <mi>p</mi>
       <mi>q</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>c</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <ci>pmod</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\equiv m^{2}\;\;(\mathop{{\rm mod}}pq)
  </annotation>
 </semantics>
</math>

 follows that 

<math display="inline" id="Rabin_cryptosystem:57">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>≡</mo>
   <mrow>
    <msup>
     <mi>m</mi>
     <mn>2</mn>
    </msup>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>c</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\equiv m^{2}\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

. Thus <em>c</em> is a <a href="quadratic_residue" title="wikilink">quadratic residue</a> modulo <em>p</em>. Hence 

<math display="inline" id="Rabin_cryptosystem:58">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mi>c</mi>
     <mi>p</mi>
    </mfrac>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>c</ci>
     <ci>p</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left({c\over p}\right)=1
  </annotation>
 </semantics>
</math>

 and therefore</p>

<p>

<math display="block" id="Rabin_cryptosystem:59">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>m</mi>
     <mi>p</mi>
     <mn>2</mn>
    </msubsup>
    <mo>≡</mo>
    <mrow>
     <mi>c</mi>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>p</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>p</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <ci>c</ci>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{p}^{2}\equiv c\;\;(\mathop{{\rm mod}}p).
  </annotation>
 </semantics>
</math>

</p>

<p>The relation 

<math display="inline" id="Rabin_cryptosystem:60">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>≡</mo>
   <mrow>
    <mn>3</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>4</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>p</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">3</cn>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\equiv 3\;\;(\mathop{{\rm mod}}4)
  </annotation>
 </semantics>
</math>

 is not a requirement because square roots modulo other primes can be computed too. E.g., Rabin proposes to find the square roots modulo primes by using a special case of <a href="Berlekamp's_algorithm" title="wikilink">Berlekamp's algorithm</a>.</p>
<h2 id="evaluation-of-the-algorithm">Evaluation of the algorithm</h2>
<h3 id="effectiveness">Effectiveness</h3>

<p>Decoding produces three false results in addition to the correct one, so that the correct result must be guessed. This is the major disadvantage of the Rabin cryptosystem and one of the factors which have prevented it from finding widespread practical use.</p>

<p>If the plaintext is intended to represent a text message, guessing is not difficult; however, if the plaintext is intended to represent a numerical value, this issue becomes a problem that must be resolved by some kind of disambiguation scheme. It is possible to choose plaintexts with special structures, or to add <a href="padding_(cryptography)" title="wikilink">padding</a>, to eliminate this problem. A way of removing the ambiguity of inversion was suggested by Blum and Williams: the two primes used are restricted to primes congruent to 3 modulo 4 and the domain of the squaring is restricted to the set of quadratic residues. These restrictions make the squaring function into a <a href="Trapdoor_function" title="wikilink">trapdoor</a> <a class="uri" href="permutation" title="wikilink">permutation</a>, eliminating the ambiguity.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h3 id="efficiency">Efficiency</h3>

<p>For encryption, a square modulo <em>n</em> must be calculated. This is more efficient than <a href="RSA_(algorithm)" title="wikilink">RSA</a>, which requires the calculation of at least a cube. (Unless the convention of setting e=3 in the public key is used)</p>

<p>For decryption, the <a href="Chinese_remainder_theorem" title="wikilink">Chinese remainder theorem</a> is applied, along with two <a href="modular_exponentiation" title="wikilink">modular exponentiations</a>. Here the efficiency is comparable to RSA.</p>

<p>Disambiguation introduces additional computational costs, and is what has prevented the Rabin cryptosystem from finding widespread practical use.</p>
<h3 id="security">Security</h3>

<p>The great advantage of the Rabin cryptosystem is that a random plaintext can be recovered entirely from the ciphertext only if the codebreaker is capable of efficiently factoring the public key <em>n</em>. Note that this is a very weak level of security. Extensions of the Rabin cryptosystem achieve stronger notions of security.</p>

<p>It has been proven that decoding the Rabin cryptosystem is equivalent to the integer factorization problem, something that has not been proven for RSA. Thus the Rabin system is 'more secure' in this sense than is RSA, and will remain so until a general solution for the factorization problem is discovered, or until the RSA problem is discovered to be equivalent to factorization. (This assumes that the plaintext was not created with a specific structure to ease decoding.)</p>

<p>Since the solution to the factorization problem is being sought on many different fronts, any solution (outside classified research organizations such as <a class="uri" href="NSA" title="wikilink">NSA</a>) would rapidly become available to the whole scientific community. However, a solution has been long in coming, and the factorization problem has been, thus, practically insoluble. Without such an advance, an attacker would have no chance today of breaking the code. This cryptosystem is provably secure (in a strong sense) against <a href="chosen_plaintext" title="wikilink">chosen plaintext</a> attacks.</p>

<p>However, it has been proven an active attacker can break the system using a <a href="chosen_ciphertext_attack" title="wikilink">chosen ciphertext attack</a>. By adding redundancies, for example, the repetition of the last 64 bits, the system can be made to produce a single root. This thwarts the chosen-ciphertext attack, since the decoding algorithm then only produces the root that the attacker already knows. If this technique is applied, the proof of the equivalence with the factorization problem fails, so it is uncertain as of 2004 if this variant is secure. The <a href="http://www.cacr.math.uwaterloo.ca/hac/">Handbook of Applied Cryptography</a> by Menezes, Oorschot and Vanstone considers this equivalence probable, however, as long as the finding of the roots remains a two-part process (1. roots 

<math display="inline" id="Rabin_cryptosystem:61">
 <semantics>
  <mrow>
   <mi></mi>
   <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">modulo</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mod p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Rabin_cryptosystem:62">
 <semantics>
  <mrow>
   <mi></mi>
   <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">modulo</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mod q
  </annotation>
 </semantics>
</math>

 and 2. application of the Chinese remainder theorem).</p>

<p>Since in the encoding process, only the modulo remainders of perfect squares are used (in our example with 

<math display="inline" id="Rabin_cryptosystem:63">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>77</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">77</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=77
  </annotation>
 </semantics>
</math>

, this is only 23 of the 76 possible values), other attacks on the process are possible.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Topics_in_cryptography" title="wikilink">Topics in cryptography</a></li>
<li><a href="Blum_Blum_Shub" title="wikilink">Blum Blum Shub</a></li>
<li><a href="Shanks–Tonelli_algorithm" title="wikilink">Shanks–Tonelli algorithm</a></li>
<li><a href="Schmidt–Samoa_cryptosystem" title="wikilink">Schmidt–Samoa cryptosystem</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>Buchmann, Johannes. <em>Einführung in die Kryptographie</em>. Second Edition. Berlin: Springer, 2001. ISBN 3-540-41283-2</li>
<li>Menezes, Alfred; van Oorschot, Paul C.; and Vanstone, Scott A. <em>Handbook of Applied Cryptography</em>. CRC Press, October 1996. ISBN 0-8493-8523-7</li>
<li>Rabin, Michael. <em><a href="http://www.lcs.mit.edu/publications/pubs/pdf/MIT-LCS-TR-212.pdf">Digitalized Signatures and Public-Key Functions as Intractable as Factorization</a></em> (in PDF). MIT Laboratory for Computer Science, January 1979.</li>
<li>Scott Lindhurst, An analysis of Shank's algorithm for computing square roots in finite fields. in R Gupta and K S Williams, Proc 5th Conf Can Nr Theo Assoc, 1999, vol 19 CRM Proc &amp; Lec Notes, AMS, Aug 1999.</li>
<li>R Kumanduri and C Romero, Number Theory w/ Computer Applications, Alg 9.2.9, Prentice Hall, 1997. A probabilistic for square root of a quadratic residue modulo a prime.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cacr.math.uwaterloo.ca/hac/">Menezes, Oorschot, Vanstone, Scott: <em>Handbook of Applied Cryptography</em> (free PDF downloads), see Chapter 8</a></li>
</ul>

<p>"</p>

<p><a href="Category:Public-key_encryption_schemes" title="wikilink">Category:Public-key encryption schemes</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Shafi_Goldwasser" title="wikilink">Shafi Goldwasser</a> and <a href="Mihir_Bellare" title="wikilink">Mihir Bellare</a> <a href="http://cseweb.ucsd.edu/~mihir/papers/gb.html">"Lecture Notes on Cryptography"</a>. Summer course on cryptography, MIT, 1996-2001<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
