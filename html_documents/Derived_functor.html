<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="876">Derived functor</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Derived functor</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, certain <a href="functor" title="wikilink">functors</a> may be <em>derived</em> to obtain other functors closely related to the original ones. This operation, while fairly abstract, unifies a number of constructions throughout mathematics.</p>
<h2 id="motivation">Motivation</h2>

<p>It was noted in various quite different settings that a <a href="short_exact_sequence" title="wikilink">short exact sequence</a> often gives rise to a "long exact sequence". The concept of derived functors explains and clarifies many of these observations.</p>

<p>Suppose we are given a covariant <a href="left_exact_functor" title="wikilink">left exact functor</a> <em>F</em> : <strong>A</strong> → <strong>B</strong> between two <a href="abelian_category" title="wikilink">abelian categories</a> <strong>A</strong> and <strong>B</strong>. If 0 → <em>A</em> → <em>B</em> → <em>C</em> → 0 is a short exact sequence in <strong>A</strong>, then applying <em>F</em> yields the exact sequence 0 → <em>F</em>(<em>A</em>) → <em>F</em>(<em>B</em>) → <em>F</em>(<em>C</em>) and one could ask how to continue this sequence to the right to form a long exact sequence. Strictly speaking, this question is ill-posed, since there are always numerous different ways to continue a given exact sequence to the right. But it turns out that (if <strong>A</strong> is "nice" enough) there is one <a href="canonical_form" title="wikilink">canonical</a> way of doing so, given by the right derived functors of <em>F</em>. For every <em>i</em>≥1, there is a functor <em>R<sup>i</sup>F</em>: <strong>A</strong> → <strong>B</strong>, and the above sequence continues like so: 0 → <em>F</em>(<em>A</em>) → <em>F</em>(<em>B</em>) → <em>F</em>(<em>C</em>) → <em>R</em><sup>1</sup><em>F</em>(<em>A</em>) → <em>R</em><sup>1</sup><em>F</em>(<em>B</em>) → <em>R</em><sup>1</sup><em>F</em>(<em>C</em>) → <em>R</em><sup>2</sup><em>F</em>(<em>A</em>) → <em>R</em><sup>2</sup><em>F</em>(<em>B</em>) → ... . From this we see that <em>F</em> is an exact functor if and only if <em>R</em><sup>1</sup><em>F</em> = 0; so in a sense the right derived functors of <em>F</em> measure "how far" <em>F</em> is from being exact.</p>

<p>If the object <em>A</em> in the above short exact sequence is <a href="injective_object" title="wikilink">injective</a>, then the sequence <a href="Splitting_lemma" title="wikilink">splits</a>. Applying any additive functor to a split sequence results in a split sequence, so in particular <em>R</em><sup>1</sup><em>F</em>(<em>A</em>) = 0. Right derived functors are zero on injectives: this is the motivation for the construction given below.</p>
<h2 id="construction-and-first-properties">Construction and first properties</h2>

<p>The crucial assumption we need to make about our abelian category <strong>A</strong> is that it has <em>enough injectives</em>, meaning that for every object <em>A</em> in <strong>A</strong> there exists a <a class="uri" href="monomorphism" title="wikilink">monomorphism</a> <em>A</em> → <em>I</em> where <em>I</em> is an <a href="injective_object" title="wikilink">injective object</a> in <strong>A</strong>.</p>

<p>The right derived functors of the covariant left-exact functor <em>F</em> : <strong>A</strong> → <strong>B</strong> are then defined as follows. Start with an object <em>X</em> of <strong>A</strong>. Because there are enough injectives, we can construct a long exact sequence of the form</p>

<p>

<math display="block" id="Derived_functor:0">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mi>X</mi>
   <mo>→</mo>
   <msup>
    <mi>I</mi>
    <mn>0</mn>
   </msup>
   <mo>→</mo>
   <msup>
    <mi>I</mi>
    <mn>1</mn>
   </msup>
   <mo>→</mo>
   <msup>
    <mi>I</mi>
    <mn>2</mn>
   </msup>
   <mo>→</mo>
   <mi mathvariant="normal">⋯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <ci>X</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>I</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>I</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>I</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\to X\to I^{0}\to I^{1}\to I^{2}\to\cdots
  </annotation>
 </semantics>
</math>

 where the <em>I</em><sup> <em>i</em></sup> are all injective (this is known as an <em>injective resolution</em> of <em>X</em>). Applying the functor <em>F</em> to this sequence, and chopping off the first term, we obtain the <a href="chain_complex" title="wikilink">chain complex</a></p>

<p>

<math display="block" id="Derived_functor:1">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>I</mi>
      <mn>0</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>I</mi>
      <mn>1</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>I</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mi mathvariant="normal">⋯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <ci>F</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>I</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>F</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>I</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>F</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>I</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\to F(I^{0})\to F(I^{1})\to F(I^{2})\to\cdots
  </annotation>
 </semantics>
</math>

</p>

<p>Note: this is in general <em>not</em> an exact sequence anymore. But we can compute its <a href="homology_(mathematics)" title="wikilink">homology</a> at the <em>i</em>-th spot (the kernel of the map from <em>F</em>(<em>I</em><sup><em>i</em></sup>) modulo the image of the map to <em>F</em>(<em>I</em><sup><em>i</em></sup>)); we call the result <em>R<sup>i</sup>F</em>(<em>X</em>). Of course, various things have to be checked: the end result does not depend on the given injective resolution of <em>X</em>, and any morphism <em>X</em> → <em>Y</em> naturally yields a morphism <em>R<sup>i</sup>F</em>(<em>X</em>) → <em>R<sup>i</sup>F</em>(<em>Y</em>), so that we indeed obtain a functor. Note that left exactness means that 0 →<em>F</em>(<em>X</em>) → <em>F</em>(<em>I</em><sup>0</sup>) → <em>F</em>(<em>I</em><sup>1</sup>) is exact, so <em>R</em><sup>0</sup><em>F</em>(<em>X</em>) = <em>F</em>(<em>X</em>), so we only get something interesting for <em>i</em>&gt;0.</p>

<p>(Technically, to produce well-defined derivatives of <em>F</em>, we would have to fix an injective resolution for every object of <strong>A</strong>. This choice of injective resolutions then yields functors <em>R<sup>i</sup>F</em>. Different choices of resolutions yield <a href="naturally_isomorphic" title="wikilink">naturally isomorphic</a> functors, so in the end the choice doesn't really matter.)</p>

<p>The above-mentioned property of turning short exact sequences into long exact sequences is a consequence of the <a href="snake_lemma" title="wikilink">snake lemma</a>. This tell us that the collection of derived functors is a <a href="Delta-functor" title="wikilink">δ-functor</a>.</p>

<p>If <em>X</em> is itself injective, then we can choose the injective resolution 0 → <em>X</em> → <em>X</em> → 0, and we obtain that <em>R<sup>i</sup>F</em>(<em>X</em>) = 0 for all <em>i</em> ≥ 1. In practice, this fact, together with the long exact sequence property, is often used to compute the values of right derived functors.</p>

<p>An equivalent way to compute <em>R<sup>i</sup>F</em>(<em>X</em>) is the following: take an injective resolution of <em>X</em> as above, and let <em>K</em><sup><em>i</em></sup> be the image of the map <em>I</em><sup><em>i</em>-1</sup>→<em>I<sup>i</sup></em> (for <em>i</em>=0, define <em>I</em><sup><em>i</em>-1</sup>=0), which is the same as the kernel of <em>I</em><sup><em>i</em></sup>→<em>I</em><sup><em>i</em>+1</sup>. Let φ<sub><em>i</em></sub> : <em>I</em><sup><em>i</em>-1</sup>→<em>K</em><sup><em>i</em></sup> be the corresponding surjective map. Then <em>R<sup>i</sup>F</em>(<em>X</em>) is the cokernel of <em>F</em>(φ<sub><em>i</em></sub>).</p>
<h2 id="variations">Variations</h2>

<p>If one starts with a covariant <em>right-exact</em> functor <em>G</em>, and the category <strong>A</strong> has enough projectives (i.e. for every object <em>A</em> of <strong>A</strong> there exists an epimorphism <em>P</em> → <em>A</em> where <em>P</em> is a <a href="projective_module" title="wikilink">projective object</a>), then one can define analogously the left-derived functors <em>L<sub>i</sub>G</em>. For an object <em>X</em> of <strong>A</strong> we first construct a projective resolution of the form</p>

<p>

<math display="block" id="Derived_functor:2">
 <semantics>
  <mrow>
   <mi mathvariant="normal">⋯</mi>
   <mo>→</mo>
   <msub>
    <mi>P</mi>
    <mn>2</mn>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>P</mi>
    <mn>1</mn>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>P</mi>
    <mn>0</mn>
   </msub>
   <mo>→</mo>
   <mi>X</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>X</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdots\to P_{2}\to P_{1}\to P_{0}\to X\to 0
  </annotation>
 </semantics>
</math>

 where the <em>P</em><sub><em>i</em></sub> are projective. We apply <em>G</em> to this sequence, chop off the last term, and compute homology to get <em>L<sub>i</sub>G</em>(<em>X</em>). As before, <em>L</em><sub>0</sub><em>G</em>(<em>X</em>) = <em>G</em>(<em>X</em>).</p>

<p>In this case, the long exact sequence will grow "to the left" rather than to the right:</p>

<p>

<math display="block" id="Derived_functor:3">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mi>A</mi>
   <mo>→</mo>
   <mi>B</mi>
   <mo>→</mo>
   <mi>C</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>B</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>C</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\to A\to B\to C\to 0
  </annotation>
 </semantics>
</math>

 is turned into</p>

<p>

<math display="block" id="Derived_functor:4">
 <semantics>
  <mrow>
   <mi mathvariant="normal">⋯</mi>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>L</mi>
     <mn>2</mn>
    </msub>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>L</mi>
     <mn>1</mn>
    </msub>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>L</mi>
     <mn>1</mn>
    </msub>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>L</mi>
     <mn>1</mn>
    </msub>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>G</ci>
      <ci>C</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>G</ci>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>G</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>G</ci>
      <ci>C</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>C</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdots\to L_{2}G(C)\to L_{1}G(A)\to L_{1}G(B)\to L_{1}G(C)\to G(A)\to G(B)\to G%
(C)\to 0
  </annotation>
 </semantics>
</math>

.</p>

<p>Left derived functors are zero on all projective objects.</p>

<p>One may also start with a <em>contravariant</em> left-exact functor <em>F</em>; the resulting right-derived functors are then also contravariant. The short exact sequence</p>

<p>

<math display="block" id="Derived_functor:5">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mi>A</mi>
   <mo>→</mo>
   <mi>B</mi>
   <mo>→</mo>
   <mi>C</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>B</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>C</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\to A\to B\to C\to 0
  </annotation>
 </semantics>
</math>

</p>

<p>is turned into the long exact sequence</p>

<p>

<math display="block" id="Derived_functor:6">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>R</mi>
     <mn>1</mn>
    </msup>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>R</mi>
     <mn>1</mn>
    </msup>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>R</mi>
     <mn>1</mn>
    </msup>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msup>
     <mi>R</mi>
     <mn>2</mn>
    </msup>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mi mathvariant="normal">⋯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>C</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>F</ci>
      <ci>C</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>F</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>F</ci>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>F</ci>
      <ci>C</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\to F(C)\to F(B)\to F(A)\to R^{1}F(C)\to R^{1}F(B)\to R^{1}F(A)\to R^{2}F(C)\to\cdots
  </annotation>
 </semantics>
</math>

</p>

<p>These right derived functors are zero on projectives and are therefore computed via projective resolutions.</p>
<h2 id="applications">Applications</h2>

<p><strong><a href="Sheaf_cohomology" title="wikilink">Sheaf cohomology</a>.</strong> If <em>X</em> is a <a href="topological_space" title="wikilink">topological space</a>, then the category of all <a href="sheaf_(mathematics)" title="wikilink">sheaves</a> of <a href="abelian_group" title="wikilink">abelian groups</a> on <em>X</em> is an abelian category with enough injectives. The functor which assigns to each such sheaf <em>L</em> the group <em>L</em>(<em>X</em>) of global sections is left exact, and the right derived functors are the <a href="sheaf_cohomology" title="wikilink">sheaf cohomology</a> functors, usually written as <em>H</em><sup> <em>i</em></sup>(<em>X</em>,<em>L</em>). Slightly more generally: if (<em>X</em>, O<sub><em>X</em></sub>) is a <a href="ringed_space" title="wikilink">ringed space</a>, then the category of all sheaves of O<sub><em>X</em></sub>-modules is an abelian category with enough injectives, and we can again construct sheaf cohomology as the right derived functors of the global section functor.</p>

<p><strong><a href="Étale_cohomology" title="wikilink">Étale cohomology</a></strong> is another cohomology theory for sheaves over a scheme.</p>

<p><strong><a href="Ext_functor" title="wikilink">Ext functors</a>.</strong> If <em>R</em> is a <a href="ring_(mathematics)" title="wikilink">ring</a>, then the category of all left <a href="module_(mathematics)" title="wikilink"><em>R</em>-modules</a> is an abelian category with enough injectives. If <em>A</em> is a fixed left <em>R</em>-module, then the functor Hom(<em>A</em>,-) is left exact, and its right derived functors are the <a href="Ext_functor" title="wikilink">Ext functors</a> Ext<sub><em>R</em></sub><sup><em>i</em></sup>(<em>A</em>,-).</p>

<p><strong><a href="Tor_functor" title="wikilink">Tor functors</a>.</strong> The category of left <em>R</em>-modules also has enough projectives. If <em>A</em> is a fixed right <em>R</em>-module, then the <a href="tensor_product" title="wikilink">tensor product</a> with <em>A</em> gives a right exact covariant functor on the category of left <em>R</em>-modules; its left derivatives are the <a href="Tor_functor" title="wikilink">Tor functors</a> Tor<sup><em>R</em></sup><sub><em>i</em></sub>(<em>A</em>,-).</p>

<p><strong><a href="Group_cohomology" title="wikilink">Group cohomology</a>.</strong> Let <em>G</em> be a <a href="group_(mathematics)" title="wikilink">group</a>. A <a href="G-module" title="wikilink"><em>G</em>-module</a> <em>M</em> is an <a href="abelian_group" title="wikilink">abelian group</a> <em>M</em> together with a <a href="group_action" title="wikilink">group action</a> of <em>G</em> on <em>M</em> as a group of automorphisms. This is the same as a <a href="module_(mathematics)" title="wikilink">module</a> over the <a href="group_ring" title="wikilink">group ring</a> <strong>Z</strong><em>G</em>. The <em>G</em>-modules form an abelian category with enough injectives. We write <em>M</em><sup><em>G</em></sup> for the subgroup of <em>M</em> consisting of all elements of <em>M</em> that are held fixed by <em>G</em>. This is a left-exact functor, and its right derived functors are the group cohomology functors, typically written as H<sup> <em>i</em></sup>(<em>G</em>,<em>M</em>).</p>
<h2 id="naturality">Naturality</h2>

<p>Derived functors and the long exact sequences are "natural" in several technical senses.</p>

<p>First, given a <a href="commutative_diagram" title="wikilink">commutative diagram</a> of the form</p>

<p>

<math display="inline" id="Derived_functor:7">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="center">
     <mn>0</mn>
    </mtd>
    <mtd columnalign="center">
     <mover accent="true">
      <mo>→</mo>
      <mi></mi>
     </mover>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi>A</mi>
      <msub>
       <mo>;</mo>
       <mn>1</mn>
      </msub>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mover accent="true">
      <mo>→</mo>
      <msub>
       <mi>f</mi>
       <mn>1</mn>
      </msub>
     </mover>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi>B</mi>
      <msub>
       <mo>;</mo>
       <mn>1</mn>
      </msub>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mover accent="true">
      <mo>→</mo>
      <msub>
       <mi>g</mi>
       <mn>1</mn>
      </msub>
     </mover>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi>C</mi>
      <msub>
       <mo>;</mo>
       <mn>1</mn>
      </msub>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mover accent="true">
      <mo>→</mo>
      <mi></mi>
     </mover>
    </mtd>
    <mtd columnalign="center">
     <mn>0</mn>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd></mtd>
    <mtd columnalign="center">
     <mrow>
      <mi>α</mi>
      <mo>↓</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd columnalign="center">
     <mrow>
      <mi>β</mi>
      <mo>↓</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd columnalign="center">
     <mrow>
      <mi>γ</mi>
      <mo>↓</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mn>0</mn>
    </mtd>
    <mtd columnalign="center">
     <mover accent="true">
      <mo>→</mo>
      <mi></mi>
     </mover>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi>A</mi>
      <msub>
       <mo>;</mo>
       <mn>2</mn>
      </msub>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mover accent="true">
      <mo>→</mo>
      <msub>
       <mi>f</mi>
       <mn>2</mn>
      </msub>
     </mover>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi>B</mi>
      <msub>
       <mo>;</mo>
       <mn>2</mn>
      </msub>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mover accent="true">
      <mo>→</mo>
      <msub>
       <mi>g</mi>
       <mn>2</mn>
      </msub>
     </mover>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mi>C</mi>
      <msub>
       <mo>;</mo>
       <mn>2</mn>
      </msub>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mover accent="true">
      <mo>→</mo>
      <mi></mi>
     </mover>
    </mtd>
    <mtd columnalign="center">
     <mn>0</mn>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="latexml">absent</csymbol>
      <ci>normal-→</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">A</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">1</cn>
      </apply>
     </cerror>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">B</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">1</cn>
      </apply>
     </cerror>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">1</cn>
      </apply>
     </cerror>
     <apply>
      <csymbol cd="latexml">absent</csymbol>
      <ci>normal-→</ci>
     </apply>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <ci>normal-↓</ci>
      <ci>α</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <ci>normal-↓</ci>
      <ci>β</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <ci>normal-↓</ci>
      <ci>γ</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="latexml">absent</csymbol>
      <ci>normal-→</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">A</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">2</cn>
      </apply>
     </cerror>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">B</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">2</cn>
      </apply>
     </cerror>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-→</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-;</ci>
       <cn type="integer">2</cn>
      </apply>
     </cerror>
     <apply>
      <csymbol cd="latexml">absent</csymbol>
      <ci>normal-→</ci>
     </apply>
     <cn type="integer">0</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{ccccccccc}0&\xrightarrow{}&A;_{1}&\xrightarrow{f_{1}}&B;_{1}&%
\xrightarrow{g_{1}}&C;_{1}&\xrightarrow{}&0\\
&&\alpha\downarrow&&\beta\downarrow&&\gamma\downarrow&&\\
0&\xrightarrow{}&A;_{2}&\xrightarrow{f_{2}}&B;_{2}&\xrightarrow{g_{2}}&C;_{2}&%
\xrightarrow{}&0\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>(where the rows are exact), the two resulting long exact sequences are related by commuting squares:</p>
<figure><b>(Figure)</b>
<figcaption>two long exact sequences.png</figcaption>
</figure>

<p>Second, suppose η : <em>F</em> → <em>G</em> is a <a href="natural_transformation" title="wikilink">natural transformation</a> from the left exact functor <em>F</em> to the left exact functor <em>G</em>. Then natural transformations <em>R<sup>i</sup></em>η : <em>R<sup>i</sup>F</em> → <em>R<sup>i</sup>G</em> are induced, and indeed <em>R<sup>i</sup></em> becomes a functor from the <a href="functor_category" title="wikilink">functor category</a> of all left exact functors from <strong>A</strong> to <strong>B</strong> to the full functor category of all functors from <strong>A</strong> to <strong>B</strong>. Furthermore, this functor is compatible with the long exact sequences in the following sense: if</p>

<p>

<math display="block" id="Derived_functor:8">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mover accent="true">
    <mo>→</mo>
    <mi></mi>
   </mover>
   <mi>A</mi>
   <mover accent="true">
    <mo>→</mo>
    <mo>𝑓</mo>
   </mover>
   <mi>B</mi>
   <mover accent="true">
    <mo>→</mo>
    <mo>𝑔</mo>
   </mover>
   <mi>C</mi>
   <mover accent="true">
    <mo>→</mo>
    <mi></mi>
   </mover>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <csymbol cd="latexml">absent</csymbol>
      <ci>normal-→</ci>
     </apply>
     <cn type="integer">0</cn>
     <ci>A</ci>
    </apply>
    <apply>
     <apply>
      <ci>f</ci>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <ci>B</ci>
    </apply>
    <apply>
     <apply>
      <ci>g</ci>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <ci>C</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="latexml">absent</csymbol>
      <ci>normal-→</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\xrightarrow{}A\xrightarrow{f}B\xrightarrow{g}C\xrightarrow{}0
  </annotation>
 </semantics>
</math>

 is a short exact sequence, then a commutative diagram</p>
<figure><b>(Figure)</b>
<figcaption>two long exact sequences2.png</figcaption>
</figure>

<p>is induced.</p>

<p>Both of these naturalities follow from the naturality of the sequence provided by the <a href="snake_lemma" title="wikilink">snake lemma</a>.</p>

<p>Conversely, the following characterization of derived functors holds: given a family of functors <em>R</em><sup><em>i</em></sup>: <strong>A</strong> → <strong>B</strong>, satisfying the above, i.e. mapping short exact sequences to long exact sequences, such that for every injective object <em>I</em> of <strong>A</strong>, <em>R</em><sup><em>i</em></sup>(<em>I</em>)=0 for every positive <em>i</em>, then these functors are the right derived functors of <em>R</em><sup>0</sup>.</p>
<h2 id="generalization">Generalization</h2>

<p>The more modern (and more general) approach to derived functors uses the language of <a href="derived_category" title="wikilink">derived categories</a>.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Homological_algebra" title="wikilink">Category:Homological algebra</a> <a class="uri" href="Category:Functors" title="wikilink">Category:Functors</a></p>
</body>
</html>
