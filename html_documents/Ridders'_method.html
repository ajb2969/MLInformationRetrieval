<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="422">Ridders' method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Ridders' method</h1>
<hr/>

<p>In <a href="numerical_analysis" title="wikilink">numerical analysis</a>, <strong>Ridders' method</strong> is a <a href="root-finding_algorithm" title="wikilink">root-finding algorithm</a> based on the <a href="false_position_method" title="wikilink">false position method</a> and the use of an <a href="exponential_function" title="wikilink">exponential function</a> to successively approximate a <a href="Root_of_a_function" title="wikilink">root</a> of a <a href="Function_(mathematics)" title="wikilink">function</a> <em>f</em>. The method is due to C. Ridders.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Ridders' method is simpler than <a href="Muller's_method" title="wikilink">Muller's method</a> or <a href="Brent's_method" title="wikilink">Brent's method</a> but with similar performance.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The formula below converges quadratically when the function is well-behaved, which implies that the number of additional significant digits found at each step approximately doubles; but the function has to be evaluated twice for each step, so the overall <a href="order_of_convergence" title="wikilink">order of convergence</a> of the method is √2. If the function is not well-behaved, the root remains bracketed and the length of the bracketing interval at least halves on each iteration, so convergence is guaranteed. The algorithm also makes use of square roots, which are slower than basic floating point operations.</p>
<h2 id="method">Method</h2>

<p>Press et al. (2007) describe the method as follows. Given two values of the independent variable, <em>x</em><sub>1</sub> and <em>x</em><sub>2</sub>, which are on two different sides of the root being sought, the method begins by evaluating the function at the midpoint <em>x</em><sub>3</sub> between the two points. One then finds the unique exponential function of the form <em>e</em><sup><em>ax</em></sup> which, when multiplied by <em>f</em>, transforms the function at the three points into a straight line. The false position method is then applied to the transformed values, leading to a new value <em>x</em><sub>4</sub>, between <em>x</em><sub>1</sub> and <em>x</em><sub>2</sub>, which can be used as one of the two bracketing values in the next step of the iteration. The other bracketing value is taken to be <em>x</em><sub>3</sub> if f(<em>x</em><sub>3</sub>) has the opposite sign to f(<em>x</em><sub>4</sub>), or otherwise whichever of <em>x</em><sub>1</sub> and <em>x</em><sub>2</sub> has f(x) of opposite sign to f(<em>x</em><sub>4</sub>).</p>

<p>The method can be summarized by the formula (equation 9.2.4 from Press et al.)</p>

<p>

<math display="block" id="Ridders'_method:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>4</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>3</mn>
     </msub>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mn>3</mn>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mfrac>
       <mrow>
        <mrow>
         <mrow>
          <mo>sign</mo>
          <mrow>
           <mo stretchy="false">[</mo>
           <mrow>
            <mrow>
             <mi>f</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <msub>
               <mi>x</mi>
               <mn>1</mn>
              </msub>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo>-</mo>
            <mrow>
             <mi>f</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <msub>
               <mi>x</mi>
               <mn>2</mn>
              </msub>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
           </mrow>
           <mo stretchy="false">]</mo>
          </mrow>
         </mrow>
         <mi>f</mi>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mn>3</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <msqrt>
        <mrow>
         <mrow>
          <mi>f</mi>
          <msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>x</mi>
             <mn>3</mn>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
           <mn>2</mn>
          </msup>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>x</mi>
            <mn>1</mn>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>x</mi>
            <mn>2</mn>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </msqrt>
      </mfrac>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">4</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <apply>
          <ci>sign</ci>
          <apply>
           <minus></minus>
           <apply>
            <times></times>
            <ci>f</ci>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <cn type="integer">1</cn>
            </apply>
           </apply>
           <apply>
            <times></times>
            <ci>f</ci>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <cn type="integer">2</cn>
            </apply>
           </apply>
          </apply>
         </apply>
         <ci>f</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">3</cn>
        </apply>
       </apply>
       <apply>
        <root></root>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>f</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <cn type="integer">3</cn>
           </apply>
           <cn type="integer">2</cn>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>f</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>f</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{4}=x_{3}+(x_{3}-x_{1})\frac{\operatorname{sign}[f(x_{1})-f(x_{2})]f(x_{3})}%
{\sqrt{f(x_{3})^{2}-f(x_{1})f(x_{2})}}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Root-finding_algorithms" title="wikilink">Category:Root-finding algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
