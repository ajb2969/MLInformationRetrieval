<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="220">Büchi automaton</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Büchi automaton</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a> and <a href="automata_theory" title="wikilink">automata theory</a>, a <strong>Büchi automaton</strong> is a type of <a class="uri" href="ω-automaton" title="wikilink">ω-automaton</a>, which extends a <a href="finite_automaton" title="wikilink">finite automaton</a> to infinite inputs. It accepts an infinite input sequence if there exists a run of the automaton that visits (at least) one of the final states infinitely often. Büchi automata recognize the <a href="omega-regular_languages" title="wikilink">omega-regular languages</a>, the infinite word version of <a href="regular_languages" title="wikilink">regular languages</a>. It is named after the Swiss mathematician <a href="Julius_Richard_Büchi" title="wikilink">Julius Richard Büchi</a> who invented this kind of automaton in 1962.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Büchi automata are often used in <a href="model_checking" title="wikilink">model checking</a> as an automata-theoretic version of a formula in <a href="linear_temporal_logic" title="wikilink">linear temporal logic</a>.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>Formally, a <strong>deterministic Büchi automaton</strong> is a tuple <em>A</em> = (<em>Q</em>,Σ,δ,<em>q</em><sub>0</sub>,<strong>F</strong>) that consists of the following components:</p>
<ul>
<li><em>Q</em> is a <a href="finite_set" title="wikilink">finite set</a>. The elements of <em>Q</em> are called the <em>states</em> of <em>A</em>.</li>
<li>Σ is a finite set called the <em>alphabet</em> of <em>A</em>.</li>
<li>δ: <em>Q</em> × Σ → <em>Q</em> is a function, called the <em>transition function</em> of <em>A</em>.</li>
<li><em>q</em><sub>0</sub> is an element of <em>Q</em>, called the <em>initial state</em> of <em>A</em>.</li>
<li><strong>F</strong>⊆<em>Q</em> is the <em>acceptance condition</em>. <em>A</em> accepts exactly those runs in which at least one of the infinitely often occurring states is in <strong>F</strong>.</li>
</ul>

<p>In a <strong>non-deterministic Büchi automaton</strong>, the transition function δ is replaced with a transition relation Δ that returns a set of states, and the single initial state <em>q</em><sub>0</sub> is replaced by a set <em>I</em> of initial states. Generally, the term Büchi automaton without qualifier refers to non-deterministic Büchi automata.</p>

<p>For more comprehensive formalism see also <a class="uri" href="ω-automaton" title="wikilink">ω-automaton</a>.</p>
<h2 id="closure-properties">Closure properties</h2>

<p>The set of Büchi automata is <a href="closed_under" title="wikilink">closed under</a> the following operations.</p>

<p>Let A=(<em>Q</em><sub>A</sub>,Σ,Δ<sub>A</sub>,<em>I</em><sub>A</sub>,<em>F</em><sub>A</sub>) and B=(<em>Q</em><sub>B</sub>,Σ,Δ<sub>B</sub>,<em>I</em><sub>B</sub>,<em>F</em><sub>B</sub>) be Büchi automata and C=(<em>Q</em><sub>C</sub>,Σ,Δ<sub>C</sub>,<em>I</em><sub>C</sub>,<em>F</em><sub>C</sub>) be a <a href="finite_automaton" title="wikilink">finite automaton</a>.</p>
<ul>
<li><strong>Union</strong>: <em>There is a Büchi automaton that recognizes the language L(A)∪L(B).</em></li>
</ul>
<dl>
<dd><strong>Proof:</strong> If we assume, <em><a class="uri" href="w.l.o.g." title="wikilink">w.l.o.g.</a></em>, <em>Q</em><sub>A</sub>∩<em>Q</em><sub>B</sub> is empty then L(A)∪L(B) is recognized by the Büchi automaton (<em>Q</em><sub>A</sub>∪<em>Q</em><sub>B</sub>, Σ, Δ<sub>A</sub>∪Δ<sub>B</sub>, <em>I</em><sub>A</sub>∪<em>I</em><sub>B</sub>, <em>F</em><sub>A</sub>∪<em>F</em><sub>B</sub>).
</dd>
</dl>
<ul>
<li><strong>Intersection</strong>: <em>There is a Büchi automaton that recognizes the language L(A)∩L(B).</em></li>
</ul>
<dl>
<dd><strong>Proof:</strong> The Büchi automaton A'=(Q',Σ,Δ',I',F') recognizes L(A)∩L(B), where
</dd>
</dl>
<ul>
<li><ul>
<li>Q' = <em>Q</em><sub>A</sub> × <em>Q</em><sub>B</sub> × {1,2}</li>
<li>Δ' = Δ<sub>1</sub> ∪ Δ<sub>2</sub>
<ul>
<li>Δ<sub>1</sub> = {( (q<sub>A</sub>,q<sub>B</sub>,1), a, (q'<sub>A</sub>,q'<sub>B</sub>,i) ) | (q<sub>A</sub>,a,q'<sub>A</sub>)∈Δ<sub>A</sub> and (q<sub>B</sub>,a,q'<sub>B</sub>)∈Δ<sub>B</sub> and if q<sub>A</sub>∈F<sub>A</sub> then i=2 else i=1 }</li>
<li>Δ<sub>2</sub> = {( (q<sub>A</sub>,q<sub>B</sub>,2), a, (q'<sub>A</sub>,q'<sub>B</sub>,i) ) | (q<sub>A</sub>,a,q'<sub>A</sub>)∈Δ<sub>A</sub> and (q<sub>B</sub>,a,q'<sub>B</sub>)∈Δ<sub>B</sub> and if q<sub>B</sub>∈F<sub>B</sub> then i=1 else i=2 }</li>
</ul></li>
<li>I' = I<sub>A</sub> × I<sub>B</sub> × {1}</li>
<li>F' = { (q<sub>A</sub>,q<sub>B</sub>,2) | q<sub>B</sub>∈F<sub>B</sub> }</li>
</ul></li>
</ul>
<dl>
<dd>By construction, r'=(q<sub>A</sub><sup>0</sup>,q<sub>B</sub><sup>0</sup>,i<sup>0</sup>),(q<sub>A</sub><sup>1</sup>,q<sub>B</sub><sup>1</sup>,i<sup>1</sup>),... is a run of automaton A' on input word <em>w</em> iff r<sub>A</sub>=q<sub>A</sub><sup>0</sup>,q<sub>A</sub><sup>1</sup>,... is run of A on <em>w</em> and r<sub>B</sub>=q<sub>B</sub><sup>0</sup>,q<sub>B</sub><sup>1</sup>,... is run of B on <em>w</em>. r<sub>A</sub> is accepting and r<sub>B</sub> is accepting iff r' is concatenation of an infinite series of finite segments of 1-states(states with third component 1) and 2-states(states with third component 2) alternatively. There is such a series of segments of r' iff r' is accepted by A'.
</dd>
</dl>
<ul>
<li><strong>Concatenation</strong>: <em>There is a Büchi automaton that recognizes the language L(C)⋅L(A).</em></li>
</ul>
<dl>
<dd><strong>Proof:</strong> If we assume, <em>w.l.o.g.</em>, <em>Q</em><sub>C</sub>∩<em>Q</em><sub>A</sub> is empty then the Büchi automaton A'=(Q<sub>C</sub>∪Q<sub>A</sub>,Σ,Δ',I',F<sub>A</sub>) recognizes L(C)⋅L(A), where
</dd>
</dl>
<ul>
<li><ul>
<li>Δ' = Δ<sub>A</sub> ∪ Δ<sub>C</sub> ∪ { (q,a,q') | q'∈I<sub>A</sub> and ∃f∈F<sub>C</sub>. (q,a,f)∈Δ<sub>C</sub> }</li>
<li>if I<sub>C</sub>∩F<sub>C</sub> is empty then I' = I<sub>C</sub> otherwise I' = I<sub>C</sub> ∪ I<sub>A</sub></li>
</ul></li>
<li><strong>ω-closure</strong>: <em>If L(C) does not contain the empty word then there is a Büchi automaton that recognizes the language L(C)<sup>ω</sup>.</em></li>
</ul>
<dl>
<dd><strong>Proof:</strong> The Büchi automaton that recognizes L(C)<sup>ω</sup> is constructed in two stages. First, we construct a finite automaton A' such that A' also recognizes L(C) but there are no incoming transitions to initial states of A'. So, A'=(Q<sub>C</sub> ∪ {q<sub>new</sub>},Σ,Δ',{q<sub>new</sub>},F<sub>C</sub>), where Δ' = Δ<sub>C</sub> ∪ { (q<sub>new</sub>,a,q') | ∃q∈I<sub>C</sub>. (q,a,q')∈Δ<sub>C</sub>}. Note that L(C)=L(A') because L(C) does not contain the empty string. Second, we will construct the Büchi automaton A" that recognize L(C)<sup>ω</sup> by adding a loop back to the initial state of A'. So, A"=(Q<sub>C</sub> ∪ {q<sub>new</sub>},Σ,Δ",{q<sub>new</sub>},{q<sub>new</sub>}), where Δ" = Δ' ∪ { (q,a,q<sub>new</sub>) | ∃q'∈F<sub>C</sub>. (q,a,q')∈Δ'}.
</dd>
</dl>
<ul>
<li><strong>Complementation</strong>:<em>There is a Büchi automaton that recognizes the language Σ<sup>ω</sup>/L(A).</em></li>
</ul>
<dl>
<dd><strong>Proof:</strong> The proof is presented <a href="Complementation_of_Büchi_automaton" title="wikilink">here</a>.
</dd>
</dl>
<h2 id="recognizable-languages">Recognizable languages</h2>

<p>Büchi automata recognize the <a href="ω-regular_language" title="wikilink">ω-regular languages</a>. Using the definition of ω-regular language and the above closure properties of Büchi automata, it can be easily shown that a Büchi automaton can be constructed such that it recognizes any given ω-regular language. For converse, see <a href="ω-regular_language#Equivalence_to_Büchi_automaton" title="wikilink">construction of a ω-regular language</a> for a Büchi automaton.</p>
<dl>
<dt>Deterministic versus non-deterministic Büchi automata</dt>
</dl>

<p> The class of deterministic Büchi automata does not suffice to encompass all omega-regular languages. In particular, there is no deterministic Büchi automaton that recognizes the language (0+1)*0<sup>ω</sup> (Any word that has an infinite suffix consisting of only 0's). We can demonstrate it by contradiction that no such deterministic Büchi automaton exists. Let us suppose <em>A</em> is a deterministic Büchi automaton that recognize (0+1)*0<sup>ω</sup> with final state set <em>F</em>. <em>A</em> accepts 0<sup>ω</sup>. So, <em>A</em> will visit some state in <em>F</em> after reading some finite prefix of 0<sup>ω</sup>, say after the i<sub>0</sub>th letter. <em>A</em> also accepts the ω-word 0<sup>i<sub>0</sub></sup>10<sup>ω</sup>. Therefore, for some i<sub>1</sub>, after the prefix 0<sup>i<sub>0</sub></sup>10<sup>i<sub>1</sub></sup> the automaton will visit some state in <em>F</em>. Continuing with this construction the ω-word 0<sup>i<sub>0</sub></sup>10<sup>i<sub>1</sub></sup>10<sup>i<sub>2</sub></sup>... is generated which causes A to visit some state in <em>F</em> infinitely often and the word is not in (0+1)*0<sup>ω</sup>. Contradiction.</p>

<p>The class of languages recognizable by deterministic Büchi automata is characterized by the following lemma.</p>
<dl>
<dd><strong>Lemma:</strong> <em>An ω-language is recognizable by a deterministic Büchi automaton iff it is the <a href="Omega_language#Operations" title="wikilink">limit language</a> of some <a href="regular_language" title="wikilink">regular language</a>.</em>
</dd>
<dd><strong>Proof:</strong> Any deterministic Büchi automaton A can be viewed as a deterministic finite automaton A' and vice versa, since both types of automaton are defined as 5-tuple of the same components, only the interpretation of acceptance condition is different. We will show that L(A) is the limit language of L(A'). An ω-word is accepted by A iff it will force A to visit final states infinitely often. Iff, infinitely many finite prefixes of this ω-word will be accepted by A'. Hence, L(A) is a limit language of L(A').
</dd>
</dl>
<h2 id="algorithms">Algorithms</h2>

<p><a href="Model_checking" title="wikilink">Model checking</a> of finite state systems can often be translated into various operations on Büchi automata. In addition to the closure operations presented above, the following are some useful operations for the applications of Büchi automata.</p>
<dl>
<dt>Determinization</dt>
</dl>

<p>Since deterministic Büchi automata are strictly less expressive than non-deterministic automata, there can not be an algorithm for determinization of Büchi automata. But, <a href="McNaughton's_Theorem" title="wikilink">McNaughton's Theorem</a> and <a href="Safra's_construction" title="wikilink">Safra's construction</a> provide algorithms that can translate a Büchi automaton into a deterministic <a href="Muller_automaton" title="wikilink">Muller automaton</a> or deterministic <a href="Rabin_automaton" title="wikilink">Rabin automaton</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<dl>
<dt>Emptiness checking</dt>
</dl>

<p>The language recognized by a Büchi automaton is non-empty if and only if there is a final state that is both reachable from the initial state, and lies on a cycle.</p>

<p>An effective algorithm that can check emptiness of a Büchi automaton:</p>
<ol>
<li>Consider the automaton as a <a href="directed_graph" title="wikilink">directed graph</a> and decompose it into <a href="strongly_connected_component" title="wikilink">strongly connected components</a> (SCCs).</li>
<li>Run a search (e.g., the <a href="depth-first_search" title="wikilink">depth-first search</a>) to find which SCCs are reachable from the initial state.</li>
<li>Check whether there is a non-trivial SCC that is reachable and contains a final state.</li>
</ol>

<p>Each of the steps of this algorithm can be done in time linear in the automaton size, hence the algorithm is clearly optimal.</p>
<dl>
<dt>Minimization</dt>
</dl>

<p>The algorithm for <a href="minimizing_nondeterministic_finite_automaton" title="wikilink">minimizing nondeterministic finite automaton</a> also correctly minimizes a Büchi automaton. The algorithm does not guarantee minimum Büchi automaton. However, the algorithms for <a href="minimizing_deterministic_finite_automaton" title="wikilink">minimizing deterministic finite automaton</a> does not work for deterministic Büchi automaton.</p>
<h2 id="variants">Variants</h2>
<ul>
<li><a href="Co-Büchi_automaton" title="wikilink">Co-Büchi automaton</a></li>
<li><a href="Weak_Büchi_automaton" title="wikilink">Weak Büchi automaton</a></li>
<li><a href="Semi-deterministic_Büchi_automaton" title="wikilink">Semi-deterministic Büchi automaton</a></li>
<li><a href="Generalized_Büchi_automaton" title="wikilink">Generalized Büchi automaton</a></li>
</ul>
<h2 id="transforming-from-other-models-of-description-to-non-deterministic-büchi-automata">Transforming from other models of description to non-deterministic Büchi automata</h2>
<dl>
<dt>From <a href="Generalized_Büchi_automaton" title="wikilink">generalized Büchi automata</a> (GBA)</dt>
</dl>
<dl>
<dd>Multiple sets of states in acceptance condition can be translated into one set of states by an <a href="automata_construction" title="wikilink">automata construction</a>, which is known as "counting construction". Let's say <em>A</em> = (Q,Σ,∆,q<sub>0</sub>,{F<sub>1</sub>,...,F<sub>n</sub>}) is a GBA, where F<sub>1</sub>,...,F<sub>n</sub> are sets of accepting states then the equivalent Büchi automaton is <em>A</em>' = (Q', Σ, ∆',q'<sub>0</sub>,F'), where
</dd>
</dl>
<ul>
<li><ul>
<li>Q' = Q × {1,...,n}</li>
<li>q'<sub>0</sub> = ( q<sub>0</sub>,1 )</li>
<li>∆' = { ( (q,i), a, (q',j) ) | (q,a,q') ∈ ∆ and if q ∈ F<sub>i</sub> then j=((i+1) mod n) else j=i }</li>
<li>F'=F<sub>1</sub>× {1}</li>
</ul></li>
</ul>
<dl>
<dt>From <a href="Linear_temporal_logic" title="wikilink">Linear temporal logic</a> formula</dt>
<dd>A translation from a Linear temporal logic formula to a generalized Büchi automaton is given <a href="Linear_temporal_logic_to_Büchi_automaton" title="wikilink">here</a>. And, a translation from a generalized Büchi automaton to a Büchi automaton is presented above.
</dd>
</dl>
<dl>
<dt>From <a href="Muller_automaton" title="wikilink">Muller automata</a></dt>
<dd>A given Muller automaton can be transformed into an equivalent Büchi automaton with following <a href="automata_construction" title="wikilink">automata construction</a>. Let's suppose <em>A</em> = (Q,Σ,∆,Q<sub>0</sub>,{F<sub>0</sub>,...,F<sub>n</sub>}) is a Muller automaton, where F<sub>0</sub>,...,F<sub>n</sub> are sets of accepting states. An equivalent Büchi automaton is <em>A</em>' = (Q', Σ, ∆',Q<sub>0</sub>,F'), where
</dd>
</dl>
<ul>
<li><ul>
<li>Q' = Q ∪  <big>∪</big><sup>n</sup><sub>i=0</sub> {i} × F<sub>i</sub> × 2<sup>F<sub>i</sub></sup></li>
<li>∆'= ∆ ∪ ∆<sub>1</sub> ∪ ∆<sub>2</sub>, where
<ul>
<li>∆<sub>1</sub> ={ ( q, a, (i,q',∅) ) | (q, a, q') ∈ ∆ and q' ∈ F<sub>i</sub> }</li>
<li>∆<sub>2</sub>={ ( (i,q,R), a, (i,q',R') ) | (q,a,q')∈∆ and q,q' ∈ F<sub>i</sub> and if R=F<sub>i</sub> then R'= ∅ otherwise R'=R∪{q} }</li>
</ul></li>
<li>F'=<big>∪</big><sup>n</sup><sub>i=0</sub> {i} × F<sub>i</sub> × {F<sub>i</sub>}</li>
</ul></li>
</ul>
<dl>
<dd>''A' '' keeps original set of states from <em>A</em> and adds extra states on them. The Büchi automaton ''A' '' simulates the Muller automaton <em>A</em> as follows: At the beginning of the input word, the execution of <em>A</em>' follows the execution of <em>A</em>, since initial states are same and ∆' contains ∆. At some non-deterministically chosen position in the input word, ''A' '' decides of jump into newly added states via a transition in ∆<sub>1</sub>. Then, the transitions in ∆<sub>2</sub> try to visit all the states of <em>F<sub>i</sub></em> and keep growing <em>R</em>. Once <em>R</em> becomes equal to <em>F<sub>i</sub></em> then it is reset to the empty set and ∆<sub>2</sub> try to visit all the states of <em>F<sub>i</sub></em> states again and again. So, if the states <em>R</em>=<em>F<sub>i</sub></em> are visited infinitely often then ''A' '' accepts corresponding input and so does <em>A</em>. This construction closely follows the first part of the proof of <a href="McNaughton's_Theorem" title="wikilink">McNaughton's Theorem</a>.
</dd>
</dl>
<dl>
<dt>From Kripke structures</dt>
<dd>Let the given <a href="Kripke_structure" title="wikilink">Kripke structure</a> be defined by <em>M</em> =  where <em>Q</em> is the set of states, <em>I</em> is the set of initial states, <em>R</em> is a relation between two states also interpreted as an edge, <em>L</em> is the label for the state and <em>AP</em> are the set of atomic propositions that form <em>L</em>.
</dd>
</dl>
<dl>
<dd>The Büchi automaton will have the following characteristics:

<p>

<math display="block" id="Büchi_automaton:0">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mtext>final</mtext>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>Q</mi>
    <mo>∪</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mtext>init</mtext>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <mtext>final</mtext>
    </apply>
    <apply>
     <union></union>
     <ci>Q</ci>
     <set>
      <mtext>init</mtext>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{\text{final}}=Q\cup\{\text{init}\}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Büchi_automaton:1">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Σ</mi>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>A</mi>
     <mi>P</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Σ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma=2^{AP}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Büchi_automaton:2">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mtext>init</mtext>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>I</ci>
    <set>
     <mtext>init</mtext>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I=\{\text{init}\}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Büchi_automaton:3">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <mrow>
    <mi>Q</mi>
    <mo>∪</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mtext>init</mtext>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>F</ci>
    <apply>
     <union></union>
     <ci>Q</ci>
     <set>
      <mtext>init</mtext>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=Q\cup\{\text{init}\}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Büchi_automaton:4">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mo>=</mo>
   <mrow>
    <mi>q</mi>
    <mover accent="true">
     <mi>a</mi>
     <mo>→</mo>
    </mover>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>δ</ci>
    <apply>
     <times></times>
     <ci>q</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>a</ci>
     </apply>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta=q\overrightarrow{a}p
  </annotation>
 </semantics>
</math>

 if (<em>q</em>, <em>p</em>) belongs to <em>R</em> and <em>L</em>(<em>p</em>) = <em>a</em></p>
</dd>
</dl>
<dl>
<dd>and init 

<math display="inline" id="Büchi_automaton:5">
 <semantics>
  <mover accent="true">
   <mi>a</mi>
   <mo>→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overrightarrow{a}
  </annotation>
 </semantics>
</math>

 <em>q</em> if <em>q</em> belongs to <em>I</em> and <em>L</em>(<em>q</em>) = <em>a</em>.
</dd>
</dl>
<dl>
<dd>Note however that there is a difference in the interpretation between Kripke structures and Büchi automata. While the former explicitly names every state variable's polarity for every state, the latter just declares the current set of variables holding or not holding true. It says absolutely nothing about the other variables that could be present in the model.
</dd>
</dl>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Automata_theory" title="wikilink">Category:Automata theory</a> <a href="Category:Models_of_computation" title="wikilink">Category:Models of computation</a> <a href="Category:Model_checking" title="wikilink">Category:Model checking</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
