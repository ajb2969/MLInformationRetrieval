<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1657">Elliptic filter</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Elliptic filter</h1>
<hr/>

<p>An <strong>elliptic filter</strong> (also known as a <strong>Cauer filter</strong>, named after <a href="Wilhelm_Cauer" title="wikilink">Wilhelm Cauer</a>, or as a <strong>Zolotarev filter</strong>, after <a href="Yegor_Zolotarev" title="wikilink">Yegor Zolotarev</a>) is a <a href="filter_(signal_processing)" title="wikilink">signal processing filter</a> with equalized <a href="ripple_(filters)" title="wikilink">ripple</a> (<a class="uri" href="equiripple" title="wikilink">equiripple</a>) behavior in both the <a class="uri" href="passband" title="wikilink">passband</a> and the <a class="uri" href="stopband" title="wikilink">stopband</a>. The amount of ripple in each band is independently adjustable, and no other filter of equal order can have a faster transition in <a class="uri" href="gain" title="wikilink">gain</a> between the <a class="uri" href="passband" title="wikilink">passband</a> and the <a class="uri" href="stopband" title="wikilink">stopband</a>, for the given values of ripple (whether the ripple is equalized or not). Alternatively, one may give up the ability to adjust independently the passband and stopband ripple, and instead design a filter which is maximally insensitive to component variations.</p>

<p>As the ripple in the stopband approaches zero, the filter becomes a type I <a href="Chebyshev_filter" title="wikilink">Chebyshev filter</a>. As the ripple in the passband approaches zero, the filter becomes a type II <a href="Chebyshev_filter" title="wikilink">Chebyshev filter</a> and finally, as both ripple values approach zero, the filter becomes a <a href="Butterworth_filter" title="wikilink">Butterworth filter</a>.</p>

<p>The gain of a <a class="uri" href="lowpass" title="wikilink">lowpass</a> elliptic filter as a function of angular frequency ω is given by:</p>

<p>

<math display="block" id="Elliptic_filter:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>G</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <msqrt>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mrow>
       <msup>
        <mi>ϵ</mi>
        <mn>2</mn>
       </msup>
       <msubsup>
        <mi>R</mi>
        <mi>n</mi>
        <mn>2</mn>
       </msubsup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ξ</mi>
        <mo>,</mo>
        <mrow>
         <mi>ω</mi>
         <mo>/</mo>
         <msub>
          <mi>ω</mi>
          <mn>0</mn>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msqrt>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <ci>n</ci>
     </apply>
     <ci>ω</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ϵ</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>R</ci>
          <ci>n</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <interval closure="open">
         <ci>ξ</ci>
         <apply>
          <divide></divide>
          <ci>ω</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ω</ci>
           <cn type="integer">0</cn>
          </apply>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{n}(\omega)={1\over\sqrt{1+\epsilon^{2}R_{n}^{2}(\xi,\omega/\omega_{0})}}
  </annotation>
 </semantics>
</math>

</p>

<p>where R<sub>n</sub> is the <em>n</em>th-order <a href="Elliptic_rational_functions" title="wikilink">elliptic rational function</a> (sometimes known as a Chebyshev rational function) and</p>

<p>

<math display="block" id="Elliptic_filter:1">
 <semantics>
  <msub>
   <mi>ω</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ω</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{0}
  </annotation>
 </semantics>
</math>

 is the cutoff frequency</p>

<p>

<math display="block" id="Elliptic_filter:2">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 is the ripple factor</p>

<p>

<math display="block" id="Elliptic_filter:3">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

 is the selectivity factor</p>

<p>The value of the ripple factor specifies the passband ripple, while the combination of the ripple factor and the selectivity factor specify the stopband ripple.</p>
<h2 id="properties">Properties</h2>

<p> </p>
<ul>
<li>In the passband, the elliptic rational function varies between zero and unity. The gain of the passband therefore will vary between 1 and 

<math display="inline" id="Elliptic_filter:4">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <msqrt>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <msup>
      <mi>ϵ</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <root></root>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ϵ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/\sqrt{1+\epsilon^{2}}
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li>In the stopband, the elliptic rational function varies between infinity and the discrimination factor 

<math display="inline" id="Elliptic_filter:5">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{n}
  </annotation>
 </semantics>
</math>

 which is defined as:</li>
</ul>

<p>

<math display="block" id="Elliptic_filter:6">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ξ</mi>
     <mo>,</mo>
     <mi>ξ</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>n</ci>
     </apply>
     <interval closure="open">
      <ci>ξ</ci>
      <ci>ξ</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{n}=R_{n}(\xi,\xi)\,
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd>The gain of the stopband therefore will vary between 0 and 

<math display="inline" id="Elliptic_filter:7">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <msqrt>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <msup>
       <mi>ϵ</mi>
       <mn>2</mn>
      </msup>
      <msubsup>
       <mi>L</mi>
       <mi>n</mi>
       <mn>2</mn>
      </msubsup>
     </mrow>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <root></root>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ϵ</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <ci>n</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/\sqrt{1+\epsilon^{2}L_{n}^{2}}
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
<ul>
<li>In the limit of 

<math display="inline" id="Elliptic_filter:8">
 <semantics>
  <mrow>
   <mi>ξ</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ξ</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi\rightarrow\infty
  </annotation>
 </semantics>
</math>


 the elliptic rational function becomes a <a href="Chebyshev_polynomial" title="wikilink">Chebyshev polynomial</a>, and therefore the filter becomes a <a href="Chebyshev_filter" title="wikilink">Chebyshev type I filter</a>, with ripple factor ε</li>
</ul>
<ul>
<li>Since the Butterworth filter is a limiting form of the Chebyshev filter, it follows that in the limit of 

<math display="inline" id="Elliptic_filter:9">
 <semantics>
  <mrow>
   <mi>ξ</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ξ</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi\rightarrow\infty
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Elliptic_filter:10">
 <semantics>
  <mrow>
   <msub>
    <mi>ω</mi>
    <mn>0</mn>
   </msub>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{0}\rightarrow 0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Elliptic_filter:11">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ϵ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon\rightarrow 0
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Elliptic_filter:12">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>ϵ</mi>
    </mpadded>
    <msub>
     <mi>R</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ξ</mi>
     <mo>,</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <msub>
       <mi>ω</mi>
       <mn>0</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ϵ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>n</ci>
     </apply>
     <interval closure="open">
      <ci>ξ</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </interval>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon\,R_{n}(\xi,1/\omega_{0})=1
  </annotation>
 </semantics>
</math>

 the filter becomes a <a href="Butterworth_filter" title="wikilink">Butterworth filter</a></li>
</ul>
<ul>
<li>In the limit of 

<math display="inline" id="Elliptic_filter:13">
 <semantics>
  <mrow>
   <mi>ξ</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ξ</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi\rightarrow\infty
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Elliptic_filter:14">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ϵ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon\rightarrow 0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Elliptic_filter:15">
 <semantics>
  <mrow>
   <msub>
    <mi>ω</mi>
    <mn>0</mn>
   </msub>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{0}\rightarrow 0
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Elliptic_filter:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>ξ</mi>
    <msub>
     <mi>ω</mi>
     <mn>0</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ξ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi\omega_{0}=1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Elliptic_filter:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϵ</mi>
    <msub>
     <mi>L</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ϵ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon L_{n}=\alpha
  </annotation>
 </semantics>
</math>

, the filter becomes a <a href="Chebyshev_filter" title="wikilink">Chebyshev type II filter</a> with gain</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Elliptic_filter:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <msqrt>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mfrac>
       <mn>1</mn>
       <mrow>
        <msup>
         <mi>α</mi>
         <mn>2</mn>
        </msup>
        <msubsup>
         <mi>T</mi>
         <mi>n</mi>
         <mn>2</mn>
        </msubsup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>/</mo>
          <mi>ω</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
     </mrow>
    </msqrt>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>ω</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>α</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>T</ci>
           <cn type="integer">2</cn>
          </apply>
          <ci>n</ci>
         </apply>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <ci>ω</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(\omega)=\frac{1}{\sqrt{1+\frac{1}{\alpha^{2}T^{2}_{n}(1/\omega)}}}
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>

<p><br/>
</p>
<h2 id="poles-and-zeroes">Poles and zeroes</h2>

<p> </p>

<p>The zeroes of the gain of an elliptic filter will coincide with the poles of the elliptic rational function, which are derived in the article on <a href="elliptic_rational_functions" title="wikilink">elliptic rational functions</a>.</p>

<p>The poles of the gain of an elliptic filter may be derived in a manner very similar to the derivation of the poles of the gain of a type I <a href="Chebyshev_filter" title="wikilink">Chebyshev filter</a>. For simplicity, assume that the cutoff frequency is equal to unity. The poles 

<math display="inline" id="Elliptic_filter:19">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>ω</mi>
    <mrow>
     <mi>p</mi>
     <mi>m</mi>
    </mrow>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ω</ci>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\omega_{pm})
  </annotation>
 </semantics>
</math>

 of the gain of the elliptical filter will be the zeroes of the denominator of the gain. Using the complex frequency 

<math display="inline" id="Elliptic_filter:20">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mi>σ</mi>
    <mo>+</mo>
    <mrow>
     <mi>j</mi>
     <mi>ω</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <plus></plus>
     <ci>σ</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>ω</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=\sigma+j\omega
  </annotation>
 </semantics>
</math>

 this means that:</p>

<p>

<math display="block" id="Elliptic_filter:21">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <msup>
      <mi>ϵ</mi>
      <mn>2</mn>
     </msup>
     <msubsup>
      <mi>R</mi>
      <mi>n</mi>
      <mn>2</mn>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>j</mi>
        <mi>s</mi>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mi>ξ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ϵ</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <interval closure="open">
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>s</ci>
        </apply>
       </apply>
       <ci>ξ</ci>
      </interval>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+\epsilon^{2}R_{n}^{2}(-js,\xi)=0\,
  </annotation>
 </semantics>
</math>

</p>

<p>Defining 

<math display="inline" id="Elliptic_filter:22">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>j</mi>
     <mi>s</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>cd</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo>,</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mi>ξ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>cd</ci>
     <interval closure="open">
      <ci>w</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>ξ</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -js=\mathrm{cd}(w,1/\xi)
  </annotation>
 </semantics>
</math>

 where cd() is the <a href="Jacobi_elliptic_functions" title="wikilink">Jacobi elliptic cosine function</a> and using the definition of the elliptic rational functions yields:</p>

<p>

<math display="block" id="Elliptic_filter:23">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <msup>
      <mi>ϵ</mi>
      <mn>2</mn>
     </msup>
     <msup>
      <mi>cd</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <mi>n</mi>
        <mi>w</mi>
        <msub>
         <mi>K</mi>
         <mi>n</mi>
        </msub>
       </mrow>
       <mi>K</mi>
      </mfrac>
      <mo>,</mo>
      <mfrac>
       <mn>1</mn>
       <msub>
        <mi>L</mi>
        <mi>n</mi>
       </msub>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ϵ</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>cd</ci>
       <cn type="integer">2</cn>
      </apply>
      <interval closure="open">
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>w</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>K</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <ci>K</ci>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </interval>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+\epsilon^{2}\mathrm{cd}^{2}\left(\frac{nwK_{n}}{K},\frac{1}{L_{n}}\right)=0\,
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Elliptic_filter:24">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>=</mo>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mi>ξ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>K</ci>
    <apply>
     <times></times>
     <ci>K</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>ξ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K=K(1/\xi)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Elliptic_filter:25">
 <semantics>
  <mrow>
   <msub>
    <mi>K</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <msub>
       <mi>L</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>K</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{n}=K(1/L_{n})
  </annotation>
 </semantics>
</math>

. Solving for <em>w</em></p>

<p>

<math display="block" id="Elliptic_filter:26">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mi>K</mi>
      <mrow>
       <mi>n</mi>
       <msub>
        <mi>K</mi>
        <mi>n</mi>
       </msub>
      </mrow>
     </mfrac>
     <msup>
      <mi>cd</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <mo>±</mo>
        <mi>j</mi>
       </mrow>
       <mi>ϵ</mi>
      </mfrac>
      <mo>,</mo>
      <mfrac>
       <mn>1</mn>
       <msub>
        <mi>L</mi>
        <mi>n</mi>
       </msub>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mfrac>
     <mrow>
      <mi>m</mi>
      <mi>K</mi>
     </mrow>
     <mi>n</mi>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>w</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>K</ci>
       <apply>
        <times></times>
        <ci>n</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>K</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>cd</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <interval closure="open">
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="latexml">plus-or-minus</csymbol>
         <ci>j</ci>
        </apply>
        <ci>ϵ</ci>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </interval>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>K</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w=\frac{K}{nK_{n}}\mathrm{cd}^{-1}\left(\frac{\pm j}{\epsilon},\frac{1}{L_{n}}%
\right)+\frac{mK}{n}
  </annotation>
 </semantics>
</math>

</p>

<p>where the multiple values of the inverse cd() function are made explicit using the integer index <em>m</em>.</p>

<p>The poles of the elliptic gain function are then:</p>

<p>

<math display="block" id="Elliptic_filter:27">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mrow>
     <mi>p</mi>
     <mi>m</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>i</mi>
    </mpadded>
    <mi>cd</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo>,</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mi>ξ</mi>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>cd</ci>
     <interval closure="open">
      <ci>w</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>ξ</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{pm}=i\,\mathrm{cd}(w,1/\xi)\,
  </annotation>
 </semantics>
</math>

</p>

<p>As is the case for the Chebyshev polynomials, this may be expressed in explicitly complex form </p>

<p>

<math display="block" id="Elliptic_filter:28">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mrow>
     <mi>p</mi>
     <mi>m</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>a</mi>
     <mo>+</mo>
     <mrow>
      <mi>j</mi>
      <mi>b</mi>
     </mrow>
    </mrow>
    <mi>c</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <ci>a</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{pm}=\frac{a+jb}{c}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Elliptic_filter:29">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>ζ</mi>
      <mi>n</mi>
     </msub>
     <msqrt>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <msubsup>
        <mi>ζ</mi>
        <mi>n</mi>
        <mn>2</mn>
       </msubsup>
      </mrow>
     </msqrt>
     <msqrt>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <msubsup>
        <mi>x</mi>
        <mi>m</mi>
        <mn>2</mn>
       </msubsup>
      </mrow>
     </msqrt>
     <msqrt>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <msubsup>
         <mi>x</mi>
         <mi>m</mi>
         <mn>2</mn>
        </msubsup>
        <mo>/</mo>
        <msup>
         <mi>ξ</mi>
         <mn>2</mn>
        </msup>
       </mrow>
      </mrow>
     </msqrt>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ζ</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <root></root>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ζ</ci>
          <ci>n</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <root></root>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>m</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <root></root>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>m</ci>
          </apply>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>ξ</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=-\zeta_{n}\sqrt{1-\zeta_{n}^{2}}\sqrt{1-x_{m}^{2}}\sqrt{1-x_{m}^{2}/\xi^{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Elliptic_filter:30">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>m</mi>
    </msub>
    <msqrt>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <msubsup>
        <mi>ζ</mi>
        <mi>n</mi>
        <mn>2</mn>
       </msubsup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mrow>
          <mn>1</mn>
          <mo>/</mo>
          <msup>
           <mi>ξ</mi>
           <mn>2</mn>
          </msup>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>b</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <root></root>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ζ</ci>
          <ci>n</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>ξ</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b=x_{m}\sqrt{1-\zeta_{n}^{2}(1-1/\xi^{2})}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Elliptic_filter:31">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <msubsup>
      <mi>ζ</mi>
      <mi>n</mi>
      <mn>2</mn>
     </msubsup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <msubsup>
       <mi>x</mi>
       <mi>i</mi>
       <mn>2</mn>
      </msubsup>
      <msubsup>
       <mi>ζ</mi>
       <mi>n</mi>
       <mn>2</mn>
      </msubsup>
     </mrow>
     <mo>/</mo>
     <msup>
      <mi>ξ</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ζ</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ζ</ci>
         <ci>n</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ξ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=1-\zeta_{n}^{2}+x_{i}^{2}\zeta_{n}^{2}/\xi^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Elliptic_filter:32">
 <semantics>
  <msub>
   <mi>ζ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ζ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \zeta_{n}
  </annotation>
 </semantics>
</math>

 is a function of 

<math display="inline" id="Elliptic_filter:33">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo rspace="4.2pt">,</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>n</ci>
    <ci>ϵ</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n,\,\epsilon
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Elliptic_filter:34">
 <semantics>
  <mi>ξ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ξ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Elliptic_filter:35">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{m}
  </annotation>
 </semantics>
</math>

 are the zeroes of the elliptic rational function. 

<math display="inline" id="Elliptic_filter:36">
 <semantics>
  <msub>
   <mi>ζ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ζ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \zeta_{n}
  </annotation>
 </semantics>
</math>

 is expressible for all <em>n</em> in terms of Jacobi elliptic functions, or algebraically for some orders, especially orders 1,2, and 3. For orders 1 and 2 we have</p>

<p>

<math display="block" id="Elliptic_filter:37">
 <semantics>
  <mrow>
   <msub>
    <mi>ζ</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <msqrt>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <msup>
       <mi>ϵ</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </msqrt>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ζ</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ϵ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \zeta_{1}=\frac{1}{\sqrt{1+\epsilon^{2}}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Elliptic_filter:38">
 <semantics>
  <mrow>
   <msub>
    <mi>ζ</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mn>2</mn>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mi>t</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <msqrt>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <msup>
         <mi>ϵ</mi>
         <mn>2</mn>
        </msup>
       </mrow>
      </msqrt>
     </mrow>
     <mo>+</mo>
     <msqrt>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mi>t</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
       <mo>+</mo>
       <mrow>
        <msup>
         <mi>ϵ</mi>
         <mn>2</mn>
        </msup>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mn>1</mn>
           <mo>+</mo>
           <mi>t</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mrow>
      </mrow>
     </msqrt>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ζ</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <ci>t</ci>
       </apply>
       <apply>
        <root></root>
        <apply>
         <plus></plus>
         <cn type="integer">1</cn>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>ϵ</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <root></root>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <ci>t</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>ϵ</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <plus></plus>
           <cn type="integer">1</cn>
           <ci>t</ci>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \zeta_{2}=\frac{2}{(1+t)\sqrt{1+\epsilon^{2}}+\sqrt{(1-t)^{2}+\epsilon^{2}(1+t%
)^{2}}}
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Elliptic_filter:39">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <msup>
       <mi>ξ</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <root></root>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ξ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=\sqrt{1-1/\xi^{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>The algebraic expression for 

<math display="inline" id="Elliptic_filter:40">
 <semantics>
  <msub>
   <mi>ζ</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ζ</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \zeta_{3}
  </annotation>
 </semantics>
</math>

 is rather involved (See ).</p>

<p>The nesting property of the <a href="elliptic_rational_functions" title="wikilink">elliptic rational functions</a> can be used to build up higher order expressions for 

<math display="inline" id="Elliptic_filter:41">
 <semantics>
  <msub>
   <mi>ζ</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ζ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \zeta_{n}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Elliptic_filter:42">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ζ</mi>
     <mrow>
      <mi>m</mi>
      <mo>⋅</mo>
      <mi>n</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ξ</mi>
     <mo>,</mo>
     <mi>ϵ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>ζ</mi>
     <mi>m</mi>
    </msub>
    <mrow>
     <mo>(</mo>
     <mi>ξ</mi>
     <mo>,</mo>
     <msqrt>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mrow>
         <msubsup>
          <mi>ζ</mi>
          <mi>n</mi>
          <mn>2</mn>
         </msubsup>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>L</mi>
           <mi>m</mi>
          </msub>
          <mo>,</mo>
          <mi>ϵ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mfrac>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msqrt>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ζ</ci>
      <apply>
       <ci>normal-⋅</ci>
       <ci>m</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <interval closure="open">
      <ci>ξ</ci>
      <ci>ϵ</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ζ</ci>
      <ci>m</ci>
     </apply>
     <interval closure="open">
      <ci>ξ</ci>
      <apply>
       <root></root>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>ζ</ci>
            <ci>n</ci>
           </apply>
           <cn type="integer">2</cn>
          </apply>
          <interval closure="open">
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>L</ci>
            <ci>m</ci>
           </apply>
           <ci>ϵ</ci>
          </interval>
         </apply>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \zeta_{m\cdot n}(\xi,\epsilon)=\zeta_{m}\left(\xi,\sqrt{\frac{1}{\zeta_{n}^{2}%
(L_{m},\epsilon)}-1}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Elliptic_filter:43">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mi>m</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>m</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ξ</mi>
     <mo>,</mo>
     <mi>ξ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>m</ci>
     </apply>
     <interval closure="open">
      <ci>ξ</ci>
      <ci>ξ</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{m}=R_{m}(\xi,\xi)
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="minimum-q-factor-elliptic-filters">Minimum Q-factor elliptic filters</h2>
<figure><b>(Figure)</b>
<figcaption> The normalized Q-factors of the poles of an 8-th order elliptic filter with ξ=1.1 as a function of ripple factor ε. Each curve represents four poles, since complex conjugate pole pairs and positive-negative pole pairs have the same Q-factor. (The blue and cyan curves nearly coincide). The Q-factor of all poles are simultaneously minimized at ε<sub>Qmin</sub>=1/√L<sub>n</sub>=0.02323...</figcaption>
</figure>

<p>See .</p>

<p>Elliptic filters are generally specified by requiring a particular value for the passband ripple, stopband ripple and the sharpness of the cutoff. This will generally specify a minimum value of the filter order which must be used. Another design consideration is the sensitivity of the gain function to the values of the electronic components used to build the filter. This sensitivity is inversely proportional to the quality factor (<a class="uri" href="Q-factor" title="wikilink">Q-factor</a>) of the poles of the transfer function of the filter. The Q-factor of a pole is defined as:</p>

<p>

<math display="block" id="Elliptic_filter:44">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mo stretchy="false">|</mo>
      <msub>
       <mi>s</mi>
       <mrow>
        <mi>p</mi>
        <mi>m</mi>
       </mrow>
      </msub>
      <mo stretchy="false">|</mo>
     </mrow>
     <mrow>
      <mn>2</mn>
      <mi mathvariant="normal">R</mi>
      <mi mathvariant="normal">e</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>s</mi>
        <mrow>
         <mi>p</mi>
         <mi>m</mi>
        </mrow>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mrow>
       <mi>cos</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>arg</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>s</mi>
           <mrow>
            <mi>p</mi>
            <mi>m</mi>
           </mrow>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>Q</ci>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <abs></abs>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <apply>
          <times></times>
          <ci>p</ci>
          <ci>m</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>normal-R</ci>
        <ci>normal-e</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <apply>
          <times></times>
          <ci>p</ci>
          <ci>m</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <cos></cos>
         <apply>
          <arg></arg>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>s</ci>
           <apply>
            <times></times>
            <ci>p</ci>
            <ci>m</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=-\frac{|s_{pm}|}{2\mathrm{Re}(s_{pm})}=-\frac{1}{2\cos(\arg(s_{pm}))}
  </annotation>
 </semantics>
</math>

</p>

<p>and is a measure of the influence of the pole on the gain function. For an elliptic filter, it happens that, for a given order, there exists a relationship between the ripple factor and selectivity factor which simultaneously minimizes the Q-factor of all poles in the transfer function:</p>

<p>

<math display="block" id="Elliptic_filter:45">
 <semantics>
  <mrow>
   <msub>
    <mi>ϵ</mi>
    <mrow>
     <mi>Q</mi>
     <mi>m</mi>
     <mi>i</mi>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <msqrt>
     <mrow>
      <msub>
       <mi>L</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ξ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msqrt>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϵ</ci>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>m</ci>
      <ci>i</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>n</ci>
       </apply>
       <ci>ξ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{Qmin}=\frac{1}{\sqrt{L_{n}(\xi)}}
  </annotation>
 </semantics>
</math>

</p>

<p>This results in a filter which is maximally insensitive to component variations, but the ability to independently specify the passband and stopband ripples will be lost. For such filters, as the order increases, the ripple in both bands will decrease and the rate of cutoff will increase. If one decides to use a minimum-Q elliptic filter in order to achieve a particular minimum ripple in the filter bands along with a particular rate of cutoff, the order needed will generally be greater than the order one would otherwise need without the minimum-Q restriction. An image of the absolute value of the gain will look very much like the image in the previous section, except that the poles are arranged in a circle rather than an ellipse. They will not be evenly spaced and there will be zeroes on the ω axis, unlike the <a href="Butterworth_filter" title="wikilink">Butterworth filter</a>, whose poles are also arranged in a circle.</p>
<h2 id="comparison-with-other-linear-filters">Comparison with other linear filters</h2>

<p>Here is an image showing the elliptic filter next to other common kind of filters obtained with the same number of coefficients:</p>
<figure><b>(Figure)</b>
<figcaption>Electronic linear filters.svg</figcaption>
</figure>

<p>As is clear from the image, elliptic filters are sharper than all the others, but they show ripples on the whole bandwidth.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Linear_filters" title="wikilink">Category:Linear filters</a> <a href="Category:Network_synthesis_filters" title="wikilink">Category:Network synthesis filters</a> <a href="Category:Electronic_design" title="wikilink">Category:Electronic design</a></p>
</body>
</html>
