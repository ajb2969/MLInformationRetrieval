<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1712">Medcouple</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Medcouple</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>A histogram of 5000 random values sampled from a skew <a href="gamma_distribution" title="wikilink">gamma distribution</a> above, and the corresponding histogram of the medcouple kernel values below. The actual medcouple is the median of the bottom distribution, marked at 0.188994 with a yellow line.</figcaption>
</figure>

<p>The <strong>medcouple</strong> is a <a href="robust_statistic" title="wikilink">robust statistic</a> that measures the <a href="skewness" title="wikilink">skewness of a univariate distribution</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Its robustness makes it suitable for identifying <a class="uri" href="outliers" title="wikilink">outliers</a> in <a href="boxplot#Variations" title="wikilink">adjusted boxplots</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Ordinary <a class="uri" href="boxplots" title="wikilink">boxplots</a> do not fare well with skew distributions, since they label the longer unsymmetrical tails as outliers. Using the medcouple, the whiskers of a boxplot can be adjusted for skew distributions and thus have a more accurate identification of outliers for non-symmetrical distributions.</p>

<p>As a kind of <a href="order_statistic" title="wikilink">order statistic</a>, the medcouple belongs to the class of incomplete generalised <a href="L-statistic" title="wikilink">L-statistics</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Like the ordinary <a class="uri" href="median" title="wikilink">median</a> or <a class="uri" href="mean" title="wikilink">mean</a>, the medcouple is a <a href="nonparametric_statistics" title="wikilink">nonparametric statistic</a>, thus it can be computed for any distribution.</p>
<h2 id="definition">Definition</h2>

<p>In order to harmonise with <a href="zero-based_indexing" title="wikilink">zero-based indexing</a> in many programming languages, we will index from zero in all that follows.</p>

<p>Let 

<math display="inline" id="Medcouple:0">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>:=</mo>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>≥</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>≥</mo>
   <mi mathvariant="normal">…</mi>
   <mo>≥</mo>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <ci>X</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <ci>normal-…</ci>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X:=x_{0}\geq x_{1}\geq\ldots\geq x_{n-1}
  </annotation>
 </semantics>
</math>

 be an ordered sample of size 

<math display="inline" id="Medcouple:1">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, and let 

<math display="inline" id="Medcouple:2">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{m}
  </annotation>
 </semantics>
</math>

 be the <a class="uri" href="median" title="wikilink">median</a> of 

<math display="inline" id="Medcouple:3">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

. Define the sets</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Medcouple:4">
 <semantics>
  <mrow>
   <msup>
    <mi>X</mi>
    <mo>+</mo>
   </msup>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mpadded width="+3.3pt">
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
    </mpadded>
    <mo rspace="5.8pt" stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo>≥</mo>
     <msub>
      <mi>x</mi>
      <mi>m</mi>
     </msub>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <plus></plus>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <geq></geq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{+}:=\{x_{i}~{}|~{}x_{i}\geq x_{m}\}
  </annotation>
 </semantics>
</math>

,
</dd>
<dd>

<math display="inline" id="Medcouple:5">
 <semantics>
  <mrow>
   <msup>
    <mi>X</mi>
    <mo>-</mo>
   </msup>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mpadded width="+3.3pt">
     <msub>
      <mi>x</mi>
      <mi>j</mi>
     </msub>
    </mpadded>
    <mo rspace="5.8pt" stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>j</mi>
     </msub>
     <mo>≤</mo>
     <msub>
      <mi>x</mi>
      <mi>m</mi>
     </msub>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <minus></minus>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <leq></leq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{-}:=\{x_{j}~{}|~{}x_{j}\leq x_{m}\}
  </annotation>
 </semantics>
</math>

,
</dd>
</dl>
</dd>
</dl>

<p>of sizes 

<math display="inline" id="Medcouple:6">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>X</mi>
     <mo>+</mo>
    </msup>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>p</ci>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <plus></plus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p:=|X^{+}|
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Medcouple:7">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>:=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>X</mi>
     <mo>-</mo>
    </msup>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>q</ci>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <minus></minus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q:=|X^{-}|
  </annotation>
 </semantics>
</math>

 respectively. For 

<math display="inline" id="Medcouple:8">
 <semantics>
  <mrow>
   <msubsup>
    <mi>x</mi>
    <mi>i</mi>
    <mo>+</mo>
   </msubsup>
   <mo>∈</mo>
   <msup>
    <mi>X</mi>
    <mo>+</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <plus></plus>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <plus></plus>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}^{+}\in X^{+}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Medcouple:9">
 <semantics>
  <mrow>
   <msubsup>
    <mi>x</mi>
    <mi>j</mi>
    <mo>-</mo>
   </msubsup>
   <mo>∈</mo>
   <msup>
    <mi>X</mi>
    <mo>-</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
     <minus></minus>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <minus></minus>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{j}^{-}\in X^{-}
  </annotation>
 </semantics>
</math>

, we define the <em>kernel function</em></p>

<p>

<math display="block" id="Medcouple:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>x</mi>
      <mi>i</mi>
      <mo>+</mo>
     </msubsup>
     <mo>,</mo>
     <msubsup>
      <mi>x</mi>
      <mi>j</mi>
      <mo>-</mo>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mfrac>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msubsup>
            <mi>x</mi>
            <mi>i</mi>
            <mo>+</mo>
           </msubsup>
           <mo>-</mo>
           <msub>
            <mi>x</mi>
            <mi>m</mi>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mi>x</mi>
            <mi>m</mi>
           </msub>
           <mo>-</mo>
           <msubsup>
            <mi>x</mi>
            <mi>j</mi>
            <mo>-</mo>
           </msubsup>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <msubsup>
          <mi>x</mi>
          <mi>i</mi>
          <mo>+</mo>
         </msubsup>
         <mo>-</mo>
         <msubsup>
          <mi>x</mi>
          <mi>j</mi>
          <mo>-</mo>
         </msubsup>
        </mrow>
       </mfrac>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <msubsup>
           <mi>x</mi>
           <mi>i</mi>
           <mo>+</mo>
          </msubsup>
         </mrow>
         <mo>></mo>
         <msubsup>
          <mi>x</mi>
          <mi>j</mi>
          <mo>-</mo>
         </msubsup>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mo>signum</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>p</mi>
          <mo>-</mo>
          <mn>1</mn>
          <mo>-</mo>
          <mi>i</mi>
          <mo>-</mo>
          <mi>j</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <msubsup>
           <mi>x</mi>
           <mi>i</mi>
           <mo>+</mo>
          </msubsup>
         </mrow>
         <mo>=</mo>
         <msub>
          <mi>x</mi>
          <mi>m</mi>
         </msub>
         <mo>=</mo>
         <msubsup>
          <mi>x</mi>
          <mi>j</mi>
          <mo>-</mo>
         </msubsup>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>h</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <plus></plus>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
       <minus></minus>
      </apply>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
         <plus></plus>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>m</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>m</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>j</ci>
         </apply>
         <minus></minus>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <plus></plus>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>j</ci>
        </apply>
        <minus></minus>
       </apply>
      </apply>
     </apply>
     <apply>
      <gt></gt>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <plus></plus>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
       <minus></minus>
      </apply>
     </apply>
     <apply>
      <ci>signum</ci>
      <apply>
       <minus></minus>
       <ci>p</ci>
       <cn type="integer">1</cn>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <and></and>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <mtext>if</mtext>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
         <plus></plus>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>m</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>j</ci>
        </apply>
        <minus></minus>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x_{i}^{+},x_{j}^{-}):=\begin{cases}\displaystyle\frac{(x_{i}^{+}-x_{m})-(x_{%
m}-x_{j}^{-})}{x_{i}^{+}-x_{j}^{-}}&\text{ if }x_{i}^{+}>x_{j}^{-},\\
\operatorname{signum}(p-1-i-j)&\text{ if }x_{i}^{+}=x_{m}=x_{j}^{-},\end{cases}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Medcouple:11">
 <semantics>
  <mo>signum</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>signum</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{signum}
  </annotation>
 </semantics>
</math>

 is the <a href="sign_function" title="wikilink">sign function</a>.</p>

<p>The <em>medcouple</em> is then the median of the set<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Medcouple:12">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>x</mi>
      <mi>i</mi>
      <mo>+</mo>
     </msubsup>
     <mo>,</mo>
     <msubsup>
      <mi>x</mi>
      <mi>j</mi>
      <mo>-</mo>
     </msubsup>
     <mo rspace="5.8pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="5.8pt" stretchy="false">|</mo>
   <mrow>
    <msubsup>
     <mi>x</mi>
     <mi>i</mi>
     <mo>+</mo>
    </msubsup>
    <mo>∈</mo>
    <mrow>
     <msup>
      <mi>X</mi>
      <mo>+</mo>
     </msup>
     <mtext>and</mtext>
     <msubsup>
      <mi>x</mi>
      <mi>j</mi>
      <mo>-</mo>
     </msubsup>
    </mrow>
    <mo>∈</mo>
    <msup>
     <mi>X</mi>
     <mo>-</mo>
    </msup>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <times></times>
     <ci>h</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <plus></plus>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
       <minus></minus>
      </apply>
     </interval>
    </apply>
    <apply>
     <and></and>
     <apply>
      <in></in>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <plus></plus>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>X</ci>
        <plus></plus>
       </apply>
       <mtext>and</mtext>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>j</ci>
        </apply>
        <minus></minus>
       </apply>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>X</ci>
       <minus></minus>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{h(x_{i}^{+},x_{j}^{-})~{}|~{}x_{i}^{+}\in X^{+}\text{ and }x_{j}^{-}\in X^{-}\}
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
</dd>
</dl>

<p>In other words, we split the distribution into all values greater or equal to the median and all values less than or equal to the median. We define a kernel function whose first variable is over the 

<math display="inline" id="Medcouple:13">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 greater values and whose second variable is over the 

<math display="inline" id="Medcouple:14">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 lessers values. For the special case of values tied to the median, we define the kernel by the <a href="signum_function" title="wikilink">signum function</a>. The medcouple is then the median over all 

<math display="inline" id="Medcouple:15">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   pq
  </annotation>
 </semantics>
</math>

 values of 

<math display="inline" id="Medcouple:16">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>x</mi>
     <mi>i</mi>
     <mo>+</mo>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mi>x</mi>
     <mi>j</mi>
     <mo>-</mo>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <plus></plus>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
      <minus></minus>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x_{i}^{+},x_{j}^{-})
  </annotation>
 </semantics>
</math>

.</p>

<p>Since the medcouple is not a median applied to all 

<math display="inline" id="Medcouple:17">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>j</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>j</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{i},x_{j})
  </annotation>
 </semantics>
</math>

 couples, but only to those for which 

<math display="inline" id="Medcouple:18">
 <semantics>
  <mrow>
   <msubsup>
    <mi>x</mi>
    <mi>i</mi>
    <mo>+</mo>
   </msubsup>
   <mo>≥</mo>
   <msub>
    <mi>x</mi>
    <mi>m</mi>
   </msub>
   <mo>≥</mo>
   <msubsup>
    <mi>x</mi>
    <mi>j</mi>
    <mo>-</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <plus></plus>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
      <minus></minus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}^{+}\geq x_{m}\geq x_{j}^{-}
  </annotation>
 </semantics>
</math>

, it belongs to the class of incomplete generalised <a href="L-statistic" title="wikilink">L-statistics</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="properties-of-the-medcouple">Properties of the medcouple</h2>

<p>The medcouple has a number of desirable properties. A few of them are directly inherited from the kernel function.</p>
<h3 id="the-medcouple-kernel">The medcouple kernel</h3>

<p>We make the following observations about the kernel function 

<math display="inline" id="Medcouple:19">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>x</mi>
     <mi>i</mi>
     <mo>+</mo>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mi>x</mi>
     <mi>j</mi>
     <mo>-</mo>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <plus></plus>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
      <minus></minus>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x_{i}^{+},x_{j}^{-})
  </annotation>
 </semantics>
</math>

:</p>
<ol>
<li><strong>The kernel function is location-invariant.</strong><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> If we add or subtract any value to each element of the sample 

<math display="inline" id="Medcouple:20">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

, the corresponding values of the kernel function do not change.</li>
<li><strong>The kernel function is scale-invariant.</strong><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Equally scaling all elements of the sample 

<math display="inline" id="Medcouple:21">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 does not alter the values of the kernel function.</li>
</ol>

<p>These properties are in turn inherited by the medcouple. Thus, the medcouple is independent of the <a class="uri" href="mean" title="wikilink">mean</a> and <a href="standard_deviation" title="wikilink">standard deviation</a> of a distribution, a desirable property for measuring <a class="uri" href="skewness" title="wikilink">skewness</a>. For ease of computation, these properties enable us to define the two sets</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Medcouple:22">
 <semantics>
  <mrow>
   <msup>
    <mi>Z</mi>
    <mo>+</mo>
   </msup>
   <mo>:=</mo>
   <mrow>
    <mo>{</mo>
    <mpadded width="+3.3pt">
     <mfrac>
      <mrow>
       <msubsup>
        <mi>x</mi>
        <mi>i</mi>
        <mo>+</mo>
       </msubsup>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mi>m</mi>
       </msub>
      </mrow>
      <mi>r</mi>
     </mfrac>
    </mpadded>
    <mo rspace="5.8pt">|</mo>
    <mrow>
     <msubsup>
      <mi>x</mi>
      <mi>i</mi>
      <mo>+</mo>
     </msubsup>
     <mo>∈</mo>
     <msup>
      <mi>X</mi>
      <mo>+</mo>
     </msup>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Z</ci>
     <plus></plus>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <plus></plus>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>m</ci>
       </apply>
      </apply>
      <ci>r</ci>
     </apply>
     <apply>
      <in></in>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <plus></plus>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>X</ci>
       <plus></plus>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z^{+}:=\left.\left\{\frac{x_{i}^{+}-x_{m}}{r}~{}\right|~{}x_{i}^{+}\in X^{+}\right\}
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Medcouple:23">
 <semantics>
  <mrow>
   <msup>
    <mi>Z</mi>
    <mo>-</mo>
   </msup>
   <mo>:=</mo>
   <mrow>
    <mo>{</mo>
    <mpadded width="+3.3pt">
     <mfrac>
      <mrow>
       <msubsup>
        <mi>x</mi>
        <mi>j</mi>
        <mo>-</mo>
       </msubsup>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mi>m</mi>
       </msub>
      </mrow>
      <mi>r</mi>
     </mfrac>
    </mpadded>
    <mo rspace="5.8pt">|</mo>
    <mrow>
     <msubsup>
      <mi>x</mi>
      <mi>j</mi>
      <mo>-</mo>
     </msubsup>
     <mo>∈</mo>
     <msup>
      <mi>X</mi>
      <mo>-</mo>
     </msup>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Z</ci>
     <minus></minus>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>j</ci>
        </apply>
        <minus></minus>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>m</ci>
       </apply>
      </apply>
      <ci>r</ci>
     </apply>
     <apply>
      <in></in>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
       <minus></minus>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>X</ci>
       <minus></minus>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z^{-}:=\left.\left\{\frac{x_{j}^{-}-x_{m}}{r}~{}\right|~{}x_{j}^{-}\in X^{-}\right\}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where 

<math display="inline" id="Medcouple:24">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mrow>
     <msub>
      <mi>max</mi>
      <mrow>
       <mn>0</mn>
       <mo>≤</mo>
       <mi>i</mi>
       <mo>≤</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">|</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <apply>
        <and></and>
        <apply>
         <leq></leq>
         <cn type="integer">0</cn>
         <ci>i</ci>
        </apply>
        <apply>
         <leq></leq>
         <share href="#.cmml">
         </share>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=2\max_{0\leq i\leq n-1}|x_{i}|
  </annotation>
 </semantics>
</math>

. This makes the set 

<math display="inline" id="Medcouple:25">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>:=</mo>
   <mrow>
    <msup>
     <mi>Z</mi>
     <mo>+</mo>
    </msup>
    <mo>∪</mo>
    <msup>
     <mi>Z</mi>
     <mo>-</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>Z</ci>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Z</ci>
      <plus></plus>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Z</ci>
      <minus></minus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z:=Z^{+}\cup Z^{-}
  </annotation>
 </semantics>
</math>

 have <a href="range_(statistics)" title="wikilink">range</a> of at most 1, median 0, and keep the same medcouple as 

<math display="inline" id="Medcouple:26">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

.</p>

<p>For 

<math display="inline" id="Medcouple:27">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

, the medcouple kernel reduces to</p>
<dl>
<dd><dl>
<dd><math>h(z_i^+, z_j^-) := \begin{cases}
</math></dd>
</dl>
</dd>
</dl>

<p>\displaystyle\frac{z_i^+ + z_j^-}{z_i^+ - z_j^-} &amp; \text { if } z_i^+ &gt; z_j^- \\ \operatorname{signum} (p - 1 - i - j) &amp; \text{ if } z_i^+ = 0 = z_j^- \end{cases} </p>

<p>Using the recentred and rescaled set 

<math display="inline" id="Medcouple:28">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 we can observe the following.</p>
<ol>
<li></li><li value="3">

<p><strong>The kernel function is between -1 and 1,</strong><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> that is, 

<math display="inline" id="Medcouple:29">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msubsup>
       <mi>z</mi>
       <mi>i</mi>
       <mo>+</mo>
      </msubsup>
      <mo>,</mo>
      <msubsup>
       <mi>z</mi>
       <mi>j</mi>
       <mo>-</mo>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <ci>h</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <ci>i</ci>
        </apply>
        <plus></plus>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <ci>j</ci>
        </apply>
        <minus></minus>
       </apply>
      </interval>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |h(z_{i}^{+},z_{j}^{-})|\leq 1
  </annotation>
 </semantics>
</math>

. This follows from the <a href="reverse_triangle_inequality" title="wikilink">reverse triangle inequality</a> 

<math display="inline" id="Medcouple:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>a</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>b</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>a</mi>
     <mo>-</mo>
     <mi>b</mi>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <abs></abs>
      <ci>a</ci>
     </apply>
     <apply>
      <abs></abs>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |a|-|b|\leq|a-b|
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Medcouple:31">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <msubsup>
    <mi>z</mi>
    <mi>i</mi>
    <mo>+</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <ci>i</ci>
     </apply>
     <plus></plus>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=z_{i}^{+}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Medcouple:32">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>=</mo>
   <msubsup>
    <mi>z</mi>
    <mi>j</mi>
    <mo>-</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>b</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <ci>j</ci>
     </apply>
     <minus></minus>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b=z_{j}^{-}
  </annotation>
 </semantics>
</math>

 and the fact that 

<math display="inline" id="Medcouple:33">
 <semantics>
  <mrow>
   <msubsup>
    <mi>z</mi>
    <mi>i</mi>
    <mo>+</mo>
   </msubsup>
   <mo>≥</mo>
   <mn>0</mn>
   <mo>≥</mo>
   <msubsup>
    <mi>z</mi>
    <mi>j</mi>
    <mo>-</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>i</ci>
      </apply>
      <plus></plus>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>j</ci>
      </apply>
      <minus></minus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{i}^{+}\geq 0\geq z_{j}^{-}
  </annotation>
 </semantics>
</math>

.</p>
</li>
<li><strong>The medcouple kernel 

<math display="inline" id="Medcouple:34">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>z</mi>
     <mi>i</mi>
     <mo>+</mo>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mi>z</mi>
     <mi>j</mi>
     <mo>-</mo>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>i</ci>
      </apply>
      <plus></plus>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>j</ci>
      </apply>
      <minus></minus>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(z_{i}^{+},z_{j}^{-})
  </annotation>
 </semantics>
</math>

 is non-decreasing in each variable.</strong><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> This can be verified by the partial derivatives 

<math display="inline" id="Medcouple:35">
 <semantics>
  <mfrac>
   <mrow>
    <mo>∂</mo>
    <mi>h</mi>
   </mrow>
   <mrow>
    <mo>∂</mo>
    <msubsup>
     <mi>z</mi>
     <mi>i</mi>
     <mo>+</mo>
    </msubsup>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <partialdiff></partialdiff>
     <ci>h</ci>
    </apply>
    <apply>
     <partialdiff></partialdiff>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>i</ci>
      </apply>
      <plus></plus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial h}{\partial z_{i}^{+}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Medcouple:36">
 <semantics>
  <mfrac>
   <mrow>
    <mo>∂</mo>
    <mi>h</mi>
   </mrow>
   <mrow>
    <mo>∂</mo>
    <msubsup>
     <mi>z</mi>
     <mi>j</mi>
     <mo>-</mo>
    </msubsup>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <partialdiff></partialdiff>
     <ci>h</ci>
    </apply>
    <apply>
     <partialdiff></partialdiff>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>j</ci>
      </apply>
      <minus></minus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial h}{\partial z_{j}^{-}}
  </annotation>
 </semantics>
</math>

, both nonnegative, since 

<math display="inline" id="Medcouple:37">
 <semantics>
  <mrow>
   <msubsup>
    <mi>z</mi>
    <mi>i</mi>
    <mo>+</mo>
   </msubsup>
   <mo>≥</mo>
   <mn>0</mn>
   <mo>≥</mo>
   <msubsup>
    <mi>z</mi>
    <mi>j</mi>
    <mo>-</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>i</ci>
      </apply>
      <plus></plus>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>j</ci>
      </apply>
      <minus></minus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{i}^{+}\geq 0\geq z_{j}^{-}
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>With properties 1, 2, and 4, we can thus define the following <a href="Matrix_(mathematics)" title="wikilink">matrix</a>,</p>
<dl>
<dd><dl>
<dd><math> H :=(h_{ij}) = (h(z_i^+, z_j^-)) =
</math></dd>
</dl>
</dd>
</dl>

<p>\begin{pmatrix} h(z_0^+, z_0^-) &amp; \cdots &amp; h(z_0^+, z_{q - 1}^-) \\ \vdots &amp; \ddots &amp; \vdots \\ h(z_{p -1}^+, z_0^-) &amp; \cdots &amp; h(z_{p -1}^+, z_{q - 1}^-) \end{pmatrix}.  If we sort the sets 

<math display="inline" id="Medcouple:38">
 <semantics>
  <msup>
   <mi>Z</mi>
   <mo>+</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>Z</ci>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z^{+}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Medcouple:39">
 <semantics>
  <msup>
   <mi>Z</mi>
   <mo>-</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>Z</ci>
    <minus></minus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z^{-}
  </annotation>
 </semantics>
</math>

 in decreasing order, then the matrix 

<math display="inline" id="Medcouple:40">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 has sorted rows and sorted columns,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<dl>
<dd><dl>
<dd><math> H =
</math></dd>
</dl>
</dd>
</dl>

<p>\begin{pmatrix} h(z_0^+, z_0^-) &amp; \geq &amp; \cdots &amp; \geq &amp; h(z_0^+, z_{q - 1}^-) \\ \geq &amp; &amp; &amp; &amp; \geq \\ \vdots &amp; &amp; \ddots &amp; &amp; \vdots \\ \geq &amp; &amp; &amp; &amp; \geq \\ h(z_{p -1}^+, z_0^-) &amp; \geq &amp; \cdots &amp; \geq &amp; h(z_{p -1}^+, z_{q - 1}^-) \end{pmatrix}.  The medcouple is then the median of this matrix with sorted rows and sorted columns. The fact that the rows and columns are sorted allows the implementation of a <a href="Medcouple#Fast_algorithm" title="wikilink">fast algorithm</a> for computing the medcouple.</p>
<h3 id="robustness">Robustness</h3>

<p>The <a href="breakdown_point" title="wikilink">breakdown point</a> is the number of values that a statistic can resist before it becomes meaningless, i.e. the number of arbitrarily large outliers that the data set 

<math display="inline" id="Medcouple:41">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 may have before the value of the statistic is affected. For the medcouple, the breakdown point is 25%, since it is a median taken over the couples 

<math display="inline" id="Medcouple:42">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>j</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>j</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{i},x_{j})
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Medcouple:43">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>≥</mo>
   <msub>
    <mi>x</mi>
    <mi>m</mi>
   </msub>
   <mo>≥</mo>
   <msub>
    <mi>x</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}\geq x_{m}\geq x_{j}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h3 id="values">Values</h3>

<p>Like all measures of <a class="uri" href="skewness" title="wikilink">skewness</a>, the medcouple is positive for distributions that are skewed to the right, negative for distributions skewed to the left, and zero for symmetrical distributions. In addition, the values of the medcouple are bounded by 1 in absolute value.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="algorithms-for-computing-the-medcouple">Algorithms for computing the medcouple</h2>

<p>Before presenting medcouple algorithms, we recall the there exist 

<math display="inline" id="Medcouple:44">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 <a href="selection_algorithm" title="wikilink">algorithms for the finding the median</a>. Since the medcouple is a median, ordinary algorithms for median-finding are important.</p>
<h3 id="naïve-algorithm">Naïve algorithm</h3>

<p>The naïve <a class="uri" href="algorithm" title="wikilink">algorithm</a> for computing the medcouple is slow.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> It proceeds in two steps. First, it constructs the medcouple matrix 

<math display="inline" id="Medcouple:45">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 which contains all of the possible values of the medcouple kernel. In the second step, it finds the median of this matrix. Since there are 

<math display="inline" id="Medcouple:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mi>q</mi>
   </mrow>
   <mo>≈</mo>
   <mfrac>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mn>4</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>q</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   pq\approx\frac{n^{2}}{4}
  </annotation>
 </semantics>
</math>

 entries in the matrix in the case when all elements of the data set 

<math display="inline" id="Medcouple:47">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 are unique, the <a href="Analysis_of_algorithms" title="wikilink">algorithmic complexity</a> of the naïve algorithm is 

<math display="inline" id="Medcouple:48">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2})
  </annotation>
 </semantics>
</math>

.</p>

<p>More concretely, the naïve algorithm proceeds as follows. Recall that we are using <a href="zero-based_indexing" title="wikilink">zero-based indexing</a>.</p>

<p><code>
    '''function''' naïve_medcouple('''vector''' X):
        ''// X is a vector of size n.''
        
        ''//Sorting in decreasing order can be done in-place in O(n log n) time''
        [[Sorting algorithm|sort_decreasing]](X)
        
        xm := median(X)
        xscale := 2*max(X)
        
        ''// define the upper and lower centred and rescaled vectors''
        ''// they inherit X's own decreasing sorting
        Zplus  := [(x - xm)/xscale | x '''in''' X '''such that''' x &gt;= xm]
        Zminus := [(x - xm)/xscale | x '''in''' X '''such that''' x &lt;= xm]
        
        p := size(Zplus)
        q := size(Zminus)
        
        ''// define the kernel function [[Closure (computer programming)|closing]] over Zplus and Zminus''
        '''function''' h(i,j):
            a := Zplus[i]
            b := Zminus[j]
            
            '''if''' a == b:
                '''return''' [[sign function|signum]](p - 1 - i - j)
            '''else''':
                '''return''' (a + b)/(a - b)
            '''endif'''
        '''endfunction'''
        
        ''// O(n^2) operations necessary to form this vector''
        H := [h(i,j) | i '''in''' [0, 1, ..., p - 1] '''and''' j '''in''' [0, 1, ..., q - 1]]
        
        '''return''' median(H)
    '''endfunction'''
</code></p>

<p>The final call to <code>median</code> on a vector of size 

<math display="inline" id="Medcouple:49">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2})
  </annotation>
 </semantics>
</math>

 can be done itself in 

<math display="inline" id="Medcouple:50">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2})
  </annotation>
 </semantics>
</math>

 operations, hence the entire naïve medcouple algorithm is of the same complexity.</p>
<h3 id="fast-algorithm">Fast algorithm</h3>

<p>The fast algorithm outperforms the naïve algorithm by exploiting the sorted nature of the medcouple matrix 

<math display="inline" id="Medcouple:51">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

. Instead of computing all entries of the matrix, the fast algorithm uses the K<sup>th</sup> pair algorithm of Johnson &amp; Mizoguchi.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>The first stage of the fast algorithm proceeds as the naïve algorithm. We first compute the necessary ingredients for the kernel matrix, 

<math display="inline" id="Medcouple:52">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>h</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=(h_{ij})
  </annotation>
 </semantics>
</math>

, with sorted rows and sorted columns in decreasing order. Rather than computing all values of 

<math display="inline" id="Medcouple:53">
 <semantics>
  <msub>
   <mi>h</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{ij}
  </annotation>
 </semantics>
</math>

, we instead exploit the monotonicity in rows and columns, via the following observations.</p>
<h4 id="comparing-a-value-against-the-kernel-matrix">Comparing a value against the kernel matrix</h4>

<p>First, we note that we can compare any 

<math display="inline" id="Medcouple:54">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 with all values 

<math display="inline" id="Medcouple:55">
 <semantics>
  <msub>
   <mi>h</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{ij}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Medcouple:56">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Medcouple:57">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 time.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> For example, for determining all 

<math display="inline" id="Medcouple:58">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Medcouple:59">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Medcouple:60">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>></mo>
   <mi>u</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{ij}>u
  </annotation>
 </semantics>
</math>

, we have the following function:</p>

<p><code>    </code><strong><code>function</code></strong><code> greater_h(</code><strong><code>kernel</code></strong><code> h, </code><strong><code>int</code></strong><code> p, </code><strong><code>int</code></strong><code> q, </code><strong><code>real</code></strong><code> u):</code><br/>
<code>        </code><em><code>//</code> <code>h</code> <code>is</code> <code>the</code> <code>kernel</code> <code>function,</code> <code>h(i,j)</code> <code>gives</code> <code>the</code> <code>ith,</code> <code>jth</code> <code>entry</code> <code>of</code> <code>H</code></em><br/>
<code>        </code><em><code>//</code> <code>p</code> <code>and</code> <code>q</code> <code>are</code> <code>the</code> <code>number</code> <code>of</code> <code>rows</code> <code>and</code> <code>columns</code> <code>of</code> <code>the</code> <code>kernel</code> <code>matrix</code> <code>H</code></em><br/>
<code>        </code><br/>
<code>        </code><em><code>//</code> <code>vector</code> <code>of</code> <code>size</code> <code>p</code></em><br/>
<code>        P := </code><strong><code>vector</code></strong><code>(p)</code><br/>
<code>        </code><br/>
<code>        </code><em><code>//</code> <code>indexing</code> <code>from</code> <code>zero</code></em><br/>
<code>        j := 0</code><br/>
<code>        </code><br/>
<code>        </code><em><code>//</code> <code>starting</code> <code>from</code> <code>the</code> <code>bottom,</code> <code>compute</code> <code>the</code> <a href="supremum" title="wikilink"><code>least</code> <code>upper</code> <code>bound</code></a> <code>for</code> <code>each</code> <code>row</code></em><br/>
<code>        </code><strong><code>for</code></strong><code> i := p - 1, p - 2, ..., 1, 0:</code><br/>
<code>                 </code><br/>
<code>            </code><em><code>//</code> <code>search</code> <code>this</code> <code>row</code> <code>until</code> <code>we</code> <code>find</code> <code>a</code> <code>value</code> <code>less</code> <code>than</code> <code>u</code></em><br/>
<code>            </code><strong><code>while</code></strong><code> j </code><code> u:</code><br/>
<code>                j := j + 1</code><br/>
<code>            </code><strong><code>endwhile</code></strong><br/>
<code>            </code><br/>
<code>            ''// the entry preceding the one we just found is greater than u</code><br/>
<code>            P[i] := j - 1</code><br/>
<code>        </code><strong><code>endfor</code></strong><br/>
<code>        </code><br/>
<code>        </code><strong><code>return</code></strong><code> P</code><br/>
<code>    </code><strong><code>endfunction</code></strong></p>

<p>This <code>greater_h</code> function is traversing the kernel matrix from the bottom left to the top right, and returns a vector 

<math display="inline" id="Medcouple:61">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 of indices that indicate for each row where the boundary lies between values greater than 

<math display="inline" id="Medcouple:62">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 and those less than or equal to 

<math display="inline" id="Medcouple:63">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

. This method works because of the row-column sorted property of 

<math display="inline" id="Medcouple:64">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>h</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=(h_{ij})
  </annotation>
 </semantics>
</math>

. Since <code>greater_h</code> computes at most 

<math display="inline" id="Medcouple:65">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>+</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p+q
  </annotation>
 </semantics>
</math>

 values of 

<math display="inline" id="Medcouple:66">
 <semantics>
  <msub>
   <mi>h</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{ij}
  </annotation>
 </semantics>
</math>

, its complexity is 

<math display="inline" id="Medcouple:67">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>Conceptually, the resulting 

<math display="inline" id="Medcouple:68">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 vector can be visualised as establishing a boundary on the matrix as suggested by the following diagram, where the red entries are all larger than 

<math display="inline" id="Medcouple:69">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

:</p>
<dl>
<dd><dl>
<dd>
</dd>
</dl>
</dd>
</dl>

<p>The symmetric algorithm for computing the values of 

<math display="inline" id="Medcouple:70">
 <semantics>
  <msub>
   <mi>h</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{ij}
  </annotation>
 </semantics>
</math>

 less than 

<math display="inline" id="Medcouple:71">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 is very similar. It instead proceeds along 

<math display="inline" id="Medcouple:72">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 in the opposite direction, from the top right to the bottom left:</p>

<p><code>    </code><strong><code>function</code></strong><code> less_h(</code><strong><code>kernel</code></strong><code> h, </code><strong><code>int</code></strong><code> p, </code><strong><code>int</code></strong><code> q, </code><strong><code>real</code></strong><code> u):</code><br/>
<code>    </code><br/>
<code>        </code><em><code>//</code> <code>vector</code> <code>of</code> <code>size</code> <code>p</code></em><br/>
<code>        Q := </code><strong><code>vector</code></strong><code>(p)</code><br/>
<code>        </code><br/>
<code>        </code><em><code>//</code> <code>last</code> <code>possible</code> <code>row</code> <code>index</code></em><br/>
<code>        j := q - 1</code><br/>
<code>        </code><br/>
<code>        </code><em><code>//</code> <code>starting</code> <code>from</code> <code>the</code> <code>top,</code> <code>compute</code> <code>the</code> <a href="infimum" title="wikilink"><code>greatest</code> <code>lower</code> <code>bound</code></a> <code>for</code> <code>each</code> <code>row</code></em><br/>
<code>        </code><strong><code>for</code></strong><code> i := 0, 1, ..., p - 2, p - 1:</code><br/>
<code>        </code><br/>
<code>            </code><em><code>//</code> <code>search</code> <code>this</code> <code>row</code> <code>until</code> <code>we</code> <code>find</code> <code>a</code> <code>value</code> <code>greater</code> <code>than</code> <code>u</code></em><br/>
<code>            </code><strong><code>while</code></strong><code> j &gt;= 0 </code><strong><code>and</code></strong><code> h(i, j) </code><code>u</code><code>:</code></p>
<dl>
<dd><dl>
<dd>
</dd>
</dl>
</dd>
</dl>

<p>For each 

<math display="inline" id="Medcouple:73">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, we have that 

<math display="inline" id="Medcouple:74">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>i</mi>
   </msub>
   <mo>≥</mo>
   <msub>
    <mi>Q</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}\geq Q_{i}
  </annotation>
 </semantics>
</math>

, with strict inequality occurring only for those rows that have values equal to 

<math display="inline" id="Medcouple:75">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

.</p>

<p>We also have that the sums</p>

<p>

<math display="block" id="Medcouple:76">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>p</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>P</mi>
       <mi>i</mi>
      </msub>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>p</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <msub>
     <mi>Q</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>i</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=0}^{p-1}(P_{i}+1)~{}\qquad~{}\sum_{i=0}^{p-1}Q_{i}
  </annotation>
 </semantics>
</math>

 give, respectively, the number of elements of 

<math display="inline" id="Medcouple:77">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 that are greater than 

<math display="inline" id="Medcouple:78">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

, and the number of elements that are greater than or equal to 

<math display="inline" id="Medcouple:79">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

. Thus this method also yields the <a href="ranking#Ranking_in_statistics" title="wikilink">rank</a> of 

<math display="inline" id="Medcouple:80">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 within the elements 

<math display="inline" id="Medcouple:81">
 <semantics>
  <msub>
   <mi>h</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{ij}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Medcouple:82">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h4 id="weighted-median-of-row-medians">Weighted median of row medians</h4>

<p>The second observation is that we can use the sorted matrix structure to instantly compare any element to at least half of the entries in the matrix. For example, the median of the row medians across the entire matrix is less than the upper left quadrant in red, but greater than the lower right quadrant in blue:</p>
<dl>
<dd><dl>
<dd>
</dd>
</dl>
</dd>
</dl>

<p>More generally, using the boundaries given by the 

<math display="inline" id="Medcouple:83">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Medcouple:84">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 vectors from the previous section, we can assume that after some iterations, we have pinpointed the position of the medcouple to lie between the red left boundary and the blue right boundary:<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<dl>
<dd><dl>
<dd>
</dd>
</dl>
</dd>
</dl>

<p>The yellow entries indicate the median of each row. If we mentally re-arrange the rows so that the medians align and ignore the discarded entries outside the boundaries,</p>
<dl>
<dd><dl>
<dd>
</dd>
</dl>
</dd>
</dl>

<p>we can select a <a href="weighted_median" title="wikilink">weighted median</a> of these medians, each entry weighted by the number of remaining entries on this row. This ensures that we can discard at least 1/4 of all remaining values no matter if we have to discard the larger values in red or the smaller values in blue:</p>
<dl>
<dd><dl>
<dd>
</dd>
</dl>
</dd>
</dl>

<p>Each row median can be computed in 

<math display="inline" id="Medcouple:85">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1)
  </annotation>
 </semantics>
</math>

 time, since the rows are sorted, and the <a href="weighted_median" title="wikilink">weighted median</a> can be computed in 

<math display="inline" id="Medcouple:86">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 time, using a binary search.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h4 id="kth-pair-algorithm">K<sup>th</sup> pair algorithm</h4>

<p>Putting together these two observations, the fast medcouple algorithm proceeds broadly as follows.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>
<ol>
<li>Compute the necessary ingredients for the medcouple kernel function 

<math display="inline" id="Medcouple:87">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <interval closure="open">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(i,j)
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Medcouple:88">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 sorted rows and 

<math display="inline" id="Medcouple:89">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 sorted columns.</li>
<li>At each iteration, approximate the medcouple with the <a href="weighted_median" title="wikilink">weighted median</a> of the row medians.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></li>
<li>Compare this tentative guess to the entire matrix obtaining right and left boundary vectors 

<math display="inline" id="Medcouple:90">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Medcouple:91">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 respectively. The sum of these vectors also gives us the <a href="ranking#Ranking_in_statistics" title="wikilink">rank</a> of this tentative medcouple.
<ol>
<li>If the rank of the tentative medcouple is exactly 

<math display="inline" id="Medcouple:92">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mi>q</mi>
   </mrow>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>q</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   pq/2
  </annotation>
 </semantics>
</math>

, then stop. We have found the medcouple.</li>
<li>Otherwise, discard the entries greater than or less than the tentative guess by picking either 

<math display="inline" id="Medcouple:93">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Medcouple:94">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 as the new right or left boundary, depending on which side the element of rank 

<math display="inline" id="Medcouple:95">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mi>q</mi>
   </mrow>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>q</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   pq/2
  </annotation>
 </semantics>
</math>

 is in. This step always discards at least 1/4 of all remaining entries.</li>
</ol></li>
<li>Once the number of candidate medcouples between the right and left boundaries is less than or equal to 

<math display="inline" id="Medcouple:96">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, perform a <a href="selection_algorithm" title="wikilink">rank selection</a> amongst the remaining entries, such that the rank within this smaller candidate set corresponds to the 

<math display="inline" id="Medcouple:97">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mi>q</mi>
   </mrow>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>q</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   pq/2
  </annotation>
 </semantics>
</math>

 rank of the medcouple within the whole matrix.</li>
</ol>

<p>The initial sorting in order to form the 

<math display="inline" id="Medcouple:98">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <interval closure="open">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(i,j)
  </annotation>
 </semantics>
</math>

 function takes 

<math display="inline" id="Medcouple:99">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n\log n)
  </annotation>
 </semantics>
</math>

 time. At each iteration, the weighted median takes 

<math display="inline" id="Medcouple:100">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 time, as well as the computations of the new tentative 

<math display="inline" id="Medcouple:101">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Medcouple:102">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 left and right boundaries. Since each iteration discards at least 1/4 of all remaining entries, there will be at most 

<math display="inline" id="Medcouple:103">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log n)
  </annotation>
 </semantics>
</math>

 iterations.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> Thus, the whole fast algorithm takes 

<math display="inline" id="Medcouple:104">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n\log n)
  </annotation>
 </semantics>
</math>

 time.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>

<p>Let us restate the fast algorithm in more detail. <code>
    '''function''' medcouple('''vector''' X):
        ''// X is a vector of size n''
        
        ''// compute initial ingredients as for [[Medcouple#Na.C3.AFve algorithm|the naïve medcouple]]''
        [[Sorting algorithm|sort_decreasing]](X)
        
        xm := median(X)
        xscale := 2*max(X)
        
        Zplus  := [(x - xm)/xscale | x '''in''' X '''such that''' x &gt;= xm]
        Zminus := [(x - xm)/xscale | x '''in''' X '''such that''' x &lt;= xm]
        
        p := size(Zplus)
        q := size(Zminus)
        
        '''function''' h(i,j):
            a := Zplus[i]
            b := Zminus[j]
            
            '''if''' a == b:
                '''return''' [[sign function|signum]](p - 1 - i - j)
            '''else''':
                '''return''' (a + b)/(a - b)
            '''endif'''
        '''endfunction'''
        
        ''// begin Kth pair algorithm (Johnson &amp; Mizoguchi)''
        
        ''// the initial left and right boundaries, two vectors of size p''
        L := [0, 0, ..., 0]
        R := [q - 1, q - 1, ..., q - 1]
        
        ''// number of entries to the left of the left boundary''
        Ltotal := 0
        
        ''// number of entries to the left of the right boundary''
        Rtotal := p*q
        
        ''// since we are indexing from zero, the medcouple index is one''
        ''// less than its rank''
        medcouple_index := [[floor function|floor]](Rtotal/2)
        
        ''// iterate while the number of entries between the boundaries is''
        ''// greater than the number of rows in the matrix''
        '''while''' Rtotal - Ltotal &gt; p:
            
            ''// compute row medians and their associated weights, but skip''
            ''// any rows that are already empty''
            middle_idx  := [i | i '''in''' [0, 1, ..., p - 1] '''such''' '''that''' L[i] &lt;= R[i]]
            row_medians := [h(i, [[floor function|floor]]((L[i] + R[i])/2) | i '''in''' middle_idx]
            weights := [R[i] - L[i] + 1 | i '''in''' middle_idx]
            
            WM := [[weighted median]](row_medians, weights)
            
            ''// new tentative right and left boundaries''
            P := [[Medcouple#Comparing a value against the kernel matrix|greater_h]](h, p, q, WM)
            Q := [[Medcouple#Comparing a value against the kernel matrix|less_h]](h, p, q, WM)
            
            Ptotal := sum(P) + size(P)
            Qtotal := sum(Q)
            
            ''// determine which entries to discard, or if we've found the medcouple''
            '''if''' medcouple_index &lt;= Ptotal - 1:
                R := P
                Rtotal := P
            '''else''':
                '''if''' medcouple_index &gt; Qtotal - 1:
                    L := Q
                    Ltotal := Qtotal
                '''else''':
                    // found the medcouple, rank of the weighted median equals medcouple index
                    '''return''' WM
                '''endif'''
            '''endif'''
       
        '''endwhile'''
        
        // did not find the medcouple, but there are very few tentative entries remaining
        remaining := [h(i,j) | i '''in''' [0, 1, ..., p - 1],
                               j '''in''' [L[i], L[i] + 1, ..., R[i]]
                               '''such''' '''that''' L[i] &lt;= R[i] ]
        
        ''// select the medcouple by rank amongst the remaining entries''
        medcouple := [[selection algorithm|select_nth]](remaining, medcouple_index - Ltotal)
       
        '''return''' medcouple
    '''endfunction'''
</code></p>

<p>In real-world use, the algorithm also needs to account for errors arising from finite-precision <a href="floating_point_arithmetic" title="wikilink">floating point arithmetic</a>. For example, the comparisons for the medcouple kernel function should be done within <a href="machine_epsilon" title="wikilink">machine epsilon</a>, as well as the order comparisons in <a href="Medcouple#Comparing_a_value_against_the_kernel_matrix" title="wikilink">the <code>greater_h</code> and <code>less_h</code> functions</a>.</p>
<h2 id="softwaresource-code">Software/source code</h2>
<ul>
<li>The fast medcouple algorithm is implemented in <a href="R_(programming_language)" title="wikilink">R</a>'s <a href="http://svitsrv25.epfl.ch/R-doc/library/robustbase/html/mc.html">robustbase package.</a></li>
<li>A GPL'ed <a class="uri" href="C++" title="wikilink">C++</a> implementation of the <a href="http://inversethought.com/hg/medcouple/file/default/jmedcouple.c%2B%2B">fast algorithm</a>, derived from the R implementation.</li>
<li>A <a class="uri" href="Stata" title="wikilink">Stata</a> implementation of the <a href="http://econpapers.repec.org/software/bocbocode/s457699.htm">fast algorithm</a>.</li>
<li>An implementation of <a href="http://www.mathworks.com/matlabcentral/fileexchange/28501-tests-to-identify-outliers-in-data-series/content/medcouple.m">the naïve algorithm</a> in <a class="uri" href="Matlab" title="wikilink">Matlab</a> (and hence <a href="GNU_Octave" title="wikilink">GNU Octave</a>).</li>
<li>The naïve algorithm is also implemented for the <a href="Python_(programming_language)" title="wikilink">Python</a> package <a href="http://statsmodels.sourceforge.net/stable/release/version0.6.html?highlight=medcouple">statsmodels</a>.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Robust_statistic" title="wikilink">Robust statistic</a></li>
<li><a class="uri" href="Skewness" title="wikilink">Skewness</a></li>
<li><a href="Box_plot#Variations" title="wikilink">Adjusted boxplots</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Robust_statistics" title="wikilink">Category:Robust statistics</a> <a href="Category:Estimation_theory" title="wikilink">Category:Estimation theory</a> <a href="Category:Non-parametric_statistics" title="wikilink">Category:Non-parametric statistics</a> <a href="Category:Statistical_deviation_and_dispersion" title="wikilink">Category:Statistical deviation and dispersion</a> <a href="Category:Statistical_outliers" title="wikilink">Category:Statistical outliers</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"></li>
</ol>
</section>
</body>
</html>
