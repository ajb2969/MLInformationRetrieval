<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1471">Tree-depth</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Tree-depth</h1>
<hr/>

<p>In <a href="graph_theory" title="wikilink">graph theory</a>, the <strong>tree-depth</strong> of a <a href="connected_graph" title="wikilink">connected</a> <a href="undirected_graph" title="wikilink">undirected graph</a> <em>G</em> is a numerical <a href="graph_invariant" title="wikilink">invariant</a> of <em>G</em>, the minimum height of a <a href="Trémaux_tree" title="wikilink">Trémaux tree</a> for a <a href="Glossary_of_graph_theory#Subgraphs" title="wikilink">supergraph</a> of <em>G</em>. This invariant and its close relatives have gone under many different names in the literature, including vertex ranking number, ordered chromatic number, and minimum elimination tree height; it is also closely related to the <a href="cycle_rank" title="wikilink">cycle rank</a> of <a href="directed_graph" title="wikilink">directed graphs</a> and the <a href="star_height" title="wikilink">star height</a> of <a href="regular_language" title="wikilink">regular languages</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Intuitively, where the <a class="uri" href="treewidth" title="wikilink">treewidth</a> graph width parameter measures how far a graph is from being a tree, this parameter measures how far a graph is from being a star.</p>
<h2 id="definitions">Definitions</h2>

<p>The tree-depth of a graph <em>G</em> may be defined as the minimum height of a <a href="forest_(graph_theory)" title="wikilink">forest</a> <em>F</em> with the property that every edge of <em>G</em> connects a pair of nodes that have an ancestor-descendant relationship to each other in <em>F</em>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> If <em>G</em> is connected, this forest must be a single tree; it need not be a subgraph of <em>G</em>, but if it is, it is a <a href="Trémaux_tree" title="wikilink">Trémaux tree</a> for <em>G</em>.</p>

<p>The set of ancestor-descendant pairs in <em>F</em> forms a <a href="trivially_perfect_graph" title="wikilink">trivially perfect graph</a>, and the height of <em>F</em> is the size of the largest <a href="clique_(graph_theory)" title="wikilink">clique</a> in this graph. Thus, the tree-depth may alternatively be defined as the size of the largest clique in a trivially perfect supergraph of <em>G</em>, mirroring the definition of <a class="uri" href="treewidth" title="wikilink">treewidth</a> as one less than the size of the largest clique in a <a href="chordal_graph" title="wikilink">chordal</a> supergraph of <em>G</em>.</p>

<p>Another definition is the following:</p>

<p>

<math display="inline" id="Tree-depth:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mn>1</mn>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mrow>
           <mo stretchy="false">|</mo>
           <mi>G</mi>
           <mo stretchy="false">|</mo>
          </mrow>
         </mrow>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mo>;</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mn>1</mn>
         <mo>+</mo>
         <mrow>
          <mrow>
           <msub>
            <mi>min</mi>
            <mrow>
             <mi>v</mi>
             <mo>∈</mo>
             <mi>V</mi>
            </mrow>
           </msub>
           <mrow>
            <mi>t</mi>
            <mi>d</mi>
           </mrow>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>G</mi>
            <mo>-</mo>
            <mi>v</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>G</mi>
          <mtext>is connected and</mtext>
          <mrow>
           <mo stretchy="false">|</mo>
           <mi>G</mi>
           <mo stretchy="false">|</mo>
          </mrow>
         </mrow>
         <mo>></mo>
         <mn>1</mn>
        </mrow>
        <mo>;</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <msub>
           <mi>max</mi>
           <mi>i</mi>
          </msub>
          <mrow>
           <mi>t</mi>
           <mi>d</mi>
          </mrow>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>G</mi>
           <mi>i</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mtext>otherwise</mtext>
        <mo>;</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>d</ci>
     <ci>G</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <apply>
        <abs></abs>
        <ci>G</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <min></min>
         <apply>
          <in></in>
          <ci>v</ci>
          <ci>V</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>t</ci>
         <ci>d</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>G</ci>
        <ci>v</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <gt></gt>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>G</ci>
       <mtext>is connected and</mtext>
       <apply>
        <abs></abs>
        <ci>G</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <max></max>
        <ci>i</ci>
       </apply>
       <apply>
        <times></times>
        <ci>t</ci>
        <ci>d</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>G</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   td(G)=\begin{cases}1,&\text{if }|G|=1;\\
1+\min_{v\in V}td(G-v),&\text{if }G\text{ is connected and }|G|>1;\\
\max_{i}td(G_{i}),&\text{otherwise};\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>V</em> is the set of vertices of <em>G</em> and the 

<math display="inline" id="Tree-depth:1">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{i}
  </annotation>
 </semantics>
</math>

 are the connected components of <em>G</em>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> This definition mirrors the definition of <a href="cycle_rank" title="wikilink">cycle rank</a> of directed graphs, which uses strong connectivity and strongly connected components in place of undirected connectivity and connected components.</p>

<p>Tree-depth may also be defined using a form of <a href="graph_coloring" title="wikilink">graph coloring</a>. A <strong>centered coloring</strong> of a graph is a coloring of its vertices with the property that every connected <a href="induced_subgraph" title="wikilink">induced subgraph</a> has a color that appears exactly once. Then, the tree-depth is the minimum number of colors in a centered coloring of the given graph. If <em>F</em> is a forest of height <em>d</em> with the property that every edge of <em>G</em> connects an ancestor and a descendant in the tree, then a centered coloring of <em>G</em> using <em>d</em> colors may be obtained by coloring each vertex by its distance from the root of its tree in <em>F</em>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Finally, one can define this in terms of a <a href="pebble_game" title="wikilink">pebble game</a>, or more precisely as a <a href="Pursuit-evasion" title="wikilink">cops and robber</a> game. Consider the following game, played on an undirected graph. There are two players, a robber and a cop. The robber has one pebble he can move along the edges of the given graph. The cop has an unlimited number of pebbles, but she wants to minimize the amount of pebbles she uses. The cop cannot move a pebble after it hass been placed on the graph. The game proceeds as follows. The robber places his pebble. The cop then announces where she wants to place a new cop pebble. The robber can then move his pebble along edges, but not through occupied vertices. The game is over when the cop player places a pebble on top of the robber pebble. The tree-depth of the given graph is the minimum number of pebbles needed by the cop to guarantee a win.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> For a <a href="Star_(graph_theory)" title="wikilink">star graph</a>, two pebbles suffice: the strategy is to place a pebble at the center vertex, forcing the robber to one arm, and then to place the remaining pebble on the robber. For a <a href="path_graph" title="wikilink">path</a> with 

<math display="inline" id="Tree-depth:2">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 vertices, the cop uses a <a href="binary_search" title="wikilink">binary search</a> strategy, which guarantees that at most 

<math display="inline" id="Tree-depth:3">
 <semantics>
  <mrow>
   <mo stretchy="false">⌈</mo>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">⌉</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ceiling></ceiling>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lceil\log_{2}(n+1)\rceil
  </annotation>
 </semantics>
</math>

 pebbles are needed.</p>
<h2 id="examples">Examples</h2>

<p> The tree-depth of a <a href="complete_graph" title="wikilink">complete graph</a> equals its number of vertices, for in this case the only possible forest <em>F</em> for which every pair of vertices are in an ancestor-descendant relationship is a single path. Similarly, the tree-depth of a <a href="complete_bipartite_graph" title="wikilink">complete bipartite graph</a> <em>K</em><sub><em>x</em>,<em>y</em></sub> is min(<em>x</em>,<em>y</em>) + 1, for whatever nodes are placed at the leaves of the forest <em>F</em> must have at least min(<em>x</em>,<em>y</em>) ancestors in <em>F</em>. A forest achieving this min(<em>x</em>,<em>y</em>) + 1 bound may be constructed by forming a path for the smaller side of the bipartition, with each vertex on the larger side of the bipartition forming a leaf in <em>F</em> connected to the bottom vertex of this path.</p>

<p>The tree-depth of a path with <em>n</em> vertices is exactly 

<math display="inline" id="Tree-depth:4">
 <semantics>
  <mrow>
   <mo stretchy="false">⌈</mo>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">⌉</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ceiling></ceiling>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lceil\log_{2}(n+1)\rceil
  </annotation>
 </semantics>
</math>

. A forest <em>F</em> representing this path with this depth may be formed by placing the midpoint of the path as the root of <em>F</em> and recursing within the two smaller paths on either side of it.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="depth-of-trees-and-relation-to-treewidth">Depth of trees and relation to treewidth</h2>

<p>Any <em>n</em>-vertex <a href="tree_(graph_theory)" title="wikilink">forest</a> has tree-depth O(log <em>n</em>). For, in a forest, one can always find a constant number of vertices the removal of which leaves a forest that can be partitioned into two smaller subforests with at most 2<em>n</em>/3 vertices each. By recursively partitioning each of these two subforests, we can easily derive a logarithmic upper bound on the tree-depth. The same technique, applied to a <a href="tree_decomposition" title="wikilink">tree decomposition</a> of a graph, shows that, if the <a class="uri" href="treewidth" title="wikilink">treewidth</a> of an <em>n</em>-vertex graph <em>G</em> is <em>t</em>, then the tree-depth of <em>G</em> is O(<em>t</em> log <em>n</em>).<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Since <a href="outerplanar_graph" title="wikilink">outerplanar graphs</a>, <a href="series-parallel_graph" title="wikilink">series-parallel graphs</a>, and <a href="Halin_graph" title="wikilink">Halin graphs</a> all have bounded treewidth, they all also have at most logarithmic tree-depth.</p>

<p>In the other direction, the treewidth of a graph is at most equal to its tree-depth. More precisely, the treewidth is at most the <a class="uri" href="pathwidth" title="wikilink">pathwidth</a>, which is at most one less than the tree-depth.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="graph-minors">Graph minors</h2>

<p>A <a href="minor_(graph_theory)" title="wikilink">minor</a> of a graph <em>G</em> is another graph formed from a subgraph of <em>G</em> by contracting some of its edges. Tree-depth is monotonic under minors: every minor of a graph <em>G</em> has tree-depth at most equal to the tree-depth of <em>G</em> itself.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Thus, by the <a href="Robertson–Seymour_theorem" title="wikilink">Robertson–Seymour theorem</a>, for every fixed <em>d</em> the set of graphs with tree-depth at most <em>d</em> has a finite set of <a href="forbidden_graph_characterization" title="wikilink">forbidden minors</a>.</p>

<p>If <em>C</em> is a class of graphs closed under taking graph minors, then the graphs in <em>C</em> have tree-depth 

<math display="inline" id="Tree-depth:5">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1)
  </annotation>
 </semantics>
</math>

 if and only if <em>C</em> does not include all the <a href="path_graph" title="wikilink">path graphs</a>.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="induced-subgraphs">Induced subgraphs</h2>

<p>As well as behaving well under graph minors, tree-depth has close connections to the theory of <a href="induced_subgraph" title="wikilink">induced subgraphs</a> of a graph. Within the class of graphs that have tree-depth at most <em>d</em> (for any fixed integer <em>d</em>), the relation of being an induced subgraph forms a <a class="uri" href="well-quasi-ordering" title="wikilink">well-quasi-ordering</a>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> The basic idea of the proof that this relation is a well-quasi-ordering is to use induction on <em>d</em>; the forests of height <em>d</em> may be interpreted as sequences of forests of height <em>d</em> − 1 (formed by deleting the roots of the trees in the height-<em>d</em> forest) and <a href="Higman's_lemma" title="wikilink">Higman's lemma</a> can be used together with the induction hypothesis to show that these sequences are well-quasi-ordered.</p>

<p>Well-quasi-ordering implies that any property of graphs that is monotonic with respect to induced subgraphs has finitely many forbidden induced subgraphs, and therefore may be tested in polynomial time on graphs of bounded tree-depth. The graphs with tree-depth at most <em>d</em> themselves also have a finite set of forbidden induced subgraphs.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>If <em>C</em> is a class of graphs with bounded <a href="degeneracy_(graph_theory)" title="wikilink">degeneracy</a>, the graphs in <em>C</em> have bounded tree-depth if and only if there is a path graph that cannot occur as an induced subgraph of a graph in <em>C</em>.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="complexity">Complexity</h2>

<p>Computing the tree-depth is computationally hard: the corresponding decision problem is <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> The problem remains NP-complete for <a href="complement_(graph_theory)" title="wikilink">complements</a> of <a href="bipartite_graph" title="wikilink">bipartite graphs</a>,<ref <mtpl="" for="" graph="" name="p88"></ref></p></body></html>

<p>, as well as for <a href="chordal_graph" title="wikilink">chordal graphs</a>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>On the positive side, the tree-depth can be computed in <a href="polynomial_time" title="wikilink">polynomial time</a> on interval graphs,<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> as well as on permutation, trapezoid, circular-arc, circular permutation graphs, and cocomparability graphs of bounded dimension.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> For undirected trees, the tree-depth can be computed in linear time.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a>  give an <a href="approximation_algorithm" title="wikilink">approximation algorithm</a> for the tree-depth with approximation ratio 

<math display="inline" id="Tree-depth:6">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O((\log n)^{2})
  </annotation>
 </semantics>
</math>

, based on the fact that the tree-depth is always within a logarithmic factor of the treewidth.</p>

<p>Because tree-depth is monotonic under graph minors, it is <a href="Parameterized_complexity" title="wikilink">fixed-parameter tractable</a>: there is an algorithm for computing tree-depth whose time is 

<math display="inline" id="Tree-depth:7">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>d</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <msup>
    <mi>n</mi>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>d</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(d)n^{O(1)}
  </annotation>
 </semantics>
</math>

, where <em>d</em> is the depth of the given graph and <em>n</em> is its number of vertices. Thus, for every fixed value of <em>d</em>, the problem of testing whether the tree-depth is at most <em>d</em> can be solved in <a href="polynomial_time" title="wikilink">polynomial time</a>. More specifically, the dependence on <em>n</em> in this algorithm can be made linear, by the following method: compute a depth first search tree, and test whether this tree's depth is greater than 2<sup><em>d</em></sup>. If so, the tree-depth of the graph is greater than <em>d</em> and the problem is solved. If not, the shallow depth first search tree can be used to construct a <a href="tree_decomposition" title="wikilink">tree decomposition</a> with bounded width, and standard <a href="dynamic_programming" title="wikilink">dynamic programming</a> techniques for graphs of bounded treewidth can be used to compute the depth in linear time.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>It is also possible to compute the tree-depth exactly, for graphs whose tree-depth may be large, in time <em>O</em>(<em>c</em><sup><em>n</em></sup>) for a constant <em>c</em> slightly smaller than 2.</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Graph_coloring" title="wikilink">Category:Graph coloring</a> <a href="Category:Graph_invariants" title="wikilink">Category:Graph invariants</a> <a href="Category:Graph_minor_theory" title="wikilink">Category:Graph minor theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">; ; , p. 116.<a href="#fnref1">↩</a></li>
<li id="fn2">, Definition 6.1, p. 115.<a href="#fnref2">↩</a></li>
<li id="fn3">, Lemma 6.1, p. 117.<a href="#fnref3">↩</a></li>
<li id="fn4">, Section 6.5, "Centered Colorings", pp. 125–128.<a href="#fnref4">↩</a></li>
<li id="fn5">, Theorem 5, , Main Theorem.<a href="#fnref5">↩</a></li>
<li id="fn6">, Formula 6.2, p. 117.<a href="#fnref6">↩</a></li>
<li id="fn7">; , Corollary 6.1, p. 124.<a href="#fnref7">↩</a></li>
<li id="fn8">; , p. 123.<a href="#fnref8">↩</a></li>
<li id="fn9">, Lemma 6.2, p. 117.<a href="#fnref9">↩</a></li>
<li id="fn10">, Proposition 6.4, p. 122.<a href="#fnref10">↩</a></li>
<li id="fn11">, Lemma 6.13, p. 137.<a href="#fnref11">↩</a></li>
<li id="fn12">, p. 138. Figure 6.6 on p. 139 shows the 14 forbidden subgraphs for graphs of tree-depth at most three, credited to the 2007 Ph.D. thesis of Z. Dvořák.<a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14">.<a href="#fnref14">↩</a></li>
<li id="fn15">.<a href="#fnref15">↩</a></li>
<li id="fn16">.<a href="#fnref16">↩</a></li>
<li id="fn17">.<a href="#fnref17">↩</a></li>
<li id="fn18">; .<a href="#fnref18">↩</a></li>
<li id="fn19">, p. 138. A more complicated linear time algorithm based on the planarity of the excluded minors for tree-depth was given earlier by . For improved parameterized algorithms see .<a href="#fnref19">↩</a></li>
</ol>
</section>


