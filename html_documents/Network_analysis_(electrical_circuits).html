<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="514">Network analysis (electrical circuits)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Network analysis (electrical circuits)</h1>
<hr/>

<p>A network, in the context of <a class="uri" href="electronics" title="wikilink">electronics</a>, is a collection of interconnected components. <strong>Network analysis</strong> is the process of finding the voltages across, and the currents through, every component in the network. There are many different techniques for calculating these values. However, for the most part, the applied technique assumes that the components of the network are all <a class="uri" href="linear" title="wikilink">linear</a>. The methods described in this article are only applicable to <em>linear</em> network analysis, except where explicitly stated.</p>
<h2 id="definitions">Definitions</h2>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong><a href="Electronic_component" title="wikilink">Component</a></strong></p></td>
<td style="text-align: left;">
<p>A device with two or more terminals into which, or out of which, current may flow.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong><a href="Node_(circuits)" title="wikilink">Node</a></strong></p></td>
<td style="text-align: left;">
<p>A point at which terminals of more than two components are joined. A conductor with a substantially zero resistance is considered to be a node for the purpose of analysis.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Branch</strong></p></td>
<td style="text-align: left;">
<p>The component(s) joining two nodes.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong><a href="Mesh_analysis" title="wikilink">Mesh</a></strong></p></td>
<td style="text-align: left;">
<p>A group of branches within a network joined so as to form a complete loop.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong><a href="Port_(circuit_theory)" title="wikilink">Port</a></strong></p></td>
<td style="text-align: left;">
<p>Two terminals where the current into one is identical to the current out of the other.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong><a href="Electrical_circuit" title="wikilink">Circuit</a></strong></p></td>
<td style="text-align: left;">
<p>A current from one terminal of a <a href="generator_(circuit_theory)" title="wikilink">generator</a>, through load component(s) and back into the other terminal. A circuit is, in this sense, a one-port network and is a trivial case to analyse. If there is any connection to any other circuits then a non-trivial network has been formed and at least two ports must exist. Often, "circuit" and "network" are used interchangeably, but many analysts reserve "network" to mean an idealised model consisting of ideal components.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong><a href="Transfer_function" title="wikilink">Transfer function</a></strong></p></td>
<td style="text-align: left;">
<p>The relationship of the currents and/or voltages between two ports. Most often, an input port and an output port are discussed and the transfer function is described as gain or attenuation.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>Component transfer function</strong></p></td>
<td style="text-align: left;">
<p>For a two-terminal component (i.e. one-port component), the current and voltage are taken as the input and output and the transfer function will have units of impedance or admittance (it is usually a matter of arbitrary convenience whether voltage or current is considered the input). A three (or more) terminal component effectively has two (or more) ports and the transfer function cannot be expressed as a single impedance. The usual approach is to express the transfer function as a matrix of parameters. These parameters can be impedances, but there is a large number of other approaches (see <a href="two-port_network" title="wikilink">two-port network</a>).</p></td>
</tr>
</tbody>
</table>
<h2 id="equivalent-circuits">Equivalent circuits</h2>

<p>  A useful procedure in network analysis is to simplify the network by reducing the number of components. This can be done by replacing the actual components with other notional components that have the same effect. A particular technique might directly reduce the number of components, for instance by combining impedances in series. On the other hand it might merely change the form into one in which the components can be reduced in a later operation. For instance, one might transform a voltage generator into a current generator using Norton's theorem in order to be able to later combine the internal resistance of the generator with a parallel impedance load.</p>

<p>A <a href="resistive_circuit" title="wikilink">resistive circuit</a> is a circuit containing only <a class="uri" href="resistors" title="wikilink">resistors</a>, ideal <a href="current_source" title="wikilink">current sources</a>, and ideal <a href="voltage_source" title="wikilink">voltage sources</a>. If the sources are constant (<a href="Direct_current" title="wikilink">DC</a>) sources, the result is a <a href="direct_current_circuit" title="wikilink">DC circuit</a>. Analysis of a circuit consists of solving for the voltages and currents present in the circuit. The solution principles outlined here also apply to <a href="phasor_(electronics)" title="wikilink">phasor</a> analysis of <a href="#AC_circuits" title="wikilink">AC circuits</a>.</p>

<p>Two circuits are said to be <strong>equivalent</strong> with respect to a pair of terminals if the <a class="uri" href="voltage" title="wikilink">voltage</a> across the terminals and <a href="Current_(electricity)" title="wikilink">current</a> through the terminals for one network have the same relationship as the voltage and current at the terminals of the other network.</p>

<p>If 

<math display="inline" id="Network_analysis_(electrical_circuits):0">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>V</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{2}=V_{1}
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Network_analysis_(electrical_circuits):1">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>I</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{2}=I_{1}
  </annotation>
 </semantics>
</math>

 for all (real) values of 

<math display="inline" id="Network_analysis_(electrical_circuits):2">
 <semantics>
  <msub>
   <mi>V</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{1}
  </annotation>
 </semantics>
</math>

, then with respect to terminals ab and xy, circuit 1 and circuit 2 are equivalent.</p>

<p>The above is a sufficient definition for a <a class="uri" href="one-port" title="wikilink">one-port</a> network. For more than one port, then it must be defined that the currents and voltages between all pairs of corresponding ports must bear the same relationship. For instance, star and delta networks are effectively three port networks and hence require three simultaneous equations to fully specify their equivalence.</p>
<h3 id="impedances-in-series-and-in-parallel">Impedances in series and in parallel</h3>

<p>Any two terminal network of impedances can eventually be reduced to a single impedance by successive applications of impedances in series or impedances in parallel.</p>

<p>Impedances in <a href="Series_and_parallel_circuits#Series_circuits" title="wikilink">series</a>

<math display="block" id="Network_analysis_(electrical_circuits):3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Z</mi>
     <mi>eq</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>Z</mi>
      <mn>1</mn>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>Z</mi>
      <mn>2</mn>
     </msub>
     <mo>+</mo>
     <mpadded width="+1.7pt">
      <mi mathvariant="normal">⋯</mi>
     </mpadded>
     <mo>+</mo>
     <msub>
      <mi>Z</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Z</ci>
     <ci>eq</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{\mathrm{eq}}=Z_{1}+Z_{2}+\,\cdots\,+Z_{n}.
  </annotation>
 </semantics>
</math>

</p>

<p>Impedances in <a href="Series_and_parallel_circuits#Parallel_circuits" title="wikilink">parallel</a>

<math display="block" id="Network_analysis_(electrical_circuits):4">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msub>
      <mi>Z</mi>
      <mi>eq</mi>
     </msub>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msub>
       <mi>Z</mi>
       <mn>1</mn>
      </msub>
     </mfrac>
     <mo>+</mo>
     <mfrac>
      <mn>1</mn>
      <msub>
       <mi>Z</mi>
       <mn>2</mn>
      </msub>
     </mfrac>
     <mo>+</mo>
     <mpadded width="+1.7pt">
      <mi mathvariant="normal">⋯</mi>
     </mpadded>
     <mo>+</mo>
     <mfrac>
      <mn>1</mn>
      <msub>
       <mi>Z</mi>
       <mi>n</mi>
      </msub>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <ci>eq</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Z</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Z</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Z</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{Z_{\mathrm{eq}}}=\frac{1}{Z_{1}}+\frac{1}{Z_{2}}+\,\cdots\,+\frac{1}{%
Z_{n}}.
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd>The above simplified for only two impedances in parallel

<math display="block" id="Network_analysis_(electrical_circuits):5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Z</mi>
     <mi>eq</mi>
    </msub>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <msub>
       <mi>Z</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>Z</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mrow>
      <msub>
       <mi>Z</mi>
       <mn>1</mn>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>Z</mi>
       <mn>2</mn>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Z</ci>
     <ci>eq</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Z</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Z</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Z</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Z</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{\mathrm{eq}}=\frac{Z_{1}Z_{2}}{Z_{1}+Z_{2}}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<h3 id="delta-wye-transformation">Delta-wye transformation</h3>
<figure><b>(Figure)</b>
<figcaption>Delta-Star Transformation.svg</figcaption>
</figure>

<p>A network of impedances with more than two terminals cannot be reduced to a single impedance equivalent circuit. An n-terminal network can, at best, be reduced to <em>n</em> impedances (at worst <sup><em>n</em></sup>C<sub>2</sub>). For a three terminal network, the three impedances can be expressed as a three node delta (Δ) network or four node star (Y) network. These two networks are equivalent and the transformations between them are given below. A general network with an arbitrary number of nodes cannot be reduced to the minimum number of impedances using only series and parallel combinations. In general, Y-Δ and Δ-Y transformations must also be used. For some networks the extension of Y-Δ to <a href="#General_form_of_network_node_elimination" title="wikilink">star-polygon</a> transformations may also be required.</p>

<p>For equivalence, the impedances between any pair of terminals must be the same for both networks, resulting in a set of three simultaneous equations. The equations below are expressed as resistances but apply equally to the general case with impedances.</p>
<h4 id="delta-to-star-transformation-equations">Delta-to-star transformation equations</h4>

<p>

<math display="block" id="Network_analysis_(electrical_circuits):6">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>a</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>ac</mi>
     </msub>
     <msub>
      <mi>R</mi>
      <mi>ab</mi>
     </msub>
    </mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>ac</mi>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>R</mi>
      <mi>ab</mi>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>R</mi>
      <mi>bc</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>ac</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>ab</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>ac</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>ab</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>bc</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{a}=\frac{R_{\mathrm{ac}}R_{\mathrm{ab}}}{R_{\mathrm{ac}}+R_{\mathrm{ab}}+R_%
{\mathrm{bc}}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Network_analysis_(electrical_circuits):7">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>b</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>ab</mi>
     </msub>
     <msub>
      <mi>R</mi>
      <mi>bc</mi>
     </msub>
    </mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>ac</mi>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>R</mi>
      <mi>ab</mi>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>R</mi>
      <mi>bc</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>ab</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>bc</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>ac</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>ab</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>bc</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{b}=\frac{R_{\mathrm{ab}}R_{\mathrm{bc}}}{R_{\mathrm{ac}}+R_{\mathrm{ab}}+R_%
{\mathrm{bc}}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Network_analysis_(electrical_circuits):8">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>c</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>bc</mi>
     </msub>
     <msub>
      <mi>R</mi>
      <mi>ac</mi>
     </msub>
    </mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>ac</mi>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>R</mi>
      <mi>ab</mi>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>R</mi>
      <mi>bc</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>c</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>bc</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>ac</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>ac</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>ab</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>bc</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{c}=\frac{R_{\mathrm{bc}}R_{\mathrm{ac}}}{R_{\mathrm{ac}}+R_{\mathrm{ab}}+R_%
{\mathrm{bc}}}
  </annotation>
 </semantics>
</math>

</p>
<h4 id="star-to-delta-transformation-equations">Star-to-delta transformation equations</h4>

<p>

<math display="block" id="Network_analysis_(electrical_circuits):9">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>ac</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <msub>
       <mi>R</mi>
       <mi>a</mi>
      </msub>
      <msub>
       <mi>R</mi>
       <mi>b</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>R</mi>
       <mi>b</mi>
      </msub>
      <msub>
       <mi>R</mi>
       <mi>c</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>R</mi>
       <mi>c</mi>
      </msub>
      <msub>
       <mi>R</mi>
       <mi>a</mi>
      </msub>
     </mrow>
    </mrow>
    <msub>
     <mi>R</mi>
     <mi>b</mi>
    </msub>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>ac</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>a</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>b</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>c</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>c</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{\mathrm{ac}}=\frac{R_{a}R_{b}+R_{b}R_{c}+R_{c}R_{a}}{R_{b}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Network_analysis_(electrical_circuits):10">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>ab</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <msub>
       <mi>R</mi>
       <mi>a</mi>
      </msub>
      <msub>
       <mi>R</mi>
       <mi>b</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>R</mi>
       <mi>b</mi>
      </msub>
      <msub>
       <mi>R</mi>
       <mi>c</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>R</mi>
       <mi>c</mi>
      </msub>
      <msub>
       <mi>R</mi>
       <mi>a</mi>
      </msub>
     </mrow>
    </mrow>
    <msub>
     <mi>R</mi>
     <mi>c</mi>
    </msub>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>ab</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>a</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>b</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>c</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>c</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{\mathrm{ab}}=\frac{R_{a}R_{b}+R_{b}R_{c}+R_{c}R_{a}}{R_{c}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Network_analysis_(electrical_circuits):11">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>bc</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <msub>
       <mi>R</mi>
       <mi>a</mi>
      </msub>
      <msub>
       <mi>R</mi>
       <mi>b</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>R</mi>
       <mi>b</mi>
      </msub>
      <msub>
       <mi>R</mi>
       <mi>c</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>R</mi>
       <mi>c</mi>
      </msub>
      <msub>
       <mi>R</mi>
       <mi>a</mi>
      </msub>
     </mrow>
    </mrow>
    <msub>
     <mi>R</mi>
     <mi>a</mi>
    </msub>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>bc</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>a</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>b</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>c</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>c</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{\mathrm{bc}}=\frac{R_{a}R_{b}+R_{b}R_{c}+R_{c}R_{a}}{R_{a}}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="general-form-of-network-node-elimination">General form of network node elimination</h3>

<p>The star-to-delta and series-resistor transformations are special cases of the general resistor network node elimination algorithm. Any node connected by 

<math display="inline" id="Network_analysis_(electrical_circuits):12">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 resistors (

<math display="inline" id="Network_analysis_(electrical_circuits):13">
 <semantics>
  <msub>
   <mi>R</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{1}
  </annotation>
 </semantics>
</math>


 .. 

<math display="inline" id="Network_analysis_(electrical_circuits):14">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>N</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{N}
  </annotation>
 </semantics>
</math>

) to nodes <strong>1</strong> .. <strong>N</strong> can be replaced by 

<math display="inline" id="Network_analysis_(electrical_circuits):15">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mstyle scriptlevel="+1">
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mi>N</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mn>2</mn>
      </mtd>
     </mtr>
    </mtable>
   </mstyle>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">binomial</csymbol>
    <ci>N</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {N\choose 2}
  </annotation>
 </semantics>
</math>

 resistors interconnecting the remaining 

<math display="inline" id="Network_analysis_(electrical_circuits):16">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 nodes. The resistance between any two nodes 

<math display="inline" id="Network_analysis_(electrical_circuits):17">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Network_analysis_(electrical_circuits):18">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>


 is given by:</p>

<p>

<math display="block" id="Network_analysis_(electrical_circuits):19">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>xy</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>x</mi>
    </msub>
    <msub>
     <mi>R</mi>
     <mi>y</mi>
    </msub>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mfrac>
      <mn>1</mn>
      <msub>
       <mi>R</mi>
       <mi>i</mi>
      </msub>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>xy</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{\mathrm{xy}}=R_{x}R_{y}\sum_{i=1}^{N}\frac{1}{R_{i}}
  </annotation>
 </semantics>
</math>

 For a star-to-delta (

<math display="inline" id="Network_analysis_(electrical_circuits):20">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=3
  </annotation>
 </semantics>
</math>

) this reduces to:</p>

<p>

<math display="block" id="Network_analysis_(electrical_circuits):21">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>ab</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>a</mi>
    </msub>
    <msub>
     <mi>R</mi>
     <mi>b</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mfrac>
        <mn>1</mn>
        <mi>R</mi>
       </mfrac>
       <mi>a</mi>
      </msub>
      <mo>+</mo>
      <msub>
       <mfrac>
        <mn>1</mn>
        <mi>R</mi>
       </mfrac>
       <mi>b</mi>
      </msub>
      <mo>+</mo>
      <msub>
       <mfrac>
        <mn>1</mn>
        <mi>R</mi>
       </mfrac>
       <mi>c</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>a</mi>
     </msub>
     <msub>
      <mi>R</mi>
      <mi>b</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>R</mi>
         <mi>a</mi>
        </msub>
        <msub>
         <mi>R</mi>
         <mi>b</mi>
        </msub>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msub>
         <mi>R</mi>
         <mi>a</mi>
        </msub>
        <msub>
         <mi>R</mi>
         <mi>c</mi>
        </msub>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msub>
         <mi>R</mi>
         <mi>b</mi>
        </msub>
        <msub>
         <mi>R</mi>
         <mi>c</mi>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>a</mi>
     </msub>
     <msub>
      <mi>R</mi>
      <mi>b</mi>
     </msub>
     <msub>
      <mi>R</mi>
      <mi>c</mi>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <msub>
       <mi>R</mi>
       <mi>a</mi>
      </msub>
      <msub>
       <mi>R</mi>
       <mi>b</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>R</mi>
       <mi>b</mi>
      </msub>
      <msub>
       <mi>R</mi>
       <mi>c</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>R</mi>
       <mi>c</mi>
      </msub>
      <msub>
       <mi>R</mi>
       <mi>a</mi>
      </msub>
     </mrow>
    </mrow>
    <msub>
     <mi>R</mi>
     <mi>c</mi>
    </msub>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>ab</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>b</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <ci>R</ci>
        </apply>
        <ci>a</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <ci>R</ci>
        </apply>
        <ci>b</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <ci>R</ci>
        </apply>
        <ci>c</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>a</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>b</ci>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>R</ci>
          <ci>a</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>R</ci>
          <ci>b</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>R</ci>
          <ci>a</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>R</ci>
          <ci>c</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>R</ci>
          <ci>b</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>R</ci>
          <ci>c</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>a</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>b</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>c</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <ci>a</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <ci>b</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <ci>b</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <ci>c</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <ci>c</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <ci>a</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{\mathrm{ab}}=R_{a}R_{b}(\frac{1}{R}_{a}+\frac{1}{R}_{b}+\frac{1}{R}_{c})=%
\frac{R_{a}R_{b}(R_{a}R_{b}+R_{a}R_{c}+R_{b}R_{c})}{R_{a}R_{b}R_{c}}=\frac{R_{%
a}R_{b}+R_{b}R_{c}+R_{c}R_{a}}{R_{c}}
  </annotation>
 </semantics>
</math>

 For a series reduction (

<math display="inline" id="Network_analysis_(electrical_circuits):22">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=2
  </annotation>
 </semantics>
</math>

) this reduces to:</p>

<p>

<math display="block" id="Network_analysis_(electrical_circuits):23">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>ab</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>a</mi>
    </msub>
    <msub>
     <mi>R</mi>
     <mi>b</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mfrac>
        <mn>1</mn>
        <mi>R</mi>
       </mfrac>
       <mi>a</mi>
      </msub>
      <mo>+</mo>
      <msub>
       <mfrac>
        <mn>1</mn>
        <mi>R</mi>
       </mfrac>
       <mi>b</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>a</mi>
     </msub>
     <msub>
      <mi>R</mi>
      <mi>b</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>R</mi>
        <mi>a</mi>
       </msub>
       <mo>+</mo>
       <msub>
        <mi>R</mi>
        <mi>b</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>a</mi>
     </msub>
     <msub>
      <mi>R</mi>
      <mi>b</mi>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>a</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>R</mi>
     <mi>b</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>ab</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>b</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <ci>R</ci>
        </apply>
        <ci>a</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <ci>R</ci>
        </apply>
        <ci>b</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>a</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>b</ci>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <ci>a</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <ci>b</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>a</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>b</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{\mathrm{ab}}=R_{a}R_{b}(\frac{1}{R}_{a}+\frac{1}{R}_{b})=\frac{R_{a}R_{b}(R%
_{a}+R_{b})}{R_{a}R_{b}}=R_{a}+R_{b}
  </annotation>
 </semantics>
</math>

 For a dangling resistor (

<math display="inline" id="Network_analysis_(electrical_circuits):24">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=1
  </annotation>
 </semantics>
</math>

) it results in the elimination of the resistor because 

<math display="inline" id="Network_analysis_(electrical_circuits):25">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mstyle scriptlevel="+1">
     <mtable columnspacing="0.4em" rowspacing="0.2ex">
      <mtr>
       <mtd>
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mn>2</mn>
       </mtd>
      </mtr>
     </mtable>
    </mstyle>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">binomial</csymbol>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {1\choose 2}=0
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="source-transformation">Source transformation</h3>
<figure><b>(Figure)</b>
<figcaption>Sourcetransform.svg</figcaption>
</figure>

<p>A generator with an internal impedance (i.e. non-ideal generator) can be represented as either an ideal voltage generator or an ideal current generator plus the impedance. These two forms are equivalent and the transformations are given below. If the two networks are equivalent with respect to terminals ab, then V and I must be identical for both networks. Thus,</p>

<p>

<math display="block" id="Network_analysis_(electrical_circuits):26">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mi mathvariant="normal">s</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <msub>
     <mi>I</mi>
     <mi mathvariant="normal">s</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>normal-s</ci>
    </apply>
    <apply>
     <times></times>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>normal-s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{\mathrm{s}}=RI_{\mathrm{s}}\,\!
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Network_analysis_(electrical_circuits):27">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mi mathvariant="normal">s</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mi>V</mi>
     <mi mathvariant="normal">s</mi>
    </msub>
    <mi>R</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>normal-s</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>normal-s</ci>
     </apply>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{\mathrm{s}}=\frac{V_{\mathrm{s}}}{R}
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li><a href="Norton's_theorem" title="wikilink">Norton's theorem</a> states that any two-terminal network can be reduced to an ideal current generator and a parallel impedance.</li>
<li><a href="Thévenin's_theorem" title="wikilink">Thévenin's theorem</a> states that any two-terminal network can be reduced to an ideal voltage generator plus a series impedance.</li>
</ul>
<h2 id="simple-networks">Simple networks</h2>

<p>Some very simple networks can be analysed without the need to apply the more systematic approaches.</p>
<h3 id="voltage-division-of-series-components">Voltage division of series components</h3>

<p>Consider n impedances that are connected in <strong>series</strong>. The voltage 

<math display="inline" id="Network_analysis_(electrical_circuits):28">
 <semantics>
  <msub>
   <mi>V</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{i}
  </annotation>
 </semantics>
</math>


 across any impedance 

<math display="inline" id="Network_analysis_(electrical_circuits):29">
 <semantics>
  <msub>
   <mi>Z</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Z</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{i}
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="block" id="Network_analysis_(electrical_circuits):30">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>Z</mi>
     <mi>i</mi>
    </msub>
    <mi>I</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <msub>
       <mi>Z</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <msub>
        <mi>Z</mi>
        <mn>1</mn>
       </msub>
       <mo>+</mo>
       <msub>
        <mi>Z</mi>
        <mn>2</mn>
       </msub>
       <mo>+</mo>
       <mi mathvariant="normal">⋯</mi>
       <mo>+</mo>
       <msub>
        <mi>Z</mi>
        <mi>n</mi>
       </msub>
      </mrow>
     </mfrac>
     <mo>)</mo>
    </mrow>
    <mi>V</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Z</ci>
       <ci>i</ci>
      </apply>
      <ci>I</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Z</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Z</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Z</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>normal-⋯</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Z</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{i}=Z_{i}I=\left(\frac{Z_{i}}{Z_{1}+Z_{2}+\cdots+Z_{n}}\right)V
  </annotation>
 </semantics>
</math>

</p>
<h3 id="current-division-of-parallel-components">Current division of parallel components</h3>

<p>Consider n impedances that are connected in <strong>parallel</strong>. The current 

<math display="inline" id="Network_analysis_(electrical_circuits):31">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{i}
  </annotation>
 </semantics>
</math>

 through any impedance 

<math display="inline" id="Network_analysis_(electrical_circuits):32">
 <semantics>
  <msub>
   <mi>Z</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Z</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{i}
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="block" id="Network_analysis_(electrical_circuits):33">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mn>1</mn>
        <msub>
         <mi>Z</mi>
         <mi>i</mi>
        </msub>
       </mfrac>
       <mo>)</mo>
      </mrow>
      <mrow>
       <mrow>
        <mo>(</mo>
        <mfrac>
         <mn>1</mn>
         <msub>
          <mi>Z</mi>
          <mn>1</mn>
         </msub>
        </mfrac>
        <mo>)</mo>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mo>(</mo>
        <mfrac>
         <mn>1</mn>
         <msub>
          <mi>Z</mi>
          <mn>2</mn>
         </msub>
        </mfrac>
        <mo>)</mo>
       </mrow>
       <mo>+</mo>
       <mpadded width="+1.7pt">
        <mi mathvariant="normal">⋯</mi>
       </mpadded>
       <mo>+</mo>
       <mrow>
        <mo>(</mo>
        <mfrac>
         <mn>1</mn>
         <msub>
          <mi>Z</mi>
          <mi>n</mi>
         </msub>
        </mfrac>
        <mo>)</mo>
       </mrow>
      </mrow>
     </mfrac>
     <mo>)</mo>
    </mrow>
    <mi>I</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Z</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Z</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Z</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Z</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{i}=\left(\frac{\left(\frac{1}{Z_{i}}\right)}{\left(\frac{1}{Z_{1}}\right)+%
\left(\frac{1}{Z_{2}}\right)+\,\cdots\,+\left(\frac{1}{Z_{n}}\right)}\right)I
  </annotation>
 </semantics>
</math>

</p>

<p>for 

<math display="inline" id="Network_analysis_(electrical_circuits):34">
 <semantics>
  <mrow>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,2,...,n.
  </annotation>
 </semantics>
</math>

</p>
<h4 id="special-case-current-division-of-two-parallel-components">Special case: Current division of two parallel components</h4>

<p>

<math display="block" id="Network_analysis_(electrical_circuits):35">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <msub>
       <mi>Z</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <msub>
        <mi>Z</mi>
        <mn>1</mn>
       </msub>
       <mo>+</mo>
       <msub>
        <mi>Z</mi>
        <mn>2</mn>
       </msub>
      </mrow>
     </mfrac>
     <mo>)</mo>
    </mrow>
    <mi>I</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Z</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Z</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Z</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{1}=\left(\frac{Z_{2}}{Z_{1}+Z_{2}}\right)I
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Network_analysis_(electrical_circuits):36">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <msub>
       <mi>Z</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <msub>
        <mi>Z</mi>
        <mn>1</mn>
       </msub>
       <mo>+</mo>
       <msub>
        <mi>Z</mi>
        <mn>2</mn>
       </msub>
      </mrow>
     </mfrac>
     <mo>)</mo>
    </mrow>
    <mi>I</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Z</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Z</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Z</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{2}=\left(\frac{Z_{1}}{Z_{1}+Z_{2}}\right)I
  </annotation>
 </semantics>
</math>

</p>
<h2 id="nodal-analysis">Nodal analysis</h2>

<p>1. Label all <strong>nodes</strong> in the circuit. Arbitrarily select any node as reference.</p>

<p>2. Define a voltage variable from every remaining node to the reference. These voltage variables must be defined as voltage rises with respect to the reference node.</p>

<p>3. Write a <a href="Kirchhoff's_circuit_laws" title="wikilink">KCL</a> equation for every node except the reference.</p>

<p>4. Solve the resulting system of equations.</p>
<h2 id="mesh-analysis">Mesh analysis</h2>

<p><a class="uri" href="Mesh" title="wikilink">Mesh</a> — a loop that does not contain an inner loop.</p>

<p>1. Count the number of “window panes” in the circuit. Assign a mesh current to each window pane.</p>

<p>2. Write a <a href="Kirchhoff's_circuit_laws" title="wikilink">KVL</a> equation for every mesh whose current is unknown.</p>

<p>3. Solve the resulting equations</p>
<h2 id="superposition">Superposition</h2>

<p>In this method, the effect of each generator in turn is calculated. All the generators other than the one being considered are removed and either short-circuited in the case of voltage generators or open-circuited in the case of current generators. The total current through or the total voltage across a particular branch is then calculated by summing all the individual currents or voltages.</p>

<p><em>There is an underlying assumption to this method that the total current or voltage is a linear superposition of its parts. Therefore, the method cannot be used if non-linear components are present.</em> Note that mesh analysis and node analysis also implicitly use superposition so these too, are only applicable to linear circuits. Superposition cannot be used to find total power consumed by elements even in linear circuits. Power varies according to the square of total voltage or current and the square of the sum is not generally equal to the sum of the squares.</p>
<h2 id="choice-of-method">Choice of method</h2>

<p>Choice of method<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> is to some extent a matter of taste. If the network is particularly simple or only a specific current or voltage is required then ad-hoc application of some simple equivalent circuits may yield the answer without recourse to the more systematic methods.</p>
<ul>
<li><a href="Nodal_analysis" title="wikilink">Nodal analysis</a>: The number of voltage variables, and hence simultaneous equations to solve, equals the number of nodes minus one. Every voltage source connected to the reference node reduces the number of unknowns and equations by one.</li>
<li><a href="Mesh_analysis" title="wikilink">Mesh analysis</a>: The number of current variables, and hence simultaneous equations to solve, equals the number of meshes. Every current source in a mesh reduces the number of unknowns by one. Mesh analysis can only be used with networks which can be drawn as a <a href="Planar_graph" title="wikilink">planar</a> network, that is, with no crossing components.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
<li><a href="Superposition_theorem" title="wikilink">Superposition</a> is possibly the most conceptually simple method but rapidly leads to a large number of equations and messy impedance combinations as the network becomes larger.</li>
</ul>
<h2 id="transfer-function">Transfer function</h2>

<p>A <a href="transfer_function" title="wikilink">transfer function</a> expresses the relationship between an input and an output of a network. For resistive networks, this will always be a simple real number or an expression which boils down to a real number. Resistive networks are represented by a system of simultaneous algebraic equations. However in the general case of linear networks, the network is represented by a system of simultaneous linear differential equations. In network analysis, rather than use the differential equations directly, it is usual practice to carry out a <a href="Laplace_transform" title="wikilink">Laplace transform</a> on them first and then express the result in terms of the Laplace parameter s, which in general is <a href="Complex_number" title="wikilink">complex</a>. This is described as working in the <a class="uri" href="s-domain" title="wikilink">s-domain</a>. Working with the equations directly would be described as working in the time (or t) domain because the results would be expressed as time varying quantities. The Laplace transform is the mathematical method of transforming between the s-domain and the t-domain.</p>

<p>This approach is standard in <a href="control_theory" title="wikilink">control theory</a> and is useful for determining <a href="Stable_polynomial" title="wikilink">stability</a> of a system, for instance, in an amplifier with feedback.</p>
<h3 id="two-terminal-component-transfer-functions">Two terminal component transfer functions</h3>

<p>For two terminal components the transfer function, or more generally for non-linear elements, the <a href="constitutive_equation" title="wikilink">constitutive equation</a>, is the relationship between the current input to the device and the resulting voltage across it. The transfer function, Z(s), will thus have units of impedance – ohms. For the three passive components found in electrical networks, the transfer functions are;</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Resistor</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Network_analysis_(electrical_circuits):37">
 <semantics>
  <mrow>
   <mrow>
    <mi>Z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Z</ci>
     <ci>s</ci>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z(s)=R\,\!
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Inductor</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Network_analysis_(electrical_circuits):38">
 <semantics>
  <mrow>
   <mrow>
    <mi>Z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>s</mi>
    <mi>L</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Z</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z(s)=sL\,\!
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Capacitor</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Network_analysis_(electrical_circuits):39">
 <semantics>
  <mrow>
   <mrow>
    <mi>Z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>s</mi>
     <mi>C</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Z</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z(s)=\frac{1}{sC}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>For a network to which only steady ac signals are applied, s is replaced with <em>jω</em> and the more familiar values from ac network theory result.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Resistor</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Network_analysis_(electrical_circuits):40">
 <semantics>
  <mrow>
   <mrow>
    <mi>Z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>j</mi>
      <mi>ω</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Z</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>ω</ci>
     </apply>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z(j\omega)=R\,\!
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Inductor</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Network_analysis_(electrical_circuits):41">
 <semantics>
  <mrow>
   <mrow>
    <mi>Z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>j</mi>
      <mi>ω</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>j</mi>
    <mi>ω</mi>
    <mi>L</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Z</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>ω</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>j</ci>
     <ci>ω</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z(j\omega)=j\omega L\,\!
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Capacitor</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Network_analysis_(electrical_circuits):42">
 <semantics>
  <mrow>
   <mrow>
    <mi>Z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>j</mi>
      <mi>ω</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>j</mi>
     <mi>ω</mi>
     <mi>C</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Z</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>ω</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>ω</ci>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z(j\omega)=\frac{1}{j\omega C}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Finally, for a network to which only steady dc is applied, s is replaced with zero and dc network theory applies.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Resistor</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Network_analysis_(electrical_circuits):43">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>=</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Z</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z=R\,\!
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Inductor</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Network_analysis_(electrical_circuits):44">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Z</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z=0\,\!
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Capacitor</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Network_analysis_(electrical_circuits):45">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>=</mo>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\infin</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Z</ci>
    <mtext>\infin</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z=\infin\,\!
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
<h3 id="two-port-network-transfer-function">Two port network transfer function</h3>

<p>Transfer functions, in general, in control theory are given the symbol H(s). Most commonly in electronics, transfer function is defined as the ratio of output voltage to input voltage and given the symbol A(s), or more commonly (because analysis is invariably done in terms of sine wave response), A(jω), so that;</p>

<p>

<math display="inline" id="Network_analysis_(electrical_circuits):46">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>j</mi>
      <mi>ω</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mi>V</mi>
     <mi>o</mi>
    </msub>
    <msub>
     <mi>V</mi>
     <mi>i</mi>
    </msub>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>ω</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>o</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(j\omega)=\frac{V_{o}}{V_{i}}
  </annotation>
 </semantics>
</math>

</p>

<p>The A standing for attenuation, or amplification, depending on context. In general, this will be a complex function of <em>jω</em>, which can be derived from an analysis of the impedances in the network and their individual transfer functions. Sometimes the analyst is only interested in the magnitude of the gain and not the phase angle. In this case the complex numbers can be eliminated from the transfer function and it might then be written as;</p>

<p>

<math display="inline" id="Network_analysis_(electrical_circuits):47">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>|</mo>
    <mfrac>
     <msub>
      <mi>V</mi>
      <mi>o</mi>
     </msub>
     <msub>
      <mi>V</mi>
      <mi>i</mi>
     </msub>
    </mfrac>
    <mo>|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>ω</ci>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>o</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(\omega)=\left|{\frac{V_{o}}{V_{i}}}\right|
  </annotation>
 </semantics>
</math>

</p>
<h4 id="two-port-parameters">Two port parameters</h4>

<p>The concept of a two-port network can be useful in network analysis as a <a href="black_box" title="wikilink">black box</a> approach to analysis. The behaviour of the two-port network in a larger network can be entirely characterised without necessarily stating anything about the internal structure. However, to do this it is necessary to have more information than just the A(jω) described above. It can be shown that four such parameters are required to fully characterise the two-port network. These could be the forward transfer function, the input impedance, the reverse transfer function (i.e., the voltage appearing at the input when a voltage is applied to the output) and the output impedance. There are many others (see the main article for a full listing), one of these expresses all four parameters as impedances. It is usual to express the four parameters as a matrix;</p>

<p>

<math display="inline" id="Network_analysis_(electrical_circuits):48">
 <semantics>
  <mrow>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>V</mi>
        <mn>1</mn>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>V</mi>
        <mn>0</mn>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mtable>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mi>z</mi>
         <msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>j</mi>
            <mi>ω</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mn>11</mn>
         </msub>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mi>z</mi>
         <msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>j</mi>
            <mi>ω</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mn>12</mn>
         </msub>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mi>z</mi>
         <msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>j</mi>
            <mi>ω</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mn>21</mn>
         </msub>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mi>z</mi>
         <msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>j</mi>
            <mi>ω</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mn>22</mn>
         </msub>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mrow>
     <mo>[</mo>
     <mtable>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>I</mi>
         <mn>1</mn>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>I</mi>
         <mn>0</mn>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <cn type="integer">1</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <cn type="integer">0</cn>
      </apply>
     </matrixrow>
    </matrix>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <ci>z</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <times></times>
          <ci>j</ci>
          <ci>ω</ci>
         </apply>
         <cn type="integer">11</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>z</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <times></times>
          <ci>j</ci>
          <ci>ω</ci>
         </apply>
         <cn type="integer">12</cn>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>z</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <times></times>
          <ci>j</ci>
          <ci>ω</ci>
         </apply>
         <cn type="integer">21</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>z</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <times></times>
          <ci>j</ci>
          <ci>ω</ci>
         </apply>
         <cn type="integer">22</cn>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <cn type="integer">0</cn>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}V_{1}\\
V_{0}\end{bmatrix}=\begin{bmatrix}z(j\omega)_{11}&z(j\omega)_{12}\\
z(j\omega)_{21}&z(j\omega)_{22}\end{bmatrix}\begin{bmatrix}I_{1}\\
I_{0}\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>The matrix may be abbreviated to a representative element;</p>

<p>

<math display="inline" id="Network_analysis_(electrical_circuits):49">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mrow>
    <mi>z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>j</mi>
      <mi>ω</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <apply>
     <times></times>
     <ci>z</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>ω</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left[z(j\omega)\right]
  </annotation>
 </semantics>
</math>

 or just 

<math display="inline" id="Network_analysis_(electrical_circuits):50">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mi>z</mi>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left[z\right]
  </annotation>
 </semantics>
</math>

</p>

<p>These concepts are capable of being extended to networks of more than two ports. However, this is rarely done in reality because, in many practical cases, ports are considered either purely input or purely output. If reverse direction transfer functions are ignored, a multi-port network can always be decomposed into a number of two-port networks.</p>
<h4 id="distributed-components">Distributed components</h4>

<p>Where a network is composed of discrete components, analysis using two-port networks is a matter of choice, not essential. The network can always alternatively be analysed in terms of its individual component transfer functions. However, if a network contains <a href="distributed_element_model" title="wikilink">distributed components</a>, such as in the case of a <a href="transmission_line" title="wikilink">transmission line</a>, then it is not possible to analyse in terms of individual components since they do not exist. The most common approach to this is to model the line as a two-port network and characterise it using two-port parameters (or something equivalent to them). Another example of this technique is modelling the carriers crossing the base region in a high frequency transistor. The base region has to be modelled as distributed resistance and capacitance rather than <a href="Lumped_parameters" title="wikilink">lumped components</a>.</p>
<h4 id="image-analysis">Image analysis</h4>

<p>Transmission lines and certain types of filter design use the image method to determine their transfer parameters. In this method, the behaviour of an infinitely long cascade connected chain of identical networks is considered. The input and output impedances and the forward and reverse transmission functions are then calculated for this infinitely long chain. Although the theoretical values so obtained can never be exactly realised in practice, in many cases they serve as a very good approximation for the behaviour of a finite chain as long as it is not too short.</p>
<h2 id="non-linear-networks">Non-linear networks</h2>

<p>Most electronic designs are, in reality, non-linear. There is very little that does not include some semiconductor devices. These are invariably non-linear, the transfer function of an ideal semiconductor <a href="p-n_junction" title="wikilink">p-n junction</a> is given by the very non-linear relationship;</p>

<p>

<math display="block" id="Network_analysis_(electrical_circuits):51">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>I</mi>
     <mi>o</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>e</mi>
       <mfrac>
        <mi>v</mi>
        <msub>
         <mi>V</mi>
         <mi>T</mi>
        </msub>
       </mfrac>
      </msup>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>o</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <divide></divide>
        <ci>v</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>V</ci>
         <ci>T</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=I_{o}(e^{\frac{v}{V_{T}}}-1)
  </annotation>
 </semantics>
</math>

</p>

<p>where;</p>
<ul>
<li><em>i</em> and <em>v</em> are the instantaneous current and voltage.</li>
<li><em>I<sub>o</sub></em> is an arbitrary parameter called the reverse leakage current whose value depends on the construction of the device.</li>
<li><em>V<sub>T</sub></em> is a parameter proportional to temperature called the thermal voltage and equal to about 25mV at room temperature.</li>
</ul>

<p>There are many other ways that non-linearity can appear in a network. All methods utilising linear superposition will fail when non-linear components are present. There are several options for dealing with non-linearity depending on the type of circuit and the information the analyst wishes to obtain.</p>
<h3 id="constitutive-equations">Constitutive equations</h3>

<p>The <a class="uri" href="diode" title="wikilink">diode</a> equation above is an example of an <a href="Electrical_element#Non-linear_elements" title="wikilink">element constitutive equation</a> of the general form,</p>

<p>

<math display="block" id="Network_analysis_(electrical_circuits):52">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>v</ci>
      <ci>i</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(v,i)=0\,
  </annotation>
 </semantics>
</math>

</p>

<p>This can be thought of as a non-linear resistor. The corresponding constitutive equations for non-linear inductors and capacitors are respectively;</p>

<p>

<math display="block" id="Network_analysis_(electrical_circuits):53">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>φ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>v</ci>
      <ci>φ</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(v,\varphi)=0\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Network_analysis_(electrical_circuits):54">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>v</ci>
      <ci>q</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(v,q)=0\,
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>f</em> is any arbitrary function, <em>φ</em> is the stored magnetic flux and <em>q</em> is the stored charge.</p>
<h3 id="existence-uniqueness-and-stability">Existence, uniqueness and stability</h3>

<p>An important consideration in non-linear analysis is the question of uniqueness. For a network composed of linear components there will always be one, and only one, unique solution for a given set of boundary conditions. This is not always the case in non-linear circuits. For instance, a linear resistor with a fixed current applied to it has only one solution for the voltage across it. On the other hand, the non-linear <a href="tunnel_diode" title="wikilink">tunnel diode</a> has up to three solutions for the voltage for a given current. That is, a particular solution for the current through the diode is not unique, there may be others, equally valid. In some cases there may not be a solution at all: the question of existence of solutions must be considered.</p>

<p>Another important consideration is the question of stability. A particular solution may exist, but it may not be stable, rapidly departing from that point at the slightest stimulation. It can be shown that a network that is absolutely stable for all conditions must have one, and only one, solution for each set of conditions.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h3 id="methods">Methods</h3>
<h4 id="boolean-analysis-of-switching-networks">Boolean analysis of switching networks</h4>

<p>A switching device is one where the non-linearity is utilised to produce two opposite states. CMOS devices in digital circuits, for instance, have their output connected to either the positive or the negative supply rail and are never found at anything in between except during a transient period when the device is actually switching. Here the non-linearity is designed to be extreme, and the analyst can actually take advantage of that fact. These kinds of networks can be analysed using <a href="Boolean_algebra_(logic)" title="wikilink">Boolean algebra</a> by assigning the two states ("on"/"off", "positive"/"negative" or whatever states are being used) to the boolean constants "0" and "1".</p>

<p>The transients are ignored in this analysis, along with any slight discrepancy between the actual state of the device and the nominal state assigned to a boolean value. For instance, boolean "1" may be assigned to the state of +5V. The output of the device may actually be +4.5V but the analyst still considers this to be boolean "1". Device manufacturers will usually specify a range of values in their data sheets that are to be considered undefined (i.e. the result will be unpredictable).</p>

<p>The transients are not entirely uninteresting to the analyst. The maximum rate of switching is determined by the speed of transition from one state to the other. Happily for the analyst, for many devices most of the transition occurs in the linear portion of the devices transfer function and linear analysis can be applied to obtain at least an approximate answer.</p>

<p>It is mathematically possible to derive <a href="Boolean_algebra_(structure)" title="wikilink">boolean algebras</a> which have more than two states. There is not too much use found for these in electronics, although three-state devices are passingly common.</p>
<h4 id="separation-of-bias-and-signal-analyses">Separation of bias and signal analyses</h4>

<p>This technique is used where the operation of the circuit is to be essentially linear, but the devices used to implement it are non-linear. A transistor amplifier is an example of this kind of network. The essence of this technique is to separate the analysis into two parts. Firstly, the dc <a href="Biasing_(electronics)" title="wikilink">biases</a> are analysed using some non-linear method. This establishes the <a href="Biasing" title="wikilink">quiescent</a> operating point of the circuit. Secondly, the <a href="small_signal" title="wikilink">small signal</a> characteristics of the circuit are analysed using linear network analysis. Examples of methods that can be used for both these stages are given below.</p>
<h4 id="graphical-method-of-dc-analysis">Graphical method of dc analysis</h4>

<p>In a great many circuit designs, the dc bias is fed to a non-linear component via a resistor (or possibly a network of resistors). Since resistors are linear components, it is particularly easy to determine the quiescent operating point of the non-linear device from a graph of its transfer function. The method is as follows: from linear network analysis the output transfer function (that is output voltage against output current) is calculated for the network of resistor(s) and the generator driving them. This will be a straight line (called the <a href="load_line_(electronics)" title="wikilink">load line</a>) and can readily be superimposed on the transfer function plot of the non-linear device. The point where the lines cross is the quiescent operating point.</p>

<p>Perhaps the easiest practical method is to calculate the (linear) network open circuit voltage and short circuit current and plot these on the transfer function of the non-linear device. The straight line joining these two point is the transfer function of the network.</p>

<p>In reality, the designer of the circuit would proceed in the reverse direction to that described. Starting from a plot provided in the manufacturers data sheet for the non-linear device, the designer would choose the desired operating point and then calculate the linear component values required to achieve it.</p>

<p>It is still possible to use this method if the device being biased has its bias fed through another device which is itself non-linear – a diode for instance. In this case however, the plot of the network transfer function onto the device being biased would no longer be a straight line and is consequently more tedious to do.</p>
<h4 id="small-signal-equivalent-circuit">Small signal equivalent circuit</h4>

<p>This method can be used where the deviation of the input and output signals in a network stay within a substantially linear portion of the non-linear devices transfer function, or else are so small that the curve of the transfer function can be considered linear. Under a set of these specific conditions, the non-linear device can be represented by an equivalent linear network. It must be remembered that this equivalent circuit is entirely notional and only valid for the small signal deviations. It is entirely inapplicable to the dc biasing of the device.</p>

<p>For a simple two-terminal device, the small signal equivalent circuit may be no more than two components. A resistance equal to the slope of the v/i curve at the operating point (called the dynamic resistance), and tangent to the curve. A generator, because this tangent will not, in general, pass through the origin. With more terminals, more complicated equivalent circuits are required.</p>

<p>A popular form of specifying the small signal equivalent circuit amongst transistor manufacturers is to use the two-port network parameters known as [[two-port network#Hybrid parameters (h-parameters)|[h] parameters]]. These are a matrix of four parameters as with the [z] parameters but in the case of the [h] parameters they are a hybrid mixture of impedances, admittances, current gains and voltage gains. In this model the three terminal transistor is considered to be a two port network, one of its terminals being common to both ports. The [h] parameters are quite different depending on which terminal is chosen as the common one. The most important parameter for transistors is usually the forward current gain, h<sub>21</sub>, in the common emitter configuration. This is designated h<sub>fe</sub> on data sheets.</p>

<p>The small signal equivalent circuit in terms of two-port parameters leads to the concept of dependent generators. That is, the value of a voltage or current generator depends linearly on a voltage or current elsewhere in the circuit. For instance the [z] parameter model leads to dependent voltage generators as shown in this diagram;</p>
<figure><b>(Figure)</b>
<figcaption>[z] parameter equivalent circuit showing dependent voltage generators</figcaption>
</figure>

<p>There will always be dependent generators in a two-port parameter equivalent circuit. This applies to the [h] parameters as well as to the [z] and any other kind. These dependencies must be preserved when developing the equations in a larger linear network analysis.</p>
<h4 id="piecewise-linear-method">Piecewise linear method</h4>

<p>In this method, the transfer function of the non-linear device is broken up into regions. Each of these regions is approximated by a straight line. Thus, the transfer function will be linear up to a particular point where there will be a discontinuity. Past this point the transfer function will again be linear but with a different slope.</p>

<p>A well known application of this method is the approximation of the transfer function of a pn junction diode. The actual transfer function of an ideal diode has been given at the top of this (non-linear) section. However, this formula is rarely used in network analysis, a piecewise approximation being used instead. It can be seen that the diode current rapidly diminishes to -I<sub>o</sub> as the voltage falls. This current, for most purposes, is so small it can be ignored. With increasing voltage, the current increases exponentially. The diode is modelled as an open circuit up to the knee of the exponential curve, then past this point as a resistor equal to the <a href="bulk_resistance" title="wikilink">bulk resistance</a> of the semiconducting material.</p>

<p>The commonly accepted values for the transition point voltage are 0.7V for silicon devices and 0.3V for germanium devices. An even simpler model of the diode, sometimes used in switching applications, is short circuit for forward voltages and open circuit for reverse voltages.</p>

<p>The model of a forward biased pn junction having an approximately constant 0.7V is also a much used approximation for transistor base-emitter junction voltage in amplifier design.</p>

<p>The piecewise method is similar to the small signal method in that linear network analysis techniques can only be applied if the signal stays within certain bounds. If the signal crosses a discontinuity point then the model is no longer valid for linear analysis purposes. The model does have the advantage over small signal however, in that it is equally applicable to signal and dc bias. These can therefore both be analysed in the same operations and will be linearly superimposable.</p>
<h3 id="time-varying-components">Time-varying components</h3>

<p>In linear analysis, the components of the network are assumed to be unchanging, but in some circuits this does not apply, such as sweep oscillators, <a href="voltage_controlled_amplifier" title="wikilink">voltage controlled amplifiers</a>, and variable <a href="Electronic_filter" title="wikilink">equalisers</a>. In many circumstances the change in component value is periodic. A non-linear component excited with a periodic signal, for instance, can be represented as periodically varying <em>linear</em> component. <a href="Sidney_Darlington" title="wikilink">Sidney Darlington</a> disclosed a method of analysing such periodic time varying circuits. He developed canonical circuit forms which are analogous to the canonical forms of <a href="Ronald_Foster" title="wikilink">Ronald Foster</a> and <a href="Wilhelm_Cauer" title="wikilink">Wilhelm Cauer</a> used for analysing linear circuits.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Bartlett's_bisection_theorem" title="wikilink">Bartlett's bisection theorem</a></li>
<li><a href="Equivalent_impedance_transforms" title="wikilink">Equivalent impedance transforms</a></li>
<li><a href="Kirchhoff's_circuit_laws" title="wikilink">Kirchhoff's circuit laws</a></li>
<li><a href="Mesh_analysis" title="wikilink">Mesh analysis</a></li>
<li><a href="Millman's_Theorem" title="wikilink">Millman's Theorem</a></li>
<li><a href="Ohm's_law" title="wikilink">Ohm's law</a></li>
<li><a href="Reciprocity_(electromagnetism)#Reciprocity_for_electrical_networks" title="wikilink">Reciprocity theorem</a></li>
<li><a href="Resistive_circuit" title="wikilink">Resistive circuit</a></li>
<li><a href="Series_and_parallel_circuits" title="wikilink">Series and parallel circuits</a></li>
<li><a href="Tellegen's_theorem" title="wikilink">Tellegen's theorem</a></li>
<li><a href="Two-port_network" title="wikilink">Two-port network</a></li>
<li><a href="Y-Δ_transform" title="wikilink">Wye-delta transform</a></li>
<li><a href="Symbolic_circuit_analysis" title="wikilink">Symbolic circuit analysis</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://holbert.faculty.asu.edu/ece201/recipes.html">Circuit Analysis Techniques</a> — includes node/mesh analysis, superposition, and thevenin/norton transformation</li>
<li><a href="http://www.maxim-ic.com/appnotes.cfm/appnote_number/1939">Nodal Analysis of Op Amp Circuits</a></li>
<li><a href="http://www.swarthmore.edu/NatSci/echeeve1/Ref/mna/MNA1.html">Analysis of Resistive Circuits</a></li>
<li><a href="http://hyperphysics.phy-astr.gsu.edu/HBASE/electric/dcex.html">Circuit Analysis Related Laws, Examples and Solutions</a></li>
<li><a href="http://arxiv.org/a/khan_s_1">Sameen Ahmed Khan</a>, <a href="http://www.physedu.in/uploads/publication/12/171/29.4-5-Set-Theoretic-Approach-to-Resistor-Networks.pdf">Set Theoretic Approach to Resistor Networks</a>, Physics Education, Volume 29, No. 4, Article Number: 5 (October-December 2013).</li>
</ul>

<p>"</p>

<p><a href="Category:Electronic_design" title="wikilink">Category:Electronic design</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"> cites to justify this definition.<br/>
<a href="Sidney_Darlington" title="wikilink">Sidney Darlington</a> <br/>
follows Belevitch but notes there are now also many colloquial uses of "network".<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">Ljiljana Trajković, "Nonlinear circuits", <em>The Electrical Engineering Handbook</em> (Ed: Wai-Kai Chen), pp.79-81, Academic Press, 2005 ISBN 0-12-170960-4<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
