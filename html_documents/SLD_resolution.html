<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1581">SLD resolution</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>SLD resolution</h1>
<hr/>

<p><strong>SLD resolution</strong> (<em>Selective Linear Definite</em> clause resolution) is the basic <a href="rule_of_inference" title="wikilink">inference rule</a> used in <a href="logic_programming" title="wikilink">logic programming</a>. It is a refinement of <a href="Resolution_(logic)" title="wikilink">resolution</a>, which is both <a href="Soundness" title="wikilink">sound</a> and refutation <a href="Completeness_(logic)" title="wikilink">complete</a> for <a href="Horn_clause" title="wikilink">Horn clauses</a>.</p>
<h2 id="the-sld-inference-rule">The SLD inference rule</h2>

<p>Given a goal clause:</p>

<p>
<math display="inline" id="SLD_resolution:0">
<semantics>
<mrow>
<mi mathvariant="normal">¬</mi>
<msub>
<mi>L</mi>
<mn>1</mn>
</msub>
<mi mathvariant="normal">⋯</mi>
<mi mathvariant="normal">¬</mi>
<msub>
<mi>L</mi>
<mi>i</mi>
</msub>
<mi mathvariant="normal">⋯</mi>
<mi mathvariant="normal">¬</mi>
<msub>
<mi>L</mi>
<mi>n</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<not></not>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-⋯</ci>
<not></not>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<ci>i</ci>
</apply>
<ci>normal-⋯</ci>
<not></not>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \neg L_{1}\cdots\neg L_{i}\cdots\neg L_{n}
  </annotation>
</semantics>
</math>
</p>

<p>with selected literal 

<math display="inline" id="SLD_resolution:1">
<semantics>
<mrow>
<mi mathvariant="normal">¬</mi>
<msub>
<mi>L</mi>
<mi>i</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<not></not>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<ci>i</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \neg L_{i}
  </annotation>
</semantics>
</math>

, and an input definite clause:</p>

<p>
<math display="inline" id="SLD_resolution:2">
<semantics>
<mrow>
<mi>L</mi>
<mi mathvariant="normal">¬</mi>
<msub>
<mi>K</mi>
<mn>1</mn>
</msub>
<mi mathvariant="normal">⋯</mi>
<mi mathvariant="normal">¬</mi>
<msub>
<mi>K</mi>
<mi>m</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>L</ci>
<not></not>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>K</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-⋯</ci>
<not></not>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>K</ci>
<ci>m</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L\neg K_{1}\cdots\neg K_{m}
  </annotation>
</semantics>
</math>
</p>

<p>whose positive literal (atom) 

<math display="inline" id="SLD_resolution:3">
<semantics>
<mpadded width="+1.7pt">
<mi>L</mi>
</mpadded>
<annotation-xml encoding="MathML-Content">
<ci>L</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   L\,
  </annotation>
</semantics>
</math>
<a href="unification_(computing)" title="wikilink">unifies</a> with the atom 

<math display="inline" id="SLD_resolution:4">
<semantics>
<mpadded width="+1.7pt">
<msub>
<mi>L</mi>
<mi>i</mi>
</msub>
</mpadded>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L_{i}\,
  </annotation>
</semantics>
</math>

 of the selected literal 

<math display="inline" id="SLD_resolution:5">
<semantics>
<mrow>
<mi mathvariant="normal">¬</mi>
<mpadded width="+1.7pt">
<msub>
<mi>L</mi>
<mi>i</mi>
</msub>
</mpadded>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<not></not>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<ci>i</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \neg L_{i}\,
  </annotation>
</semantics>
</math>

, SLD resolution derives another goal clause, in which the selected literal is replaced by the negative literals of the input clause and the unifying substitution 

<math display="inline" id="SLD_resolution:6">
<semantics>
<mpadded width="+1.7pt">
<mi>θ</mi>
</mpadded>
<annotation-xml encoding="MathML-Content">
<ci>θ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \theta\,
  </annotation>
</semantics>
</math>

 is applied:</p>

<p>
<math display="inline" id="SLD_resolution:7">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi mathvariant="normal">¬</mi>
<msub>
<mi>L</mi>
<mn>1</mn>
</msub>
<mi mathvariant="normal">⋯</mi>
<mi mathvariant="normal">¬</mi>
<msub>
<mi>K</mi>
<mn>1</mn>
</msub>
<mi mathvariant="normal">⋯</mi>
<mi mathvariant="normal">¬</mi>
<mpadded width="+5pt">
<msub>
<mi>K</mi>
<mi>m</mi>
</msub>
</mpadded>
<mi mathvariant="normal">⋯</mi>
<mi mathvariant="normal">¬</mi>
<msub>
<mi>L</mi>
<mi>n</mi>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>θ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<times></times>
<not></not>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-⋯</ci>
<not></not>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>K</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-⋯</ci>
<not></not>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>K</ci>
<ci>m</ci>
</apply>
<ci>normal-⋯</ci>
<not></not>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<ci>n</ci>
</apply>
</apply>
<ci>θ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (\neg L_{1}\cdots\neg K_{1}\cdots\neg K_{m}\ \cdots\neg L_{n})\theta
  </annotation>
</semantics>
</math>
</p>

<p>In the simplest case, in propositional logic, the atoms 

<math display="inline" id="SLD_resolution:8">
<semantics>
<mpadded width="+1.7pt">
<msub>
<mi>L</mi>
<mi>i</mi>
</msub>
</mpadded>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L_{i}\,
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="SLD_resolution:9">
<semantics>
<mpadded width="+1.7pt">
<mi>L</mi>
</mpadded>
<annotation-xml encoding="MathML-Content">
<ci>L</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   L\,
  </annotation>
</semantics>
</math>

 are identical, and the unifying substitution 

<math display="inline" id="SLD_resolution:10">
<semantics>
<mpadded width="+1.7pt">
<mi>θ</mi>
</mpadded>
<annotation-xml encoding="MathML-Content">
<ci>θ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \theta\,
  </annotation>
</semantics>
</math>

 is vacuous. However, in the more general case, the unifying substitution is necessary to make the two literals identical.</p>
<h2 id="the-origin-of-the-name-sld">The origin of the name "SLD"</h2>

<p>The name "SLD resolution" was given by Maarten van Emden for the unnamed inference rule introduced by <a href="Robert_Kowalski" title="wikilink">Robert Kowalski</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Its name is derived from SL resolution,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> which is both sound and refutation complete for the unrestricted clausal form of logic. "SLD" stands for "SL resolution with Definite clauses".</p>

<p>In both, SL and SLD, "L" stands for the fact that a resolution proof can be restricted to a linear sequence of clauses:</p>

<p>
<math display="inline" id="SLD_resolution:11">
<semantics>
<mrow>
<msub>
<mi>C</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>C</mi>
<mn>2</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">⋯</mi>
<mo>,</mo>
<msub>
<mi>C</mi>
<mi>l</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<cn type="integer">2</cn>
</apply>
<ci>normal-⋯</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<ci>l</ci>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   C_{1},C_{2},\cdots,C_{l}
  </annotation>
</semantics>
</math>
</p>

<p>where the "top clause" 

<math display="inline" id="SLD_resolution:12">
<semantics>
<mpadded width="+1.7pt">
<msub>
<mi>C</mi>
<mn>1</mn>
</msub>
</mpadded>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C_{1}\,
  </annotation>
</semantics>
</math>

 is an input clause, and every other clause 

<math display="inline" id="SLD_resolution:13">
<semantics>
<mpadded width="+1.7pt">
<msub>
<mi>C</mi>
<mrow>
<mi>i</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
</mpadded>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<apply>
<plus></plus>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C_{i+1}\,
  </annotation>
</semantics>
</math>

 is a resolvent one of whose parents is the previous clause 

<math display="inline" id="SLD_resolution:14">
<semantics>
<mpadded width="+1.7pt">
<msub>
<mi>C</mi>
<mi>i</mi>
</msub>
</mpadded>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C_{i}\,
  </annotation>
</semantics>
</math>

. The proof is a refutation if the last clause 

<math display="inline" id="SLD_resolution:15">
<semantics>
<mpadded width="+1.7pt">
<msub>
<mi>C</mi>
<mi>l</mi>
</msub>
</mpadded>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<ci>l</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C_{l}\,
  </annotation>
</semantics>
</math>

 is the empty clause.</p>

<p>In SLD, all of the clauses in the sequence are goal clauses, and the other parent is an input clause. In SL resolution, the other parent is either an input clause or an ancestor clause earlier in the sequence.</p>

<p>In both SL and SLD, "S" stands for the fact that the only literal resolved upon in any clause 

<math display="inline" id="SLD_resolution:16">
<semantics>
<mpadded width="+1.7pt">
<msub>
<mi>C</mi>
<mi>i</mi>
</msub>
</mpadded>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C_{i}\,
  </annotation>
</semantics>
</math>

 is one that is uniquely selected by a selection rule or selection function. In SL resolution, the selected literal is restricted to one which has been most recently introduced into the clause. In the simplest case, such a last-in-first-out selection function can be specified by the order in which literals are written, as in <a class="uri" href="Prolog" title="wikilink">Prolog</a>. However, the selection function in SLD resolution is more general than in SL resolution and in Prolog. There is no restriction on the literal that can be selected.</p>
<h2 id="the-computational-interpretation-of-sld-resolution">The computational interpretation of SLD resolution</h2>

<p>In clausal logic, an SLD refutation demonstrates that the input set of clauses is unsatisfiable. In logic programming, however, an SLD refutation also has a computational interpretation. The top clause 

<math display="inline" id="SLD_resolution:17">
<semantics>
<mrow>
<mi mathvariant="normal">¬</mi>
<msub>
<mi>L</mi>
<mn>1</mn>
</msub>
<mi mathvariant="normal">⋯</mi>
<mi mathvariant="normal">¬</mi>
<msub>
<mi>L</mi>
<mi>i</mi>
</msub>
<mi mathvariant="normal">⋯</mi>
<mi mathvariant="normal">¬</mi>
<msub>
<mi>L</mi>
<mi>n</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<not></not>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-⋯</ci>
<not></not>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<ci>i</ci>
</apply>
<ci>normal-⋯</ci>
<not></not>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \neg L_{1}\cdots\neg L_{i}\cdots\neg L_{n}
  </annotation>
</semantics>
</math>

 can be interpreted as the denial of a conjunction of subgoals 

<math display="inline" id="SLD_resolution:18">
<semantics>
<mrow>
<msub>
<mi>L</mi>
<mn>1</mn>
</msub>
<mi mathvariant="italic">and</mi>
<mi mathvariant="normal">⋯</mi>
<mi mathvariant="italic">and</mi>
<msub>
<mi>L</mi>
<mi>i</mi>
</msub>
<mi mathvariant="italic">and</mi>
<mi mathvariant="normal">⋯</mi>
<mi mathvariant="italic">and</mi>
<msub>
<mi>L</mi>
<mi>n</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<cn type="integer">1</cn>
</apply>
<ci>italic- and</ci>
<ci>normal-⋯</ci>
<ci>italic- and</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<ci>i</ci>
</apply>
<ci>italic- and</ci>
<ci>normal-⋯</ci>
<ci>italic- and</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L_{1}\and\cdots\and L_{i}\and\cdots\and L_{n}
  </annotation>
</semantics>
</math>

. The derivation of clause 

<math display="inline" id="SLD_resolution:19">
<semantics>
<mpadded width="+1.7pt">
<msub>
<mi>C</mi>
<mrow>
<mi>i</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
</mpadded>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<apply>
<plus></plus>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C_{i+1}\,
  </annotation>
</semantics>
</math>

 from 

<math display="inline" id="SLD_resolution:20">
<semantics>
<mpadded width="+1.7pt">
<msub>
<mi>C</mi>
<mi>i</mi>
</msub>
</mpadded>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>C</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C_{i}\,
  </annotation>
</semantics>
</math>

 is the derivation, by means of <a href="backward_reasoning" title="wikilink">backward reasoning</a>, of a new set of sub-goals using an input clause as a goal-reduction procedure. The unifying substitution 

<math display="inline" id="SLD_resolution:21">
<semantics>
<mpadded width="+1.7pt">
<mi>θ</mi>
</mpadded>
<annotation-xml encoding="MathML-Content">
<ci>θ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \theta\,
  </annotation>
</semantics>
</math>

 both passes input from the selected subgoal to the body of the procedure and simultaneously passes output from the head of the procedure to the remaining unselected subgoals. The empty clause is simply an empty set of subgoals, which signals that the initial conjunction of subgoals in the top clause has been solved.</p>
<h2 id="sld-resolution-strategies">SLD resolution strategies</h2>

<p>SLD resolution implicitly defines a search tree of alternative computations, in which the initial goal clause is associated with the root of the tree. For every node in the tree and for every definite clause in the program whose positive literal unifies with the selected literal in the goal clause associated with the node, there is a child node associated with the goal clause obtained by SLD resolution.</p>

<p>A leaf node, which has no children, is a success node if its associated goal clause is the empty clause. It is a failure node if its associated goal clause is non-empty but its selected literal unifies with the positive literal of no input clause.</p>

<p>SLD resolution is non-deterministic in the sense that it does not determine the search strategy for exploring the search tree. Prolog searches the tree depth-first, one branch at a time, using backtracking when it encounters a failure node. Depth-first search is very efficient in its use of computing resources, but is incomplete if the search space contains infinite branches and the search strategy searches these in preference to finite branches: the computation does not terminate. Other search strategies, including breadth-first, best-first, and branch-and-bound search are also possible. Moreover, the search can be carried out sequentially, one node at a time, or in parallel, many nodes simultaneously.</p>

<p>SLD resolution is also non-deterministic in the sense, mentioned earlier, that the selection rule is not determined by the inference rule, but is determined by a separate decision procedure, which can be sensitive to the dynamics of the program execution process.</p>

<p>The SLD resolution search space is an or-tree, in which different branches represent alternative computations. In the case of propositional logic programs, SLD can be generalised so that the search space is an <a href="and-or_tree" title="wikilink">and-or tree</a>, whose nodes are labelled by single literals, representing subgoals, and nodes are joined either by conjunction or by disjunction. In the general case, where conjoint subgoals share variables, the and-or tree representation is more complicated.</p>
<h2 id="example">Example</h2>

<p>Given the logic program:</p>

<p><code> q :- p </code> <code>p</code></p>

<p>and the top-level goal:</p>

<p><code>q</code></p>

<p>the search space consists of a single branch, in which <code>q</code> is reduced to <code>p</code> which is reduced to the empty set of subgoals, signalling a successful computation. In this case, the program is so simple that there is no role for the selection function and no need for any search.</p>

<p>In clausal logic, the program is represented by the set of clauses:</p>

<p>
<math display="inline" id="SLD_resolution:22">
<semantics>
<mrow>
<mi>q</mi>
<mi mathvariant="normal">¬</mi>
<mi>p</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>q</ci>
<not></not>
<ci>p</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   q\neg p
  </annotation>
</semantics>
</math>
<math display="inline" id="SLD_resolution:23">
<semantics>
<mpadded width="+1.7pt">
<mi>p</mi>
</mpadded>
<annotation-xml encoding="MathML-Content">
<ci>p</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   p\,
  </annotation>
</semantics>
</math>
</p>

<p>and top-level goal is represented by the goal clause with a single negative literal:</p>

<p>
<math display="inline" id="SLD_resolution:24">
<semantics>
<mrow>
<mi mathvariant="normal">¬</mi>
<mi>q</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<not></not>
<ci>q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \neg q
  </annotation>
</semantics>
</math>
</p>

<p>The search space consists of the single refutation:</p>

<p>
<math display="inline" id="SLD_resolution:25">
<semantics>
<mrow>
<mrow>
<mi mathvariant="normal">¬</mi>
<mi>q</mi>
</mrow>
<mo>,</mo>
<mrow>
<mi mathvariant="normal">¬</mi>
<mi>p</mi>
</mrow>
<mo>,</mo>
<mi>𝑓𝑎𝑙𝑠𝑒</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<times></times>
<not></not>
<ci>q</ci>
</apply>
<apply>
<times></times>
<not></not>
<ci>p</ci>
</apply>
<ci>𝑓𝑎𝑙𝑠𝑒</ci>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   \neg q,\neg p,\mathit{false}
  </annotation>
</semantics>
</math>
</p>

<p>where 

<math display="inline" id="SLD_resolution:26">
<semantics>
<mpadded width="+1.7pt">
<mi>𝑓𝑎𝑙𝑠𝑒</mi>
</mpadded>
<annotation-xml encoding="MathML-Content">
<ci>𝑓𝑎𝑙𝑠𝑒</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathit{false}\,
  </annotation>
</semantics>
</math>

 represents the empty clause.</p>

<p>If the following clause were added to the program:</p>

<p><code> q :- r </code></p>

<p>then there would be an additional branch in the search space, whose leaf node <code>r</code> is a failure node. In Prolog, if this clause were added to the front of the original program, then Prolog would use the order in which the clauses are written to determine the order in which the branches of the search space are investigated. Prolog would try this new branch first, fail, and then backtrack to investigate the single branch of the original program and succeed.</p>

<p>If the clause</p>

<p><code> p :- p </code></p>

<p>were now added to the program, then the search tree would contain an infinite branch. If this clause were tried first, then Prolog would go into an infinite loop and not find the successful branch.</p>
<h2 id="sldnf">SLDNF</h2>

<p>SLDNF<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> is an extension of SLD resolution to deal with <a href="negation_as_failure" title="wikilink">negation as failure</a>. In SLDNF, goal clauses can contain negation as failure literals, say of the form 

<math display="inline" id="SLD_resolution:27">
<semantics>
<mrow>
<mi>n</mi>
<mi>o</mi>
<mi>t</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>p</mi>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>n</ci>
<ci>o</ci>
<ci>t</ci>
<ci>p</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   not(p)\,
  </annotation>
</semantics>
</math>

, which can be selected only if they contain no variables. When such a variable-free literal is selected, a subproof (or subcomputation) is attempted to determine whether there is an SLDNF refutation starting from the corresponding unnegated literal 

<math display="inline" id="SLD_resolution:28">
<semantics>
<mpadded width="+1.7pt">
<mi>p</mi>
</mpadded>
<annotation-xml encoding="MathML-Content">
<ci>p</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   p\,
  </annotation>
</semantics>
</math>

 as top clause. The selected subgoal 

<math display="inline" id="SLD_resolution:29">
<semantics>
<mrow>
<mi>n</mi>
<mi>o</mi>
<mi>t</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>p</mi>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>n</ci>
<ci>o</ci>
<ci>t</ci>
<ci>p</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   not(p)\,
  </annotation>
</semantics>
</math>

 succeeds if the subproof fails, and it fails if the subproof succeeds.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="John_Alan_Robinson" title="wikilink">John Alan Robinson</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<ul>
<li><a href="Jean_Gallier" title="wikilink">Jean Gallier</a>, <em><a href="https://cs.uwaterloo.ca/~david/cl/sld-gallier.pdf">SLD-Resolution and Logic Programming</a></em> chapter 9 of <em><a href="http://www.cis.upenn.edu/~jean/gbooks/logic.html">Logic for Computer Science: Foundations of Automatic Theorem Proving</a></em>, 2003 online revision (free to download), originally published by Wiley, 1986</li>
</ul>
<ul>
<li>John C. Shepherdson, <em>SLDNF-Resolution with Equality</em>, Journal of Automated Reasoning 8: 297-306, 1992; defines semantics with respect to which SLDNF-resolution with equality is sound and complete</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://foldoc.org/?SLD+resolution">1</a> Definition from the Free On-Line Dictionary of Computing</li>
</ul>

<p>"</p>

<p><a href="Category:Logic_programming" title="wikilink">Category:Logic programming</a> <a href="Category:Rules_of_inference" title="wikilink">Category:Rules of inference</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Robert Kowalski <a href="http://www.doc.ic.ac.uk/~rak/papers/IFIP%2074.pdf"><strong>Predicate Logic as a Programming Language</strong></a> Memo 70, Department of Artificial Intelligence, Edinburgh University. 1973. Also in Proceedings IFIP Congress, Stockholm, North Holland Publishing Co., 1974, pp. 569-574.<a href="#fnref1">↩</a></li>
<li id="fn2">Robert Kowalski and Donald Kuehner, <a href="http://www.doc.ic.ac.uk/~rak/papers/sl.pdf"><strong>Linear Resolution with Selection Function</strong></a> Artificial Intelligence, Vol. 2, 1971, pp. 227-60.<a href="#fnref2">↩</a></li>
<li id="fn3">Krzysztof Apt and Maarten van Emden, <a href="http://dl.acm.org/citation.cfm?doid=322326.322339">Contributions to the Theory of Logic Programming</a>, Journal of the Association for Computing Machinery. Vol, 1982 - portal.acm.org<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
