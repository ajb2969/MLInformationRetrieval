<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="666">Convolution (computer science)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Convolution (computer science)</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, specifically <a href="formal_language" title="wikilink">formal languages</a>, <strong>convolution</strong> (sometimes referred to as <strong>zip</strong>) is a function which maps a <a class="uri" href="tuple" title="wikilink">tuple</a> of <a href="sequence" title="wikilink">sequences</a> into a <a class="uri" href="sequence" title="wikilink">sequence</a> of <a href="tuple" title="wikilink">tuples</a>.</p>
<h2 id="example">Example</h2>

<p>Given the three words <em>and</em>, <em>fish</em> and <em>be</em> where |<em>and</em>| is 3, |<em>fish</em>| is 4 and |<em>be</em>| is 2. Let 

<math display="inline" id="Convolution_(computer_science):0">
 <semantics>
  <mi mathvariant="normal">ℓ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-ℓ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

 denote the longest word which is <em>fish</em>; 

<math display="inline" id="Convolution_(computer_science):1">
 <semantics>
  <mrow>
   <mi mathvariant="normal">ℓ</mi>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-ℓ</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell=4
  </annotation>
 </semantics>
</math>

. The convolution of <em>and</em>, <em>fish</em>, <em>be</em> is then 4 tuples of elements:</p>

<p>

<math display="block" id="Convolution_(computer_science):2">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>f</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>e</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>d</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi mathvariant="normal">#</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">#</mi>
    <mo>,</mo>
    <mi>h</mi>
    <mo>,</mo>
    <mi mathvariant="normal">#</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <vector>
     <ci>a</ci>
     <ci>f</ci>
     <ci>b</ci>
    </vector>
    <vector>
     <ci>n</ci>
     <ci>i</ci>
     <ci>e</ci>
    </vector>
    <vector>
     <ci>d</ci>
     <ci>s</ci>
     <ci>normal-#</ci>
    </vector>
    <vector>
     <ci>normal-#</ci>
     <ci>h</ci>
     <ci>normal-#</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,f,b)(n,i,e)(d,s,\#)(\#,h,\#)
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>#</em> is a symbol not in the original alphabet. In <a href="Haskell_(programming_language)" title="wikilink">Haskell</a> this truncates to shortest sequence 

<math display="inline" id="Convolution_(computer_science):3">
 <semantics>
  <munder accentunder="true">
   <mi mathvariant="normal">ℓ</mi>
   <mo>¯</mo>
  </munder>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>normal-ℓ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underline{\ell}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Convolution_(computer_science):4">
 <semantics>
  <mrow>
   <munder accentunder="true">
    <mi mathvariant="normal">ℓ</mi>
    <mo>¯</mo>
   </munder>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¯</ci>
     <ci>normal-ℓ</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underline{\ell}=2
  </annotation>
 </semantics>
</math>

:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zip3 <span class="st">"and"</span> <span class="st">"fish"</span> <span class="st">"be"</span>
<span class="co">-- [('a','f','b'),('n','i','e')]</span></code></pre></div>
<h2 id="definition">Definition</h2>

<p>Let Σ be an alphabet, # a symbol not in Σ.</p>

<p>Let <em>x</em><sub>1</sub><em>x</em><sub>2</sub>... <em>x</em><sub>|<em>x</em>|</sub>, <em>y</em><sub>1</sub><em>y</em><sub>2</sub>... <em>y</em><sub>|<em>y</em>|</sub>, <em>z</em><sub>1</sub><em>z</em><sub>2</sub>... <em>z</em><sub>|<em>z</em>|</sub>, ... be <em>n</em> <a href="word_(mathematics)" title="wikilink">words</a> (i.e. finite <a href="sequence" title="wikilink">sequences</a>) of elements of Σ. Let 

<math display="inline" id="Convolution_(computer_science):5">
 <semantics>
  <mi mathvariant="normal">ℓ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-ℓ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

 denote the length of the longest word, i.e. the maximum of |<em>x</em>|, |<em>y</em>|, |<em>z</em>|, ... .</p>

<p>The convolution of these words is a finite sequence of <em>n</em>-tuples of elements of (Σ ∪ {#}), i.e. an element of 

<math display="inline" id="Convolution_(computer_science):6">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">Σ</mi>
       <mo>∪</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mi mathvariant="normal">#</mi>
        <mo stretchy="false">}</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>n</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <union></union>
      <ci>normal-Σ</ci>
      <set>
       <ci>normal-#</ci>
      </set>
     </apply>
     <ci>n</ci>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((\Sigma\cup\{\#\})^{n})^{*}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Convolution_(computer_science):7">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal">…</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi mathvariant="normal">ℓ</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi mathvariant="normal">ℓ</mi>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
    </vector>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
    </vector>
    <ci>normal-…</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>normal-ℓ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>normal-ℓ</ci>
     </apply>
     <ci>normal-…</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},y_{1},\ldots)(x_{2},y_{2},\ldots)\ldots(x_{\ell},y_{\ell},\ldots)
  </annotation>
 </semantics>
</math>

,</p>

<p>where for any index <em>i</em> &gt; |<em>w</em>|, the ''w<sub>i''</sub> is #.</p>

<p>The convolution of <em>x, y, z, ...</em> is denoted conv( <em>x, y, z, ...</em>), zip( <em>x, y, z, ...</em>) or <em>x</em> ⋆ <em>y</em> ⋆ <em>z</em> ⋆ ...</p>

<p>The inverse to convolution is sometimes denoted unzip.</p>

<p>A variation of the convolution operation is defined by:</p>

<p>

<math display="block" id="Convolution_(computer_science):8">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal">…</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <munder accentunder="true">
      <mi mathvariant="normal">ℓ</mi>
      <mo>¯</mo>
     </munder>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <munder accentunder="true">
      <mi mathvariant="normal">ℓ</mi>
      <mo>¯</mo>
     </munder>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
    </vector>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
    </vector>
    <ci>normal-…</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>normal-ℓ</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>normal-ℓ</ci>
      </apply>
     </apply>
     <ci>normal-…</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1},y_{1},\ldots)(x_{2},y_{2},\ldots)\ldots(x_{\underline{\ell}},y_{%
\underline{\ell}},\ldots)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Convolution_(computer_science):9">
 <semantics>
  <munder accentunder="true">
   <mi mathvariant="normal">ℓ</mi>
   <mo>¯</mo>
  </munder>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>normal-ℓ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underline{\ell}
  </annotation>
 </semantics>
</math>

 is the <em>minimum</em> length of the input words. It avoids the use of an adjoined element 

<math display="inline" id="Convolution_(computer_science):10">
 <semantics>
  <mi mathvariant="normal">#</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-#</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \#
  </annotation>
 </semantics>
</math>

, but destroys information about elements of the input sequences beyond 

<math display="inline" id="Convolution_(computer_science):11">
 <semantics>
  <munder accentunder="true">
   <mi mathvariant="normal">ℓ</mi>
   <mo>¯</mo>
  </munder>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>normal-ℓ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underline{\ell}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="in-programming-languages">In programming languages</h2>

<p>Convolution <a href="Subroutine" title="wikilink">functions</a> are often available in <a href="programming_language" title="wikilink">programming languages</a>, often referred to as <code>zip</code>. In <a href="Lisp_(programming_language)" title="wikilink">Lisp</a>-dialects one can simply <code>[[Map (higher-order function)|map]]</code> the desired function over the desired lists, <code>map</code> is <a href="Variadic_function" title="wikilink">variadic</a> in Lisp so it can take an arbitrary amount of lists as argument. An example from <a class="uri" href="Clojure" title="wikilink">Clojure</a>:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<div class="sourceCode"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span class="co">;; `nums' contains an infinite list of numbers (0 1 2 3 ...)</span>
(<span class="kw">def</span><span class="fu"> nums </span>(<span class="kw">range</span>))
(<span class="kw">def</span><span class="fu"> tens </span>[<span class="dv">10</span> <span class="dv">20</span> <span class="dv">30</span>])
(<span class="kw">def</span><span class="fu"> firstname </span><span class="st">"Alice"</span>)

<span class="co">;; To convolve (0 1 2 3 ...) and [10 20 30] into a vector, invoke `map vector' on them; same with list</span>
(<span class="kw">map</span> <span class="kw">vector</span> nums tens)           <span class="co">; ⇒ ([1 10] [2 20] [3 30])</span>
(<span class="kw">map</span> <span class="kw">list</span> nums tens)             <span class="co">; ⇒ ((1 10) (2 20) (3 30))</span>
(<span class="kw">map</span> <span class="kw">str</span> nums tens)              <span class="co">; ⇒ ("110" "220" "330")</span>

<span class="co">;; `map' truncates to the shortest sequence; note missing \c and \e from "Alice"</span>
(<span class="kw">map</span> <span class="kw">vector</span> nums tens firstname) <span class="co">; ⇒ ([1 10 \A] [2 20 \l] [3 30 \i])</span>
(<span class="kw">map</span> <span class="kw">str</span> nums tens firstname)    <span class="co">; ⇒ ("110A" "220l" "330i")</span>

<span class="co">;; To unzip, apply `map vector' or `map list'</span>
(<span class="kw">apply</span> <span class="kw">map</span> <span class="kw">list</span> (<span class="kw">map</span> <span class="kw">vector</span> nums tens firstname))
<span class="co">;; ⇒ ((0 1 2) (10 20 30) (\A \l \i))</span></code></pre></div>

<p>In <a href="Common_Lisp" title="wikilink">Common Lisp</a>:</p>
<pre class="lisp"><code>(defparameter nums '(1 2 3))
(defparameter tens '(10 20 30))
(defparameter firstname "Alice")

(mapcar #'list nums tens)
;; ⇒ ((1 10) (2 20) (3 30))

(mapcar #'list nums tens (coerce firstname 'list))
;; ⇒ ((1 10 #\A) (2 20 #\l) (3 30 #\i)) — truncates on shortest list

;; Unzips
(apply #'mapcar #'list (mapcar #'list nums tens (coerce firstname 'list)))
;; ⇒ ((1 2 3) (10 20 30) (#\A #\l #\i))</code></pre>

<p>Languages such as <a href="Python_(programming_language)" title="wikilink">Python</a> provide a <code>zip()</code> function, older version (Python 2.*) allowed mapping <code>None</code> over lists to get a similar effect.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <code>zip()</code> in conjunction with the <code>*</code> operator unzips a list:<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">nums <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]
tens <span class="op">=</span> [<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>]
firstname <span class="op">=</span> <span class="st">'Alice'</span>

zipped <span class="op">=</span> <span class="bu">zip</span>(nums, tens)
zipped
<span class="co"># ⇒ [(1, 10), (2, 20), (3, 30)] — zip</span>

<span class="bu">zip</span>(<span class="op">*</span>zipped)
<span class="co"># ⇒ [(1, 2, 3), (10, 20, 30)] — unzip</span>

zipped2 <span class="op">=</span> <span class="bu">zip</span>(nums, tens, <span class="bu">list</span>(firstname))
zipped2
<span class="co"># ⇒ [(1, 10, 'A'), (2, 20, 'l'), (3, 30, 'i')] — zip, truncates on shortest</span>
<span class="bu">zip</span>(<span class="op">*</span>zipped2)
<span class="co"># ⇒ [(1, 2, 3), (10, 20, 30), ('A', 'l', 'i')] — unzip</span>

<span class="co"># mapping with `None' doesn't truncate; deprecated in Python 3.*</span>
<span class="bu">map</span>(<span class="va">None</span>,nums, tens, <span class="bu">list</span>(firstname))
<span class="co"># ⇒ [(1, 10, 'A'), (2, 20, 'l'), (3, 30, 'i'), (None, None, 'c'), (None, None, 'e')]</span></code></pre></div>

<p><a href="Haskell_(programming_language)" title="wikilink">Haskell</a> has a method of convolving sequences but requires a specific function for each <a class="uri" href="arity" title="wikilink">arity</a> (<code>zip</code> for two sequences, <code>zip3</code> for three etc.),<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> similarly the functions <code>unzip</code> and <code>unzip3</code> are available for unzipping:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- nums contains an infinite list of numbers [1, 2, 3,...] </span>
nums <span class="fu">=</span> [<span class="dv">1</span><span class="fu">..</span>]
tens <span class="fu">=</span> [<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>]
firstname <span class="fu">=</span> <span class="st">"Alice"</span>

zip nums tens
<span class="co">-- ⇒ [(1,10),(2,20),(3,30)] — zip, truncates infinite list</span>
unzip <span class="fu">$</span> zip nums tens
<span class="co">-- ⇒ ([1,2,3],[10,20,30]) — unzip</span>

zip3 nums tens firstname
<span class="co">-- ⇒ [(1,10,'A'),(2,20,'l'),(3,30,'i')] — zip, truncates</span>
unzip3 <span class="fu">$</span> zip3 nums tens firstname
<span class="co">-- ⇒ ([1,2,3],[10,20,30],"Ali") — unzip</span></code></pre></div>
<h2 id="language-comparison">Language comparison</h2>

<p>List of languages by support of convolution:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Zip in various languages</p></td>
<td style="text-align: left;">
<p>Language</p></td>
<td style="text-align: left;">
<p>Zip</p></td>
<td style="text-align: left;">
<p>Zip 3 lists</p></td>
<td style="text-align: left;">
<p>Zip <em>n</em> lists</p></td>
<td style="text-align: left;">
<p>Notes</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="Clojure" title="wikilink">Clojure</a></p></td>
<td style="text-align: left;">
<p><code>(map list ''list1'' ''list2'')<br/> (map vector ''list1'' ''list2'') </code></p></td>
<td style="text-align: left;">
<p><code>(map vector ''list1'' ''list2'' ''list3'')<br/> (map vector ''list1'' ''list2'' ''list3'') </code></p></td>
<td style="text-align: left;">
<p><code>(map list ''list1'' … ''listn'')<br/> (map vector ''list1'' … ''listn'') </code></p></td>
<td style="text-align: left;">
<p>Stops after the length of the shortest list.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Common_Lisp" title="wikilink">Common Lisp</a></p></td>
<td style="text-align: left;">
<p><code>(mapcar #'list ''list1'' ''list2'')</code></p></td>
<td style="text-align: left;">
<p><code>(mapcar #'list ''list1'' ''list2'' ''list3'')</code></p></td>
<td style="text-align: left;">
<p><code>(mapcar #'list ''list1'' ...  ''listn'')</code></p></td>
<td style="text-align: left;">
<p>Stops after the length of the shortest list.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="D_(programming_language)" title="wikilink">D</a></p></td>
<td style="text-align: left;">
<p><code>zip(''range1'',''range2'')<br/> ''range1''.zip(''range2'')</code></p></td>
<td style="text-align: left;">
<p><code>zip(''range1'',''range2'',''range3'')<br/> ''range1''.zip(range2,range3)</code></p></td>
<td style="text-align: left;">
<p><code>zip(''range1'',…,''rangeN'')<br/> ''range1''.zip(…,rangeN)</code></p></td>
<td style="text-align: left;">
<p>The stopping policy defaults to shortest and can be optionally provided as shortest, longest, or requiring the same length.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The second form is an example of <a href="Uniform_Function_Call_Syntax" title="wikilink">UFCS</a>.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="F_Sharp_(programming_language)" title="wikilink">F#</a></p></td>
<td style="text-align: left;">
<p><code>List.zip ''list1'' ''list2''<br/>Seq.zip ''source1'' ''source2''<br/>Array.zip ''array1'' ''array2''</code></p></td>
<td style="text-align: left;">
<p><code>List.zip3 ''list1'' ''list2'' ''list3''<br/>Seq.zip3 ''source1'' ''source2'' ''source3''<br/>Array.zip3 ''array1'' ''array2'' ''array3''</code></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Haskell_(programming_language)" title="wikilink">Haskell</a></p></td>
<td style="text-align: left;">
<p><code>zip ''list1'' ''list2''</code></p></td>
<td style="text-align: left;">
<p><code>zip3 ''list1'' ''list2'' ''list3''</code></p></td>
<td style="text-align: left;">
<p><code>zip''n'' ''list1'' … ''listn''</code></p></td>
<td style="text-align: left;">
<p><code>zipn</code> for <em>n</em> &gt; 3 is available in the module <em>Data.List</em>. Stops after the shortest list ends.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Python_(programming_language)" title="wikilink">Python</a></p></td>
<td style="text-align: left;">
<p><code>zip(''list1'', ''list2'')</code></p></td>
<td style="text-align: left;">
<p><code>zip(''list1'', ''list2'', ''list3'')</code></p></td>
<td style="text-align: left;">
<p><code>zip(''list1'', …, ''listn'')</code></p></td>
<td style="text-align: left;">
<p><code>''zip()''</code> and <code>''map()''</code> (3.x) stops after the shortest list ends, whereas <code>''map()''</code> (2.x) and <code>''itertools.zip_longest()''</code> (3.x) extends the shorter lists with <code>''None''</code> items</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Ruby_(programming_language)" title="wikilink">Ruby</a></p></td>
<td style="text-align: left;">
<p><code>''list1''.zip(''list2'')</code></p></td>
<td style="text-align: left;">
<p><code>''list1''.zip(''list2'', ''list3'')</code></p></td>
<td style="text-align: left;">
<p><code>''list1''.zip(''list1'', .., ''listn'')</code></p></td>
<td style="text-align: left;">
<p>When the list being executed upon (list1) is shorter than the lists being zipped the resulting list is the length of list1. If list1 is longer nil values are used to fill the missing values<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Unzip in various languages</p></td>
<td style="text-align: left;">
<p>Language</p></td>
<td style="text-align: left;">
<p>Unzip</p></td>
<td style="text-align: left;">
<p>Unzip 3 tuples</p></td>
<td style="text-align: left;">
<p>Unzip <em>n</em> tuples</p></td>
<td style="text-align: left;">
<p>Notes</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="Clojure" title="wikilink">Clojure</a></p></td>
<td style="text-align: left;">
<p><code>(apply map vector ''convlist'')</code></p></td>
<td style="text-align: left;">
<p><code>(apply map vector ''convlist'')</code></p></td>
<td style="text-align: left;">
<p><code>(apply map vector ''convlist'')</code></p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Common_Lisp" title="wikilink">Common Lisp</a></p></td>
<td style="text-align: left;">
<p><code>(apply #'mapcar #'list ''convlist'')</code></p></td>
<td style="text-align: left;">
<p><code>(apply #'mapcar #'list ''convlist'')</code></p></td>
<td style="text-align: left;">
<p><code>(apply #'mapcar #'list ''convlist'')</code></p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="F_Sharp_(programming_language)" title="wikilink">F#</a></p></td>
<td style="text-align: left;">
<p><code>List.unzip ''list1'' ''list2''<br/>Seq.unzip ''source1'' ''source2''<br/>Array.unzip ''array1'' ''array2''</code></p></td>
<td style="text-align: left;">
<p><code>List.unzip3 ''list1'' ''list2'' ''list3''<br/>Seq.unzip3 ''source1'' ''source2'' ''source3''<br/>Array.unzip3 ''array1'' ''array2'' ''array3''</code></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Haskell_(programming_language)" title="wikilink">Haskell</a></p></td>
<td style="text-align: left;">
<p><code>unzip ''convlist''</code></p></td>
<td style="text-align: left;">
<p><code>unzip3 ''convlist''</code></p></td>
<td style="text-align: left;">
<p><code>unzip''n'' ''convlist''</code></p></td>
<td style="text-align: left;">
<p><code>unzipn</code> for <em>n</em> &gt; 3 is available in the module <code>''Data.List''.</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Python_(programming_language)" title="wikilink">Python</a></p></td>
<td style="text-align: left;">
<p><code>zip(*''convvlist'')</code></p></td>
<td style="text-align: left;">
<p><code>zip(*''convvlist'')</code></p></td>
<td style="text-align: left;">
<p><code>zip(*''convvlist'')</code></p></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Map_(higher-order_function)" title="wikilink">Map (higher-order function)</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a> <a href="Category:Articles_with_example_Haskell_code" title="wikilink">Category:Articles with example Haskell code</a> <a href="Category:Articles_with_example_Lisp_code" title="wikilink">Category:Articles with example Lisp code</a> <a href="Category:Articles_with_example_Clojure_code" title="wikilink">Category:Articles with example Clojure code</a> <a href="Category:Articles_with_example_Python_code" title="wikilink">Category:Articles with example Python code</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://clojuredocs.org/clojure_core/1.2.0/clojure.core/map">map</a> from ClojureDocs<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="https://docs.python.org/library/functions.html#map">map(function, iterable, ...)</a> from section Built-in Functions from Python v2.7.2 documentation<a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:zip">zip :: [a] -&gt; [b] -&gt; [(a, b)]</a> from Prelude, Basic libraries<a href="#fnref4">↩</a></li>
<li id="fn5"><a class="uri" href="http://dlang.org/phobos/std_range.html#zip">http://dlang.org/phobos/std_range.html#zip</a><a href="#fnref5">↩</a></li>
<li id="fn6"><a class="uri" href="http://www.ruby-doc.org/core-2.0/Array.html#method-i-zip">http://www.ruby-doc.org/core-2.0/Array.html#method-i-zip</a><a href="#fnref6">↩</a></li>
</ol>
</section>
</body>

