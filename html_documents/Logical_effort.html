<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="628">Logical effort</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Logical effort</h1>
<hr/>

<p>The method of <strong>logical effort</strong>, a term coined by <a href="Ivan_Sutherland" title="wikilink">Ivan Sutherland</a> and <a href="Bob_Sproull" title="wikilink">Bob Sproull</a> in 1991, is a straightforward technique used to <a href="delay_calculation" title="wikilink">estimate delay</a> in a <a class="uri" href="CMOS" title="wikilink">CMOS</a> circuit. Used properly, it can aid in selection of gates for a given function (including the number of stages necessary) and sizing gates to achieve the minimum delay possible for a circuit.</p>
<h2 id="derivation-of-delay-in-a-logic-gate">Derivation of delay in a logic gate</h2>

<p>Delay is expressed in terms of a basic delay unit, <em>τ</em> = <em>3RC</em>, the delay of an inverter driving an identical inverter with no parasitic capacitance; the unitless number associated with this is known as the <strong>normalized delay</strong>. (Some authors prefer define the basic delay unit as the <a href="fanout_of_4" title="wikilink">fanout of 4</a> delay—the delay of one inverter driving 4 identical inverters). The absolute delay is then simply defined as the product of the normalized delay of the gate, <em>d</em>, and <em>τ</em>:</p>

<p>

<math display="block" id="Logical_effort:0">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
     <mi>s</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>d</mi>
    <mo>⋅</mo>
    <mi>τ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>d</ci>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{abs}=d\cdot\tau
  </annotation>
 </semantics>
</math>

</p>

<p>In a typical 600-nm process <em>τ</em> is about 50 ps. For a 250-nm process, <em>τ</em> is about 20 ps. In modern 45 nm processes the delay is approximately 4 to 5 ps.</p>

<p>The normalized delay in a logic gate can be expressed as a summation of two primary terms: normalized <strong><a href="parasitic_delay" title="wikilink">parasitic delay</a></strong>, <em>p</em> (which is an intrinsic delay of the gate and can be found by considering the gate driving no load), and <strong><a href="stage_effort" title="wikilink">stage effort</a></strong>, <em>f</em> (which is dependent on the load as described below). Consequently,</p>

<p>

<math display="block" id="Logical_effort:1">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mo>+</mo>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>d</ci>
    <apply>
     <plus></plus>
     <ci>f</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=f+p
  </annotation>
 </semantics>
</math>

</p>

<p>The stage effort is divided into two components: a <strong>logical effort</strong>, <em>g</em>, which is the ratio of the input capacitance of a given gate to that of an inverter capable of delivering the same output current (and hence is a constant for a particular class of gate and can be described as capturing the intrinsic properties of the gate), and an <strong>electrical effort</strong>, <em>h</em>, which is the ratio of the input capacitance of the load to that of the gate. Note that "logical effort" does not take the load into account and hence we have the term "electrical effort" which takes the load into account.The stage effort is then simply:</p>

<p>

<math display="block" id="Logical_effort:2">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mi>h</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>f</ci>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=gh
  </annotation>
 </semantics>
</math>

</p>

<p>Combining these equations yields a basic equation that models the normalized delay through a single logic gate:</p>

<p>

<math display="block" id="Logical_effort:3">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>g</mi>
     <mi>h</mi>
    </mrow>
    <mo>+</mo>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>d</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>h</ci>
     </apply>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=gh+p
  </annotation>
 </semantics>
</math>

</p>
<h2 id="procedure-for-calculating-the-logical-effort-of-a-single-stage">Procedure for calculating the logical effort of a single stage</h2>

<p>CMOS inverters along the critical path are typically designed with a gamma equal to 2. In other words, the pFET of the inverter is designed with twice the width (and therefore twice the capacitance) as the nFET of the inverter, in order to get roughly the same <a href="Power_MOSFET#P-substrate_power_MOSFET" title="wikilink">pFET resistance</a> as nFET resistance, in order to get roughly equal pull-up current and pull-down current.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Choose sizes for all transistors such that the output drive of the gate is equal to the output drive of an inverter built from a size-2 PMOS and a size-1 NMOS.</p>

<p>The output drive of a gate is equal to the minimum – over all possible combinations of inputs – of the output drive of the gate for that input.</p>

<p>The output drive of a gate for a given input is equal to the drive at its output node.</p>

<p>The drive at a node is equal to the sum of the drives of all transistors which are enabled and whose source or drain is in contact with the node in question. A PMOS transistor is enabled when its gate voltage is 0. An NMOS transistor is enabled when its gate voltage is 1.</p>

<p>Once sizes have been chosen, the logical effort of the output of the gate is the sum of the widths of all transistors whose source or drain is in contact with the output node. The logical effort of each input to the gate is the sum of the widths of all transistors whose gate is in contact with that input node.</p>

<p>The logical effort of the entire gate is the ratio of its output logical effort to the sum of its input logical efforts.</p>
<h2 id="multistage-logic-networks">Multistage logic networks</h2>

<p>A major advantage of the method of logical effort is that it can quickly be extended to circuits composed of multiple stages. The total normalised path delay <em>D</em> can be expressed in terms of an overall <strong>path effort</strong>, <em>F</em>, and the <strong>path parasitic delay</strong> <em>P</em> (which is the sum of the individual parasitic delays):</p>

<p>

<math display="block" id="Logical_effort:4">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>N</mi>
     <msup>
      <mi>F</mi>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mi>N</mi>
      </mrow>
     </msup>
    </mrow>
    <mo>+</mo>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>N</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>F</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=NF^{1/N}+P
  </annotation>
 </semantics>
</math>

</p>

<p>The path effort is expressed in terms of the <strong>path logical effort</strong> <em>G</em> (the product of the individual logical efforts of the gates), and the <strong>path electrical effort</strong> <em>H</em> (the ratio of the load of the path to its input capacitance).</p>

<p>For paths where each gate drives only one additional gate (i.e. the next gate in the path),</p>

<p>

<math display="block" id="Logical_effort:5">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <mrow>
    <mi>G</mi>
    <mi>H</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>F</ci>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=GH
  </annotation>
 </semantics>
</math>

</p>

<p>However, for circuits that branch, an additional <strong>branching effort</strong>, <em>b</em>, needs to be taken into account; it is the ratio of total capacitance being driven by the gate to the capacitance on the path of interest:</p>

<p>

<math display="block" id="Logical_effort:6">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>C</mi>
      <mrow>
       <mi>o</mi>
       <mi>n</mi>
       <mi>p</mi>
       <mi>a</mi>
       <mi>t</mi>
       <mi>h</mi>
      </mrow>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>C</mi>
      <mrow>
       <mi>o</mi>
       <mi>f</mi>
       <mi>f</mi>
       <mi>p</mi>
       <mi>a</mi>
       <mi>t</mi>
       <mi>h</mi>
      </mrow>
     </msub>
    </mrow>
    <msub>
     <mi>C</mi>
     <mrow>
      <mi>o</mi>
      <mi>n</mi>
      <mi>p</mi>
      <mi>a</mi>
      <mi>t</mi>
      <mi>h</mi>
     </mrow>
    </msub>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>b</ci>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <apply>
        <times></times>
        <ci>o</ci>
        <ci>n</ci>
        <ci>p</ci>
        <ci>a</ci>
        <ci>t</ci>
        <ci>h</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <apply>
        <times></times>
        <ci>o</ci>
        <ci>f</ci>
        <ci>f</ci>
        <ci>p</ci>
        <ci>a</ci>
        <ci>t</ci>
        <ci>h</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>o</ci>
       <ci>n</ci>
       <ci>p</ci>
       <ci>a</ci>
       <ci>t</ci>
       <ci>h</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b=\frac{C_{onpath}+C_{offpath}}{C_{onpath}}
  </annotation>
 </semantics>
</math>

</p>

<p>This yields a <strong>path branching effort</strong> <em>B</em> which is the product of the individual stage branching efforts; the total path effort is then</p>

<p>

<math display="block" id="Logical_effort:7">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <mrow>
    <mi>G</mi>
    <mi>H</mi>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>F</ci>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>H</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=GHB
  </annotation>
 </semantics>
</math>

</p>

<p>It can be seen that <em>b</em> = 1 for gates driving only one additional gate, fixing <em>B</em> = 1 and causing the formula to reduce to the earlier non-branching version.</p>
<h3 id="minimum-delay">Minimum delay</h3>

<p>It can be shown that in multistage logic networks, the minimum possible delay along a particular path can be achieved by designing the circuit such that the stage logical efforts are equal. For a given combination of gates and a known load, <em>B</em>, <em>G</em>, and <em>H</em> are all fixed causing <em>F</em> to be fixed; hence the individual gates should be sized such that the individual stage efforts are</p>

<p>

<math display="block" id="Logical_effort:8">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <msup>
    <mi>F</mi>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>N</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>f</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>F</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=F^{1/N}
  </annotation>
 </semantics>
</math>

 where <em>N</em> is the number of stages in the circuit.</p>
<h2 id="examples">Examples</h2>
<h3 id="delay-in-an-inverter">Delay in an inverter</h3>
<figure><b>(Figure)</b>
<figcaption>A CMOS inverter circuit.</figcaption>
</figure>

<p>By definition, the logical effort <em>g</em> of an inverter is 1. If the inverter drives an equivalent inverter, the electrical effort <em>h</em> is also 1.</p>

<p>The parasitic delay <em>p</em> of an inverter is also 1 (this can be found by considering the <a href="Elmore_delay" title="wikilink">Elmore delay</a> model of the inverter).</p>

<p>Therefore the total normalised delay of an inverter driving an equivalent inverter is</p>

<p>

<math display="block" id="Logical_effort:9">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>g</mi>
     <mi>h</mi>
    </mrow>
    <mo>+</mo>
    <mi>p</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>d</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>g</ci>
       <ci>h</ci>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=gh+p=(1)(1)+1=2
  </annotation>
 </semantics>
</math>

</p>
<h3 id="delay-in-nand-and-nor-gates">Delay in NAND and NOR gates</h3>

<p>The logical effort of a two-input NAND gate is calculated to be <em>g</em> = 4/3 because a NAND gate with input capacitance 4 can drive the same current as the inverter can, with input capacitance 3. Similarly, the logical effort of a two-input NOR gate can be found to be <em>g</em> = 5/3. Due to the lower logical effort, NAND gates are typically preferred to NOR gates.</p>

<p>For larger gates, the logical effort is as follows:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Logical effort for inputs of static CMOS gates, with gamma = 2</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Number of Inputs</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Gate type</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>2</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Inverter</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>N/A</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>NAND</p></td>
<td style="text-align: left;">
<p>N/A</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Logical_effort:10">
 <semantics>
  <mfrac>
   <mn>4</mn>
   <mn>3</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">4</cn>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{4}{3}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>NOR</p></td>
<td style="text-align: left;">
<p>N/A</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Logical_effort:11">
 <semantics>
  <mfrac>
   <mn>5</mn>
   <mn>3</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">5</cn>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{5}{3}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>The normalised parasitic delay of NAND and NOR gates is equal to the number of inputs.</p>

<p>Therefore, the normalised delay of a two-input NAND gate driving an identical copy of itself (such that the electrical effort is 1) is</p>

<p>

<math display="block" id="Logical_effort:12">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>g</mi>
     <mi>h</mi>
    </mrow>
    <mo>+</mo>
    <mi>p</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>4</mn>
       <mo>/</mo>
       <mn>3</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>10</mn>
    <mo>/</mo>
    <mn>3</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>d</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>g</ci>
       <ci>h</ci>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">4</cn>
        <cn type="integer">3</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">10</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=gh+p=(4/3)(1)+2=10/3
  </annotation>
 </semantics>
</math>

</p>

<p>and for a two-input NOR gate, the delay is</p>

<p>

<math display="block" id="Logical_effort:13">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>g</mi>
     <mi>h</mi>
    </mrow>
    <mo>+</mo>
    <mi>p</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>5</mn>
       <mo>/</mo>
       <mn>3</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>13</mn>
    <mo>/</mo>
    <mn>3</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>d</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>g</ci>
       <ci>h</ci>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">5</cn>
        <cn type="integer">3</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">13</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=gh+p=(5/3)(2)+1=13/3
  </annotation>
 </semantics>
</math>

</p>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Digital_electronics" title="wikilink">Category:Digital electronics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
