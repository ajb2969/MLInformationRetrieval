<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1938">Color quantization</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Color quantization</h1>
<hr/>

<p>{|style="float:right" | |- | |- | |} In <a href="computer_graphics" title="wikilink">computer graphics</a>, <strong>color quantization</strong> or <strong>color image quantization</strong> is a process that reduces the number of distinct colors used in an image, usually with the intention that the new image should be as visually similar as possible to the original image. Computer algorithms to perform color quantization on bitmaps have been studied since the 1970s. Color quantization is critical for displaying images with many colors on devices that can only display a limited number of colors, usually due to memory limitations, and enables efficient compression of certain types of images.</p>

<p>The name "color quantization" is primarily used in computer graphics research literature; in applications, terms such as <em>optimized palette generation</em>, <em>optimal palette generation</em>, or <em>decreasing color depth</em> are used. Some of these are misleading, as the palettes generated by standard algorithms are not necessarily the best possible.</p>
<h2 id="algorithms">Algorithms</h2>

<p>Most standard techniques treat color quantization as a problem of clustering points in three-dimensional space, where the points represent colors found in the original image and the three axes represent the three color channels. Almost any three-dimensional <a href="data_clustering" title="wikilink">clustering algorithm</a> can be applied to color quantization, and vice versa. After the clusters are located, typically the points in each cluster are averaged to obtain the representative color that all colors in that cluster are mapped to. The three color channels are usually <a href="RGB_color_model" title="wikilink">red, green, and blue</a>, but another popular choice is the <a href="Lab_color_space" title="wikilink">Lab color space</a>, in which <a href="Euclidean_distance" title="wikilink">Euclidean distance</a> is more consistent with perceptual difference.</p>

<p>The most popular algorithm by far for color quantization, invented by Paul Heckbert in 1980, is the <a href="median_cut" title="wikilink">median cut</a> algorithm. Many variations on this scheme are in use. Before this time, most color quantization was done using the <em>population algorithm</em> or <em>population method</em>, which essentially constructs a histogram of equal-sized ranges and assigns colors to the ranges containing the most points. A more modern popular method is clustering using <a href="octree" title="wikilink">octrees</a>, first conceived by Gervautz and Purgathofer and improved by <a href="Xerox_PARC" title="wikilink">Xerox PARC</a> researcher <a href="Dan_Bloomberg" title="wikilink">Dan Bloomberg</a>.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>A small photograph that has had its blue channel removed. This means all of its pixel colors lie in a two-dimensional plane in the color cube.</figcaption>
</figure></td>
<td style="text-align: left;">
<p>|</p></td>
</tr>
</tbody>
</table>

<p>If the palette is fixed, as is often the case in real-time color quantization systems such as those used in operating systems, color quantization is usually done using the "straight-line distance" or "nearest color" algorithm, which simply takes each color in the original image and finds the closest palette entry, where distance is determined by the distance between the two corresponding points in three-dimensional space. In other words, if the colors are 

<math display="inline" id="Color_quantization:0">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>r</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>g</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>b</mi>
    <mn>1</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <cn type="integer">1</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (r_{1},g_{1},b_{1})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Color_quantization:1">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>r</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>g</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>b</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <cn type="integer">2</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (r_{2},g_{2},b_{2})
  </annotation>
 </semantics>
</math>

, we want to minimize the <a href="Euclidean_distance" title="wikilink">Euclidean distance</a>:</p>

<p>

<math display="block" id="Color_quantization:2">
 <semantics>
  <mrow>
   <msqrt>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>r</mi>
         <mn>1</mn>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>r</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>g</mi>
         <mn>1</mn>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>g</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>b</mi>
         <mn>1</mn>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>b</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </msqrt>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{(r_{1}-r_{2})^{2}+(g_{1}-g_{2})^{2}+(b_{1}-b_{2})^{2}}.
  </annotation>
 </semantics>
</math>

</p>

<p>This effectively decomposes the color cube into a <a href="Voronoi_diagram" title="wikilink">Voronoi diagram</a>, where the palette entries are the points and a cell contains all colors mapping to a single palette entry. There are efficient algorithms from <a href="computational_geometry" title="wikilink">computational geometry</a> for computing Voronoi diagrams and determining which region a given point falls in; in practice, indexed palettes are so small that these are usually overkill.</p>

<p> Color quantization is frequently combined with <a href="dither" title="wikilink">dithering</a>, which can eliminate unpleasant artifacts such as banding that appear when quantizing smooth gradients and give the appearance of a larger number of colors. Some modern schemes for color quantization attempt to combine palette selection with dithering in one stage, rather than perform them independently.</p>

<p>A number of other much less frequently used methods have been invented that use entirely different approaches. The Local K-means algorithm, conceived by Oleg Verevka in 1995, is designed for use in windowing systems where a core set of "reserved colors" is fixed for use by the system and many images with different color schemes might be displayed simultaneously. It is a post-clustering scheme that makes an initial guess at the palette and then iteratively refines it.</p>

<p>The high quality but slow <em>NeuQuant</em> algorithm reduces images to 256 colors by training a <a href="self-organizing_map" title="wikilink">Kohonen neural network</a> "which self-organises through learning to match the distribution of colours in an input image. Taking the position in RGB-space of each neuron gives a high-quality colour map in which adjacent colours are similar." <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It is particularly advantageous for images with gradients.</p>

<p>Finally, one of the most promising new methods is <em>spatial color quantization</em>, conceived by Puzicha, Held, Ketterer, Buhmann, and Fellner of the <a href="University_of_Bonn" title="wikilink">University of Bonn</a>, which combines dithering with palette generation and a simplified model of human perception to produce visually impressive results even for very small numbers of colors. It does not treat palette selection strictly as a clustering problem, in that the colors of nearby pixels in the original image also affect the color of a pixel. See <a href="http://www.cs.berkeley.edu/~dcoetzee/downloads/scolorq/#sampleimages">sample images</a>.</p>
<h2 id="history-and-applications">History and applications</h2>

<p>In the early days of PCs, it was common for video adapters to support only 2, 4, 16, or (eventually) 256 colors due to video memory limitations; they preferred to dedicate the video memory to having more pixels (higher resolution) rather than more colors. Color quantization helped to justify this tradeoff by making it possible to display many high color images in 16- and 256-color modes with limited visual degradation. Many operating systems automatically perform quantization and dithering when viewing high color images in a 256 color video mode, which was important when video devices limited to 256 color modes were dominant. Modern computers can now display millions of colors at once, far more than can be distinguished by the human eye, limiting this application primarily to mobile devices and legacy hardware.</p>

<p>Nowadays, color quantization is mainly used in <a class="uri" href="GIF" title="wikilink">GIF</a> and <a href="Portable_Network_Graphics" title="wikilink">PNG</a> images. GIF, for a long time the most popular lossless and animated bitmap format on the <a href="World_Wide_Web" title="wikilink">World Wide Web</a>, only supports up to 256 colors, necessitating quantization for many images. Some early web browsers constrained images to use a specific palette known as the <a href="web_colors" title="wikilink">web colors</a>, leading to severe degradation in quality compared to optimized palettes. PNG images support 24-bit color, but can often be made much smaller in filesize without much visual degradation by application of color quantization, since PNG files use fewer bits per pixel for palettized images.</p>

<p>The infinite number of colors available through the lens of a camera is impossible to display on a computer screen; thus converting any photograph to a digital representation necessarily involves some quantization. Practically speaking, 24-bit color is sufficiently rich to represent almost all colors perceivable by humans with sufficiently small error as to be visually identical (if presented faithfully), within the available <a href="color_space" title="wikilink">color space</a> . However, the digitization of color, either in a camera detector or on a screen, necessarily limits the available color space. Consequently there are many colors that may be impossible to reproduce, regardless of how many bits are used to represent the color. For example, it is impossible in typical RGB color spaces (common on computer monitors) to reproduce the full range of green colors that the human eye is capable of perceiving.</p>

<p>With the few colors available on early computers, different quantization algorithms produced very different-looking output images. As a result, a lot of time was spent on writing sophisticated algorithms to be more lifelike.</p>
<h3 id="editor-support">Editor support</h3>

<p>Many <a href="bitmap_graphics_editor" title="wikilink">bitmap graphics editors</a> contain built-in support for color quantization, and will automatically perform it when converting an image with many colors to an image format with fewer colors. Most of these implementations allow the user to set exactly the number of desired colors. Examples of such support include:</p>
<ul>
<li>Photoshop's <em>Mode→Indexed Color</em> function supplies a number of quantization algorithms ranging from the fixed Windows system and Web palettes to the proprietary Local and Global algorithms for generating palettes suited to a particular image or images.</li>
<li>Paint Shop Pro, in its <em>Colors→Decrease Color Depth</em> dialog, supplies three standard color quantization algorithms: median cut, octree, and the fixed standard "web safe" palette.</li>
<li>The GIMP's <em>Generate Optimal Palette with 256 Colours</em> option is known to use the median cut algorithm. There has been some discussion in the developer community of adding support for spatial color quantization.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></li>
</ul>

<p>Color quantization is also used to create <a class="uri" href="posterization" title="wikilink">posterization</a> effects, although posterization has the slightly different goal of minimizing the number of colors used within the same color space, and typically uses a fixed palette.</p>

<p>Some <a href="vector_graphics_editor" title="wikilink">vector graphics editors</a> also utilize color quantization, especially for <a class="uri" href="raster-to-vector" title="wikilink">raster-to-vector</a> techniques that create tracings of bitmap images with the help of <a href="edge_detection" title="wikilink">edge detection</a>.</p>
<ul>
<li>Inkscape's <em>Path→Trace Bitmap: Multiple Scans: Color</em> function uses octree quantization to create color traces.<ref name="Inkscape"></ref></li>
</ul>

<p></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Indexed_color" title="wikilink">Indexed color</a></li>
<li><a href="Palette_(computing)" title="wikilink">Palette (computing)</a></li>
<li><a href="List_of_software_palettes" title="wikilink">List of software palettes</a> — <a href="List_of_software_palettes#Adaptive_palettes" title="wikilink">Adaptive palettes</a> section.</li>
<li><a class="uri" href="Dithering" title="wikilink">Dithering</a></li>
<li><a href="Quantization_(image_processing)" title="wikilink">Quantization (image processing)</a></li>
<li><a href="Image_segmentation" title="wikilink">Image segmentation</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Paul S. Heckbert. <a href="http://web.archive.org/web/20050606233131/http://citeseer.ist.psu.edu/heckbert80color.html">Color Image Quantization for Frame Buffer Display</a>. ACM SIGGRAPH '82 Proceedings. First publication of the median cut algorithm.</li>
<li>Dan Bloomberg. <a href="http://www.leptonica.com/papers/colorquant.pdf">Color quantization using octrees</a>. Leptonica.</li>
<li>Oleg Verevka. <a href="http://citeseer.ist.psu.edu/100440.html">Color Image Quantization in Windows Systems with Local K-means Algorithm</a>. <em>Proceedings of the Western Computer Graphics Symposium '95.</em></li>
<li>J. Puzicha, M. Held, J. Ketterer, J. M. Buhmann, and D. Fellner. <a href="http://www.iai.uni-bonn.de/III/forschung/publikationen/tr/abstracts/IAI-TR-98-1.abstract-en.html">On Spatial Quantization of Color Images</a>. (<a href="http://www.informatik.uni-bonn.de/III/forschung/publikationen/tr/reports/IAI-TR-98-1.ps.gz">full text .ps.gz</a>) Technical Report IAI-TR-98-1, University of Bonn. 1998.</li>
<li>A. Schrader. <a href="http://www.andreas-schrader.de/publications.html">Evolutionäre Algorithmen zur Farbquantisierung und asymmetrischen Codierung digitaler Farbbilder</a>. WVB Verlag, Berlin, 1999. Comprehensive Overview and Comparison of Color Quantization Algorithms.</li>
</ul>

<p>"</p>

<p><a href="Category:Image_processing" title="wikilink">Category:Image processing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a class="uri" href="http://members.ozemail.com.au/~dekker/NEUQUANT.HTML">http://members.ozemail.com.au/~dekker/NEUQUANT.HTML</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a class="uri" href="http://lists.xcf.berkeley.edu/lists/gimp-user/2000-April/001024.html">http://lists.xcf.berkeley.edu/lists/gimp-user/2000-April/001024.html</a>, <a class="uri" href="http://lists.xcf.berkeley.edu/lists/gimp-developer/2000-April/012205.html">http://lists.xcf.berkeley.edu/lists/gimp-developer/2000-April/012205.html</a><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
