<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1121">Hensel's lemma</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Hensel's lemma</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <strong>Hensel's lemma</strong>, also known as <strong>Hensel's lifting lemma</strong>, named after <a href="Kurt_Hensel" title="wikilink">Kurt Hensel</a>, is a result in <a href="modular_arithmetic" title="wikilink">modular arithmetic</a>, stating that if a <a href="polynomial_equation" title="wikilink">polynomial equation</a> has a <a href="Multiplicity_(mathematics)#Multiplicity_of_a_root_of_a_polynomial" title="wikilink">simple root</a> modulo a <a href="prime_number" title="wikilink">prime number</a> 

<math display="inline" id="Hensel's_lemma:0">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, then this root corresponds to a unique root of the same equation modulo any higher power of 

<math display="inline" id="Hensel's_lemma:1">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, which can be found by iteratively "<a href="lift_(mathematics)" title="wikilink">lifting</a>" the solution modulo successive powers of 

<math display="inline" id="Hensel's_lemma:2">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

. More generally it is used as a generic name for analogues for <a href="completion_(ring_theory)" title="wikilink">complete</a> <a href="commutative_ring" title="wikilink">commutative rings</a> (including <a href="p-adic_field" title="wikilink"><em>p</em>-adic fields</a> in particular) of the <a href="Newton_method" title="wikilink">Newton method</a> for solving equations. Since <a href="p-adic_analysis" title="wikilink"><em>p</em>-adic analysis</a> is in some ways simpler than <a href="real_analysis" title="wikilink">real analysis</a>, there are relatively neat criteria guaranteeing a root of a polynomial.</p>
<h2 id="statement">Statement</h2>

<p>Let 

<math display="inline" id="Hensel's_lemma:3">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>


 be a <a class="uri" href="polynomial" title="wikilink">polynomial</a> with <a class="uri" href="integer" title="wikilink">integer</a> (or <em>p</em>-adic integer) coefficients, and let <em>m</em>,<em>k</em> be positive integers such that <em>m</em> ≤ <em>k</em>. If <em>r</em> is an integer such that</p>

<p>

<math display="block" id="Hensel's_lemma:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mn>0</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <msup>
       <mi>p</mi>
       <mi>k</mi>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <ci>pmod</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(r)\equiv 0\;\;(\mathop{{\rm mod}}p^{k})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hensel's_lemma:5">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≢</mo>
   <mrow>
    <mn>0</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-equivalent-to</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>r</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(r)\not\equiv 0\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

</p>

<p>then there exists an integer <em>s</em> such that</p>

<p>

<math display="block" id="Hensel's_lemma:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mn>0</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <msup>
       <mi>p</mi>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mi>m</mi>
       </mrow>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <ci>pmod</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(s)\equiv 0\;\;(\mathop{{\rm mod}}p^{k+m})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hensel's_lemma:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mo>≡</mo>
    <mrow>
     <mi>s</mi>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <msup>
        <mi>p</mi>
        <mi>k</mi>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>r</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <ci>s</ci>
     <apply>
      <ci>pmod</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\equiv s\;\;(\mathop{{\rm mod}}p^{k}).
  </annotation>
 </semantics>
</math>

</p>

<p>Furthermore, this <em>s</em> is unique modulo <em>p</em><sup><em>k</em>+m</sup>, and can be computed explicitly as</p>

<p>

<math display="block" id="Hensel's_lemma:8">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mi>r</mi>
    <mo>+</mo>
    <mrow>
     <mi>t</mi>
     <msup>
      <mi>p</mi>
      <mi>k</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <plus></plus>
     <ci>r</ci>
     <apply>
      <times></times>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=r+tp^{k}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Hensel's_lemma:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>r</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <msup>
        <mi>p</mi>
        <mi>k</mi>
       </msup>
      </mfrac>
      <mo>⋅</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>f</mi>
         <mo>′</mo>
        </msup>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>r</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>r</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>r</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=-\frac{f(r)}{p^{k}}\cdot(f^{\prime}(r)^{-1}).
  </annotation>
 </semantics>
</math>

</p>

<p>In this formula for <em>t</em>, the division by <em>p</em><sup><em>k</em></sup> denotes ordinary integer division (where the remainder will be 0), while negation, multiplication, and multiplicative inversion 

<math display="inline" id="Hensel's_lemma:10">
 <semantics>
  <mrow>
   <msup>
    <mi>f</mi>
    <mo>′</mo>
   </msup>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>r</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(r)^{-1}
  </annotation>
 </semantics>
</math>

 are performed in 

<math display="inline" id="Hensel's_lemma:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <msup>
     <mi>p</mi>
     <mi>m</mi>
    </msup>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/p^{m}\mathbb{Z}
  </annotation>
 </semantics>
</math>

.</p>

<p>As an aside, if 

<math display="inline" id="Hensel's_lemma:12">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mn>0</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>r</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(r)\equiv 0\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

, then 0, 1, or several <em>s</em> may exist (see Hensel Lifting below).</p>
<h3 id="derivation">Derivation</h3>

<p>The lemma derives from considering the Taylor expansion of <em>f</em> around <em>r</em>. From 

<math display="inline" id="Hensel's_lemma:13">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>≡</mo>
   <mrow>
    <mi>s</mi>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <msup>
       <mi>p</mi>
       <mi>k</mi>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>r</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <ci>s</ci>
     <apply>
      <ci>pmod</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\equiv s\;\;(\mathop{{\rm mod}}p^{k})
  </annotation>
 </semantics>
</math>


, we see that <em>s</em> has to be of the form <em>s = r + tp<sup>k</sup></em> for some integer <em>t</em>. Expanding 

<math display="inline" id="Hensel's_lemma:14">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>r</mi>
     <mo>+</mo>
     <mrow>
      <mi>t</mi>
      <msup>
       <mi>p</mi>
       <mi>k</mi>
      </msup>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <plus></plus>
     <ci>r</ci>
     <apply>
      <times></times>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(r+tp^{k})
  </annotation>
 </semantics>
</math>

 gives</p>

<p>

<math display="block" id="Hensel's_lemma:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>r</mi>
       <mo>+</mo>
       <mrow>
        <mi>t</mi>
        <msup>
         <mi>p</mi>
         <mi>k</mi>
        </msup>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>r</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>t</mi>
        <msup>
         <mi>p</mi>
         <mi>k</mi>
        </msup>
       </mrow>
       <mo>⋅</mo>
       <msup>
        <mi>f</mi>
        <mo>′</mo>
       </msup>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>r</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>O</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>p</mi>
        <mrow>
         <mn>2</mn>
         <mi>k</mi>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <plus></plus>
      <ci>r</ci>
      <apply>
       <times></times>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>r</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>p</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <ci>r</ci>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(r+tp^{k})=f(r)+tp^{k}\cdot f^{\prime}(r)+O(p^{2k}).
  </annotation>
 </semantics>
</math>

</p>

<p>Reducing both sides modulo p<sup>k+m</sup>, we see that for 

<math display="inline" id="Hensel's_lemma:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mn>0</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <msup>
       <mi>p</mi>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mi>m</mi>
       </mrow>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <ci>pmod</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(s)\equiv 0\;\;(\mathop{{\rm mod}}p^{k+m})
  </annotation>
 </semantics>
</math>

 to hold, we need</p>

<p>

<math display="block" id="Hensel's_lemma:17">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≡</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>r</mi>
      <mo>+</mo>
      <mrow>
       <mi>t</mi>
       <msup>
        <mi>p</mi>
        <mi>k</mi>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>r</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>t</mi>
        <msup>
         <mi>p</mi>
         <mi>k</mi>
        </msup>
       </mrow>
       <mo>⋅</mo>
       <msup>
        <mi>f</mi>
        <mo>′</mo>
       </msup>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>r</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <msup>
       <mi>p</mi>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mi>m</mi>
       </mrow>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <plus></plus>
       <ci>r</ci>
       <apply>
        <times></times>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>p</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>r</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <ci>normal-⋅</ci>
         <apply>
          <times></times>
          <ci>t</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>p</ci>
           <ci>k</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>f</ci>
          <ci>normal-′</ci>
         </apply>
        </apply>
        <ci>r</ci>
       </apply>
      </apply>
      <apply>
       <ci>pmod</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <ci>m</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\equiv f(r+tp^{k})\equiv f(r)+tp^{k}\cdot f^{\prime}(r)\;\;(\mathop{{\rm mod}%
}p^{k+m})
  </annotation>
 </semantics>
</math>

</p>

<p>where the <em>O</em>(<em>p</em><sup>2<em>k</em></sup>) terms vanish because <em>k</em>+<em>m</em> ≤ 2<em>k</em>. Then we note that 

<math display="inline" id="Hensel's_lemma:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>z</mi>
    <msup>
     <mi>p</mi>
     <mi>k</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <ci>z</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(r)=zp^{k}
  </annotation>
 </semantics>
</math>


 for some integer <em>z</em> since <em>r</em> is a root of <em>f</em> mod <em>p</em><sup><em>k</em></sup>, so</p>

<p>

<math display="block" id="Hensel's_lemma:19">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>z</mi>
       <mo>+</mo>
       <mrow>
        <mi>t</mi>
        <msup>
         <mi>f</mi>
         <mo>′</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>r</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>p</mi>
      <mi>k</mi>
     </msup>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <msup>
       <mi>p</mi>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mi>m</mi>
       </mrow>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <cn type="integer">0</cn>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <ci>z</ci>
       <apply>
        <times></times>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>r</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\equiv(z+tf^{\prime}(r))p^{k}\;\;(\mathop{{\rm mod}}p^{k+m})
  </annotation>
 </semantics>
</math>

, which is to say</p>

<p>

<math display="block" id="Hensel's_lemma:20">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo>≡</mo>
    <mrow>
     <mrow>
      <mi>z</mi>
      <mo>+</mo>
      <mrow>
       <mi>t</mi>
       <msup>
        <mi>f</mi>
        <mo>′</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>r</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <msup>
        <mi>p</mi>
        <mi>m</mi>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <cn type="integer">0</cn>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <plus></plus>
      <ci>z</ci>
      <apply>
       <times></times>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>r</ci>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\equiv z+tf^{\prime}(r)\;\;(\mathop{{\rm mod}}p^{m}).
  </annotation>
 </semantics>
</math>

</p>

<p>Then substituting back <em>f</em>(<em>r</em>)/<em>p</em><sup><em>k</em></sup> for <em>z</em> and solving for <em>t</em> in 

<math display="inline" id="Hensel's_lemma:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <msup>
     <mi>p</mi>
     <mi>m</mi>
    </msup>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/p^{m}\mathbb{Z}
  </annotation>
 </semantics>
</math>

 gives the explicit formula for <em>t</em> mentioned above. The assumption that 

<math display="inline" id="Hensel's_lemma:22">
 <semantics>
  <mrow>
   <msup>
    <mi>f</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(r)
  </annotation>
 </semantics>
</math>

 is not divisible by <em>p</em> ensures that 

<math display="inline" id="Hensel's_lemma:23">
 <semantics>
  <mrow>
   <msup>
    <mi>f</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(r)
  </annotation>
 </semantics>
</math>


 has an inverse mod 

<math display="inline" id="Hensel's_lemma:24">
 <semantics>
  <msup>
   <mi>p</mi>
   <mi>m</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>p</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{m}
  </annotation>
 </semantics>
</math>

 which is necessarily unique. Hence a solution for <em>t</em> exists uniquely modulo 

<math display="inline" id="Hensel's_lemma:25">
 <semantics>
  <msup>
   <mi>p</mi>
   <mi>m</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>p</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{m}
  </annotation>
 </semantics>
</math>

, and <em>s</em> exists uniquely modulo 

<math display="inline" id="Hensel's_lemma:26">
 <semantics>
  <msup>
   <mi>p</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mi>m</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>p</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{k+m}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="hensel-lifting">Hensel Lifting</h2>

<p>Using the lemma, one can "lift" (i.e. add multiples of the next power of p) a root <em>r</em> of the polynomial <em>f</em> mod <em>p</em><sup><em>k</em></sup> to a new root <em>s</em> mod <em>p</em><sup><em>k</em>+1</sup> such that <em>r</em> ≡ <em>s</em> mod <em>p</em><sup><em>k</em></sup> (by taking <em>m</em>=1; taking larger <em>m</em> follows by induction). In fact, a root mod <em>p</em><sup><em>k</em>+1</sup> is also a root mod <em>p</em><sup><em>k</em></sup>, so the roots mod <em>p</em><sup><em>k</em>+1</sup> are precisely the liftings of roots mod <em>p</em><sup><em>k</em></sup>. The new root <em>s</em> is congruent to <em>r</em> mod <em>p</em>, so the new root also satisfies 

<math display="inline" id="Hensel's_lemma:27">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≢</mo>
   <mrow>
    <mn>0</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">not-equivalent-to</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <cn type="integer">0</cn>
      <apply>
       <ci>pmod</ci>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(s)\equiv f^{\prime}(r)\not\equiv 0\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

. So the lifting can be repeated, and starting from a solution <em>r</em><sub><em>k</em></sub> of 

<math display="inline" id="Hensel's_lemma:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mn>0</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <msup>
       <mi>p</mi>
       <mi>k</mi>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <ci>pmod</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)\equiv 0\;\;(\mathop{{\rm mod}}p^{k})
  </annotation>
 </semantics>
</math>


 we can derive a sequence of solutions <em>r</em><sub><em>k</em>+1</sub>, <em>r</em><sub><em>k</em>+2</sub>, ... of the same congruence for successively higher powers of <em>p</em>, provided 

<math display="inline" id="Hensel's_lemma:29">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>r</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≢</mo>
   <mrow>
    <mn>0</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-equivalent-to</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(r_{k})\not\equiv 0\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

 for the initial root <em>r</em><sub><em>k</em></sub>. This also shows that <em>f</em> has the same number of roots mod <em>p</em><sup><em>k</em></sup> as mod <em>p</em><sup><em>k</em>+1</sup>, mod <em>p</em> <sup><em>k</em>+2</sup>, or any other higher power of <em>p</em>, provided the roots of <em>f</em> mod <em>p</em><sup><em>k</em></sup> are all simple.</p>

<p>What happens to this process if <em>r</em> is not a simple root mod <em>p</em>? If we have a root mod <em>p</em><sup><em>k</em></sup> at which the derivative mod <em>p</em> is 0, then there is <em>not</em> a unique lifting of a root mod <em>p</em><sup><em>k</em></sup> to a root mod <em>p</em><sup><em>k</em>+1</sup>: either there is no lifting to a root mod <em>p</em><sup><em>k</em>+1</sup> or there are multiple choices:</p>
<dl>
<dd><dl>
<dd>if 

<math display="inline" id="Hensel's_lemma:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mn>0</mn>
    </mpadded>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <msup>
     <mi>p</mi>
     <mi>k</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(r)\equiv 0\,\bmod{p^{k}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hensel's_lemma:31">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>f</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>r</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mn>0</mn>
     </mpadded>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <mi>p</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>r</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <cn type="integer">0</cn>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(r)\equiv 0\,\bmod{p},
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Hensel's_lemma:32">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>≡</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>r</mi>
    </mpadded>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <msup>
     <mi>p</mi>
     <mi>k</mi>
    </msup>
   </mrow>
   <mo>⇒</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>r</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <msup>
     <mi>p</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <ci>s</ci>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <ci>r</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>r</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\equiv r\,\bmod p^{k}\Rightarrow f(s)\equiv f(r)\,\bmod p^{k+1}
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
</dd>
</dl>

<p>That is, 

<math display="inline" id="Hensel's_lemma:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>r</mi>
      <mo>+</mo>
      <mrow>
       <mi>t</mi>
       <msup>
        <mi>p</mi>
        <mi>k</mi>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mn>0</mn>
    </mpadded>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mpadded width="+1.7pt">
     <msup>
      <mi>p</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <plus></plus>
      <ci>r</ci>
      <apply>
       <times></times>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(r+tp^{k})\equiv 0\,\bmod{p^{k+1}}\,
  </annotation>
 </semantics>
</math>


 for all integers <em>t</em>. Therefore if 

<math display="inline" id="Hensel's_lemma:34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>r</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≢</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mn>0</mn>
     </mpadded>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <msup>
      <mi>p</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-equivalent-to</csymbol>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(r)\not\equiv 0\,\bmod{p^{k+1}},
  </annotation>
 </semantics>
</math>

 then there is no lifting of <em>r</em> to a root of <em>f</em>(<em>x</em>) mod <em>p</em><sup><em>k</em>+1</sup>, while if 

<math display="inline" id="Hensel's_lemma:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>r</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mn>0</mn>
     </mpadded>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <msup>
      <mi>p</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(r)\equiv 0\,\bmod{p^{k+1}},
  </annotation>
 </semantics>
</math>

 then every lifting of <em>r</em> to modulus <em>p</em><sup><em>k</em>+1</sup> is a root of <em>f</em>(<em>x</em>) mod <em>p</em><sup><em>k</em>+1</sup>.</p>

<p>To see the difficulty that can arise in concrete examples, take <em>p</em> = 2, <em>f</em>(<em>x</em>) = <em>x</em><sup>2</sup> + 1, and <em>r</em> = 1. Then <em>f</em>(1) ≡ 0 mod 2 and f'(1) ≡ 0 mod 2. We have <em>f</em>(1) = 2 ≠ 0 mod 4 which means that no lifting of 1 to modulus 4 is a root of <em>f</em>(<em>x</em>) mod 4.</p>

<p>On the other hand, if we take <em>f</em>(<em>x</em>) = <em>x</em><sup>2</sup> − 17 then, as before, 1 is a root of <em>f</em>(<em>x</em>) mod 2 and the derivative is 0 mod 2. But since <em>f</em>(1) is 0 mod 4, then we <strong><em>can</em></strong> lift our solution to modulo 4 and <strong><em>both</em></strong> 1 and 3 are solutions. The derivative is still 0 mod 2, so <em>a priori</em> we don't know whether we can lift them to modulo 8, but in fact we can, since <em>f</em>(1) is 0 mod 8 and <em>f</em>(3) is 0 mod 8, giving solutions at 1, 3, 5, and 7 mod 8. Since of these only <em>f</em>(1) and <em>f</em>(7) are 0 mod 16 we can lift only 1 and 7 to modulo 16, giving 1, 7, 9, and 15 mod 16. Of these, only 7 and 9 give <em>f</em>(<em>x</em>)=0 mod 32, so these can be raised giving 7, 9, 23, and 25 mod 32. It turns out that (for this example f(x)) for every positive integer <em>k</em> there are four liftings of 1 mod 2 to a root of <em>f</em>(<em>x</em>) mod 2<sup><em>k</em></sup>.</p>
<h2 id="hensels-lemma-for-p-adic-numbers">Hensel's Lemma for <em>p</em>-adic Numbers</h2>

<p>In the <em>p</em>-adic numbers, where we can make sense of rational numbers modulo powers of <em>p</em> as long as the denominator is not a multiple of <em>p</em>, the recursion from <em>r</em><sub><em>k</em></sub> (roots mod <em>p</em><sup><em>k</em></sup>) to <em>r</em><sub><em>k</em>+1</sub> (roots mod <em>p</em><sup><em>k</em>+1</sup>) can be expressed in a much more intuitive way. Instead of choosing <em>t</em> to be an(y) integer which solves the congruence 

<math display="inline" id="Hensel's_lemma:36">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>r</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>r</mi>
          <mi>k</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>/</mo>
       <msup>
        <mi>p</mi>
        <mi>k</mi>
       </msup>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mpadded width="+1.7pt">
     <msup>
      <mi>p</mi>
      <mi>m</mi>
     </msup>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>t</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   tf^{\prime}(r_{k})\equiv-(f(r_{k})/p^{k})\,\bmod{p^{m}}\,
  </annotation>
 </semantics>
</math>

, let <em>t</em> be the rational number 

<math display="inline" id="Hensel's_lemma:37">
 <semantics>
  <mrow>
   <mo lspace="7.5pt">-</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>r</mi>
          <mi>k</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>/</mo>
       <msup>
        <mi>p</mi>
        <mi>k</mi>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>/</mo>
     <msup>
      <mi>f</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>r</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ -(f(r_{k})/p^{k})/f^{\prime}(r_{k})
  </annotation>
 </semantics>
</math>

 (the <em>p</em><sup><em>k</em></sup> here is not really a denominator since <em>f</em>(<em>r</em><sub><em>k</em></sub>) is divisible by <em>p</em><sup><em>k</em></sup>). Then set</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Hensel's_lemma:38">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>r</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>r</mi>
      <mi>k</mi>
     </msub>
     <mo>+</mo>
     <mrow>
      <mi>t</mi>
      <msup>
       <mi>p</mi>
       <mi>k</mi>
      </msup>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>r</mi>
      <mi>k</mi>
     </msub>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>r</mi>
         <mi>k</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <msup>
        <mi>f</mi>
        <mo>′</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>r</mi>
         <mi>k</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{k+1}=r_{k}+tp^{k}=r_{k}-\frac{f(r_{k})}{f^{\prime}(r_{k})}.
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>

<p>This fraction may not be an integer, but it is a <em>p</em>-adic integer, and the sequence of numbers <em>r</em><sub><em>k</em></sub> converges in the <em>p</em>-adic integers to a root of <em>f</em>(<em>x</em>) = 0. Moreover, the displayed recursive formula for the (new) number <em>r</em><sub><em>k</em>+1</sub> in terms of <em>r</em><sub><em>k</em></sub> is precisely <a href="Newton's_method" title="wikilink">Newton's method</a> for finding roots to equations in the real numbers.</p>

<p>By working directly in the <em>p</em>-adics and using the <em>p</em>-adic absolute value, there is a version of Hensel's lemma which can be applied even if we start with a solution of <em>f</em>(<em>a</em>) ≡ 0 mod <em>p</em> such that f'(<em>a</em>) ≡ 0 mod <em>p</em>. We just need to make sure the number f'(<em>a</em>) is not exactly 0. This more general version is as follows: if there is an integer <em>a</em> which satisfies |<em>f</em>(<em>a</em>)|<sub><em>p</em></sub> <em>p</em><sup>2</sup>, then there is a unique <em>p</em>-adic integer <em>b</em> such <em>f</em>(<em>b</em>) = 0 and |<em>b</em>-<em>a</em>|<sub><em>p</em></sub> <em>p</em>. The construction of <em>b</em> amounts to showing that the recursion from Newton's method with initial value <em>a</em> converges in the <em>p</em>-adics and we let <em>b</em> be the limit. The uniqueness of <em>b</em> as a root fitting the condition |<em>b</em>-<em>a</em>|<sub><em>p</em></sub> <em>p</em> needs additional work.</p>

<p>The statement of Hensel's lemma given above (taking 

<math display="inline" id="Hensel's_lemma:39">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=1
  </annotation>
 </semantics>
</math>

) is a special case of this more general version, since the conditions that <em>f</em>(<em>a</em>) ≡ 0 mod <em>p</em> and f'(<em>a</em>) ≠ 0 mod <em>p</em> say that |<em>f</em>(<em>a</em>)|<sub><em>p</em></sub> <em>p</em> = 1.</p>
<h2 id="examples">Examples</h2>

<p>Suppose that <em>p</em> is an odd prime number and <em>a</em> is a <a href="quadratic_residue" title="wikilink">quadratic residue</a> modulo <em>p</em> that is nonzero mod <em>p</em>. Then Hensel's lemma implies that <em>a</em> has a square root in the ring of <em>p</em>-adic integers <strong>Z</strong><sub><em>p</em></sub>. Indeed, let <em>f</em>(<em>x</em>)=<em>x</em><sup>2</sup>-<em>a</em>. Its derivative is 2<em>x</em>, so if <em>r</em> is a square root of <em>a</em> mod <em>p</em> we have</p>

<p>

<math display="block" id="Hensel's_lemma:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>r</mi>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mi>a</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mn>0</mn>
    </mpadded>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>r</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>r</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <cn type="integer">0</cn>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(r)=r^{2}-a\equiv 0\,\bmod{p}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hensel's_lemma:41">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mi>r</mi>
   </mrow>
   <mo>≢</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mn>0</mn>
    </mpadded>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>r</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">not-equivalent-to</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <cn type="integer">0</cn>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(r)=2r\not\equiv 0\,\bmod{p}
  </annotation>
 </semantics>
</math>

,</p>

<p>where the second condition depends on <em>p</em> not being 2. The basic version of Hensel's lemma tells us that starting from <em>r</em><sub>1</sub>= <em>r</em> we can recursively construct a sequence of integers { <em>r</em><sub>k</sub> } such that</p>

<p>

<math display="block" id="Hensel's_lemma:42">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>r</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>≡</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <msub>
        <mi>r</mi>
        <mi>k</mi>
       </msub>
      </mpadded>
      <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
      <msup>
       <mi>p</mi>
       <mi>k</mi>
      </msup>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <msubsup>
      <mi>r</mi>
      <mi>k</mi>
      <mn>2</mn>
     </msubsup>
     <mo>≡</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>a</mi>
      </mpadded>
      <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
      <msup>
       <mi>p</mi>
       <mi>k</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <equivalent></equivalent>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>k</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{k+1}\equiv r_{k}\,\bmod{p^{k}},\quad r_{k}^{2}\equiv a\,\bmod{p^{k}}.
  </annotation>
 </semantics>
</math>

</p>

<p>This sequence converges to some <em>p</em>-adic integer <em>b</em> and <em>b</em><sup>2</sup>=<em>a</em>. In fact, <em>b</em> is the unique square root of <em>a</em> in <strong>Z</strong><sub>p</sub> congruent to <em>r</em><sub>1</sub> modulo <em>p</em>. Conversely, if <em>a</em> is a perfect square in <strong>Z</strong><sub>p</sub> and it is not divisible by <em>p</em> then it is a nonzero quadratic residue mod <em>p</em>. Note that the <a href="quadratic_reciprocity_law" title="wikilink">quadratic reciprocity law</a> allows one to easily test whether <em>a</em> is a nonzero quadratic residue mod <em>p</em>, thus we get a practical way to determine which <em>p</em>-adic numbers (for <em>p</em> odd) have a <em>p</em>-adic square root, and it can be extended to cover the case <em>p</em>=2 using the more general version of Hensel's lemma (an example with 2-adic square roots of 17 is given later).</p>

<p>To make the discussion above more explicit, let us find a "square root of 2" (the solution to 

<math display="inline" id="Hensel's_lemma:43">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}-2=0
  </annotation>
 </semantics>
</math>


) in the 7-adic integers. Modulo 7 one solution is 3 (we could also take 4), so we set 

<math display="inline" id="Hensel's_lemma:44">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{1}=3
  </annotation>
 </semantics>
</math>

. Hensel's lemma then allows us to find 

<math display="inline" id="Hensel's_lemma:45">
 <semantics>
  <msub>
   <mi>r</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{2}
  </annotation>
 </semantics>
</math>

 as follows:</p>

<p>

<math display="block" id="Hensel's_lemma:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>r</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>3</mn>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
   <mo>=</mo>
   <mn>7</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">3</cn>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">7</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(r_{1})=3^{2}-2=7
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Hensel's_lemma:47">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>r</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <msup>
     <mi>p</mi>
     <mn>1</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>7</mn>
    <mo>/</mo>
    <mn>7</mn>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">7</cn>
      <cn type="integer">7</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(r_{1})/p^{1}=7/7=1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Hensel's_lemma:48">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>r</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <msub>
     <mi>r</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>6</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">6</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(r_{1})=2r_{1}=6
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Hensel's_lemma:49">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>t</mi>
     <msup>
      <mi>f</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>r</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>r</mi>
           <mn>1</mn>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>/</mo>
        <msup>
         <mi>p</mi>
         <mrow>
          <mi>k</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
       </mrow>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <mi>p</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>t</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <apply>
         <minus></minus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   tf^{\prime}(r_{1})\equiv-(f(r_{1})/p^{k-1})\,\bmod{p},
  </annotation>
 </semantics>
</math>

 that is, 

<math display="inline" id="Hensel's_lemma:50">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mo>⋅</mo>
    <mn>6</mn>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mpadded width="+1.7pt">
      <mn>1</mn>
     </mpadded>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mn>7</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <ci>normal-⋅</ci>
     <ci>t</ci>
     <cn type="integer">6</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">7</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\cdot 6\equiv-1\,\bmod{7}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Hensel's_lemma:51">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⇒</mo>
   <mi>t</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-⇒</ci>
     <csymbol cd="latexml">absent</csymbol>
     <ci>t</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Rightarrow t=1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Hensel's_lemma:52">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>r</mi>
     <mn>2</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>r</mi>
      <mn>1</mn>
     </msub>
     <mo>+</mo>
     <mrow>
      <mi>t</mi>
      <msup>
       <mi>p</mi>
       <mn>1</mn>
      </msup>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>3</mn>
     <mo>+</mo>
     <mrow>
      <mn>1</mn>
      <mo>⋅</mo>
      <mn>7</mn>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>10</mn>
    <mo>=</mo>
    <msub>
     <mn>13</mn>
     <mn>7</mn>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <cn type="integer">3</cn>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">1</cn>
       <cn type="integer">7</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">10</cn>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">13</cn>
      <cn type="integer">7</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{2}=r_{1}+tp^{1}=3+1\cdot 7=10=13_{7}.
  </annotation>
 </semantics>
</math>

</p>

<p>And sure enough, 

<math display="inline" id="Hensel's_lemma:53">
 <semantics>
  <mrow>
   <msup>
    <mn>10</mn>
    <mn>2</mn>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mn>2</mn>
    </mpadded>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <msup>
     <mn>7</mn>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">10</cn>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">7</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   10^{2}\equiv 2\,\bmod{7^{2}}
  </annotation>
 </semantics>
</math>


. (If we had used the Newton method recursion directly in the 7-adics, then <em>r</em><sub>2</sub> = <em>r</em><sub>1</sub> - f(<em>r</em><sub>1</sub>)/f'(<em>r</em><sub>1</sub>) = 3 - 7/6 = 11/6, and 11/6 ≡ 10 mod 7<sup>2</sup>.)</p>

<p>We can continue and find 

<math display="inline" id="Hensel's_lemma:54">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <mn>108</mn>
   <mo>=</mo>
   <mrow>
    <mn>3</mn>
    <mo>+</mo>
    <mn>7</mn>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mo>⋅</mo>
     <msup>
      <mn>7</mn>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mn>213</mn>
    <mn>7</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <cn type="integer">3</cn>
     </apply>
     <cn type="integer">108</cn>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <cn type="integer">3</cn>
      <cn type="integer">7</cn>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">7</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">213</cn>
      <cn type="integer">7</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{3}=108=3+7+2\cdot 7^{2}=213_{7}
  </annotation>
 </semantics>
</math>

. Each time we carry out the calculation (that is, for each successive value of <em>k</em>), one more base 7 digit is added for the next higher power of 7. In the 7-adic integers this sequence converges, and the limit is a square root of 2 in <strong>Z</strong><sub>7</sub> which has initial 7-adic expansion</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Hensel's_lemma:55">
 <semantics>
  <mrow>
   <mrow>
    <mn>3</mn>
    <mo>+</mo>
    <mn>7</mn>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mo>⋅</mo>
     <msup>
      <mn>7</mn>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>6</mn>
     <mo>⋅</mo>
     <msup>
      <mn>7</mn>
      <mn>3</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <msup>
     <mn>7</mn>
     <mn>4</mn>
    </msup>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mo>⋅</mo>
     <msup>
      <mn>7</mn>
      <mn>5</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <msup>
     <mn>7</mn>
     <mn>6</mn>
    </msup>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mo>⋅</mo>
     <msup>
      <mn>7</mn>
      <mn>7</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>4</mn>
     <mo>⋅</mo>
     <msup>
      <mn>7</mn>
      <mn>8</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">3</cn>
    <cn type="integer">7</cn>
    <apply>
     <ci>normal-⋅</ci>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">7</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <cn type="integer">6</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">7</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">7</cn>
     <cn type="integer">4</cn>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">7</cn>
      <cn type="integer">5</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">7</cn>
     <cn type="integer">6</cn>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">7</cn>
      <cn type="integer">7</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <cn type="integer">4</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">7</cn>
      <cn type="integer">8</cn>
     </apply>
    </apply>
    <ci>normal-⋯</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3+7+2\cdot 7^{2}+6\cdot 7^{3}+7^{4}+2\cdot 7^{5}+7^{6}+2\cdot 7^{7}+4\cdot 7^{%
8}+\cdots.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>If we started with the initial choice 

<math display="inline" id="Hensel's_lemma:56">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{1}=4
  </annotation>
 </semantics>
</math>

 then Hensel's lemma would produce a square root of 2 in <strong>Z</strong><sub>7</sub> which is congruent to 4 (mod 7) instead of 3 (mod 7) and in fact this second square root would be the negative of the first square root (which is consistent with 4 = -3 mod 7).</p>

<p>As an example where the original version of Hensel's lemma is not valid but the more general one is, let <em>f</em>(<em>x</em>) = <em>x</em><sup>2</sup> - 17 and <em>a</em> = 1. Then <em>f</em>(<em>a</em>) = -16 and f'(<em>a</em>) = 2, so |<em>f</em>(<em>a</em>)|<sub>2</sub> <em>2</em><sup>2</sup>, which implies there is a unique 2-adic integer <em>b</em> satisfying <em>b</em><sup>2</sup> = 17 and |<em>b</em>- <em>a</em>|<sub>2</sub> 2 = 1/2, i.e., <em>b</em> ≡ 1 mod 4. There are two square roots of 17 in the 2-adic integers, differing by a sign, and although they are congruent mod 2 they are not congruent mod 4. This is consistent with the general version of Hensel's lemma only giving us a unique 2-adic square root of 17 that is congruent to 1 mod 4 rather than mod 2. If we had started with the initial approximate root <em>a</em> = 3 then we could apply the more general Hensel's lemma again to find a unique 2-adic square root of 17 which is congruent to 3 mod 4. This is the other 2-adic square root of 17.</p>

<p>In terms of lifting roots of <em>x</em><sup>2</sup> - 17 from one modulus 2<sup><em>k</em></sup> to the next 2<sup><em>k</em>+1</sup>, the lifts starting with the root 1 mod 2 are as follows:</p>
<dl>
<dd><dl>
<dd>1 mod 2 --&gt; 1, 3 mod 4
</dd>
<dd>1 mod 4 --&gt; 1, 5 mod 8 and 3 mod 4 ---&gt; 3, 7 mod 8
</dd>
<dd>1 mod 8 --&gt; 1, 9 mod 16 and 7 mod 8 ---&gt; 7, 15 mod 16, while 3 mod 8 and 5 mod 8 don't lift to roots mod 16
</dd>
<dd>9 mod 16 --&gt; 9, 25 mod 32 and 7 mod 16 --&gt; 7, 23 mod 16, while 1 mod 16 and 15 mod 16 don't lift to roots mod 32.
</dd>
</dl>
</dd>
</dl>

<p>For every <em>k</em> at least 3, there are <em>four</em> roots of <em>x</em><sup>2</sup> - 17 mod 2<sup><em>k</em></sup>, but if we look at their 2-adic expansions we can see that in pairs they are converging to just <em>two</em> 2-adic limits. For instance, the four roots mod 32 break up into two pairs of roots which each look the same mod 16:</p>
<dl>
<dd><dl>
<dd>9 = 1 + 2<sup>3</sup> and 25 = 1 + 2<sup>3</sup> + 2<sup>4</sup>, 7 = 1 + 2 + 2<sup>2</sup> and 23 = 1 + 2 + 2<sup>2</sup> + 2<sup>4</sup>.
</dd>
</dl>
</dd>
</dl>

<p>The 2-adic square roots of 17 have expansions</p>
<dl>
<dd><dl>
<dd>1 + 2<sup>3</sup> + 2<sup>5</sup> + 2<sup>6</sup> + 2<sup>7</sup> + 2<sup>9</sup> + 2<sup>10</sup> + ..., 1 + 2 + 2<sup>2</sup> + 2<sup>4</sup> + 2<sup>8</sup> + 2<sup>11</sup>...
</dd>
</dl>
</dd>
</dl>

<p>Another example where we can use the more general version of Hensel's lemma but not the basic version is a proof that any 3-adic integer <em>c</em> ≡ 1 mod 9 is a cube in <strong>Z</strong><sub>3</sub>. Let <em>f</em>(<em>x</em>) = <em>x</em><sup>3</sup> - c and take initial approximation <em>a</em> = 1. The basic Hensel's lemma cannot be used to find roots of <em>f</em>(<em>x</em>) since f'(<em>r</em>) ≡ 0 mod 3 for every <em>r</em>. To apply the general version of Hensel's lemma we want |f(1)|<sub>3</sub> 3<sup>2</sup>, which means <em>c</em> ≡ 1 mod 27. That is, if <em>c</em> ≡ 1 mod 27 then the general Hensel's lemma tells us <em>f</em>(<em>x</em>) has a 3-adic root, so <em>c</em> is a 3-adic cube. However, we wanted to have this result under the weaker condition that <em>c</em> ≡ 1 mod 9. If <em>c</em> ≡ 1 mod 9 then <em>c</em> ≡ 1, 10, or 19 mod 27. We can apply the general Hensel's lemma three times depending on the value of <em>c</em> mod 27: if <em>c</em> ≡ 1 mod 27 then use <em>a</em> = 1, if <em>c</em> ≡ 10 mod 27 then use <em>a</em> = 4 (since 4 is a root of <em>f</em>(<em>x</em>) mod 27), and if <em>c</em> ≡ 19 mod 27 then use <em>a</em> = 7. (It is not true that every <em>c</em> ≡ 1 mod 3 is a 3-adic cube, e.g., 4 is not a 3-adic cube since it is not a cube mod 9.)</p>

<p>In a similar way, after some preliminary work Hensel's lemma can be used to show that for any <em>odd</em> prime number <em>p</em>, any <em>p</em>-adic integer <em>c</em> which is 1 mod <em>p</em><sup>2</sup> is a <em>p</em>-th power in <strong>Z</strong><sub><em>p</em></sub>. (This is false when <em>p</em> is 2.)</p>
<h2 id="generalizations">Generalizations</h2>

<p>Suppose <em>A</em> is a <a href="commutative_ring" title="wikilink">commutative ring</a>, complete with respect to an <a href="ideal_(ring_theory)" title="wikilink">ideal</a> 

<math display="inline" id="Hensel's_lemma:57">
 <semantics>
  <msub>
   <mi>𝔪</mi>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝔪</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathfrak{m}_{A}
  </annotation>
 </semantics>
</math>

, and let 

<math display="inline" id="Hensel's_lemma:58">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)\in A[x]
  </annotation>
 </semantics>
</math>


 be a <a class="uri" href="polynomial" title="wikilink">polynomial</a> with coefficients in <em>A</em>. Then if <em>a</em> ∈ <em>A</em> is an "approximate root" of <em>f</em> in the sense that it satisfies</p>

<p>

<math display="block" id="Hensel's_lemma:59">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mn>0</mn>
    </mpadded>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mrow>
     <msup>
      <mi>f</mi>
      <mo>′</mo>
     </msup>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mi>𝔪</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>𝔪</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(a)\equiv 0\,\bmod{f^{\prime}(a)^{2}\mathfrak{m}}
  </annotation>
 </semantics>
</math>

</p>

<p>then there is an exact root <em>b</em> ∈ <em>A</em> of <em>f</em> "close to" <em>a</em>; that is,</p>

<p>

<math display="block" id="Hensel's_lemma:60">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>b</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(b)=0
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Hensel's_lemma:61">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mo>≡</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>a</mi>
     </mpadded>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <mrow>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>𝔪</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>b</ci>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <ci>a</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>a</ci>
      <ci>𝔪</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\equiv a\,\bmod{f^{\prime}(a)\mathfrak{m}}.
  </annotation>
 </semantics>
</math>

</p>

<p>Further, if <em>f</em> ′(<em>a</em>) is not a zero-divisor then <em>b</em> is unique.</p>

<p>As a special case, if 

<math display="inline" id="Hensel's_lemma:62">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mn>0</mn>
    </mpadded>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mi>𝔪</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <cn type="integer">0</cn>
     <ci>𝔪</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(a)\equiv 0\,\bmod{\mathfrak{m}}
  </annotation>
 </semantics>
</math>

 and <em>f</em> ′(<em>a</em>) is a unit in <em>A</em> then there is a unique solution to <em>f</em>(<em>b</em>) = 0 in <em>A</em> such that 

<math display="inline" id="Hensel's_lemma:63">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mo>≡</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>a</mi>
     </mpadded>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <mi>𝔪</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>b</ci>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <ci>a</ci>
     <ci>𝔪</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\equiv a\,\bmod{\mathfrak{m}}.
  </annotation>
 </semantics>
</math>


</p>

<p>This result can be generalized to several variables as follows:</p>

<p><strong>Theorem</strong>: Let <em>A</em> be a commutative ring that is complete with respect to an ideal <strong>m</strong> ⊂ <em>A</em> and <em>f</em><sub><em>i</em></sub>(<strong>x</strong>) ∈ <em>A</em>[<em>x</em><sub>1</sub>, …, <em>x</em><sub><em>n</em></sub>] for <em>i</em> = 1,...,<em>n</em> be a system of <em>n</em> polynomials in <em>n</em> variables over <em>A</em>. Let <strong>f</strong> = (<em>f</em><sub>1</sub>,...,<em>f</em><sub><em>n</em></sub>), viewed as a mapping from <em>A</em><sup><em>n</em></sup> to <em>A</em><sup><em>n</em></sup>, and let <em>J</em><sub><strong>f</strong></sub>(<strong>x</strong>) be the <a href="Jacobian_matrix" title="wikilink">Jacobian matrix</a> of <strong>f</strong>. Suppose some <strong>a</strong> = (<em>a</em><sub>1</sub>, …, <em>a</em><sub><em>n</em></sub>) ∈ <em>A</em><sup><em>n</em></sup> is an approximate solution to <strong>f</strong> = <strong>0</strong> in the sense that</p>
<dl>
<dd><em>f</em><sub><em>i</em></sub>(<strong>a</strong>) ≡ 0 mod (det J<sub><strong>f</strong></sub>(<strong>a</strong>))<sup>2</sup><strong>m</strong>
</dd>
</dl>

<p>for 1 ≤ <em>i</em> ≤ <em>n</em>. Then there is some <strong>b</strong> = (<em>b</em><sub>1</sub>, …, <em>b</em><sub><em>n</em></sub>) in <em>A</em><sup><em>n</em></sup> satisfying <strong>f</strong>(<strong>b</strong>) = <strong>0</strong>, i.e.,</p>
<dl>
<dd><em>f</em><sub><em>i</em></sub>(<strong>b</strong>) = 0 for all <em>i</em>,
</dd>
</dl>

<p>and furthermore this solution is "close" to <strong>a</strong> in the sense that</p>
<dl>
<dd><em>b</em><sub><em>i</em></sub> ≡ <em>a</em><sub><em>i</em></sub> mod <em>J</em><sub><strong>f</strong></sub>(<strong>a</strong>)<strong>m</strong>
</dd>
</dl>

<p>for 1 ≤ <em>i</em> ≤ <em>n</em>.</p>

<p>As a special case, if <em>f</em><sub><em>i</em></sub>(<strong>a</strong>) ≡ 0 mod <strong>m</strong> for all <em>i</em> and det J<sub><strong>f</strong></sub>(<strong>a</strong>) is a unit in <em>A</em> then there is a solution to <strong>f</strong>(<strong>b</strong>) = <strong>0</strong> with <em>b</em><sub><em>i</em></sub> ≡ <em>a</em><sub><em>i</em></sub> mod <strong>m</strong> for all <em>i</em>.</p>

<p>When <em>n</em> = 1, <strong>a</strong> = <em>a</em> is an element of <em>A</em> and <em>J</em><sub><strong>f</strong></sub>(<strong>a</strong>) = <em>J</em><sub><em>f</em></sub>(<em>a</em>) is <em>f</em> ′(<em>a</em>). The hypotheses of this multivariable Hensel's lemma reduce to the ones which were stated in the one-variable Hensel's lemma.</p>
<h2 id="related-concepts">Related concepts</h2>

<p>Completeness of a ring is not a necessary condition for the ring to have the Henselian property: <a href="Goro_Azumaya" title="wikilink">Goro Azumaya</a> in 1950 defined a commutative <a href="local_ring" title="wikilink">local ring</a> satisfying the Henselian property for the maximal ideal <strong>m</strong> to be a <strong><a href="Henselian_ring" title="wikilink">Henselian ring</a></strong>.</p>

<p><a href="Masayoshi_Nagata" title="wikilink">Masayoshi Nagata</a> proved in the 1950s that for any commutative local ring <em>A</em> with maximal ideal <strong>m</strong> there always exists a smallest ring <em>A</em><sup>h</sup> containing <em>A</em> such that <em>A</em><sup>h</sup> is Henselian with respect to <strong>m</strong><em>A</em><sup>h</sup>. This <em>A</em><sup>h</sup> is called the <strong><a class="uri" href="Henselization" title="wikilink">Henselization</a></strong> of <em>A</em>. If <em>A</em> is <a href="noetherian_ring" title="wikilink">noetherian</a>, <em>A</em><sup>h</sup> will also be noetherian, and <em>A</em><sup>h</sup> is manifestly algebraic as it is constructed as a limit of <a href="étale_topology" title="wikilink">étale neighbourhoods</a>. This means that <em>A</em><sup>h</sup> is usually much smaller than the completion <em>Â</em> while still retaining the Henselian property and remaining in the same <a href="category_theory" title="wikilink">category</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Hasse–Minkowski_theorem" title="wikilink">Hasse–Minkowski theorem</a></li>
<li><a href="Newton_polygon" title="wikilink">Newton polygon</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Modular_arithmetic" title="wikilink">Category:Modular arithmetic</a> <a href="Category:Commutative_algebra" title="wikilink">Category:Commutative algebra</a> <a class="uri" href="Category:Lemmas" title="wikilink">Category:Lemmas</a></p>
</body>
</html>
