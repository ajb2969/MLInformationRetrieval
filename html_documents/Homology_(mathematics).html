<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="316">Homology (mathematics)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Homology (mathematics)</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a> (especially <a href="algebraic_topology" title="wikilink">algebraic topology</a> and <a href="abstract_algebra" title="wikilink">abstract algebra</a>), <strong>homology</strong> (in part from <a href="Greek_language" title="wikilink">Greek</a> ὁμός <em>homos</em> "identical") is a certain general procedure to associate a <a class="uri" href="sequence" title="wikilink">sequence</a> of <a href="abelian_group" title="wikilink">abelian groups</a> or <a href="module_(mathematics)" title="wikilink">modules</a> with a given mathematical object such as a <a href="topological_space" title="wikilink">topological space</a> or a <a href="group_(mathematics)" title="wikilink">group</a>. See <a href="singular_homology" title="wikilink">singular homology</a> for a concrete version for topological spaces, or <a href="group_cohomology" title="wikilink">group cohomology</a> for a concrete version for groups.</p>

<p>For a topological space, the homology groups are generally much easier to compute than the <a href="homotopy_group" title="wikilink">homotopy groups</a>, and consequently one usually will have an easier time working with homology to aid in the classification of spaces.</p>

<p>The original motivation for defining homology groups is the observation that shapes are distinguished by their <em>holes</em>. But because a hole is "not there", it is not immediately obvious how to define a hole, or how to distinguish between different kinds of holes. Homology is a rigorous mathematical method for defining and categorizing holes in a shape. As it turns out, subtle kinds of holes exist that homology cannot "see" — in which case homotopy groups may be what is needed.</p>
<h2 id="informal-examples">Informal examples</h2>

<p>Informally, the homology of a <a href="topological_space" title="wikilink">topological space</a> <em>X</em> is a set of <a href="Topological_property" title="wikilink">topological invariants</a> of <em>X</em> represented by its <em>homology groups</em></p>

<p>

<math display="block" id="Homology_(mathematics):0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>X</ci>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{0}(X),H_{1}(X),H_{2}(X),\ldots
  </annotation>
 </semantics>
</math>

</p>

<p>where the 

<math display="inline" id="Homology_(mathematics):1">
 <semantics>
  <msup>
   <mi>k</mi>
   <mi>th</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <ci>th</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{\rm th}
  </annotation>
 </semantics>
</math>

 homology group 

<math display="inline" id="Homology_(mathematics):2">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>k</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{k}(X)
  </annotation>
 </semantics>
</math>

 describes the <em>k</em>-dimensional holes in <em>X</em>. A 0-dimensional hole is simply a gap between two <a href="Connected_space#Connected_components" title="wikilink">components</a>, consequently 

<math display="inline" id="Homology_(mathematics):3">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mn>0</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{0}(X)
  </annotation>
 </semantics>
</math>

 describes the path-connected components of <em>X</em>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p> A one-dimensional <a class="uri" href="sphere" title="wikilink">sphere</a> 

<math display="inline" id="Homology_(mathematics):4">
 <semantics>
  <msup>
   <mi>S</mi>
   <mn>1</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>S</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{1}
  </annotation>
 </semantics>
</math>

 is a <a class="uri" href="circle" title="wikilink">circle</a>. It has a single connected component and a one-dimensional hole, but no higher-dimensional holes. The corresponding homology groups are given as</p>

<p>

<math display="block" id="Homology_(mathematics):5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>S</mi>
      <mn>1</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mi>ℤ</mi>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mi>k</mi>
        <mo>=</mo>
        <mrow>
         <mn>0</mn>
         <mo>,</mo>
         <mn>1</mn>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mo stretchy="false">{</mo>
        <mn>0</mn>
        <mo stretchy="false">}</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <ci>ℤ</ci>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <list>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </list>
     </apply>
     <set>
      <cn type="integer">0</cn>
     </set>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{k}(S^{1})=\begin{cases}\mathbb{Z}&k=0,1\\
\{0\}&\text{otherwise}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Homology_(mathematics):6">
 <semantics>
  <mi>ℤ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℤ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}
  </annotation>
 </semantics>
</math>

 is the group of integers and 

<math display="inline" id="Homology_(mathematics):7">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>0</mn>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">0</cn>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{0\}
  </annotation>
 </semantics>
</math>

 is the <a href="trivial_group" title="wikilink">trivial group</a>. The group 

<math display="inline" id="Homology_(mathematics):8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>S</mi>
      <mn>1</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}(S^{1})=\mathbb{Z}
  </annotation>
 </semantics>
</math>

 represents a <a href="finitely-generated_abelian_group" title="wikilink">finitely-generated abelian group</a>, with a single <a href="Generator_(groups)" title="wikilink">generator</a> representing the one-dimensional hole contained in a circle.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p> A two-dimensional <a class="uri" href="sphere" title="wikilink">sphere</a> 

<math display="inline" id="Homology_(mathematics):9">
 <semantics>
  <msup>
   <mi>S</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>S</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{2}
  </annotation>
 </semantics>
</math>

 has a single connected component, no one-dimensional holes, a two-dimensional hole, and no higher-dimensional holes. The corresponding homology groups are<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>

<math display="block" id="Homology_(mathematics):10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>S</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mi>ℤ</mi>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mi>k</mi>
        <mo>=</mo>
        <mrow>
         <mn>0</mn>
         <mo>,</mo>
         <mn>2</mn>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mo stretchy="false">{</mo>
        <mn>0</mn>
        <mo stretchy="false">}</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <ci>ℤ</ci>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <list>
       <cn type="integer">0</cn>
       <cn type="integer">2</cn>
      </list>
     </apply>
     <set>
      <cn type="integer">0</cn>
     </set>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{k}(S^{2})=\begin{cases}\mathbb{Z}&k=0,2\\
\{0\}&\text{otherwise}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>In general for an <em>n</em>-dimensional sphere <em>S<sup>n</sup></em>, the homology groups are</p>

<p>

<math display="block" id="Homology_(mathematics):11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>S</mi>
      <mi>n</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mi>ℤ</mi>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mi>k</mi>
        <mo>=</mo>
        <mrow>
         <mn>0</mn>
         <mo>,</mo>
         <mi>n</mi>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mo stretchy="false">{</mo>
        <mn>0</mn>
        <mo stretchy="false">}</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <ci>ℤ</ci>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <list>
       <cn type="integer">0</cn>
       <ci>n</ci>
      </list>
     </apply>
     <set>
      <cn type="integer">0</cn>
     </set>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{k}(S^{n})=\begin{cases}\mathbb{Z}&k=0,n\\
\{0\}&\text{otherwise}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p> A one-dimensional <a href="Ball_(mathematics)" title="wikilink">ball</a> <em>B</em><sup>1</sup> is a solid disc. It has a single path-connected component, but in contrast to the circle, has no one-dimensional or higher-dimensional holes. The corresponding homology groups are all trivial except for 

<math display="inline" id="Homology_(mathematics):12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>B</mi>
      <mn>1</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{0}(B^{1})=\mathbb{Z}
  </annotation>
 </semantics>
</math>

. In general, for an <em>n</em>-dimensional ball <em>B<sup>n</sup></em>,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>

<math display="block" id="Homology_(mathematics):13">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>B</mi>
      <mi>n</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mi>ℤ</mi>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mi>k</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mo stretchy="false">{</mo>
        <mn>0</mn>
        <mo stretchy="false">}</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <ci>ℤ</ci>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">0</cn>
     </apply>
     <set>
      <cn type="integer">0</cn>
     </set>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{k}(B^{n})=\begin{cases}\mathbb{Z}&k=0\\
\{0\}&\text{otherwise}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p> The <a class="uri" href="torus" title="wikilink">torus</a> is defined as a <a href="Cartesian_product" title="wikilink">Cartesian product</a> of two circles 

<math display="inline" id="Homology_(mathematics):14">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>S</mi>
     <mn>1</mn>
    </msup>
    <mo>×</mo>
    <msup>
     <mi>S</mi>
     <mn>1</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=S^{1}\times S^{1}
  </annotation>
 </semantics>
</math>

. The torus has a single path-connected component, two independent one-dimensional holes (indicated by circles in red and blue) and one two-dimensional hole as the interior of the torus. The corresponding homology groups are<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>

<math display="block" id="Homology_(mathematics):15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mi>ℤ</mi>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mi>k</mi>
        <mo>=</mo>
        <mrow>
         <mn>0</mn>
         <mo>,</mo>
         <mn>2</mn>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>ℤ</mi>
        <mo>×</mo>
        <mi>ℤ</mi>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mi>k</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mo stretchy="false">{</mo>
        <mn>0</mn>
        <mo stretchy="false">}</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>k</ci>
     </apply>
     <ci>T</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <ci>ℤ</ci>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <list>
       <cn type="integer">0</cn>
       <cn type="integer">2</cn>
      </list>
     </apply>
     <apply>
      <times></times>
      <ci>ℤ</ci>
      <ci>ℤ</ci>
     </apply>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
     <set>
      <cn type="integer">0</cn>
     </set>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{k}(T)=\begin{cases}\mathbb{Z}&k=0,2\\
\mathbb{Z}\times\mathbb{Z}&k=1\\
\{0\}&\text{otherwise}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>The two independent 1D holes form independent generators in a finitely-generated abelian group, expressed as the Cartesian product group 

<math display="inline" id="Homology_(mathematics):16">
 <semantics>
  <mrow>
   <mi>ℤ</mi>
   <mo>×</mo>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ℤ</ci>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}\times\mathbb{Z}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="history">History</h2>

<p>Homology theory can be said to start with the Euler polyhedron formula, or <a href="Euler_characteristic" title="wikilink">Euler characteristic</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> This was followed by Riemann's definition of genus and <em>n</em>-fold connectedness numerical invariants in 1857 and Betti's proof in 1871 of the independence of "homology numbers" from the choice of basis.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>A recognisable theory of homology, including homology classes and relations, was first introduced by <a href="Henri_Poincaré" title="wikilink">Henri Poincaré</a> in his seminal paper "<a href="Analysis_Situs_(paper)" title="wikilink">Analysis situs</a>", <em>J. Ecole polytech.</em> (2) <strong>1</strong>. 1–121 (1895). Poincaré was also the first to consider the simplicial homology of a triangulated manifold and to create what is now called a chain complex. Homology remains the primary method of classifying <a href="manifold" title="wikilink">manifolds</a>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>The homology group was further developed by <a href="Emmy_Noether" title="wikilink">Emmy Noether</a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> and, independently, by <a href="Leopold_Vietoris" title="wikilink">Leopold Vietoris</a> and <a href="Walther_Mayer" title="wikilink">Walther Mayer</a>, in the period 1925–28.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Prior to this, topological classes in <a href="combinatorial_topology" title="wikilink">combinatorial topology</a> were not formally considered as <a href="abelian_group" title="wikilink">abelian groups</a>. The spread of homology groups marked the change of terminology and viewpoint from "combinatorial topology" to "algebraic topology".<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="construction-of-homology-groups">Construction of homology groups</h2>

<p>The construction begins with an object such as a topological space <em>X</em>, on which one first defines a <em><a href="chain_complex" title="wikilink">chain complex</a></em> <em>C(X)</em> encoding information about <em>X</em>. A chain complex is a sequence of abelian groups or modules <em>C</em><sub>0</sub>, <em>C</em><sub>1</sub>, <em>C</em><sub>2</sub>, ... connected by <a href="group_homomorphism" title="wikilink">homomorphisms</a> 

<math display="inline" id="Homology_(mathematics):17">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>∂</mo>
     <mi>n</mi>
    </msub>
    <mo>:</mo>
    <mrow>
     <msub>
      <mi>C</mi>
      <mi>n</mi>
     </msub>
     <mo>→</mo>
     <msub>
      <mi>C</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <partialdiff></partialdiff>
     <ci>n</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial_{n}:C_{n}\to C_{n-1},
  </annotation>
 </semantics>
</math>

 which are called <strong>boundary operators</strong>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> That is,</p>

<p>

<math display="block" id="Homology_(mathematics):18">
 <semantics>
  <mrow>
   <mi mathvariant="normal">⋯</mi>
   <mover accent="true">
    <mo rspace="4.2pt">⟶</mo>
    <msub>
     <mo>∂</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mover>
   <msub>
    <mi>C</mi>
    <mi>n</mi>
   </msub>
   <mover accent="true">
    <mo rspace="4.2pt">⟶</mo>
    <msub>
     <mo>∂</mo>
     <mi>n</mi>
    </msub>
   </mover>
   <msub>
    <mi>C</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mover accent="true">
    <mo rspace="4.2pt">⟶</mo>
    <msub>
     <mo>∂</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mover>
   <mi mathvariant="normal">⋯</mi>
   <mover accent="true">
    <mo rspace="4.2pt">⟶</mo>
    <msub>
     <mo>∂</mo>
     <mn>2</mn>
    </msub>
   </mover>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
   <mover accent="true">
    <mo rspace="4.2pt">⟶</mo>
    <msub>
     <mo>∂</mo>
     <mn>1</mn>
    </msub>
   </mover>
   <msub>
    <mi>C</mi>
    <mn>0</mn>
   </msub>
   <mover accent="true">
    <mo rspace="4.2pt">⟶</mo>
    <msub>
     <mo>∂</mo>
     <mn>0</mn>
    </msub>
   </mover>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-⋯</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-⟶</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <ci>n</ci>
     </apply>
     <ci>normal-⟶</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-⟶</ci>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⟶</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⟶</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-⟶</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdots\overset{\partial_{n+1}}{\longrightarrow\,}C_{n}\overset{\partial_{n}}{%
\longrightarrow\,}C_{n-1}\overset{\partial_{n-1}}{\longrightarrow\,}\cdots%
\overset{\partial_{2}}{\longrightarrow\,}C_{1}\overset{\partial_{1}}{%
\longrightarrow\,}C_{0}\overset{\partial_{0}}{\longrightarrow\,}0
  </annotation>
 </semantics>
</math>

</p>

<p>where 0 denotes the trivial group and 

<math display="inline" id="Homology_(mathematics):19">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>i</mi>
   </msub>
   <mo>≡</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}\equiv 0
  </annotation>
 </semantics>
</math>

 for <em>i</em>  \partial_n \circ \partial_{n+1} = 0_{n+1,n-1},</p>

<p>i.e., the constant map sending every element of <em>C</em><sub><em>n</em>+1</sub> to the group identity in <em>C</em><sub><em>n</em> - 1</sub>. That the boundary of a boundary is trivial implies 

<math display="inline" id="Homology_(mathematics):20">
 <semantics>
  <mrow>
   <mrow>
    <mi>im</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mo>∂</mo>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⊆</mo>
   <mrow>
    <mi>ker</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mo>∂</mo>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <ci>im</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">kernel</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{im}(\partial_{n+1})\subseteq\ker(\partial_{n})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Homology_(mathematics):21">
 <semantics>
  <mrow>
   <mi>im</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mo>∂</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>im</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <partialdiff></partialdiff>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{im}(\partial_{n+1})
  </annotation>
 </semantics>
</math>

 denotes the <a href="image_(mathematics)" title="wikilink">image</a> of the boundary operator and 

<math display="inline" id="Homology_(mathematics):22">
 <semantics>
  <mrow>
   <mi>ker</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mo>∂</mo>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">kernel</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <partialdiff></partialdiff>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ker(\partial_{n})
  </annotation>
 </semantics>
</math>

 its <a href="kernel_(algebra)" title="wikilink">kernel</a>. Elements of 

<math display="inline" id="Homology_(mathematics):23">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>B</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>im</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mo>∂</mo>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <ci>n</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <ci>im</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{n}(X)=\mathrm{im}(\partial_{n+1})
  </annotation>
 </semantics>
</math>

 are called <strong>boundaries</strong> and elements of 

<math display="inline" id="Homology_(mathematics):24">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Z</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ker</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mo>∂</mo>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <ci>n</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">kernel</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <partialdiff></partialdiff>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{n}(X)=\ker(\partial_{n})
  </annotation>
 </semantics>
</math>

 are called <strong>cycles</strong>.</p>

<p>Since each chain group <em>C<sub>n</sub></em> is abelian all its subgroups are normal. Then because 

<math display="inline" id="Homology_(mathematics):25">
 <semantics>
  <mrow>
   <mi>im</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mo>∂</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>im</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <partialdiff></partialdiff>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{im}(\partial_{n+1})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Homology_(mathematics):26">
 <semantics>
  <mrow>
   <mi>ker</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mo>∂</mo>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">kernel</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <partialdiff></partialdiff>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ker(\partial_{n})
  </annotation>
 </semantics>
</math>

 are both subgroups of <em>C<sub>n</sub></em>, 

<math display="inline" id="Homology_(mathematics):27">
 <semantics>
  <mrow>
   <mi>im</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mo>∂</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>im</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <partialdiff></partialdiff>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{im}(\partial_{n+1})
  </annotation>
 </semantics>
</math>

 is a <a href="normal_subgroup" title="wikilink">normal subgroup</a> of 

<math display="inline" id="Homology_(mathematics):28">
 <semantics>
  <mrow>
   <mi>ker</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mo>∂</mo>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">kernel</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <partialdiff></partialdiff>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ker(\partial_{n})
  </annotation>
 </semantics>
</math>

. Then one can create the <a href="quotient_group" title="wikilink">quotient group</a></p>

<p>

<math display="block" id="Homology_(mathematics):29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>H</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>:=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>ker</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mo>∂</mo>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>/</mo>
      <mi>im</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mo>∂</mo>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mi>Z</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>/</mo>
      <msub>
       <mi>B</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>n</ci>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="latexml">kernel</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <partialdiff></partialdiff>
         <ci>n</ci>
        </apply>
       </apply>
       <ci>im</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <partialdiff></partialdiff>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Z</ci>
         <ci>n</ci>
        </apply>
        <ci>X</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{n}(X):=\ker(\partial_{n})/\mathrm{im}(\partial_{n+1})=Z_{n}(X)/B_{n}(X),
  </annotation>
 </semantics>
</math>

</p>

<p>called the <strong><em>n</em>-th homology group of <em>X</em></strong>. The elements of <em>H<sub>n</sub>(X)</em> are called <strong>homology classes</strong>. Each homology class is an equivalence class over cycles and two cycles in the same homology class are said to be <strong>homologous</strong>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>A chain complex is said to be <a href="exact_sequence" title="wikilink">exact</a> if the image of the (<em>n</em> + 1)-th map is always equal to the kernel of the <em>n</em>-th map. The homology groups of <em>X</em> therefore measure "how far" the chain complex associated to <em>X</em> is from being exact.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>The <a href="reduced_homology" title="wikilink">reduced homology groups</a> of a chain complex <em>C(X)</em> are defined as homologies of the augmented chain complex<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>

<math display="block" id="Homology_(mathematics):30">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">⋯</mi>
    <mover accent="true">
     <mo rspace="4.2pt">⟶</mo>
     <msub>
      <mo>∂</mo>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mover>
    <msub>
     <mi>C</mi>
     <mi>n</mi>
    </msub>
    <mover accent="true">
     <mo rspace="4.2pt">⟶</mo>
     <msub>
      <mo>∂</mo>
      <mi>n</mi>
     </msub>
    </mover>
    <msub>
     <mi>C</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mover accent="true">
     <mo rspace="4.2pt">⟶</mo>
     <msub>
      <mo>∂</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mover>
    <mi mathvariant="normal">⋯</mi>
    <mover accent="true">
     <mo rspace="4.2pt">⟶</mo>
     <msub>
      <mo>∂</mo>
      <mn>2</mn>
     </msub>
    </mover>
    <msub>
     <mi>C</mi>
     <mn>1</mn>
    </msub>
    <mover accent="true">
     <mo rspace="4.2pt">⟶</mo>
     <msub>
      <mo>∂</mo>
      <mn>1</mn>
     </msub>
    </mover>
    <msub>
     <mi>C</mi>
     <mn>0</mn>
    </msub>
    <mover accent="true">
     <mo rspace="4.2pt">⟶</mo>
     <mo mathvariant="italic">ϵ</mo>
    </mover>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\Z</mtext>
    </merror>
   </mrow>
   <mo>⟶</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⟶</ci>
    <apply>
     <times></times>
     <ci>normal-⋯</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <partialdiff></partialdiff>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-⟶</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <partialdiff></partialdiff>
       <ci>n</ci>
      </apply>
      <ci>normal-⟶</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <partialdiff></partialdiff>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-⟶</ci>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <partialdiff></partialdiff>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-⟶</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <partialdiff></partialdiff>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-⟶</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <ci>ϵ</ci>
      <ci>normal-⟶</ci>
     </apply>
     <mtext>\Z</mtext>
    </apply>
    <cn type="float">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdots\overset{\partial_{n+1}}{\longrightarrow\,}C_{n}\overset{\partial_{n}}{%
\longrightarrow\,}C_{n-1}\overset{\partial_{n-1}}{\longrightarrow\,}\cdots%
\overset{\partial_{2}}{\longrightarrow\,}C_{1}\overset{\partial_{1}}{%
\longrightarrow\,}C_{0}\overset{\epsilon}{\longrightarrow\,}\Z{\longrightarrow%
\,}0
  </annotation>
 </semantics>
</math>

</p>

<p>where the boundary operator 

<math display="inline" id="Homology_(mathematics):31">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="block" id="Homology_(mathematics):32">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϵ</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mi>i</mi>
      </munder>
      <mrow>
       <msub>
        <mi>n</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>σ</mi>
        <mi>i</mi>
       </msub>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <msub>
     <mi>n</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ϵ</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon\left(\sum_{i}n_{i}\sigma_{i}\right)=\sum_{i}n_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>for a combination <em>Σ n<sub>i</sub>σ<sub>i</sub></em> of points σ<sub>i</sub>, which are the fixed generators of <em>C<sub>0</sub></em>. The reduced homology groups 

<math display="inline" id="Homology_(mathematics):33">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>H</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>H</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{H}_{i}(X)
  </annotation>
 </semantics>
</math>

 coincide with 

<math display="inline" id="Homology_(mathematics):34">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>i</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{i}(X)
  </annotation>
 </semantics>
</math>

 for <em>i</em> ≠ 0. The extra 

<math display="inline" id="Homology_(mathematics):35">
 <semantics>
  <merror class="ltx_ERROR undefined undefined">
   <mtext>\Z</mtext>
  </merror>
  <annotation-xml encoding="MathML-Content">
   <mtext>\Z</mtext>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Z
  </annotation>
 </semantics>
</math>

 in the chain complex represents the unique map 

<math display="inline" id="Homology_(mathematics):36">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi mathvariant="normal">∅</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>⟶</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⟶</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <emptyset></emptyset>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\emptyset]\longrightarrow X
  </annotation>
 </semantics>
</math>

 from the empty simplex to <em>X</em>.</p>

<p>Computing the cycle 

<math display="inline" id="Homology_(mathematics):37">
 <semantics>
  <mrow>
   <msub>
    <mi>Z</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Z</ci>
     <ci>n</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{n}(X)
  </annotation>
 </semantics>
</math>

 and boundary 

<math display="inline" id="Homology_(mathematics):38">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>n</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{n}(X)
  </annotation>
 </semantics>
</math>

 groups is usually rather difficult since they have a very large number of generators. On the other hand, there are tools which make the task easier.</p>

<p>The <em><a href="simplicial_homology" title="wikilink">simplicial homology</a></em> groups <em>H<sub>n</sub>(X)</em> of a <em><a href="simplicial_complex" title="wikilink">simplicial complex</a></em> <em>X</em> are defined using the simplicial chain complex <em>C(X)</em>, with <em>C(X)<sub>n</sub></em> the <a href="free_abelian_group" title="wikilink">free abelian group</a> generated by the <em>n</em>-simplices of <em>X</em>. The <em><a href="singular_homology" title="wikilink">singular homology</a></em> groups <em>H<sub>n</sub>(X)</em> are defined for any topological space <em>X</em>, and agree with the simplicial homology groups for a simplicial complex.</p>

<p>Cohomology groups are formally similar to homology groups: one starts with a <a href="cochain_complex" title="wikilink">cochain complex</a>, which is the same as a chain complex but whose arrows, now denoted <em>d<sup>n</sup></em> point in the direction of increasing <em>n</em> rather than decreasing <em>n</em>; then the groups 

<math display="inline" id="Homology_(mathematics):39">
 <semantics>
  <mrow>
   <mrow>
    <mi>ker</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>d</mi>
      <mi>n</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>Z</mi>
     <mi>n</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">kernel</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>d</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Z</ci>
      <ci>n</ci>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ker(d^{n})=Z^{n}(X)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Homology_(mathematics):40">
 <semantics>
  <mrow>
   <mrow>
    <mi>im</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>d</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>B</mi>
     <mi>n</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>im</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>d</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>n</ci>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{im}(d^{n-1})=B^{n}(X)
  </annotation>
 </semantics>
</math>

 follow from the same description. The <em>n</em>-th cohomology group of <em>X</em> is then the quotient group</p>

<p>

<math display="block" id="Homology_(mathematics):41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>H</mi>
      <mi>n</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <msup>
        <mi>Z</mi>
        <mi>n</mi>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>/</mo>
      <msup>
       <mi>B</mi>
       <mi>n</mi>
      </msup>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <ci>n</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Z</ci>
        <ci>n</ci>
       </apply>
       <ci>X</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{n}(X)=Z^{n}(X)/B^{n}(X),
  </annotation>
 </semantics>
</math>

</p>

<p>in analogy with the <em>n</em>-th homology group.</p>
<h2 id="types-of-homology">Types of homology</h2>

<p>The different types of homology theory arise from functors mapping from various categories of mathematical objects to the category of chain complexes. In each case the composition of the functor from objects to chain complexes and the functor from chain complexes to homology groups defines the overall homology functor for the theory.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h3 id="simplicial-homology">Simplicial homology</h3>

<p>The motivating example comes from <a href="algebraic_topology" title="wikilink">algebraic topology</a>: the <strong><a href="simplicial_homology" title="wikilink">simplicial homology</a></strong> of a <a href="simplicial_complex" title="wikilink">simplicial complex</a> <em>X</em>. Here <em>A<sub>n</sub></em> is the <a href="free_abelian_group" title="wikilink">free abelian group</a> or module whose generators are the <em>n</em>-dimensional oriented simplexes of <em>X</em>. The mappings are called the <em>boundary mappings</em> and send the simplex with <a href="vertex_(geometry)" title="wikilink">vertices</a></p>

<p>

<math display="block" id="Homology_(mathematics):42">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>1</mn>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <times></times>
     <ci>a</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>a</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <ci>a</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a[0],a[1],\dots,a[n])
  </annotation>
 </semantics>
</math>

</p>

<p>to the sum</p>

<p>

<math display="block" id="Homology_(mathematics):43">
 <semantics>
  <mrow>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mi>n</mi>
   </munderover>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>i</mi>
    </msup>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mn>0</mn>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>i</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>n</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <ci>i</ci>
     </apply>
     <vector>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>n</ci>
       </apply>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=0}^{n}(-1)^{i}\left(a[0],\dots,a[i-1],a[i+1],\dots,a[n]\right)
  </annotation>
 </semantics>
</math>

</p>

<p>(which is considered 0 if <em>n</em> = 0).</p>

<p>If we take the modules to be over a field, then the dimension of the <em>n</em>-th homology of <em>X</em> turns out to be the number of "holes" in <em>X</em> at dimension <em>n</em>. It may be computed by putting <a href="Matrix_(mathematics)" title="wikilink">matrix</a> representations of these boundary mappings in <a href="Smith_normal_form" title="wikilink">Smith normal form</a>.</p>
<h3 id="singular-homology">Singular homology</h3>

<p>Using simplicial homology example as a model, one can define a <em>singular homology</em> for any <a href="topological_space" title="wikilink">topological space</a> <em>X</em>. A chain complex for <em>X</em> is defined by taking <em>A<sub>n</sub></em> to be the free abelian group (or free module) whose generators are all <a href="continuous_function_(topology)" title="wikilink">continuous</a> maps from <em>n</em>-dimensional <a href="simplex" title="wikilink">simplices</a> into <em>X</em>. The homomorphisms ∂<sub><em>n</em></sub> arise from the boundary maps of simplices.</p>
<h3 id="group-homology">Group homology</h3>

<p>In <a href="abstract_algebra" title="wikilink">abstract algebra</a>, one uses homology to define <a href="derived_functor" title="wikilink">derived functors</a>, for example the <a href="Tor_functor" title="wikilink">Tor functors</a>. Here one starts with some covariant additive functor <em>F</em> and some module <em>X</em>. The chain complex for <em>X</em> is defined as follows: first find a free module <em>F</em><sub>1</sub> and a <a class="uri" href="surjective" title="wikilink">surjective</a> homomorphism <em>p</em><sub>1</sub> : <em>F</em><sub>1</sub> → <em>X</em>. Then one finds a free module <em>F</em><sub>2</sub> and a surjective homomorphism <em>p</em><sub>2</sub> : <em>F</em><sub>2</sub> → ker(<em>p</em><sub>1</sub>). Continuing in this fashion, a sequence of free modules <em>F<sub>n</sub></em> and homomorphisms <em>p<sub>n</sub></em> can be defined. By applying the functor <em>F</em> to this sequence, one obtains a chain complex; the homology <em>H<sub>n</sub></em> of this complex depends only on <em>F</em> and <em>X</em> and is, by definition, the <em>n</em>-th derived functor of <em>F</em>, applied to <em>X</em>.</p>
<h3 id="other-homology-theories">Other homology theories</h3>
<ul>
<li><a href="Borel–Moore_homology" title="wikilink">Borel–Moore homology</a></li>
<li><a href="Cellular_homology" title="wikilink">Cellular homology</a></li>
<li><a href="Cyclic_homology" title="wikilink">Cyclic homology</a></li>
<li><a href="Hochschild_homology" title="wikilink">Hochschild homology</a></li>
<li><a href="Floer_homology" title="wikilink">Floer homology</a></li>
<li><a href="Intersection_homology" title="wikilink">Intersection homology</a></li>
<li><a class="uri" href="K-homology" title="wikilink">K-homology</a></li>
<li><a href="Khovanov_homology" title="wikilink">Khovanov homology</a></li>
<li><a href="Morse_homology" title="wikilink">Morse homology</a></li>
<li><a href="Persistent_homology" title="wikilink">Persistent homology</a></li>
<li><a href="Steenrod_homology" title="wikilink">Steenrod homology</a></li>
</ul>
<h2 id="homology-functors">Homology functors</h2>

<p>Chain complexes form a <a href="category_(mathematics)" title="wikilink">category</a>: A morphism from the chain complex (<em>d<sub>n</sub></em>: <em>A<sub>n</sub></em> → <em>A</em><sub><em>n</em>-1</sub>) to the chain complex (<em>e<sub>n</sub></em>: <em>B<sub>n</sub></em> → <em>B</em><sub><em>n</em>-1</sub>) is a sequence of homomorphisms <em>f<sub>n</sub></em>: <em>A<sub>n</sub></em> → <em>B<sub>n</sub></em> such that 

<math display="inline" id="Homology_(mathematics):44">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>∘</mo>
    <msub>
     <mi>d</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>e</mi>
     <mi>n</mi>
    </msub>
    <mo>∘</mo>
    <msub>
     <mi>f</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{n-1}\circ d_{n}=e_{n}\circ f_{n}
  </annotation>
 </semantics>
</math>

 for all <em>n</em>. The <em>n</em>-th homology <em>H<sub>n</sub></em> can be viewed as a covariant <a class="uri" href="functor" title="wikilink">functor</a> from the category of chain complexes to the category of abelian groups (or modules).</p>

<p>If the chain complex depends on the object <em>X</em> in a covariant manner (meaning that any morphism <em>X → Y</em> induces a morphism from the chain complex of <em>X</em> to the chain complex of <em>Y</em>), then the <em>H<sub>n</sub></em> are covariant <a href="functor" title="wikilink">functors</a> from the category that <em>X</em> belongs to into the category of abelian groups (or modules).</p>

<p>The only difference between homology and <a class="uri" href="cohomology" title="wikilink">cohomology</a> is that in cohomology the chain complexes depend in a <em>contravariant</em> manner on <em>X</em>, and that therefore the homology groups (which are called <em>cohomology groups</em> in this context and denoted by <em>H<sup>n</sup></em>) form <em>contravariant</em> functors from the category that <em>X</em> belongs to into the category of abelian groups or modules.</p>
<h2 id="properties">Properties</h2>

<p>If (<em>d<sub>n</sub></em>: <em>A<sub>n</sub></em> → <em>A</em><sub><em>n</em>-1</sub>) is a chain complex such that all but finitely many <em>A<sub>n</sub></em> are zero, and the others are finitely generated abelian groups (or finite-dimensional vector spaces), then we can define the <em><a href="Euler_characteristic" title="wikilink">Euler characteristic</a></em></p>

<p>

<math display="block" id="Homology_(mathematics):45">
 <semantics>
  <mrow>
   <mi>χ</mi>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>n</mi>
      </msup>
     </mpadded>
     <mi>rank</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>A</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>χ</ci>
    <apply>
     <sum></sum>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <ci>n</ci>
      </apply>
      <ci>rank</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi=\sum(-1)^{n}\,\mathrm{rank}(A_{n})
  </annotation>
 </semantics>
</math>

</p>

<p>(using the <a href="rank_of_an_abelian_group" title="wikilink">rank</a> in the case of abelian groups and the <a href="Hamel_dimension" title="wikilink">Hamel dimension</a> in the case of vector spaces). It turns out that the Euler characteristic can also be computed on the level of homology:</p>

<p>

<math display="block" id="Homology_(mathematics):46">
 <semantics>
  <mrow>
   <mi>χ</mi>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>n</mi>
      </msup>
     </mpadded>
     <mi>rank</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>H</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>χ</ci>
    <apply>
     <sum></sum>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <ci>n</ci>
      </apply>
      <ci>rank</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi=\sum(-1)^{n}\,\mathrm{rank}(H_{n})
  </annotation>
 </semantics>
</math>

</p>

<p>and, especially in algebraic topology, this provides two ways to compute the important invariant χ for the object <em>X</em> which gave rise to the chain complex.</p>

<p>Every <a href="short_exact_sequence" title="wikilink">short exact sequence</a></p>

<p>

<math display="block" id="Homology_(mathematics):47">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>→</mo>
   <mi>A</mi>
   <mo>→</mo>
   <mi>B</mi>
   <mo>→</mo>
   <mi>C</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <cn type="integer">0</cn>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>B</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>C</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\rightarrow A\rightarrow B\rightarrow C\rightarrow 0
  </annotation>
 </semantics>
</math>

</p>

<p>of chain complexes gives rise to a <a href="long_exact_sequence" title="wikilink">long exact sequence</a> of homology groups</p>

<p>

<math display="block" id="Homology_(mathematics):48">
 <semantics>
  <mrow>
   <mi mathvariant="normal">⋯</mi>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mi mathvariant="normal">⋯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>n</ci>
      </apply>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>n</ci>
      </apply>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>n</ci>
      </apply>
      <ci>C</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>C</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdots\to H_{n}(A)\to H_{n}(B)\to H_{n}(C)\to H_{n-1}(A)\to H_{n-1}(B)\to H_{n%
-1}(C)\to H_{n-2}(A)\to\cdots
  </annotation>
 </semantics>
</math>

</p>

<p>All maps in this long exact sequence are induced by the maps between the chain complexes, except for the maps <em>H<sub>n</sub>(C)</em> → <em>H</em><sub><em>n</em>-1</sub><em>(A)</em> The latter are called <em>connecting homomorphisms</em> and are provided by the <a href="zig-zag_lemma" title="wikilink">zig-zag lemma</a>. This lemma can be applied to homology in numerous ways that aid in calculating homology groups, such as the theories of <em>relative homology</em> and <em>Mayer-Vietoris sequences</em>.</p>
<h2 id="applications">Applications</h2>

<p>Notable theorems proved using homology include the following:</p>
<ul>
<li>The <a href="Brouwer_fixed_point_theorem" title="wikilink">Brouwer fixed point theorem</a>: If <em>f</em> is any continuous map from the ball <em>B<sup>n</sup></em> to itself, then there is a fixed point <em>a</em> ∈ <em>B<sup>n</sup></em> with <em>f</em>(<em>a</em>) = <em>a</em>.</li>
<li><a href="Invariance_of_domain" title="wikilink">Invariance of domain</a>: If <em>U</em> is an <a href="open_set" title="wikilink">open subset</a> of <strong>R</strong><sup><em>n</em></sup> and <em>f</em> : <em>U</em> → <strong>R</strong><sup><em>n</em></sup> is an <a class="uri" href="injective" title="wikilink">injective</a> <a href="continuous_map" title="wikilink">continuous map</a>, then <em>V</em> = <em>f</em>(<em>U</em>) is open and <em>f</em> is a <a class="uri" href="homeomorphism" title="wikilink">homeomorphism</a> between <em>U</em> and <em>V</em>.</li>
<li>The <a href="Hairy_ball_theorem" title="wikilink">Hairy ball theorem</a>: any vector field on the 2-sphere (or more generally, the 2<em>k</em>-sphere for any <em>k</em> ≥ 1) vanishes at some point.</li>
<li>The <a href="Borsuk–Ulam_theorem" title="wikilink">Borsuk–Ulam theorem</a>: any <a href="continuous_function" title="wikilink">continuous function</a> from an <a href="n-sphere" title="wikilink"><em>n</em>-sphere</a> into <a href="Euclidean_space" title="wikilink">Euclidean <em>n</em>-space</a> maps some pair of <a href="antipodal_point" title="wikilink">antipodal points</a> to the same point. (Two points on a sphere are called antipodal if they are in exactly opposite directions from the sphere's center.)</li>
</ul>
<h3 id="application-in-science-and-engineering">Application in science and engineering</h3>

<p>In <a href="topological_data_analysis" title="wikilink">topological data analysis</a>, data sets are regarded as a <a href="point_cloud" title="wikilink">point cloud</a> sampling of a manifold or <a href="algebraic_variety" title="wikilink">algebraic variety</a> embedded in <a href="Euclidean_space" title="wikilink">Euclidean space</a>. By linking nearest neighbor points in the cloud into a triangulation, a simplicial approximation of the manifold is created and its simplicial homology may be calculated. Finding techniques to robustly calculate homology using various triangulation strategies over multiple length scales is the topic of <a href="persistent_homology" title="wikilink">persistent homology</a>.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>In <a href="sensor_network" title="wikilink">sensor networks</a>, sensors may communicate information via an ad-hoc network that dynamically changes in time. To understand the global context of this set of local measurements and communication paths, it is useful to compute the homology of the <a href="network_topology" title="wikilink">network topology</a> to evaluate, for instance, holes in coverage.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>

<p>In <a href="dynamical_system" title="wikilink">dynamical systems</a> theory in <a class="uri" href="physics" title="wikilink">physics</a>, Poincaré was one of the first to consider the interplay between the <a href="invariant_manifold" title="wikilink">invariant manifold</a> of a dynamical system and its topological invariants. <a href="Morse_theory" title="wikilink">Morse theory</a> relates the dynamics of a gradient flow on a manifold to, for example, its homology. <a href="Floer_homology" title="wikilink">Floer homology</a> extended this to infinite-dimensional manifolds. The <a href="KAM_theorem" title="wikilink">KAM theorem</a> established that <a href="periodic_orbit" title="wikilink">periodic orbits</a> can follow complex trajectories; in particular, they may form <a href="Braid_theory" title="wikilink">braids</a> that can be investigated using Floer homology.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>

<p>In one class of <a href="finite_element_methods" title="wikilink">finite element methods</a>, <a href="boundary-value_problem" title="wikilink">boundary-value problems</a> for differential equations involving the <a href="Hodge-Laplace_operator" title="wikilink">Hodge-Laplace operator</a> may need to be solved on topologically nontrivial domains, for example, in <a href="Computational_electromagnetics" title="wikilink">electromagnetic simulations</a>. In these simulations, solution is aided by fixing the <a href="cohomology_class" title="wikilink">cohomology class</a> of the solution based on the chosen boundary conditions and the homology of the domain. FEM domains can be triangulated, from which the simplicial homology can be calculated.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>
<h2 id="software">Software</h2>

<p>Various software packages have been developed for the purposes of computing homology groups of finite cell complexes. <a href="http://linalg.org">Linbox</a> is a <a class="uri" href="C++" title="wikilink">C++</a> library for performing fast matrix operations, including <a href="Smith_normal_form" title="wikilink">Smith normal form</a>; it interfaces with both <a href="http://www.gap-system.org">Gap</a> and <a href="http://www.maplesoft.com">Maple</a>. <a href="http://chomp.rutgers.edu">Chomp</a>, <a href="http://redhom.ii.uj.edu.pl">CAPD::Redhom</a> and <a href="http://www.sas.upenn.edu/~vnanda/perseus">Perseus</a> are also written in C++. All three implement pre-processing algorithms based on <a href="Simple-homotopy_equivalence" title="wikilink">Simple-homotopy equivalence</a> and <a href="discrete_Morse_theory" title="wikilink">discrete Morse theory</a> to perform homology-preserving reductions of the input cell complexes before resorting to matrix algebra. <a href="http://www-fourier.ujf-grenoble.fr/~sergerar/Kenzo/">Kenzo</a> is written in Lisp, and in addition to homology it may also be used to generate <a href="Presentation_of_a_group" title="wikilink">presentations</a> of <a class="uri" href="homotopy" title="wikilink">homotopy</a> groups of finite simplicial complexes. <a class="uri" href="Gmsh" title="wikilink">Gmsh</a> includes a homology solver for finite element meshes, which can generate <a class="uri" href="Cohomology" title="wikilink">Cohomology</a> bases directly usable by finite element software.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Betti_number" title="wikilink">Betti number</a></li>
<li><a href="Cycle_space" title="wikilink">Cycle space</a></li>
<li><a href="Eilenberg–Steenrod_axioms" title="wikilink">Eilenberg–Steenrod axioms</a></li>
<li><a href="Extraordinary_homology_theory" title="wikilink">Extraordinary homology theory</a></li>
<li><a href="Homological_algebra" title="wikilink">Homological algebra</a></li>
<li><a href="Homological_conjectures_in_commutative_algebra" title="wikilink">Homological conjectures in commutative algebra</a></li>
<li><a href="Homological_dimension_(disambiguation)" title="wikilink">Homological dimension (disambiguation)</a></li>
<li><a href="Künneth_theorem" title="wikilink">Künneth theorem</a></li>
<li><a href="List_of_cohomology_theories" title="wikilink">List of cohomology theories</a> - also has a list of homology theories</li>
<li><a href="Torsion_coefficient_(topology)" title="wikilink">Torsion coefficient</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li><a href="Henri_Cartan" title="wikilink">Cartan, Henri Paul</a> and <a href="Samuel_Eilenberg" title="wikilink">Eilenberg, Samuel</a> (1956) <em>Homological Algebra</em> Princeton University Press, Princeton, NJ, <a href="http://worldcat.org/oclc/529171">OCLC 529171</a></li>
<li>Eilenberg, Samuel and Moore, J. C. (1965) <em>Foundations of relative homological algebra</em> (Memoirs of the American Mathematical Society number 55) American Mathematical Society, Providence, R.I., <a href="http://worldcat.org/oclc/1361982">OCLC 1361982</a></li>
<li>Hatcher, A., (2002) <em><a href="http://www.math.cornell.edu/~hatcher/AT/ATchapters.html">Algebraic Topology</a></em> Cambridge University Press, ISBN 0-521-79540-0. Detailed discussion of homology theories for simplicial complexes and manifolds, singular homology, etc.</li>
<li><a href="http://www.encyclopediaofmath.org/index.php/Homology_group"><em>Homology group</em> at Encyclopaedia of Mathematics</a></li>
<li></li>
<li></li>
<li></li>
<li>Spanier, Edwin H. (1966). <em>Algebraic Topology.</em>, Springer, p. 155,. ISBN 0-387-90646-0.</li>
<li>Timothy Gowers, June Barrow-Green, Imre Leader (2010), <em>The Princeton Companion to Mathematics.</em>, Princeton University Press, ISBN 9781400830398.</li>
<li>John Stillwell (1993), <em>Classical Topology and Combinatorial Group Theory</em>, Springer, <a class="uri" href="doi:10.1007/978-1-4612-4372-4_6">doi:10.1007/978-1-4612-4372-4_6</a>, ISBN 978-0-387-97970-0.</li>
<li>Charles A. Weibel (1999), <em><a href="http://www.math.uiuc.edu/K-theory/0245/survey.pdf">History of Homological Algebra</a></em>, chapter 28 in the book <em>History of Topology</em> by I.M. James, Elsevier, ISBN 9780080534077.</li>
</ul>

<p>"</p>

<p><a href="Category:Homology_theory" title="wikilink"> </a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8">Richeson, D.; <em>Euler's Gem: The Polyhedron Formula and the Birth of Topology</em>, Princeton University (2008), Page 254.<a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11">For example <a href="http://smf4.emath.fr/Publications/Gazette/2011/127/smf_gazette_127_15-44.pdf"><em>L'émergence de la notion de groupe d'homologie</em>, Nicolas Basbois (PDF)</a>, in French, note 41, explicitly names Noether as inventing the <a href="homology_group" title="wikilink">homology group</a>.<a href="#fnref11">↩</a></li>
<li id="fn12">Hirzebruch, Friedrich, <a href="http://www.mathe2.uni-bayreuth.de/axel/papers/hierzebruch:emmy_noether_and_topology.ps.gz">Emmy Noether and Topology</a> in .<a href="#fnref12">↩</a></li>
<li id="fn13"><a href="http://math.vassar.edu/faculty/McCleary/BourbakiAlgTop.pdf"><em>Bourbaki and Algebraic Topology</em> by John McCleary (PDF)</a> gives documentation (translated into English from French originals).<a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"></li>
</ol>
</section>
</body>
</html>
