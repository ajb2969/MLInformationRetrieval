<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="298">Malware research</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Malware research</h1>
<hr/>

<p>The notion of a self-reproducing computer program can be traced back to initial theories about the operation of complex automata.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a href="John_von_Neumann" title="wikilink">John von Neumann</a> showed that in theory a program could reproduce itself. This constituted a plausibility result in <a href="computability_theory_(computer_science)" title="wikilink">computability theory</a>. <a href="Fred_Cohen" title="wikilink">Fred Cohen</a> experimented with computer viruses and confirmed Neumann's postulate and investigated other properties of malware such as detectability and self-obfuscation using rudimentary encryption. His 1988 Doctoral dissertation was on the subject of computer viruses.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Cohen's faculty advisor, <a href="Leonard_Adleman" title="wikilink">Leonard Adleman</a>, presented a rigorous proof that, in the general case, algorithmic determination of the presence of a virus is <a href="Undecidable_problem" title="wikilink">undecidable</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> This problem must not be mistaken for that of determination within a broad class of programs that a virus is not present. This problem differs in that it does not require the ability to recognize all viruses.</p>

<p>Adleman's proof is perhaps the deepest result in malware <a href="computability_theory_(computer_science)" title="wikilink">computability theory</a> to date and it relies on <a href="Cantor's_diagonal_argument" title="wikilink">Cantor's diagonal argument</a> as well as the <a href="halting_problem" title="wikilink">halting problem</a>. Ironically, it was later shown by Young and Yung that Adleman's work in <a class="uri" href="cryptography" title="wikilink">cryptography</a> is ideal in constructing a virus that is highly resistant to reverse-engineering by presenting the notion of a <a href="Cryptovirology" title="wikilink">cryptovirus</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> A cryptovirus is a virus that contains and uses a public key and randomly generated <a href="symmetric_cipher" title="wikilink">symmetric cipher</a> <a href="initialization_vector" title="wikilink">initialization vector</a> (IV) and <a href="session_key" title="wikilink">session key</a> (SK).</p>

<p>In the cryptoviral extortion attack, the virus hybrid encrypts <a class="uri" href="plaintext" title="wikilink">plaintext</a> data on the victim's machine using the randomly generated IV and SK. The IV+SK are then encrypted using the virus writer's <a href="public_key" title="wikilink">public key</a>. In theory the victim must negotiate with the virus writer to get the IV+SK back in order to decrypt the <a class="uri" href="ciphertext" title="wikilink">ciphertext</a> (assuming there are no backups). Analysis of the virus reveals the public key, not the IV and SK needed for decryption, or the private key needed to recover the IV and SK. This result was the first to show that <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a> can be used to devise malware that is robust against reverse-engineering.</p>

<p>A growing area of computer virus research is to mathematically model the infection behavior of worms using models such as <a href="Lotka–Volterra_equation" title="wikilink">Lotka–Volterra equations</a>, which has been applied in the study of biological virus. Various virus propagation scenarios have been studied by researchers such as propagation of computer virus, fighting virus with virus like predator codes,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> effectiveness of patching etc.</p>

<p>Behavioral malware detection has been researched more recently. Most approaches to behavioral detection are based on analysis of <a href="system_call" title="wikilink">system call</a> dependencies. The executed binary code is traced using <a class="uri" href="strace" title="wikilink">strace</a> or more precise <a href="taint_checking" title="wikilink">taint analysis</a> to compute data-flow dependencies among <a href="system_call" title="wikilink">system calls</a>. The result is a <a href="directed_graph" title="wikilink">directed graph</a> 

<math display="inline" id="Malware_research:0">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

 such that nodes are <a href="system_call" title="wikilink">system calls</a>, and edges represent dependencies. For example, 

<math display="inline" id="Malware_research:1">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>s</ci>
     <ci>t</ci>
    </interval>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,t)\in E
  </annotation>
 </semantics>
</math>

 if a result returned by system call 

<math display="inline" id="Malware_research:2">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 (either directly as a result or indirectly through output parameters) is later used as a parameter of system call 

<math display="inline" id="Malware_research:3">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

. The origins of the idea to use system calls to analyze software can be found in the work of Forrest et al.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Christodorescu et al.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> point out that malware authors cannot easily reorder system calls without changing the semantics of the program, which makes system call dependency graphs suitable for malware detection. They compute a difference between malware and goodware system call dependency graphs and use the resulting graphs for detection, achieving high detection rates. Kolbitsch et al.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> pre-compute symbolic expressions and evaluate them on the syscall parameters observed at runtime.</p>

<p>They detect dependencies by observing whether the result obtained by evaluation matches the parameter values observed at runtime. Malware is detected by comparing the dependency graphs of the training and test sets. Fredrikson et al.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> describe an approach that uncovers distinguishing features in malware system call dependency graphs. They extract significant behaviors using <a href="formal_concept_analysis" title="wikilink">concept analysis</a> and leap mining.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> Babic et al.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> recently proposed a novel approach for both malware detection and classification based on <a href="grammar_induction" title="wikilink">grammar inference</a> of <a href="tree_automaton" title="wikilink">tree automata</a>. Their approach infers an <a class="uri" href="automaton" title="wikilink">automaton</a> from dependency graphs, and they show how such an automaton could be used for detection and classification of malware.</p>

<p>Research in combining static and dynamic malware analysis techniques is also currently being conducted in an effort to minimize the shortcomings of both. Studies by researchers such as Islam et al.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> are working to integrate static and dynamic techniques in order to better analyze and classify malware and malware variants.</p>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a class="uri" href="Category:Malware" title="wikilink">Category:Malware</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">John von Neumann, "Theory of Self-Reproducing Automata", Part 1: Transcripts of lectures given at the University of Illinois, December 1949, Editor: A. W. Burks, University of Illinois, USA, 1966.<a href="#fnref1">↩</a></li>
<li id="fn2">Fred Cohen, "Computer Viruses", PhD Thesis, University of Southern California, ASP Press, 1988.<a href="#fnref2">↩</a></li>
<li id="fn3">L. M. Adleman, "An Abstract Theory of Computer Viruses", Advances in Cryptology---Crypto '88, LNCS 403, pp. 354-374, 1988.<a href="#fnref3">↩</a></li>
<li id="fn4">A. Young, M. Yung, "Cryptovirology: Extortion-Based Security Threats and Countermeasures," IEEE Symposium on Security &amp; Privacy, pp. 129-141, 1996.<a href="#fnref4">↩</a></li>
<li id="fn5">H. Toyoizumi, A. Kara. Predators: Good Will Mobile Codes Combat against Computer Viruses. Proc. of the 2002 New Security Paradigms Workshop, 2002<a href="#fnref5">↩</a></li>
<li id="fn6">Zakiya M. Tamimi, Javed I. Khan, <a href="http://www.medianet.kent.edu/publications/ICCCE06DL-2virusabstract-TK.pdf">Model-Based Analysis of Two Fighting Worms</a>, IEEE/IIU Proc. of ICCCE '06, Kuala Lumpur, Malaysia, May 2006, Vol-I, p. 157-163.<a href="#fnref6">↩</a></li>
<li id="fn7">S. Forrest, S. A. Hofmeyr, A. Somayaji, T. A. Longstaff, Thomas A.: <a href="http://dx.doi.org/10.1109/SECPRI.1996.502675">A Sense of Self for Unix Processes</a>, Proc. of the 1996 IEEE Symp. on Security and Privacy, 1996, p. 120-129.<a href="#fnref7">↩</a></li>
<li id="fn8">M. Christodorescu, S. Jha, C. Kruegel: <a href="http://dx.doi.org/10.1145/1287624.1287628">Mining specifications of malicious behavior</a>, Proc. of the 6th joint meeting of the European software engineering conf. and the ACM SIGSOFT symp. on The foundations of software engineering, 2007, p. 5-14<a href="#fnref8">↩</a></li>
<li id="fn9">C. Kolbitsch, P. Milani, C. Kruegel, E. Kirda, X. Zhou, and X. Wang: <a href="http://www.usenix.org/events/sec09/tech/full_papers/kolbitsch.pdf">Effective and Efficient Malware Detection at the End Host</a>, The 18th USENIX Security Symposium, 2009.<a href="#fnref9">↩</a></li>
<li id="fn10">M. Fredrikson, S. Jha, M. Christodorescu, R. Sailer, and X. Yan: <a href="http://dx.doi.org/10.1109/SP.2010.11">Synthesizing Near-Optimal Malware Specifications from Suspicious Behaviors</a>, Proc. of the 2010 IEEE Symposium on Security and Privacy, 2010, p. 45-60.<a href="#fnref10">↩</a></li>
<li id="fn11">X. Yan, H. Cheng, J. Han, and P. S. Yu: <a href="http://dx.doi.org/10.1145/1376616.1376662">Mining significant graph patterns by leap search</a> in Proceedings of the 2008 ACM SIGMOD International Conference on Management of Data (SIGMOD’08). New York, NY, USA: ACM Press, 2008, pp. 433-444<a href="#fnref11">↩</a></li>
<li id="fn12">D. Babic, D. Reynaud, and D. Song: <a href="http://www.domagoj-babic.com/index.php/Pubs/CAV11malware">Malware Analysis with Tree Automata Inference</a>, in Proceedings of the 23rd Int. Conference on Computer Aided Verification, 2011, Springer.<a href="#fnref12">↩</a></li>
<li id="fn13">R. Islam, R. Tian, L. M. Batten, and S. Versteeg: Classification of malware based on integrated staic and dynamic features, Journal of Network Computer Applications, 2013, p. 646-656.<a href="#fnref13">↩</a></li>
</ol>
</section>
</body>
</html>
