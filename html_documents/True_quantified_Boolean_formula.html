<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1790">True quantified Boolean formula</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>True quantified Boolean formula</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, the language <strong>TQBF</strong> is a <a href="formal_language" title="wikilink">formal language</a> consisting of the <strong>true quantified Boolean formulas</strong>. A (fully) quantified Boolean formula is a formula in <a href="Quantification_(logic)" title="wikilink">quantified</a> <a href="propositional_logic" title="wikilink">propositional logic</a> where every variable is quantified (or <a href="Bound_variable" title="wikilink">bound</a>), using either <a href="existential_quantification" title="wikilink">existential</a> or <a href="universal_quantification" title="wikilink">universal</a> quantifiers, at the beginning of the sentence. Such a formula is equivalent to either true or false (since there are no <a href="Bound_variable" title="wikilink">free</a> variables). If such a formula evaluates to true, then that formula is in the language TQBF. It is also known as <strong>QSAT</strong> (Quantified <a href="Boolean_satisfiability_problem" title="wikilink">SAT</a>).</p>
<h2 id="overview">Overview</h2>

<p>In computational complexity theory, the <strong>quantified Boolean formula problem</strong> (<strong>QBF</strong>) is a generalization of the <a href="Boolean_satisfiability_problem" title="wikilink">Boolean satisfiability problem</a> in which both <a href="existential_quantification" title="wikilink">existential quantifiers</a> and <a href="universal_quantification" title="wikilink">universal quantifiers</a> can be applied to each variable. Put another way, it asks whether a quantified sentential form over a set of Boolean variables is true or false. For example, the following is an instance of QBF:</p>

<p>

<math display="block" id="True_quantified_Boolean_formula:0">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>y</mi>
      </mpadded>
      <mrow>
       <mo>∃</mo>
       <mrow>
        <mpadded width="+5pt">
         <mi>z</mi>
        </mpadded>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>x</mi>
            <mo>∨</mo>
            <mi>z</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mo>∧</mo>
          <mi>y</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>y</ci>
       <apply>
        <exists></exists>
        <apply>
         <times></times>
         <ci>z</ci>
         <apply>
          <and></and>
          <apply>
           <or></or>
           <ci>x</ci>
           <ci>z</ci>
          </apply>
          <ci>y</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\ \exists y\ \exists z\ ((x\lor z)\land y)
  </annotation>
 </semantics>
</math>

</p>

<p>QBF is the canonical <a href="complete_problem" title="wikilink">complete problem</a> for <a class="uri" href="PSPACE" title="wikilink">PSPACE</a>, the class of problems solvable by a deterministic or nondeterministic <a href="Turing_machine" title="wikilink">Turing machine</a> in polynomial space and unlimited time.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Given the formula in the form of an <a href="abstract_syntax_tree" title="wikilink">abstract syntax tree</a>, the problem can be solved easily by a set of mutually recursive procedures which evaluate the formula. Such an algorithm uses space proportional to the height of the tree, which is linear in the worst case, but uses time exponential in the number of quantifiers.</p>

<p>Provided that <a href="MA_(complexity)" title="wikilink">MA</a> ⊊ PSPACE, which is widely believed, QBF cannot be solved, nor can a given solution even be verified, in either deterministic or <a href="probabilistic_Turing_machine" title="wikilink">probabilistic</a> polynomial time (in fact, unlike the satisfiability problem, there's no known way to specify a solution succinctly). It is trivial to solve using an <a href="alternating_Turing_machine" title="wikilink">alternating Turing machine</a> in linear time, which is no surprise since in fact <a href="AP_(complexity)" title="wikilink">AP</a> = PSPACE, where AP is the class of problems alternating machines can solve in polynomial time.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>When the seminal result <a href="IP_(complexity)" title="wikilink">IP</a> = PSPACE was shown (see <a href="interactive_proof_system" title="wikilink">interactive proof system</a>), it was done by exhibiting an interactive proof system that could solve QBF by solving a particular arithmetization of the problem.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>QBF formulas have a number of useful canonical forms. For example, it can be shown that there is a <a href="polynomial-time_many-one_reduction" title="wikilink">polynomial-time many-one reduction</a> that will move all quantifiers to the front of the formula and make them alternate between universal and existential quantifiers. There is another reduction that proved useful in the IP = PSPACE proof where no more than one universal quantifier is placed between each variable's use and the quantifier binding that variable. This was critical in limiting the number of products in certain subexpressions of the arithmetization.</p>
<h2 id="prenex-normal-form">Prenex normal form</h2>

<p>A fully quantified Boolean formula can be assumed to have a very specific form, called <a href="prenex_normal_form" title="wikilink">prenex normal form</a>. It has two basic parts: a portion containing only quantifiers and a portion containing an unquantified Boolean formula usually denoted as 

<math display="inline" id="True_quantified_Boolean_formula:1">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\phi
  </annotation>
 </semantics>
</math>

. If there are 

<math display="inline" id="True_quantified_Boolean_formula:2">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle n
  </annotation>
 </semantics>
</math>

 Boolean variables, the entire formula can be written as</p>

<p>

<math display="block" id="True_quantified_Boolean_formula:3">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo>∃</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mn>3</mn>
        </msub>
        <mi mathvariant="normal">⋯</mi>
        <msub>
         <mi>Q</mi>
         <mi>n</mi>
        </msub>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mi>ϕ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>x</mi>
          <mn>2</mn>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>x</mi>
          <mn>3</mn>
         </msub>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo>,</mo>
         <msub>
          <mi>x</mi>
          <mi>n</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <exists></exists>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">3</cn>
         </apply>
         <ci>normal-⋯</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Q</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>n</ci>
         </apply>
         <ci>ϕ</ci>
         <vector>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <cn type="integer">3</cn>
          </apply>
          <ci>normal-…</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>n</ci>
          </apply>
         </vector>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\exists x_{1}\forall x_{2}\exists x_{3}\cdots Q_{n}x_{n}\phi(x_{1%
},x_{2},x_{3},\dots,x_{n})
  </annotation>
 </semantics>
</math>

</p>

<p>where every variable falls within the <a href="Free_variables_and_bound_variables" title="wikilink">scope</a> of some quantifier. By introducing dummy variables, any formula in prenex normal form can be converted into a sentence where existential and universal quantifiers alternate. Using the dummy variable 

<math display="inline" id="True_quantified_Boolean_formula:4">
 <semantics>
  <msub>
   <mi>y</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle y_{1}
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="True_quantified_Boolean_formula:5">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
       <mi>ϕ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>↦</mo>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo>∃</mo>
        <mrow>
         <msub>
          <mi>x</mi>
          <mn>2</mn>
         </msub>
         <mi>ϕ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mn>1</mn>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>x</mi>
           <mn>2</mn>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <exists></exists>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>ϕ</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">2</cn>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <exists></exists>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <cn type="integer">2</cn>
          </apply>
          <ci>ϕ</ci>
          <interval closure="open">
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <cn type="integer">1</cn>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <cn type="integer">2</cn>
           </apply>
          </interval>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\exists x_{1}\exists x_{2}\phi(x_{1},x_{2})\quad\mapsto\quad%
\exists x_{1}\forall y_{1}\exists x_{2}\phi(x_{1},x_{2})
  </annotation>
 </semantics>
</math>

</p>

<p>The second sentence has the same <a href="truth_value" title="wikilink">truth value</a> but follows the restricted syntax. Assuming fully quantified Boolean formulas to be in prenex normal form is a frequent feature of proofs.</p>
<h2 id="solving">Solving</h2>

<p>There is a simple recursive algorithm for determining whether a QBF is in TQBF (i.e. is true). Given some QBF</p>

<p>

<math display="block" id="True_quantified_Boolean_formula:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>Q</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>Q</mi>
     <mn>2</mn>
    </msub>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mi mathvariant="normal">⋯</mi>
    <msub>
     <mi>Q</mi>
     <mi>n</mi>
    </msub>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <ci>ϕ</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{1}x_{1}Q_{2}x_{2}\cdots Q_{n}x_{n}\phi(x_{1},x_{2},\dots,x_{n}).
  </annotation>
 </semantics>
</math>

</p>

<p>If the formula contains no quantifiers, we can just return the formula. Otherwise, we take off the first quantifier and check both possible values for the first variable:</p>

<p>

<math display="block" id="True_quantified_Boolean_formula:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mn>2</mn>
     </msub>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mi mathvariant="normal">⋯</mi>
     <msub>
      <mi>Q</mi>
      <mi>n</mi>
     </msub>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <ci>ϕ</ci>
     <vector>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=Q_{2}x_{2}\cdots Q_{n}x_{n}\phi(0,x_{2},\dots,x_{n}),
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="True_quantified_Boolean_formula:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>B</mi>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mn>2</mn>
     </msub>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mi mathvariant="normal">⋯</mi>
     <msub>
      <mi>Q</mi>
      <mi>n</mi>
     </msub>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>B</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <ci>ϕ</ci>
     <vector>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B=Q_{2}x_{2}\cdots Q_{n}x_{n}\phi(1,x_{2},\dots,x_{n}).
  </annotation>
 </semantics>
</math>

</p>

<p>If 

<math display="inline" id="True_quantified_Boolean_formula:9">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mo>∃</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <cn type="integer">1</cn>
    </apply>
    <exists></exists>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{1}=\exists
  </annotation>
 </semantics>
</math>

, then return 

<math display="inline" id="True_quantified_Boolean_formula:10">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∨</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\lor B
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="True_quantified_Boolean_formula:11">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mo>∀</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <cn type="integer">1</cn>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{1}=\forall
  </annotation>
 </semantics>
</math>

, then return 

<math display="inline" id="True_quantified_Boolean_formula:12">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∧</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\land B
  </annotation>
 </semantics>
</math>

.</p>

<p>How fast does this algorithm run? For every quantifier in the initial QBF, the algorithm makes two recursive calls on only a linearly smaller subproblem. This gives the algorithm an exponential runtime <a href="Big_O_notation" title="wikilink">O(2<sup><em>n</em></sup>)</a>.</p>

<p>How much space does this algorithm use? Within each invocation of the algorithm, it needs to store the intermediate results of computing A and B. Every recursive call takes off one quantifier, so the total recursive depth is linear in the number of quantifiers. Formulas that lack quantifiers can be evaluated in space logarithmic in the number of variables. The initial QBF was fully quantified, so there are at least as many quantifiers as variables. Thus, this algorithm uses <em>O</em>(<em>n</em> + log <em>n</em>) = <em>O</em>(<em>n</em>) space. This makes the TQBF language part of the <a class="uri" href="PSPACE" title="wikilink">PSPACE</a> <a href="complexity_class" title="wikilink">complexity class</a>.</p>
<h2 id="pspace-completeness">PSPACE-completeness</h2>

<p>The TQBF language serves in <a href="computational_complexity_theory" title="wikilink">complexity theory</a> as the canonical <a class="uri" href="PSPACE-complete" title="wikilink">PSPACE-complete</a> problem. Being PSPACE-complete means that a language is in PSPACE and that the language is also <a class="uri" href="PSPACE-hard" title="wikilink">PSPACE-hard</a>. The algorithm above shows that TQBF is in PSPACE. Showing that TQBF is PSPACE-hard requires showing that any language in the complexity class PSPACE can be reduced to TQBF in polynomial time. I.e.,</p>

<p>

<math display="block" id="True_quantified_Boolean_formula:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>L</mi>
     </mrow>
     <mo>∈</mo>
     <mtext>PSPACE</mtext>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>L</mi>
     <msub>
      <mo>≤</mo>
      <mi>p</mi>
     </msub>
     <mtext>TQBF</mtext>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>L</ci>
     </apply>
     <mtext>PSPACE</mtext>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <leq></leq>
      <ci>p</ci>
     </apply>
     <ci>L</ci>
     <mtext>TQBF</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall L\in\textrm{PSPACE},L\leq_{p}\textrm{TQBF}.
  </annotation>
 </semantics>
</math>

</p>

<p>This means that, for a PSPACE language L, whether an input 

<math display="inline" id="True_quantified_Boolean_formula:14">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is in L can be decided by checking whether 

<math display="inline" id="True_quantified_Boolean_formula:15">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 is in TQBF, for some function 

<math display="inline" id="True_quantified_Boolean_formula:16">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 that is required to run in polynomial time (relative to the length of the input) Symbolically,</p>

<p>

<math display="block" id="True_quantified_Boolean_formula:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mi>L</mi>
    </mrow>
    <mo>⇔</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∈</mo>
     <mtext>TQBF</mtext>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <mtext>TQBF</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in L\iff f(x)\in\textrm{TQBF}.
  </annotation>
 </semantics>
</math>

</p>

<p>Proving that TQBF is PSPACE-hard, requires specification of 

<math display="inline" id="True_quantified_Boolean_formula:18">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

.</p>

<p>So, suppose that L is a PSPACE language. This means that L can be decided by a polynomial space deterministic <a href="Turing_machine" title="wikilink">Turing machine</a> (DTM). This is very important for the reduction of L to TQBF, because the configurations of any such Turing Machine can be represented as Boolean formulas, with Boolean variables representing the state of the machine as well as the contents of each cell on the Turing Machine tape, with the position of the Turing Machine head encoded in the formula by the formula's ordering. In particular, our reduction will use the variables 

<math display="inline" id="True_quantified_Boolean_formula:19">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="True_quantified_Boolean_formula:20">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{2}
  </annotation>
 </semantics>
</math>

, which represent two possible configurations of the DTM for L, and a natural number t, in constructing a QBF 

<math display="inline" id="True_quantified_Boolean_formula:21">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mrow>
    <msub>
     <mi>c</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>c</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi>t</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>t</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{c_{1},c_{2},t}
  </annotation>
 </semantics>
</math>

 which is true if and only if the DTM for L can go from the configuration encoded in 

<math display="inline" id="True_quantified_Boolean_formula:22">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{1}
  </annotation>
 </semantics>
</math>

 to the configuration encoded in 

<math display="inline" id="True_quantified_Boolean_formula:23">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{2}
  </annotation>
 </semantics>
</math>

 in no more than t steps. The function 

<math display="inline" id="True_quantified_Boolean_formula:24">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

, then, will construct from the DTM for L a QBF 

<math display="inline" id="True_quantified_Boolean_formula:25">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mrow>
    <msub>
     <mi>c</mi>
     <mrow>
      <mi>s</mi>
      <mi>t</mi>
      <mi>a</mi>
      <mi>r</mi>
      <mi>t</mi>
     </mrow>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>c</mi>
     <mrow>
      <mi>a</mi>
      <mi>c</mi>
      <mi>c</mi>
      <mi>e</mi>
      <mi>p</mi>
      <mi>t</mi>
     </mrow>
    </msub>
    <mo>,</mo>
    <mi>T</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>t</ci>
       <ci>a</ci>
       <ci>r</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>c</ci>
       <ci>c</ci>
       <ci>e</ci>
       <ci>p</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <ci>T</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{c_{start},c_{accept},T}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="True_quantified_Boolean_formula:26">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mi>s</mi>
    <mi>t</mi>
    <mi>a</mi>
    <mi>r</mi>
    <mi>t</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>t</ci>
     <ci>a</ci>
     <ci>r</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{start}
  </annotation>
 </semantics>
</math>

 is the DTM's starting configuration, 

<math display="inline" id="True_quantified_Boolean_formula:27">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mi>a</mi>
    <mi>c</mi>
    <mi>c</mi>
    <mi>e</mi>
    <mi>p</mi>
    <mi>t</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>c</ci>
     <ci>c</ci>
     <ci>e</ci>
     <ci>p</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{accept}
  </annotation>
 </semantics>
</math>

 is the DTM's accepting configuration, and T is the maximum number of steps the DTM could need to move from one configuration to the other. We know that <em>T</em> = <a href="Big-o_notation" title="wikilink"><em>O</em>(exp(<em>n</em>))</a>, where n is the length of the input, because this bounds the total number of possible configurations of the relevant DTM. Of course, it cannot take the DTM more steps than there are possible configurations to reach 

<math display="inline" id="True_quantified_Boolean_formula:28">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>accept</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>accept</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{\mathrm{accept}}
  </annotation>
 </semantics>
</math>

 unless it enters a loop, in which case it will never reach 

<math display="inline" id="True_quantified_Boolean_formula:29">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>accept</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>accept</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{\mathrm{accept}}
  </annotation>
 </semantics>
</math>

 anyway.</p>

<p>At this stage of the proof, we have already reduced the question of whether an input formula 

<math display="inline" id="True_quantified_Boolean_formula:30">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 (encoded, of course, in 

<math display="inline" id="True_quantified_Boolean_formula:31">
 <semantics>
  <msub>
   <mi>c</mi>
   <mrow>
    <mi>s</mi>
    <mi>t</mi>
    <mi>a</mi>
    <mi>r</mi>
    <mi>t</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>t</ci>
     <ci>a</ci>
     <ci>r</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{start}
  </annotation>
 </semantics>
</math>

) is in L to the question of whether the QBF 

<math display="inline" id="True_quantified_Boolean_formula:32">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mrow>
    <msub>
     <mi>c</mi>
     <mrow>
      <mi>s</mi>
      <mi>t</mi>
      <mi>a</mi>
      <mi>r</mi>
      <mi>t</mi>
     </mrow>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>c</mi>
     <mrow>
      <mi>a</mi>
      <mi>c</mi>
      <mi>c</mi>
      <mi>e</mi>
      <mi>p</mi>
      <mi>t</mi>
     </mrow>
    </msub>
    <mo>,</mo>
    <mi>T</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>t</ci>
       <ci>a</ci>
       <ci>r</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>c</ci>
       <ci>c</ci>
       <ci>e</ci>
       <ci>p</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <ci>T</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{c_{start},c_{accept},T}
  </annotation>
 </semantics>
</math>

, i.e., 

<math display="inline" id="True_quantified_Boolean_formula:33">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(w)
  </annotation>
 </semantics>
</math>

, is in TQBF. The remainder of this proof proves that 

<math display="inline" id="True_quantified_Boolean_formula:34">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 can be computed in polynomial time.</p>

<p>For 

<math display="inline" id="True_quantified_Boolean_formula:35">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=1
  </annotation>
 </semantics>
</math>

, computation of 

<math display="inline" id="True_quantified_Boolean_formula:36">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mrow>
    <msub>
     <mi>c</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>c</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi>t</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>t</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{c_{1},c_{2},t}
  </annotation>
 </semantics>
</math>

 is straightforward—either one of the configurations changes to the other in one step or it does not. Since the Turing Machine that our formula represents is deterministic, this presents no problem.</p>

<p>For 

<math display="inline" id="True_quantified_Boolean_formula:37">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>></mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t>1
  </annotation>
 </semantics>
</math>

, computation of 

<math display="inline" id="True_quantified_Boolean_formula:38">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mrow>
    <msub>
     <mi>c</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>c</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi>t</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>t</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{c_{1},c_{2},t}
  </annotation>
 </semantics>
</math>

 involves a recursive evaluation, looking for a so-called "middle point" 

<math display="inline" id="True_quantified_Boolean_formula:39">
 <semantics>
  <msub>
   <mi>m</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{1}
  </annotation>
 </semantics>
</math>

. In this case, we rewrite the formula as follows:</p>

<p>

<math display="block" id="True_quantified_Boolean_formula:40">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ϕ</mi>
     <mrow>
      <msub>
       <mi>c</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>c</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <mi>t</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <msub>
       <mi>m</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>ϕ</mi>
         <mrow>
          <msub>
           <mi>c</mi>
           <mn>1</mn>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>m</mi>
           <mn>1</mn>
          </msub>
          <mo>,</mo>
          <mrow>
           <mo stretchy="false">⌈</mo>
           <mrow>
            <mi>t</mi>
            <mo>/</mo>
            <mn>2</mn>
           </mrow>
           <mo stretchy="false">⌉</mo>
          </mrow>
         </mrow>
        </msub>
        <mo>∧</mo>
        <msub>
         <mi>ϕ</mi>
         <mrow>
          <msub>
           <mi>m</mi>
           <mn>1</mn>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>c</mi>
           <mn>2</mn>
          </msub>
          <mo>,</mo>
          <mrow>
           <mo stretchy="false">⌈</mo>
           <mrow>
            <mi>t</mi>
            <mo>/</mo>
            <mn>2</mn>
           </mrow>
           <mo stretchy="false">⌉</mo>
          </mrow>
         </mrow>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>t</ci>
     </list>
    </apply>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <and></and>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϕ</ci>
        <list>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <ceiling></ceiling>
          <apply>
           <divide></divide>
           <ci>t</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </list>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϕ</ci>
        <list>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <ceiling></ceiling>
          <apply>
           <divide></divide>
           <ci>t</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </list>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{c_{1},c_{2},t}=\exists m_{1}(\phi_{c_{1},m_{1},\lceil t/2\rceil}\wedge%
\phi_{m_{1},c_{2},\lceil t/2\rceil}).
  </annotation>
 </semantics>
</math>

</p>

<p>This converts the question of whether 

<math display="inline" id="True_quantified_Boolean_formula:41">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{1}
  </annotation>
 </semantics>
</math>

 can reach 

<math display="inline" id="True_quantified_Boolean_formula:42">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{2}
  </annotation>
 </semantics>
</math>

 in t steps to the question of whether 

<math display="inline" id="True_quantified_Boolean_formula:43">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{1}
  </annotation>
 </semantics>
</math>

 reaches a middle point 

<math display="inline" id="True_quantified_Boolean_formula:44">
 <semantics>
  <msub>
   <mi>m</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{1}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="True_quantified_Boolean_formula:45">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>t</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t/2
  </annotation>
 </semantics>
</math>

 steps, which itself reaches 

<math display="inline" id="True_quantified_Boolean_formula:46">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{2}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="True_quantified_Boolean_formula:47">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>t</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t/2
  </annotation>
 </semantics>
</math>

 steps. The answer to the latter question of course gives the answer to the former.</p>

<p>Now, t is only bounded by T, which is exponential (and so not polynomial) in the length of the input. Additionally, each recursive layer virtually doubles the length of the formula. (The variable 

<math display="inline" id="True_quantified_Boolean_formula:48">
 <semantics>
  <msub>
   <mi>m</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{1}
  </annotation>
 </semantics>
</math>

 is only one midpoint—for greater t, there are more stops along the way, so to speak.) So the time required to recursively evaluate 

<math display="inline" id="True_quantified_Boolean_formula:49">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mrow>
    <msub>
     <mi>c</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>c</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi>t</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>t</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{c_{1},c_{2},t}
  </annotation>
 </semantics>
</math>

 in this manner could be exponential as well, simply because the formula could become exponentially large. This problem is solved by universally quantifying using variables 

<math display="inline" id="True_quantified_Boolean_formula:50">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{3}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="True_quantified_Boolean_formula:51">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>4</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{4}
  </annotation>
 </semantics>
</math>

 over the configuration pairs (e.g., 

<math display="inline" id="True_quantified_Boolean_formula:52">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>m</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>m</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>c</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(c_{1},m_{1}),(m_{1},c_{2})\}
  </annotation>
 </semantics>
</math>

), which prevents the length of the formula from expanding due to recursive layers. This yields the following interpretation of 

<math display="inline" id="True_quantified_Boolean_formula:53">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mrow>
    <msub>
     <mi>c</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>c</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi>t</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>t</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{c_{1},c_{2},t}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="True_quantified_Boolean_formula:54">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ϕ</mi>
     <mrow>
      <msub>
       <mi>c</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>c</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <mi>t</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <msub>
       <mi>m</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo>∀</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>c</mi>
         <mn>3</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>c</mi>
         <mn>4</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>c</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>m</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>m</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>c</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>ϕ</mi>
       <mrow>
        <msub>
         <mi>c</mi>
         <mn>3</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>c</mi>
         <mn>4</mn>
        </msub>
        <mo>,</mo>
        <mrow>
         <mo stretchy="false">⌈</mo>
         <mrow>
          <mi>t</mi>
          <mo>/</mo>
          <mn>2</mn>
         </mrow>
         <mo stretchy="false">⌉</mo>
        </mrow>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>t</ci>
      </list>
     </apply>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <cn type="integer">3</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>c</ci>
          <cn type="integer">4</cn>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <set>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>c</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <cn type="integer">1</cn>
        </apply>
       </interval>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>c</ci>
         <cn type="integer">2</cn>
        </apply>
       </interval>
      </set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>c</ci>
         <cn type="integer">3</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>c</ci>
         <cn type="integer">4</cn>
        </apply>
        <apply>
         <ceiling></ceiling>
         <apply>
          <divide></divide>
          <ci>t</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </list>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{c_{1},c_{2},t}=\exists m_{1}\forall(c_{3},c_{4})\in\{(c_{1},m_{1}),(m_{1%
},c_{2})\}(\phi_{c_{3},c_{4},\lceil t/2\rceil}).
  </annotation>
 </semantics>
</math>

</p>

<p>This version of the formula can indeed be computed in polynomial time, since any one instance of it can be computed in polynomial time. The universally quantified ordered pair simply tells us that whichever choice of 

<math display="inline" id="True_quantified_Boolean_formula:55">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>c</mi>
    <mn>3</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mn>4</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">4</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (c_{3},c_{4})
  </annotation>
 </semantics>
</math>

 is made, 

<math display="inline" id="True_quantified_Boolean_formula:56">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mrow>
     <msub>
      <mi>c</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>c</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi>t</mi>
    </mrow>
   </msub>
   <mo>⇔</mo>
   <msub>
    <mi>ϕ</mi>
    <mrow>
     <msub>
      <mi>c</mi>
      <mn>3</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>c</mi>
      <mn>4</mn>
     </msub>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">⌈</mo>
      <mrow>
       <mi>t</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">⌉</mo>
     </mrow>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>t</ci>
     </list>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <cn type="integer">4</cn>
      </apply>
      <apply>
       <ceiling></ceiling>
       <apply>
        <divide></divide>
        <ci>t</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{c_{1},c_{2},t}\iff\phi_{c_{3},c_{4},\lceil t/2\rceil}
  </annotation>
 </semantics>
</math>

.</p>

<p>Thus, 

<math display="inline" id="True_quantified_Boolean_formula:57">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>L</mi>
    </mrow>
    <mo>∈</mo>
    <mtext>PSPACE</mtext>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>L</mi>
    <msub>
     <mo>≤</mo>
     <mi>p</mi>
    </msub>
    <mtext>TQBF</mtext>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>L</ci>
     </apply>
     <mtext>PSPACE</mtext>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <leq></leq>
      <ci>p</ci>
     </apply>
     <ci>L</ci>
     <mtext>TQBF</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall L\in\textrm{PSPACE},L\leq_{p}\textrm{TQBF}
  </annotation>
 </semantics>
</math>

, so TQBF is PSPACE-hard. Together with the above result that TQBF is in PSPACE, this completes the proof that TQBF is a PSPACE-complete language.</p>

<p>(This proof follows Sipser 2006 pp. 310–313 in all essentials. Papadimitriou 1994 also includes a proof.)</p>
<h2 id="miscellany">Miscellany</h2>
<ul>
<li>One important subproblem in TQBF is the <a href="Boolean_satisfiability_problem" title="wikilink">Boolean satisfiability problem</a>. In this problem, you wish to know whether a given Boolean formula 

<math display="inline" id="True_quantified_Boolean_formula:58">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 can be made true with some assignment of variables. This is equivalent to the TQBF using only existential quantifiers:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="True_quantified_Boolean_formula:59">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">⋯</mi>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
       <ci>ϕ</ci>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </vector>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x_{1}\cdots\exists x_{n}\phi(x_{1},\ldots,x_{n})
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>This is also an example of the larger result NP 

<math display="inline" id="True_quantified_Boolean_formula:60">
 <semantics>
  <mo>⊆</mo>
  <annotation-xml encoding="MathML-Content">
   <subset></subset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subseteq
  </annotation>
 </semantics>
</math>

 PSPACE which follows directly from the observation that a polynomial time verifier for a proof of a language accepted by a NTM (<a href="Non-deterministic_Turing_machine" title="wikilink">Non-deterministic Turing machine</a>) requires polynomial space to store the proof.
</dd>
</dl>
<ul>
<li>Any class in the <a href="polynomial_hierarchy" title="wikilink">polynomial hierarchy</a> (<a href="PH_(complexity)" title="wikilink">PH</a>) has TQBF as a hard problem. In other words, for the class comprising all languages L for which there exists a poly-time TM V, a verifier, such that for all input x and some constant i,</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="True_quantified_Boolean_formula:61">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>L</mi>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo>∀</mo>
       <mrow>
        <msub>
         <mi>y</mi>
         <mn>2</mn>
        </msub>
        <mi mathvariant="normal">⋯</mi>
        <msub>
         <mi>Q</mi>
         <mi>i</mi>
        </msub>
        <mpadded width="+5pt">
         <msub>
          <mi>y</mi>
          <mi>i</mi>
         </msub>
        </mpadded>
        <mi>V</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <msub>
          <mi>y</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>y</mi>
          <mn>2</mn>
         </msub>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo>,</mo>
         <msub>
          <mi>y</mi>
          <mi>i</mi>
         </msub>
         <mo rspace="7.5pt" stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>normal-⋯</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Q</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
         <ci>V</ci>
         <vector>
          <ci>x</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <cn type="integer">2</cn>
          </apply>
          <ci>normal-…</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>i</ci>
          </apply>
         </vector>
        </apply>
       </apply>
      </apply>
     </apply>
     <cn type="float">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in L\Leftrightarrow\exists y_{1}\forall y_{2}\cdots Q_{i}y_{i}\ V(x,y_{1},y_%
{2},\dots,y_{i})\ =\ 1
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>which has a specific QBF formulation that is given as
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="True_quantified_Boolean_formula:62">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists\phi
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="True_quantified_Boolean_formula:63">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mover accent="true">
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">→</mo>
     </mover>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <mover accent="true">
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
        <mo stretchy="false">→</mo>
       </mover>
       <mi mathvariant="normal">⋯</mi>
       <msub>
        <mi>Q</mi>
        <mi>i</mi>
       </msub>
       <mpadded width="+5pt">
        <mover accent="true">
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">→</mo>
        </mover>
       </mpadded>
       <mi>ϕ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mover accent="true">
         <msub>
          <mi>x</mi>
          <mn>1</mn>
         </msub>
         <mo stretchy="false">→</mo>
        </mover>
        <mo>,</mo>
        <mover accent="true">
         <msub>
          <mi>x</mi>
          <mn>2</mn>
         </msub>
         <mo stretchy="false">→</mo>
        </mover>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <mover accent="true">
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">→</mo>
        </mover>
        <mo rspace="7.5pt" stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <apply>
       <ci>normal-→</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <times></times>
        <apply>
         <ci>normal-→</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <ci>normal-⋯</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Q</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <ci>normal-→</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <ci>ϕ</ci>
        <vector>
         <apply>
          <ci>normal-→</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <ci>normal-→</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <ci>normal-→</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </vector>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="float">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists\vec{x_{1}}\forall\vec{x_{2}}\cdots Q_{i}\vec{x_{i}}\ \phi(\vec{x_{1}},%
\vec{x_{2}},\dots,\vec{x_{i}})\ =\ 1
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>where the 

<math display="inline" id="True_quantified_Boolean_formula:64">
 <semantics>
  <mover accent="true">
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{x_{i}}
  </annotation>
 </semantics>
</math>

's are vectors of Boolean variables.
</dd>
</dl>
<ul>
<li>It is important to note that while TQBF the language is defined as the collection of true quantified Boolean formulas, the abbreviation TQBF is often used (even in this article) to stand for a totally quantified Boolean formula, often simply called a QBF (quantified Boolean formula, understood as "fully" or "totally" quantified). It is important to distinguish contextually between the two uses of the abbreviation TQBF in reading the literature.</li>
<li>A TQBF can be thought of as a game played between two players, with alternating moves. Existentially quantified variables are equivalent to the notion that a move is available to a player at a turn. Universally quantified variables mean that the outcome of the game does not depend on what move a player makes at that turn. Also, a TQBF whose first quantifier is existential corresponds to a <a href="formula_game" title="wikilink">formula game</a> in which the first player has a winning strategy.</li>
<li>A TQBF for which the quantified formula is in <a href="conjunctive_normal_form" title="wikilink">2-CNF</a> may be solved in <a href="linear_time" title="wikilink">linear time</a>, by an algorithm involving <a href="strongly_connected_component" title="wikilink">strong connectivity analysis</a> of its <a href="implication_graph" title="wikilink">implication graph</a>. The <a class="uri" href="2-satisfiability" title="wikilink">2-satisfiability</a> problem is a special case of TQBF for these formulas, in which every quantifier is existential.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
<li>There is a systematic treatment of restricted versions of quantified boolean formulas (giving Schaefer-type classifications) provided in an expository paper by Hubie Chen.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></li>
</ul>
<h2 id="notes-and-references">Notes and references</h2>
<references>
</references>
<ul>
<li>Fortnow &amp; Homer (2003) provides some historical background for PSPACE and TQBF.</li>
<li>Zhang (2003) provides some historical background of Boolean formulas.</li>
<li>Arora, Sanjeev. (2001). <a href="http://www.cs.princeton.edu/~arora/pubs/aroracom.ps"><em>COS 522: Computational Complexity</em></a>. Lecture Notes, Princeton University. Retrieved October 10, 2005.</li>
<li>Fortnow, Lance &amp; Steve Homer. (2003, June). <a href="http://people.cs.uchicago.edu/~fortnow/beatcs/column80.pdf">A short history of computational complexity</a>. <em>The Computational Complexity Column,</em> 80. Retrieved October 9, 2005.</li>
<li>Papadimitriou, C. H. (1994). <em>Computational Complexity.</em> Reading: Addison-Wesley.</li>
<li>Sipser, Michael. (2006). <em>Introduction to the Theory of Computation.</em> Boston: Thomson Course Technology.</li>
<li>Zhang, Lintao. (2003). <a href="http://research.microsoft.com/users/lintaoz/thesis_lintao_zhang.pdf"><em>Searching for truth: Techniques for satisfiability of boolean formulas</em></a>. Retrieved October 10, 2005.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Cook–Levin_theorem" title="wikilink">Cook–Levin theorem</a>, stating that <a href="Boolean_satisfiability_problem" title="wikilink">SAT</a> is <a class="uri" href="NP-complete" title="wikilink">NP-complete</a></li>
<li><a href="Generalized_geography" title="wikilink">Generalized geography</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>The Quantified Boolean Formulas Library <a href="http://www.qbflib.org">(QBFLIB)</a></li>
<li><a href="http://lonsing.github.io/depqbf/">DepQBF</a> - a search-based solver for quantified boolean formula</li>
<li><a href="http://fmv.jku.at/qbf15/">International Workshop on Quantified Boolean Formulas</a></li>
</ul>

<p>"</p>

<p><a href="Category:Satisfiability_problems" title="wikilink">Category:Satisfiability problems</a> <a href="Category:Boolean_algebra" title="wikilink">Category:Boolean algebra</a> <a href="Category:PSPACE-complete_problems" title="wikilink">Category:PSPACE-complete problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">.<a href="#fnref4">↩</a></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
