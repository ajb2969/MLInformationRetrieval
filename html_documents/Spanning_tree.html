<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title offset="1014">Spanning tree</title>
   <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js">
    </script>
</head>
<body>
<h1>Spanning tree</h1>
<hr/>
<p> In the <a href="mathematics" title="wikilink">mathematical</a> field of <a href="graph_theory" title="wikilink">graph theory</a>, a <strong>spanning tree</strong> <em>T</em> of an <a href="undirected_graph" title="wikilink">undirected graph</a> <em>G</em> is a subgraph that includes all of the <a href="Vertex_(graph_theory)" title="wikilink">vertices</a> of <em>G</em> that is a <a href="tree_(graph_theory)" title="wikilink">tree</a>. In general, a graph may have several spanning trees, but a graph that is not <a href="connected_graph" title="wikilink">connected</a> will not contain a spanning tree (but see <a href="#Spanning_forests" title="wikilink">Spanning forests</a> below). If all of the <a href="edge_(graph_theory)" title="wikilink">edges</a> of <em>G</em> are also edges of a spanning tree <em>T</em> of <em>G</em>, then <em>G</em> is a tree and is identical to <em>T</em> (that is, a tree has a unique spanning tree and it is itself).</p>
<h2 id="applications">Applications</h2>
<p>Several <a class="uri" href="pathfinding" title="wikilink">pathfinding</a> algorithms, including <a href="Dijkstra's_algorithm" title="wikilink">Dijkstra's algorithm</a> and the <a href="A*_search_algorithm" title="wikilink">A* search algorithm</a>, internally build a spanning tree as an intermediate step in solving the problem.</p>
<p>In order to minimize the cost of power networks, wiring connections, piping, automatic speech recognition, etc., people often use algorithms that gradually build a spanning tree (or many such trees) as intermediate steps in the process of finding the <a href="minimum_spanning_tree" title="wikilink">minimum spanning tree</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<p>The Internet and many other <a href="telecommunications_network" title="wikilink">telecommunications networks</a> have transmission links that connect nodes together in a <a href="mesh_topology" title="wikilink">mesh topology</a> that includes some loops. In order to "avoid <a href="bridge_loop" title="wikilink">bridge loops</a> and "<a href="routing_loop" title="wikilink">routing loops</a>", many routing protocols designed for such networks -- including the <a href="Spanning_Tree_Protocol" title="wikilink">Spanning Tree Protocol</a>, <a href="Open_Shortest_Path_First" title="wikilink">Open Shortest Path First</a>, <a href="Link-state_routing_protocol" title="wikilink">Link-state routing protocol</a>, <a href="Augmented_tree-based_routing" title="wikilink">Augmented tree-based routing</a>, etc. -- require each router to remember a spanning tree.</p>
<h2 id="definitions">Definitions</h2>
<p>A tree is a <a href="connected_graph" title="wikilink">connected</a> <a href="undirected_graph" title="wikilink">undirected graph</a> with no <a href="cycle_(graph_theory)" title="wikilink">cycles</a>. It is a spanning tree of a graph <em>G</em> if it spans <em>G</em> (that is, it includes every vertex of <em>G</em>) and is a subgraph of <em>G</em> (every edge in the tree belongs to <em>G</em>). A spanning tree of a connected graph <em>G</em> can also be defined as a maximal set of edges of <em>G</em> that contains no cycle, or as a minimal set of edges that connect all vertices.</p>
<h3 id="fundamental-cycles">Fundamental cycles</h3>
<p>Adding just one edge to a spanning tree will create a cycle; such a cycle is called a <strong>fundamental cycle</strong>. There is a distinct fundamental cycle for each edge; thus, there is a one-to-one correspondence between fundamental cycles and edges not in the spanning tree. For a connected graph with <em>V</em> vertices, any spanning tree will have <em>V</em> − 1 edges, and thus, a graph of <em>E</em> edges and one of its spanning trees will have <em>E</em> − <em>V</em> + 1 fundamental cycles. For any given spanning tree the set of all <em>E</em> − <em>V</em> + 1 fundamental cycles forms a <a href="cycle_basis" title="wikilink">cycle basis</a>, a basis for the <a href="cycle_space" title="wikilink">cycle space</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h3 id="fundamental-cutsets">Fundamental cutsets</h3>
<p>Dual to the notion of a fundamental cycle is the notion of a <strong>fundamental cutset</strong>. By deleting just one edge of the spanning tree, the vertices are partitioned into two disjoint sets. The fundamental cutset is defined as the set of edges that must be removed from the graph <em>G</em> to accomplish the same partition. Thus, each spanning tree defines a set of <em>V</em> − 1 fundamental cutsets, one for each edge of the spanning tree.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<p>The duality between fundamental cutsets and fundamental cycles is established by noting that cycle edges not in the spanning tree can only appear in the cutsets of the other edges in the cycle; and <em>vice versa</em>: edges in a cutset can only appear in those cycles containing the edge corresponding to the cutset. This duality can also be expressed using the theory of <a href="matroid" title="wikilink">matroids</a>, according to which a spanning tree is a base of the <a href="graphic_matroid" title="wikilink">graphic matroid</a>, a fundamental cycle is the unique circuit within the set formed by adding one element to the base, and fundamental cutsets are defined in the same way from the <a href="dual_matroid" title="wikilink">dual matroid</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h3 id="spanning-forests">Spanning forests</h3>
<p>In graphs that are not connected, there can be no spanning tree, and one must consider <strong>spanning forests</strong> instead. Here there are two competing definitions:</p>
<ul>
<li>Some authors consider a spanning forest to be a maximal acyclic subgraph of the given graph, or equivalently a graph consisting of a spanning tree in each <a href="Connected_component_(graph_theory)" title="wikilink">connected component</a> of the graph.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
<li>For other authors, a spanning forest is a forest that spans all of the vertices, meaning only that each vertex of the graph is a vertex in the forest. For this definition, even a connected graph may have a disconnected spanning forest, such as the forest in which each vertex forms a single-vertex tree.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></li>
</ul>
<p>To avoid confusion between these two definitions,  suggest the term "full spanning forest" for a spanning forest with the same connectivity as the given graph, while  instead call this kind of forest a "maximal spanning forest".<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="counting-spanning-trees">Counting spanning trees</h2>
<p> The number <em>t</em>(<em>G</em>) of spanning trees of a connected graph is a well-studied <a href="invariant_(mathematics)" title="wikilink">invariant</a>.</p>
<h3 id="in-specific-graphs">In specific graphs</h3>
<p>In some cases, it is easy to calculate <em>t</em>(<em>G</em>) directly:</p>
<ul>
<li>If <em>G</em> is itself a tree, then <em>t</em>(<em>G</em>) = 1.</li>
<li>When <em>G</em> is the <a href="cycle_graph" title="wikilink">cycle graph</a> ''C<sub>n</sub> with <em>n</em> vertices, then <em>t</em>(<em>G</em>) = <em>n</em>.</li>
<li>For a <a href="complete_graph" title="wikilink">complete graph</a> with <em>n</em> vertices, <a href="Cayley's_formula" title="wikilink">Cayley's formula</a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> gives the number of spanning trees as <em>n</em><sup><em>n</em> − 2</sup>.</li>
<li>If <em>G</em> is the <a href="complete_bipartite_graph" title="wikilink">complete bipartite graph</a> <span class="LaTeX">$K_{p,q}$</span>,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> then <span class="LaTeX">$t(G)=p^{q-1}q^{p-1}$</span>.</li>
<li>For the <em>n</em>-dimensional <a href="hypercube_graph" title="wikilink">hypercube graph</a> <span class="LaTeX">$Q_n$</span>,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> the number of spanning trees is <span class="LaTeX">$t(G)=2^{2^n-n-1}\prod_{k=2}^n k^{{n\choose k}}$</span>.</li>
</ul>
<h3 id="in-arbitrary-graphs">In arbitrary graphs</h3>
<p>More generally, for any graph <em>G</em>, the number <em>t</em>(<em>G</em>) can be calculated in <a href="polynomial_time" title="wikilink">polynomial time</a> as the <a class="uri" href="determinant" title="wikilink">determinant</a> of a <a href="matrix_(mathematics)" title="wikilink">matrix</a> derived from the graph, using <a href="Kirchhoff's_theorem" title="wikilink">Kirchhoff's matrix-tree theorem</a>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<p>Specifically, to compute <em>t</em>(<em>G</em>), one constructs a square matrix in which the rows and columns are both indexed by the vertices of <em>G</em>. The entry in row <em>i</em> and column <em>j</em> is one of three values:</p>
<ul>
<li>The degree of vertex <em>i</em>, if <em>i</em> = <em>j</em>,</li>
<li>−1, if vertices <em>i</em> and <em>j</em> are adjacent, or</li>
<li>0, if vertices <em>i</em> and <em>j</em> are different from each other but not adjacent.</li>
</ul>
<p>The resulting matrix is <a href="singular_matrix" title="wikilink">singular</a>, so its determinant is zero. However, deleting the row and column for an arbitrarily chosen vertex leads to a smaller matrix whose determinant is exactly <em>t</em>(<em>G</em>).</p>
<h3 id="deletion-contraction">Deletion-contraction</h3>
<p>If <em>G</em> is a graph or <a class="uri" href="multigraph" title="wikilink">multigraph</a> and <em>e</em> is an arbitrary edge of <em>G</em>, then the number <em>t</em>(<em>G</em>) of spanning trees of <em>G</em> satisfies the <em>deletion-contraction recurrence</em> <em>t</em>(<em>G</em>) = <em>t</em>(<em>G</em> − <em>e</em>) + <em>t</em>(<em>G</em>/<em>e</em>), where <em>G</em> − <em>e</em> is the multigraph obtained by deleting <em>e</em> and <em>G</em>/<em>e</em> is the <a href="Edge_contraction" title="wikilink">contraction</a> of <em>G</em> by <em>e</em>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> The term <em>t</em>(<em>G</em> − <em>e</em>) in this formula counts the spanning trees of <em>G</em> that do not use edge <em>e</em>, and the term <em>t</em>(<em>G</em>/<em>e</em>) counts the spanning trees of <em>G</em> that use <em>e</em>.</p>
<p>In this formula, if the given graph <em>G</em> is a <a class="uri" href="multigraph" title="wikilink">multigraph</a>, or if a contraction causes two vertices to be connected to each other by multiple edges, then the redundant edges should not be removed, as that would lead to the wrong total. For instance a <a href="bond_graph" title="wikilink">bond graph</a> connecting two vertices by <em>k</em> edges has <em>k</em> different spanning trees, each consisting of a single one of these edges.</p>
<h3 id="tutte-polynomial">Tutte polynomial</h3>
<p>The <a href="Tutte_polynomial" title="wikilink">Tutte polynomial</a> of a graph can be defined as a sum, over the spanning trees of the graph, of terms computed from the "internal activity" and "external activity" of the tree. Its value at the arguments (1,1) is the number of spanning trees or, in a disconnected graph, the number of maximal spanning forest.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<p>The Tutte polynomial can also be computed using a deletion-contraction recurrence, but its <a href="Computational_complexity_theory" title="wikilink">computational complexity</a> is high: for many values of its arguments, computing it exactly is <a href="Sharp-P-complete" title="wikilink">#P-complete</a>, and it is also hard to approximate with a guaranteed <a href="approximation_ratio" title="wikilink">approximation ratio</a>. The point (1,1), at which it can be evaluated using Kirchhoff's theorem, is one of the few exceptions.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="algorithms">Algorithms</h2>
<h3 id="construction">Construction</h3>
<p>A single spanning tree of a graph can be found in <a href="linear_time" title="wikilink">linear time</a> by either <a href="depth-first_search" title="wikilink">depth-first search</a> or <a href="breadth-first_search" title="wikilink">breadth-first search</a>. Both of these algorithms explore the given graph, starting from an arbitrary vertex <em>v</em>, by looping through the neighbors of the vertices they discover and adding each unexplored neighbor to a data structure to be explored later. They differ in whether this data structure is a <a href="Stack_(abstract_data_type)" title="wikilink">stack</a> (in the case of depth-first search) or a <a href="Queue_(abstract_data_type)" title="wikilink">queue</a> (in the case of breadth-first search). In either case, one can form a spanning tree by connecting each vertex, other than the root vertex <em>v</em>, to the vertex from which it was discovered. This tree is known as a depth-first search tree or a breadth-first search tree according to the graph exploration algorithm used to construct it.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> Depth-first search trees are a special case of a class of spanning trees called <a href="Trémaux_tree" title="wikilink">Trémaux trees</a>, named after the 19th-century discoverer of depth-first search.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<p>Spanning trees are important in parallel and distributed computing, as a way of maintaining communications between a set of processors; see for instance the <a href="Spanning_Tree_Protocol" title="wikilink">Spanning Tree Protocol</a> used by <a href="Data_link_layer" title="wikilink">OSI link layer</a> devices. However, the depth-first and breadth-first methods for constructing spanning trees on sequential computers are not well suited for parallel and distributed computers.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> Instead, researchers have devised several more specialized algorithms for finding spanning trees in these models of computation.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h3 id="optimization">Optimization</h3>
<p>In certain fields of graph theory it is often useful to find a <a href="minimum_spanning_tree" title="wikilink">minimum spanning tree</a> of a <a href="weighted_graph" title="wikilink">weighted graph</a>. Other optimization problems on spanning trees have also been studied, including the maximum spanning tree, the minimum tree that spans at least k vertices, the <a href="Minimum_degree_spanning_tree" title="wikilink">spanning tree with the fewest edges per vertex</a>, the <a href="maximum_leaf_spanning_tree" title="wikilink">spanning tree with the largest number of leaves</a>, the spanning tree with the fewest leaves (closely related to the <a href="Hamiltonian_path_problem" title="wikilink">Hamiltonian path problem</a>), the minimum diameter spanning tree, and the minimum dilation spanning tree.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<p>Optimal spanning tree problems have also been studied for finite sets of points in a geometric space such as the <a href="Euclidean_plane" title="wikilink">Euclidean plane</a>. For such an input, a spanning tree is again a tree that has as its vertices the given points. The quality of the tree is measured in the same way as in a graph, using the Euclidean distance between pairs of points as the weight for each edge. Thus, for instance, a <a href="Euclidean_minimum_spanning_tree" title="wikilink">Euclidean minimum spanning tree</a> is the same as a graph minimum spanning tree in a <a href="complete_graph" title="wikilink">complete graph</a> with Euclidean edge weights. However, it is not necessary to construct this graph in order to solve the optimization problem; the Euclidean minimum spanning tree problem, for instance, can be solved more efficiently in <em>O</em>(<em>n</em> log <em>n</em>) time by constructing the <a href="Delaunay_triangulation" title="wikilink">Delaunay triangulation</a> and then applying a linear time <a href="planar_graph" title="wikilink">planar graph</a> minimum spanning tree algorithm to the resulting triangulation.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>
<h3 id="randomization">Randomization</h3>
<p>A spanning tree chosen <a href="random" title="wikilink">randomly</a> from among all the spanning trees with equal probability is called a <a href="uniform_spanning_tree" title="wikilink">uniform spanning tree</a>. Wilson's algorithm can be used to generate uniform spanning trees in polynomial time by a process of taking a random walk on the given graph and erasing the cycles created by this walk.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>
<p>An alternative model for generating spanning trees randomly but not uniformly is the <a href="random_minimal_spanning_tree" title="wikilink">random minimal spanning tree</a>. In this model, the edges of the graph are assigned random weights and then the <a href="minimum_spanning_tree" title="wikilink">minimum spanning tree</a> of the weighted graph is constructed.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>
<h3 id="enumeration">Enumeration</h3>
<p>Because a graph may have exponentially many spanning trees, it is not possible to list them all in <a href="polynomial_time" title="wikilink">polynomial time</a>. However, algorithms are known for listing all spanning trees in polynomial time per tree.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<h2 id="in-infinite-graphs">In infinite graphs</h2>
<p>Every finite connected graph has a spanning tree. However, for infinite connected graphs, the existence of spanning trees is equivalent to the <a href="axiom_of_choice" title="wikilink">axiom of choice</a>. An infinite graph is connected if each pair of its vertices forms the pair of endpoints of a finite path. As with finite graphs, a tree is a connected graph with no finite cycles, and a spanning tree can be defined either as a maximal acyclic set of edges or as a tree that contains every vertex.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>
<p>The trees within a graph may be partially ordered by their subgraph relation, and any infinite chain in this partial order has an upper bound (the union of the trees in the chain). <a href="Zorn's_lemma" title="wikilink">Zorn's lemma</a>, one of many equivalent statements to the axiom of choice, requires that a partial order in which all chains are upper bounded have a maximal element; in the partial order on the trees of the graph, this maximal element must be a spanning tree. Therefore, if Zorn's lemma is assumed, every infinite connected graph has a spanning tree.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>
<p>In the other direction, given a <a href="family_of_sets" title="wikilink">family of sets</a>, it is possible to construct an infinite graph such that every spanning tree of the graph corresponds to a <a href="choice_function" title="wikilink">choice function</a> of the family of sets. Therefore, if every infinite connected graph has a spanning tree, then the axiom of choice is true.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>
<h2 id="in-directed-multigraphs">In directed multigraphs</h2>
<p>The idea of a spanning tree can be generalized to directed multigraphs.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> Given a vertex <em>v</em> on a directed multigraph <em>G</em>, an <em>oriented spanning tree</em> <em>T</em> rooted at <em>v</em> is an acyclic subgraph of <em>G</em> in which every vertex other than <em>v</em> has outdegree 1. This definition is only satisfied when the “branches” of <em>T</em> point in toward <em>v</em>.</p>
<h2 id="notes">Notes</h2>
<p>"</p>
<p><a href="Category:Spanning_tree" title="wikilink">Category:Spanning tree</a> <a href="Category:Computational_problems_in_graph_theory" title="wikilink">Category:Computational problems in graph theory</a> <a href="Category:Axiom_of_choice" title="wikilink">Category:Axiom of choice</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">R. L. Graham and Pavol Hell. <a href="http://www.math.ucsd.edu/~ronspubs/85_07_minimum_spanning_tree.pdf">"On the History of the Minimum Spanning Tree Problem"</a>. 1985.<a href="#fnref1">↩</a></li>
<li id="fn2">, pp. 65–67.<a href="#fnref2">↩</a></li>
<li id="fn3">, pp. 67–69.<a href="#fnref3">↩</a></li>
<li id="fn4">.<a href="#fnref4">↩</a></li>
<li id="fn5">; .<a href="#fnref5">↩</a></li>
<li id="fn6">.<a href="#fnref6">↩</a></li>
<li id="fn7">; .<a href="#fnref7">↩</a></li>
<li id="fn8">.<a href="#fnref8">↩</a></li>
<li id="fn9">.<a href="#fnref9">↩</a></li>
<li id="fn10">.<a href="#fnref10">↩</a></li>
<li id="fn11">.<a href="#fnref11">↩</a></li>
<li id="fn12">, p. 109.<a href="#fnref12">↩</a></li>
<li id="fn13">, p. 351.<a href="#fnref13">↩</a></li>
<li id="fn14">; .<a href="#fnref14">↩</a></li>
<li id="fn15">.<a href="#fnref15">↩</a></li>
<li id="fn16">.<a href="#fnref16">↩</a></li>
<li id="fn17">.<a href="#fnref17">↩</a></li>
<li id="fn18">; ; .<a href="#fnref18">↩</a></li>
<li id="fn19">.<a href="#fnref19">↩</a></li>
<li id="fn20">.<a href="#fnref20">↩</a></li>
<li id="fn21"></li>
<li id="fn22">.<a href="#fnref22">↩</a></li>
<li id="fn23">.<a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"></li>
<li id="fn26">.<a href="#fnref26">↩</a></li>
<li id="fn27">. See in particular Theorem 2.1, [<a class="uri" href="http://books.google.com/books?id=kIKW18ENfUMC&pg">http://books.google.com/books?id=kIKW18ENfUMC&pg</a>;=PA192 pp. 192–193].<a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
</ol>
</section>
</body>
</html>
