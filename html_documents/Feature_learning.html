<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1563">Feature learning</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Feature learning</h1>
<hr/>

<p>In <a href="machine_learning" title="wikilink">machine learning</a>, <strong>feature learning</strong> or <strong>representation learning</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> is a set of techniques that learn a <a href="feature_(machine_learning)" title="wikilink">feature</a>: a transformation of raw data input to a representation that can be effectively exploited in machine learning tasks. This obviates the need for manual <a href="feature_engineering" title="wikilink">feature engineering</a>, which is otherwise necessary, and allows a machine to both learn at a specific task (<em>using</em> the features) <em>and</em> learn the features themselves: to learn how to learn.</p>

<p>Feature learning is motivated by the fact that machine learning tasks such as <a href="statistical_classification" title="wikilink">classification</a> often require input that is mathematically and computationally convenient to process. However, real-world data such as images, video, and sensor measurement is usually complex, redundant, and highly variable. Thus, it is necessary to discover useful features or representations from raw data. Traditional hand-crafted features often require expensive human labor and often rely on expert knowledge. Also, they normally do not generalize well. This motivates the design of efficient feature learning techniques, to automate and generalize this.</p>

<p>Feature learning can be divided into two categories: supervised and unsupervised feature learning, analogous to these categories in machine learning generally.</p>
<ul>
<li>In supervised feature learning, features are learned with labeled input data. Examples include <a href="artificial_neural_network" title="wikilink">neural networks</a>, <a href="multilayer_perceptron" title="wikilink">multilayer perceptron</a>, and (supervised) dictionary learning.</li>
</ul>
<ul>
<li>In unsupervised feature learning, features are learned with unlabeled input data. Examples include dictionary learning, <a href="independent_component_analysis" title="wikilink">independent component analysis</a>, <a href="Autoencoder" title="wikilink">autoencoders</a>, <a href="Matrix_decomposition" title="wikilink">matrix factorization</a>,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and various forms of <a href="Cluster_analysis" title="wikilink">clustering</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
</ul>
<h2 id="supervised-feature-learning">Supervised feature learning</h2>

<p>Supervised feature learning is to learn features from labeled data. Several approaches are introduced in the following.</p>
<h3 id="supervised-dictionary-learning">Supervised dictionary learning</h3>

<p>Dictionary learning is to learn a set (dictionary) of representative elements from the input data such that each data point can be represented as a weighted sum of the representative elements. The dictionary elements and the weights may be found by minimizing the average representation error (over the input data), together with <a href="L1_regularization" title="wikilink"><em>L1</em> regularization</a> on the weights to enable sparsity (i.e., the representation of each data point has only a few nonzero weights).</p>

<p>Supervised dictionary learning exploits both the structure underlying the input data and the labels for optimizing the dictionary elements. For example, a supervised dictionary learning technique was proposed by Mairal et al. in 2009.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The authors apply dictionary learning on classification problems by jointly optimizing the dictionary elements, weights for representing data points, and parameters of the classifier based on the input data. In particular, a minimization problem is formulated, where the objective function consists of the classification error, the representation error, an <em>L1</em> regularization on the representing weights for each data point (to enable sparse representation of data), and an <em>L2</em> regularization on the parameters of the classifier.</p>
<h3 id="neural-networks">Neural networks</h3>

<p><a href="Artificial_neural_networks" title="wikilink">Neural networks</a> are used to illustrate a family of learning algorithms via a "network" consisting of multiple layers of inter-connected nodes. It is inspired by the nervous system, where the nodes are viewed as neurons and edges are viewed as synapse. Each edge has an associated weight, and the network defines computational rules that passes input data from the input layer to the output layer. A network function associated with a neural network characterizes the relationship between input and output layers, which is parameterized by the weights. With appropriately defined network functions, various learning tasks can be performed by minimizing a cost function over the network function (weights).</p>

<p>Multilayer <a href="neural_network" title="wikilink">neural networks</a> can be used to perform feature learning, since they learn a representation of their input at the hidden layer(s) which is subsequently used for classification or regression at the output layer.</p>
<h2 id="unsupervised-feature-learning">Unsupervised feature learning</h2>

<p>Unsupervised feature learning is to learn features from unlabeled data. The goal of unsupervised feature learning is often to discover low-dimensional features that captures some structure underlying the high-dimensional input data. When the feature learning is performed in an unsupervised way, it enables a form of <a href="semisupervised_learning" title="wikilink">semisupervised learning</a> where first, features are learned from an unlabeled dataset, which are then employed to improve performance in a supervised setting with labeled data.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Several approaches are introduced in the following.</p>
<h3 id="k-means-clustering"><em>K</em>-means clustering</h3>

<p><a href="K-means_clustering" title="wikilink"><em>K</em>-means clustering</a> is an approach for vector quantization. In particular, given a set of <em>n</em> vectors, <em>k</em>-means clustering groups them into k clusters (i.e., subsets) in such a way that each vector belongs to the cluster with the closest mean. The problem is computationally <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>, and suboptimal greedy algorithms have been developed for <em>k</em>-means clustering.</p>

<p>In feature learning, <em>k</em>-means clustering can be used to group an unlabeled set of inputs into <em>k</em> clusters, and then use the centroids of these clusters to produce features. These features can be produced in several ways. The simplest way is to add <em>k</em> binary features to each sample, where each feature <em>j</em> has value one <a href="if_and_only_if" title="wikilink">iff</a> the <em>j</em>th centroid learned by <em>k</em>-means is the closest to the sample under consideration.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> It is also possible to use the distances to the clusters as features, perhaps after transforming them through a <a href="radial_basis_function" title="wikilink">radial basis function</a> (a technique that has used to train <a href="Radial_basis_function_network" title="wikilink">RBF networks</a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a>). Coates and <a href="Andrew_Ng" title="wikilink">Ng</a> note that certain variants of <em>k</em>-means behave similarly to <a href="sparse_coding" title="wikilink">sparse coding</a> algorithms.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>In a comparative evaluation of unsupervised feature learning methods, Coates, Lee and Ng found that <em>k</em>-means clustering with an appropriate transformation outperforms the more recently invented auto-encoders and RBMs on an image classification task.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> <em>K</em>-means has also been shown to improve performance in the domain of <a href="Natural_language_processing" title="wikilink">NLP</a>, specifically for <a href="named-entity_recognition" title="wikilink">named-entity recognition</a>;<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> there, it competes with <a href="Brown_clustering" title="wikilink">Brown clustering</a>, as well as with distributed word representations (also known as neural word embeddings).<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h3 id="principal-component-analysis">Principal component analysis</h3>

<p><a href="Principal_component_analysis" title="wikilink">Principal component analysis</a> (PCA) is often used for dimension reduction. Given a unlabeled set of <em>n</em> input data vectors, PCA generates <em>p</em> (which is much smaller than the dimension of the input data) right singular vectors corresponding to the <em>p</em> largest singular values of the data matrix, where the <em>k</em>th row of the data matrix is the <em>k</em>th input data vector shifted by the <a href="Sample_mean_and_sample_covariance" title="wikilink">sample mean</a> of the input (i.e., subtracting the sample mean from the data vector). Equivalently, these singular vectors are the eigenvectors corresponding to the <em>p</em> largest eigenvalues of the <a href="Sample_mean_and_sample_covariance" title="wikilink">sample covariance matrix</a> of the input vectors. These <em>p</em> singular vectors are the feature vectors learned from the input data, and they represent directions along which the data has the largest variations.</p>

<p>PCA is a linear feature learning approach since the <em>p</em> singular vectors are linear functions of the data matrix. The singular vectors can be generated via a simple algorithm with <em>p</em> iterations. In the <em>i</em>th iteration, the projection of the data matrix on the <em>(i-1)</em>th eigenvector is subtracted, and the <em>i</em>th singular vector is found as the right singular vector corresponding to the largest singular of the residual data matrix.</p>

<p>PCA has several limitations. First, it assumes that the directions with large variance are of most interest, which may not be the case in many applications. PCA only relies on orthogonal transformations of the original data, and it only exploits the first- and second-order moments of the data, which may not well characterize the distribution of the data. Furthermore, PCA can effectively reduce dimension only when the input data vectors are correlated (which results in a few dominant eigenvalues).</p>
<h3 id="local-linear-embedding">Local linear embedding</h3>

<p><a href="Nonlinear_dimensionality_reduction" title="wikilink">Local linear embedding</a> (LLE) is a nonlinear unsupervised learning approach for generating low-dimensional neighbor-preserving representations from (unlabeled) high-dimension input. The approach was proposed by Sam T. Roweis and Lawrence K. Saul in 2000.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>The general idea of LLE is to reconstruct the original high-dimensional data using lower-dimensional points while maintaining some geometric properties of the neighborhoods in the original data set. LLE consists of two major steps. The first step is for "neighbor-preserving," where each input data point <em>Xi</em> is reconstructed as a weighted sum of <em>K</em> nearest neighboring data points, and the optimal weights are found by minimizing the average squared reconstruction error (i.e., difference between a point and its reconstruction) under the constraint that the weights associated to each point sum up to one. The second step is for "dimension reduction," by looking for vectors in a lower-dimensional space that minimizes the representation error using the optimized weights in the first step. Note that in the first step, the weights are optimized with data being fixed, which can be solved as a <a href="least_squares" title="wikilink">least squares</a> problem; while in the second step, lower-dimensional points are optimized with the weights being fixed, which can be solved via sparse eigenvalue decomposition.</p>

<p>The reconstruction weights obtained in the first step captures the "intrinsic geometric properties" of a neighborhood in the input data.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> It is assumed that original data lie on a smooth lower-dimensional manifold, and the "intrinsic geometric properties" captured by the weights of the original data are expected also on the manifold. This is why the same weights are used in the second step of LLE. Compared with PCA, LLE is more powerful in exploiting the underlying structure of data.</p>
<h3 id="independent-component-analysis">Independent component analysis</h3>

<p><a href="Independent_component_analysis" title="wikilink">Independent component analysis</a> (ICA) is technique for learning a representation of data using a weighted sum of independent non-Gaussian components.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> The assumption of non-Gaussian is imposed since the weights cannot be uniquely determined when all the components follow Gaussian distribution.</p>
<h3 id="unsupervised-dictionary-learning">Unsupervised dictionary learning</h3>

<p>Different from supervised dictionary learning, unsupervised dictionary learning does not utilize the labels of the data and only exploits the structure underlying the data for optimizing the dictionary elements. An example of unsupervised dictionary learning is sparse coding, which aims to learn basis functions (dictionary elements) for data representation from unlabeled input data. Sparse coding can be applied to learn overcomplete dictionary, where the number of dictionary elements is larger than the dimension of the input data.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> Aharon et al. proposed an algorithm known as K-SVD for learning from unlabeled input data a dictionary of elements that enables sparse representation of the data.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h2 id="multilayerdeep-architectures">Multilayer/Deep architectures</h2>

<p>The hierarchical architecture of the neural system inspires <a href="deep_learning" title="wikilink">deep learning</a> architectures for feature learning by stacking multiple layers of simple learning blocks.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> These architectures are often designed based on the assumption of <a href="distributed_representation" title="wikilink">distributed representation</a>: observed data is generated by the interactions of many different factors on multiple levels. In a deep learning architecture, the output of each intermediate layer can be viewed as a representation of the original input data. Each level uses the representation produced by previous level as input, and produces new representations as output, which is then fed to higher levels. The input of bottom layer is the raw data, and the output of the final layer is the final low-dimensional feature or representation.</p>
<h3 id="restricted-boltzmann-machine">Restricted Boltzmann machine</h3>

<p><a href="Restricted_Boltzmann_machine" title="wikilink">Restricted Boltzmann machines</a> (RBMs) are often used as a building block for multilayer learning architectures.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> An RBM can be represented by an undirected bipartite graph consisting of a group of binary hidden variables, a group of visible variables, and edges connecting the hidden and visible nodes. It is a special case of the more general Boltzmann machines with the constraint of no intra-node connections. Each edge in an RBM is associated with a weight. The weights together with the connections define an energy function, based on which a joint distribution of visible and hidden nodes can be devised. Based on the topology of the RBM, the hidden (visible) variables are independent conditioned on the visible (hidden) variables. Such conditional independence facilitates computations on RBM.</p>

<p>An RBM can be viewed as a single layer architecture for unsupervised feature learning. In particular, the visible variables correspond to input data, and the hidden variables correspond to feature detectors. The weights can be trained by maximizing the probability of visible variables using the contrastive divergence (CD) algorithm by <a href="Geoffrey_Hinton" title="wikilink">Geoffrey Hinton</a>.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>

<p>In general, the training of RBM by solving the above maximization problem tends to result in non-sparse representations. The sparse RBM, <a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> a modification of the RBM, was proposed to enable sparse representations. The idea is to add a regularization term in the objective function of data likelihood, which penalizes the deviation of the expected hidden variables from a small constant 

<math display="inline" id="Feature_learning:0">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="autoencoder">Autoencoder</h3>

<p>An autoencoder consisting of encoder and decoder is a paradigm for deep learning architectures. An example is provided by Hinton and Salakhutdinov<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> where the encoder uses raw data (e.g., image) as input and produces feature or representation as output, and the decoder uses the extracted feature from the encoder as input and reconstructs the original input raw data as output. The encoder and decoder are constructed by stacking multiple layers of RBMs. The parameters involved in the architecture are trained in a greedy layer-by-layer manner: after one layer of feature detectors is learned, they are fed to upper layers as visible variables for training the corresponding RBM. The process can be repeated until some stopping criteria is satisfied.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Basis_function" title="wikilink">Basis function</a></li>
<li><a href="Deep_learning" title="wikilink">Deep learning</a></li>
<li><a href="Feature_detection_(computer_vision)" title="wikilink">Feature detection (computer vision)</a></li>
<li><a href="Feature_extraction" title="wikilink">Feature extraction</a></li>
<li><a href="Kernel_trick" title="wikilink">Kernel trick</a></li>
<li><a href="Vector_quantization" title="wikilink">Vector quantization</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Machine_learning" title="wikilink">Category:Machine learning</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"></li>
</ol>
</section>
</body>
</html>
