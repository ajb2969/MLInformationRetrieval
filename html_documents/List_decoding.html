<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1766">List decoding</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>List decoding</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, particularly in <a href="coding_theory" title="wikilink">coding theory</a>, <strong>list decoding</strong> is an alternative to unique decoding of <a href="error-correcting_codes" title="wikilink">error-correcting codes</a> for large error rates. The notion was proposed by <a href="Peter_Elias" title="wikilink">Elias</a> in the 1950s. The main idea behind list decoding is that the decoding algorithm instead of outputting a single possible message outputs a list of possibilities one of which is correct. This allows for handling a greater number of errors than that allowed by unique decoding.</p>

<p>The unique decoding model in <a href="coding_theory" title="wikilink">coding theory</a>, which is constrained to output a single valid codeword from the received word could not tolerate greater fraction of errors. This resulted in a gap between the error-correction performance for <a class="uri" href="stochastic" title="wikilink">stochastic</a> noise models (proposed by <a href="Claude_Shannon" title="wikilink">Shannon</a>) and the adversarial noise model (considered by <a href="Richard_Hamming" title="wikilink">Richard Hamming</a>). Since the mid 90s, significant algorithmic progress by the coding theory community has bridged this gap. Much of this progress is based on a relaxed error-correction model called list decoding, wherein the decoder outputs a list of codewords for worst-case pathological error patterns where the actual transmitted codeword is included in the output list. In case of typical error patterns though, the decoder outputs a unique single codeword, given a received word, which is almost always the case (However, this is not known to be true for all codes). The improvement here is significant in that the error-correction performance doubles. This is because now the decoder is not confined by the half-the-minimum distance barrier. This model is very appealing because having a list of codewords is certainly better than just giving up. The notion of list-decoding has many interesting applications in <a href="Computational_complexity_theory" title="wikilink">complexity theory</a>.</p>

<p>The way the channel noise is modeled plays a crucial role in that it governs the rate at which reliable communication is possible. There are two main schools of thought in modeling the channel behavior:</p>
<ul>
<li>Probabilistic noise model studied by Shannon in which the channel noise is modeled precisely in the sense that the probabilistic behavior of the channel is well known and the probability of occurrence of too many or too few errors is low</li>
<li>Worst-case or adversarial noise model considered by Hamming in which the channel acts as an adversary that arbitrarily corrupts the codeword subject to a bound on the total number of errors.</li>
</ul>

<p>The highlight of list-decoding is that even under adversarial noise conditions, it is possible to achieve the information-theoretic optimal trade-off between rate and fraction of errors that can be corrected. Hence, in a sense this is like improving the error-correction performance to that possible in case of a weaker, stochastic noise model.</p>
<h2 id="mathematical-formulation">Mathematical formulation</h2>

<p>Let 

<math display="inline" id="List_decoding:0">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíû</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíû</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>


 be a 

<math display="inline" id="List_decoding:1">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo>,</mo>
    <mi>d</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <vector>
     <ci>n</ci>
     <ci>k</ci>
     <ci>d</ci>
    </vector>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n,k,d)_{q}
  </annotation>
 </semantics>
</math>

 error-correcting code; in other words, 

<math display="inline" id="List_decoding:2">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíû</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíû</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 is a code of length 

<math display="inline" id="List_decoding:3">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, dimension 

<math display="inline" id="List_decoding:4">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 and minimum distance 

<math display="inline" id="List_decoding:5">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>


 over an alphabet 

<math display="inline" id="List_decoding:6">
 <semantics>
  <mi mathvariant="normal">Œ£</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Œ£</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

 of size 

<math display="inline" id="List_decoding:7">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

. The list-decoding problem can now be formulated as follows:</p>

<p><strong>Input:</strong> Received word 

<math display="inline" id="List_decoding:8">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>‚àà</mo>
   <msup>
    <mi mathvariant="normal">Œ£</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Œ£</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\Sigma^{n}
  </annotation>
 </semantics>
</math>

, <a href="error_bound" title="wikilink">error bound</a> 

<math display="inline" id="List_decoding:9">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

</p>

<p><strong>Output:</strong> A list of all codewords 

<math display="inline" id="List_decoding:10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>m</mi>
    </msub>
   </mrow>
   <mo>‚àà</mo>
   <mi class="ltx_font_mathcaligraphic">ùíû</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>m</ci>
     </apply>
    </list>
    <ci>ùíû</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},x_{2},\ldots,x_{m}\in\mathcal{C}
  </annotation>
 </semantics>
</math>


 whose <a href="hamming_distance" title="wikilink">hamming distance</a> from 

<math display="inline" id="List_decoding:11">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is at most 

<math display="inline" id="List_decoding:12">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="motivation-for-list-decoding">Motivation for list decoding</h2>

<p>Given a received word 

<math display="inline" id="List_decoding:13">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

, which is a noisy version of some transmitted codeword 

<math display="inline" id="List_decoding:14">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

, the decoder tries to output the transmitted codeword by placing its bet on a codeword that is ‚Äúnearest‚Äù to the received word. The Hamming distance between two codewords is used as a metric in finding the nearest codeword, given the received word by the decoder. If 

<math display="inline" id="List_decoding:15">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>


 is the minimum Hamming distance of a code 

<math display="inline" id="List_decoding:16">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíû</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíû</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

, then there exists two codewords 

<math display="inline" id="List_decoding:17">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="List_decoding:18">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{2}
  </annotation>
 </semantics>
</math>

 that differ in exactly 

<math display="inline" id="List_decoding:19">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 positions. Now, in the case where the received word 

<math display="inline" id="List_decoding:20">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>


 is equidistant from the codewords 

<math display="inline" id="List_decoding:21">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="List_decoding:22">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{2}
  </annotation>
 </semantics>
</math>

, unambiguous decoding becomes impossible as the decoder cannot decide which one of 

<math display="inline" id="List_decoding:23">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="List_decoding:24">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{2}
  </annotation>
 </semantics>
</math>

 to output as the original transmitted codeword. As a result, the half-the minimum distance acts as a combinatorial barrier beyond which unambiguous error-correction is impossible, if we only insist on unique decoding. However, received words such as 

<math display="inline" id="List_decoding:25">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>


 considered above occur only in the worst-case and if one looks at the way Hamming balls are packed in high-dimensional space, even for error patterns 

<math display="inline" id="List_decoding:26">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 beyond half-the minimum distance, there is only a single codeword 

<math display="inline" id="List_decoding:27">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 within Hamming distance 

<math display="inline" id="List_decoding:28">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 from the received word. This claim has been shown to hold with high probability for a random code picked from a natural ensemble and more so for the case of <a href="Reed‚ÄìSolomon_error_correction" title="wikilink">Reed‚ÄìSolomon codes</a> which is well studied and quite ubiquitous in the real world applications. In fact, Shannon‚Äôs proof of the capacity theorem for <em>q</em>-ary symmetric channels can be viewed in light of the above claim for random codes.</p>

<p>Under the mandate of list-decoding, for worst-case errors, the decoder is allowed to output a small list of codewords. With some context specific or side information, it may be possible to prune the list and recover the original transmitted codeword. Hence, in general, this seems to be a stronger error-recovery model than unique decoding.</p>
<h2 id="list-decoding-potential">List-decoding potential</h2>

<p>For a polynomial-time list-decoding algorithm to exist, we need the combinatorial guarantee that any Hamming ball of radius 

<math display="inline" id="List_decoding:29">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   pn
  </annotation>
 </semantics>
</math>

 around a received word 

<math display="inline" id="List_decoding:30">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>


 (where 

<math display="inline" id="List_decoding:31">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is the fraction of errors in terms of the block length 

<math display="inline" id="List_decoding:32">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

) has a small number of codewords. This is because the list size itself is clearly a lower bound on the running time of the algorithm. Hence, we require the list size to be a polynomial in the block length 

<math display="inline" id="List_decoding:33">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 of the code. A combinatorial consequence of this requirement is that it imposes an upper bound on the rate of a code. List decoding promises to meet this upper bound. It has been shown non-constructively that codes of rate 

<math display="inline" id="List_decoding:34">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 exist that can be list decoded up to a fraction of errors approaching 

<math display="inline" id="List_decoding:35">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-R
  </annotation>
 </semantics>
</math>


. The quantity 

<math display="inline" id="List_decoding:36">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-R
  </annotation>
 </semantics>
</math>

 is referred to in the literature as the list-decoding capacity. This is a substantial gain compared to the unique decoding model as we now have the potential to correct twice as many errors. Naturally, we need to have at least a fraction 

<math display="inline" id="List_decoding:37">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 of the transmitted symbols to be correct in order to recover the message. This is an information-theoretic lower bound on the number of correct symbols required to perform decoding and with list decoding, we can potentially achieve this information-theoretic limit. However, to realize this potential, we need explicit codes (codes that can be constructed in polynomial time) and efficient algorithms to perform encoding and decoding.</p>
<h2 id="definitions-of-list-decoding">Definitions of list decoding</h2>
<h3 id="p-l-list-decodability">(<em>p</em>, <em>L</em>)-list-decodability</h3>

<p>For any error fraction 

<math display="inline" id="List_decoding:38">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>‚â§</mo>
   <mi>p</mi>
   <mo>‚â§</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>p</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq p\leq 1
  </annotation>
 </semantics>
</math>

 and an integer 

<math display="inline" id="List_decoding:39">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>‚â•</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>L</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\geq 1
  </annotation>
 </semantics>
</math>

, a code 

<math display="inline" id="List_decoding:40">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ùíû</mi>
   <mo>‚äÜ</mo>
   <msup>
    <mi mathvariant="normal">Œ£</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>ùíû</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Œ£</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}\subseteq\Sigma^{n}
  </annotation>
 </semantics>
</math>


 is said to be list decodable up to a fraction 

<math display="inline" id="List_decoding:41">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 of errors with list size at most 

<math display="inline" id="List_decoding:42">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

. In other words, if for every 

<math display="inline" id="List_decoding:43">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>‚àà</mo>
   <msup>
    <mi mathvariant="normal">Œ£</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Œ£</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in\Sigma^{n}
  </annotation>
 </semantics>
</math>

, the number of codewords 

<math display="inline" id="List_decoding:44">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>‚àà</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>c</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\in C
  </annotation>
 </semantics>
</math>

 within Hamming distance 

<math display="inline" id="List_decoding:45">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   pn
  </annotation>
 </semantics>
</math>


 from 

<math display="inline" id="List_decoding:46">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is at most 

<math display="inline" id="List_decoding:47">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

, then the code 

<math display="inline" id="List_decoding:48">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíû</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíû</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

 is said to be (

<math display="inline" id="List_decoding:49">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="List_decoding:50">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>


)-list-decodable.</p>
<h2 id="combinatorics-of-list-decoding">Combinatorics of list decoding</h2>

<p>The relation between list decodability of a code and other fundamental parameters such as minimum distance and rate have been fairly well studied. It has been shown that every code can be list decoded using small lists beyond half the minimum distance up to a bound called the Johnson radius. This is quite significant because it proves the existence of (

<math display="inline" id="List_decoding:51">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="List_decoding:52">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

)-list-decodable codes of good rate with a list-decoding radius much larger than 

<math display="inline" id="List_decoding:53">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>d</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d/2
  </annotation>
 </semantics>
</math>

. In other words, the <a href="Johnson_bound" title="wikilink">Johnson bound</a> rules out the possibility of having a large number of codewords in a Hamming ball of radius slightly greater than 

<math display="inline" id="List_decoding:54">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>d</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d/2
  </annotation>
 </semantics>
</math>

 which means that it is possible to correct far more errors with list decoding.</p>
<h2 id="list-decoding-capacity">List-decoding capacity</h2>

<p>Below, 

<math display="inline" id="List_decoding:55">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>q</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <msub>
       <mi>log</mi>
       <mi>q</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>q</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>p</mi>
     <mrow>
      <msub>
       <mi>log</mi>
       <mi>q</mi>
      </msub>
      <mi>p</mi>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>p</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <msub>
       <mi>log</mi>
       <mi>q</mi>
      </msub>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>p</mi>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>q</ci>
     </apply>
     <ci>p</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>p</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <ci>q</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>q</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>p</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <ci>q</ci>
       </apply>
       <ci>p</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>p</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <ci>q</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {H_{q}}(p)=p{\log_{q}}(q-1)-p{\log_{q}}p-(1-p){\log_{q}}\left({1-p}\right)
  </annotation>
 </semantics>
</math>


 is the q-ary entropy function (defined for 

<math display="inline" id="List_decoding:56">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>‚â•</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>q</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\geq 2
  </annotation>
 </semantics>
</math>

).</p>
<h3 id="theorem-list-decoding-capacity">Theorem (list-decoding capacity)</h3>

<p>Let 

<math display="inline" id="List_decoding:57">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>‚â§</mo>
   <mi>p</mi>
   <mo>‚â§</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>q</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>p</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq p\leq 1-1/q
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="List_decoding:58">
 <semantics>
  <mrow>
   <mi>œµ</mi>
   <mo>‚â•</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>œµ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon\geq 0
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="List_decoding:59">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, then the following two statements hold for large enough block length 

<math display="inline" id="List_decoding:60">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>‚â§</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>H</mi>
      <mi>q</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>p</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mi>œµ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>R</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>q</ci>
      </apply>
      <ci>p</ci>
     </apply>
     <ci>œµ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\leq 1-H_{q}(p)-\epsilon
  </annotation>
 </semantics>
</math>


.</p>

<p>i) If 

<math display="inline" id="List_decoding:61">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, then there exists a (

<math display="inline" id="List_decoding:62">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>œµ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>œµ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1/\epsilon)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="List_decoding:63">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>‚â•</mo>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>H</mi>
       <mi>q</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>p</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi>œµ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>R</ci>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <ci>q</ci>
       </apply>
       <ci>p</ci>
      </apply>
     </apply>
     <ci>œµ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\geq 1-H_{q}(p)+\epsilon
  </annotation>
 </semantics>
</math>

)-list decodable code.</p>

<p>ii) If 

<math display="inline" id="List_decoding:64">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, then every (

<math display="inline" id="List_decoding:65">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="List_decoding:66">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <msup>
    <mi>q</mi>
    <mrow>
     <mi mathvariant="normal">Œ©</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>q</ci>
     <apply>
      <times></times>
      <ci>normal-Œ©</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=q^{\Omega(n)}
  </annotation>
 </semantics>
</math>

)-list-decodable code has 

<math display="inline" id="List_decoding:67">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

.</p>

<p>What this means is that for rates approaching the channel capacity, there exists list decodable codes with polynomial sized lists enabling efficient decoding algorithms whereas for rates exceeding the channel capacity, the list size becomes exponential which rules out the existence of efficient decoding algorithms.</p>

<p>The proof for list-decoding capacity is a significant one in that it exactly matches the capacity of a 

<math display="inline" id="List_decoding:68">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mi>S</mi>
   <msub>
    <mi>C</mi>
    <mi>p</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>q</ci>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   qSC_{p}
  </annotation>
 </semantics>
</math>

-ary symmetric channel 

<math display="inline" id="List_decoding:69">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mi>S</mi>
   <msub>
    <mi>C</mi>
    <mi>p</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   BSC_{p}
  </annotation>
 </semantics>
</math>

. In fact, the term "list-decoding capacity" should actually be read as the capacity of an adversarial channel under list decoding. Also, the proof for list-decoding capacity is an important result that pin points the optimal trade-off between rate of a code and the fraction of errors that can be corrected under list decoding.</p>
<h3 id="sketch-of-proof">Sketch of proof</h3>

<p>The idea behind the proof is similar to that of Shannon's proof for capacity of the <a href="binary_symmetric_channel" title="wikilink">binary symmetric channel</a> 

<math display="inline" id="List_decoding:70">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>


 where a random code is picked and showing that it is (

<math display="inline" id="List_decoding:71">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="List_decoding:72">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>‚â§</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>H</mi>
      <mi>q</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>p</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>L</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>R</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>q</ci>
      </apply>
      <ci>p</ci>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>L</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\leq 1-H_{q}(p)-1/L
  </annotation>
 </semantics>
</math>

)-list-decodable with high probability as long as the rate 

<math display="inline" id="List_decoding:73">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

. For rates exceeding the above quantity, it can be shown that the list size 

<math display="inline" id="List_decoding:74">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>‚àà</mo>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>q</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>q</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in[q]^{n}
  </annotation>
 </semantics>
</math>

 becomes super-polynomially large.</p>

<p>A "bad" event is defined as one in which, given a received word 

<math display="inline" id="List_decoding:75">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>L</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L+1
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="List_decoding:76">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>m</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msub>
     <mi>m</mi>
     <mi>L</mi>
    </msub>
   </mrow>
   <mo>‚àà</mo>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>q</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>L</ci>
     </apply>
    </list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>q</ci>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{0},\dots,m_{L}\in[q]^{k}
  </annotation>
 </semantics>
</math>

 messages 

<math display="inline" id="List_decoding:77">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ùíû</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>m</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚àà</mo>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mrow>
      <mi>p</mi>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>ùíû</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>B</ci>
     <interval closure="open">
      <ci>y</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}(m_{i})\in B(y,pn)
  </annotation>
 </semantics>
</math>

, it so happens that 

<math display="inline" id="List_decoding:78">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>‚â§</mo>
   <mi>i</mi>
   <mo>‚â§</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq i\leq L
  </annotation>
 </semantics>
</math>

, for every 

<math display="inline" id="List_decoding:79">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="List_decoding:80">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mrow>
     <mi>p</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <interval closure="open">
     <ci>y</ci>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>n</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B(y,pn)
  </annotation>
 </semantics>
</math>


 is the fraction of errors that we wish to correct and 

<math display="inline" id="List_decoding:81">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   pn
  </annotation>
 </semantics>
</math>

 is the Hamming ball of radius 

<math display="inline" id="List_decoding:82">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 with the received word 

<math display="inline" id="List_decoding:83">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ùíû</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>m</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ùíû</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}(m_{i})
  </annotation>
 </semantics>
</math>

 as the center.</p>

<p>Now, the probability that a codeword 

<math display="inline" id="List_decoding:84">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mi>i</mi>
   </msub>
   <mo>‚àà</mo>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>q</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>q</ci>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i}\in[q]^{k}
  </annotation>
 </semantics>
</math>

 associated with a fixed message 

<math display="inline" id="List_decoding:85">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mrow>
     <mi>p</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <interval closure="open">
     <ci>y</ci>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>n</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B(y,pn)
  </annotation>
 </semantics>
</math>


 lies in a Hamming ball 

<math display="block" id="List_decoding:86">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Pr</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mrow>
        <mi>C</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>m</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>‚àà</mo>
       <mrow>
        <mi>B</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>y</mi>
         <mo>,</mo>
         <mrow>
          <mi>p</mi>
          <mi>n</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>Vol</mi>
       <mi>q</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo>,</mo>
       <mrow>
        <mi>p</mi>
        <mi>n</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>/</mo>
     <msup>
      <mi>q</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo>‚â§</mo>
    <msup>
     <mi>q</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>n</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mrow>
          <msub>
           <mi>H</mi>
           <mi>q</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>p</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>Pr</ci>
      <apply>
       <in></in>
       <apply>
        <times></times>
        <ci>C</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>B</ci>
        <interval closure="open">
         <ci>y</ci>
         <apply>
          <times></times>
          <ci>p</ci>
          <ci>n</ci>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Vol</ci>
        <ci>q</ci>
       </apply>
       <interval closure="open">
        <ci>y</ci>
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
       </interval>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>q</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>n</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>H</ci>
           <ci>q</ci>
          </apply>
          <ci>p</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr[C(m_{i})\in B(y,pn)]=\mathrm{Vol}_{q}(y,pn)/q^{n}\leq q^{-n(1-H_{q}(p))},
  </annotation>
 </semantics>
</math>

 is given by</p>

<p>

<math display="inline" id="List_decoding:87">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mi>o</mi>
   <msub>
    <mi>l</mi>
    <mi>q</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mrow>
     <mi>p</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>o</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>l</ci>
     <ci>q</ci>
    </apply>
    <interval closure="open">
     <ci>y</ci>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>n</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Vol_{q}(y,pn)
  </annotation>
 </semantics>
</math>

</p>

<p>where the quantity 

<math display="inline" id="List_decoding:88">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   pn
  </annotation>
 </semantics>
</math>

 is the volume of a Hamming ball of radius 

<math display="inline" id="List_decoding:89">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 with the received word 

<math display="inline" id="List_decoding:90">
 <semantics>
  <msup>
   <mi>q</mi>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>q</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>q</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>q</ci>
     </apply>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q^{H_{q}(p)}
  </annotation>
 </semantics>
</math>


 as the center. The inequality in the above relation follows from the upper bound on the volume of a Hamming ball. The quantity 

<math display="inline" id="List_decoding:91">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 gives a very good estimate on the volume of a Hamming ball of radius 

<math display="inline" id="List_decoding:92">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>q</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>q</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [q]^{n}
  </annotation>
 </semantics>
</math>

 centered around any word in 

<math display="inline" id="List_decoding:93">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>y</mi>
   <mo>,</mo>
   <msub>
    <mi>m</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">‚Ä¶</mi>
   <mo>,</mo>
   <msub>
    <mi>m</mi>
    <mi>L</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-‚Ä¶</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>L</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (y,m_{0},\dots,m_{L})
  </annotation>
 </semantics>
</math>

. Put another way, the volume of a Hamming ball is translation invariant. To continue with the proof sketch, we conjure the <a href="union_bound" title="wikilink">union bound</a> in probability theory which tells us that the probability of a bad event happening for a given 

<math display="inline" id="List_decoding:94">
 <semantics>
  <msup>
   <mi>q</mi>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>L</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>H</mi>
         <mi>q</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>p</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>q</ci>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <plus></plus>
       <ci>L</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <ci>q</ci>
        </apply>
        <ci>p</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q^{-n(L+1)(1-H_{q}(p))}
  </annotation>
 </semantics>
</math>

 is upper bounded by the quantity 

<math display="inline" id="List_decoding:95">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>


.</p>

<p>With the above in mind, the probability of "any" bad event happening can be shown to be less than 

<math display="inline" id="List_decoding:96">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>‚àà</mo>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>q</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>q</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in[q]^{n}
  </annotation>
 </semantics>
</math>

. To show this, we work our way over all possible received words 

<math display="inline" id="List_decoding:97">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 and every possible subset of 

<math display="inline" id="List_decoding:98">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>q</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>q</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [q]^{k}
  </annotation>
 </semantics>
</math>

 messages in 

<math display="inline" id="List_decoding:99">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>‚àà</mo>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>q</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>q</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in[q]^{n}
  </annotation>
 </semantics>
</math>

.</p>

<p>Now turning to the proof of part (ii), we need to show that there are super-polynomially many codewords around every 

<math display="inline" id="List_decoding:100">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ùíû</mi>
    <mo>‚à©</mo>
    <mrow>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mrow>
       <mi>p</mi>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <intersect></intersect>
     <ci>ùíû</ci>
     <apply>
      <times></times>
      <ci>B</ci>
      <interval closure="open">
       <ci>y</ci>
       <apply>
        <times></times>
        <ci>p</ci>
        <ci>n</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\mathcal{C}\cap B(y,pn)|
  </annotation>
 </semantics>
</math>


 when the rate exceeds the list-decoding capacity. We need to show that 

<math display="inline" id="List_decoding:101">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>‚â•</mo>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>H</mi>
       <mi>q</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>p</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi>œµ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>R</ci>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <ci>q</ci>
       </apply>
       <ci>p</ci>
      </apply>
     </apply>
     <ci>œµ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\geq 1-H_{q}(p)+\epsilon
  </annotation>
 </semantics>
</math>

 is super-polynomially large if the rate 

<math display="inline" id="List_decoding:102">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>‚àà</mo>
   <mi class="ltx_font_mathcaligraphic">ùíû</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>c</ci>
    <ci>ùíû</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\in\mathcal{C}
  </annotation>
 </semantics>
</math>

. Fix a codeword 

<math display="inline" id="List_decoding:103">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>‚àà</mo>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>q</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>q</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in[q]^{n}
  </annotation>
 </semantics>
</math>

. Now, for every 

<math display="block" id="List_decoding:104">
 <semantics>
  <mrow>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>c</mi>
      <mo>‚àà</mo>
      <mrow>
       <mi>B</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo>,</mo>
        <mrow>
         <mi>p</mi>
         <mi>n</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>y</mi>
      <mo>‚àà</mo>
      <mrow>
       <mi>B</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>c</mi>
        <mo>,</mo>
        <mrow>
         <mi>p</mi>
         <mi>n</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>Pr</ci>
     <apply>
      <in></in>
      <ci>c</ci>
      <apply>
       <times></times>
       <ci>B</ci>
       <interval closure="open">
        <ci>y</ci>
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>Pr</ci>
     <apply>
      <in></in>
      <ci>y</ci>
      <apply>
       <times></times>
       <ci>B</ci>
       <interval closure="open">
        <ci>c</ci>
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr[c\in B(y,pn)]=\Pr[y\in B(c,pn)]\,
  </annotation>
 </semantics>
</math>

 picked at random, we have</p>

<p>

<math display="inline" id="List_decoding:105">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>


</p>

<p>since Hamming balls are translation invariant. From the definition of the volume of a Hamming ball and the fact that 

<math display="inline" id="List_decoding:106">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>q</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>q</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [q]^{n}
  </annotation>
 </semantics>
</math>

 is chosen uniformly at random from 

<math display="block" id="List_decoding:107">
 <semantics>
  <mrow>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>c</mi>
      <mo>‚àà</mo>
      <mrow>
       <mi>B</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo>,</mo>
        <mrow>
         <mi>p</mi>
         <mi>n</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>y</mi>
      <mo>‚àà</mo>
      <mrow>
       <mi>B</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>c</mi>
        <mo>,</mo>
        <mrow>
         <mi>p</mi>
         <mi>n</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>Vol</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mrow>
       <mi>p</mi>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <msup>
     <mi>q</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>‚â•</mo>
   <mpadded width="+1.7pt">
    <msup>
     <mi>q</mi>
     <mrow>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>n</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mrow>
           <msub>
            <mi>H</mi>
            <mi>q</mi>
           </msub>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>p</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>o</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>Pr</ci>
      <apply>
       <in></in>
       <ci>c</ci>
       <apply>
        <times></times>
        <ci>B</ci>
        <interval closure="open">
         <ci>y</ci>
         <apply>
          <times></times>
          <ci>p</ci>
          <ci>n</ci>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>Pr</ci>
      <apply>
       <in></in>
       <ci>y</ci>
       <apply>
        <times></times>
        <ci>B</ci>
        <interval closure="open">
         <ci>c</ci>
         <apply>
          <times></times>
          <ci>p</ci>
          <ci>n</ci>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>Vol</ci>
       <interval closure="open">
        <ci>y</ci>
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
       </interval>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>q</ci>
      <apply>
       <minus></minus>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>n</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>H</ci>
            <ci>q</ci>
           </apply>
           <ci>p</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>o</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr[c\in B(y,pn)]=\Pr[y\in B(c,pn)]=\mathrm{Vol}(y,pn)/q^{n}\geq q^{-n(1-H_{q}%
(p))-o(n)}\,
  </annotation>
 </semantics>
</math>

 we also have</p>

<p>

<math display="inline" id="List_decoding:108">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>c</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{c}
  </annotation>
 </semantics>
</math>

</p>

<p>Let us now define an indicator variable 

<math display="block" id="List_decoding:109">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mi>c</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mtext>if</mtext>
     <mi>c</mi>
    </mrow>
    <mo>‚àà</mo>
    <mrow>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mrow>
       <mi>p</mi>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">1</cn>
      <mtext>if</mtext>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>B</ci>
      <interval closure="open">
       <ci>y</ci>
       <apply>
        <times></times>
        <ci>p</ci>
        <ci>n</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{c}=1\text{ if }c\in B(y,pn),
  </annotation>
 </semantics>
</math>

 such that</p>

<p>

<math display="inline" id="List_decoding:110">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>B</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo>,</mo>
       <mrow>
        <mi>p</mi>
        <mi>n</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>B</ci>
       <interval closure="open">
        <ci>y</ci>
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle E[|B(y,pn)|]
  </annotation>
 </semantics>
</math>


</p>

<p>0 otherwise.</p>

<p>Taking the expectation of the volume of a Hamming ball we have</p>

<p>

<math display="inline" id="List_decoding:111">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <msqrt>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mi>Œ¥</mi>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <root></root>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>Œ¥</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\sqrt{1-\delta}
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore, by the probabilistic method, we have shown that if the rate exceeds the list-decoding capacity, then the list size becomes super-polynomially large. This completes the proof sketch for the list-decoding capacity.</p>
<h2 id="list-decoding-algorithms">List-decoding algorithms</h2>

<p>In the period from 1995 to 2007, the coding theory community developed progressivly more efficient list-decoding algorithms. Algorithms for <a href="Reed‚ÄìSolomon_error_correction" title="wikilink">Reed‚ÄìSolomon codes</a> that can decode up to the Johnson radius which is 

<math display="inline" id="List_decoding:112">
 <semantics>
  <mi>Œ¥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ¥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

 exist where 

<math display="inline" id="List_decoding:113">
 <semantics>
  <mrow>
   <mi>Œ¥</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Œ¥</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta=1-R
  </annotation>
 </semantics>
</math>

 is the normalised distance or relative distance. However, for Reed-Solomon codes, 

<math display="inline" id="List_decoding:114">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <msqrt>
    <mi>R</mi>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <root></root>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\sqrt{R}
  </annotation>
 </semantics>
</math>

 which means a fraction 

<math display="inline" id="List_decoding:115">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <msqrt>
    <mrow>
     <mn>2</mn>
     <mi>R</mi>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <root></root>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>R</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\sqrt{2R}
  </annotation>
 </semantics>
</math>

 of errors can be corrected. Some of the most prominent list-decoding algorithms are the following:</p>
<ul>
<li>Sudan '95 ‚Äì The first known non-trivial list-decoding algorithm for Reed‚ÄìSolomon codes that achieved efficient list decoding up to 

<math display="inline" id="List_decoding:116">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <msqrt>
    <mi>R</mi>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <root></root>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\sqrt{R}
  </annotation>
 </semantics>
</math>

 errors developed by <a href="Madhu_Sudan" title="wikilink">Madhu Sudan</a>.</li>
</ul>
<ul>
<li><a href="Guruswami‚ÄìSudan_list_decoding_algorithm" title="wikilink">Guruswami‚ÄìSudan '98</a> ‚Äì An improvement on the above algorithm for list decoding Reed‚ÄìSolomon codes up to 

<math display="inline" id="List_decoding:117">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <msqrt>
    <mi>R</mi>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <root></root>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\sqrt{R}
  </annotation>
 </semantics>
</math>

 errors by Madhu Sudan and his then doctoral student <a href="Venkatesan_Guruswami" title="wikilink">Venkatesan Guruswami</a>.</li>
</ul>
<ul>
<li>Parvaresh‚ÄìVardy '05 ‚Äì In a breakthrough paper, Farzad Parvaresh and Alexander Vardy presented codes that can be list decoded beyond the 

<math display="inline" id="List_decoding:118">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 radius for low rates 

<math display="inline" id="List_decoding:119">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>‚â•</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>m</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\geq 1
  </annotation>
 </semantics>
</math>

. Their codes are variants of Reed-Solomon codes which are obtained by evaluating 

<math display="inline" id="List_decoding:120">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 correlated polynomials instead of just 

<math display="inline" id="List_decoding:121">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mi>R</mi>
   <mo>-</mo>
   <mi>œµ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>R</ci>
    <ci>œµ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-R-\epsilon
  </annotation>
 </semantics>
</math>

 as in the case of usual Reed-Solomon codes.</li>
</ul>
<ul>
<li>Guruswami‚ÄìRudra '06 - In yet another breakthrough, Venkatesan Guruswami and <a href="http://www.cse.buffalo.edu/~atri/">Atri Rudra</a> give explicit codes that achieve list-decoding capacity, that is, they can be list decoded up to the radius 

<math display="inline" id="List_decoding:122">
 <semantics>
  <mrow>
   <mi>œµ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>œµ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon>0
  </annotation>
 </semantics>
</math>

 for any 

<math display="inline" id="List_decoding:123">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <interval closure="closed">
     <ci>n</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [n,k+1]_{q}
  </annotation>
 </semantics>
</math>

. In other words, this is error-correction with optimal redundancy. This answered a question that had been open for about 50 years. This work has been invited to the Research Highlights section of the Communications of the ACM (which is ‚Äúdevoted to the most important research results published in Computer Science in recent years‚Äù) and was mentioned in an article titled ‚ÄúCoding and Computing Join Forces‚Äù in the Sep 21, 2007 issue of the Science magazine. The codes that they are give are called folded Reed-Solomon codes which are nothing but plain Reed-Solomon codes but viewed as a code over a larger alphabet by careful bundling of codeword symbols.</li>
</ul>

<p>Because of their ubiquity and the nice algebraic properties they possess, list-decoding algorithms for Reed‚ÄìSolomon codes were a main focus of researchers. The list-decoding problem for Reed‚ÄìSolomon codes can be formulated as follows:</p>

<p><strong>Input</strong>: For an 

<math display="inline" id="List_decoding:124">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>Œ±</mi>
    <mi>i</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Œ±</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\alpha_{i},y_{i})
  </annotation>
 </semantics>
</math>

 Reed-Solomon code, we are given the pair 

<math display="inline" id="List_decoding:125">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>‚â§</mo>
   <mi>i</mi>
   <mo>‚â§</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq i\leq n
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="List_decoding:126">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="List_decoding:127">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 is the 

<math display="inline" id="List_decoding:128">
 <semantics>
  <msub>
   <mi>Œ±</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Œ±</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}
  </annotation>
 </semantics>
</math>

th bit of the received word and the 

<math display="inline" id="List_decoding:129">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{q}
  </annotation>
 </semantics>
</math>

's are distinct points in the finite field 

<math display="inline" id="List_decoding:130">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>=</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>e</ci>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e=n-t
  </annotation>
 </semantics>
</math>

 and an error parameter 

<math display="inline" id="List_decoding:131">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚àà</mo>
   <mrow>
    <msub>
     <mi>F</mi>
     <mi>q</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>q</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X)\in F_{q}[X]
  </annotation>
 </semantics>
</math>

.</p>

<p><strong>Output</strong>: The goal is to find all the polynomials 

<math display="inline" id="List_decoding:132">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 of degree at most 

<math display="inline" id="List_decoding:133">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>Œ±</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Œ±</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\alpha_{i})=y_{i}
  </annotation>
 </semantics>
</math>

 which is the message length such that 

<math display="inline" id="List_decoding:134">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 for at least 

<math display="inline" id="List_decoding:135">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 values of 

<math display="inline" id="List_decoding:136">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

. Here, we would like to have 

<math display="inline" id="List_decoding:137">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <interval closure="open">
     <ci>X</ci>
     <ci>Y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X,Y)
  </annotation>
 </semantics>
</math>

 as small as possible so that greater number of errors can be tolerated.</p>

<p>With the above formulation, the general structure of list-decoding algorithms for Reed-Solomon codes is as follows:</p>

<p><strong>Step 1</strong>: (Interpolation) Find a non-zero bivariate polynomial 

<math display="inline" id="List_decoding:138">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>Œ±</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Œ±</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(\alpha_{i},y_{i})=0
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="List_decoding:139">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>‚â§</mo>
   <mi>i</mi>
   <mo>‚â§</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq i\leq n
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="List_decoding:140">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

.</p>

<p><strong>Step 2</strong>: (Root finding/Factorization) Output all degree 

<math display="inline" id="List_decoding:141">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(X)
  </annotation>
 </semantics>
</math>

 polynomials 

<math display="inline" id="List_decoding:142">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>-</mo>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>Y</ci>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y-p(X)
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="List_decoding:143">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <interval closure="open">
     <ci>X</ci>
     <ci>Y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X,Y)
  </annotation>
 </semantics>
</math>

 is a factor of 

<math display="inline" id="List_decoding:144">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <interval closure="open">
      <ci>X</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>X</ci>
      </apply>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(X,p(X))=0
  </annotation>
 </semantics>
</math>

 i.e. 

<math display="inline" id="List_decoding:145">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>Œ±</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Œ±</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\alpha_{i})=y_{i}
  </annotation>
 </semantics>
</math>

. For each of these polynomials, check if 

<math display="inline" id="List_decoding:146">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 for at least 

<math display="inline" id="List_decoding:147">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>‚àà</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>i</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\in[n]
  </annotation>
 </semantics>
</math>

 values of 

<math display="inline" id="List_decoding:148">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(X)
  </annotation>
 </semantics>
</math>

. If so, include such a polynomial <span class="LaTeX">$p(X)$</span> in the output list.</p>

<p>Given the fact that bivariate polynomials can be factored efficiently, the above algorithm runs in polynomial time.</p>
<h2 id="applications-in-complexity-theory-and-cryptography">Applications in complexity theory and cryptography</h2>

<p>Algorithms developed for list decoding of several interesting code families have found interesting applications in <a href="Analysis_of_algorithms" title="wikilink">computational complexity</a> and the field of <a class="uri" href="cryptography" title="wikilink">cryptography</a>. Following is a sample list of applications outside of coding theory:</p>
<ul>
<li>Construction of <a href="hard-core_predicate" title="wikilink">hard-core predicates</a> from <a href="One-way_function" title="wikilink">one-way permutations</a>.</li>
<li>Predicting witnesses for NP-search problems.</li>
<li>Amplifying hardness of Boolean functions.</li>
<li>Average case hardness of <a class="uri" href="permanent" title="wikilink">permanent</a> of random matrices.</li>
<li><a href="Extractor_(mathematics)" title="wikilink">Extractors</a> and <a href="Pseudorandom_generator" title="wikilink">Pseudorandom generators</a>.</li>
<li>Efficient traitor tracing.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://theory.lcs.mit.edu/%7Emadhu/papers/noneed/ifip-journ.ps">A Survey on list decoding</a> by <a href="Madhu_Sudan" title="wikilink">Madhu Sudan</a></li>
<li><a href="http://people.csail.mit.edu/madhu/FT01/">Notes from a course</a> taught by Madhu Sudan</li>
<li><a href="http://www.cs.berkeley.edu/~luca/cs294/">Notes from a course</a> taught by <a href="Luca_Trevisan" title="wikilink">Luca Trevisan</a></li>
<li><a href="http://www.cs.washington.edu/education/courses/533/06au/">Notes from a course</a> taught by <a href="Venkatesan_Guruswami" title="wikilink">Venkatesan Guruswami</a></li>
<li><a href="http://www.cse.buffalo.edu/~atri/courses/coding-theory/">Notes from a course</a> taught by Atri Rudra</li>
<li>P. Elias, "List decoding for noisy channels," Technical Report 335, Research Laboratory of Electronics, MIT, 1957.</li>
<li>P. Elias, "Error-correcting codes for list decoding," IEEE Transactions on Information Theory, vol. 37, pp.¬†5‚Äì12, 1991.</li>
<li>J. M. Wozencraft, "List decoding," Quarterly Progress Report, Research Laboratory of Electronics, MIT, vol. 48, pp.¬†90‚Äì95, 1958.</li>
<li><a href="Venkatesan_Guruswami" title="wikilink">Venkatesan Guruswami</a>'s <a href="http://www.springer.com/computer/foundations/book/978-3-540-24051-8">PhD thesis</a></li>
<li>[<a class="uri" href="http://www.nowpublishers.com/product.aspx?product=TCS&amp;doi">http://www.nowpublishers.com/product.aspx?product=TCS&amp;doi;</a>;=0400000007 Algorithmic Results in List Decoding]</li>
<li><a href="Folded_Reed‚ÄìSolomon_code" title="wikilink">Folded Reed‚ÄìSolomon code</a></li>
</ul>

<p>"</p>

<p><a href="Category:Coding_theory" title="wikilink">Category:Coding theory</a> <a href="Category:Error_detection_and_correction" title="wikilink">Category:Error detection and correction</a> <a href="Category:Computational_complexity_theory" title="wikilink">Category:Computational complexity theory</a></p>
</body>
</html>
