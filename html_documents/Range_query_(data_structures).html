<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="27">Range query (data structures)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Range query (data structures)</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a href="data_structure" title="wikilink">data structures</a>, a <strong>range query</strong> consists of preprocessing some input data into a data structure to efficiently answer any number of queries on any subset of the input. Particularly, there is a group of problems that have been extensively studied where the input is an <a href="Array_data_structure" title="wikilink">array</a> of unsorted numbers and a query consists in computing some function on a specific range of the array. In this article we describe some of these problems together with their solutions.</p>
<h2 id="problem-statement">Problem statement</h2>

<p>We may state the problem of range queries in the following way: a range query 

<math display="inline" id="Range_query_(data_structures):0">
 <semantics>
  <mrow>
   <msub>
    <mi>q</mi>
    <mi>f</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <ci>f</ci>
    </apply>
    <vector>
     <ci>A</ci>
     <ci>i</ci>
     <ci>j</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{f}(A,i,j)
  </annotation>
 </semantics>
</math>

 on an array 

<math display="inline" id="Range_query_(data_structures):1">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mo>.</mo>
    <mo>.</mo>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-.</ci>
     <ci>normal-.</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=[a_{1},a_{2},..,a_{n}]
  </annotation>
 </semantics>
</math>

 of <em>n</em> elements of some set 

<math display="inline" id="Range_query_(data_structures):2">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, denoted 

<math display="inline" id="Range_query_(data_structures):3">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="closed">
     <cn type="integer">1</cn>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A[1,n]
  </annotation>
 </semantics>
</math>


, takes two indices 

<math display="inline" id="Range_query_(data_structures):4">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>i</mi>
   <mo>≤</mo>
   <mi>j</mi>
   <mo>≤</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>j</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq i\leq j\leq n
  </annotation>
 </semantics>
</math>

, a function 

<math display="inline" id="Range_query_(data_structures):5">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 defined over arrays of elements of 

<math display="inline" id="Range_query_(data_structures):6">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 and outputs 

<math display="inline" id="Range_query_(data_structures):7">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>i</mi>
       <mo>,</mo>
       <mi>j</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <interval closure="closed">
       <ci>i</ci>
       <ci>j</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>j</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(A[i,j])=f(a_{i},\ldots,a_{j})
  </annotation>
 </semantics>
</math>

. This should be done space and time efficient.</p>

<p>consider for instance 

<math display="inline" id="Range_query_(data_structures):8">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <mrow>
    <mi>s</mi>
    <mi>u</mi>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>f</ci>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>u</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=sum
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Range_query_(data_structures):9">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="closed">
     <cn type="integer">1</cn>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A[1,n]
  </annotation>
 </semantics>
</math>

 an array of numbers, the range query 

<math display="inline" id="Range_query_(data_structures):10">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi>u</mi>
   <mi>m</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>u</ci>
    <ci>m</ci>
    <vector>
     <ci>A</ci>
     <ci>i</ci>
     <ci>j</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   sum(A,i,j)
  </annotation>
 </semantics>
</math>

 computes 

<math display="inline" id="Range_query_(data_structures):11">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mi>u</mi>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>i</mi>
       <mo>,</mo>
       <mi>j</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <mo>+</mo>
     <mi mathvariant="normal">…</mi>
     <mo>+</mo>
     <msub>
      <mi>a</mi>
      <mi>j</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>u</ci>
     <ci>m</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <interval closure="closed">
       <ci>i</ci>
       <ci>j</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   sum(A[i,j])=(a_{i}+\ldots+a_{j})
  </annotation>
 </semantics>
</math>

, for any 

<math display="inline" id="Range_query_(data_structures):12">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>i</mi>
   <mo>≤</mo>
   <mi>j</mi>
   <mo>≤</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>j</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq i\leq j\leq n
  </annotation>
 </semantics>
</math>

. These queries may be answered in constant time and using 

<math display="inline" id="Range_query_(data_structures):13">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>


 extra space by calculating the sums of the first 

<math display="inline" id="Range_query_(data_structures):14">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 elements of 

<math display="inline" id="Range_query_(data_structures):15">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and storing them into an auxiliar array 

<math display="inline" id="Range_query_(data_structures):16">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

, such that 

<math display="inline" id="Range_query_(data_structures):17">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>i</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B[i]
  </annotation>
 </semantics>
</math>

 contains the sum of the first 

<math display="inline" id="Range_query_(data_structures):18">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>


 elements of 

<math display="inline" id="Range_query_(data_structures):19">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 for every 

<math display="inline" id="Range_query_(data_structures):20">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <mi>i</mi>
   <mo>≤</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq i\leq n
  </annotation>
 </semantics>
</math>

.Therefore any query might be answered by doing 

<math display="inline" id="Range_query_(data_structures):21">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mi>u</mi>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>i</mi>
       <mo>,</mo>
       <mi>j</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>j</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>u</ci>
     <ci>m</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <interval closure="closed">
       <ci>i</ci>
       <ci>j</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>B</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>B</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   sum(A[i,j])=B[j]-B[i-1]
  </annotation>
 </semantics>
</math>

.</p>

<p>This strategy may be extended for every <a href="Group_(mathematics)" title="wikilink">group</a> operator 

<math display="inline" id="Range_query_(data_structures):22">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 where the notion of 

<math display="inline" id="Range_query_(data_structures):23">
 <semantics>
  <msup>
   <mi>f</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>f</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{-1}
  </annotation>
 </semantics>
</math>


 is well defined and easily computable.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Finally notice this solution might be extended for arrays of dimension two with a similar preprocessing.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="examples">Examples</h2>
<h3 id="semigroup-operators">Semigroup operators</h3>

<p> </p>

<p>When the function of interest in a range query is a <a class="uri" href="semigroup" title="wikilink">semigroup</a> operator the notion of 

<math display="inline" id="Range_query_(data_structures):24">
 <semantics>
  <msup>
   <mi>f</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>f</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{-1}
  </annotation>
 </semantics>
</math>

 is not always defined, therefore we can not use an analogous strategy to the previous section. Yao showed<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> that there exists an efficient solution for range queries that involve semigroup operators. He proved that for any constant 

<math display="inline" id="Range_query_(data_structures):25">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

, a preprocessing of time and space 

<math display="inline" id="Range_query_(data_structures):26">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>c</mi>
     <mo>⋅</mo>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>θ</ci>
    <apply>
     <ci>normal-⋅</ci>
     <ci>c</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta(c\cdot n)
  </annotation>
 </semantics>
</math>

 allows to answer range queries on lists where 

<math display="inline" id="Range_query_(data_structures):27">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is a semigroup operator in 

<math display="inline" id="Range_query_(data_structures):28">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>c</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>θ</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>c</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta(\alpha_{c}(n))
  </annotation>
 </semantics>
</math>


 time, where 

<math display="inline" id="Range_query_(data_structures):29">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{k}
  </annotation>
 </semantics>
</math>

 is a certain functional inverse of the <a href="Ackermann_function" title="wikilink">Ackermann function</a>.</p>

<p>There are some semigroup operators that admit slightly better solutions. For instance when 

<math display="inline" id="Range_query_(data_structures):30">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>max</mi>
    <mo>,</mo>
    <mi>min</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>f</ci>
    <set>
     <max></max>
     <min></min>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\in\{\max,\min\}
  </annotation>
 </semantics>
</math>

. Assume 

<math display="inline" id="Range_query_(data_structures):31">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <mi>min</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>f</ci>
    <min></min>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=\min
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Range_query_(data_structures):32">
 <semantics>
  <mrow>
   <mi>min</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mn>1..</mn>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <min></min>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <cn type="float">1..</cn>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min(A[1..n])
  </annotation>
 </semantics>
</math>

 returns the index of the <a class="uri" href="minimum" title="wikilink">minimum</a> element of 

<math display="inline" id="Range_query_(data_structures):33">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mn>1..</mn>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <times></times>
      <cn type="float">1..</cn>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A[1..n]
  </annotation>
 </semantics>
</math>


. Then 

<math display="inline" id="Range_query_(data_structures):34">
 <semantics>
  <mrow>
   <mi>min</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <min></min>
    <ci>A</ci>
    <ci>i</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min(A,i,j)
  </annotation>
 </semantics>
</math>

 denotes the corresponding minimum range query. There are several data structures that allow to answer a range minimum query in 

<math display="inline" id="Range_query_(data_structures):35">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1)
  </annotation>
 </semantics>
</math>

 time using a preprocessing of time and space 

<math display="inline" id="Range_query_(data_structures):36">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

. Probably the simplest solution to sketch here is based on the equivalence between this problem and the <a href="Lowest_common_ancestor" title="wikilink">Lowest common ancestor</a> problem. We briefly describe this solution.</p>

<p>The <a href="cartesian_tree" title="wikilink">cartesian tree</a> 

<math display="inline" id="Range_query_(data_structures):37">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{A}
  </annotation>
 </semantics>
</math>

 of an array 

<math display="inline" id="Range_query_(data_structures):38">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="closed">
     <cn type="integer">1</cn>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A[1,n]
  </annotation>
 </semantics>
</math>


 has as root 

<math display="inline" id="Range_query_(data_structures):39">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>m</mi>
    <mi>i</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>i</ci>
     <ci>n</ci>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}=min\{a_{1},a_{2},\ldots,a_{n}\}
  </annotation>
 </semantics>
</math>

 and it has as left and right subtrees the cartesian tree of 

<math display="inline" id="Range_query_(data_structures):40">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mrow>
     <mi>i</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="closed">
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A[1,i-1]
  </annotation>
 </semantics>
</math>

 and the cartesian tree of 

<math display="inline" id="Range_query_(data_structures):41">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="closed">
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A[i+1,n]
  </annotation>
 </semantics>
</math>

 respectively. It is easy to see that a range minimum query 

<math display="inline" id="Range_query_(data_structures):42">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi>i</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>i</ci>
    <ci>n</ci>
    <vector>
     <ci>A</ci>
     <ci>i</ci>
     <ci>j</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   min(A,i,j)
  </annotation>
 </semantics>
</math>

 is the <a href="lowest_common_ancestor" title="wikilink">lowest common ancestor</a> in 

<math display="inline" id="Range_query_(data_structures):43">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{A}
  </annotation>
 </semantics>
</math>


 of 

<math display="inline" id="Range_query_(data_structures):44">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Range_query_(data_structures):45">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{j}
  </annotation>
 </semantics>
</math>

. Since the lowest common ancestor is solvable in constant time using a preprocessing of time and space 

<math display="inline" id="Range_query_(data_structures):46">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 thus so does the range minimum query problem. The solution when <em>f = max</em> is analogous. Cartesian trees can be constructed in linear time.</p>
<h3 id="mode">Mode</h3>

<p>The <em><a href="Mode_(statistics)" title="wikilink">mode</a></em> of an array <em>A</em> is the element that appears the most in <em>A</em>. For instance the mode of 

<math display="inline" id="Range_query_(data_structures):47">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>4</mn>
    <mo>,</mo>
    <mn>5</mn>
    <mo>,</mo>
    <mn>6</mn>
    <mo>,</mo>
    <mn>7</mn>
    <mo>,</mo>
    <mn>4</mn>
    <mo>,</mo>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cn type="integer">4</cn>
     <ci>normal-,</ci>
     <cn type="integer">5</cn>
     <ci>normal-,</ci>
     <cn type="integer">6</cn>
     <ci>normal-,</ci>
     <cn type="integer">7</cn>
     <ci>normal-,</ci>
     <cn type="integer">4</cn>
     <ci>normal-,</ci>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=[4,5,6,7,4,]
  </annotation>
 </semantics>
</math>

 is <em>4</em>. In case of ties any of the most frequent elements might be picked as mode. A range mode query consists in preprocessing 

<math display="inline" id="Range_query_(data_structures):48">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="closed">
     <cn type="integer">1</cn>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A[1,n]
  </annotation>
 </semantics>
</math>


 such that we can find the mode in any range of 

<math display="inline" id="Range_query_(data_structures):49">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="closed">
     <cn type="integer">1</cn>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A[1,n]
  </annotation>
 </semantics>
</math>

. Several data structures have been devised to solve this problem, we summarize some of the results in the following table.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Range Mode Queries</p></th>
<th style="text-align: left;"></th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Space</p></td>
<td style="text-align: left;">
<p>Query Time</p></td>
<td style="text-align: left;">
<p>Restrictions</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Range_query_(data_structures):50">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mrow>
      <mn>2</mn>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <mi>ϵ</mi>
      </mrow>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <cn type="integer">2</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>ϵ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2-2\epsilon})
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Range_query_(data_structures):51">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mi>ϵ</mi>
     </msup>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <ci>ϵ</ci>
     </apply>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{\epsilon}\log n)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Range_query_(data_structures):52">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <mi>ϵ</mi>
   <mo>≤</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>ϵ</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq\epsilon\leq 1/2
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Range_query_(data_structures):53">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mi>n</mi>
        <mo>/</mo>
        <mrow>
         <mi>log</mi>
         <mi>n</mi>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <log></log>
      <apply>
       <log></log>
       <apply>
        <divide></divide>
        <ci>n</ci>
        <apply>
         <log></log>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2}\log\log n/\log n)
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Range_query_(data_structures):54">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
</tr>
</tbody>
</table>

<p>Recently Jørgensen et al. proved a lower bound on the cell probe model of 

<math display="inline" id="Range_query_(data_structures):55">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo>(</mo>
    <mfrac>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>S</mi>
         <mi>w</mi>
        </mrow>
        <mo>/</mo>
        <mi>n</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <apply>
     <divide></divide>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
     <apply>
      <log></log>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>w</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega\left(\frac{\log n}{\log(Sw/n)}\right)
  </annotation>
 </semantics>
</math>

 for any data structure that uses 

<math display="inline" id="Range_query_(data_structures):56">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 cells.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="median">Median</h3>

<p>This particular case is of special interest since finding the <a class="uri" href="median" title="wikilink">median</a> has several applications, for further reference see.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> On the other hand, the median problem, a special case of the <a href="selection_problem" title="wikilink">selection problem</a>, is solvable in O(<em>n</em>), by the <a href="median_of_medians" title="wikilink">median of medians</a> algorithm.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> However its generalization through range median queries is recent.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> A range median query 

<math display="inline" id="Range_query_(data_structures):57">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi>e</mi>
   <mi>d</mi>
   <mi>i</mi>
   <mi>a</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>e</ci>
    <ci>d</ci>
    <ci>i</ci>
    <ci>a</ci>
    <ci>n</ci>
    <vector>
     <ci>A</ci>
     <ci>i</ci>
     <ci>j</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   median(A,i,j)
  </annotation>
 </semantics>
</math>

 where <em>A,i</em> and <em>j</em> have the usual meanings returns the median element of 

<math display="inline" id="Range_query_(data_structures):58">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="closed">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A[i,j]
  </annotation>
 </semantics>
</math>


. Equivalently, 

<math display="inline" id="Range_query_(data_structures):59">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi>e</mi>
   <mi>d</mi>
   <mi>i</mi>
   <mi>a</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>e</ci>
    <ci>d</ci>
    <ci>i</ci>
    <ci>a</ci>
    <ci>n</ci>
    <vector>
     <ci>A</ci>
     <ci>i</ci>
     <ci>j</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   median(A,i,j)
  </annotation>
 </semantics>
</math>

 should return the element of 

<math display="inline" id="Range_query_(data_structures):60">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="closed">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A[i,j]
  </annotation>
 </semantics>
</math>

 of rank 

<math display="inline" id="Range_query_(data_structures):61">
 <semantics>
  <mfrac>
   <mrow>
    <mi>j</mi>
    <mo>-</mo>
    <mi>i</mi>
   </mrow>
   <mn>2</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <minus></minus>
     <ci>j</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{j-i}{2}
  </annotation>
 </semantics>
</math>

. Note that range median queries can not be solved by following any of the previous methods discussed above including Yao's approach for semigroup operators.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>There have been studied two variants of this problem, the <em>offline</em> version, where all the <em>k</em> queries of interest are given in a batch and we are interested in reduce the total cost and a version where all the preprocessing is done <em>up front</em> and we are interested in optimize the cost of any subsequent single query. Concerning the first variant of the problem recently was proven that can be solved in time 

<math display="inline" id="Range_query_(data_structures):62">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>n</mi>
      <mrow>
       <mi>log</mi>
       <mi>k</mi>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>k</mi>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <log></log>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>k</ci>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n\log k+k\log n)
  </annotation>
 </semantics>
</math>

 and space 

<math display="inline" id="Range_query_(data_structures):63">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mi>log</mi>
      <mi>k</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n\log k)
  </annotation>
 </semantics>
</math>


. We describe such a solution.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>The following pseudo code shows how to find the element of rank 

<math display="inline" id="Range_query_(data_structures):64">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Range_query_(data_structures):65">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="closed">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A[i,j]
  </annotation>
 </semantics>
</math>

 an unsorted array of distinct elements, to find the range medians we set 

<math display="inline" id="Range_query_(data_structures):66">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>j</mi>
     <mo>-</mo>
     <mi>i</mi>
    </mrow>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <ci>j</ci>
      <ci>i</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=\frac{j-i}{2}
  </annotation>
 </semantics>
</math>

.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
rangeMedian(A,i,j,r){

  <span class="kw">if</span> A.length() == <span class="dv">1</span> <span class="kw">return</span> A[<span class="dv">1</span>]

  <span class="kw">if</span> A.low is undefined then
    m = median(A)
    A.low  = [e in A | e &lt;= m]
    A.high = [e in A | e &gt; m ]

 calculate t  the number of elements of A[i,j] that belong to A.low

 <span class="kw">if</span> r &lt;= t <span class="kw">return</span> rangeMedian(A.low, i,j,r)
  <span class="kw">else</span> <span class="kw">return</span> rangeMedian(A.high, i,j, r-t)
}</code></pre></div>

<p>Procedure <em>rangeMedian</em> partitions A, using A's median, into two arrays <em>A.low</em> and <em>A.high</em>, where the former contains the elements of <em>A</em> that are less than or equal to the median <em>m</em> and the latter the rest of the elements of <em>A</em>. If we know that the number of elements of 

<math display="inline" id="Range_query_(data_structures):67">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <interval closure="closed">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A[i,j]
  </annotation>
 </semantics>
</math>

 that end up in <em>A.low</em> is <em>t</em> and this number is bigger than <em>r</em> then we should keep looking for the element of rank <em>r</em> in <em>A.low</em> else we should look for the element of rank 

<math display="inline" id="Range_query_(data_structures):68">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>r</mi>
    <mo>-</mo>
    <mi>t</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>r</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (r-t)
  </annotation>
 </semantics>
</math>


 in A.high. To find 

<math display="inline" id="Range_query_(data_structures):69">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, it is enough to find the maximum index 

<math display="inline" id="Range_query_(data_structures):70">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>≤</mo>
   <mrow>
    <mi>i</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>m</ci>
    <apply>
     <minus></minus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\leq i-1
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Range_query_(data_structures):71">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{m}
  </annotation>
 </semantics>
</math>

 is in <em>A.low</em> and the maximum index 

<math display="inline" id="Range_query_(data_structures):72">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mo>≤</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>l</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l\leq j
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Range_query_(data_structures):73">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{l}
  </annotation>
 </semantics>
</math>


 is in A.high. Then 

<math display="inline" id="Range_query_(data_structures):74">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mi>l</mi>
    <mo>-</mo>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <minus></minus>
     <ci>l</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=l-m
  </annotation>
 </semantics>
</math>

. The total cost for any query, without considering the partitioning part, is 

<math display="inline" id="Range_query_(data_structures):75">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log n
  </annotation>
 </semantics>
</math>

 since at most 

<math display="inline" id="Range_query_(data_structures):76">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log n
  </annotation>
 </semantics>
</math>

 recursion calls are done and only a constant number of operations are performed in each of them (to get the value of 

<math display="inline" id="Range_query_(data_structures):77">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 <a href="fractional_cascading" title="wikilink">fractional cascading</a> should be used). If a linear algorithm to find the medians is used, the total cost of preprocessing for 

<math display="inline" id="Range_query_(data_structures):78">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>


 range median queries is 

<math display="inline" id="Range_query_(data_structures):79">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mrow>
    <mi>log</mi>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <apply>
     <log></log>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\log k
  </annotation>
 </semantics>
</math>

. Clearly this algorithm can be easily modified to solve the up front version of the problem.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h2 id="related-problems">Related Problems</h2>

<p>All the problems described above have been studied for higher dimensions as well as their dynamic versions. On the other hand, range queries might be extended to other data structures like <a href="Tree_(data_structure)" title="wikilink">trees</a>,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> such as the <a href="level_ancestor_problem" title="wikilink">level ancestor problem</a>. A similar family of problems are <a href="Range_searching" title="wikilink">orthogonal range</a> queries also known as counting queries.</p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://opendatastructures.org/versions/edition-0.1c/ods-java/node64.html">Open Data Structure - Chapter 13 - Data Structures for Integers</a></li>
<li><a href="http://www.cs.au.dk/~gerth/papers/isaac09median.pdf">Data Structures for Range Median Queries - Gerth Stolting Brodal and Allan Gronlund Jorgensen</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Arrays" title="wikilink">Category:Arrays</a> <a href="Category:Articles_created_via_the_Article_Wizard" title="wikilink">Category:Articles created via the Article Wizard</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
</ol>
</section>
</body>

