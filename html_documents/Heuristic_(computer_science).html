<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1720">Heuristic (computer science)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Heuristic (computer science)</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, <a href="artificial_intelligence" title="wikilink">artificial intelligence</a>, and <a href="mathematical_optimization" title="wikilink">mathematical optimization</a>, a <strong>heuristic</strong> is a technique designed for <a href="problem_solving" title="wikilink">solving a problem</a> more quickly when classic methods are too slow, or for finding an approximate solution when classic methods fail to find any exact solution. This is achieved by trading optimality, completeness, <a href="Accuracy_and_precision" title="wikilink">accuracy</a>, or <a href="Accuracy_and_precision" title="wikilink">precision</a> for speed. In a way, it can be considered a shortcut.</p>
<h2 id="definition-and-motivation">Definition and motivation</h2>

<p>The objective of a heuristic is to produce a solution in a reasonable time frame that is good enough for solving the problem at hand. This solution may not be the best of all the actual solutions to this problem, or it may simply approximate the exact solution. But it is still valuable because finding it does not require a prohibitively long time.</p>

<p>Heuristics may produce results by themselves, or they may be used in conjunction with optimization algorithms to improve their efficiency (e.g., they may be used to generate good seed values).</p>

<p>Results about <a href="NP-hard" title="wikilink">NP-hardness</a> in theoretical computer science make heuristics the only viable option for a variety of complex optimization problems that need to be routinely solved in real-world applications.</p>
<h2 id="trade-off">Trade-off</h2>

<p>The trade-off criteria for deciding whether to use a heuristic for solving a given problem include the following:</p>
<ul>
<li><em>Optimality:</em> When several solutions exist for a given problem, does the heuristic guarantee that the best solution will be found? Is it actually necessary to find the best solution?</li>
</ul>
<ul>
<li><em>Completeness:</em> When several solutions exist for a given problem, can the heuristic find them all? Do we actually need all solutions? Many heuristics are only meant to find one solution.</li>
</ul>
<ul>
<li><em>Accuracy and precision:</em> Can the heuristic provide a confidence interval for the purported solution? Is the error bar on the solution unreasonably large?</li>
</ul>
<ul>
<li><em>Execution time</em>: Is this the best known heuristic for solving this type of problem? Some heuristics converge faster than others. Some heuristics are only marginally quicker than classic methods.</li>
</ul>

<p>In some cases, it may be difficult to decide whether the solution found by the heuristic is good enough, because the theory underlying that heuristic is not very elaborate.</p>
<h2 id="examples">Examples</h2>
<h3 id="simpler-problem">Simpler problem</h3>

<p>One way of achieving the computational performance gain expected of a heuristic consists in solving a simpler problem whose solution is also a solution to the initial problem. Such a heuristic is unable to find all the solutions to the initial problem, but it may find one much faster because the simple problem is easy to solve.</p>
<h3 id="traveling-salesman-problem">Traveling salesman problem</h3>

<p>An example of approximation is described by <a href="Jon_Bentley" title="wikilink">Jon Bentley</a> for solving the <a href="traveling_salesman_problem" title="wikilink">traveling salesman problem</a> (TSP) so as to select the order to draw using a <a href="pen_plotter" title="wikilink">pen plotter</a>. TSP is known to be <a class="uri" href="NP-Complete" title="wikilink">NP-Complete</a> so an optimal solution for even moderate size problem is intractable. Instead, the <a href="greedy_algorithm" title="wikilink">greedy algorithm</a> can be used to give a good but not optimal solution (it is an approximation to the optimal answer) in a reasonably short amount of time. The greedy algorithm heuristic says to pick whatever is currently the best next step regardless of whether that precludes good steps later. It is a heuristic in that practice says it is a good enough solution, theory says there are better solutions (and even can tell how much better in some cases).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h3 id="search">Search</h3>

<p>Another example of heuristic making an algorithm faster occurs in certain search problems. Initially, the heuristic tries every possibility at each step, like the full-space search algorithm. But it can stop the search at any time if the current possibility is already worse than the best solution already found. In such search problems, a heuristic can be used to try good choices first so that bad paths can be eliminated early (see <a href="alpha-beta_pruning" title="wikilink">alpha-beta pruning</a>).</p>
<h3 id="newell-and-simon-heuristic-search-hypothesis">Newell and Simon: Heuristic Search Hypothesis</h3>

<p>In their <a href="Turing_Award" title="wikilink">Turing Award</a> acceptance speech, <a href="Allen_Newell" title="wikilink">Allen Newell</a> and <a href="Herbert_A._Simon" title="wikilink">Herbert A. Simon</a> discuss the Heuristic Search Hypothesis: a physical symbol system will repeatedly generate and modify known symbol structures until the created structure matches the solution structure. Each successive iteration depends upon the step before it, thus the heuristic search learns what avenues to pursue and which ones to disregard by measuring how close the current iteration is to the solution. Therefore, some possibilities will never be generated as they are measured to be less likely to complete the solution.</p>

<p>A heuristic method can accomplish its task by using search trees. However, instead of generating all possible solution branches, a heuristic selects branches more likely to produce outcomes than other branches. It is selective at each decision point, picking branches that are more likely to produce solutions.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h3 id="virus-scanning">Virus scanning</h3>

<p>Many virus scanners use heuristic rules for detecting viruses and other forms of malware. Heuristic scanning looks for code and/or behavioral patterns indicative of a class or family of viruses, with different sets of rules for different viruses. If a file or executing process is observed to contain matching code patterns and/or to be performing that set of activities, then the scanner infers that the file is infected. The most advanced part of behavior-based heuristic scanning is that it can work against highly randomized polymorphic viruses, which simpler string scanning-only approaches cannot reliably detect. Heuristic scanning has the potential to detect many future viruses without requiring the virus to be detected somewhere, submitted to the virus scanner developer, analyzed, and a detection update for the scanner provided to the scanner's users.</p>
<h3 id="russell-and-norvig">Russell and Norvig</h3>

<p>More examples of heuristics search methods can be found in (Russell and Norvig 2010).<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="pitfalls">Pitfalls</h2>

<p>Some heuristics have a strong underlying theory; they are either derived in a top-down manner from the theory or inferred from experimental data. Others are just <a href="rule_of_thumb" title="wikilink">rules of thumb</a> learned empirically without even a glimpse of theory. The latter are exposed to a number of pitfalls.</p>

<p>When a heuristic is reused in various contexts because it has been seen to "work" in one context, without having been mathematically proven to meet a given set of requirements, it is possible that the current data set does not necessarily represent future data sets and that purported "solutions" turn out to be akin to noise.</p>

<p><a href="Statistical_analysis" title="wikilink">Statistical analysis</a> can be conducted when employing heuristics to estimate the probability of incorrect outcomes. To use a heuristic for solving a <a href="Search_problem" title="wikilink">search</a> or a <a href="knapsack_problem" title="wikilink">knapsack</a> problem, it is necessary to check that the heuristic is <a href="admissible_heuristic" title="wikilink">admissible</a>. Given a heuristic function 

<math display="inline" id="Heuristic_(computer_science):0">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mi>g</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>g</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(v_{i},v_{g})
  </annotation>
 </semantics>
</math>

 meant to approximate the true optimal distance 

<math display="inline" id="Heuristic_(computer_science):1">
 <semantics>
  <mrow>
   <msup>
    <mi>d</mi>
    <mo>⋆</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mi>g</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>d</ci>
     <ci>normal-⋆</ci>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>g</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d^{\star}(v_{i},v_{g})
  </annotation>
 </semantics>
</math>

 to the goal node 

<math display="inline" id="Heuristic_(computer_science):2">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>g</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{g}
  </annotation>
 </semantics>
</math>

 in a directed graph 

<math display="inline" id="Heuristic_(computer_science):3">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 containing 

<math display="inline" id="Heuristic_(computer_science):4">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 total nodes or vertexes labeled 

<math display="inline" id="Heuristic_(computer_science):5">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{0},v_{1},\cdots,v_{n}
  </annotation>
 </semantics>
</math>

, "admissible" means that 

<math display="inline" id="Heuristic_(computer_science):6">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>v</mi>
      <mi>g</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <msup>
     <mi>d</mi>
     <mo>⋆</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>v</mi>
      <mi>g</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>h</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>g</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>d</ci>
      <ci>normal-⋆</ci>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>g</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(v_{i},v_{g})\leq d^{\star}(v_{i},v_{g})
  </annotation>
 </semantics>
</math>

 for <em>all</em> 

<math display="inline" id="Heuristic_(computer_science):7">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mi>g</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>g</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (v_{i},v_{g})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Heuristic_(computer_science):8">
 <semantics>
  <mrow>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mi>g</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>i</ci>
     <ci>g</ci>
    </list>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {i,g}\in[0,1,...,n]
  </annotation>
 </semantics>
</math>

.</p>

<p>If a heuristic is not admissible, it may never find the goal, either by ending up in a dead end of graph 

<math display="inline" id="Heuristic_(computer_science):9">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 or by skipping back and forth between two nodes 

<math display="inline" id="Heuristic_(computer_science):10">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Heuristic_(computer_science):11">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{j}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Heuristic_(computer_science):12">
 <semantics>
  <mrow>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
   </mrow>
   <mo>≠</mo>
   <mi>g</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <list>
     <ci>i</ci>
     <ci>j</ci>
    </list>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {i,j}\neq g
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Algorithm" title="wikilink">Algorithm</a></li>
<li><a href="Genetic_algorithm" title="wikilink">Genetic algorithm</a></li>
<li><a class="uri" href="Heuristic" title="wikilink">Heuristic</a></li>
<li><a href="Heuristic_function" title="wikilink">Heuristic function</a></li>
<li><a href="Heuristic_routing" title="wikilink">Heuristic routing</a></li>
<li><a href="Heuristic_evaluation" title="wikilink">Heuristic evaluation</a>: Method for identifying <a class="uri" href="usability" title="wikilink">usability</a> problems in user interfaces.</li>
<li><a class="uri" href="Metaheuristic" title="wikilink">Metaheuristic</a>: Methods for controlling and tuning basic heuristic algorithms, usually with usage of memory and learning.</li>
<li><a class="uri" href="Matheuristics" title="wikilink">Matheuristics</a>: Optimization algorithms made by the interoperation of metaheuristics and mathematical programming (MP) techniques.</li>
<li><a href="Reactive_search_optimization" title="wikilink">Reactive search optimization</a>: Methods using online <a href="machine_learning" title="wikilink">machine learning</a> principles for self-tuning of heuristics.</li>
</ul>
<h2 id="references">References</h2>

<p><a class="uri" href="de:Heuristik#Informatik" title="wikilink">de:Heuristik#Informatik</a>"</p>

<p><a href="Category:Heuristic_algorithms" title="wikilink">Category:Heuristic algorithms</a> <a class="uri" href="Category:Heuristics" title="wikilink">Category:Heuristics</a> <a href="Category:Problem_solving" title="wikilink">Category:Problem solving</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
