<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1070">Induction-recursion (type theory)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Induction-recursion (type theory)</h1>
<hr/>

<p>In <a href="intuitionistic_type_theory" title="wikilink">intuitionistic type theory</a> (ITT), a discipline within <a href="mathematical_logic" title="wikilink">mathematical logic</a>, <strong>induction-recursion</strong> is a feature for simultaneously declaring a type and function on that type. It allows the creation of larger types, such as universes, than <a href="Intuitionistic_type_theory#Inductive_types" title="wikilink">inductive types</a>. The types created still remain <a href="Predicativity" title="wikilink">predicative</a> inside ITT.</p>

<p>An <a href="inductive_definition" title="wikilink">inductive definition</a> is given by rules for generating elements of a type. One can then define functions from that type by induction on the way the elements of the type are generated. Induction-recursion generalizes this situation since one can <em>simultaneously</em> define the type and the function, because the rules for generating elements of the type are allowed to refer to the function.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Induction-recursion can be used to define large types including various universe constructions. It increases the proof-theoretic strength of type theory substantially. Nevertheless, inductive-recursive recursive definitions are still considered <a href="Impredicativity" title="wikilink">predicative</a>.</p>
<h2 id="background">Background</h2>

<p>Induction-Recursion came out of investigations to the rules of Martin-Löf's <a href="intuitionistic_type_theory" title="wikilink">intuitionistic type theory</a>. The type theory has a number of "type formers" and 4 kinds rules for each one. Martin-Löf had hinted that the rules for each type former followed a pattern, which preserved the properties of the type theory (e.g., <a href="Normalization_property_(abstract_rewriting)" title="wikilink">strong normalization</a>, <a href="Impredicativity" title="wikilink">predicativity</a>). Researchers started looking for the most general description of the pattern, since that would tell what kinds of type formers could be added (or not added!) to extend the type theory.</p>

<p>The "universe" type former was the most interesting, because when the rules were written "ala Tarski", they simultaneously defined the "universe type" ''and ''a function that operated on it. This eventually lead Dybjer to Induction-Recursion.</p>

<p>Dybjer's initial papers called Induction-Recursion a "schema" for rules. It stated what type formers could be added to the type theory. Later, he and Setzer would write a new type former with rules that allowed new Induction-Recursion definitions to be made inside the type theory.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> This was added to the Half proof assistant (a variant of <a href="ALF_(proof_assistant)" title="wikilink">Alf</a>).</p>
<h2 id="the-idea">The Idea</h2>

<p>Before covering Inductive-Recursive types, the simpler case is Inductive Types. Constructors for Inductive types can be self-referential, but in a limited way. The constructor's parameters must be "positive":</p>
<ul>
<li>not refer to the type being defined</li>
<li>be exactly the type being defined, or</li>
<li>be a function that returns the type being defined.</li>
</ul>

<p>With Inductive types, a parameter's type can depend on earlier parameters, but they cannot refer to ones of the type being defined. Inductive-Recursive types go further and parameter's types <em>can</em> refer to earlier parameters that use the type being defined. These must be "half-positive":</p>
<ul>
<li>be a function depending on an earlier parameter <strong>if</strong> that parameter is wrapped in the function being defined.</li>
</ul>

<p>So, if 

<math display="inline" id="Induction-recursion_(type_theory):0">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 is the type being defined and 

<math display="inline" id="Induction-recursion_(type_theory):1">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is the function being (simultaneously) defined, these parameter declarations are positive:</p>
<ul>
<li>

<math display="inline" id="Induction-recursion_(type_theory):2">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>:</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>a</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a:A
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Induction-recursion_(type_theory):3">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>:</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>d</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d:D
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Induction-recursion_(type_theory):4">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>:</mo>
   <mrow>
    <mi>A</mi>
    <mo>→</mo>
    <mrow>
     <mi>T</mi>
     <mi>y</mi>
     <mi>p</mi>
     <mi>e</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>y</ci>
      <ci>p</ci>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g:A\to Type
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Induction-recursion_(type_theory):5">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>:</mo>
   <mrow>
    <mi>A</mi>
    <mo>→</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>h</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>A</ci>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h:A\to D
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Induction-recursion_(type_theory):6">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>:</mo>
   <mrow>
    <mi>A</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo>→</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>i</ci>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <ci>D</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i:A\to B\to D
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Induction-recursion_(type_theory):7">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>:</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mi>a</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>j</ci>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j:g\ a
  </annotation>
 </semantics>
</math>

 (Depends on earlier parameters, none of which are type 

<math display="inline" id="Induction-recursion_(type_theory):8">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

.)</li>
</ul>

<p>This is half-positive:</p>
<ul>
<li>

<math display="inline" id="Induction-recursion_(type_theory):9">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>f</mi>
      </mpadded>
      <mi>d</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>k</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>d</ci>
     </apply>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k:(f\ d)\to D
  </annotation>
 </semantics>
</math>

 (Depends on parameter 

<math display="inline" id="Induction-recursion_(type_theory):10">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 of type 

<math display="inline" id="Induction-recursion_(type_theory):11">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 but only through call to 

<math display="inline" id="Induction-recursion_(type_theory):12">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

.)</li>
</ul>

<p>These are <strong>not</strong> positive nor half-positive:</p>
<ul>
<li>

<math display="inline" id="Induction-recursion_(type_theory):13">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>:</mo>
   <mrow>
    <mi>D</mi>
    <mo>→</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>k</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>D</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k:D\to A
  </annotation>
 </semantics>
</math>

 (

<math display="inline" id="Induction-recursion_(type_theory):14">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 is a parameter to the function.)</li>
<li>

<math display="inline" id="Induction-recursion_(type_theory):15">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mi>D</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">l</csymbol>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">A</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l:(A\to D)\to A
  </annotation>
 </semantics>
</math>

 (The parameter takes a function that returns 

<math display="inline" id="Induction-recursion_(type_theory):16">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

, but returns 

<math display="inline" id="Induction-recursion_(type_theory):17">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 itself.)</li>
<li>

<math display="inline" id="Induction-recursion_(type_theory):18">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>:</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>z</mi>
    </mpadded>
    <mi>d</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>m</ci>
    <apply>
     <times></times>
     <ci>z</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m:z\ d
  </annotation>
 </semantics>
</math>

 (Depends on 

<math display="inline" id="Induction-recursion_(type_theory):19">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 of type 

<math display="inline" id="Induction-recursion_(type_theory):20">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

, but not through the function 

<math display="inline" id="Induction-recursion_(type_theory):21">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

.)</li>
</ul>
<h2 id="universe-example">Universe Example</h2>

<p>A simple common example is the Universe ala Tarski type former. It creates a type 

<math display="inline" id="Induction-recursion_(type_theory):22">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 and a function 

<math display="inline" id="Induction-recursion_(type_theory):23">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

. There is an element of 

<math display="inline" id="Induction-recursion_(type_theory):24">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 for every type in the type theory (except 

<math display="inline" id="Induction-recursion_(type_theory):25">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 itself!). The function 

<math display="inline" id="Induction-recursion_(type_theory):26">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 maps the elements of 

<math display="inline" id="Induction-recursion_(type_theory):27">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 to the associated type.</p>

<p>The type 

<math display="inline" id="Induction-recursion_(type_theory):28">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 has a constructor (or introduction rule) for each type former in the type theory. The one for dependent functions would be:</p>

<p>

<math display="inline" id="Induction-recursion_(type_theory):29">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mi>o</mi>
   <mi>n</mi>
   <mi>s</mi>
   <mi>t</mi>
   <mi>r</mi>
   <mi>u</mi>
   <mi>c</mi>
   <mi>t</mi>
   <mi>o</mi>
   <msub>
    <mi>r</mi>
    <mi mathvariant="normal">Π</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>:</mo>
    <mi>U</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>u</mi>
     <mo>′</mo>
    </msup>
    <mo>:</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>:</mo>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>U</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:</mo>
   <mi>U</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">c</csymbol>
    <csymbol cd="unknown">o</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <csymbol cd="unknown">u</csymbol>
    <csymbol cd="unknown">c</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <csymbol cd="unknown">o</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>normal-Π</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">U</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>u</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-:</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-:</ci>
      <csymbol cd="unknown">T</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">u</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">U</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-:</ci>
    <csymbol cd="unknown">U</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   constructor_{\Pi}(u:U)(u^{\prime}:(x:T(u))U):U
  </annotation>
 </semantics>
</math>

</p>

<p>That is, it takes an element 

<math display="inline" id="Induction-recursion_(type_theory):30">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 of type 

<math display="inline" id="Induction-recursion_(type_theory):31">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 that will map to the type of the parameter and an element 

<math display="inline" id="Induction-recursion_(type_theory):32">
 <semantics>
  <msup>
   <mi>u</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>u</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u^{\prime}
  </annotation>
 </semantics>
</math>

 that will map to the return type of the function (which is dependent on the value of the parameter). (The final 

<math display="inline" id="Induction-recursion_(type_theory):33">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>:</mo>
   <mi>U</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <csymbol cd="latexml">absent</csymbol>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   :U
  </annotation>
 </semantics>
</math>

 says that the result of the constructor is an element of type 

<math display="inline" id="Induction-recursion_(type_theory):34">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

.)</p>

<p>The reduction (or computation rule) says that</p>

<p>

<math display="inline" id="Induction-recursion_(type_theory):35">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>c</mi>
     <mi>o</mi>
     <mi>n</mi>
     <mi>s</mi>
     <mi>t</mi>
     <mi>r</mi>
     <mi>u</mi>
     <mi>c</mi>
     <mi>t</mi>
     <mi>o</mi>
     <msub>
      <mi>r</mi>
      <mi mathvariant="normal">Π</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <msup>
       <mi>u</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>o</ci>
     <ci>n</ci>
     <ci>s</ci>
     <ci>t</ci>
     <ci>r</ci>
     <ci>u</ci>
     <ci>c</ci>
     <ci>t</ci>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>normal-Π</ci>
     </apply>
     <interval closure="open">
      <ci>u</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>u</ci>
       <ci>normal-′</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(constructor_{\Pi}(u,u^{\prime}))
  </annotation>
 </semantics>
</math>

 becomes 

<math display="inline" id="Induction-recursion_(type_theory):36">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Π</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>u</mi>
        <mo>′</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Π</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>T</ci>
      <ci>u</ci>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>T</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>u</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi(T(u),(x)T(u^{\prime}(x)))
  </annotation>
 </semantics>
</math>

</p>

<p>After reduction, the function 

<math display="inline" id="Induction-recursion_(type_theory):37">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is operating on a smaller part of the input. If that holds when 

<math display="inline" id="Induction-recursion_(type_theory):38">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is applied to any constructor, then 

<math display="inline" id="Induction-recursion_(type_theory):39">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 will always terminate. Without going into the details, Induction-Recursion states what kinds of definitions (or rules) can be added to the theory such that the function calls will always terminate.</p>
<h2 id="usage">Usage</h2>

<p>Induction-Recursion is implemented in <a href="Agda_(programming_language)" title="wikilink">Agda</a> and <a href="Idris_(programming_language)" title="wikilink">Idris</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Induction-Induction_(type_theory)" title="wikilink"> Induction-Induction</a> Further work that defines a type and family-of-types at the same time.</li>
</ul>

<p>References</p>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cse.chalmers.se/~peterd/papers/inductive.html">A list of Peter Dybjer's publications on induction and induction-recursion</a></li>
</ul>
<ul>
<li><a href="http://www.cs.swan.ac.uk/~csetzer/slides/dybjer60thBirthdayGothenburgJune2013/dybjer60thBirthdayGothenburgJune2013.pdf">Slides covering Induction-Recursion and its derivatives</a></li>
</ul>

<p>"</p>

<p><a href="Category:Type_theory" title="wikilink">Category:Type theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
