<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1636">Schaefer's dichotomy theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Schaefer's dichotomy theorem</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, a branch of <a href="computer_science" title="wikilink">computer science</a>, <strong>Schaefer's dichotomy theorem</strong> states necessary and sufficient conditions under which a finite set <em>S</em> of relations over the Boolean domain yields <a href="P_(complexity)" title="wikilink">polynomial-time</a> or <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problems when the relations of <em>S</em> are used to constrain some of the <a href="propositional_variable" title="wikilink">propositional variables</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It is called a <strong>dichotomy theorem</strong> because the complexity of the problem defined by <em>S</em> is either in P or NP-complete as opposed to one of the classes of <a href="NP-intermediate" title="wikilink">intermediate complexity</a> that is known to exist (assuming <a href="P_versus_NP_problem" title="wikilink">P ≠ NP</a>) by <a href="Ladner's_theorem" title="wikilink">Ladner's theorem</a>.</p>

<p>Special cases of Schaefer's dichotomy theorem include the NP-completeness of SAT (the <a href="Boolean_satisfiability_problem" title="wikilink">Boolean satisfiability problem</a>) and its two popular variants <a href="One-in-three_3SAT" title="wikilink">1-in-3 SAT</a> and Not-All-Equal 3SAT (often denoted by NAE-3SAT). In fact, for these two variants of SAT, Schaefer's dichotomy theorem shows that their monotone versions (where negations of variables are not allowed) are also NP-complete.</p>
<h2 id="original-presentation">Original presentation</h2>

<p>Schaefer defines a <a href="decision_problem" title="wikilink">decision problem</a> that he calls the Generalized Satisfiability problem for <em>S</em> (denoted by SAT(<em>S</em>)). An instance of the problem is an <em>S</em>-formula, i.e. a conjunction of constraints of the form 

<math display="inline" id="Schaefer's_dichotomy_theorem:0">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <msub>
      <mi>i</mi>
      <mn>1</mn>
     </msub>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <msub>
      <mi>i</mi>
      <mi>n</mi>
     </msub>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>i</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(x_{i_{1}},\ldots,x_{i_{n}})
  </annotation>
 </semantics>
</math>

 where R is a relation in <em>S</em> and the 

<math display="inline" id="Schaefer's_dichotomy_theorem:1">
 <semantics>
  <msub>
   <mi>x</mi>
   <msub>
    <mi>i</mi>
    <mi>j</mi>
   </msub>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i_{j}}
  </annotation>
 </semantics>
</math>

 are propositional variables. The problem is to determine whether the given formula is satisfiable, in other words if the variables can be assigned values such that they satisfy all the constraints.</p>

<p>Schaefer identifies six classes of sets of Boolean relations for which SAT(<em>S</em>) is in P and proves that all other sets of relations generate an NP-complete problem. A finite set of relations <em>S</em> over the Boolean domain defines a polynomial time computable satisfiability problem if any one of the following conditions holds:</p>
<ol>
<li>all relations which are not constantly false are true when all its arguments are true;</li>
<li>all relations which are not constantly false are true when all its arguments are false;</li>
<li>all relations are equivalent to a conjunction of binary clauses;</li>
<li>all relations are equivalent to a conjunction of <a href="Horn_clause" title="wikilink">Horn clauses</a>;</li>
<li>all relations are equivalent to a conjunction of dual-Horn clauses;</li>
<li>all relations are equivalent to a conjunction of affine formulae. <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></li>
</ol>

<p>Otherwise, the problem SAT(<em>S</em>) is NP-complete.</p>
<h2 id="modern-presentation">Modern presentation</h2>

<p>A modern, streamlined presentation of Schaefer's theorem is given in an expository paper by Hubie Chen.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> In modern terms, the problem SAT(<em>S</em>) is viewed as a <a href="constraint_satisfaction_problem" title="wikilink">constraint satisfaction problem</a> over the <a href="Boolean_domain" title="wikilink">Boolean domain</a>. In this area, it is standard to denote the set of relations by Γ and the decision problem defined by Γ as CSP(Γ).</p>

<p>This modern understanding uses algebra, in particular, <a href="universal_algebra" title="wikilink">universal algebra</a>. For Schaefer's dichotomy theorem, the most important concept in universal algebra is that of a polymorphism. An operation 

<math display="inline" id="Schaefer's_dichotomy_theorem:2">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>D</mi>
     <mi>m</mi>
    </msup>
    <mo>→</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>D</ci>
      <ci>m</ci>
     </apply>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:D^{m}\to D
  </annotation>
 </semantics>
</math>

 is a polymorphism of a relation 

<math display="inline" id="Schaefer's_dichotomy_theorem:3">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>⊆</mo>
   <msup>
    <mi>D</mi>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>R</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>D</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\subseteq D^{k}
  </annotation>
 </semantics>
</math>

 if, for any choice of <em>m</em> tuples 

<math display="inline" id="Schaefer's_dichotomy_theorem:4">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mn>11</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>t</mi>
     <mrow>
      <mn>1</mn>
      <mi>k</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mrow>
      <mi>m</mi>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>t</mi>
     <mrow>
      <mi>m</mi>
      <mi>k</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">11</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <apply>
       <times></times>
       <cn type="integer">1</cn>
       <ci>k</ci>
      </apply>
     </apply>
    </vector>
    <ci>normal-…</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </vector>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (t_{11},\ldots,t_{1k}),\ldots,(t_{m1},\ldots,t_{mk})
  </annotation>
 </semantics>
</math>

 from <em>R</em>, it holds that the tuple obtained from these <em>m</em> tuples by applying <em>f</em> coordinate-wise, i.e. 

<math display="inline" id="Schaefer's_dichotomy_theorem:5">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>t</mi>
      <mn>11</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>t</mi>
      <mrow>
       <mi>m</mi>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>t</mi>
      <mrow>
       <mn>1</mn>
       <mi>k</mi>
      </mrow>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>t</mi>
      <mrow>
       <mi>m</mi>
       <mi>k</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">11</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </vector>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <apply>
        <times></times>
        <cn type="integer">1</cn>
        <ci>k</ci>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </vector>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f(t_{11},\ldots,t_{m1}),\ldots,f(t_{1k},\ldots,t_{mk}))
  </annotation>
 </semantics>
</math>

, is in <em>R</em>. That is, an operation <em>f</em> is a polymorphism of <em>R</em> if <em>R</em> is closed under <em>f</em>: applying <em>f</em> to any tuples in <em>R</em> yields another tuple inside <em>R</em>. A set of relations Γ is said to have a polymorphism <em>f</em> if every relation in Γ has <em>f</em> as a polymorphism. This definition allows for the algebraic formulation of Schaefer's dichotomy theorem.</p>

<p>Let Γ be a finite constraint language over the Boolean domain. The problem CSP(Γ) is decidable in polynomial-time if Γ has one of the following six operations as a polymorphism:</p>
<ol>
<li>the constant unary operation 0;</li>
<li>the constant unary operation 1;</li>
<li>the binary AND operation ∧;</li>
<li>the binary OR operation ∨;</li>
<li>the ternary majority operation 

<math display="inline" id="Schaefer's_dichotomy_theorem:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>Majority</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>∧</mo>
       <mi>y</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∨</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>∧</mo>
       <mi>z</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∨</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>y</mi>
       <mo>∧</mo>
       <mi>z</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>Majority</ci>
     <ci>x</ci>
     <ci>y</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <or></or>
     <apply>
      <and></and>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <and></and>
      <ci>x</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <and></and>
      <ci>y</ci>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Majority}(x,y,z)=(x\wedge y)\vee(x\wedge z)\vee(y\wedge z);
  </annotation>
 </semantics>
</math>

</li>
<li>the ternary minority operation 

<math display="inline" id="Schaefer's_dichotomy_theorem:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>Minority</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>x</mi>
     <mo>⊕</mo>
     <mi>y</mi>
     <mo>⊕</mo>
     <mi>z</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>Minority</ci>
     <ci>x</ci>
     <ci>y</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <ci>x</ci>
     <ci>y</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Minority}(x,y,z)=x\oplus y\oplus z.
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>Otherwise, the problem CSP(Γ) is NP-complete.</p>

<p>In this formulation, it is easy to check if any of the tractability conditions hold.</p>
<h2 id="properties-of-polymorphisms">Properties of Polymorphisms</h2>

<p>Given a set Γ of relations, there is a surprisingly close connection between its polymorphisms and the computational complexity of CSP(Γ).</p>

<p>A relation <em>R</em> is called <strong>primitive positive definable</strong>, or short <strong>pp-definable</strong>, from a set Γ of relations if <em>R</em>(<em>v</em><sub>1</sub>, ... , <em>v</em><sub><em>k</em></sub>) ⇔ ∃<em>x</em><sub>1</sub> ... <em>x</em><sub><em>m</em></sub>. <em>C</em> holds for some conjunction <em>C</em> of constraints from Γ and equations over the variables {<em>v</em><sub>1</sub>,...,<em>v</em><sub><em>k</em></sub>, <em>x</em><sub>1</sub>,...,<em>x</em><sub><em>m</em></sub>}. For example, if Γ consists of the ternary relation <em>nae</em>(<em>x</em>,<em>y</em>,<em>z</em>) holding if <em>x</em>,<em>y</em>,<em>z</em> are not all equal, and <em>R</em>(<em>x</em>,<em>y</em>,<em>z</em>) is <em>x</em>∨<em>y</em>∨<em>z</em>, then <em>R</em> can be pp-defined by <em>R</em>(<em>x</em>,<em>y</em>,<em>z</em>) ⇔ ∃<em>a</em>. <em>nae</em>(0,<em>x</em>,<em>a</em>) ∧ <em>nae</em>(<em>y</em>,<em>z</em>,¬<em>a</em>); this reduction has been used to prove that NAE-3SAT is NP-complete. The set of all relations which are pp-definable from Γ is denoted by ≪Γ≫. If Γ' ⊆ ≪Γ≫ for some finite constraint sets Γ and Γ', then CSP(Γ') <a href="Reduction_(complexity)" title="wikilink">reduces</a> to CSP(Γ).<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>Given a set Γ of relations, <em>Pol</em>(Γ) denotes the set of polymorphisms of Γ. Conversely, if <em>O</em> is a set of operations, then <em>Inv</em>(<em>O</em>) denotes the set of relations having all operations in <em>O</em> as a polymorphism. <em>Pol</em> and <em>Inv</em> together build a <a href="Galois_connection" title="wikilink">Galois connection</a>. For any finite set Γ of relations over a finite domain, ≪Γ≫ = Inv(Pol(Γ)) holds, that is, the set of relations pp-definable from Γ can be derived from the polymorphisms of Γ.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Moreover, if <em>Pol</em>(Γ) ⊆ <em>Pol(Γ')</em> for two finite relation sets Γ and Γ', then Γ' ⊆ ≪Γ≫ and CSP(Γ') reduces to CSP(Γ). As a consequence, two relation sets having the same polymorphisms lead to the same computational complexity.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="generalizations">Generalizations</h2>

<p>The analysis was later fine-tuned: CSP(Γ) is either solvable in co-NLOGTIME, <a href="L_(complexity)" title="wikilink">L-complete</a>, <a class="uri" href="NL-complete" title="wikilink">NL-complete</a>, ⊕L-complete, <a class="uri" href="P-complete" title="wikilink">P-complete</a> or NP-complete and given Γ, one can decide in polynomial time which of these cases holds.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>Schaefer's dichotomy theorem was recently generalized to a larger class of relations.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="related-work">Related work</h2>

<p>If the problem is to count the number of solutions, which is denoted by #CSP(Γ), then a similar result by Creignou and Hermann holds.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Let Γ be a finite constraint language over the Boolean domain. The problem #CSP(Γ) is computable in polynomial time if Γ has a Mal'tsev operation as a polymorphism. Otherwise, the problem #CSP(Γ) is <a href="Sharp-P-complete" title="wikilink">#P-complete</a>. A Mal'tsev operation <em>m</em> is a ternary operation that satisfies 

<math display="inline" id="Schaefer's_dichotomy_theorem:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>m</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>m</ci>
      <vector>
       <ci>x</ci>
       <ci>y</ci>
       <ci>y</ci>
      </vector>
     </apply>
     <apply>
      <times></times>
      <ci>m</ci>
      <vector>
       <ci>y</ci>
       <ci>y</ci>
       <ci>x</ci>
      </vector>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m(x,y,y)=m(y,y,x)=x.
  </annotation>
 </semantics>
</math>

 An example of a Mal'tsev operation is the Minority operation given in the modern, algebraic formulation of Schaefer's dichotomy theorem above. Thus, when Γ has the Minority operation as a polymorphism, it is not only possible to decide CSP(Γ) in polynomial time, but to compute #CSP(Γ) in polynomial time. Other examples of Mal'tsev operations include 

<math display="inline" id="Schaefer's_dichotomy_theorem:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>-</mo>
    <mi>y</mi>
   </mrow>
   <mo>+</mo>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <minus></minus>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x-y+z
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Schaefer's_dichotomy_theorem:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <msup>
     <mi>y</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>z</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   xy^{-1}z.
  </annotation>
 </semantics>
</math>

</p>

<p>For larger domains, even for a domain of size three, the existence of a Maltsev polymorphism for Γ is no longer a sufficient condition for the tractability of #CSP(Γ). However, the absence of a Mal'tsev polymorphism for Γ still implies the #P-hardness of #CSP(Γ).</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Max/min_CSP/Ones_classification_theorems" title="wikilink">Max/min CSP/Ones classification theorems</a>, a similar set of constraints for optimization problems</li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Constraint_programming" title="wikilink">Category:Constraint programming</a> <a href="Category:Theorems_in_computational_complexity_theory" title="wikilink">Category:Theorems in computational complexity theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">Schaefer (1978, p.218 left) defines an <strong>affine formula</strong> to be of the form <em>x</em><sub>1</sub> ⊕ ... ⊕ <em>x</em><sub><em>n</em></sub> = <em>c</em>, where each <em>x</em><sub><em>i</em></sub> is a variable, <em>c</em> is a constant, i.e. <em>true</em> or <em>false</em>, and "⊕" denotes <a class="uri" href="XOR" title="wikilink">XOR</a>, i.e. addition in a <a href="Boolean_ring" title="wikilink">Boolean ring</a>.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">Chen (2006), p.8, Proposition 3.9; Chen uses polynomial-time <a href="many-one_reduction" title="wikilink">many-one reduction</a><a href="#fnref5">↩</a></li>
<li id="fn6">Chen (2006), p.9, Theorem 3.13<a href="#fnref6">↩</a></li>
<li id="fn7">Chen (2006), p.11, Theorem 3.15<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
</ol>
</section>
</body>
</html>
