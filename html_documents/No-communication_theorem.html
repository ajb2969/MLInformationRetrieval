<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="739">No-communication theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>No-communication theorem</h1>
<hr>In [[physics]], the '''no-communication theorem''' is a [[no-go theorem]] from [[quantum information theory]] which states that, during measure
<p>ment of an <a href="quantum_entanglement" title="wikilink">entangled quantum state</a>, it is not possible for one observer, by making a measurement of a subsystem of the total state, to communicate information to another observer. The theorem is important because, in <a href="quantum_mechanics" title="wikilink">quantum mechanics</a>, <a href="quantum_entanglement" title="wikilink">quantum entanglement</a> is an effect by which certain widely separated events can be correlated in ways that suggest the possibility of instantaneous communication. The no-communication theorem gives conditions under which such transfer of information between two observers is impossible. These results can be applied to understand the so-called paradoxes in <a href="quantum_mechanics" title="wikilink">quantum mechanics</a>, such as the <a href="EPR_paradox" title="wikilink">EPR paradox</a>, or violations of <a href="local_realism" title="wikilink">local realism</a> obtained in tests of <a href="Bell's_theorem" title="wikilink">Bell's theorem</a>. In these experiments, the no-communication theorem shows that failure of local realism does not lead to what could be referred to as "spooky communication at a distance" (in analogy with Einstein's labeling of <a href="quantum_entanglement" title="wikilink">quantum entanglement</a> as "spooky action at a distance").</p>

<p>In very rough terms, the theorem describes a situation that is analogous to two people, each with a radio receiver, listening to a common radio station: it is impossible for one of the listeners to use their radio receiver to send messages to the other listener. This analogy is imprecise, because quantum entanglement suggests that perhaps a message could have been conveyed; the theorem replies 'no, this is not possible'.</p>
<h2 id="informal-overview">Informal overview</h2>

<p>The no-communication theorem states that, within the context of quantum mechanics, it is not possible to transmit classical bits of information by means of carefully prepared <a href="mixed_state_(physics)" title="wikilink">mixed</a> or <a href="pure_state" title="wikilink">pure states</a>, whether <a href="entangled_state" title="wikilink">entangled</a> or not. The theorem disallows all communication, not just faster-than-light communication, by means of shared quantum states. The theorem disallows not only the communication of whole bits, but even fractions of a bit. This is important to take note of, as there are many classical radio communications encoding techniques that can send arbitrarily small fractions of a bit across arbitrarily narrow, noisy <a href="communications_channel" title="wikilink">communications channels</a>. In particular, one may imagine that there is some <a href="statistical_ensemble_(mathematical_physics)" title="wikilink">ensemble</a> that can be prepared, with small portions of the ensemble communicating a fraction of a bit; this, too, is not possible.</p>

<p>The theorem is built on the basic presumption that the laws of quantum mechanics hold. Similar theorems may or may not hold for other related theories,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> such as <a href="hidden_variable_theory" title="wikilink">hidden variable theories</a>. The no-communication theorem is not meant to constrain other, non-quantum-mechanical theories.</p>

<p>The basic assumption entering into the theorem is that a quantum-mechanical system is prepared in an initial state, and that this initial state is describable as a mixed or pure state in a <a href="Hilbert_space" title="wikilink">Hilbert space</a> <em>H</em>. The system then evolves over time in such a way that there are two spatially distinct parts, <em>A</em> and <em>B</em>, sent to two distinct observers, <a href="Alice_and_Bob" title="wikilink">Alice and Bob</a>, who are free to perform quantum mechanical measurements on their portion of the total system (viz, A and B). The question is: is there any action that Alice can perform that would be detectable by Bob? The theorem replies 'no'.</p>

<p>An important assumption going into the theorem is that neither Alice nor Bob is allowed, in any way, to affect the preparation of the initial state. If Alice were allowed to take part in the preparation of the initial state, it would be trivially easy for her to encode a message into it; thus neither Alice nor Bob participates in the preparation of the initial state. The theorem does not require that the initial state be somehow 'random' or 'balanced' or 'uniform': indeed, a third party preparing the initial state could easily encode messages in it, received by Alice and Bob. Simply, the theorem states that, given some initial state, prepared in some way, there is no action that Alice can take that would be detectable by Bob.</p>

<p>The proof proceeds by defining how the total Hilbert space <em>H</em> can be split into two parts, <em>H</em><sub><em>A</em></sub> and <em>H</em><sub><em>B</em></sub>, describing the subspaces accessible to Alice and Bob. The total state of the system is assumed to be described by a <a href="density_matrix" title="wikilink">density matrix</a> σ. This appears to be a reasonable assumption, as a density matrix is sufficient to describe both pure and mixed states in quantum mechanics. Another important part of the theorem is that measurement is performed by applying a generalized <a href="projection_operator" title="wikilink">projection operator</a> <em>P</em> to the state σ. This again is reasonable, as projection operators give the appropriate mathematical description of <a href="quantum_measurement" title="wikilink">quantum measurements</a>. After a measurement by Alice, the state of the total system is said to have <em><a href="wave-function_collapse" title="wikilink">collapsed</a></em> to a state <em>P</em>(σ).</p>

<p>The goal of the theorem is to prove that Bob cannot in any way distinguish the pre-measurement state σ from the post-measurement state <em>P</em>(σ). This is accomplished mathematically by comparing the <a href="trace_(linear_algebra)" title="wikilink">trace</a> of σ and the trace of <em>P</em>(σ), with the trace being taken over the subspace <em>H</em><sub><em>A</em></sub>. Since the trace is only over a subspace, it is technically called a <a href="partial_trace" title="wikilink">partial trace</a>. Key to this step is the assumption that the (partial) trace adequately summarizes the system from Bob's point of view. That is, everything that Bob has access to, or could ever have access to, measure, or detect, is completely described by a partial trace over <em>H</em><sub>A</sub> of the system σ. Again, this is a reasonable assumption, as it is a part of standard quantum mechanics. The fact that this trace never changes as Alice performs her measurements is the conclusion of the proof of the no-communication theorem.</p>
<h2 id="formulation">Formulation</h2>

<p>The proof of the theorem is commonly illustrated for the setup of <a href="Bell_test" title="wikilink">Bell tests</a> in which two observers <a href="Alice_and_Bob" title="wikilink">Alice and Bob</a> perform local observations on a common bipartite system, and uses the statistical machinery of quantum mechanics, namely <a href="density_state" title="wikilink">density states</a> and <a href="quantum_operation" title="wikilink">quantum operations</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Alice and Bob perform measurements on system <strong>S</strong> whose underlying <a href="Hilbert_space" title="wikilink">Hilbert space</a> is</p>

<p>

<math display="block" id="No-communication_theorem:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>H</mi>
      <mi>A</mi>
     </msub>
     <mo>⊗</mo>
     <msub>
      <mi>H</mi>
      <mi>B</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=H_{A}\otimes H_{B}.
  </annotation>
 </semantics>
</math>

</p>

<p>It is also assumed that everything is finite-dimensional to avoid convergence issues. The state of the composite system is given by a density operator on <em>H</em>. Any <a href="density_operator" title="wikilink">density operator</a> σ on <em>H</em> is a sum of the form:</p>

<p>

<math display="block" id="No-communication_theorem:1">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <msub>
      <mi>T</mi>
      <mi>i</mi>
     </msub>
     <mo>⊗</mo>
     <msub>
      <mi>S</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>σ</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma=\sum_{i}T_{i}\otimes S_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>T<sub>i</sub></em> and <em>S<sub>i</sub></em> are operators on <em>H</em><sub><em>A</em></sub> and <em>H</em><sub><em>B</em></sub>. For the following, it is not required to assume that <em>T<sub>i</sub></em> and <em>S<sub>i</sub></em> are state projection operators: <em>i.e.</em> they need not necessarily be non-negative, nor have a trace of one. That is, σ can have a definition somewhat broader than that of a density matrix; the theorem still holds. Note that the theorem holds trivially for <a href="separable_state" title="wikilink">separable states</a>. If the shared state σ is separable, it is clear that any local operation by Alice will leave Bob's system intact. Thus the point of the theorem is no communication can be achieved via a shared entangled state.</p>

<p>Alice performs a local measurement on her subsystem. In general, this is described by a quantum operation, on the system state, of the following kind</p>

<p>

<math display="block" id="No-communication_theorem:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>σ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>k</mi>
     </munder>
     <mrow>
      <mpadded width="+5pt">
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mi>V</mi>
           <mi>k</mi>
          </msub>
          <mo>⊗</mo>
          <msub>
           <mi>I</mi>
           <msub>
            <mi>H</mi>
            <mi>B</mi>
           </msub>
          </msub>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>*</mo>
       </msup>
      </mpadded>
      <mpadded width="+5pt">
       <mi>σ</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>V</mi>
         <mi>k</mi>
        </msub>
        <mo>⊗</mo>
        <msub>
         <mi>I</mi>
         <msub>
          <mi>H</mi>
          <mi>B</mi>
         </msub>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>σ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>V</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>I</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>H</ci>
          <ci>B</ci>
         </apply>
        </apply>
       </apply>
       <times></times>
      </apply>
      <ci>σ</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <ci>B</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\sigma)=\sum_{k}(V_{k}\otimes I_{H_{B}})^{*}\ \sigma\ (V_{k}\otimes I_{H_{B}%
}),
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>V</em><sub><em>k</em></sub> are called <a href="completely_positive_map" title="wikilink">Kraus matrices</a> which satisfy</p>

<p>

<math display="block" id="No-communication_theorem:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>k</mi>
     </munder>
     <mrow>
      <msub>
       <mi>V</mi>
       <mi>k</mi>
      </msub>
      <msubsup>
       <mi>V</mi>
       <mi>k</mi>
       <mo>*</mo>
      </msubsup>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>I</mi>
     <msub>
      <mi>H</mi>
      <mi>A</mi>
     </msub>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <ci>k</ci>
       </apply>
       <times></times>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{k}V_{k}V_{k}^{*}=I_{H_{A}}.
  </annotation>
 </semantics>
</math>

</p>

<p>The term</p>

<p>

<math display="block" id="No-communication_theorem:4">
 <semantics>
  <msub>
   <mi>I</mi>
   <msub>
    <mi>H</mi>
    <mi>B</mi>
   </msub>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{H_{B}}
  </annotation>
 </semantics>
</math>

</p>

<p>from the expression</p>

<p>

<math display="block" id="No-communication_theorem:5">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>V</mi>
     <mi>k</mi>
    </msub>
    <mo>⊗</mo>
    <msub>
     <mi>I</mi>
     <msub>
      <mi>H</mi>
      <mi>B</mi>
     </msub>
    </msub>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (V_{k}\otimes I_{H_{B}})
  </annotation>
 </semantics>
</math>

</p>

<p>means that Alice's measurement apparatus does not interact with Bob's subsystem.</p>

<p>Supposing the combined system is prepared in state σ and assuming, for purposes of argument, a non-relativistic situation, immediately (with no time delay) after Alice performs her measurement, the relative state of Bob's system is given by the <a href="partial_trace" title="wikilink">partial trace</a> of the overall state with respect to Alice's system. In symbols, the relative state of Bob's system after Alice's operation is</p>

<p>

<math display="block" id="No-communication_theorem:6">
 <semantics>
  <mrow>
   <msub>
    <mo>tr</mo>
    <msub>
     <mi>H</mi>
     <mi>A</mi>
    </msub>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>σ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>tr</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{tr}_{H_{A}}(P(\sigma))
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="No-communication_theorem:7">
 <semantics>
  <msub>
   <mo>tr</mo>
   <msub>
    <mi>H</mi>
    <mi>A</mi>
   </msub>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>tr</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{tr}_{H_{A}}
  </annotation>
 </semantics>
</math>

 is the partial trace mapping with respect to Alice's system.</p>

<p>One can directly calculate this state:</p>

<p>

<math display="block" id="No-communication_theorem:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>tr</mo>
     <msub>
      <mi>H</mi>
      <mi>A</mi>
     </msub>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>σ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>tr</mo>
     <msub>
      <mi>H</mi>
      <mi>A</mi>
     </msub>
    </msub>
    <mrow>
     <mo>(</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mi>k</mi>
      </munder>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mi>V</mi>
           <mi>k</mi>
          </msub>
          <mo>⊗</mo>
          <msub>
           <mi>I</mi>
           <msub>
            <mi>H</mi>
            <mi>B</mi>
           </msub>
          </msub>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>*</mo>
       </msup>
       <mi>σ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>V</mi>
          <mi>k</mi>
         </msub>
         <mo>⊗</mo>
         <msub>
          <mi>I</mi>
          <msub>
           <mi>H</mi>
           <mi>B</mi>
          </msub>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>tr</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>A</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>σ</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>tr</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>A</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="latexml">tensor-product</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>V</ci>
          <ci>k</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>H</ci>
           <ci>B</ci>
          </apply>
         </apply>
        </apply>
        <times></times>
       </apply>
       <ci>σ</ci>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>V</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>I</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>H</ci>
          <ci>B</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{tr}_{H_{A}}(P(\sigma))=\operatorname{tr}_{H_{A}}\left(\sum_{k}(V%
_{k}\otimes I_{H_{B}})^{*}\sigma(V_{k}\otimes I_{H_{B}})\right)
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="No-communication_theorem:9">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>tr</mo>
     <msub>
      <mi>H</mi>
      <mi>A</mi>
     </msub>
    </msub>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mi>k</mi>
      </msub>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <mi>i</mi>
       </msub>
       <mrow>
        <mrow>
         <msubsup>
          <mi>V</mi>
          <mi>k</mi>
          <mo>*</mo>
         </msubsup>
         <msub>
          <mi>T</mi>
          <mi>i</mi>
         </msub>
         <msub>
          <mi>V</mi>
          <mi>k</mi>
         </msub>
        </mrow>
        <mo>⊗</mo>
        <msub>
         <mi>S</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>tr</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>A</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>k</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>V</ci>
           <ci>k</ci>
          </apply>
          <times></times>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>T</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>V</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>S</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\operatorname{tr}_{H_{A}}\left(\sum_{k}\sum_{i}V_{k}^{*}T_{i}V_{k}\otimes S_{%
i}\right)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="No-communication_theorem:10">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>k</mi>
     </msub>
     <mrow>
      <mrow>
       <mo>tr</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msubsup>
          <mi>V</mi>
          <mi>k</mi>
          <mo>*</mo>
         </msubsup>
         <msub>
          <mi>T</mi>
          <mi>i</mi>
         </msub>
         <msub>
          <mi>V</mi>
          <mi>k</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <msub>
       <mi>S</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>k</ci>
      </apply>
      <apply>
       <apply>
        <ci>tr</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>V</ci>
           <ci>k</ci>
          </apply>
          <times></times>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>T</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>V</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\sum_{i}\sum_{k}\operatorname{tr}(V_{k}^{*}T_{i}V_{k})S_{i}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="No-communication_theorem:11">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>k</mi>
     </msub>
     <mrow>
      <mrow>
       <mo>tr</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>T</mi>
          <mi>i</mi>
         </msub>
         <msub>
          <mi>V</mi>
          <mi>k</mi>
         </msub>
         <msubsup>
          <mi>V</mi>
          <mi>k</mi>
          <mo>*</mo>
         </msubsup>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <msub>
       <mi>S</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>k</ci>
      </apply>
      <apply>
       <apply>
        <ci>tr</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>T</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>V</ci>
          <ci>k</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>V</ci>
           <ci>k</ci>
          </apply>
          <times></times>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\sum_{i}\sum_{k}\operatorname{tr}(T_{i}V_{k}V_{k}^{*})S_{i}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="No-communication_theorem:12">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <mrow>
     <mrow>
      <mo>tr</mo>
      <mrow>
       <mo>(</mo>
       <mrow>
        <msub>
         <mi>T</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <msub>
          <mo largeop="true" symmetric="true">∑</mo>
          <mi>k</mi>
         </msub>
         <mrow>
          <msub>
           <mi>V</mi>
           <mi>k</mi>
          </msub>
          <msubsup>
           <mi>V</mi>
           <mi>k</mi>
           <mo>*</mo>
          </msubsup>
         </mrow>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
     <msub>
      <mi>S</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <apply>
       <ci>tr</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <ci>k</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>V</ci>
           <ci>k</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>V</ci>
            <ci>k</ci>
           </apply>
           <times></times>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\sum_{i}\operatorname{tr}\left(T_{i}\sum_{k}V_{k}V_{k}^{*}\right)S_{i}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="No-communication_theorem:13">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>i</mi>
    </msub>
    <mrow>
     <mrow>
      <mo>tr</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>T</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <msub>
      <mi>S</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <apply>
       <ci>tr</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\sum_{i}\operatorname{tr}(T_{i})S_{i}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="No-communication_theorem:14">
 <semantics>
  <mrow>
   <mrow>
    <mi></mi>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo>tr</mo>
      <msub>
       <mi>H</mi>
       <mi>A</mi>
      </msub>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>σ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>tr</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>A</ci>
      </apply>
     </apply>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\operatorname{tr}_{H_{A}}(\sigma).
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>From this it is argued that, statistically, Bob cannot tell the difference between what Alice did and a random measurement (or whether she did anything at all).</p>
<h2 id="some-comments">Some comments</h2>
<ul>
<li>If the density operator 

<math display="inline" id="No-communication_theorem:15">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>σ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(\sigma)
  </annotation>
 </semantics>
</math>

 is allowed to evolve under the influence of non-local interactions between A and B, then the calculation in the proof no longer holds.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
</ul>
<ul>
<li>The no-communication theorem thus says shared entanglement alone can not be used to transmit any information. Compare this with the <a href="no-teleportation_theorem" title="wikilink">no-teleportation theorem</a>, which states a <a href="classical_information_channel" title="wikilink">classical information channel</a> can not transmit quantum information. (By <em>transmit</em>, we mean transmission with full fidelity.) However, <a href="quantum_teleportation" title="wikilink">quantum teleportation</a> schemes utilize both resources to achieve what is impossible for either alone.</li>
</ul>
<ul>
<li>The no-communication theorem implies the <a href="no-cloning_theorem" title="wikilink">no-cloning theorem</a>, which states that quantum states cannot be (perfectly) copied. That is, cloning is a sufficient condition for the communication of classical information to occur. To see this, suppose that quantum states could be cloned. Assume parts of a <a href="Maximally_entangled_state" title="wikilink">maximally entangled</a> <a href="Bell_state" title="wikilink">Bell state</a> are distributed to Alice and Bob. Alice could send bits to Bob in the following way: If Alice wishes to transmit a "0", she measures the spin of her electron in the <strong>z</strong> direction, collapsing Bob's state to either 

<math display="inline" id="No-communication_theorem:16">
 <semantics>
  <msub>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mrow>
     <mi>z</mi>
     <mo>+</mo>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="latexml">limit-from</csymbol>
      <ci>z</ci>
      <plus></plus>
     </apply>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |z+\rangle_{B}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="No-communication_theorem:17">
 <semantics>
  <msub>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mrow>
     <mi>z</mi>
     <mo>-</mo>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="latexml">limit-from</csymbol>
      <ci>z</ci>
      <minus></minus>
     </apply>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |z-\rangle_{B}
  </annotation>
 </semantics>
</math>

. To transmit "1", Alice does nothing to her <a class="uri" href="qubit" title="wikilink">qubit</a>. Bob creates many copies of his electron's state, and measures the spin of each copy in the <strong>z</strong> direction. Bob will know that Alice has transmitted a "0" if all his measurements will produce the same result; otherwise, his measurements will have outcomes 

<math display="inline" id="No-communication_theorem:18">
 <semantics>
  <msub>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mrow>
     <mi>z</mi>
     <mo>+</mo>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="latexml">limit-from</csymbol>
      <ci>z</ci>
      <plus></plus>
     </apply>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |z+\rangle_{B}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="No-communication_theorem:19">
 <semantics>
  <msub>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mrow>
     <mi>z</mi>
     <mo>-</mo>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="latexml">limit-from</csymbol>
      <ci>z</ci>
      <minus></minus>
     </apply>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |z-\rangle_{B}
  </annotation>
 </semantics>
</math>

 with equal probability. This would allow Alice and Bob to communicate classical bits between each other (possibly across <a class="uri" href="space-like" title="wikilink">space-like</a> separations, violating <a class="uri" href="causality" title="wikilink">causality</a>).</li>
</ul>
<ul>
<li>The version of the no-communication theorem discussed in this article assumes that the quantum system shared by Alice and Bob is a composite system, i.e. that its underlying Hilbert space is a tensor product whose first factor describes the part of the system that Alice can interact with and whose second factor describes the part of the system that Bob can interact with. In <a href="quantum_field_theory" title="wikilink">quantum field theory</a>, this assumption can be replaced by the assumption that Alice and Bob are <a href="Spacetime#Space-like_interval" title="wikilink">spacelike separated</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> This alternate version of the no-communication theorem shows that <a href="faster-than-light_communication" title="wikilink">faster-than-light communication</a> cannot be achieved using processes which obey the rules of quantum field theory.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="No-broadcast_theorem" title="wikilink">No-broadcast theorem</a></li>
<li><a href="No-cloning_theorem" title="wikilink">No-cloning theorem</a></li>
<li><a href="No-deleting_theorem" title="wikilink">No-deleting theorem</a></li>
<li><a href="No-teleportation_theorem" title="wikilink">No-teleportation theorem</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Hall, M.J.W. <em>Imprecise measurements and non-locality in quantum mechanics</em>, Phys. Lett. A (1987) 89-91</li>
<li><a href="Giancarlo_Ghirardi" title="wikilink">Ghirardi, G.C.</a> et al. <em>Experiments of the EPR Type Involving CP-Violation Do not Allow Faster-than-Light Communication between Distant Observers</em>, Europhys. Lett. 6 (1988) 95-100</li>
<li>Florig, M. and Summers, S. J. <em>On the statistical independence of algebras of observables</em>, J. Math. Phys. 38 (1997) 1318- 1328</li>
</ul>

<p>"</p>

<p><a href="Category:Quantum_measurement" title="wikilink">Category:Quantum measurement</a> <a href="Category:Quantum_information_science" title="wikilink">Category:Quantum information science</a> <a href="Category:Physics_theorems" title="wikilink">Category:Physics theorems</a> <a href="Category:Statistical_mechanics_theorems" title="wikilink">Category:Statistical mechanics theorems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">S. Popescu, D. Rohrlich (1997) "Causality and Nonlocality as Axioms for Quantum Mechanics", <em>Proceedings of the Symposium on Causality and Locality in Modern Physics and Astronomy</em> (York University, Toronto, 1997).<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
</ol>
</section>
</hr></body>
</html>
