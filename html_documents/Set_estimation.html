<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1835">Set estimation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Set estimation</h1>
<hr/>

<p><strong>Set-membership approach</strong></p>

<p>In <a class="uri" href="statistics" title="wikilink">statistics</a>, a random vector <em>x</em> is classically represented by a <a href="probability_density_function" title="wikilink">probability density function</a>. In a set-membership approach, <em>x</em> is represented by a set <em>X</em> to which <em>x</em> is assumed to belong. It means that the support of the probability distribution function of <em>x</em> is included inside <em>X</em>. On the one hand, representing random vectors by sets makes it possible to provide less assumptions on the random variables (such as independence) and dealing with nonlinearities is easier. On the other hand, a probability distribution function provides a more accurate information than a set enclosing its support.</p>
<h2 id="set-membership-estimation">Set-membership estimation</h2>

<p>Set membership estimation (or <em>set estimation</em> for short) is an <a href="Estimation_theory" title="wikilink">estimation approach</a> which considers that measurements are represented by a set <em>Y</em> (most of the time a box of <strong>R</strong><sup><em>m</em></sup>, where <em>m</em> is the number of measurements) of the measurement space. If <em>p</em> is the parameter vector and <em>f</em> is the model function, then the set of all feasible parameter vectors is</p>

<p>

<math display="inline" id="Set_estimation:0">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>P</mi>
     <mn>0</mn>
    </msub>
    <mo>∩</mo>
    <mrow>
     <msup>
      <mi>f</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <intersect></intersect>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>Y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=P_{0}\cap f^{-1}(Y)
  </annotation>
 </semantics>
</math>

,</p>

<p>where <em>P</em><sub>0</sub> is the prior set for the parameters. Characterizing <em>P</em> corresponds to a <a href="set_inversion" title="wikilink">set-inversion problem</a> .<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="resolution">Resolution</h2>

<p>When <em>f</em> is linear the feasible set <em>P</em> can be described by linear inequalities and can be approximated using <a href="linear_programming" title="wikilink">linear programming</a> techniques .<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>When <em>f</em> is nonlinear, the resolution can be performed using <a href="Interval_arithmetic" title="wikilink">interval analysis</a>. The feasible set <em>P</em> is then approximated by an inner and an outer <a href="subpaving" title="wikilink">subpavings</a>. The main limitation of the method is its exponential complexity with respect to the number of parameters .<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="example">Example</h2>

<p>Consider the following model</p>

<p>

<math display="inline" id="Set_estimation:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>p</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>p</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>t</mi>
        <msub>
         <mi>p</mi>
         <mn>1</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <mrow>
      <mi>t</mi>
      <msubsup>
       <mi>p</mi>
       <mn>2</mn>
       <mn>2</mn>
      </msubsup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>s</mi>
      <mi>i</mi>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>p</mi>
         <mn>1</mn>
        </msub>
        <mo>+</mo>
        <mrow>
         <mi>t</mi>
         <msub>
          <mi>p</mi>
          <mn>2</mn>
         </msub>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>i</ci>
      <ci>n</ci>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(p_{1},p_{2},t)=(tp_{1})^{2}+tp_{2}^{2}+sin(p_{1}+tp_{2}),
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>p</em><sub>1</sub> and <em>p</em><sub>2</sub> are the two parameters to be estimated.  Assume that at times <em>t</em><sub>1</sub>=-1, <em>t</em><sub>2</sub>=1, <em>t</em><sub>3</sub>=2, the following interval measurements have been collected: [<em>y</em><sub>1</sub>]=[-4,-2], [<em>y</em><sub>2</sub>]=[4,9], [<em>y</em><sub>3</sub>]=[7,11], as illustrated by Figure 1. The corresponding measurement set (here a box) is</p>

<p>

<math display="inline" id="Set_estimation:2">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>×</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>×</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>y</mi>
      <mn>3</mn>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Y</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=[y_{1}]\times[y_{2}]\times[y_{3}]
  </annotation>
 </semantics>
</math>

.</p>

<p>The model function is defined by</p>

<p>

<math display="inline" id="Set_estimation:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>p</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>p</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mrow>
         <msubsup>
          <mi>p</mi>
          <mn>1</mn>
          <mn>2</mn>
         </msubsup>
         <mo>-</mo>
         <msubsup>
          <mi>p</mi>
          <mn>2</mn>
          <mn>2</mn>
         </msubsup>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>s</mi>
         <mi>i</mi>
         <mi>n</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mi>p</mi>
            <mn>1</mn>
           </msub>
           <mo>-</mo>
           <msub>
            <mi>p</mi>
            <mn>2</mn>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msubsup>
         <mi>p</mi>
         <mn>1</mn>
         <mn>2</mn>
        </msubsup>
        <mo>+</mo>
        <msubsup>
         <mi>p</mi>
         <mn>2</mn>
         <mn>2</mn>
        </msubsup>
        <mo>+</mo>
        <mrow>
         <mi>s</mi>
         <mi>i</mi>
         <mi>n</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mi>p</mi>
            <mn>1</mn>
           </msub>
           <mo>+</mo>
           <msub>
            <mi>p</mi>
            <mn>2</mn>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mn>2</mn>
           <msub>
            <mi>p</mi>
            <mn>1</mn>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>2</mn>
        </msup>
        <mo>+</mo>
        <mrow>
         <mn>2</mn>
         <msubsup>
          <mi>p</mi>
          <mn>2</mn>
          <mn>2</mn>
         </msubsup>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>s</mi>
         <mi>i</mi>
         <mi>n</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mi>p</mi>
            <mn>1</mn>
           </msub>
           <mo>+</mo>
           <mrow>
            <mn>2</mn>
            <msub>
             <mi>p</mi>
             <mn>2</mn>
            </msub>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <cn type="integer">1</cn>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <cn type="integer">2</cn>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>s</ci>
        <ci>i</ci>
        <ci>n</ci>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <ci>s</ci>
        <ci>i</ci>
        <ci>n</ci>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <cn type="integer">2</cn>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>s</ci>
        <ci>i</ci>
        <ci>n</ci>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>p</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(p_{1},p_{2})=\begin{bmatrix}p_{1}^{2}-p_{2}^{2}+sin(p_{1}-p_{2})\\
p_{1}^{2}+p_{2}^{2}+sin(p_{1}+p_{2})\\
(2p_{1})^{2}+2p_{2}^{2}+sin(p_{1}+2p_{2})\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>The components of <em>f</em> are obtained using the model for each time measurement. After solving the set inversion problem, we get the approximation depicted on Figure 2. Red boxes are inside the feasible set <em>P</em> and blue boxes are outside <em>P</em>. </p>
<h2 id="recursive-case">Recursive case</h2>

<p>Set estimation can be used to estimate the state of a system described by state equations using a recursive implementation. When the system is linear, the corresponding feasible set for the state vector can be described by polytopes or by ellipsoids <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> .<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> When the system is nonlinear, the set can be enclosed by subpavings. <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="robust-case">Robust case</h2>

<p>When outliers occur, the set estimation method generally returns an empty set. This is due to the fact that the intersection between of sets of parameter vectors that are consistent with the <em>i</em>th data bar is empty. To be robust with respect to outliers, we generally characterize the set of parameter vectors that are consistent with all data bars except <em>q</em> of them. This is possible using the notion of <em>q</em>-<a href="relaxed_intersection" title="wikilink">relaxed intersection</a>.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Estimation_theory" title="wikilink"> </a> <a href="Category:Statistical_inference" title="wikilink">Category:Statistical inference</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
