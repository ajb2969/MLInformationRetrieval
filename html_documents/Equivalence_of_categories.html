<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="488">Equivalence of categories</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Equivalence of categories</h1>
<hr/>

<p>In <a href="category_theory" title="wikilink">category theory</a>, an abstract branch of <a class="uri" href="mathematics" title="wikilink">mathematics</a>, an <strong>equivalence of categories</strong> is a relation between two <a href="Category_(mathematics)" title="wikilink">categories</a> that establishes that these categories are "essentially the same". There are numerous examples of categorical equivalences from many areas of mathematics. Establishing an equivalence involves demonstrating strong similarities between the mathematical structures concerned. In some cases, these structures may appear to be unrelated at a superficial or intuitive level, making the notion fairly powerful: it creates the opportunity to "translate" theorems between different kinds of mathematical structures, knowing that the essential meaning of those theorems is preserved under the translation.</p>

<p>If a category is equivalent to the <a href="dual_(category_theory)" title="wikilink">opposite (or dual)</a> of another category then one speaks of a <strong>duality of categories</strong>, and says that the two categories are <strong>dually equivalent</strong>.</p>

<p>An equivalence of categories consists of a <a class="uri" href="functor" title="wikilink">functor</a> between the involved categories, which is required to have an "inverse" functor. However, in contrast to the situation common for <a href="isomorphism" title="wikilink">isomorphisms</a> in an algebraic setting, the composition of the functor and its "inverse" is not necessarily the identity mapping. Instead it is sufficient that each object be <em><a href="natural_transformation" title="wikilink">naturally isomorphic</a></em> to its image under this composition. Thus one may describe the functors as being "inverse up to isomorphism". There is indeed a concept of <a href="isomorphism_of_categories" title="wikilink">isomorphism of categories</a> where a strict form of inverse functor is required, but this is of much less practical use than the <em>equivalence</em> concept.</p>
<h2 id="definition">Definition</h2>

<p>Formally, given two categories <em>C</em> and <em>D</em>, an <em>equivalence of categories</em> consists of a functor <em>F</em> : <em>C</em> → <em>D</em>, a functor <em>G</em> : <em>D</em> → <em>C</em>, and two natural isomorphisms ε: <em>FG</em>→<strong>I</strong><sub><em>D</em></sub> and η : <strong>I</strong><sub><em>C</em></sub>→<em>GF</em>. Here <em>FG</em>: <em>D</em>→<em>D</em> and <em>GF</em>: <em>C</em>→<em>C</em>, denote the respective compositions of <em>F</em> and <em>G</em>, and <strong>I</strong><sub><em>C</em></sub>: <em>C</em>→<em>C</em> and <strong>I</strong><sub><em>D</em></sub>: <em>D</em>→<em>D</em> denote the <em>identity functors</em> on <em>C</em> and <em>D</em>, assigning each object and morphism to itself. If <em>F</em> and <em>G</em> are contravariant functors one speaks of a <em>duality of categories</em> instead.</p>

<p>One often does not specify all the above data. For instance, we say that the categories <em>C</em> and <em>D</em> are <em>equivalent</em> (respectively <em>dually equivalent</em>) if there exists an equivalence (respectively duality) between them. Furthermore, we say that <em>F</em> "is" an equivalence of categories if an inverse functor <em>G</em> and natural isomorphisms as above exist. Note however that knowledge of <em>F</em> is usually not enough to reconstruct <em>G</em> and the natural isomorphisms: there may be many choices (see example below).</p>
<h2 id="equivalent-characterizations">Equivalent characterizations</h2>

<p>One can show that a functor <em>F</em> : <em>C</em> → <em>D</em> yields an equivalence of categories if and only if it is simultaneously:</p>
<ul>
<li><a href="full_functor" title="wikilink">full</a>, i.e. for any two objects <em>c</em><sub>1</sub> and <em>c</em><sub>2</sub> of <em>C</em>, the map Hom<sub><em>C</em></sub>(<em>c</em><sub>1</sub>,<em>c</em><sub>2</sub>) → Hom<sub><em>D</em></sub>(<em>Fc</em><sub>1</sub>,<em>Fc</em><sub>2</sub>) induced by <em>F</em> is <a class="uri" href="surjective" title="wikilink">surjective</a>;</li>
<li><a href="faithful_functor" title="wikilink">faithful</a>, i.e. for any two objects <em>c</em><sub>1</sub> and <em>c</em><sub>2</sub> of <em>C</em>, the map Hom<sub><em>C</em></sub>(<em>c</em><sub>1</sub>,<em>c</em><sub>2</sub>) → Hom<sub><em>D</em></sub>(<em>Fc</em><sub>1</sub>,<em>Fc</em><sub>2</sub>) induced by <em>F</em> is <a class="uri" href="injective" title="wikilink">injective</a>; and</li>
<li><a href="essentially_surjective_functor" title="wikilink">essentially surjective (dense)</a>, i.e. each object <em>d</em> in <em>D</em> is isomorphic to an object of the form <em>Fc</em>, for <em>c</em> in <em>C</em>.</li>
</ul>

<p>This is a quite useful and commonly applied criterion, because one does not have to explicitly construct the "inverse" <em>G</em> and the natural isomorphisms between <em>FG</em>, <em>GF</em> and the identity functors. On the other hand, though the above properties guarantee the <em>existence</em> of a categorical equivalence (given a sufficiently strong version of the <a href="axiom_of_choice" title="wikilink">axiom of choice</a> in the underlying set theory), the missing data is not completely specified, and often there are many choices. It is a good idea to specify the missing constructions explicitly whenever possible. Due to this circumstance, a functor with these properties is sometimes called a <strong>weak equivalence of categories</strong> (unfortunately this conflicts with terminology from homotopy theory).</p>

<p>There is also a close relation to the concept of <a href="adjoint_functors" title="wikilink">adjoint functors</a>. The following statements are equivalent for functors <em>F</em> : <em>C</em> → <em>D</em> and <em>G</em> : <em>D</em> → <em>C</em>:</p>
<ul>
<li>There are natural isomorphisms from <em>FG</em> to <strong>I</strong><sub><em>D</em></sub> and <strong>I</strong><sub><em>C</em></sub> to <em>GF</em>.</li>
<li><em>F</em> is a left adjoint of <em>G</em> and both functors are full and faithful.</li>
<li><em>G</em> is a right adjoint of <em>F</em> and both functors are full and faithful.</li>
</ul>

<p>One may therefore view an adjointness relation between two functors as a "very weak form of equivalence". Assuming that the natural transformations for the adjunctions are given, all of these formulations allow for an explicit construction of the necessary data, and no choice principles are needed. The key property that one has to prove here is that the <em>counit</em> of an adjunction is an isomorphism if and only if the right adjoint is a full and faithful functor.</p>
<h2 id="examples">Examples</h2>
<ul>
<li>Consider the category 

<math display="inline" id="Equivalence_of_categories:0">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 having a single object 

<math display="inline" id="Equivalence_of_categories:1">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 and a single morphism 

<math display="inline" id="Equivalence_of_categories:2">
 <semantics>
  <msub>
   <mn>1</mn>
   <mi>c</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cn type="integer">1</cn>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1_{c}
  </annotation>
 </semantics>
</math>

, and the category 

<math display="inline" id="Equivalence_of_categories:3">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>


 with two objects 

<math display="inline" id="Equivalence_of_categories:4">
 <semantics>
  <msub>
   <mi>d</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{1}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Equivalence_of_categories:5">
 <semantics>
  <msub>
   <mi>d</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{2}
  </annotation>
 </semantics>
</math>

 and four morphisms: two identity morphisms 

<math display="inline" id="Equivalence_of_categories:6">
 <semantics>
  <msub>
   <mn>1</mn>
   <msub>
    <mi>d</mi>
    <mn>1</mn>
   </msub>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1_{d_{1}}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Equivalence_of_categories:7">
 <semantics>
  <msub>
   <mn>1</mn>
   <msub>
    <mi>d</mi>
    <mn>2</mn>
   </msub>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1_{d_{2}}
  </annotation>
 </semantics>
</math>

 and two isomorphisms 

<math display="inline" id="Equivalence_of_categories:8">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>d</mi>
     <mn>1</mn>
    </msub>
    <mo>→</mo>
    <msub>
     <mi>d</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>α</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\colon d_{1}\to d_{2}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Equivalence_of_categories:9">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>d</mi>
     <mn>2</mn>
    </msub>
    <mo>→</mo>
    <msub>
     <mi>d</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>β</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\colon d_{2}\to d_{1}
  </annotation>
 </semantics>
</math>

. The categories 

<math display="inline" id="Equivalence_of_categories:10">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Equivalence_of_categories:11">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 are equivalent; we can (for example) have 

<math display="inline" id="Equivalence_of_categories:12">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 map 

<math display="inline" id="Equivalence_of_categories:13">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>


 to 

<math display="inline" id="Equivalence_of_categories:14">
 <semantics>
  <msub>
   <mi>d</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Equivalence_of_categories:15">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 map both objects of 

<math display="inline" id="Equivalence_of_categories:16">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Equivalence_of_categories:17">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 and all morphisms to 

<math display="inline" id="Equivalence_of_categories:18">
 <semantics>
  <msub>
   <mn>1</mn>
   <mi>c</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cn type="integer">1</cn>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1_{c}
  </annotation>
 </semantics>
</math>


.</li>
</ul>
<ul>
<li>By contrast, the category 

<math display="inline" id="Equivalence_of_categories:19">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 with a single object and a single morphism is <em>not</em> equivalent to the category 

<math display="inline" id="Equivalence_of_categories:20">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 with two objects and only two identity morphisms as the two objects therein are <em>not</em> isomorphic.</li>
</ul>
<ul>
<li>Consider a category 

<math display="inline" id="Equivalence_of_categories:21">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 with one object 

<math display="inline" id="Equivalence_of_categories:22">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

, and two morphisms 

<math display="inline" id="Equivalence_of_categories:23">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mn>1</mn>
     <mi>c</mi>
    </msub>
    <mo>,</mo>
    <mi>f</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>c</mi>
    <mo>→</mo>
    <mi>c</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">1</cn>
      <ci>c</ci>
     </apply>
     <ci>f</ci>
    </list>
    <apply>
     <ci>normal-→</ci>
     <ci>c</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1_{c},f\colon c\to c
  </annotation>
 </semantics>
</math>


. Let 

<math display="inline" id="Equivalence_of_categories:24">
 <semantics>
  <msub>
   <mn>1</mn>
   <mi>c</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cn type="integer">1</cn>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1_{c}
  </annotation>
 </semantics>
</math>

 be the identity morphism on 

<math display="inline" id="Equivalence_of_categories:25">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 and set 

<math display="inline" id="Equivalence_of_categories:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>∘</mo>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <ci>f</ci>
     <ci>f</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\circ f=1
  </annotation>
 </semantics>
</math>

. Of course, 

<math display="inline" id="Equivalence_of_categories:27">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is equivalent to itself, which can be shown by taking 

<math display="inline" id="Equivalence_of_categories:28">
 <semantics>
  <msub>
   <mn>1</mn>
   <mi>c</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cn type="integer">1</cn>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1_{c}
  </annotation>
 </semantics>
</math>


 in place of the required natural isomorphisms between the functor 

<math display="inline" id="Equivalence_of_categories:29">
 <semantics>
  <msub>
   <mi>𝐈</mi>
   <mi>C</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐈</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{I}_{C}
  </annotation>
 </semantics>
</math>

 and itself. However, it is also true that 

<math display="inline" id="Equivalence_of_categories:30">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 yields a natural isomorphism from 

<math display="inline" id="Equivalence_of_categories:31">
 <semantics>
  <msub>
   <mi>𝐈</mi>
   <mi>C</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐈</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{I}_{C}
  </annotation>
 </semantics>
</math>

 to itself. Hence, given the information that the identity functors form an equivalence of categories, in this example one still can choose between two natural isomorphisms for each direction.</li>
</ul>
<ul>
<li>The category of sets and <a href="partial_function" title="wikilink">partial functions</a> is equivalent to but not isomorphic with the category of <a href="pointed_set" title="wikilink">pointed sets</a> and point-preserving maps.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></li>
</ul>
<ul>
<li>Consider the category 

<math display="inline" id="Equivalence_of_categories:32">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 of finite-<a href="dimension_of_a_vector_space" title="wikilink">dimensional</a> <a href="real_number" title="wikilink">real</a> <a href="vector_space" title="wikilink">vector spaces</a>, and the category 

<math display="inline" id="Equivalence_of_categories:33">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <mi>Mat</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ℝ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <apply>
     <times></times>
     <ci>Mat</ci>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=\mathrm{Mat}(\mathbb{R})
  </annotation>
 </semantics>
</math>


 of all real <a href="matrix_(mathematics)" title="wikilink">matrices</a> (the latter category is explained in the article on <a href="additive_category" title="wikilink">additive categories</a>). Then 

<math display="inline" id="Equivalence_of_categories:34">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Equivalence_of_categories:35">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 are equivalent: The functor 

<math display="inline" id="Equivalence_of_categories:36">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>:</mo>
   <mrow>
    <mi>D</mi>
    <mo>→</mo>
    <mi>C</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>G</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>D</ci>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\colon D\to C
  </annotation>
 </semantics>
</math>

 which maps the object 

<math display="inline" id="Equivalence_of_categories:37">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{n}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Equivalence_of_categories:38">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>


 to the vector space 

<math display="inline" id="Equivalence_of_categories:39">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

 and the matrices in 

<math display="inline" id="Equivalence_of_categories:40">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 to the corresponding linear maps is full, faithful and essentially surjective.</li>
</ul>
<ul>
<li>One of the central themes of <a href="algebraic_geometry" title="wikilink">algebraic geometry</a> is the duality of the category of <a href="affine_scheme" title="wikilink">affine schemes</a> and the category of <a href="commutative_ring" title="wikilink">commutative rings</a>. The functor 

<math display="inline" id="Equivalence_of_categories:41">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 associates to every commutative ring its <a href="spectrum_of_a_ring" title="wikilink">spectrum</a>, the scheme defined by the <a href="prime_ideal" title="wikilink">prime ideals</a> of the ring. Its adjoint 

<math display="inline" id="Equivalence_of_categories:42">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 associates to every affine scheme its ring of global sections.</li>
</ul>
<ul>
<li>In <a href="functional_analysis" title="wikilink">functional analysis</a> the category of commutative <a href="C*-algebra" title="wikilink">C*-algebras</a> with identity is contravariantly equivalent to the category of <a href="compact_space" title="wikilink">compact</a> <a href="Hausdorff_space" title="wikilink">Hausdorff spaces</a>. Under this duality, every compact Hausdorff space 

<math display="inline" id="Equivalence_of_categories:43">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>


 is associated with the algebra of continuous complex-valued functions on 

<math display="inline" id="Equivalence_of_categories:44">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

, and every commutative C*-algebra is associated with the space of its <a href="maximal_ideal" title="wikilink">maximal ideals</a>. This is the <a href="Gelfand_representation" title="wikilink">Gelfand representation</a>.</li>
</ul>
<ul>
<li>In <a href="lattice_theory" title="wikilink">lattice theory</a>, there are a number of dualities, based on representation theorems that connect certain classes of lattices to classes of <a href="topology" title="wikilink">topological spaces</a>. Probably the most well-known theorem of this kind is <em><a href="Stone's_representation_theorem_for_Boolean_algebras" title="wikilink">Stone's representation theorem for Boolean algebras</a></em>, which is a special instance within the general scheme of <em><a href="Stone_duality" title="wikilink">Stone duality</a></em>. Each <a href="Boolean_algebra_(structure)" title="wikilink">Boolean algebra</a> 

<math display="inline" id="Equivalence_of_categories:45">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is mapped to a specific topology on the set of <a href="lattice_theory" title="wikilink">ultrafilters</a> of 

<math display="inline" id="Equivalence_of_categories:46">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

. Conversely, for any topology the clopen (i.e. closed and open) subsets yield a Boolean algebra. One obtains a duality between the category of Boolean algebras (with their homomorphisms) and <a href="Stone_space" title="wikilink">Stone spaces</a> (with continuous mappings). Another case of Stone duality is <a href="Birkhoff's_representation_theorem" title="wikilink">Birkhoff's representation theorem</a> stating a duality between finite partial orders and finite distributive lattices.</li>
</ul>
<ul>
<li>In <a href="pointless_topology" title="wikilink">pointless topology</a> the category of spatial locales is known to be equivalent to the dual of the category of sober spaces.</li>
</ul>
<ul>
<li>For two rings <em>R</em> and <em>S</em>, <em>R</em>-<strong>Mod</strong>×<em>S</em>-<strong>Mod</strong> is equivalent to (<em>R</em>×<em>S</em>)-<strong>Mod</strong>.</li>
</ul>
<ul>
<li>Any category is equivalent to its <a href="skeleton_(category_theory)" title="wikilink">skeleton</a>.</li>
</ul>
<h2 id="properties">Properties</h2>

<p>As a rule of thumb, an equivalence of categories preserves all "categorical" concepts and properties. If <em>F</em> : <em>C</em> → <em>D</em> is an equivalence, then the following statements are all true:</p>
<ul>
<li>the object <em>c</em> of <em>C</em> is an <a href="initial_object" title="wikilink">initial object</a> (or <a href="terminal_object" title="wikilink">terminal object</a>, or <a href="zero_object" title="wikilink">zero object</a>), <a href="if_and_only_if" title="wikilink">if and only if</a> <em>Fc</em> is an <a href="initial_object" title="wikilink">initial object</a> (or <a href="terminal_object" title="wikilink">terminal object</a>, or <a href="zero_object" title="wikilink">zero object</a>) of <em>D</em></li>
<li>the morphism α in <em>C</em> is a <a class="uri" href="monomorphism" title="wikilink">monomorphism</a> (or <a class="uri" href="epimorphism" title="wikilink">epimorphism</a>, or <a class="uri" href="isomorphism" title="wikilink">isomorphism</a>), if and only if <em>Fα</em> is a monomorphism (or epimorphism, or isomorphism) in <em>D</em>.</li>
<li>the functor <em>H</em> : <em>I</em> → <em>C</em> has <a href="limit_(category_theory)" title="wikilink">limit</a> (or colimit) <em>l</em> if and only if the functor <em>FH</em> : <em>I</em> → <em>D</em> has limit (or colimit) <em>Fl</em>. This can be applied to <a href="equaliser_(mathematics)" title="wikilink">equalizers</a>, <a href="product_(category_theory)" title="wikilink">products</a> and <a href="coproduct" title="wikilink">coproducts</a> among others. Applying it to <a href="kernel_(category_theory)" title="wikilink">kernels</a> and <a href="cokernel" title="wikilink">cokernels</a>, we see that the equivalence <em>F</em> is an <a href="Regular_category#Exact_sequences_and_regular_functors" title="wikilink">exact functor</a>.</li>
<li><em>C</em> is a <a href="cartesian_closed_category" title="wikilink">cartesian closed category</a> (or a <a class="uri" href="topos" title="wikilink">topos</a>) if and only if <em>D</em> is cartesian closed (or a topos).</li>
</ul>

<p>Dualities "turn all concepts around": they turn initial objects into terminal objects, monomorphisms into epimorphisms, kernels into cokernels, limits into colimits etc.</p>

<p>If <em>F</em> : <em>C</em> → <em>D</em> is an equivalence of categories, and <em>G</em><sub>1</sub> and <em>G</em><sub>2</sub> are two inverses of <em>F</em>, then <em>G</em><sub>1</sub> and <em>G</em><sub>2</sub> are naturally isomorphic.</p>

<p>If <em>F</em> : <em>C</em> → <em>D</em> is an equivalence of categories, and if <em>C</em> is a <a href="preadditive_category" title="wikilink">preadditive category</a> (or <a href="additive_category" title="wikilink">additive category</a>, or <a href="abelian_category" title="wikilink">abelian category</a>), then <em>D</em> may be turned into a preadditive category (or additive category, or abelian category) in such a way that <em>F</em> becomes an <a href="additive_functor" title="wikilink">additive functor</a>. On the other hand, any equivalence between additive categories is necessarily additive. (Note that the latter statement is not true for equivalences between preadditive categories.)</p>

<p>An <strong>auto-equivalence</strong> of a category <em>C</em> is an equivalence <em>F</em> : <em>C</em> → <em>C</em>. The auto-equivalences of <em>C</em> form a <a href="group_(mathematics)" title="wikilink">group</a> under composition if we consider two auto-equivalences that are naturally isomorphic to be identical. This group captures the essential "symmetries" of <em>C</em>. (One caveat: if <em>C</em> is not a small category, then the auto-equivalences of <em>C</em> may form a proper <a href="class_(set_theory)" title="wikilink">class</a> rather than a <a href="Set_(mathematics)" title="wikilink">set</a>.)</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Equivalent_definitions_of_mathematical_structures" title="wikilink">Equivalent definitions of mathematical structures</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Adjoint_functors" title="wikilink">Category:Adjoint functors</a> <a href="Category:Category_theory" title="wikilink">Category:Category theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
