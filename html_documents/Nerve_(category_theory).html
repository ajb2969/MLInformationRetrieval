<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="59">Nerve (category theory)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Nerve (category theory)</h1>
<hr/>

<p>In <a href="category_theory" title="wikilink">category theory</a>, a discipline within mathematics, the <strong>nerve</strong> <em>N</em>(<em>C</em>) of a <a href="small_category" title="wikilink">small category</a> <em>C</em> is a <a href="simplicial_set" title="wikilink">simplicial set</a> constructed from the objects and morphisms of <em>C</em>. The <a href="geometric_realization" title="wikilink">geometric realization</a> of this simplicial set is a <a href="topological_space" title="wikilink">topological space</a>, called the <strong>classifying space of the category</strong> <em>C</em>. These closely related objects can provide information about some familiar and useful categories using <a href="algebraic_topology" title="wikilink">algebraic topology</a>, most often <a href="homotopy_theory" title="wikilink">homotopy theory</a>.</p>
<h2 id="motivation">Motivation</h2>

<p>The nerve of a category is often used to construct topological versions of <a href="moduli_space" title="wikilink">moduli spaces</a>. If <em>X</em> is an object of <em>C</em>, its moduli space should somehow encode all objects isomorphic to <em>X</em> and keep track of the various isomorphisms between all of these objects in that category. This can become rather complicated, especially if the objects have many non-identity automorphisms. The nerve provides a combinatorial way of organizing this data. Since simplicial sets have a good homotopy theory, one can ask questions about the meaning of the various homotopy groups π<sub>n</sub>(<em>N</em>(<em>C</em>)). One hopes that the answers to such questions provide interesting information about the original category <em>C</em>, or about related categories.</p>

<p>The notion of nerve is a direct generalization of the classical notion of <a href="classifying_space" title="wikilink">classifying space</a> of a discrete group; see below for details.</p>
<h2 id="construction">Construction</h2>

<p>Let <em>C</em> be a small category. It is easy to define the sets <em>N</em>(<em>C</em>)<sub><em>k</em></sub> for small <em>k</em>, which leads to the general definition. In particular, there is a 0-simplex of <em>N</em>(<em>C</em>) for each object of <em>C</em>. There is a 1-simplex for each morphism <em>f</em> : <em>x</em> → <em>y</em> in <em>C</em>. Now suppose that <em>f</em>: <em>x</em> → <em>y</em> and <em>g</em> : <em>y</em> →  <em>z</em> are morphisms in <em>C</em>. Then we also have their composition <em>gf</em> : <em>x</em> → <em>z</em>.  The diagram suggests our course of action: add a 2-simplex for this commutative triangle. Every 2-simplex of <em>N</em>(<em>C</em>) comes from a pair of composable morphisms in this way. Note that the addition of these 2-simplices does not erase or otherwise disregard morphisms obtained by composition, it merely remembers that that is how they arise.</p>

<p>In general, <em>N</em>(<em>C</em>)<sub><em>k</em></sub> consists of the <em>k</em>-tuples of composable morphisms</p>

<p>

<math display="block" id="Nerve_(category_theory):0">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>0</mn>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>A</mi>
    <mn>1</mn>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>A</mi>
    <mn>2</mn>
   </msub>
   <mo>→</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>→</mo>
   <msub>
    <mi>A</mi>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>A</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{0}\to A_{1}\to A_{2}\to\cdots\to A_{k-1}\to A_{k}
  </annotation>
 </semantics>
</math>

</p>

<p>of <em>C</em>. To complete the definition of <em>N</em>(<em>C</em>) as a simplicial set, we must also specify the face and degeneracy maps. These are also provided to us by the structure of <em>C</em> as a category. The face maps</p>

<p>

<math display="block" id="Nerve_(category_theory):1">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mi>i</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>N</mi>
     <msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>N</mi>
     <msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>N</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>N</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{i}\colon N(C)_{k}\to N(C)_{k-1}
  </annotation>
 </semantics>
</math>

</p>

<p>are given by composition of morphisms at the <em>i</em>th object (or removing the <em>i</em>th object from the sequence, when <em>i</em> is 0 or <em>k</em>).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> This means that <em>d</em><sub><em>i</em></sub> sends the <em>k</em>-tuple</p>

<p>

<math display="block" id="Nerve_(category_theory):2">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>0</mn>
   </msub>
   <mo>→</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>→</mo>
   <msub>
    <mi>A</mi>
    <mrow>
     <mi>i</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>A</mi>
    <mi>i</mi>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>A</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>→</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>→</mo>
   <msub>
    <mi>A</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{0}\to\cdots\to A_{i-1}\to A_{i}\to A_{i+1}\to\cdots\to A_{k}
  </annotation>
 </semantics>
</math>

</p>

<p>to the (<em>k</em> − 1)-tuple</p>

<p>

<math display="block" id="Nerve_(category_theory):3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>A</mi>
     <mn>0</mn>
    </msub>
    <mo>→</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>→</mo>
    <msub>
     <mi>A</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>→</mo>
    <msub>
     <mi>A</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>→</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>→</mo>
    <msub>
     <mi>A</mi>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{0}\to\cdots\to A_{i-1}\to A_{i+1}\to\cdots\to A_{k}.
  </annotation>
 </semantics>
</math>

</p>

<p>That is, the map <em>d</em><sub><em>i</em></sub> composes the morphisms <em>A</em><sub><em>i</em>−1</sub> → <em>A</em><sub><em>i</em></sub> and <em>A</em><sub><em>i</em></sub> → <em>A</em><sub><em>i</em>+1</sub> into the morphism <em>A</em><sub><em>i</em>−1</sub> → <em>A</em><sub><em>i</em>+1</sub>, yielding a (<em>k</em> − 1)-tuple for every <em>k</em>-tuple.</p>

<p>Similarly, the degeneracy maps</p>

<p>

<math display="block" id="Nerve_(category_theory):4">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>i</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>N</mi>
     <msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>N</mi>
     <msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>N</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>N</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{i}:N(C)_{k}\to N(C)_{k+1}
  </annotation>
 </semantics>
</math>

</p>

<p>are given by inserting an identity morphism at the object <em>A</em><sub><em>i</em></sub>.</p>

<p>Recall that simplicial sets may also be regarded as <a class="uri" href="functors" title="wikilink">functors</a> Δ<sup>op</sup> → <strong>Set</strong>, where Δ is the category of totally ordered finite sets and order-preserving morphisms. Every partially ordered set <em>P</em> yields a (small) category <em>i</em>(<em>P</em>) with objects the elements of <em>P</em> and with a unique morphism from <em>p</em> to <em>q</em> whenever <em>p</em> ≤ <em>q</em> in <em>P</em>. We thus obtain a functor <em>i</em> from the category Δ to the category of small categories. We can now describe the nerve of the category <em>C</em> as the functor Δ<sup>op</sup> → <strong>Set</strong></p>

<p>

<math display="block" id="Nerve_(category_theory):5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>N</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>C</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi mathvariant="normal">?</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>Fun</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>i</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi mathvariant="normal">?</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mi>C</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>C</ci>
     <ci>normal-?</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Fun</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>normal-?</ci>
      </apply>
      <ci>C</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N(C)(?)=\mathrm{Fun}(i(?),C).\,
  </annotation>
 </semantics>
</math>

</p>

<p>This description of the nerve makes functoriality quite transparent; for example, a functor between small categories <em>C</em> and <em>D</em> induces a map of simplicial sets <em>N</em>(<em>C</em>) → <em>N</em>(<em>D</em>). Moreover a natural transformation between two such functors induces a homotopy between the induced maps. This observation can be regarded as the beginning of one of the principles of <a href="higher_category_theory" title="wikilink">higher category theory</a>. It follows that <a href="adjoint_functor" title="wikilink">adjoint functors</a> induce <a href="homotopy_equivalence" title="wikilink">homotopy equivalences</a>. In particular, if <em>C</em> has an <a href="initial_object" title="wikilink">initial</a> or <a href="final_object" title="wikilink">final object</a>, its nerve is contractible.</p>
<h2 id="examples">Examples</h2>

<p>The primordial example is the classifying space of a discrete group <em>G</em>. We regard <em>G</em> as a category with one object whose endomorphisms are the elements of <em>G</em>. Then the <em>k</em>-simplices of <em>N</em>(<em>G</em>) are just <em>k</em>-tuples of elements of <em>G</em>. The face maps act by multiplication, and the degeneracy maps act by insertion of the identity element. If <em>G</em> is the group with two elements, then there is exactly one nondegenerate <em>k</em>-simplex for each nonnegative integer <em>k</em>, corresponding to the unique <em>k</em>-tuple of elements of <em>G</em> containing no identities. After passing to the geometric realization, it is not hard to see that this <em>k</em>-tuple can be identified with the unique <em>k</em>-cell in the usual <a href="CW_complex" title="wikilink">CW</a> structure on infinite-dimensional <a href="real_projective_space" title="wikilink">real projective space</a>. The latter is the most popular model for the classifying space of the group with two elements. See (Segal 1968) for further details and the relationship of the above to Milnor's join construction of <em>BG</em>.</p>
<h3 id="most-spaces-are-classifying-spaces">Most spaces are classifying spaces</h3>

<p>It is well known that every "reasonable" topological space is homeomorphic to the classifying space of a small category. Here, "reasonable" means that the space in question is the geometric realization of a simplicial set. This is obviously a necessary condition; it is perhaps surprising that it is also sufficient. Indeed, let <em>X</em> be the geometric realization of a simplicial set <em>K</em>. The set of simplices in <em>K</em> is partially ordered, by the relation <em>x</em> ≤ <em>y</em> if and only if <em>x</em> is a face of <em>y</em>. Of course, we may consider this partially ordered set as a category. The nerve of this category is the <a href="barycentric_subdivision" title="wikilink">barycentric subdivision</a> of <em>K</em>, and thus its realization is homeomorphic to <em>X</em>, because <em>X</em> is the realization of <em>K</em> by hypothesis and barycentric subdivision does not change the homeomorphism type of the realization.</p>
<h3 id="the-nerve-of-an-open-covering">The nerve of an open covering</h3>

<p>If <em>X</em> is a topological space with open cover <em>U</em><sub><em>i</em></sub>, the <a href="nerve_of_an_open_covering" title="wikilink">nerve of the cover</a> is obtained from the above definitions by replacing the cover with the category obtained by regarding the cover as a partially ordered set with relation that of set inclusion. Note that the realization of this nerve is not generally homeomorphic to <em>X</em> (or even homotopy equivalent).</p>
<h3 id="a-moduli-example">A moduli example</h3>

<p>One can use the nerve construction to recover mapping spaces, and even get "higher-homotopical" information about maps. Let <em>D</em> be a category, and let <em>X</em> and <em>Y</em> be objects of <em>D</em>. One is often interested in computing the set of morphisms <em>X</em> → <em>Y</em>. We can use a nerve construction to recover this set. Let <em>C</em> = <em>C</em>(<em>X</em>,<em>Y</em>) be the category whose objects are diagrams</p>

<p>

<math display="block" id="Nerve_(category_theory):6">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>⟵</mo>
   <mi>U</mi>
   <mo>⟶</mo>
   <mi>V</mi>
   <mo>⟵</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-⟵</ci>
     <ci>X</ci>
     <ci>U</ci>
    </apply>
    <apply>
     <ci>normal-⟶</ci>
     <share href="#.cmml">
     </share>
     <ci>V</ci>
    </apply>
    <apply>
     <ci>normal-⟵</ci>
     <share href="#.cmml">
     </share>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\longleftarrow U\longrightarrow V\longleftarrow Y
  </annotation>
 </semantics>
</math>

</p>

<p>such that the morphisms <em>U</em> → <em>X</em> and <em>Y</em> → <em>V</em> are isomorphisms in <em>D</em>. Morphisms in <em>C</em>(<em>X</em>, <em>Y</em>) are diagrams of the following shape:</p>
<dl>
<dd>
</dd>
</dl>

<p>Here, the indicated maps are to be isomorphisms or identities. The nerve of <em>C</em>(<em>X</em>, <em>Y</em>) is the <a href="moduli_space" title="wikilink">moduli space</a> of maps <em>X</em> → <em>Y</em>. In the appropriate <a href="model_category" title="wikilink">model category</a> setting, this moduli space is weak homotopy equivalent to the simplicial set of morphisms of <em>D</em> from <em>X</em> to <em>Y</em>.</p>
<h2 id="references">References</h2>
<ul>
<li>Blanc, D., W. G. Dwyer, and P.G. Goerss. "The realization space of a 

<math display="inline" id="Nerve_(category_theory):7">
 <semantics>
  <mi mathvariant="normal">Π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi
  </annotation>
 </semantics>
</math>

-algebra: a moduli problem in algebraic topology." Topology 43 (2004), no. 4, 857–892.</li>
<li>Goerss, P. G., and M. J. Hopkins. "<a href="http://www.math.northwestern.edu/~pgoerss/papers/sum.pdf">Moduli spaces of commutative ring spectra</a>." <em>Structured ring spectra</em>, 151–200, London Math. Soc. Lecture Note Ser., 315, Cambridge Univ. Press, Cambridge, 2004.</li>
<li>Segal, Graeme. "Classifying spaces and spectral sequences." Inst. Hautes Études Sci. Publ. Math. No. 34 (1968) 105–112.</li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Category_theory" title="wikilink">Category:Category theory</a> <a href="Category:Simplicial_sets" title="wikilink">Category:Simplicial sets</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">The <em>i</em>th face of the simplex is then the one missing the <em>i</em>th vertex.<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
