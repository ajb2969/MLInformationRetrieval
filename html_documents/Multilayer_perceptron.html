<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="457">Multilayer perceptron</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Multilayer perceptron</h1>
<hr/>

<p>A <strong>multilayer perceptron</strong> (MLP) is a <a href="feedforward_neural_network" title="wikilink">feedforward</a> <a href="artificial_neural_network" title="wikilink">artificial neural network</a> model that maps sets of input data onto a set of appropriate outputs. A MLP consists of multiple layers of nodes in a directed graph, with each layer fully connected to the next one. Except for the input nodes, each node is a neuron (or processing element) with a nonlinear <a href="activation_function" title="wikilink">activation function</a>. MLP utilizes a <a href="supervised_learning" title="wikilink">supervised learning</a> technique called <a class="uri" href="backpropagation" title="wikilink">backpropagation</a> for training the network.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> MLP is a modification of the standard linear <a class="uri" href="perceptron" title="wikilink">perceptron</a> and can distinguish data that are not <a href="Linear_separability" title="wikilink">linearly separable</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="theory">Theory</h2>
<section begin="theory">
</section>
<h3 id="activation-function">Activation function</h3>

<p>If a multilayer perceptron has a linear <a href="activation_function" title="wikilink">activation function</a> in all neurons, that is, a linear function that maps the <a href="synaptic_weight" title="wikilink">weighted inputs</a> to the output of each neuron, then it is easily proved with <a href="linear_algebra" title="wikilink">linear algebra</a> that any number of layers can be reduced to the standard two-layer input-output model (see <a class="uri" href="perceptron" title="wikilink">perceptron</a>). What makes a multilayer perceptron different is that some neurons use a <em>nonlinear</em> activation function which was developed to model the frequency of <a href="action_potentials" title="wikilink">action potentials</a>, or firing, of biological neurons in the brain. This function is modeled in several ways.</p>

<p>The two main activation functions used in current applications are both <a class="uri" href="sigmoids" title="wikilink">sigmoids</a>, and are described by</p>

<p>

<math display="block" id="Multilayer_perceptron:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>tanh</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>v</mi>
       <mi>i</mi>
      </msub>
      <mo rspace="9.1pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mpadded width="+6.6pt">
     <mtext>and</mtext>
    </mpadded>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <msup>
       <mi>e</mi>
       <mrow>
        <mo>-</mo>
        <msub>
         <mi>v</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <tanh></tanh>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <mtext>and</mtext>
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>v</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(v_{i})=\tanh(v_{i})~{}~{}\textrm{and}~{}~{}y(v_{i})=(1+e^{-v_{i}})^{-1}
  </annotation>
 </semantics>
</math>

,</p>

<p>in which the former function is a <a href="hyperbolic_tangent" title="wikilink">hyperbolic tangent</a> which ranges from -1 to 1, and the latter, the <a href="logistic_function" title="wikilink">logistic function</a>, is similar in shape but ranges from 0 to 1. Here 

<math display="inline" id="Multilayer_perceptron:1">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}
  </annotation>
 </semantics>
</math>

 is the output of the 

<math display="inline" id="Multilayer_perceptron:2">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

th node (neuron) and 

<math display="inline" id="Multilayer_perceptron:3">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

 is the weighted sum of the input synapses. Alternative activation functions have been proposed, including the <a href="Rectifier_(neural_networks)" title="wikilink">rectifier and softplus</a> functions. More specialized activation functions include <a href="radial_basis_functions" title="wikilink">radial basis functions</a> which are used in <a href="Radial_basis_network" title="wikilink">another class of supervised neural network models</a>.</p>
<h3 id="layers">Layers</h3>

<p>The multilayer perceptron consists of three or more layers (an input and an output layer with one or more <em>hidden layers</em>) of nonlinearly-activating nodes and is thus considered a <a href="Deep_learning#Deep_neural_networks" title="wikilink">deep neural network</a>. Each node in one layer connects with a certain weight 

<math display="inline" id="Multilayer_perceptron:4">
 <semantics>
  <msub>
   <mi>w</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{ij}
  </annotation>
 </semantics>
</math>

 to every node in the following layer. Some people do not include the input layer when counting the number of layers and there is disagreement about whether 

<math display="inline" id="Multilayer_perceptron:5">
 <semantics>
  <msub>
   <mi>w</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{ij}
  </annotation>
 </semantics>
</math>

 should be interpreted as the weight from i to j or the other way around.</p>
<h3 id="learning-through-backpropagation">Learning through backpropagation</h3>

<p>Learning occurs in the perceptron by changing connection weights after each piece of data is processed, based on the amount of error in the output compared to the expected result. This is an example of <a href="supervised_learning" title="wikilink">supervised learning</a>, and is carried out through <a class="uri" href="backpropagation" title="wikilink">backpropagation</a>, a generalization of the least mean squares algorithm in the linear perceptron.</p>

<p>We represent the error in output node 

<math display="inline" id="Multilayer_perceptron:6">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 in the 

<math display="inline" id="Multilayer_perceptron:7">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

th data point (training example) by 

<math display="inline" id="Multilayer_perceptron:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>e</mi>
     <mi>j</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>d</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>j</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <ci>j</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>j</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{j}(n)=d_{j}(n)-y_{j}(n)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Multilayer_perceptron:9">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 is the target value and 

<math display="inline" id="Multilayer_perceptron:10">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is the value produced by the perceptron. We then make corrections to the weights of the nodes based on those corrections which minimize the error in the entire output, given by</p>

<p>

<math display="block" id="Multilayer_perceptron:11">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℰ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>j</mi>
     </munder>
     <mrow>
      <msubsup>
       <mi>e</mi>
       <mi>j</mi>
       <mn>2</mn>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ℰ</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <ci>j</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{E}(n)=\frac{1}{2}\sum_{j}e_{j}^{2}(n)
  </annotation>
 </semantics>
</math>

.</p>

<p>Using <a href="gradient_descent" title="wikilink">gradient descent</a>, we find our change in each weight to be</p>

<p>

<math display="block" id="Multilayer_perceptron:12">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>j</mi>
      <mi>i</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>η</mi>
     <mfrac>
      <mrow>
       <mrow>
        <mo>∂</mo>
        <mi class="ltx_font_mathcaligraphic">ℰ</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mrow>
        <mo>∂</mo>
        <msub>
         <mi>v</mi>
         <mi>j</mi>
        </msub>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>η</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <partialdiff></partialdiff>
         <ci>ℰ</ci>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>v</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta w_{ji}(n)=-\eta\frac{\partial\mathcal{E}(n)}{\partial v_{j}(n)}y_{i}(n)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Multilayer_perceptron:13">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}
  </annotation>
 </semantics>
</math>

 is the output of the previous neuron and 

<math display="inline" id="Multilayer_perceptron:14">
 <semantics>
  <mi>η</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>η</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta
  </annotation>
 </semantics>
</math>

 is the <em>learning rate</em>, which is carefully selected to ensure that the weights converge to a response fast enough, without producing oscillations. In programming applications, this parameter typically ranges from 0.2 to 0.8.</p>

<p>The derivative to be calculated depends on the induced local field 

<math display="inline" id="Multilayer_perceptron:15">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{j}
  </annotation>
 </semantics>
</math>

, which itself varies. It is easy to prove that for an output node this derivative can be simplified to</p>

<p>

<math display="block" id="Multilayer_perceptron:16">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mo>∂</mo>
       <mi class="ltx_font_mathcaligraphic">ℰ</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mrow>
       <mo>∂</mo>
       <msub>
        <mi>v</mi>
        <mi>j</mi>
       </msub>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>e</mi>
     <mi>j</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mi>ϕ</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>v</mi>
       <mi>j</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <partialdiff></partialdiff>
        <ci>ℰ</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>j</ci>
     </apply>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ϕ</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>j</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\frac{\partial\mathcal{E}(n)}{\partial v_{j}(n)}=e_{j}(n)\phi^{\prime}(v_{j}(%
n))
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Multilayer_perceptron:17">
 <semantics>
  <msup>
   <mi>ϕ</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ϕ</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi^{\prime}
  </annotation>
 </semantics>
</math>

 is the derivative of the activation function described above, which itself does not vary. The analysis is more difficult for the change in weights to a hidden node, but it can be shown that the relevant derivative is</p>

<p>

<math display="block" id="Multilayer_perceptron:18">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mo>∂</mo>
       <mi class="ltx_font_mathcaligraphic">ℰ</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mrow>
       <mo>∂</mo>
       <msub>
        <mi>v</mi>
        <mi>j</mi>
       </msub>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>ϕ</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>v</mi>
        <mi>j</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>k</mi>
     </munder>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mrow>
        <mo>∂</mo>
        <mi class="ltx_font_mathcaligraphic">ℰ</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mrow>
        <mo>∂</mo>
        <msub>
         <mi>v</mi>
         <mi>k</mi>
        </msub>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
     <msub>
      <mi>w</mi>
      <mrow>
       <mi>k</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <partialdiff></partialdiff>
        <ci>ℰ</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ϕ</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <ci>j</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <partialdiff></partialdiff>
         <ci>ℰ</ci>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>v</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <apply>
        <times></times>
        <ci>k</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\frac{\partial\mathcal{E}(n)}{\partial v_{j}(n)}=\phi^{\prime}(v_{j}(n))\sum_%
{k}-\frac{\partial\mathcal{E}(n)}{\partial v_{k}(n)}w_{kj}(n)
  </annotation>
 </semantics>
</math>

.</p>

<p>This depends on the change in weights of the 

<math display="inline" id="Multilayer_perceptron:19">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

th nodes, which represent the output layer. So to change the hidden layer weights, we must first change the output layer weights according to the derivative of the activation function, and so this algorithm represents a <em>backpropagation of the activation function</em>. <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<section end="theory">
</section>
<h2 id="terminology">Terminology</h2>

<p>The term "multilayer perceptron" often causes confusion. It is argued the model is not a single perceptron that has multiple layers. Rather, it contains many perceptrons that are organised into layers, leading some to believe that a more fitting term might therefore be "multilayer perceptron network". Moreover, these "perceptrons" are not really perceptrons in the strictest possible sense, as true perceptrons are a special case of artificial neurons that use a threshold activation function such as the <a href="Heaviside_step_function" title="wikilink">Heaviside step function</a>, whereas the artificial neurons in a multilayer perceptron are free to take on any arbitrary activation function. Consequently, whereas a true perceptron performs binary classification, a neuron in a multilayer perceptron is free to either perform classification or regression, depending upon its activation function.</p>

<p>The two arguments raised above can be reconciled with the name "multilayer perceptron" if "perceptron" is simply interpreted to mean a binary classifier, independent of the specific mechanistic implementation of a classical perceptron. In this case, the entire network can indeed be considered to be a binary classifier with multiple layers. Furthermore, the term "multilayer perceptron" now does not specify the nature of the layers; the layers are free to be composed of general artificial neurons, and not perceptrons specifically. This interpretation of the term "multilayer perceptron" avoids the loosening of the definition of "perceptron" to mean an artificial neuron in general.</p>
<h2 id="applications">Applications</h2>

<p>Multilayer perceptrons using a backpropagation algorithm are the standard algorithm for any <a href="supervised_learning" title="wikilink">supervised learning</a> pattern recognition process and the subject of ongoing research in <a href="computational_neuroscience" title="wikilink">computational neuroscience</a> and <a href="parallel_distributed_processing" title="wikilink">parallel distributed processing</a>. They are useful in research in terms of their ability to solve problems stochastically, which often allows one to get approximate solutions for extremely <a href="Computational_complexity_theory" title="wikilink">complex</a> problems like <a href="fitness_approximation" title="wikilink">fitness approximation</a>.</p>

<p>MLPs were a popular machine learning solution in the 1980s, finding applications in diverse fields such as <a href="speech_recognition" title="wikilink">speech recognition</a>, <a href="image_recognition" title="wikilink">image recognition</a>, and <a href="machine_translation" title="wikilink">machine translation</a> software,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> but have since the 1990s faced strong competition from the much simpler (and related<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a>) <a href="support_vector_machine" title="wikilink">support vector machines</a>. More recently, there has been some renewed interest in backpropagation networks due to the successes of <a href="deep_learning" title="wikilink">deep learning</a>.</p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://numericinsight.com/uploads/A_Gentle_Introduction_to_Backpropagation.pdf">A Gentle Introduction to Backpropagation - An intuitive tutorial by Shashi Sathyanarayana</a> This is an updated PDF version of a blog article that was previously linked here. This article contains pseudocode ("Training Wheels for Training Neural Networks") for implementing the algorithm.</li>
<li><a href="http://www.cs.waikato.ac.nz/ml/weka/">Weka: Open source data mining software with multilayer perceptron implementation</a>.</li>
</ul>
<ul>
<li><a href="http://www.springerlink.com/index/200651K318731758.pdf">Border pairs method description</a>.</li>
</ul>

<p>"</p>

<p><a href="Category:Classification_algorithms" title="wikilink">Category:Classification algorithms</a> <a href="Category:Artificial_neural_networks" title="wikilink">Category:Artificial neural networks</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Rosenblatt, Frank. x. Principles of Neurodynamics: Perceptrons and the Theory of Brain Mechanisms. Spartan Books, Washington DC, 1961<a href="#fnref1">↩</a></li>
<li id="fn2">Rumelhart, David E., Geoffrey E. Hinton, and R. J. Williams. “Learning Internal Representations by Error Propagation”. David E. Rumelhart, James L. McClelland, and the PDP research group. (editors), Parallel distributed processing: Explorations in the microstructure of cognition, Volume 1: Foundations. MIT Press, 1986.<a href="#fnref2">↩</a></li>
<li id="fn3">Cybenko, G. 1989. Approximation by superpositions of a sigmoidal function <em><a href="Mathematics_of_Control,_Signals,_and_Systems" title="wikilink">Mathematics of Control, Signals, and Systems</a></em>, 2(4), 303–314.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">Neural networks. II. What are they and why is everybody so interested in them now?; Wasserman, P.D.; Schwartz, T.; Page(s): 10-15; IEEE Expert, 1988, Volume 3, Issue 1<a href="#fnref5">↩</a></li>
<li id="fn6">R. Collobert and S. Bengio (2004). Links between Perceptrons, MLPs and SVMs. Proc. Int'l Conf. on Machine Learning (ICML).<a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
