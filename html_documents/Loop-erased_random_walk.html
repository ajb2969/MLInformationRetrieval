<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1697">Loop-erased random walk</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Loop-erased random walk</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <strong>loop-erased random walk</strong> is a model for a <a class="uri" href="random" title="wikilink">random</a> <a href="path_(graph_theory)" title="wikilink">simple path</a> with important applications in <a class="uri" href="combinatorics" title="wikilink">combinatorics</a> and, in <a class="uri" href="physics" title="wikilink">physics</a>, <a href="quantum_field_theory" title="wikilink">quantum field theory</a>. It is intimately connected to the <strong>uniform spanning tree</strong>, a model for a random <a href="Tree_(graph_theory)" title="wikilink">tree</a>. See also <em><a href="random_walk" title="wikilink">random walk</a></em> for more general treatment of this topic.</p>
<h2 id="definition">Definition</h2>

<p>Assume <em>G</em> is some <a href="Graph_(mathematics)" title="wikilink">graph</a> and 

<math display="inline" id="Loop-erased_random_walk:0">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

 is some <a href="path_(graph_theory)" title="wikilink">path</a> of length <em>n</em> on <em>G</em>. In other words, 

<math display="inline" id="Loop-erased_random_walk:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mi>γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>γ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <ci>γ</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma(1),\dots,\gamma(n)
  </annotation>
 </semantics>
</math>

 are vertices of <em>G</em> such that 

<math display="inline" id="Loop-erased_random_walk:2">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>γ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma(i)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Loop-erased_random_walk:3">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>γ</ci>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma(i+1)
  </annotation>
 </semantics>
</math>

 are connected by an edge. Then the <strong>loop erasure</strong> of 

<math display="inline" id="Loop-erased_random_walk:4">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

 is a new simple path created by erasing all the loops of 

<math display="inline" id="Loop-erased_random_walk:5">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

 in chronological order. Formally, we define indices 

<math display="inline" id="Loop-erased_random_walk:6">
 <semantics>
  <msub>
   <mi>i</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>i</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{j}
  </annotation>
 </semantics>
</math>

 <a href="Mathematical_induction" title="wikilink">inductively</a> using</p>

<p>

<math display="block" id="Loop-erased_random_walk:7">
 <semantics>
  <mrow>
   <msub>
    <mi>i</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>1</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{1}=1\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Loop-erased_random_walk:8">
 <semantics>
  <mrow>
   <msub>
    <mi>i</mi>
    <mrow>
     <mi>j</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>max</mi>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mi>i</mi>
       <mo>:</mo>
       <mrow>
        <mrow>
         <mi>γ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>i</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mi>γ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>i</mi>
           <mi>j</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mpadded width="+1.7pt">
     <mn>1</mn>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>i</ci>
     <apply>
      <plus></plus>
      <ci>j</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <max></max>
      <apply>
       <ci>normal-:</ci>
       <ci>i</ci>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <ci>γ</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <times></times>
         <ci>γ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{j+1}=\max\{i:\gamma(i)=\gamma(i_{j})\}+1\,
  </annotation>
 </semantics>
</math>

</p>

<p>where "max" here means up to the length of the path 

<math display="inline" id="Loop-erased_random_walk:9">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

. The induction stops when for some 

<math display="inline" id="Loop-erased_random_walk:10">
 <semantics>
  <msub>
   <mi>i</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>i</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{j}
  </annotation>
 </semantics>
</math>

 we have 

<math display="inline" id="Loop-erased_random_walk:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>i</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>γ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>γ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma(i_{j})=\gamma(n)
  </annotation>
 </semantics>
</math>

. Assume this happens at <em>J</em> i.e. 

<math display="inline" id="Loop-erased_random_walk:12">
 <semantics>
  <msub>
   <mi>i</mi>
   <mi>J</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>i</ci>
    <ci>J</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{J}
  </annotation>
 </semantics>
</math>

 is the last 

<math display="inline" id="Loop-erased_random_walk:13">
 <semantics>
  <msub>
   <mi>i</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>i</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{j}
  </annotation>
 </semantics>
</math>

. Then the loop erasure of 

<math display="inline" id="Loop-erased_random_walk:14">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

, denoted by 

<math display="inline" id="Loop-erased_random_walk:15">
 <semantics>
  <mrow>
   <mi>LE</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>γ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>LE</ci>
    <ci>γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{LE}(\gamma)
  </annotation>
 </semantics>
</math>

 is a simple path of length <em>J</em> defined by</p>

<p>

<math display="block" id="Loop-erased_random_walk:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>LE</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>γ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>j</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>γ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>i</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>LE</ci>
     <ci>γ</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <times></times>
     <ci>γ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{LE}(\gamma)(j)=\gamma(i_{j}).\,
  </annotation>
 </semantics>
</math>

</p>

<p>Now let <em>G</em> be some graph, let <em>v</em> be a vertex of <em>G</em>, and let <em>R</em> be a random walk on <em>G</em> starting from <em>v</em>. Let <em>T</em> be some <a href="stopping_time" title="wikilink">stopping time</a> for <em>R</em>. Then the <strong>loop-erased random walk</strong> until time <em>T</em> is LE(<em>R</em>([1,<em>T</em>])). In other words, take <em>R</em> from its beginning until <em>T</em> — that's a (random) path — erase all the loops in chronological order as above — you get a random simple path.</p>

<p>The stopping time <em>T</em> may be fixed, i.e. one may perform <em>n</em> steps and then loop-erase. However, it is usually more natural to take <em>T</em> to be the <a href="hitting_time" title="wikilink">hitting time</a> in some set. For example, let <em>G</em> be the graph <strong>Z</strong><sup>2</sup> and let <em>R</em> be a random walk starting from the point (0,0). Let <em>T</em> be the time when <em>R</em> first hits the circle of radius 100 (we mean here of course a <em>discretized</em> circle). LE(<em>R</em>) is called the loop-erased random walk starting at (0,0) and stopped at the circle.</p>
<h2 id="the-uniform-spanning-tree">The uniform spanning tree</h2>

<p>A <a href="spanning_tree" title="wikilink">spanning tree</a> chosen randomly from among all possible spanning trees with equal probability is called a uniform spanning tree. To create such a tree Wilson’s algorithm uses loop-erased random walks. The algorithm proceeds by initializing the tree maze with an random starting cell. New cells are then subsequently added to the maze, initiating a random walk. The random walk progresses uninterrupted until it eventually links with the prevailing maze. However, if the random walk traverses through itself, the resulting loop is erased before the random walk proceeds. The initial random walks are unexpected to link with the small existing maze. As the maze develops, the random walks tend to have a higher probability to collide with the maze and may cause the algorithm to accelerate dramatically.</p>

<p>For instance, Let <em>G</em> again be a graph. A <a href="spanning_tree_(mathematics)" title="wikilink">spanning tree</a> of <em>G</em> is a <a href="Glossary_of_graph_theory#Subgraphs" title="wikilink">subgraph</a> of <em>G</em> containing all vertices and some of the edges, which is a <a href="tree_(graph_theory)" title="wikilink">tree</a>, i.e. <a href="Glossary_of_graph_theory#Connectivity" title="wikilink">connected</a> and with no <a href="Glossary_of_graph_theory#cycle" title="wikilink">cycles</a>. The uniform spanning tree (UST for short) is a <em>random</em> spanning tree chosen among all the possible spanning trees of <em>G</em> with equal probability.</p>

<p>Let now <em>v</em> and <em>w</em> be two vertices in <em>G</em>. Any spanning tree contains precisely one simple path between <em>v</em> and <em>w</em>. Taking this path in the <em>uniform</em> spanning tree gives a random simple path. It turns out that the distribution of this path is identical to the distribution of the loop-erased random walk starting at <em>v</em> and stopped at <em>w</em>.</p>

<p>An immediate corollary is that loop-erased random walk is symmetric in its start and end points. More precisely, the distribution of the loop-erased random walk starting at <em>v</em> and stopped at <em>w</em> is identical to the distribution of the reversal of loop-erased random walk starting at <em>w</em> and stopped at <em>v</em>. This is not a trivial fact at all! Loop-erasing a path and the reverse path do not give the same result. It is only the <em>distributions</em> that are identical.</p>

<p>A-priori <a href="Sampling_(statistics)" title="wikilink">sampling</a> a UST seems difficult. Even a relatively modest graph (say a 100x100 grid) has far too many spanning trees to prepare a complete list. Therefore a different approach is needed. There are a number of algorithms for sampling a UST, but we will concentrate on <strong>Wilson's algorithm</strong>.</p>

<p>Take any two vertices and perform loop-erased random walk from one to the other. Now take a third vertex (not on the constructed path) and perform loop-erased random walk until hitting the already constructed path. This gives a tree with either two or three leaves. Choose a fourth vertex and do loop-erased random walk until hitting this tree. Continue until the tree spans all the vertices. It turns out that <em>no matter which method you use to choose the starting vertices</em> you always end up with the same distribution on the spanning trees, namely the uniform one.</p>
<h2 id="the-laplacian-random-walk">The Laplacian random walk</h2>

<p>Another representation of loop-erased random walk stems from solutions of the <a href="Discrete_mathematics" title="wikilink">discrete</a> <a href="Laplace_equation" title="wikilink">Laplace equation</a>. Let <em>G</em> again be a graph and let <em>v</em> and <em>w</em> be two vertices in <em>G</em>. Construct a random path from <em>v</em> to <em>w</em> inductively using the following procedure. Assume we have already defined 

<math display="inline" id="Loop-erased_random_walk:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mi>γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>γ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <ci>γ</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma(1),...,\gamma(n)
  </annotation>
 </semantics>
</math>

. Let <em>f</em> be a function from <em>G</em> to <strong>R</strong> satisfying</p>

<p>

<math display="block" id="Loop-erased_random_walk:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>γ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>γ</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\gamma(i))=0
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Loop-erased_random_walk:19">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>≤</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>i</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\leq n
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Loop-erased_random_walk:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>w</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(w)=1
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><em>f</em> is discretely <a href="Harmonic_function" title="wikilink">harmonic</a> everywhere else
</dd>
</dl>

<p>Where a function <em>f</em> on a graph is discretely harmonic at a point <em>x</em> if <em>f</em>(<em>x</em>) equals the average of <em>f</em> on the neighbors of <em>x</em>.</p>

<p>With <em>f</em> defined choose 

<math display="inline" id="Loop-erased_random_walk:21">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>γ</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma(n+1)
  </annotation>
 </semantics>
</math>

 using <em>f</em> at the neighbors of 

<math display="inline" id="Loop-erased_random_walk:22">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>γ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma(n)
  </annotation>
 </semantics>
</math>

 as weights. In other words, if 

<math display="inline" id="Loop-erased_random_walk:23">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>d</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>d</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},...,x_{d}
  </annotation>
 </semantics>
</math>

 are these neighbors, choose 

<math display="inline" id="Loop-erased_random_walk:24">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 with probability</p>

<p>

<math display="block" id="Loop-erased_random_walk:25">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>d</mi>
     </msubsup>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>d</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{f(x_{i})}{\sum_{j=1}^{d}f(x_{j})}.
  </annotation>
 </semantics>
</math>

</p>

<p>Continuing this process, recalculating <em>f</em> at each step, with result in a random simple path from <em>v</em> to <em>w</em>; the distribution of this path is identical to that of a loop-erased random walk from <em>v</em> to <em>w</em>.</p>

<p>An alternative view is that the distribution of a loop-erased random walk <a href="Conditional_probability" title="wikilink">conditioned</a> to start in some path β is identical to the loop-erasure of a random walk conditioned not to hit β. This property is often referred to as the <strong>Markov property</strong> of loop-erased random walk (though the relation to the usual <a href="Markov_property" title="wikilink">Markov property</a> is somewhat vague).</p>

<p>It is important to notice that while the proof of the equivalence is quite easy, models which involve dynamically changing harmonic functions or measures are typically extremely difficult to analyze. Practically nothing is known about the <a href="p-Laplacian_walk" title="wikilink">p-Laplacian walk</a> or <a href="Brownian_tree" title="wikilink">diffusion-limited aggregation</a>. Another somewhat related model is the <a href="harmonic_explorer" title="wikilink">harmonic explorer</a>.</p>

<p>Finally there is another link that should be mentioned: <a href="Kirchhoff's_theorem" title="wikilink">Kirchhoff's theorem</a> relates the number of spanning trees of a graph <em>G</em> to the <a href="eigenvalue" title="wikilink">eigenvalues</a> of the discrete <a class="uri" href="Laplacian" title="wikilink">Laplacian</a>. See <a href="spanning_tree_(mathematics)" title="wikilink">spanning tree</a> for details.</p>
<h2 id="grids">Grids</h2>

<p>Let <em>d</em> be the dimension, which we will assume to be at least 2. Examine <strong>Z</strong><sup><em>d</em></sup> i.e. all the points 

<math display="inline" id="Loop-erased_random_walk:26">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mi>d</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>d</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a_{1},...,a_{d})
  </annotation>
 </semantics>
</math>

 with integer 

<math display="inline" id="Loop-erased_random_walk:27">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}
  </annotation>
 </semantics>
</math>

. This is an infinite graph with degree 2<em>d</em> when you connect each point to its nearest neighbors. From now on we will consider loop-erased random walk on this graph or its subgraphs.</p>
<h3 id="high-dimensions">High dimensions</h3>

<p>The easiest case to analyze is dimension 5 and above. In this case it turns out that there the intersections are only local. A calculation shows that if one takes a random walk of length <em>n</em>, its loop-erasure has length of the same order of magnitude, i.e. <em>n</em>. Scaling accordingly, it turns out that loop-erased random walk converges (in an appropriate sense) to <a href="Brownian_motion" title="wikilink">Brownian motion</a> as <em>n</em> goes to infinity. Dimension 4 is more complicated, but the general picture is still true. It turns out that the loop-erasure of a random walk of length <em>n</em> has approximately 

<math display="inline" id="Loop-erased_random_walk:28">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>/</mo>
   <mrow>
    <msup>
     <mi>log</mi>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>3</mn>
     </mrow>
    </msup>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <log></log>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n/\log^{1/3}n
  </annotation>
 </semantics>
</math>

 vertices, but again, after scaling (that takes into account the logarithmic factor) the loop-erased walk converges to Brownian motion.</p>
<h3 id="two-dimensions">Two dimensions</h3>

<p>In two dimensions, arguments from <a href="conformal_field_theory" title="wikilink">conformal field theory</a> and simulation results led to a number of exciting conjectures. Assume <em>D</em> is some <a href="simply_connected" title="wikilink">simply connected</a> <a href="Domain_(mathematics)" title="wikilink">domain</a> in the plane and <em>x</em> is a point in <em>D</em>. Take the graph <em>G</em> to be</p>

<p>

<math display="block" id="Loop-erased_random_walk:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mo>:=</mo>
    <mrow>
     <mi>D</mi>
     <mo>∩</mo>
     <mrow>
      <mi>ε</mi>
      <msup>
       <mi>ℤ</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>G</ci>
    <apply>
     <intersect></intersect>
     <ci>D</ci>
     <apply>
      <times></times>
      <ci>ε</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℤ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G:=D\cap\varepsilon\mathbb{Z}^{2},
  </annotation>
 </semantics>
</math>

</p>

<p>that is, a grid of side length ε restricted to <em>D</em>. Let <em>v</em> be the vertex of <em>G</em> closest to <em>x</em>. Examine now a loop-erased random walk starting from <em>v</em> and stopped when hitting the "boundary" of <em>G</em>, i.e. the vertices of <em>G</em> which correspond to the boundary of <em>D</em>. Then the conjectures are</p>
<ul>
<li>As ε goes to zero the distribution of the path converges to some distribution on simple paths from <em>x</em> to the boundary of <em>D</em> (different from Brownian motion, of course — in 2 dimensions paths of Brownian motion are not simple). This distribution (denote it by 

<math display="inline" id="Loop-erased_random_walk:30">
 <semantics>
  <msub>
   <mi>S</mi>
   <mrow>
    <mi>D</mi>
    <mo>,</mo>
    <mi>x</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <list>
     <ci>D</ci>
     <ci>x</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{D,x}
  </annotation>
 </semantics>
</math>

) is called the <strong>scaling limit</strong> of loop-erased random walk.</li>
<li>These distributions are <a href="Conformal_map" title="wikilink">conformally invariant</a>. Namely, if φ is a <a href="Riemann_mapping_theorem" title="wikilink">Riemann map</a> between <em>D</em> and a second domain <em>E</em> then</li>
</ul>

<p>

<math display="block" id="Loop-erased_random_walk:31">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>S</mi>
       <mrow>
        <mi>D</mi>
        <mo>,</mo>
        <mi>x</mi>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>S</mi>
     <mrow>
      <mi>E</mi>
      <mo>,</mo>
      <mrow>
       <mi>ϕ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <list>
       <ci>D</ci>
       <ci>x</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <list>
      <ci>E</ci>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <ci>x</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(S_{D,x})=S_{E,\phi(x)}.\,
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>The <a href="Hausdorff_dimension" title="wikilink">Hausdorff dimension</a> of these paths is 5/4 <a href="almost_surely" title="wikilink">almost surely</a>.</li>
</ul>

<p>The first attack at these conjectures came from the direction of <strong><a href="domino_tiling" title="wikilink">domino tilings</a></strong>. Taking a spanning tree of <em>G</em> and adding to it its <a href="Planar_graph" title="wikilink">planar dual</a> one gets a <a href="Dominoes" title="wikilink">domino</a> tiling of a special derived graph (call it <em>H</em>). Each vertex of <em>H</em> corresponds to a vertex, edge or face of <em>G</em>, and the edges of <em>H</em> show which vertex lies on which edge and which edge on which face. It turns out that taking a uniform spanning tree of <em>G</em> leads to a uniformly distributed random domino tiling of <em>H</em>. The number of domino tilings of a graph can be calculated using the determinant of special matrices, which allow to connect it to the discrete <a href="Green's_function" title="wikilink">Green function</a> which is approximately conformally invariant. These arguments allowed to show that certain measurables of loop-erased random walk are (in the limit) conformally invariant, and that the <a href="Expected_value" title="wikilink">expected</a> number of vertices in a loop-erased random walk stopped at a circle of radius <em>r</em> is of the order of 

<math display="inline" id="Loop-erased_random_walk:32">
 <semantics>
  <msup>
   <mi>r</mi>
   <mrow>
    <mn>5</mn>
    <mo>/</mo>
    <mn>4</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>r</ci>
    <apply>
     <divide></divide>
     <cn type="integer">5</cn>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{5/4}
  </annotation>
 </semantics>
</math>

.</p>

<p>In 2002 these conjectures were resolved (positively) using <a href="Stochastic_Löwner_Evolution" title="wikilink">Stochastic Löwner Evolution</a>. Very roughly, it is a stochastic conformally invariant <a href="ordinary_differential_equation" title="wikilink">ordinary differential equation</a> which allows to catch the Markov property of loop-erased random walk (and many other probabilistic processes).</p>
<h3 id="three-dimensions">Three dimensions</h3>

<p>The scaling limit exists and is invariant under rotations and dilations.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> If 

<math display="inline" id="Loop-erased_random_walk:33">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(r)
  </annotation>
 </semantics>
</math>

 denotes the expected number of vertices in the loop-erased random walk until it gets to a distance of <em>r</em>, then</p>

<p>

<math display="block" id="Loop-erased_random_walk:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <msup>
     <mi>r</mi>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mi>ε</mi>
     </mrow>
    </msup>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>C</mi>
    <mpadded width="+1.7pt">
     <msup>
      <mi>r</mi>
      <mrow>
       <mn>5</mn>
       <mo>/</mo>
       <mn>3</mn>
      </mrow>
     </msup>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <ci>c</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>r</ci>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <ci>ε</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>C</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>r</ci>
       <apply>
        <divide></divide>
        <cn type="integer">5</cn>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   cr^{1+\varepsilon}\leq L(r)\leq Cr^{5/3}\,
  </annotation>
 </semantics>
</math>

</p>

<p>where ε, <em>c</em> and <em>C</em> are some positive numbers <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> (the numbers can, in principle, be calculated from the proofs, but the author did not do it). This suggests that the scaling limit should have Hausdorff dimension between 

<math display="inline" id="Loop-erased_random_walk:35">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>+</mo>
   <mi>ε</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">1</cn>
    <ci>ε</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+\varepsilon
  </annotation>
 </semantics>
</math>

 and 5/3 almost surely. Numerical experiments show that it should be 

<math display="inline" id="Loop-erased_random_walk:36">
 <semantics>
  <mrow>
   <mn>1.62400</mn>
   <mo>±</mo>
   <mn>0.00005</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">plus-or-minus</csymbol>
    <cn type="float">1.62400</cn>
    <cn type="float">0.00005</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1.62400\pm 0.00005
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> </p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>Richard Kenyon, <em>The asymptotic determinant of the discrete Laplacian</em>, Acta Math. <strong>185:2</strong> (2000), 239-286, <a href="http://arxiv.org/abs/math-ph/0011042">online version</a>.</li>
<li>Richard Kenyon, <em>Conformal invariance of domino tiling</em>, Ann. Probab. <strong>28:2</strong> (2000), 759-795, <a href="http://arxiv.org/abs/math-ph/9910002">online version</a>.</li>
<li>Richard Kenyon, <em>Long-range properties of spanning trees</em>, Probabilistic techniques in equilibrium and nonequilibrium statistical physics, J. Math. Phys. <strong>41:3</strong> (2000), 1338-1363, <a href="http://www.math.ubc.ca/~kenyon/papers/long.ps.Z">online version</a>.</li>
<li>Gady Kozma, <em>The scaling limit of loop-erased random walk in three dimensions</em>, Acta Math. <strong>199:1</strong> (2007), 29-152, <a href="http://arxiv.org/abs/math.PR/0508344">online version</a>.</li>
<li>Gregory F. Lawler, <em>A self avoiding walk</em>, Duke Math. J. <strong>47</strong> (1980), 655-694. <em>The original definition and a proof of the Markov property</em>.</li>
<li>Gregory F. Lawler, <em>The logarithmic correction for loop-erased random walk in four dimensions</em>, Proceedings of the Conference in Honor of Jean-Pierre kahane (<a class="uri" href="Orsay" title="wikilink">Orsay</a>, 1993). Special issue of J. Fourier Anal. Appl., 347-362.</li>
<li>Gregory F. Lawler, Oded Schramm, <a href="Wendelin_Werner" title="wikilink">Wendelin Werner</a>, <em>Conformal invariance of planar loop-erased random walks and uniform spanning trees</em>, Ann. Probab. <strong>32:1B</strong> (2004), 939-995, <a href="http://arxiv.org/abs/math.PR/0112234">online version</a>.</li>
<li>Robin Pemantle, <em>Choosing a spanning tree for the integer lattice uniformly</em>, Ann. Probab. <strong>19:4</strong> (1991), 1559-1574.</li>
<li>Oded Schramm, <em>Scaling limits of loop-erased random walks and uniform spanning trees</em>, Israel J. Math. <strong>118</strong> (2000), 221-288.</li>
<li>David Bruce Wilson, <em>Generating random spanning trees more quickly than the cover time</em>, Proceedings of the Twenty-eighth Annual ACM Symposium on the Theory of Computing (Philadelphia, PA, 1996), 296-303, ACM, New York, 1996.</li>
</ul>

<p>"</p>

<p><a href="Category:Stochastic_processes" title="wikilink">Category:Stochastic processes</a> <a href="Category:Random_graphs" title="wikilink">Category:Random graphs</a> <a href="Category:Variants_of_random_walks" title="wikilink">Category:Variants of random walks</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Kozma, Gady (2007) "The scaling limit of loop-erased random walk in three dimensions", <em>Acta Mathematica</em>, 199 (1), 29–152  <a href="http://arxiv.org/abs/math.PR/0508344">preprint</a><a href="#fnref1">↩</a></li>
<li id="fn2">Lawler, Gregory F. (1999) "Loop-erased random walk", in <em>Perplexing problems in probability: Festschrift in honor of Harry Kesten</em> (M. Bramson and R. T. Durrett, eds.), Progr. Probab., vol. 44, Birkhäuser Boston, Boston, MA, 1999, pp. 197–217.<a href="#fnref2">↩</a></li>
<li id="fn3">Wilson, David B. (2010) "The dimension of loop-erased random walk in 3D", <em>Physical Review E</em>,82(6):062102.<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
