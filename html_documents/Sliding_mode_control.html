<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="425">Sliding mode control</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Sliding mode control</h1>
<hr/>

<p>In <a href="control_system" title="wikilink">control system</a>, <strong>sliding mode control</strong>, or <strong>SMC</strong>, is a <a href="nonlinear_control" title="wikilink">nonlinear control</a> method that alters the <a href="dynamic_system" title="wikilink">dynamics</a> of a <a href="nonlinear_system" title="wikilink">nonlinear system</a> by application of a <a class="uri" href="discontinuous" title="wikilink">discontinuous</a> control signal that forces the system to "slide" along a cross-section of the system's normal behavior. The <a href="state_space_(controls)" title="wikilink">state</a>-<a class="uri" href="feedback" title="wikilink">feedback</a> control law is not a <a href="continuous_function" title="wikilink">continuous function</a> of time. Instead, it can switch from one continuous structure to another based on the current position in the state space. Hence, sliding mode control is a <a href="variable_structure_control" title="wikilink">variable structure control</a> method. The multiple control structures are designed so that trajectories always move toward an adjacent region with a different control structure, and so the ultimate trajectory will not exist entirely within one control structure. Instead, it will <em>slide</em> along the boundaries of the control structures. The motion of the system as it slides along these boundaries is called a <em>sliding mode</em><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and the geometrical <a href="locus_(mathematics)" title="wikilink">locus</a> consisting of the boundaries is called the <em>sliding (hyper)surface</em>. In the context of modern control theory, any <a href="variable_structure_system" title="wikilink">variable structure system</a>, like a system under SMC, may be viewed as a special case of a <a href="hybrid_system" title="wikilink">hybrid dynamical system</a> as the system both flows through a continuous state space but also moves through different discrete control modes.</p>
<h2 id="introduction">Introduction</h2>
<figure><b>(Figure)</b>
<figcaption>Figure 1: <a href="Phase_plane" title="wikilink">Phase plane</a> trajectory of a system being stabilized by a sliding mode controller. After the initial reaching phase, the system states "slides" along the line 

<math display="inline" id="Sliding_mode_control:0">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=0
  </annotation>
 </semantics>
</math>

. The particular 

<math display="inline" id="Sliding_mode_control:1">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=0
  </annotation>
 </semantics>
</math>

 surface is chosen because it has desirable reduced-order dynamics when constrained to it. In this case, the 

<math display="inline" id="Sliding_mode_control:2">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mover accent="true">
      <mi>x</mi>
      <mo>˙</mo>
     </mover>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>s</ci>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-˙</ci>
        <ci>x</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=x_{1}+\dot{x}_{1}=0
  </annotation>
 </semantics>
</math>

 surface corresponds to the first-order <a href="LTI_system" title="wikilink">LTI system</a> 

<math display="inline" id="Sliding_mode_control:3">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>x</mi>
     <mo>˙</mo>
    </mover>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-˙</ci>
      <ci>x</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{x}_{1}=-x_{1}
  </annotation>
 </semantics>
</math>


, which has an <a href="exponentially_stable" title="wikilink">exponentially stable</a> origin.</figcaption>
</figure>

<p>Figure 1 shows an example trajectory of a system under sliding mode control. The sliding surface is described by 

<math display="inline" id="Sliding_mode_control:4">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=0
  </annotation>
 </semantics>
</math>

, and the sliding mode along the surface commences after the finite time when system trajectories have reached the surface. In the theoretical description of sliding modes, the system stays confined to the sliding surface and need only be viewed as sliding along the surface. However, real implementations of sliding mode control approximate this theoretical behavior with a high-frequency and generally non-deterministic switching control signal that causes the system to "chatter" in a tight neighborhood of the sliding surface. This chattering behavior is evident in Figure 1, which chatters along the 

<math display="inline" id="Sliding_mode_control:5">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=0
  </annotation>
 </semantics>
</math>

 surface as the system asymptotically approaches the origin, which is an asymptotically stable equilibrium of the system when confined to the sliding surface. In fact, although the system is nonlinear in general, the idealized (i.e., non-chattering) behavior of the system in Figure 1 when confined to the 

<math display="inline" id="Sliding_mode_control:6">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=0
  </annotation>
 </semantics>
</math>

 surface is an <a href="LTI_system" title="wikilink">LTI system</a> with an <a href="exponentially_stable" title="wikilink">exponentially stable</a> origin.</p>

<p>Intuitively, sliding mode control uses practically infinite <a class="uri" href="gain" title="wikilink">gain</a> to force the trajectories of a <a href="dynamic_system" title="wikilink">dynamic system</a> to slide along the restricted sliding mode subspace. Trajectories from this reduced-order sliding mode have desirable properties (e.g., the system naturally slides along it until it comes to rest at a desired <a href="stationary_point" title="wikilink">equilibrium</a>). The main strength of sliding mode control is its <a href="robust_control" title="wikilink">robustness</a>. Because the control can be as simple as a switching between two states (e.g., "on"/"off" or "forward"/"reverse"), it need not be precise and will not be sensitive to parameter variations that enter into the control channel. Additionally, because the control law is not a <a href="continuous_function" title="wikilink">continuous function</a>, the sliding mode can be reached in <em>finite</em> time (i.e., better than asymptotic behavior). Under certain common conditions, <a href="optimal_control" title="wikilink">optimality</a> requires the use of <a href="bang–bang_control" title="wikilink">bang–bang control</a>; hence, sliding mode control describes the <a href="optimal_control" title="wikilink">optimal controller</a> for a broad set of dynamic systems.</p>

<p>One application of sliding mode controller is the control of electric drives operated by switching power converters.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Because of the discontinuous operating mode of those converters, a discontinuous sliding mode controller is a natural implementation choice over continuous controllers that may need to be applied by means of <a href="pulse-width_modulation" title="wikilink">pulse-width modulation</a> or a similar technique<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> of applying a continuous signal to an output that can only take discrete states. Sliding mode control has many applications in robotics. In particular, this control algorithm has been used for tracking control of unmanned surface vessels in simulated rough seas with high degree of success.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>Sliding mode control must be applied with more care than other forms of <a href="nonlinear_control" title="wikilink">nonlinear control</a> that have more moderate control action. In particular, because actuators have delays and other imperfections, the hard sliding-mode-control action can lead to chatter, energy loss, plant damage, and excitation of unmodeled dynamics.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Continuous control design methods are not as susceptible to these problems and can be made to mimic sliding-mode controllers.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="control-scheme">Control scheme</h2>

<p>Consider a <a href="nonlinear_system" title="wikilink">nonlinear dynamical system</a> described by</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="block" id="Sliding_mode_control:7">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>𝐱</mi>
     <mo>˙</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐱</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐱</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>𝐮</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-˙</ci>
      <ci>𝐱</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>𝐱</ci>
       <ci>t</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>B</ci>
      <interval closure="open">
       <ci>𝐱</ci>
       <ci>t</ci>
      </interval>
      <ci>𝐮</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\mathbf{x}}(t)=f(\mathbf{x},t)+B(\mathbf{x},t)\,\mathbf{u}(t)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sliding_mode_control:8">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>1</mn>
   <mo rspace="4.2pt" stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1)\,
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
</tbody>
</table>

<p>where</p>

<p>

<math display="block" id="Sliding_mode_control:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐱</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≜</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msub>
         <mi>x</mi>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-≜</ci>
     <apply>
      <times></times>
      <ci>𝐱</ci>
      <ci>t</ci>
     </apply>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>t</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>t</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <ci>normal-⋮</ci>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>t</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}(t)\triangleq\begin{bmatrix}x_{1}(t)\\
x_{2}(t)\\
\vdots\\
x_{n-1}(t)\\
x_{n}(t)\end{bmatrix}\in\mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

 is an 

<math display="inline" id="Sliding_mode_control:10">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-dimensional <a href="state_space_(controls)" title="wikilink">state</a> <a href="column_vector" title="wikilink">vector</a> and</p>

<p>

<math display="block" id="Sliding_mode_control:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐮</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≜</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msub>
         <mi>u</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msub>
         <mi>u</mi>
         <mn>2</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msub>
         <mi>u</mi>
         <mrow>
          <mi>m</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msub>
         <mi>u</mi>
         <mi>m</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>m</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-≜</ci>
     <apply>
      <times></times>
      <ci>𝐮</ci>
      <ci>t</ci>
     </apply>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>t</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>t</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <ci>normal-⋮</ci>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <apply>
          <minus></minus>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>t</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>m</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}(t)\triangleq\begin{bmatrix}u_{1}(t)\\
u_{2}(t)\\
\vdots\\
u_{m-1}(t)\\
u_{m}(t)\end{bmatrix}\in\mathbb{R}^{m}
  </annotation>
 </semantics>
</math>

 is an 

<math display="inline" id="Sliding_mode_control:12">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

-dimensional input vector that will be used for state <a class="uri" href="feedback" title="wikilink">feedback</a>. The <a href="Function_(mathematics)" title="wikilink">functions</a> 

<math display="inline" id="Sliding_mode_control:13">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>ℝ</mi>
      <mi>n</mi>
     </msup>
     <mo>×</mo>
     <mi>ℝ</mi>
    </mrow>
    <mo>↦</mo>
    <msup>
     <mi>ℝ</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℝ</ci>
       <ci>n</ci>
      </apply>
      <ci>ℝ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\mathbb{R}^{n}\times\mathbb{R}\mapsto\mathbb{R}^{n}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Sliding_mode_control:14">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>ℝ</mi>
      <mi>n</mi>
     </msup>
     <mo>×</mo>
     <mi>ℝ</mi>
    </mrow>
    <mo>↦</mo>
    <msup>
     <mi>ℝ</mi>
     <mrow>
      <mi>n</mi>
      <mo>×</mo>
      <mi>m</mi>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>B</ci>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℝ</ci>
       <ci>n</ci>
      </apply>
      <ci>ℝ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B:\mathbb{R}^{n}\times\mathbb{R}\mapsto\mathbb{R}^{n\times m}
  </annotation>
 </semantics>
</math>

 are assumed to be <a href="continuous_function" title="wikilink">continuous</a> and sufficiently <a href="smooth_function" title="wikilink">smooth</a> so that the <a href="Picard–Lindelöf_theorem" title="wikilink">Picard–Lindelöf theorem</a> can be used to guarantee that solution 

<math display="inline" id="Sliding_mode_control:15">
 <semantics>
  <mrow>
   <mi>𝐱</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐱</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}(t)
  </annotation>
 </semantics>
</math>

 to Equation (1) <a href="existence" title="wikilink">exists</a> and is <a href="uniqueness" title="wikilink">unique</a>.</p>

<p>A common task is to design a state-feedback <a href="control_systems" title="wikilink">control law</a> 

<math display="inline" id="Sliding_mode_control:16">
 <semantics>
  <mrow>
   <mi>𝐮</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>𝐱</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐮</ci>
    <apply>
     <times></times>
     <ci>𝐱</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}(\mathbf{x}(t))
  </annotation>
 </semantics>
</math>

 (i.e., a mapping from current state 

<math display="inline" id="Sliding_mode_control:17">
 <semantics>
  <mrow>
   <mi>𝐱</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐱</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}(t)
  </annotation>
 </semantics>
</math>

 at time 

<math display="inline" id="Sliding_mode_control:18">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>


 to the input 

<math display="inline" id="Sliding_mode_control:19">
 <semantics>
  <mi>𝐮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}
  </annotation>
 </semantics>
</math>

) to <a href="Lyapunov_stability" title="wikilink">stabilize</a> the <a href="dynamical_system" title="wikilink">dynamical system</a> in Equation (1) around the <a href="origin_(mathematics)" title="wikilink">origin</a> 

<math display="inline" id="Sliding_mode_control:20">
 <semantics>
  <mrow>
   <mi>𝐱</mi>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mn>0</mn>
     <mo stretchy="false">]</mo>
    </mrow>
    <mtext>T</mtext>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐱</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <list>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <ci>normal-…</ci>
      <cn type="integer">0</cn>
     </list>
     <mtext>T</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}=[0,0,\ldots,0]^{\text{T}}
  </annotation>
 </semantics>
</math>

. That is, under the control law, whenever the system is started away from the origin, it will return to it. For example, the component 

<math display="inline" id="Sliding_mode_control:21">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 of the state vector 

<math display="inline" id="Sliding_mode_control:22">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 may represent the difference some output is away from a known signal (e.g., a desirable sinusoidal signal); if the control 

<math display="inline" id="Sliding_mode_control:23">
 <semantics>
  <mi>𝐮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}
  </annotation>
 </semantics>
</math>


 can ensure that 

<math display="inline" id="Sliding_mode_control:24">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 quickly returns to 

<math display="inline" id="Sliding_mode_control:25">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=0
  </annotation>
 </semantics>
</math>

, then the output will track the desired sinusoid. In sliding-mode control, the designer knows that the system behaves desirably (e.g., it has a stable <a href="stationary_point" title="wikilink">equilibrium</a>) provided that it is constrained to a subspace of its <a href="configuration_space" title="wikilink">configuration space</a>. Sliding mode control forces the system trajectories into this subspace and then holds them there so that they slide along it. This reduced-order subspace is referred to as a <em>sliding (hyper)surface</em>, and when closed-loop feedback forces trajectories to slide along it, it is referred to as a <em>sliding mode</em> of the closed-loop system. Trajectories along this subspace can be likened to trajectories along eigenvectors (i.e., modes) of <a href="LTI_system" title="wikilink">LTI systems</a>; however, the sliding mode is enforced by creasing the vector field with high-gain feedback. Like a marble rolling along a crack, trajectories are confined to the sliding mode.</p>

<p>The sliding-mode control scheme involves</p>
<ol>
<li>Selection of a <a class="uri" href="hypersurface" title="wikilink">hypersurface</a> or a manifold (i.e., the sliding surface) such that the system trajectory exhibits desirable behavior when confined to this manifold.</li>
<li>Finding feedback gains so that the system trajectory intersects and stays on the manifold.</li>
</ol>

<p>Because sliding mode control laws are not <a href="continuous_function" title="wikilink">continuous</a>, it has the ability to drive trajectories to the sliding mode in finite time (i.e., stability of the sliding surface is better than asymptotic). However, once the trajectories reach the sliding surface, the system takes on the character of the sliding mode (e.g., the origin 

<math display="inline" id="Sliding_mode_control:26">
 <semantics>
  <mrow>
   <mi>𝐱</mi>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐱</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}=\mathbf{0}
  </annotation>
 </semantics>
</math>

 may only have asymptotic stability on this surface).</p>

<p>The sliding-mode designer picks a <em>switching function</em> 

<math display="inline" id="Sliding_mode_control:27">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ℝ</mi>
     <mi>n</mi>
    </msup>
    <mo>↦</mo>
    <msup>
     <mi>ℝ</mi>
     <mi>m</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>σ</ci>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma:\mathbb{R}^{n}\mapsto\mathbb{R}^{m}
  </annotation>
 </semantics>
</math>

 that represents a kind of "distance" that the states 

<math display="inline" id="Sliding_mode_control:28">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>


 are away from a sliding surface.</p>
<ul>
<li>A state 

<math display="inline" id="Sliding_mode_control:29">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 that is outside of this sliding surface has 

<math display="inline" id="Sliding_mode_control:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})\neq 0
  </annotation>
 </semantics>
</math>

.</li>
<li>A state that is on this sliding surface has 

<math display="inline" id="Sliding_mode_control:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})=0
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>The sliding-mode-control law switches from one state to another based on the <em>sign</em> of this distance. So the sliding-mode control acts like a stiff pressure always pushing in the direction of the sliding mode where 

<math display="inline" id="Sliding_mode_control:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})=0
  </annotation>
 </semantics>
</math>

. Desirable 

<math display="inline" id="Sliding_mode_control:33">
 <semantics>
  <mrow>
   <mi>𝐱</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐱</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}(t)
  </annotation>
 </semantics>
</math>


 trajectories will approach the sliding surface, and because the control law is not <a href="continuous_function" title="wikilink">continuous</a> (i.e., it switches from one state to another as trajectories move across this surface), the surface is reached in finite time. Once a trajectory reaches the surface, it will slide along it and may, for example, move toward the 

<math display="inline" id="Sliding_mode_control:34">
 <semantics>
  <mrow>
   <mi>𝐱</mi>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐱</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}=\mathbf{0}
  </annotation>
 </semantics>
</math>

 origin. So the switching function is like a <a href="topographic_map" title="wikilink">topographic map</a> with a contour of constant height along which trajectories are forced to move.</p>

<p>The sliding (hyper)surface is of dimension 

<math display="inline" id="Sliding_mode_control:35">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times m
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Sliding_mode_control:36">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the number of states in 

<math display="inline" id="Sliding_mode_control:37">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sliding_mode_control:38">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>


 is the number of input signals (i.e., control signals) in 

<math display="inline" id="Sliding_mode_control:39">
 <semantics>
  <mi>𝐮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}
  </annotation>
 </semantics>
</math>

. For each control index 

<math display="inline" id="Sliding_mode_control:40">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>k</mi>
   <mo>≤</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>k</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq k\leq m
  </annotation>
 </semantics>
</math>

, there is an 

<math display="inline" id="Sliding_mode_control:41">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>×</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times 1
  </annotation>
 </semantics>
</math>

 sliding surface given by</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="block" id="Sliding_mode_control:42">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mrow>
    <mi>𝐱</mi>
    <mo>∈</mo>
    <msup>
     <mi>ℝ</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>σ</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐱</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <in></in>
     <ci>𝐱</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>k</ci>
      </apply>
      <ci>𝐱</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{\mathbf{x}\in\mathbb{R}^{n}:\sigma_{k}(\mathbf{x})=0\right\}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sliding_mode_control:43">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>2</mn>
   <mo rspace="4.2pt" stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">2</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (2)\,
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>The vital part of SMC design is to choose a control law so that the sliding mode (i.e., this surface given by 

<math display="inline" id="Sliding_mode_control:44">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})=\mathbf{0}
  </annotation>
 </semantics>
</math>

) exists and is reachable along system trajectories. The principle of sliding mode control is to forcibly constrain the system, by suitable control strategy, to stay on the sliding surface on which the system will exhibit desirable features. When the system is constrained by the sliding control to stay on the sliding surface, the system dynamics are governed by reduced-order system obtained from Equation (2).</p>

<p>To force the system states 

<math display="inline" id="Sliding_mode_control:45">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 to satisfy 

<math display="inline" id="Sliding_mode_control:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})=\mathbf{0}
  </annotation>
 </semantics>
</math>

, one must:</p>
<ol>
<li>Ensure that the system is capable of reaching 

<math display="inline" id="Sliding_mode_control:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})=\mathbf{0}
  </annotation>
 </semantics>
</math>

 from any initial condition</li>
<li>Having reached 

<math display="inline" id="Sliding_mode_control:48">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})=\mathbf{0}
  </annotation>
 </semantics>
</math>

, the control action is capable of maintaining the system at 

<math display="inline" id="Sliding_mode_control:49">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})=\mathbf{0}
  </annotation>
 </semantics>
</math>

</li>
</ol>
<h3 id="existence-of-closed-loop-solutions">Existence of closed-loop solutions</h3>

<p>Note that because the control law is not <a href="continuous_function" title="wikilink">continuous</a>, it is certainly not locally <a href="Lipschitz_continuous" title="wikilink">Lipschitz continuous</a>, and so existence and uniqueness of solutions to the <a href="Closed-loop_transfer_function" title="wikilink">closed-loop system</a> is <em>not</em> guaranteed by the <a href="Picard–Lindelöf_theorem" title="wikilink">Picard–Lindelöf theorem</a>. Thus the solutions are to be understood in the <a href="Aleksei_Fedorovich_Filippov" title="wikilink">Filippov</a> sense.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Roughly speaking, the resulting closed-loop system moving along 

<math display="inline" id="Sliding_mode_control:50">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})=\mathbf{0}
  </annotation>
 </semantics>
</math>

 is approximated by the smooth <a href="dynamic_system" title="wikilink">dynamics</a> 

<math display="inline" id="Sliding_mode_control:51">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>σ</mi>
     <mo>˙</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-˙</ci>
      <ci>σ</ci>
     </apply>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\sigma}(\mathbf{x})=\mathbf{0}
  </annotation>
 </semantics>
</math>

; however, this smooth behavior may not be truly realizable. Similarly, high-speed <a href="pulse-width_modulation" title="wikilink">pulse-width modulation</a> or <a href="delta-sigma_modulation" title="wikilink">delta-sigma modulation</a> produces outputs that only assume two states, but the effective output swings through a continuous range of motion. These complications can be avoided by using a different <a href="nonlinear_control" title="wikilink">nonlinear control</a> design method that produces a continuous controller. In some cases, sliding-mode control designs can be approximated by other continuous control designs.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="theoretical-foundation">Theoretical foundation</h2>

<p>The following theorems form the foundation of variable structure control.</p>
<h3 id="theorem-1-existence-of-sliding-mode">Theorem 1: Existence of Sliding Mode</h3>

<p>Consider a <a href="Lyapunov_function" title="wikilink">Lyapunov function</a> candidate</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="block" id="Sliding_mode_control:52">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>𝐱</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <msup>
     <mi>σ</mi>
     <mtext>T</mtext>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <msubsup>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mi>σ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>𝐱</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
     <mn>2</mn>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>V</ci>
      <apply>
       <times></times>
       <ci>σ</ci>
       <ci>𝐱</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>σ</ci>
       <mtext>T</mtext>
      </apply>
      <ci>𝐱</ci>
      <ci>σ</ci>
      <ci>𝐱</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <times></times>
          <ci>σ</ci>
          <ci>𝐱</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(\sigma(\mathbf{x}))=\frac{1}{2}\sigma^{\text{T}}(\mathbf{x})\sigma(\mathbf{x%
})=\frac{1}{2}\|\sigma(\mathbf{x})\|_{2}^{2}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sliding_mode_control:53">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>3</mn>
   <mo rspace="4.2pt" stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">3</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (3)\,
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>where 

<math display="inline" id="Sliding_mode_control:54">
 <semantics>
  <mrow>
   <mo>∥</mo>
   <mi mathvariant="normal">⋅</mi>
   <mo>∥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">norm</csymbol>
    <ci>normal-⋅</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\mathord{\cdot}\|
  </annotation>
 </semantics>
</math>

 is the <a href="Euclidean_norm" title="wikilink">Euclidean norm</a> (i.e., 

<math display="inline" id="Sliding_mode_control:55">
 <semantics>
  <msub>
   <mrow>
    <mo>∥</mo>
    <mrow>
     <mi>σ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐱</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∥</mo>
   </mrow>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <times></times>
      <ci>σ</ci>
      <ci>𝐱</ci>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\sigma(\mathbf{x})\|_{2}
  </annotation>
 </semantics>
</math>

 is the distance away from the sliding manifold where 

<math display="inline" id="Sliding_mode_control:56">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})=\mathbf{0}
  </annotation>
 </semantics>
</math>

). For the system given by Equation (1) and the sliding surface given by Equation (2), a sufficient condition for the existence of a sliding mode is that</p>

<p>

<math display="block" id="Sliding_mode_control:57">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <munder accentunder="true">
      <mrow>
       <mover>
        <mover accent="true">
         <msup>
          <mi>σ</mi>
          <mtext>T</mtext>
         </msup>
         <mo movablelimits="false">⏞</mo>
        </mover>
        <mstyle scriptlevel="-1">
         <mfrac>
          <mrow>
           <mo movablelimits="false">∂</mo>
           <mi>V</mi>
          </mrow>
          <mrow>
           <mo movablelimits="false">∂</mo>
           <mi>σ</mi>
          </mrow>
         </mfrac>
        </mstyle>
       </mover>
       <mover>
        <mover accent="true">
         <mover accent="true">
          <mi>σ</mi>
          <mo movablelimits="false">˙</mo>
         </mover>
         <mo movablelimits="false">⏞</mo>
        </mover>
        <mstyle scriptlevel="-1">
         <mfrac>
          <mrow>
           <mo movablelimits="false">d</mo>
           <mi>σ</mi>
          </mrow>
          <mrow>
           <mo movablelimits="false">d</mo>
           <mi>t</mi>
          </mrow>
         </mfrac>
        </mstyle>
       </mover>
      </mrow>
      <mo movablelimits="false">⏟</mo>
     </munder>
     <mstyle scriptlevel="-1">
      <mfrac>
       <mrow>
        <mo>d</mo>
        <mi>V</mi>
       </mrow>
       <mrow>
        <mo>d</mo>
        <mi>t</mi>
       </mrow>
      </mfrac>
     </mstyle>
    </munder>
    <mo><</mo>
    <mn>0</mn>
   </mrow>
   <mrow>
    <mrow>
     <mtext>(i.e.,</mtext>
     <mstyle displaystyle="false">
      <mfrac>
       <mrow>
        <mo>d</mo>
        <mi>V</mi>
       </mrow>
       <mrow>
        <mo>d</mo>
        <mi>t</mi>
       </mrow>
      </mfrac>
     </mstyle>
    </mrow>
    <mo><</mo>
    <mrow>
     <mn>0</mn>
     <mtext>)</mtext>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <lt></lt>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-⏟</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <ci>normal-⏞</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>σ</ci>
           <mtext>T</mtext>
          </apply>
         </apply>
         <apply>
          <divide></divide>
          <apply>
           <partialdiff></partialdiff>
           <ci>V</ci>
          </apply>
          <apply>
           <partialdiff></partialdiff>
           <ci>σ</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <ci>normal-⏞</ci>
          <apply>
           <ci>normal-˙</ci>
           <ci>σ</ci>
          </apply>
         </apply>
         <apply>
          <divide></divide>
          <apply>
           <ci>normal-d</ci>
           <ci>σ</ci>
          </apply>
          <apply>
           <ci>normal-d</ci>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <ci>normal-d</ci>
        <ci>V</ci>
       </apply>
       <apply>
        <ci>normal-d</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <lt></lt>
     <apply>
      <times></times>
      <mtext>(i.e.,</mtext>
      <apply>
       <divide></divide>
       <apply>
        <ci>normal-d</ci>
        <ci>V</ci>
       </apply>
       <apply>
        <ci>normal-d</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">0</cn>
      <mtext>)</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underbrace{\overbrace{\sigma^{\text{T}}}^{\tfrac{\partial V}{\partial\sigma}}%
\overbrace{\dot{\sigma}}^{\tfrac{\operatorname{d}\sigma}{\operatorname{d}t}}}_%
{\tfrac{\operatorname{d}V}{\operatorname{d}t}}<0\qquad\text{(i.e., }\tfrac{%
\operatorname{d}V}{\operatorname{d}t}<0\text{)}
  </annotation>
 </semantics>
</math>

 in a <a href="Neighbourhood_(mathematics)" title="wikilink">neighborhood</a> of the surface given by 

<math display="inline" id="Sliding_mode_control:58">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})=0
  </annotation>
 </semantics>
</math>

.</p>

<p>Roughly speaking (i.e., for the <a href="scalar_(mathematics)" title="wikilink">scalar</a> control case when 

<math display="inline" id="Sliding_mode_control:59">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=1
  </annotation>
 </semantics>
</math>

), to achieve 

<math display="inline" id="Sliding_mode_control:60">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>σ</mi>
     <mtext>T</mtext>
    </msup>
    <mover accent="true">
     <mi>σ</mi>
     <mo>˙</mo>
    </mover>
   </mrow>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>σ</ci>
      <mtext>T</mtext>
     </apply>
     <apply>
      <ci>normal-˙</ci>
      <ci>σ</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{\text{T}}\dot{\sigma}<0
  </annotation>
 </semantics>
</math>

, the feedback control law 

<math display="inline" id="Sliding_mode_control:61">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(\mathbf{x})
  </annotation>
 </semantics>
</math>

 is picked so that 

<math display="inline" id="Sliding_mode_control:62">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sliding_mode_control:63">
 <semantics>
  <mover accent="true">
   <mi>σ</mi>
   <mo>˙</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-˙</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\sigma}
  </annotation>
 </semantics>
</math>

 have opposite signs. That is,</p>
<ul>
<li>

<math display="inline" id="Sliding_mode_control:64">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(\mathbf{x})
  </annotation>
 </semantics>
</math>

 makes 

<math display="inline" id="Sliding_mode_control:65">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>σ</mi>
    <mo>˙</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-˙</ci>
     <ci>σ</ci>
    </apply>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\sigma}(\mathbf{x})
  </annotation>
 </semantics>
</math>

 negative when 

<math display="inline" id="Sliding_mode_control:66">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>σ</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})
  </annotation>
 </semantics>
</math>

 is positive.</li>
<li>

<math display="inline" id="Sliding_mode_control:67">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(\mathbf{x})
  </annotation>
 </semantics>
</math>

 makes 

<math display="inline" id="Sliding_mode_control:68">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>σ</mi>
    <mo>˙</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-˙</ci>
     <ci>σ</ci>
    </apply>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\sigma}(\mathbf{x})
  </annotation>
 </semantics>
</math>

 positive when 

<math display="inline" id="Sliding_mode_control:69">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>σ</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})
  </annotation>
 </semantics>
</math>

 is negative.</li>
</ul>

<p>Note that</p>

<p>

<math display="block" id="Sliding_mode_control:70">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>σ</mi>
    <mo>˙</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mo>∂</mo>
      <mi>σ</mi>
     </mrow>
     <mrow>
      <mo>∂</mo>
      <mi>𝐱</mi>
     </mrow>
    </mfrac>
    <mover>
     <mover accent="true">
      <mover accent="true">
       <mi>𝐱</mi>
       <mo movablelimits="false">˙</mo>
      </mover>
      <mo movablelimits="false">⏞</mo>
     </mover>
     <mstyle scriptlevel="-1">
      <mfrac>
       <mrow>
        <mo>d</mo>
        <mi>𝐱</mi>
       </mrow>
       <mrow>
        <mo>d</mo>
        <mi>t</mi>
       </mrow>
      </mfrac>
     </mstyle>
    </mover>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mo>∂</mo>
      <mi>σ</mi>
     </mrow>
     <mrow>
      <mo>∂</mo>
      <mi>𝐱</mi>
     </mrow>
    </mfrac>
    <mover>
     <mover accent="true">
      <mrow>
       <mo movablelimits="false">(</mo>
       <mrow>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo movablelimits="false" stretchy="false">(</mo>
          <mi>𝐱</mi>
          <mo movablelimits="false">,</mo>
          <mi>t</mi>
          <mo movablelimits="false" stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo movablelimits="false">+</mo>
        <mrow>
         <mi>B</mi>
         <mrow>
          <mo movablelimits="false" stretchy="false">(</mo>
          <mi>𝐱</mi>
          <mo movablelimits="false">,</mo>
          <mi>t</mi>
          <mo movablelimits="false" stretchy="false">)</mo>
         </mrow>
         <mi>𝐮</mi>
        </mrow>
       </mrow>
       <mo movablelimits="false">)</mo>
      </mrow>
      <mo movablelimits="false">⏞</mo>
     </mover>
     <mover accent="true">
      <mi>𝐱</mi>
      <mo>˙</mo>
     </mover>
    </mover>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-˙</ci>
      <ci>σ</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>σ</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>𝐱</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-⏞</ci>
        <apply>
         <ci>normal-˙</ci>
         <ci>𝐱</ci>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <ci>normal-d</ci>
         <ci>𝐱</ci>
        </apply>
        <apply>
         <ci>normal-d</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>σ</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>𝐱</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-⏞</ci>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <ci>f</ci>
          <interval closure="open">
           <ci>𝐱</ci>
           <ci>t</ci>
          </interval>
         </apply>
         <apply>
          <times></times>
          <ci>B</ci>
          <interval closure="open">
           <ci>𝐱</ci>
           <ci>t</ci>
          </interval>
          <ci>𝐮</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <ci>normal-˙</ci>
        <ci>𝐱</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\sigma}=\frac{\partial\sigma}{\partial\mathbf{x}}\overbrace{\dot{\mathbf{%
x}}}^{\tfrac{\operatorname{d}\mathbf{x}}{\operatorname{d}t}}=\frac{\partial%
\sigma}{\partial\mathbf{x}}\overbrace{\left(f(\mathbf{x},t)+B(\mathbf{x},t)%
\mathbf{u}\right)}^{\dot{\mathbf{x}}}
  </annotation>
 </semantics>
</math>

 and so the feedback control law 

<math display="inline" id="Sliding_mode_control:71">
 <semantics>
  <mrow>
   <mi>𝐮</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐮</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}(\mathbf{x})
  </annotation>
 </semantics>
</math>

 has a direct impact on 

<math display="inline" id="Sliding_mode_control:72">
 <semantics>
  <mover accent="true">
   <mi>σ</mi>
   <mo>˙</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-˙</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\sigma}
  </annotation>
 </semantics>
</math>


.</p>
<h4 id="reachability-attaining-sliding-manifold-in-finite-time">Reachability: Attaining sliding manifold in finite time</h4>

<p>To ensure that the sliding mode 

<math display="inline" id="Sliding_mode_control:73">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})=\mathbf{0}
  </annotation>
 </semantics>
</math>

 is attained in finite time, 

<math display="inline" id="Sliding_mode_control:74">
 <semantics>
  <mrow>
   <mrow>
    <mo>d</mo>
    <mi>V</mi>
   </mrow>
   <mo>/</mo>
   <mrow>
    <mo>d</mo>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <ci>normal-d</ci>
     <ci>V</ci>
    </apply>
    <apply>
     <ci>normal-d</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{d}V/{\operatorname{d}t}
  </annotation>
 </semantics>
</math>

 must be more strongly bounded away from zero. That is, if it vanishes too quickly, the attraction to the sliding mode will only be asymptotic. To ensure that the sliding mode is entered in finite time,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>

<math display="block" id="Sliding_mode_control:75">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>d</mo>
     <mi>V</mi>
    </mrow>
    <mrow>
     <mo>d</mo>
     <mi>t</mi>
    </mrow>
   </mfrac>
   <mo>≤</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>μ</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msqrt>
        <mi>V</mi>
       </msqrt>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>α</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <divide></divide>
     <apply>
      <ci>normal-d</ci>
      <ci>V</ci>
     </apply>
     <apply>
      <ci>normal-d</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>μ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <root></root>
        <ci>V</ci>
       </apply>
       <ci>α</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\operatorname{d}V}{\operatorname{d}t}\leq-\mu(\sqrt{V})^{\alpha}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Sliding_mode_control:76">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>μ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu>0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sliding_mode_control:77">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo><</mo>
   <mi>α</mi>
   <mo>≤</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <ci>α</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<\alpha\leq 1
  </annotation>
 </semantics>
</math>


 are constants.</p>
<dl>
<dt>Explanation by comparison lemma</dt>
</dl>

<p>This condition ensures that for the neighborhood of the sliding mode 

<math display="inline" id="Sliding_mode_control:78">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>V</ci>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\in[0,1]
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Sliding_mode_control:79">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <mo>d</mo>
      <mi>V</mi>
     </mrow>
     <mrow>
      <mo>d</mo>
      <mi>t</mi>
     </mrow>
    </mfrac>
    <mo>≤</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>μ</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msqrt>
         <mi>V</mi>
        </msqrt>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>α</mi>
      </msup>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>μ</mi>
      <msqrt>
       <mi>V</mi>
      </msqrt>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <divide></divide>
      <apply>
       <ci>normal-d</ci>
       <ci>V</ci>
      </apply>
      <apply>
       <ci>normal-d</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>μ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <root></root>
         <ci>V</ci>
        </apply>
        <ci>α</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>μ</ci>
       <apply>
        <root></root>
        <ci>V</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\operatorname{d}V}{\operatorname{d}t}\leq-\mu(\sqrt{V})^{\alpha}\leq-\mu%
\sqrt{V}.
  </annotation>
 </semantics>
</math>

 So, for 

<math display="inline" id="Sliding_mode_control:80">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>V</ci>
    <interval closure="open-closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\in(0,1]
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Sliding_mode_control:81">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msqrt>
       <mi>V</mi>
      </msqrt>
     </mfrac>
     <mfrac>
      <mrow>
       <mo>d</mo>
       <mi>V</mi>
      </mrow>
      <mrow>
       <mo>d</mo>
       <mi>t</mi>
      </mrow>
     </mfrac>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mo>-</mo>
     <mi>μ</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <ci>V</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <ci>normal-d</ci>
       <ci>V</ci>
      </apply>
      <apply>
       <ci>normal-d</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <ci>μ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{\sqrt{V}}\frac{\operatorname{d}V}{\operatorname{d}t}\leq-\mu,
  </annotation>
 </semantics>
</math>

 which, by the <a href="chain_rule" title="wikilink">chain rule</a> (i.e., 

<math display="inline" id="Sliding_mode_control:82">
 <semantics>
  <mrow>
   <mrow>
    <mo>d</mo>
    <mi>W</mi>
   </mrow>
   <mo>/</mo>
   <mrow>
    <mo>d</mo>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <ci>normal-d</ci>
     <ci>W</ci>
    </apply>
    <apply>
     <ci>normal-d</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{d}W/{\operatorname{d}t}
  </annotation>
 </semantics>
</math>


 with 

<math display="inline" id="Sliding_mode_control:83">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mo>≜</mo>
   <mrow>
    <mn>2</mn>
    <msqrt>
     <mi>V</mi>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-≜</ci>
    <ci>W</ci>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <root></root>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W\triangleq 2\sqrt{V}
  </annotation>
 </semantics>
</math>

), means</p>

<p>

<math display="block" id="Sliding_mode_control:84">
 <semantics>
  <mrow>
   <munder>
    <munder accentunder="true">
     <mrow>
      <msup>
       <mi>D</mi>
       <mo movablelimits="false">+</mo>
      </msup>
      <mrow>
       <mo maxsize="160%" minsize="160%" movablelimits="false">(</mo>
       <munder>
        <munder accentunder="true">
         <mrow>
          <mn>2</mn>
          <mover>
           <mover accent="true">
            <msqrt>
             <mi>V</mi>
            </msqrt>
            <mo movablelimits="false">⏞</mo>
           </mover>
           <mrow>
            <mi></mi>
            <mo movablelimits="false">∝</mo>
            <msub>
             <mrow>
              <mo movablelimits="false">∥</mo>
              <mi>σ</mi>
              <mo movablelimits="false">∥</mo>
             </mrow>
             <mn>2</mn>
            </msub>
           </mrow>
          </mover>
         </mrow>
         <mo movablelimits="false">⏟</mo>
        </munder>
        <mi>W</mi>
       </munder>
       <mo maxsize="160%" minsize="160%" movablelimits="false">)</mo>
      </mrow>
     </mrow>
     <mo movablelimits="false">⏟</mo>
    </munder>
    <mrow>
     <mrow>
      <msup>
       <mi>D</mi>
       <mo>+</mo>
      </msup>
      <mpadded width="+1.7pt">
       <mi>W</mi>
      </mpadded>
     </mrow>
     <mo rspace="4.2pt">≜</mo>
     <mrow>
      <mtext>Upper right-hand</mtext>
      <mover accent="true">
       <mi>W</mi>
       <mo>˙</mo>
      </mover>
     </mrow>
    </mrow>
   </munder>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mi>V</mi>
     </msqrt>
    </mfrac>
    <mfrac>
     <mrow>
      <mo>d</mo>
      <mi>V</mi>
     </mrow>
     <mrow>
      <mo>d</mo>
      <mi>t</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mo>-</mo>
    <mi>μ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>
      <munder>
       <munder accentunder="true">
        <mrow>
         <msup>
          <mi>D</mi>
          <mo movablelimits="false">+</mo>
         </msup>
         <mrow>
          <mo maxsize="160%" minsize="160%" movablelimits="false">(</mo>
          <munder>
           <munder accentunder="true">
            <mrow>
             <mn>2</mn>
             <mover>
              <mover accent="true">
               <msqrt>
                <mi>V</mi>
               </msqrt>
               <mo movablelimits="false">⏞</mo>
              </mover>
              <mrow>
               <mi></mi>
               <mo movablelimits="false">∝</mo>
               <msub>
                <mrow>
                 <mo movablelimits="false">∥</mo>
                 <mi>σ</mi>
                 <mo movablelimits="false">∥</mo>
                </mrow>
                <mn>2</mn>
               </msub>
              </mrow>
             </mover>
            </mrow>
            <mo movablelimits="false">⏟</mo>
           </munder>
           <mi>W</mi>
          </munder>
          <mo maxsize="160%" minsize="160%" movablelimits="false">)</mo>
         </mrow>
        </mrow>
        <mo movablelimits="false">⏟</mo>
       </munder>
       <mrow>
        <mrow>
         <msup>
          <mi>D</mi>
          <mo>+</mo>
         </msup>
         <mpadded width="+1.7pt">
          <mi>W</mi>
         </mpadded>
        </mrow>
        <mo rspace="4.2pt">≜</mo>
        <mrow>
         <mtext>Upper right-hand</mtext>
         <mover accent="true">
          <mi>W</mi>
          <mo>˙</mo>
         </mover>
        </mrow>
       </mrow>
      </munder>
     </ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <root></root>
        <ci>V</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <ci>normal-d</ci>
        <ci>V</ci>
       </apply>
       <apply>
        <ci>normal-d</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <ci>μ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathord{\underbrace{D^{+}\Bigl(\mathord{\underbrace{2\mathord{\overbrace{%
\sqrt{V}}^{{}\propto\|\sigma\|_{2}}}}_{W}}\Bigr)}_{D^{+}W\,\triangleq\,%
\mathord{\text{Upper right-hand }\dot{W}}}}=\frac{1}{\sqrt{V}}\frac{%
\operatorname{d}V}{\operatorname{d}t}\leq-\mu
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Sliding_mode_control:85">
 <semantics>
  <msup>
   <mi>D</mi>
   <mo>+</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>D</ci>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D^{+}
  </annotation>
 </semantics>
</math>

 is the <a href="upper_right-hand_derivative" title="wikilink">upper right-hand derivative</a> of 

<math display="inline" id="Sliding_mode_control:86">
 <semantics>
  <mrow>
   <mn>2</mn>
   <msqrt>
    <mi>V</mi>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <apply>
     <root></root>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\sqrt{V}
  </annotation>
 </semantics>
</math>

 and the symbol 

<math display="inline" id="Sliding_mode_control:87">
 <semantics>
  <mo>∝</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">proportional-to</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \propto
  </annotation>
 </semantics>
</math>


 denotes <a href="proportionality_(mathematics)" title="wikilink">proportionality</a>. So, by comparison to the curve 

<math display="inline" id="Sliding_mode_control:88">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>z</mi>
     <mn>0</mn>
    </msub>
    <mo>-</mo>
    <mrow>
     <mi>μ</mi>
     <mi>t</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>z</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>μ</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z(t)=z_{0}-\mu t
  </annotation>
 </semantics>
</math>

 which is represented by differential equation 

<math display="inline" id="Sliding_mode_control:89">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>z</mi>
    <mo>˙</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mi>μ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-˙</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>μ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{z}=-\mu
  </annotation>
 </semantics>
</math>

 with initial condition 

<math display="inline" id="Sliding_mode_control:90">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>z</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>z</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z(0)=z_{0}
  </annotation>
 </semantics>
</math>

, it must be the case that 

<math display="inline" id="Sliding_mode_control:91">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <msqrt>
     <mrow>
      <mi>V</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msqrt>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <msub>
     <mi>V</mi>
     <mn>0</mn>
    </msub>
    <mo>-</mo>
    <mrow>
     <mi>μ</mi>
     <mi>t</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <root></root>
      <apply>
       <times></times>
       <ci>V</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>μ</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\sqrt{V(t)}\leq V_{0}-\mu t
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Sliding_mode_control:92">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>


. Moreover, because 

<math display="inline" id="Sliding_mode_control:93">
 <semantics>
  <mrow>
   <msqrt>
    <mi>V</mi>
   </msqrt>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <root></root>
     <ci>V</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{V}\geq 0
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Sliding_mode_control:94">
 <semantics>
  <msqrt>
   <mi>V</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{V}
  </annotation>
 </semantics>
</math>

 must reach 

<math display="inline" id="Sliding_mode_control:95">
 <semantics>
  <mrow>
   <msqrt>
    <mi>V</mi>
   </msqrt>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <root></root>
     <ci>V</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{V}=0
  </annotation>
 </semantics>
</math>

 in finite time, which means that 

<math display="inline" id="Sliding_mode_control:96">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 must reach 

<math display="inline" id="Sliding_mode_control:97">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>V</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V=0
  </annotation>
 </semantics>
</math>


 (i.e., the system enters the sliding mode) in finite time.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Because 

<math display="inline" id="Sliding_mode_control:98">
 <semantics>
  <msqrt>
   <mi>V</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{V}
  </annotation>
 </semantics>
</math>

 is proportional to the <a href="Euclidean_norm" title="wikilink">Euclidean norm</a> 

<math display="inline" id="Sliding_mode_control:99">
 <semantics>
  <msub>
   <mrow>
    <mo>∥</mo>
    <mi mathvariant="normal">⋅</mi>
    <mo>∥</mo>
   </mrow>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <ci>normal-⋅</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\mathord{\cdot}\|_{2}
  </annotation>
 </semantics>
</math>

 of the switching function 

<math display="inline" id="Sliding_mode_control:100">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

, this result implies that the rate of approach to the sliding mode must be firmly bounded away from zero.</p>
<dl>
<dt>Consequences for sliding mode control</dt>
</dl>

<p>In the context of sliding mode control, this condition means that</p>

<p>

<math display="block" id="Sliding_mode_control:101">
 <semantics>
  <mrow>
   <munder>
    <munder accentunder="true">
     <mrow>
      <mover>
       <mover accent="true">
        <msup>
         <mi>σ</mi>
         <mtext>T</mtext>
        </msup>
        <mo movablelimits="false">⏞</mo>
       </mover>
       <mstyle scriptlevel="-1">
        <mfrac>
         <mrow>
          <mo movablelimits="false">∂</mo>
          <mi>V</mi>
         </mrow>
         <mrow>
          <mo movablelimits="false">∂</mo>
          <mi>σ</mi>
         </mrow>
        </mfrac>
       </mstyle>
      </mover>
      <mover>
       <mover accent="true">
        <mover accent="true">
         <mi>σ</mi>
         <mo movablelimits="false">˙</mo>
        </mover>
        <mo movablelimits="false">⏞</mo>
       </mover>
       <mstyle scriptlevel="-1">
        <mfrac>
         <mrow>
          <mo movablelimits="false">d</mo>
          <mi>σ</mi>
         </mrow>
         <mrow>
          <mo movablelimits="false">d</mo>
          <mi>t</mi>
         </mrow>
        </mfrac>
       </mstyle>
      </mover>
     </mrow>
     <mo movablelimits="false">⏟</mo>
    </munder>
    <mstyle scriptlevel="-1">
     <mfrac>
      <mrow>
       <mo>d</mo>
       <mi>V</mi>
      </mrow>
      <mrow>
       <mo>d</mo>
       <mi>t</mi>
      </mrow>
     </mfrac>
    </mstyle>
   </munder>
   <mo>≤</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>μ</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mover>
        <mover accent="true">
         <msub>
          <mrow>
           <mo movablelimits="false">∥</mo>
           <mi>σ</mi>
           <mo movablelimits="false">∥</mo>
          </mrow>
          <mn>2</mn>
         </msub>
         <mo movablelimits="false">⏞</mo>
        </mover>
        <msqrt>
         <mi>V</mi>
        </msqrt>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>α</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-⏟</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <ci>normal-⏞</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>σ</ci>
          <mtext>T</mtext>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <partialdiff></partialdiff>
          <ci>V</ci>
         </apply>
         <apply>
          <partialdiff></partialdiff>
          <ci>σ</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <ci>normal-⏞</ci>
         <apply>
          <ci>normal-˙</ci>
          <ci>σ</ci>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <ci>normal-d</ci>
          <ci>σ</ci>
         </apply>
         <apply>
          <ci>normal-d</ci>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <ci>normal-d</ci>
       <ci>V</ci>
      </apply>
      <apply>
       <ci>normal-d</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>μ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>
        <mover>
         <mover accent="true">
          <msub>
           <mrow>
            <mo movablelimits="false">∥</mo>
            <mi>σ</mi>
            <mo movablelimits="false">∥</mo>
           </mrow>
           <mn>2</mn>
          </msub>
          <mo movablelimits="false">⏞</mo>
         </mover>
         <msqrt>
          <mi>V</mi>
         </msqrt>
        </mover>
       </ci>
       <ci>α</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underbrace{\overbrace{\sigma^{\text{T}}}^{\tfrac{\partial V}{\partial\sigma}}%
\overbrace{\dot{\sigma}}^{\tfrac{\operatorname{d}\sigma}{\operatorname{d}t}}}_%
{\tfrac{\operatorname{d}V}{\operatorname{d}t}}\leq-\mu(\mathord{\overbrace{\|%
\sigma\|_{2}}^{\sqrt{V}}})^{\alpha}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Sliding_mode_control:102">
 <semantics>
  <mrow>
   <mo>∥</mo>
   <mi mathvariant="normal">⋅</mi>
   <mo>∥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">norm</csymbol>
    <ci>normal-⋅</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\mathord{\cdot}\|
  </annotation>
 </semantics>
</math>


 is the <a href="Euclidean_norm" title="wikilink">Euclidean norm</a>. For the case when switching function 

<math display="inline" id="Sliding_mode_control:103">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 is scalar valued, the sufficient condition becomes</p>

<p>

<math display="block" id="Sliding_mode_control:104">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mover accent="true">
     <mi>σ</mi>
     <mo>˙</mo>
    </mover>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>μ</mi>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>σ</mi>
       <mo stretchy="false">|</mo>
      </mrow>
      <mi>α</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <apply>
      <ci>normal-˙</ci>
      <ci>σ</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>μ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <ci>σ</ci>
       </apply>
       <ci>α</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\dot{\sigma}\leq-\mu|\sigma|^{\alpha}
  </annotation>
 </semantics>
</math>

. Taking 

<math display="inline" id="Sliding_mode_control:105">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>α</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=1
  </annotation>
 </semantics>
</math>

, the scalar sufficient condition becomes</p>

<p>

<math display="block" id="Sliding_mode_control:106">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>sgn</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>σ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mover accent="true">
     <mi>σ</mi>
     <mo>˙</mo>
    </mover>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mo>-</mo>
    <mi>μ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <ci>sgn</ci>
      <ci>σ</ci>
     </apply>
     <apply>
      <ci>normal-˙</ci>
      <ci>σ</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <ci>μ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sgn}(\sigma)\dot{\sigma}\leq-\mu
  </annotation>
 </semantics>
</math>

 which is equivalent to the condition that</p>

<p>

<math display="block" id="Sliding_mode_control:107">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>sgn</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>σ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≠</mo>
    <mrow>
     <mrow>
      <mo>sgn</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mover accent="true">
        <mi>σ</mi>
        <mo>˙</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mtext>and</mtext>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mover accent="true">
      <mi>σ</mi>
      <mo>˙</mo>
     </mover>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>≥</mo>
    <mi>μ</mi>
    <mo>></mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <neq></neq>
     <apply>
      <ci>sgn</ci>
      <ci>σ</ci>
     </apply>
     <list>
      <apply>
       <ci>sgn</ci>
       <apply>
        <ci>normal-˙</ci>
        <ci>σ</ci>
       </apply>
      </apply>
      <mtext>and</mtext>
     </list>
    </apply>
    <apply>
     <and></and>
     <apply>
      <geq></geq>
      <apply>
       <abs></abs>
       <apply>
        <ci>normal-˙</ci>
        <ci>σ</ci>
       </apply>
      </apply>
      <ci>μ</ci>
     </apply>
     <apply>
      <gt></gt>
      <share href="#.cmml">
      </share>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sgn}(\sigma)\neq\operatorname{sgn}(\dot{\sigma})\qquad\text{and}%
\qquad|\dot{\sigma}|\geq\mu>0
  </annotation>
 </semantics>
</math>

. That is, the system should always be moving toward the switching surface 

<math display="inline" id="Sliding_mode_control:108">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>σ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma=0
  </annotation>
 </semantics>
</math>

, and its speed 

<math display="inline" id="Sliding_mode_control:109">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mover accent="true">
    <mi>σ</mi>
    <mo>˙</mo>
   </mover>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <ci>normal-˙</ci>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\dot{\sigma}|
  </annotation>
 </semantics>
</math>

 toward the switching surface should have a non-zero lower bound. So, even though 

<math display="inline" id="Sliding_mode_control:110">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 may become vanishingly small as 

<math display="inline" id="Sliding_mode_control:111">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 approaches the 

<math display="inline" id="Sliding_mode_control:112">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})=\mathbf{0}
  </annotation>
 </semantics>
</math>

 surface, 

<math display="inline" id="Sliding_mode_control:113">
 <semantics>
  <mover accent="true">
   <mi>σ</mi>
   <mo>˙</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-˙</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\sigma}
  </annotation>
 </semantics>
</math>

 must always be bounded firmly away from zero. To ensure this condition, sliding mode controllers are discontinuous across the 

<math display="inline" id="Sliding_mode_control:114">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>σ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma=0
  </annotation>
 </semantics>
</math>

 manifold; they <em>switch</em> from one non-zero value to another as trajectories cross the manifold.</p>
<h3 id="theorem-2-region-of-attraction">Theorem 2: Region of Attraction</h3>

<p>For the system given by Equation (1) and sliding surface given by Equation (2), the subspace for which the 

<math display="inline" id="Sliding_mode_control:115">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>𝐱</mi>
    <mo>∈</mo>
    <msup>
     <mi>ℝ</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>σ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐱</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>𝟎</mn>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <in></in>
     <ci>𝐱</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>σ</ci>
      <ci>𝐱</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\mathbf{x}\in\mathbb{R}^{n}:\sigma(\mathbf{x})=\mathbf{0}\}
  </annotation>
 </semantics>
</math>

 surface is reachable is given by</p>

<p>

<math display="block" id="Sliding_mode_control:116">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>𝐱</mi>
    <mo>∈</mo>
    <msup>
     <mi>ℝ</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>σ</mi>
      <mtext>T</mtext>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐱</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mover accent="true">
      <mi>σ</mi>
      <mo>˙</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐱</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo><</mo>
    <mn>0</mn>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <in></in>
     <ci>𝐱</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>σ</ci>
       <mtext>T</mtext>
      </apply>
      <ci>𝐱</ci>
      <apply>
       <ci>normal-˙</ci>
       <ci>σ</ci>
      </apply>
      <ci>𝐱</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\mathbf{x}\in\mathbb{R}^{n}:\sigma^{\text{T}}(\mathbf{x})\dot{\sigma}(%
\mathbf{x})<0\}
  </annotation>
 </semantics>
</math>

 That is, when initial conditions come entirely from this space, the Lyapunov function candidate 

<math display="inline" id="Sliding_mode_control:117">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>σ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(\sigma)
  </annotation>
 </semantics>
</math>

 is a <a href="Lyapunov_function" title="wikilink">Lyapunov function</a> and 

<math display="inline" id="Sliding_mode_control:118">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 trajectories are sure to move toward the sliding mode surface where 

<math display="inline" id="Sliding_mode_control:119">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})=\mathbf{0}
  </annotation>
 </semantics>
</math>

. Moreover, if the reachability conditions from Theorem 1 are satisfied, the sliding mode will enter the region where 

<math display="inline" id="Sliding_mode_control:120">
 <semantics>
  <mover accent="true">
   <mi>V</mi>
   <mo>˙</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-˙</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{V}
  </annotation>
 </semantics>
</math>

 is more strongly bounded away from zero in finite time. Hence, the sliding mode 

<math display="inline" id="Sliding_mode_control:121">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>σ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma=0
  </annotation>
 </semantics>
</math>

 will be attained in finite time.</p>
<h3 id="theorem-3-sliding-motion">Theorem 3: Sliding Motion</h3>

<p>Let</p>

<p>

<math display="block" id="Sliding_mode_control:122">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi>σ</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <mi>𝐱</mi>
    </mrow>
   </mfrac>
   <mi>B</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>σ</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <ci>𝐱</ci>
     </apply>
    </apply>
    <ci>B</ci>
    <interval closure="open">
     <ci>𝐱</ci>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial\sigma}{\partial{\mathbf{x}}}B(\mathbf{x},t)
  </annotation>
 </semantics>
</math>

 be <a class="uri" href="nonsingular" title="wikilink">nonsingular</a>. That is, the system has a kind of <a class="uri" href="controllability" title="wikilink">controllability</a> that ensures that there is always a control that can move a trajectory to move closer to the sliding mode. Then, once the sliding mode where 

<math display="inline" id="Sliding_mode_control:123">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})=\mathbf{0}
  </annotation>
 </semantics>
</math>

 is achieved, the system will stay on that sliding mode. Along sliding mode trajectories, 

<math display="inline" id="Sliding_mode_control:124">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>σ</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})
  </annotation>
 </semantics>
</math>

 is constant, and so sliding mode trajectories are described by the differential equation</p>

<p>

<math display="block" id="Sliding_mode_control:125">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>σ</mi>
    <mo>˙</mo>
   </mover>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-˙</ci>
     <ci>σ</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\sigma}=\mathbf{0}
  </annotation>
 </semantics>
</math>

. If an 

<math display="inline" id="Sliding_mode_control:126">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

-<a href="stationary_point" title="wikilink">equilibrium</a> is <a href="Lyapunov_stability" title="wikilink">stable</a> with respect to this differential equation, then the system will slide along the sliding mode surface toward the equilibrium.</p>

<p>The <em>equivalent control law</em> on the sliding mode can be found by solving</p>

<p>

<math display="block" id="Sliding_mode_control:127">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>σ</mi>
     <mo>˙</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-˙</ci>
      <ci>σ</ci>
     </apply>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\sigma}(\mathbf{x})=0
  </annotation>
 </semantics>
</math>

 for the equivalent control law 

<math display="inline" id="Sliding_mode_control:128">
 <semantics>
  <mrow>
   <mi>𝐮</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐮</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}(\mathbf{x})
  </annotation>
 </semantics>
</math>

. That is,</p>

<p>

<math display="block" id="Sliding_mode_control:129">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <mo>∂</mo>
      <mi>σ</mi>
     </mrow>
     <mrow>
      <mo>∂</mo>
      <mi>𝐱</mi>
     </mrow>
    </mfrac>
    <mover>
     <mover accent="true">
      <mrow>
       <mo movablelimits="false">(</mo>
       <mrow>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo movablelimits="false" stretchy="false">(</mo>
          <mi>𝐱</mi>
          <mo movablelimits="false">,</mo>
          <mi>t</mi>
          <mo movablelimits="false" stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo movablelimits="false">+</mo>
        <mrow>
         <mi>B</mi>
         <mrow>
          <mo movablelimits="false" stretchy="false">(</mo>
          <mi>𝐱</mi>
          <mo movablelimits="false">,</mo>
          <mi>t</mi>
          <mo movablelimits="false" stretchy="false">)</mo>
         </mrow>
         <mi>𝐮</mi>
        </mrow>
       </mrow>
       <mo movablelimits="false">)</mo>
      </mrow>
      <mo movablelimits="false">⏞</mo>
     </mover>
     <mover accent="true">
      <mi>𝐱</mi>
      <mo>˙</mo>
     </mover>
    </mover>
   </mrow>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <ci>σ</ci>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <ci>𝐱</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-⏞</ci>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>f</ci>
         <interval closure="open">
          <ci>𝐱</ci>
          <ci>t</ci>
         </interval>
        </apply>
        <apply>
         <times></times>
         <ci>B</ci>
         <interval closure="open">
          <ci>𝐱</ci>
          <ci>t</ci>
         </interval>
         <ci>𝐮</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <ci>normal-˙</ci>
       <ci>𝐱</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial\sigma}{\partial\mathbf{x}}\overbrace{\left(f(\mathbf{x},t)+B(%
\mathbf{x},t)\mathbf{u}\right)}^{\dot{\mathbf{x}}}=\mathbf{0}
  </annotation>
 </semantics>
</math>

 and so the equivalent control</p>

<p>

<math display="block" id="Sliding_mode_control:130">
 <semantics>
  <mrow>
   <mi>𝐮</mi>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <msup>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mfrac>
         <mrow>
          <mo>∂</mo>
          <mi>σ</mi>
         </mrow>
         <mrow>
          <mo>∂</mo>
          <mi>𝐱</mi>
         </mrow>
        </mfrac>
        <mi>B</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>𝐱</mi>
         <mo>,</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <mi>σ</mi>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <mi>𝐱</mi>
      </mrow>
     </mfrac>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝐱</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐮</ci>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <partialdiff></partialdiff>
          <ci>σ</ci>
         </apply>
         <apply>
          <partialdiff></partialdiff>
          <ci>𝐱</ci>
         </apply>
        </apply>
        <ci>B</ci>
        <interval closure="open">
         <ci>𝐱</ci>
         <ci>t</ci>
        </interval>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>σ</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>𝐱</ci>
       </apply>
      </apply>
      <ci>f</ci>
      <interval closure="open">
       <ci>𝐱</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}=-\left(\frac{\partial\sigma}{\partial\mathbf{x}}B(\mathbf{x},t)%
\right)^{-1}\frac{\partial\sigma}{\partial\mathbf{x}}f(\mathbf{x},t)
  </annotation>
 </semantics>
</math>

 That is, even though the actual control 

<math display="inline" id="Sliding_mode_control:131">
 <semantics>
  <mi>𝐮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}
  </annotation>
 </semantics>
</math>

 is not <a href="continuous_function" title="wikilink">continuous</a>, the rapid switching across the sliding mode where 

<math display="inline" id="Sliding_mode_control:132">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})=\mathbf{0}
  </annotation>
 </semantics>
</math>

 forces the system to <em>act</em> as if it were driven by this continuous control.</p>

<p>Likewise, the system trajectories on the sliding mode behave as if</p>

<p>

<math display="block" id="Sliding_mode_control:133">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>𝐱</mi>
    <mo>˙</mo>
   </mover>
   <mo>=</mo>
   <mover>
    <mover accent="true">
     <mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo movablelimits="false" stretchy="false">(</mo>
        <mi>𝐱</mi>
        <mo movablelimits="false">,</mo>
        <mi>t</mi>
        <mo movablelimits="false" stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo movablelimits="false">-</mo>
      <mrow>
       <mi>B</mi>
       <mrow>
        <mo movablelimits="false" stretchy="false">(</mo>
        <mi>𝐱</mi>
        <mo movablelimits="false">,</mo>
        <mi>t</mi>
        <mo movablelimits="false" stretchy="false">)</mo>
       </mrow>
       <msup>
        <mrow>
         <mo movablelimits="false">(</mo>
         <mrow>
          <mfrac>
           <mrow>
            <mo movablelimits="false">∂</mo>
            <mi>σ</mi>
           </mrow>
           <mrow>
            <mo movablelimits="false">∂</mo>
            <mi>𝐱</mi>
           </mrow>
          </mfrac>
          <mi>B</mi>
          <mrow>
           <mo movablelimits="false" stretchy="false">(</mo>
           <mi>𝐱</mi>
           <mo movablelimits="false">,</mo>
           <mi>t</mi>
           <mo movablelimits="false" stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo movablelimits="false">)</mo>
        </mrow>
        <mrow>
         <mo movablelimits="false">-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mfrac>
        <mrow>
         <mo movablelimits="false">∂</mo>
         <mi>σ</mi>
        </mrow>
        <mrow>
         <mo movablelimits="false">∂</mo>
         <mi>𝐱</mi>
        </mrow>
       </mfrac>
       <mi>f</mi>
       <mrow>
        <mo movablelimits="false" stretchy="false">(</mo>
        <mi>𝐱</mi>
        <mo movablelimits="false">,</mo>
        <mi>t</mi>
        <mo movablelimits="false" stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo movablelimits="false">⏞</mo>
    </mover>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>𝐱</mi>
       <mo>,</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>B</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>𝐱</mi>
       <mo>,</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>u</mi>
     </mrow>
    </mrow>
   </mover>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>𝐈</mi>
      <mo>-</mo>
      <mrow>
       <mi>B</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>𝐱</mi>
        <mo>,</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <msup>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mfrac>
           <mrow>
            <mo>∂</mo>
            <mi>σ</mi>
           </mrow>
           <mrow>
            <mo>∂</mo>
            <mi>𝐱</mi>
           </mrow>
          </mfrac>
          <mi>B</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>𝐱</mi>
           <mo>,</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>)</mo>
        </mrow>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mfrac>
        <mrow>
         <mo>∂</mo>
         <mi>σ</mi>
        </mrow>
        <mrow>
         <mo>∂</mo>
         <mi>𝐱</mi>
        </mrow>
       </mfrac>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-˙</ci>
      <ci>𝐱</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-⏞</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>f</ci>
         <interval closure="open">
          <ci>𝐱</ci>
          <ci>t</ci>
         </interval>
        </apply>
        <apply>
         <times></times>
         <ci>B</ci>
         <interval closure="open">
          <ci>𝐱</ci>
          <ci>t</ci>
         </interval>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <times></times>
           <apply>
            <divide></divide>
            <apply>
             <partialdiff></partialdiff>
             <ci>σ</ci>
            </apply>
            <apply>
             <partialdiff></partialdiff>
             <ci>𝐱</ci>
            </apply>
           </apply>
           <ci>B</ci>
           <interval closure="open">
            <ci>𝐱</ci>
            <ci>t</ci>
           </interval>
          </apply>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <divide></divide>
          <apply>
           <partialdiff></partialdiff>
           <ci>σ</ci>
          </apply>
          <apply>
           <partialdiff></partialdiff>
           <ci>𝐱</ci>
          </apply>
         </apply>
         <ci>f</ci>
         <interval closure="open">
          <ci>𝐱</ci>
          <ci>t</ci>
         </interval>
        </apply>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>f</ci>
        <interval closure="open">
         <ci>𝐱</ci>
         <ci>t</ci>
        </interval>
       </apply>
       <apply>
        <times></times>
        <ci>B</ci>
        <interval closure="open">
         <ci>𝐱</ci>
         <ci>t</ci>
        </interval>
        <ci>u</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>𝐱</ci>
       <ci>t</ci>
      </interval>
      <apply>
       <minus></minus>
       <ci>𝐈</ci>
       <apply>
        <times></times>
        <ci>B</ci>
        <interval closure="open">
         <ci>𝐱</ci>
         <ci>t</ci>
        </interval>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <times></times>
          <apply>
           <divide></divide>
           <apply>
            <partialdiff></partialdiff>
            <ci>σ</ci>
           </apply>
           <apply>
            <partialdiff></partialdiff>
            <ci>𝐱</ci>
           </apply>
          </apply>
          <ci>B</ci>
          <interval closure="open">
           <ci>𝐱</ci>
           <ci>t</ci>
          </interval>
         </apply>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <partialdiff></partialdiff>
          <ci>σ</ci>
         </apply>
         <apply>
          <partialdiff></partialdiff>
          <ci>𝐱</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\mathbf{x}}=\overbrace{f(\mathbf{x},t)-B(\mathbf{x},t)\left(\frac{%
\partial\sigma}{\partial\mathbf{x}}B(\mathbf{x},t)\right)^{-1}\frac{\partial%
\sigma}{\partial\mathbf{x}}f(\mathbf{x},t)}^{f(\mathbf{x},t)+B(\mathbf{x},t)u}%
=f(\mathbf{x},t)\left(\mathbf{I}-B(\mathbf{x},t)\left(\frac{\partial\sigma}{%
\partial\mathbf{x}}B(\mathbf{x},t)\right)^{-1}\frac{\partial\sigma}{\partial%
\mathbf{x}}\right)
  </annotation>
 </semantics>
</math>

 The resulting system matches the sliding mode differential equation</p>

<p>

<math display="block" id="Sliding_mode_control:134">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>σ</mi>
     <mo>˙</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-˙</ci>
      <ci>σ</ci>
     </apply>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\sigma}(\mathbf{x})=\mathbf{0}
  </annotation>
 </semantics>
</math>

 and so as long as the sliding mode surface where 

<math display="inline" id="Sliding_mode_control:135">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})=\mathbf{0}
  </annotation>
 </semantics>
</math>

 is <a href="Lyapunov_stable" title="wikilink">stable (in the sense of Lyapunov)</a>, the system can be assumed to follow the simpler 

<math display="inline" id="Sliding_mode_control:136">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>σ</mi>
    <mo>˙</mo>
   </mover>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-˙</ci>
     <ci>σ</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\sigma}=0
  </annotation>
 </semantics>
</math>

 condition after some initial transient during the period while the system finds the sliding mode. The same motion is approximately maintained provided the equality 

<math display="inline" id="Sliding_mode_control:137">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})=\mathbf{0}
  </annotation>
 </semantics>
</math>

 only approximately holds.</p>

<p>It follows from these theorems that the sliding motion is invariant (i.e., insensitive) to sufficiently small disturbances entering the system through the control channel. That is, as long as the control is large enough to ensure that 

<math display="inline" id="Sliding_mode_control:138">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>σ</mi>
     <mtext>T</mtext>
    </msup>
    <mover accent="true">
     <mi>σ</mi>
     <mo>˙</mo>
    </mover>
   </mrow>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>σ</ci>
      <mtext>T</mtext>
     </apply>
     <apply>
      <ci>normal-˙</ci>
      <ci>σ</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{\text{T}}\dot{\sigma}<0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sliding_mode_control:139">
 <semantics>
  <mover accent="true">
   <mi>σ</mi>
   <mo>˙</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-˙</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\sigma}
  </annotation>
 </semantics>
</math>

 is uniformly bounded away from zero, the sliding mode will be maintained as if there was no disturbance. The invariance property of sliding mode control to certain disturbances and model uncertainties is its most attractive feature; it is strongly <a href="Robust_control" title="wikilink">robust</a>.</p>

<p>As discussed in an example below, a sliding mode control law can keep the constraint</p>

<p>

<math display="block" id="Sliding_mode_control:140">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>x</mi>
     <mo>˙</mo>
    </mover>
    <mo>+</mo>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-˙</ci>
      <ci>x</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{x}+x=0
  </annotation>
 </semantics>
</math>

 in order to asymptotically stabilize any system of the form</p>

<p>

<math display="block" id="Sliding_mode_control:141">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>x</mi>
    <mo>¨</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo>,</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mover accent="true">
       <mi>x</mi>
       <mo>˙</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi>u</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¨</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>a</ci>
      <vector>
       <ci>t</ci>
       <ci>x</ci>
       <apply>
        <ci>normal-˙</ci>
        <ci>x</ci>
       </apply>
      </vector>
     </apply>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ddot{x}=a(t,x,\dot{x})+u
  </annotation>
 </semantics>
</math>

 when 

<math display="inline" id="Sliding_mode_control:142">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>⋅</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>normal-⋅</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(\cdot)
  </annotation>
 </semantics>
</math>

 has a finite upper bound. In this case, the sliding mode is where</p>

<p>

<math display="block" id="Sliding_mode_control:143">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>x</mi>
    <mo>˙</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-˙</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{x}=-x
  </annotation>
 </semantics>
</math>

 (i.e., where 

<math display="inline" id="Sliding_mode_control:144">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>x</mi>
     <mo>˙</mo>
    </mover>
    <mo>+</mo>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-˙</ci>
      <ci>x</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{x}+x=0
  </annotation>
 </semantics>
</math>

). That is, when the system is constrained this way, it behaves like a simple <a href="BIBO_stability" title="wikilink">stable</a> <a href="linear_system" title="wikilink">linear system</a>, and so it has a globally exponentially stable equilibrium at the 

<math display="inline" id="Sliding_mode_control:145">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo>˙</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <ci>x</ci>
     <apply>
      <ci>normal-˙</ci>
      <ci>x</ci>
     </apply>
    </interval>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,\dot{x})=(0,0)
  </annotation>
 </semantics>
</math>

 origin.</p>
<h2 id="control-design-examples">Control design examples</h2>
<ul>
<li>Consider a <a href="plant_(control_theory)" title="wikilink">plant</a> described by Equation (1) with single input 

<math display="inline" id="Sliding_mode_control:146">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 (i.e., 

<math display="inline" id="Sliding_mode_control:147">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=1
  </annotation>
 </semantics>
</math>

). The switching function is <em>picked</em> to be the linear combination</li>
</ul>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\sigma(\mathbf{x}) \triangleq s_1 x_1 + s_2 x_2 + \cdots + s_{n-1} x_{n-1} + s_n x_n </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sliding_mode_control:148">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>4</mn>
   <mo rspace="4.2pt" stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">4</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (4)\,
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
<dl>
<dd>where the weight 

<math display="inline" id="Sliding_mode_control:149">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>i</mi>
   </msub>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{i}>0
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Sliding_mode_control:150">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>i</mi>
   <mo>≤</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq i\leq n
  </annotation>
 </semantics>
</math>

. The sliding surface is the <a class="uri" href="simplex" title="wikilink">simplex</a> where 

<math display="inline" id="Sliding_mode_control:151">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})=0
  </annotation>
 </semantics>
</math>

. When trajectories are forced to slide along this surface,

<p>

<math display="block" id="Sliding_mode_control:152">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>σ</mi>
     <mo>˙</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-˙</ci>
      <ci>σ</ci>
     </apply>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\sigma}(\mathbf{x})=0
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>and so

<p>

<math display="block" id="Sliding_mode_control:153">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>s</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mover accent="true">
       <mi>x</mi>
       <mo>˙</mo>
      </mover>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>s</mi>
      <mn>2</mn>
     </msub>
     <msub>
      <mover accent="true">
       <mi>x</mi>
       <mo>˙</mo>
      </mover>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>s</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msub>
      <mover accent="true">
       <mi>x</mi>
       <mo>˙</mo>
      </mover>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>s</mi>
      <mi>n</mi>
     </msub>
     <msub>
      <mover accent="true">
       <mi>x</mi>
       <mo>˙</mo>
      </mover>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-˙</ci>
        <ci>x</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-˙</ci>
        <ci>x</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-˙</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-˙</ci>
        <ci>x</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{1}\dot{x}_{1}+s_{2}\dot{x}_{2}+\cdots+s_{n-1}\dot{x}_{n-1}+s_{n}\dot{x}_{n}=0
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>which is a reduced-order system (i.e., the new system is of order 

<math display="inline" id="Sliding_mode_control:154">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-1
  </annotation>
 </semantics>
</math>

 because the system is constrained to this 

<math display="inline" id="Sliding_mode_control:155">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n-1)
  </annotation>
 </semantics>
</math>

-dimensional sliding mode simplex). This surface may have favorable properties (e.g., when the plant dynamics are forced to slide along this surface, they move toward the origin 

<math display="inline" id="Sliding_mode_control:156">
 <semantics>
  <mrow>
   <mi>𝐱</mi>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐱</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}=\mathbf{0}
  </annotation>
 </semantics>
</math>

). Taking the derivative of the <a href="Lyapunov_function" title="wikilink">Lyapunov function</a> in Equation (3), we have

<p>:<math></math></p>
</dd>
</dl>

<p>\dot{V}(\sigma(\mathbf{x})) = \overbrace{\sigma(\mathbf{x})^{\text{T}}}^{\tfrac{\partial \sigma}{\partial \mathbf{x}}} \overbrace{\dot{\sigma}(\mathbf{x})}^{\tfrac{\operatorname{d} \sigma}{\operatorname{d} t}}</p>
<dl>
<dd>To ensure 

<math display="inline" id="Sliding_mode_control:157">
 <semantics>
  <mover accent="true">
   <mi>V</mi>
   <mo>˙</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-˙</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{V}
  </annotation>
 </semantics>
</math>

 is a <a href="negative-definite_function" title="wikilink">negative-definite function</a> (i.e., 

<math display="inline" id="Sliding_mode_control:158">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>V</mi>
    <mo>˙</mo>
   </mover>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <ci>normal-˙</ci>
     <ci>V</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{V}<0
  </annotation>
 </semantics>
</math>

 for <a href="Lyapunov_stability" title="wikilink">Lyapunov stability</a> of the surface 

<math display="inline" id="Sliding_mode_control:159">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>σ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\sigma}=0
  </annotation>
 </semantics>
</math>

), the feedback control law 

<math display="inline" id="Sliding_mode_control:160">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(\mathbf{x})
  </annotation>
 </semantics>
</math>

 must be chosen so that

<p>:<math>\begin{cases}</math></p>
</dd>
</dl>

<p>\dot{\sigma}  0\\ \dot{\sigma} &gt; 0 &amp;\text{if } \sigma </p>
<dl>
<dd>Hence, the product 

<math display="inline" id="Sliding_mode_control:161">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mover accent="true">
     <mi>σ</mi>
     <mo>˙</mo>
    </mover>
   </mrow>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>σ</ci>
     <apply>
      <ci>normal-˙</ci>
      <ci>σ</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\dot{\sigma}<0
  </annotation>
 </semantics>
</math>

 because it is the product of a negative and a positive number. Note that
</dd>
</dl>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><dl>
<dd><dl>
<dd><math>\dot{\sigma}(\mathbf{x})
</math></dd>
</dl>
</dd>
</dl>
<h1 id="overbracefracpartialsigmamathbfxpartialmathbfx-dotmathbfxdotsigmamathbfx">\overbrace{\frac{\partial{\sigma(\mathbf{x})}}{\partial{\mathbf{x}}} \dot{\mathbf{x}}}^{\dot{\sigma}(\mathbf{x})}</h1>

<p>\frac{\partial{\sigma(\mathbf{x})}}{\partial{\mathbf{x}}}</p>

<p><code> \overbrace{\left( f(\mathbf{x},t) + B(\mathbf{x},t) u \right)}^{\dot{\mathbf{x}}}</code></p>

<p>= \overbrace{[s_1, s_2, \ldots, s_n]}^{\frac{\partial{\sigma(\mathbf{x})}}{\partial{\mathbf{x}}}}</p>

<p><code> \underbrace{\overbrace{\left( f(\mathbf{x},t) + B(\mathbf{x},t) u \right)}^{\dot{\mathbf{x}}}}_{\text{( i.e., an } n \times 1 \text{ vector )}}</code></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sliding_mode_control:162">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>5</mn>
   <mo rspace="4.2pt" stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">5</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (5)\,
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
<dl>
<dd>The control law 

<math display="inline" id="Sliding_mode_control:163">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(\mathbf{x})
  </annotation>
 </semantics>
</math>

 is chosen so that

<p>:<math>u(\mathbf{x})</math></p>
</dd>
</dl>

<p>= \begin{cases} u^+(\mathbf{x}) &amp;\text{if } \sigma(\mathbf{x}) &gt; 0 \\ u^-(\mathbf{x}) &amp;\text{if } \sigma(\mathbf{x}) </p>
<dl>
<dd>where
<ul>
<li>

<math display="inline" id="Sliding_mode_control:164">
 <semantics>
  <mrow>
   <msup>
    <mi>u</mi>
    <mo>+</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>u</ci>
     <plus></plus>
    </apply>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u^{+}(\mathbf{x})
  </annotation>
 </semantics>
</math>

 is some control (e.g., possibly extreme, like "on" or "forward") that ensures Equation (5) (i.e., 

<math display="inline" id="Sliding_mode_control:165">
 <semantics>
  <mover accent="true">
   <mi>σ</mi>
   <mo>˙</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-˙</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\sigma}
  </annotation>
 </semantics>
</math>

) is <em>negative</em> at 

<math display="inline" id="Sliding_mode_control:166">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Sliding_mode_control:167">
 <semantics>
  <mrow>
   <msup>
    <mi>u</mi>
    <mo>-</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>u</ci>
     <minus></minus>
    </apply>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u^{-}(\mathbf{x})
  </annotation>
 </semantics>
</math>

 is some control (e.g., possibly extreme, like "off" or "reverse") that ensures Equation (5) (i.e., 

<math display="inline" id="Sliding_mode_control:168">
 <semantics>
  <mover accent="true">
   <mi>σ</mi>
   <mo>˙</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-˙</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\sigma}
  </annotation>
 </semantics>
</math>

) is <em>positive</em> at 

<math display="inline" id="Sliding_mode_control:169">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

</li>
</ul>
</dd>
<dd>The resulting trajectory should move toward the sliding surface where 

<math display="inline" id="Sliding_mode_control:170">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})=0
  </annotation>
 </semantics>
</math>

. Because real systems have delay, sliding mode trajectories often <em>chatter</em> back and forth along this sliding surface (i.e., the true trajectory may not smoothly follow 

<math display="inline" id="Sliding_mode_control:171">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})=0
  </annotation>
 </semantics>
</math>

, but it will always return to the sliding mode after leaving it).
</dd>
</dl>
<ul>
<li>Consider the <a href="dynamic_system" title="wikilink">dynamic system</a></li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Sliding_mode_control:172">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>x</mi>
    <mo>¨</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo>,</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mover accent="true">
       <mi>x</mi>
       <mo>˙</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi>u</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¨</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>a</ci>
      <vector>
       <ci>t</ci>
       <ci>x</ci>
       <apply>
        <ci>normal-˙</ci>
        <ci>x</ci>
       </apply>
      </vector>
     </apply>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ddot{x}=a(t,x,\dot{x})+u
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>which can be expressed in a 2-dimensional <a href="state_space_(controls)" title="wikilink">state space</a> (with 

<math display="inline" id="Sliding_mode_control:173">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sliding_mode_control:174">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mover accent="true">
    <mi>x</mi>
    <mo>˙</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <ci>normal-˙</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}=\dot{x}
  </annotation>
 </semantics>
</math>

) as

<p>:<math></math></p>
</dd>
</dl>

<p>\begin{cases} \dot{x}_1 = x_2\\ \dot{x}_2 = a(t,x_1,x_2) + u \end{cases}</p>
<dl>
<dd>Also assume that 

<math display="inline" id="Sliding_mode_control:175">
 <semantics>
  <mrow>
   <mrow>
    <mo>sup</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>a</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mo>⋅</mo>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="latexml">supremum</csymbol>
     <set>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>normal-⋅</ci>
       </apply>
      </apply>
     </set>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sup\{|a(\cdot)|\}\leq k
  </annotation>
 </semantics>
</math>

 (i.e., 

<math display="inline" id="Sliding_mode_control:176">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>a</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |a|
  </annotation>
 </semantics>
</math>

 has a finite upper bound 

<math display="inline" id="Sliding_mode_control:177">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 that is known). For this system, choose the switching function

<p>

<math display="block" id="Sliding_mode_control:178">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo>˙</mo>
    </mover>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>σ</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <apply>
       <ci>normal-˙</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(x_{1},x_{2})=x_{1}+x_{2}=x+\dot{x}
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>By the previous example, we must choose the feedback control law 

<math display="inline" id="Sliding_mode_control:179">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo>˙</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <interval closure="open">
     <ci>x</ci>
     <apply>
      <ci>normal-˙</ci>
      <ci>x</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(x,\dot{x})
  </annotation>
 </semantics>
</math>

 so that 

<math display="inline" id="Sliding_mode_control:180">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mover accent="true">
     <mi>σ</mi>
     <mo>˙</mo>
    </mover>
   </mrow>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>σ</ci>
     <apply>
      <ci>normal-˙</ci>
      <ci>σ</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\dot{\sigma}<0
  </annotation>
 </semantics>
</math>

. Here,

<p>

<math display="block" id="Sliding_mode_control:181">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>σ</mi>
    <mo>˙</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>x</mi>
      <mo>˙</mo>
     </mover>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mover accent="true">
      <mi>x</mi>
      <mo>˙</mo>
     </mover>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mover accent="true">
     <mi>x</mi>
     <mo>˙</mo>
    </mover>
    <mo>+</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo>¨</mo>
    </mover>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mover accent="true">
      <mi>x</mi>
      <mo>˙</mo>
     </mover>
    </mpadded>
    <mo rspace="4.2pt">+</mo>
    <mover>
     <mover accent="true">
      <mrow>
       <mrow>
        <mi>a</mi>
        <mrow>
         <mo movablelimits="false" stretchy="false">(</mo>
         <mi>t</mi>
         <mo movablelimits="false">,</mo>
         <mi>x</mi>
         <mo movablelimits="false">,</mo>
         <mover accent="true">
          <mi>x</mi>
          <mo movablelimits="false">˙</mo>
         </mover>
         <mo movablelimits="false" stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo movablelimits="false">+</mo>
       <mi>u</mi>
      </mrow>
      <mo movablelimits="false">⏞</mo>
     </mover>
     <mover accent="true">
      <mi>x</mi>
      <mo>¨</mo>
     </mover>
    </mover>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-˙</ci>
      <ci>σ</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-˙</ci>
        <ci>x</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-˙</ci>
        <ci>x</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <ci>normal-˙</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <ci>normal-¨</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <ci>normal-˙</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-⏞</ci>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <ci>a</ci>
          <vector>
           <ci>t</ci>
           <ci>x</ci>
           <apply>
            <ci>normal-˙</ci>
            <ci>x</ci>
           </apply>
          </vector>
         </apply>
         <ci>u</ci>
        </apply>
       </apply>
       <apply>
        <ci>normal-¨</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\sigma}=\dot{x}_{1}+\dot{x}_{2}=\dot{x}+\ddot{x}=\dot{x}\,+\,\overbrace{a%
(t,x,\dot{x})+u}^{\ddot{x}}
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>When 

<math display="inline" id="Sliding_mode_control:182">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo>˙</mo>
    </mover>
   </mrow>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <apply>
      <ci>normal-˙</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x+\dot{x}<0
  </annotation>
 </semantics>
</math>

 (i.e., when 

<math display="inline" id="Sliding_mode_control:183">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>σ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma<0
  </annotation>
 </semantics>
</math>

), to make 

<math display="inline" id="Sliding_mode_control:184">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>σ</mi>
    <mo>˙</mo>
   </mover>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <ci>normal-˙</ci>
     <ci>σ</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\sigma}>0
  </annotation>
 </semantics>
</math>

, the control law should be picked so that 

<math display="inline" id="Sliding_mode_control:185">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>></mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mover accent="true">
      <mi>x</mi>
      <mo>˙</mo>
     </mover>
     <mo>+</mo>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mover accent="true">
        <mi>x</mi>
        <mo>˙</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>u</ci>
    <apply>
     <abs></abs>
     <apply>
      <plus></plus>
      <apply>
       <ci>normal-˙</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>a</ci>
       <vector>
        <ci>t</ci>
        <ci>x</ci>
        <apply>
         <ci>normal-˙</ci>
         <ci>x</ci>
        </apply>
       </vector>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u>|\dot{x}+a(t,x,\dot{x})|
  </annotation>
 </semantics>
</math>

</li>
<li>When 

<math display="inline" id="Sliding_mode_control:186">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo>˙</mo>
    </mover>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <apply>
      <ci>normal-˙</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x+\dot{x}>0
  </annotation>
 </semantics>
</math>

 (i.e., when 

<math display="inline" id="Sliding_mode_control:187">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>σ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma>0
  </annotation>
 </semantics>
</math>

), to make 

<math display="inline" id="Sliding_mode_control:188">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>σ</mi>
    <mo>˙</mo>
   </mover>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <ci>normal-˙</ci>
     <ci>σ</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\sigma}<0
  </annotation>
 </semantics>
</math>

, the control law should be picked so that 

<math display="inline" id="Sliding_mode_control:189">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo><</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mover accent="true">
       <mi>x</mi>
       <mo>˙</mo>
      </mover>
      <mo>+</mo>
      <mrow>
       <mi>a</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo>,</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mover accent="true">
         <mi>x</mi>
         <mo>˙</mo>
        </mover>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>u</ci>
    <apply>
     <minus></minus>
     <apply>
      <abs></abs>
      <apply>
       <plus></plus>
       <apply>
        <ci>normal-˙</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <times></times>
        <ci>a</ci>
        <vector>
         <ci>t</ci>
         <ci>x</ci>
         <apply>
          <ci>normal-˙</ci>
          <ci>x</ci>
         </apply>
        </vector>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u<-|\dot{x}+a(t,x,\dot{x})|
  </annotation>
 </semantics>
</math>

</li>
</ul>
</dd>
<dd>However, by the <a href="triangle_inequality" title="wikilink">triangle inequality</a>,

<p>

<math display="block" id="Sliding_mode_control:190">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo>˙</mo>
     </mover>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mover accent="true">
        <mi>x</mi>
        <mo>˙</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mover accent="true">
      <mi>x</mi>
      <mo>˙</mo>
     </mover>
     <mo>+</mo>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mover accent="true">
        <mi>x</mi>
        <mo>˙</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <plus></plus>
     <apply>
      <abs></abs>
      <apply>
       <ci>normal-˙</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>a</ci>
       <vector>
        <ci>t</ci>
        <ci>x</ci>
        <apply>
         <ci>normal-˙</ci>
         <ci>x</ci>
        </apply>
       </vector>
      </apply>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <plus></plus>
      <apply>
       <ci>normal-˙</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>a</ci>
       <vector>
        <ci>t</ci>
        <ci>x</ci>
        <apply>
         <ci>normal-˙</ci>
         <ci>x</ci>
        </apply>
       </vector>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\dot{x}|+|a(t,x,\dot{x})|\geq|\dot{x}+a(t,x,\dot{x})|
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>and by the assumption about 

<math display="inline" id="Sliding_mode_control:191">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>a</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |a|
  </annotation>
 </semantics>
</math>

,

<p>

<math display="block" id="Sliding_mode_control:192">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo>˙</mo>
     </mover>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>+</mo>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>></mo>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo>˙</mo>
     </mover>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>a</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mover accent="true">
        <mi>x</mi>
        <mo>˙</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <plus></plus>
     <apply>
      <abs></abs>
      <apply>
       <ci>normal-˙</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <abs></abs>
      <apply>
       <ci>normal-˙</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>a</ci>
       <vector>
        <ci>t</ci>
        <ci>x</ci>
        <apply>
         <ci>normal-˙</ci>
         <ci>x</ci>
        </apply>
       </vector>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\dot{x}|+k+1>|\dot{x}|+|a(t,x,\dot{x})|
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>So the system can be feedback stabilized (to return to the sliding mode) by means of the control law

<p>:<math>u(x,\dot{x})</math></p>
</dd>
</dl>

<p>= \begin{cases}</p>

<p><code>  |\dot{x}| + k + 1 &amp;\text{if } \underbrace{x + \dot{x}} </code><code> 0</code></p>

<p>\end{cases}</p>
<dl>
<dd>which can be expressed in <a href="closed-form_expression" title="wikilink">closed form</a> as

<p>

<math display="block" id="Sliding_mode_control:193">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo>˙</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">|</mo>
        <mover accent="true">
         <mi>x</mi>
         <mo>˙</mo>
        </mover>
        <mo stretchy="false">|</mo>
       </mrow>
       <mo>+</mo>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <munder>
      <munder accentunder="true">
       <mrow>
        <mo movablelimits="false">sgn</mo>
        <mrow>
         <mo movablelimits="false" stretchy="false">(</mo>
         <mover>
          <mover accent="true">
           <mrow>
            <mover accent="true">
             <mi>x</mi>
             <mo movablelimits="false">˙</mo>
            </mover>
            <mo movablelimits="false">+</mo>
            <mi>x</mi>
           </mrow>
           <mo movablelimits="false">⏞</mo>
          </mover>
          <mi>σ</mi>
         </mover>
         <mo movablelimits="false" stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo movablelimits="false">⏟</mo>
      </munder>
      <mrow>
       <mrow>
        <mtext>(i.e., tests</mtext>
        <mi>σ</mi>
       </mrow>
       <mo>></mo>
       <mrow>
        <mn>0</mn>
        <mtext>)</mtext>
       </mrow>
      </mrow>
     </munder>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>u</ci>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <ci>normal-˙</ci>
       <ci>x</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <apply>
        <abs></abs>
        <apply>
         <ci>normal-˙</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-⏟</ci>
        <apply>
         <ci>sgn</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <ci>normal-⏞</ci>
           <apply>
            <plus></plus>
            <apply>
             <ci>normal-˙</ci>
             <ci>x</ci>
            </apply>
            <ci>x</ci>
           </apply>
          </apply>
          <ci>σ</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <gt></gt>
        <apply>
         <times></times>
         <mtext>(i.e., tests</mtext>
         <ci>σ</ci>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">0</cn>
         <mtext>)</mtext>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(x,\dot{x})=-(|\dot{x}|+k+1)\underbrace{\operatorname{sgn}(\overbrace{\dot{x}%
+x}^{\sigma})}_{\text{(i.e., tests }\sigma>0\text{)}}
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>Assuming that the system trajectories are forced to move so that 

<math display="inline" id="Sliding_mode_control:194">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>𝐱</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})=0
  </annotation>
 </semantics>
</math>

, then

<p>

<math display="block" id="Sliding_mode_control:195">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>x</mi>
     <mo>˙</mo>
    </mover>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mtext>(i.e.,</mtext>
     <mi>σ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mover accent="true">
       <mi>x</mi>
       <mo>˙</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>x</mi>
     <mo>+</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo>˙</mo>
     </mover>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>0</mn>
     <mtext>)</mtext>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-˙</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>(i.e.,</mtext>
       <ci>σ</ci>
       <interval closure="open">
        <ci>x</ci>
        <apply>
         <ci>normal-˙</ci>
         <ci>x</ci>
        </apply>
       </interval>
      </apply>
      <apply>
       <plus></plus>
       <ci>x</ci>
       <apply>
        <ci>normal-˙</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <cn type="integer">0</cn>
       <mtext>)</mtext>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{x}=-x\qquad\text{(i.e., }\sigma(x,\dot{x})=x+\dot{x}=0\text{)}
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>So once the system reaches the sliding mode, the system's 2-dimensional dynamics behave like this 1-dimensional system, which has a globally exponentially stable <a href="stationary_point" title="wikilink">equilibrium</a> at 

<math display="inline" id="Sliding_mode_control:196">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo>˙</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <ci>x</ci>
     <apply>
      <ci>normal-˙</ci>
      <ci>x</ci>
     </apply>
    </interval>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,\dot{x})=(0,0)
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
<h3 id="automated-design-solutions">Automated design solutions</h3>

<p>Although various theories exist for sliding mode control system design, there is a lack of a highly effective design methodology due to practical difficulties encountered in analytical and numerical methods. A reusable computing paradigm such as a <a href="genetic_algorithm" title="wikilink">genetic algorithm</a> can, however, be utilized to transform a 'unsolvable problem' of optimal design into a practically solvable 'non-deterministic polynomial problem'. This results in computer-automated designs for sliding model control. <a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="sliding-mode-observer">Sliding mode observer</h2>

<p>Sliding mode control can be used in the design of <a href="state_observer" title="wikilink">state observers</a>. These non-linear high-gain observers have the ability to bring coordinates of the estimator error dynamics to zero in finite time. Additionally, switched-mode observers have attractive measurement noise resilience that is similar to a <a href="Kalman_filter" title="wikilink">Kalman filter</a>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> For simplicity, the example here uses a traditional sliding mode modification of a <a href="Luenberger_observer" title="wikilink">Luenberger observer</a> for an <a href="LTI_system" title="wikilink">LTI system</a>. In these sliding mode observers, the order of the observer dynamics are reduced by one when the system enters the sliding mode. In this particular example, the estimator error for a single estimated state is brought to zero in finite time, and after that time the other estimator errors decay exponentially to zero. However, as first described by Drakunov,<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> a <a href="State_observer#Sliding_mode_observer" title="wikilink">sliding mode observer for non-linear systems</a> can be built that brings the estimation error for all estimated states to zero in a finite (and arbitrarily small) time.</p>

<p>Here, consider the LTI system</p>

<p>

<math display="block" id="Sliding_mode_control:197">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mover accent="true">
        <mi>𝐱</mi>
        <mo>˙</mo>
       </mover>
       <mo>=</mo>
       <mrow>
        <mrow>
         <mi>A</mi>
         <mi>𝐱</mi>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>B</mi>
         <mi>𝐮</mi>
        </mrow>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mi>y</mi>
       <mo>=</mo>
       <mrow>
        <mrow>
         <mo>[</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="center">
            <mn>1</mn>
           </mtd>
           <mtd columnalign="center">
            <mn>0</mn>
           </mtd>
           <mtd columnalign="center">
            <mn>0</mn>
           </mtd>
           <mtd columnalign="center">
            <mi mathvariant="normal">⋯</mi>
           </mtd>
           <mtd columnalign="center">
            <mi></mi>
           </mtd>
          </mtr>
         </mtable>
         <mo>]</mo>
        </mrow>
        <mi>𝐱</mi>
       </mrow>
       <mo>=</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
   </mtable>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">cases</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-˙</ci>
      <ci>𝐱</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>𝐱</ci>
      </apply>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>𝐮</ci>
      </apply>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <ci>y</ci>
      <apply>
       <times></times>
       <matrix>
        <matrixrow>
         <cn type="integer">1</cn>
         <cn type="integer">0</cn>
         <cn type="integer">0</cn>
         <ci>normal-⋯</ci>
         <csymbol cd="latexml">absent</csymbol>
        </matrixrow>
       </matrix>
       <ci>𝐱</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{cases}\dot{\mathbf{x}}=A\mathbf{x}+B\mathbf{u}\\
y=\begin{bmatrix}1&0&0&\cdots&\end{bmatrix}\mathbf{x}=x_{1}\end{cases}
  </annotation>
 </semantics>
</math>

 where state vector 

<math display="inline" id="Sliding_mode_control:198">
 <semantics>
  <mrow>
   <mi>𝐱</mi>
   <mo>≜</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-≜</ci>
     <ci>𝐱</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}\triangleq(x_{1},x_{2},\dots,x_{n})\in\mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Sliding_mode_control:199">
 <semantics>
  <mrow>
   <mi>𝐮</mi>
   <mo>≜</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>u</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>u</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>u</mi>
     <mi>r</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>r</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-≜</ci>
     <ci>𝐮</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>r</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}\triangleq(u_{1},u_{2},\dots,u_{r})\in\mathbb{R}^{r}
  </annotation>
 </semantics>
</math>

 is a vector of inputs, and output 

<math display="inline" id="Sliding_mode_control:200">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is a scalar equal to the first state of the 

<math display="inline" id="Sliding_mode_control:201">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 state vector. Let</p>

<p>

<math display="block" id="Sliding_mode_control:202">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>≜</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mn>11</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>A</mi>
        <mn>12</mn>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>A</mi>
        <mn>21</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>A</mi>
        <mn>22</mn>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-≜</ci>
    <ci>A</ci>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">11</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">12</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">21</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">22</cn>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\triangleq\begin{bmatrix}a_{11}&A_{12}\\
A_{21}&A_{22}\end{bmatrix}
  </annotation>
 </semantics>
</math>

 where</p>
<ul>
<li>

<math display="inline" id="Sliding_mode_control:203">
 <semantics>
  <msub>
   <mi>a</mi>
   <mn>11</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <cn type="integer">11</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{11}
  </annotation>
 </semantics>
</math>

 is a scalar representing the influence of the first state 

<math display="inline" id="Sliding_mode_control:204">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 on itself,</li>
<li>

<math display="inline" id="Sliding_mode_control:205">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>21</mn>
   </msub>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">21</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{21}\in\mathbb{R}^{(n-1)}
  </annotation>
 </semantics>
</math>

 is a column vector representing the influence of the other states on the first state,</li>
<li>

<math display="inline" id="Sliding_mode_control:206">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>22</mn>
   </msub>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>×</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">22</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{22}\in\mathbb{R}^{(n-1)\times(n-1)}
  </annotation>
 </semantics>
</math>

 is a matrix representing the influence of the other states on themselves, and</li>
<li>

<math display="inline" id="Sliding_mode_control:207">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>12</mn>
   </msub>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mrow>
     <mn>1</mn>
     <mo>×</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">12</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <apply>
      <times></times>
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{12}\in\mathbb{R}^{1\times(n-1)}
  </annotation>
 </semantics>
</math>

 is a row vector corresponding to the influence of the first state on the other states.</li>
</ul>

<p>The goal is to design a high-gain state observer that estimates the state vector 

<math display="inline" id="Sliding_mode_control:208">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 using only information from the measurement 

<math display="inline" id="Sliding_mode_control:209">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=x_{1}
  </annotation>
 </semantics>
</math>

. Hence, let the vector 

<math display="inline" id="Sliding_mode_control:210">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>𝐱</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-^</ci>
      <ci>𝐱</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>x</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>x</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>x</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{x}}=(\hat{x}_{1},\hat{x}_{2},\dots,\hat{x}_{n})\in\mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

 be the estimates of the 

<math display="inline" id="Sliding_mode_control:211">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 states. The observer takes the form</p>

<p>

<math display="block" id="Sliding_mode_control:212">
 <semantics>
  <mrow>
   <mover accent="true">
    <mover accent="true">
     <mi>𝐱</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>˙</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mover accent="true">
      <mi>𝐱</mi>
      <mo stretchy="false">^</mo>
     </mover>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>B</mi>
     <mi>𝐮</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>L</mi>
     <mi>v</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mover accent="true">
         <mi>x</mi>
         <mo stretchy="false">^</mo>
        </mover>
        <mn>1</mn>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-˙</ci>
     <apply>
      <ci>normal-^</ci>
      <ci>𝐱</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>A</ci>
      <apply>
       <ci>normal-^</ci>
       <ci>𝐱</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>𝐮</ci>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>v</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>x</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\hat{\mathbf{x}}}=A\hat{\mathbf{x}}+B\mathbf{u}+Lv(\hat{x}_{1}-x_{1})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Sliding_mode_control:213">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>:</mo>
   <mrow>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\R</mtext>
    </merror>
    <mo>↦</mo>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\R</mtext>
    </merror>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>v</ci>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <mtext>\R</mtext>
     <mtext>\R</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v:\R\mapsto\R
  </annotation>
 </semantics>
</math>

 is a nonlinear function of the error between estimated state 

<math display="inline" id="Sliding_mode_control:214">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>x</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{x}_{1}
  </annotation>
 </semantics>
</math>

 and the output 

<math display="inline" id="Sliding_mode_control:215">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=x_{1}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Sliding_mode_control:216">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>L</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\in\mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

 is an observer gain vector that serves a similar purpose as in the typical linear <a href="state_observer" title="wikilink">Luenberger observer</a>. Likewise, let</p>

<p>

<math display="block" id="Sliding_mode_control:217">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>L</mi>
        <mn>2</mn>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <matrix>
     <matrixrow>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <cn type="integer">2</cn>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=\begin{bmatrix}-1\\
L_{2}\end{bmatrix}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Sliding_mode_control:218">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mn>2</mn>
   </msub>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{2}\in\mathbb{R}^{(n-1)}
  </annotation>
 </semantics>
</math>

 is a column vector. Additionally, let 

<math display="inline" id="Sliding_mode_control:219">
 <semantics>
  <mrow>
   <mi>𝐞</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>e</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>e</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>e</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>𝐞</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{e}=(e_{1},e_{2},\dots,e_{n})\in\mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

 be the state estimator error. That is, 

<math display="inline" id="Sliding_mode_control:220">
 <semantics>
  <mrow>
   <mi>𝐞</mi>
   <mo>=</mo>
   <mrow>
    <mover accent="true">
     <mi>𝐱</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>-</mo>
    <mi>𝐱</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐞</ci>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-^</ci>
      <ci>𝐱</ci>
     </apply>
     <ci>𝐱</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{e}=\hat{\mathbf{x}}-\mathbf{x}
  </annotation>
 </semantics>
</math>

. The error dynamics are then</p>

<p>

<math display="block" id="Sliding_mode_control:221">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mover accent="true">
        <mi>𝐞</mi>
        <mo>˙</mo>
       </mover>
       <mo>=</mo>
       <mrow>
        <mover accent="true">
         <mover accent="true">
          <mi>𝐱</mi>
          <mo stretchy="false">^</mo>
         </mover>
         <mo>˙</mo>
        </mover>
        <mo>-</mo>
        <mover accent="true">
         <mi>𝐱</mi>
         <mo>˙</mo>
        </mover>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mi></mi>
       <mo>=</mo>
       <mrow>
        <mrow>
         <mrow>
          <mi>A</mi>
          <mover accent="true">
           <mi>𝐱</mi>
           <mo stretchy="false">^</mo>
          </mover>
         </mrow>
         <mo>+</mo>
         <mrow>
          <mi>B</mi>
          <mi>𝐮</mi>
         </mrow>
         <mo>+</mo>
         <mrow>
          <mi>L</mi>
          <mi>v</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <msub>
             <mover accent="true">
              <mi>x</mi>
              <mo stretchy="false">^</mo>
             </mover>
             <mn>1</mn>
            </msub>
            <mo>-</mo>
            <msub>
             <mi>x</mi>
             <mn>1</mn>
            </msub>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>A</mi>
         <mi>𝐱</mi>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mi>B</mi>
         <mi>𝐮</mi>
        </mrow>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mi></mi>
       <mo>=</mo>
       <mrow>
        <mrow>
         <mi>A</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mover accent="true">
            <mi>𝐱</mi>
            <mo stretchy="false">^</mo>
           </mover>
           <mo>-</mo>
           <mi>𝐱</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>L</mi>
         <mi>v</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mover accent="true">
             <mi>x</mi>
             <mo stretchy="false">^</mo>
            </mover>
            <mn>1</mn>
           </msub>
           <mo>-</mo>
           <msub>
            <mi>x</mi>
            <mn>1</mn>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mi></mi>
       <mo>=</mo>
       <mrow>
        <mrow>
         <mi>A</mi>
         <mi>𝐞</mi>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>L</mi>
         <mi>v</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>e</mi>
           <mn>1</mn>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
   </mtable>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">cases</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-˙</ci>
      <ci>𝐞</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <ci>normal-˙</ci>
       <apply>
        <ci>normal-^</ci>
        <ci>𝐱</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-˙</ci>
       <ci>𝐱</ci>
      </apply>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>A</ci>
        <apply>
         <ci>normal-^</ci>
         <ci>𝐱</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>B</ci>
        <ci>𝐮</ci>
       </apply>
       <apply>
        <times></times>
        <ci>L</ci>
        <ci>v</ci>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-^</ci>
           <ci>x</ci>
          </apply>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>𝐱</ci>
      </apply>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>𝐮</ci>
      </apply>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>A</ci>
       <apply>
        <minus></minus>
        <apply>
         <ci>normal-^</ci>
         <ci>𝐱</ci>
        </apply>
        <ci>𝐱</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>L</ci>
       <ci>v</ci>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-^</ci>
          <ci>x</ci>
         </apply>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>𝐞</ci>
      </apply>
      <apply>
       <times></times>
       <ci>L</ci>
       <ci>v</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{cases}\dot{\mathbf{e}}=\dot{\hat{\mathbf{x}}}-\dot{\mathbf{x}}\\
=A\hat{\mathbf{x}}+B\mathbf{u}+Lv(\hat{x}_{1}-x_{1})-A\mathbf{x}-B\mathbf{u}\\
=A(\hat{\mathbf{x}}-\mathbf{x})+Lv(\hat{x}_{1}-x_{1})\\
=A\mathbf{e}+Lv(e_{1})\end{cases}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Sliding_mode_control:222">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mn>1</mn>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>x</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1}=\hat{x}_{1}-x_{1}
  </annotation>
 </semantics>
</math>

 is the estimator error for the first state estimate. The nonlinear control law 

<math display="inline" id="Sliding_mode_control:223">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 can be designed to enforce the sliding manifold</p>

<p>

<math display="block" id="Sliding_mode_control:224">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>=</mo>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mn>1</mn>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <cn type="integer">0</cn>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>x</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0=\hat{x}_{1}-x_{1}
  </annotation>
 </semantics>
</math>

 so that estimate 

<math display="inline" id="Sliding_mode_control:225">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>x</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{x}_{1}
  </annotation>
 </semantics>
</math>

 tracks the real state 

<math display="inline" id="Sliding_mode_control:226">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 after some finite time (i.e., 

<math display="inline" id="Sliding_mode_control:227">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>x</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{x}_{1}=x_{1}
  </annotation>
 </semantics>
</math>

). Hence, the sliding mode control switching function</p>

<p>

<math display="block" id="Sliding_mode_control:228">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>σ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mover accent="true">
        <mi>x</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mover accent="true">
       <mi>x</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≜</mo>
    <msub>
     <mi>e</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>x</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mn>1</mn>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-≜</ci>
     <apply>
      <times></times>
      <ci>σ</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>x</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <ci>normal-^</ci>
        <ci>x</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <ci>x</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\hat{x}_{1},\hat{x})\triangleq e_{1}=\hat{x}_{1}-x_{1}.
  </annotation>
 </semantics>
</math>

 To attain the sliding manifold, 

<math display="inline" id="Sliding_mode_control:229">
 <semantics>
  <mover accent="true">
   <mi>σ</mi>
   <mo>˙</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-˙</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\sigma}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sliding_mode_control:230">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 must always have opposite signs (i.e., 

<math display="inline" id="Sliding_mode_control:231">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mover accent="true">
     <mi>σ</mi>
     <mo>˙</mo>
    </mover>
   </mrow>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>σ</ci>
     <apply>
      <ci>normal-˙</ci>
      <ci>σ</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\dot{\sigma}<0
  </annotation>
 </semantics>
</math>

 for <a href="almost_everywhere" title="wikilink">essentially</a> all 

<math display="inline" id="Sliding_mode_control:232">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

). However,</p>

<p>

<math display="block" id="Sliding_mode_control:233">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>σ</mi>
    <mo>˙</mo>
   </mover>
   <mo>=</mo>
   <msub>
    <mover accent="true">
     <mi>e</mi>
     <mo>˙</mo>
    </mover>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>11</mn>
      </msub>
      <msub>
       <mi>e</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>A</mi>
       <mn>12</mn>
      </msub>
      <msub>
       <mi>𝐞</mi>
       <mn>2</mn>
      </msub>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>v</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>e</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>11</mn>
      </msub>
      <msub>
       <mi>e</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>A</mi>
       <mn>12</mn>
      </msub>
      <msub>
       <mi>𝐞</mi>
       <mn>2</mn>
      </msub>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>v</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>σ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-˙</ci>
      <ci>σ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-˙</ci>
       <ci>e</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">11</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <cn type="integer">12</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐞</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>v</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">11</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <cn type="integer">12</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐞</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>v</ci>
       <ci>σ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{\sigma}=\dot{e}_{1}=a_{11}e_{1}+A_{12}\mathbf{e}_{2}-v(e_{1})=a_{11}e_{1}%
+A_{12}\mathbf{e}_{2}-v(\sigma)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Sliding_mode_control:234">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐞</mi>
    <mn>2</mn>
   </msub>
   <mo>≜</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>e</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>e</mi>
     <mn>3</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>e</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-≜</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐞</ci>
      <cn type="integer">2</cn>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <cn type="integer">3</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{e}_{2}\triangleq(e_{2},e_{3},\ldots,e_{n})\in\mathbb{R}^{(n-1)}
  </annotation>
 </semantics>
</math>

 is the collection of the estimator errors for all of the unmeasured states. To ensure that 

<math display="inline" id="Sliding_mode_control:235">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mover accent="true">
     <mi>σ</mi>
     <mo>˙</mo>
    </mover>
   </mrow>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>σ</ci>
     <apply>
      <ci>normal-˙</ci>
      <ci>σ</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\dot{\sigma}<0
  </annotation>
 </semantics>
</math>

, let</p>

<p>

<math display="block" id="Sliding_mode_control:236">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>σ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>M</mi>
    <mrow>
     <mo>sgn</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>σ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>σ</ci>
    </apply>
    <apply>
     <times></times>
     <ci>M</ci>
     <apply>
      <ci>sgn</ci>
      <ci>σ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(\sigma)=M\operatorname{sgn}(\sigma)
  </annotation>
 </semantics>
</math>

 where</p>

<p>

<math display="block" id="Sliding_mode_control:237">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mo>></mo>
    <mrow>
     <mi>max</mi>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>a</mi>
          <mn>11</mn>
         </msub>
         <msub>
          <mi>e</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msub>
          <mi>A</mi>
          <mn>12</mn>
         </msub>
         <msub>
          <mi>𝐞</mi>
          <mn>2</mn>
         </msub>
        </mrow>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>M</ci>
    <apply>
     <max></max>
     <apply>
      <abs></abs>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">11</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>e</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <cn type="integer">12</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐞</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M>\max\{|a_{11}e_{1}+A_{12}\mathbf{e}_{2}|\}.
  </annotation>
 </semantics>
</math>

 That is, positive constant 

<math display="inline" id="Sliding_mode_control:238">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 must be greater than a scaled version of the maximum possible estimator errors for the system (i.e., the initial errors, which are assumed to be bounded so that 

<math display="inline" id="Sliding_mode_control:239">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 can be picked large enough; al). If 

<math display="inline" id="Sliding_mode_control:240">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is sufficiently large, it can be assumed that the system achieves 

<math display="inline" id="Sliding_mode_control:241">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1}=0
  </annotation>
 </semantics>
</math>

 (i.e., 

<math display="inline" id="Sliding_mode_control:242">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>x</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{x}_{1}=x_{1}
  </annotation>
 </semantics>
</math>

). Because 

<math display="inline" id="Sliding_mode_control:243">
 <semantics>
  <msub>
   <mi>e</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1}
  </annotation>
 </semantics>
</math>

 is constant (i.e., 0) along this manifold, 

<math display="inline" id="Sliding_mode_control:244">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>e</mi>
     <mo>˙</mo>
    </mover>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-˙</ci>
      <ci>e</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{e}_{1}=0
  </annotation>
 </semantics>
</math>

 as well. Hence, the discontinuous control 

<math display="inline" id="Sliding_mode_control:245">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>σ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>v</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(\sigma)
  </annotation>
 </semantics>
</math>

 may be replaced with the equivalent continuous control 

<math display="inline" id="Sliding_mode_control:246">
 <semantics>
  <msub>
   <mi>v</mi>
   <mtext>eq</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <mtext>eq</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{\text{eq}}
  </annotation>
 </semantics>
</math>

 where</p>

<p>

<math display="block" id="Sliding_mode_control:247">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo>=</mo>
    <mover accent="true">
     <mi>σ</mi>
     <mo>˙</mo>
    </mover>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mi>a</mi>
        <mn>11</mn>
       </msub>
       <mover>
        <mover accent="true">
         <msub>
          <mi>e</mi>
          <mn>1</mn>
         </msub>
         <mo movablelimits="false">⏞</mo>
        </mover>
        <mrow>
         <mi></mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
       </mover>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>A</mi>
        <mn>12</mn>
       </msub>
       <msub>
        <mi>𝐞</mi>
        <mn>2</mn>
       </msub>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mover>
      <mover accent="true">
       <msub>
        <mi>v</mi>
        <mtext>eq</mtext>
       </msub>
       <mo movablelimits="false">⏞</mo>
      </mover>
      <mrow>
       <mi>v</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>σ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mover>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>A</mi>
       <mn>12</mn>
      </msub>
      <msub>
       <mi>𝐞</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo>-</mo>
     <msub>
      <mi>v</mi>
      <mtext>eq</mtext>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <cn type="integer">0</cn>
     <apply>
      <ci>normal-˙</ci>
      <ci>σ</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">11</cn>
        </apply>
        <ci>
         <mover>
          <mover accent="true">
           <msub>
            <mi>e</mi>
            <mn>1</mn>
           </msub>
           <mo movablelimits="false">⏞</mo>
          </mover>
          <mrow>
           <mi></mi>
           <mo>=</mo>
           <mn>0</mn>
          </mrow>
         </mover>
        </ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <cn type="integer">12</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐞</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <ci>
       <mover>
        <mover accent="true">
         <msub>
          <mi>v</mi>
          <mtext>eq</mtext>
         </msub>
         <mo movablelimits="false">⏞</mo>
        </mover>
        <mrow>
         <mi>v</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>σ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mover>
      </ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">12</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐞</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <mtext>eq</mtext>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0=\dot{\sigma}=a_{11}\mathord{\overbrace{e_{1}}^{{}=0}}+A_{12}\mathbf{e}_{2}-%
\mathord{\overbrace{v_{\text{eq}}}^{v(\sigma)}}=A_{12}\mathbf{e}_{2}-v_{\text{%
eq}}.
  </annotation>
 </semantics>
</math>

 So</p>

<p>

<math display="block" id="Sliding_mode_control:248">
 <semantics>
  <mrow>
   <mrow>
    <mover>
     <mover accent="true">
      <msub>
       <mi>v</mi>
       <mtext>eq</mtext>
      </msub>
      <mo movablelimits="false">⏞</mo>
     </mover>
     <mtext>scalar</mtext>
    </mover>
    <mo>=</mo>
    <mrow>
     <mover>
      <mover accent="true">
       <msub>
        <mi>A</mi>
        <mn>12</mn>
       </msub>
       <mo movablelimits="false">⏞</mo>
      </mover>
      <mrow>
       <mrow>
        <mn>1</mn>
        <mo>×</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mtext>vector</mtext>
      </mrow>
     </mover>
     <mover>
      <mover accent="true">
       <msub>
        <mi>𝐞</mi>
        <mn>2</mn>
       </msub>
       <mo movablelimits="false">⏞</mo>
      </mover>
      <mrow>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>×</mo>
        <mn>1</mn>
       </mrow>
       <mtext>vector</mtext>
      </mrow>
     </mover>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>
     <mover>
      <mover accent="true">
       <msub>
        <mi>v</mi>
        <mtext>eq</mtext>
       </msub>
       <mo movablelimits="false">⏞</mo>
      </mover>
      <mtext>scalar</mtext>
     </mover>
    </ci>
    <apply>
     <times></times>
     <ci>
      <mover>
       <mover accent="true">
        <msub>
         <mi>A</mi>
         <mn>12</mn>
        </msub>
        <mo movablelimits="false">⏞</mo>
       </mover>
       <mrow>
        <mrow>
         <mn>1</mn>
         <mo>×</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mtext>vector</mtext>
       </mrow>
      </mover>
     </ci>
     <ci>
      <mover>
       <mover accent="true">
        <msub>
         <mi>𝐞</mi>
         <mn>2</mn>
        </msub>
        <mo movablelimits="false">⏞</mo>
       </mover>
       <mrow>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>×</mo>
         <mn>1</mn>
        </mrow>
        <mtext>vector</mtext>
       </mrow>
      </mover>
     </ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathord{\overbrace{v_{\text{eq}}}^{\text{scalar}}}=\mathord{\overbrace{A_{12}%
}^{1\times(n-1)\text{ vector}}}\mathord{\overbrace{\mathbf{e}_{2}}^{(n-1)%
\times 1\text{ vector}}}.
  </annotation>
 </semantics>
</math>

 This equivalent control 

<math display="inline" id="Sliding_mode_control:249">
 <semantics>
  <msub>
   <mi>v</mi>
   <mtext>eq</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <mtext>eq</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{\text{eq}}
  </annotation>
 </semantics>
</math>

 represents the contribution from the other 

<math display="inline" id="Sliding_mode_control:250">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n-1)
  </annotation>
 </semantics>
</math>

 states to the trajectory of the output state 

<math display="inline" id="Sliding_mode_control:251">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

. In particular, the row 

<math display="inline" id="Sliding_mode_control:252">
 <semantics>
  <msub>
   <mi>A</mi>
   <mn>12</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <cn type="integer">12</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{12}
  </annotation>
 </semantics>
</math>

 acts like an output vector for the error subsystem</p>

<p>

<math display="block" id="Sliding_mode_control:253">
 <semantics>
  <mrow>
   <mrow>
    <mover>
     <mover accent="true">
      <mrow>
       <mo movablelimits="false">[</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mover accent="true">
            <mi>e</mi>
            <mo movablelimits="false">˙</mo>
           </mover>
           <mn>2</mn>
          </msub>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mover accent="true">
            <mi>e</mi>
            <mo movablelimits="false">˙</mo>
           </mover>
           <mn>3</mn>
          </msub>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mi mathvariant="normal">⋮</mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mover accent="true">
            <mi>e</mi>
            <mo movablelimits="false">˙</mo>
           </mover>
           <mi>n</mi>
          </msub>
         </mtd>
        </mtr>
       </mtable>
       <mo movablelimits="false">]</mo>
      </mrow>
      <mo movablelimits="false">⏞</mo>
     </mover>
     <msub>
      <mover accent="true">
       <mi>𝐞</mi>
       <mo>˙</mo>
      </mover>
      <mn>2</mn>
     </msub>
    </mover>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>A</mi>
       <mn>2</mn>
      </msub>
      <mover>
       <mover accent="true">
        <mrow>
         <mo movablelimits="false">[</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="center">
            <msub>
             <mi>e</mi>
             <mn>2</mn>
            </msub>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <msub>
             <mi>e</mi>
             <mn>3</mn>
            </msub>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mi mathvariant="normal">⋮</mi>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <msub>
             <mi>e</mi>
             <mi>n</mi>
            </msub>
           </mtd>
          </mtr>
         </mtable>
         <mo movablelimits="false">]</mo>
        </mrow>
        <mo movablelimits="false">⏞</mo>
       </mover>
       <msub>
        <mi>𝐞</mi>
        <mn>2</mn>
       </msub>
      </mover>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>L</mi>
       <mn>2</mn>
      </msub>
      <mi>v</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>e</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>A</mi>
       <mn>2</mn>
      </msub>
      <msub>
       <mi>𝐞</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>L</mi>
       <mn>2</mn>
      </msub>
      <msub>
       <mi>v</mi>
       <mtext>eq</mtext>
      </msub>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>A</mi>
       <mn>2</mn>
      </msub>
      <msub>
       <mi>𝐞</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>L</mi>
       <mn>2</mn>
      </msub>
      <msub>
       <mi>A</mi>
       <mn>12</mn>
      </msub>
      <msub>
       <mi>𝐞</mi>
       <mn>2</mn>
      </msub>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>A</mi>
        <mn>2</mn>
       </msub>
       <mo>+</mo>
       <mrow>
        <msub>
         <mi>L</mi>
         <mn>2</mn>
        </msub>
        <msub>
         <mi>A</mi>
         <mn>12</mn>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>𝐞</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>
      <mover>
       <mover accent="true">
        <mrow>
         <mo movablelimits="false">[</mo>
         <mtable>
          <mtr>
           <mtd columnalign="center">
            <msub>
             <mover accent="true">
              <mi>e</mi>
              <mo movablelimits="false">˙</mo>
             </mover>
             <mn>2</mn>
            </msub>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <msub>
             <mover accent="true">
              <mi>e</mi>
              <mo movablelimits="false">˙</mo>
             </mover>
             <mn>3</mn>
            </msub>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mi mathvariant="normal">⋮</mi>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <msub>
             <mover accent="true">
              <mi>e</mi>
              <mo movablelimits="false">˙</mo>
             </mover>
             <mi>n</mi>
            </msub>
           </mtd>
          </mtr>
         </mtable>
         <mo movablelimits="false">]</mo>
        </mrow>
        <mo movablelimits="false">⏞</mo>
       </mover>
       <msub>
        <mover accent="true">
         <mi>𝐞</mi>
         <mo>˙</mo>
        </mover>
        <mn>2</mn>
       </msub>
      </mover>
     </ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>
        <mover>
         <mover accent="true">
          <mrow>
           <mo movablelimits="false">[</mo>
           <mtable>
            <mtr>
             <mtd columnalign="center">
              <msub>
               <mi>e</mi>
               <mn>2</mn>
              </msub>
             </mtd>
            </mtr>
            <mtr>
             <mtd columnalign="center">
              <msub>
               <mi>e</mi>
               <mn>3</mn>
              </msub>
             </mtd>
            </mtr>
            <mtr>
             <mtd columnalign="center">
              <mi mathvariant="normal">⋮</mi>
             </mtd>
            </mtr>
            <mtr>
             <mtd columnalign="center">
              <msub>
               <mi>e</mi>
               <mi>n</mi>
              </msub>
             </mtd>
            </mtr>
           </mtable>
           <mo movablelimits="false">]</mo>
          </mrow>
          <mo movablelimits="false">⏞</mo>
         </mover>
         <msub>
          <mi>𝐞</mi>
          <mn>2</mn>
         </msub>
        </mover>
       </ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>v</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐞</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <mtext>eq</mtext>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐞</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">12</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐞</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <cn type="integer">12</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐞</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathord{\overbrace{\begin{bmatrix}\dot{e}_{2}\\
\dot{e}_{3}\\
\vdots\\
\dot{e}_{n}\end{bmatrix}}^{\dot{\mathbf{e}}_{2}}}=A_{2}\mathord{\overbrace{%
\begin{bmatrix}e_{2}\\
e_{3}\\
\vdots\\
e_{n}\end{bmatrix}}^{\mathbf{e}_{2}}}+L_{2}v(e_{1})=A_{2}\mathbf{e}_{2}+L_{2}v%
_{\text{eq}}=A_{2}\mathbf{e}_{2}+L_{2}A_{12}\mathbf{e}_{2}=(A_{2}+L_{2}A_{12})%
\mathbf{e}_{2}.
  </annotation>
 </semantics>
</math>

 So, to ensure the estimator error 

<math display="inline" id="Sliding_mode_control:254">
 <semantics>
  <msub>
   <mi>𝐞</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐞</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{e}_{2}
  </annotation>
 </semantics>
</math>

 for the unmeasured states converges to zero, the 

<math display="inline" id="Sliding_mode_control:255">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>×</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n-1)\times 1
  </annotation>
 </semantics>
</math>

 vector 

<math display="inline" id="Sliding_mode_control:256">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{2}
  </annotation>
 </semantics>
</math>

 must be chosen so that the 

<math display="inline" id="Sliding_mode_control:257">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>×</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n-1)\times(n-1)
  </annotation>
 </semantics>
</math>

 matrix 

<math display="inline" id="Sliding_mode_control:258">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>A</mi>
     <mn>2</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>L</mi>
      <mn>2</mn>
     </msub>
     <msub>
      <mi>A</mi>
      <mn>12</mn>
     </msub>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">12</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A_{2}+L_{2}A_{12})
  </annotation>
 </semantics>
</math>

 is <a href="Hurwitz_matrix" title="wikilink">Hurwitz</a> (i.e., the real part of each of its <a href="eigenvalue" title="wikilink">eigenvalues</a> must be negative). Hence, provided that it is <a class="uri" href="observable" title="wikilink">observable</a>, this 

<math display="inline" id="Sliding_mode_control:259">
 <semantics>
  <msub>
   <mi>𝐞</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐞</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{e}_{2}
  </annotation>
 </semantics>
</math>

 system can be stabilized in exactly the same way as a typical linear <a href="state_observer" title="wikilink">state observer</a> when 

<math display="inline" id="Sliding_mode_control:260">
 <semantics>
  <msub>
   <mi>A</mi>
   <mn>12</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <cn type="integer">12</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{12}
  </annotation>
 </semantics>
</math>

 is viewed as the output matrix (i.e., "

<math display="inline" id="Sliding_mode_control:261">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

"). That is, the 

<math display="inline" id="Sliding_mode_control:262">
 <semantics>
  <msub>
   <mi>v</mi>
   <mtext>eq</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <mtext>eq</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{\text{eq}}
  </annotation>
 </semantics>
</math>

 equivalent control provides measurement information about the unmeasured states that can continually move their estimates asymptotically closer to them. Meanwhile, the discontinuous control 

<math display="inline" id="Sliding_mode_control:263">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>=</mo>
   <mrow>
    <mi>M</mi>
    <mrow>
     <mo>sgn</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mover accent="true">
         <mi>x</mi>
         <mo stretchy="false">^</mo>
        </mover>
        <mn>1</mn>
       </msub>
       <mo>-</mo>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>v</ci>
    <apply>
     <times></times>
     <ci>M</ci>
     <apply>
      <ci>sgn</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>x</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v=M\operatorname{sgn}(\hat{x}_{1}-x)
  </annotation>
 </semantics>
</math>

 forces the estimate of the measured state to have zero error in finite time. Additionally, white zero-mean symmetric measurement noise (e.g., <a href="Normal_distribution" title="wikilink">Gaussian noise</a>) only affects the switching frequency of the control 

<math display="inline" id="Sliding_mode_control:264">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

, and hence the noise will have little effect on the equivalent sliding mode control 

<math display="inline" id="Sliding_mode_control:265">
 <semantics>
  <msub>
   <mi>v</mi>
   <mtext>eq</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <mtext>eq</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{\text{eq}}
  </annotation>
 </semantics>
</math>

. Hence, the sliding mode observer has <a href="Kalman_filter" title="wikilink">Kalman filter</a>–like features.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>The final version of the observer is thus</p>

<p>

<math display="block" id="Sliding_mode_control:266">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mover accent="true">
        <mover accent="true">
         <mi>𝐱</mi>
         <mo stretchy="false">^</mo>
        </mover>
        <mo>˙</mo>
       </mover>
       <mo>=</mo>
       <mrow>
        <mrow>
         <mi>A</mi>
         <mover accent="true">
          <mi>𝐱</mi>
          <mo stretchy="false">^</mo>
         </mover>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>B</mi>
         <mi>𝐮</mi>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>L</mi>
         <mi>M</mi>
         <mrow>
          <mo>sgn</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <msub>
             <mover accent="true">
              <mi>x</mi>
              <mo stretchy="false">^</mo>
             </mover>
             <mn>1</mn>
            </msub>
            <mo>-</mo>
            <msub>
             <mi>x</mi>
             <mn>1</mn>
            </msub>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mi></mi>
       <mo>=</mo>
       <mrow>
        <mrow>
         <mi>A</mi>
         <mover accent="true">
          <mi>𝐱</mi>
          <mo stretchy="false">^</mo>
         </mover>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>B</mi>
         <mi>𝐮</mi>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mrow>
          <mo>[</mo>
          <mtable displaystyle="true">
           <mtr>
            <mtd columnalign="center">
             <mrow>
              <mo>-</mo>
              <mn>1</mn>
             </mrow>
            </mtd>
           </mtr>
           <mtr>
            <mtd columnalign="center">
             <msub>
              <mi>L</mi>
              <mn>2</mn>
             </msub>
            </mtd>
           </mtr>
          </mtable>
          <mo>]</mo>
         </mrow>
         <mi>M</mi>
         <mrow>
          <mo>sgn</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <msub>
             <mover accent="true">
              <mi>x</mi>
              <mo stretchy="false">^</mo>
             </mover>
             <mn>1</mn>
            </msub>
            <mo>-</mo>
            <msub>
             <mi>x</mi>
             <mn>1</mn>
            </msub>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mi></mi>
       <mo>=</mo>
       <mrow>
        <mrow>
         <mi>A</mi>
         <mover accent="true">
          <mi>𝐱</mi>
          <mo stretchy="false">^</mo>
         </mover>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>B</mi>
         <mi>𝐮</mi>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mrow>
          <mo>[</mo>
          <mtable displaystyle="true">
           <mtr>
            <mtd columnalign="center">
             <mrow>
              <mo>-</mo>
              <mi>M</mi>
             </mrow>
            </mtd>
           </mtr>
           <mtr>
            <mtd columnalign="center">
             <mrow>
              <msub>
               <mi>L</mi>
               <mn>2</mn>
              </msub>
              <mi>M</mi>
             </mrow>
            </mtd>
           </mtr>
          </mtable>
          <mo>]</mo>
         </mrow>
         <mrow>
          <mo>sgn</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <msub>
             <mover accent="true">
              <mi>x</mi>
              <mo stretchy="false">^</mo>
             </mover>
             <mn>1</mn>
            </msub>
            <mo>-</mo>
            <msub>
             <mi>x</mi>
             <mn>1</mn>
            </msub>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mi></mi>
       <mo>=</mo>
       <mrow>
        <mrow>
         <mi>A</mi>
         <mover accent="true">
          <mi>𝐱</mi>
          <mo stretchy="false">^</mo>
         </mover>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mrow>
          <mo>[</mo>
          <mtable displaystyle="true">
           <mtr>
            <mtd columnalign="center">
             <mi>B</mi>
            </mtd>
            <mtd columnalign="center">
             <mrow>
              <mo>[</mo>
              <mtable displaystyle="true">
               <mtr>
                <mtd columnalign="center">
                 <mrow>
                  <mo>-</mo>
                  <mi>M</mi>
                 </mrow>
                </mtd>
               </mtr>
               <mtr>
                <mtd columnalign="center">
                 <mrow>
                  <msub>
                   <mi>L</mi>
                   <mn>2</mn>
                  </msub>
                  <mi>M</mi>
                 </mrow>
                </mtd>
               </mtr>
              </mtable>
              <mo>]</mo>
             </mrow>
            </mtd>
           </mtr>
          </mtable>
          <mo>]</mo>
         </mrow>
         <mrow>
          <mo>[</mo>
          <mtable displaystyle="true">
           <mtr>
            <mtd columnalign="center">
             <mi>𝐮</mi>
            </mtd>
           </mtr>
           <mtr>
            <mtd columnalign="center">
             <mrow>
              <mo>sgn</mo>
              <mrow>
               <mo stretchy="false">(</mo>
               <mrow>
                <msub>
                 <mover accent="true">
                  <mi>x</mi>
                  <mo stretchy="false">^</mo>
                 </mover>
                 <mn>1</mn>
                </msub>
                <mo>-</mo>
                <msub>
                 <mi>x</mi>
                 <mn>1</mn>
                </msub>
               </mrow>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
            </mtd>
           </mtr>
          </mtable>
          <mo>]</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mi></mi>
       <mo>=</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>A</mi>
          <mtext>obs</mtext>
         </msub>
         <mover accent="true">
          <mi>𝐱</mi>
          <mo stretchy="false">^</mo>
         </mover>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msub>
          <mi>B</mi>
          <mtext>obs</mtext>
         </msub>
         <msub>
          <mi>𝐮</mi>
          <mtext>obs</mtext>
         </msub>
        </mrow>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
   </mtable>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">cases</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-˙</ci>
      <apply>
       <ci>normal-^</ci>
       <ci>𝐱</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>A</ci>
       <apply>
        <ci>normal-^</ci>
        <ci>𝐱</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>𝐮</ci>
      </apply>
      <apply>
       <times></times>
       <ci>L</ci>
       <ci>M</ci>
       <apply>
        <ci>sgn</ci>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-^</ci>
           <ci>x</ci>
          </apply>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>A</ci>
       <apply>
        <ci>normal-^</ci>
        <ci>𝐱</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>𝐮</ci>
      </apply>
      <apply>
       <times></times>
       <matrix>
        <matrixrow>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>L</ci>
          <cn type="integer">2</cn>
         </apply>
        </matrixrow>
       </matrix>
       <ci>M</ci>
       <apply>
        <ci>sgn</ci>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-^</ci>
           <ci>x</ci>
          </apply>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>A</ci>
       <apply>
        <ci>normal-^</ci>
        <ci>𝐱</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>𝐮</ci>
      </apply>
      <apply>
       <times></times>
       <matrix>
        <matrixrow>
         <apply>
          <minus></minus>
          <ci>M</ci>
         </apply>
        </matrixrow>
        <matrixrow>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>L</ci>
           <cn type="integer">2</cn>
          </apply>
          <ci>M</ci>
         </apply>
        </matrixrow>
       </matrix>
       <apply>
        <ci>sgn</ci>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-^</ci>
           <ci>x</ci>
          </apply>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>A</ci>
       <apply>
        <ci>normal-^</ci>
        <ci>𝐱</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <matrix>
        <matrixrow>
         <ci>B</ci>
         <matrix>
          <matrixrow>
           <apply>
            <minus></minus>
            <ci>M</ci>
           </apply>
          </matrixrow>
          <matrixrow>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>L</ci>
             <cn type="integer">2</cn>
            </apply>
            <ci>M</ci>
           </apply>
          </matrixrow>
         </matrix>
        </matrixrow>
       </matrix>
       <matrix>
        <matrixrow>
         <ci>𝐮</ci>
        </matrixrow>
        <matrixrow>
         <apply>
          <ci>sgn</ci>
          <apply>
           <minus></minus>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <apply>
             <ci>normal-^</ci>
             <ci>x</ci>
            </apply>
            <cn type="integer">1</cn>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
         </apply>
        </matrixrow>
       </matrix>
      </apply>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <mtext>obs</mtext>
       </apply>
       <apply>
        <ci>normal-^</ci>
        <ci>𝐱</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <mtext>obs</mtext>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐮</ci>
        <mtext>obs</mtext>
       </apply>
      </apply>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{cases}\dot{\hat{\mathbf{x}}}=A\hat{\mathbf{x}}+B\mathbf{u}+LM%
\operatorname{sgn}(\hat{x}_{1}-x_{1})\\
=A\hat{\mathbf{x}}+B\mathbf{u}+\begin{bmatrix}-1\\
L_{2}\end{bmatrix}M\operatorname{sgn}(\hat{x}_{1}-x_{1})\\
=A\hat{\mathbf{x}}+B\mathbf{u}+\begin{bmatrix}-M\\
L_{2}M\end{bmatrix}\operatorname{sgn}(\hat{x}_{1}-x_{1})\\
=A\hat{\mathbf{x}}+\begin{bmatrix}B&\begin{bmatrix}-M\\
L_{2}M\end{bmatrix}\end{bmatrix}\begin{bmatrix}\mathbf{u}\\
\operatorname{sgn}(\hat{x}_{1}-x_{1})\end{bmatrix}\\
=A_{\text{obs}}\hat{\mathbf{x}}+B_{\text{obs}}\mathbf{u}_{\text{obs}}\end{cases}
  </annotation>
 </semantics>
</math>

 where</p>
<ul>
<li>

<math display="inline" id="Sliding_mode_control:267">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mtext>obs</mtext>
   </msub>
   <mo>≜</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-≜</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <mtext>obs</mtext>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{\text{obs}}\triangleq A
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Sliding_mode_control:268">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mtext>obs</mtext>
   </msub>
   <mo>≜</mo>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mi>B</mi>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>[</mo>
        <mtable>
         <mtr>
          <mtd columnalign="center">
           <mrow>
            <mo>-</mo>
            <mi>M</mi>
           </mrow>
          </mtd>
         </mtr>
         <mtr>
          <mtd columnalign="center">
           <mrow>
            <msub>
             <mi>L</mi>
             <mn>2</mn>
            </msub>
            <mi>M</mi>
           </mrow>
          </mtd>
         </mtr>
        </mtable>
        <mo>]</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-≜</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <mtext>obs</mtext>
    </apply>
    <matrix>
     <matrixrow>
      <ci>B</ci>
      <matrix>
       <matrixrow>
        <apply>
         <minus></minus>
         <ci>M</ci>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>L</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>M</ci>
        </apply>
       </matrixrow>
      </matrix>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{\text{obs}}\triangleq\begin{bmatrix}B&\begin{bmatrix}-M\\
L_{2}M\end{bmatrix}\end{bmatrix}
  </annotation>
 </semantics>
</math>

, and</li>
<li>

<math display="inline" id="Sliding_mode_control:269">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mtext>obs</mtext>
   </msub>
   <mo>≜</mo>
   <mrow>
    <mo>[</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mi>𝐮</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>sgn</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mover accent="true">
            <mi>x</mi>
            <mo stretchy="false">^</mo>
           </mover>
           <mn>1</mn>
          </msub>
          <mo>-</mo>
          <msub>
           <mi>x</mi>
           <mn>1</mn>
          </msub>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-≜</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <mtext>obs</mtext>
    </apply>
    <matrix>
     <matrixrow>
      <ci>𝐮</ci>
     </matrixrow>
     <matrixrow>
      <apply>
       <ci>sgn</ci>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-^</ci>
          <ci>x</ci>
         </apply>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{\text{obs}}\triangleq\begin{bmatrix}\mathbf{u}\\
\operatorname{sgn}(\hat{x}_{1}-x_{1})\end{bmatrix}
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>That is, by augmenting the control vector 

<math display="inline" id="Sliding_mode_control:270">
 <semantics>
  <mi>𝐮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}
  </annotation>
 </semantics>
</math>

 with the switching function 

<math display="inline" id="Sliding_mode_control:271">
 <semantics>
  <mrow>
   <mo>sgn</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>x</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mn>1</mn>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>sgn</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>x</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sgn}(\hat{x}_{1}-x_{1})
  </annotation>
 </semantics>
</math>

, the sliding mode observer can be implemented as an LTI system. That is, the discontinuous signal 

<math display="inline" id="Sliding_mode_control:272">
 <semantics>
  <mrow>
   <mo>sgn</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>x</mi>
       <mo stretchy="false">^</mo>
      </mover>
      <mn>1</mn>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>sgn</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>x</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sgn}(\hat{x}_{1}-x_{1})
  </annotation>
 </semantics>
</math>

 is viewed as a control <em>input</em> to the 2-input LTI system.</p>

<p>For simplicity, this example assumes that the sliding mode observer has access to a measurement of a single state (i.e., output 

<math display="inline" id="Sliding_mode_control:273">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=x_{1}
  </annotation>
 </semantics>
</math>

). However, a similar procedure can be used to design a sliding mode observer for a vector of weighted combinations of states (i.e., when output 

<math display="inline" id="Sliding_mode_control:274">
 <semantics>
  <mrow>
   <mi>𝐲</mi>
   <mo>=</mo>
   <mrow>
    <mi>C</mi>
    <mi>𝐱</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐲</ci>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>𝐱</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}=C\mathbf{x}
  </annotation>
 </semantics>
</math>

 uses a generic matrix 

<math display="inline" id="Sliding_mode_control:275">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

). In each case, the sliding mode will be the manifold where the estimated output 

<math display="inline" id="Sliding_mode_control:276">
 <semantics>
  <mover accent="true">
   <mi>𝐲</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>𝐲</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{y}}
  </annotation>
 </semantics>
</math>

 follows the measured output 

<math display="inline" id="Sliding_mode_control:277">
 <semantics>
  <mi>𝐲</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐲</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}
  </annotation>
 </semantics>
</math>

 with zero error (i.e., the manifold where 

<math display="inline" id="Sliding_mode_control:278">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≜</mo>
   <mrow>
    <mover accent="true">
     <mi>𝐲</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>-</mo>
    <mi>𝐲</mi>
   </mrow>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-≜</ci>
     <apply>
      <times></times>
      <ci>σ</ci>
      <ci>𝐱</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <ci>normal-^</ci>
       <ci>𝐲</ci>
      </apply>
      <ci>𝐲</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{x})\triangleq\hat{\mathbf{y}}-\mathbf{y}=\mathbf{0}
  </annotation>
 </semantics>
</math>

).</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Variable_structure_control" title="wikilink">Variable structure control</a></li>
<li><a href="Variable_structure_system" title="wikilink">Variable structure system</a></li>
<li><a href="Hybrid_system" title="wikilink">Hybrid system</a></li>
<li><a href="Nonlinear_control" title="wikilink">Nonlinear control</a></li>
<li><a href="Robust_control" title="wikilink">Robust control</a></li>
<li><a href="Optimal_control" title="wikilink">Optimal control</a></li>
<li><a href="Bang–bang_control" title="wikilink">Bang–bang control</a> – Sliding mode control is often implemented as a bang–bang control. In some cases, such control is necessary for <a href="optimal_control" title="wikilink">optimality</a>.</li>
<li><a class="uri" href="H-bridge" title="wikilink">H-bridge</a> – A topology that combines four switches forming the four legs of an "H". Can be used to drive a motor (or other electrical device) forward or backward when only a single supply is available. Often used in actuator in sliding-mode controlled systems.</li>
<li><a href="Switching_amplifier" title="wikilink">Switching amplifier</a> – Uses switching-mode control to drive continuous outputs</li>
<li><a href="Delta-sigma_modulation" title="wikilink">Delta-sigma modulation</a> – Another (feedback) method of encoding a continuous range of values in a signal that rapidly switches between two states (i.e., a kind of specialized sliding-mode control)</li>
<li><a href="Pulse-density_modulation" title="wikilink">Pulse-density modulation</a> – A generalized form of delta-sigma modulation.</li>
<li><a href="Pulse-width_modulation" title="wikilink">Pulse-width modulation</a> – Another modulation scheme that produces continuous motion through discontinuous switching.</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Control_theory" title="wikilink"> </a> <a href="Category:Nonlinear_control" title="wikilink">Category:Nonlinear control</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">Other pulse-type modulation techniques include <a href="delta-sigma_modulation" title="wikilink">delta-sigma modulation</a>.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="https://www.youtube.com/watch?v=hD1hxwupECs">"Autonomous Navigation and Obstacle Avoidance of Unmanned Vessels in Simulated Rough Sea States - Villanova University"</a><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"></li>
</ol>
</section>
</body>
</html>
