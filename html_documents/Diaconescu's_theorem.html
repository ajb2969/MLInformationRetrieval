<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="775">Diaconescu's theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Diaconescu's theorem</h1>
<hr/>

<p>In <a href="mathematical_logic" title="wikilink">mathematical logic</a>, <strong>Diaconescu's <a class="uri" href="theorem" title="wikilink">theorem</a></strong>, or the <strong>Goodman–Myhill theorem</strong>, states that the full <a href="axiom_of_choice" title="wikilink">axiom of choice</a> is sufficient to derive the <a href="law_of_the_excluded_middle" title="wikilink">law of the excluded middle</a>, or restricted forms of it, in <a href="constructive_set_theory" title="wikilink">constructive set theory</a>. It was discovered in 1975 by Diaconescu<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and later by Goodman and Myhill.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Already in 1967, <a href="Errett_Bishop" title="wikilink">Errett Bishop</a> posed the Theorem as an exercise (Problem 2 on page 58 in <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a>).</p>
<h2 id="proof">Proof</h2>

<p>For any <a class="uri" href="proposition" title="wikilink">proposition</a> 

<math display="inline" id="Diaconescu's_theorem:0">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>P</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\,
  </annotation>
 </semantics>
</math>

, we can <a href="Set-builder_notation" title="wikilink">build the sets</a></p>

<p>

<math display="block" id="Diaconescu's_theorem:1">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>=</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∨</mo>
    <mi>P</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">U</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cn type="integer">0</cn>
      <ci>normal-,</ci>
      <cn type="integer">1</cn>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-:</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <eq></eq>
      <cn type="integer">0</cn>
      <ci>normal-)</ci>
     </cerror>
     <or></or>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U=\{x\in\{0,1\}:(x=0)\vee P\}
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Diaconescu's_theorem:2">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>=</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∨</mo>
    <mi>P</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">V</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cn type="integer">0</cn>
      <ci>normal-,</ci>
      <cn type="integer">1</cn>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-:</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <eq></eq>
      <cn type="integer">1</cn>
      <ci>normal-)</ci>
     </cerror>
     <or></or>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V=\{x\in\{0,1\}:(x=1)\vee P\}.
  </annotation>
 </semantics>
</math>

</p>

<p>These are sets, using the <a href="axiom_of_specification" title="wikilink">axiom of specification</a>. In classical set theory this would be equivalent to</p>

<p>

<math display="block" id="Diaconescu's_theorem:3">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mo stretchy="false">{</mo>
         <mn>0</mn>
         <mo>,</mo>
         <mn>1</mn>
         <mo stretchy="false">}</mo>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mtext>if</mtext>
        <mi>P</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mo stretchy="false">{</mo>
         <mn>0</mn>
         <mo stretchy="false">}</mo>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mtext>if</mtext>
        <mi mathvariant="normal">¬</mi>
        <mi>P</mi>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>U</ci>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <apply>
      <times></times>
      <mtext>if</mtext>
      <ci>P</ci>
     </apply>
     <set>
      <cn type="integer">0</cn>
     </set>
     <apply>
      <times></times>
      <mtext>if</mtext>
      <not></not>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U=\begin{cases}\{0,1\},&\mbox{if }P\\
\{0\},&\mbox{if }\neg P\end{cases}
  </annotation>
 </semantics>
</math>

 and similarly for 

<math display="inline" id="Diaconescu's_theorem:4">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>V</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\,
  </annotation>
 </semantics>
</math>

. However, without the law of the excluded middle, these equivalences cannot be proven; in fact the two sets are not even provably <a href="finite_set" title="wikilink">finite</a> (in the usual sense of being in <a class="uri" href="bijection" title="wikilink">bijection</a> with a <a href="natural_number" title="wikilink">natural number</a>, though they would be in the <a href="Dedekind-infinite" title="wikilink">Dedekind</a> sense).</p>

<p>Assuming the <a href="axiom_of_choice" title="wikilink">axiom of choice</a>, there exists a <a href="choice_function" title="wikilink">choice function</a> for the set 

<math display="inline" id="Diaconescu's_theorem:5">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>U</mi>
   <mo>,</mo>
   <mi>V</mi>
   <mo rspace="4.2pt" stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>U</ci>
    <ci>V</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{U,V\}\,
  </annotation>
 </semantics>
</math>

; that is, a function 

<math display="inline" id="Diaconescu's_theorem:6">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>f</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\,
  </annotation>
 </semantics>
</math>

 such that</p>

<p>

<math display="block" id="Diaconescu's_theorem:7">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>U</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>U</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>V</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>V</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo rspace="4.2pt">.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">U</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">U</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">V</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [f(U)\in U]\wedge[f(V)\in V].\,
  </annotation>
 </semantics>
</math>

</p>

<p>By the definition of the two sets, this means that</p>

<p>

<math display="block" id="Diaconescu's_theorem:8">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>U</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>=</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∨</mo>
    <mi>P</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>V</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>=</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∨</mo>
    <mi>P</mi>
    <mo rspace="4.2pt" stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">U</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <eq></eq>
      <cn type="integer">0</cn>
      <ci>normal-)</ci>
     </cerror>
     <or></or>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">V</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <eq></eq>
      <cn type="integer">1</cn>
      <ci>normal-)</ci>
     </cerror>
     <or></or>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [(f(U)=0)\vee P]\wedge[(f(V)=1)\vee P]\,
  </annotation>
 </semantics>
</math>

,</p>

<p>which implies 

<math display="inline" id="Diaconescu's_theorem:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>U</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≠</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>V</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∨</mo>
     <mi>P</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>U</ci>
    </apply>
    <apply>
     <or></or>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>V</ci>
     </apply>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(U)\neq f(V)\vee P.
  </annotation>
 </semantics>
</math>

</p>

<p>But since 

<math display="inline" id="Diaconescu's_theorem:10">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>U</mi>
    <mo>=</mo>
    <mi>V</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">U</csymbol>
     <eq></eq>
     <csymbol cd="unknown">V</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\to(U=V)
  </annotation>
 </semantics>
</math>

 (by the <a href="axiom_of_extensionality" title="wikilink">axiom of extensionality</a>), therefore 

<math display="inline" id="Diaconescu's_theorem:11">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>U</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>V</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">U</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">V</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\to(f(U)=f(V))\,
  </annotation>
 </semantics>
</math>

, so</p>

<p>

<math display="block" id="Diaconescu's_theorem:12">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>U</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>≠</mo>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>V</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi mathvariant="normal">¬</mi>
   <mi>P</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">U</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <neq></neq>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">V</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <not></not>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f(U)\neq f(V))\to\neg P.
  </annotation>
 </semantics>
</math>

</p>

<p>Thus 

<math display="inline" id="Diaconescu's_theorem:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>P</mi>
    </mrow>
    <mo>∨</mo>
    <mi>P</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <times></times>
     <not></not>
     <ci>P</ci>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg P\vee P.
  </annotation>
 </semantics>
</math>

 As this could be done for any proposition, this completes the proof that the axiom of choice implies the law of the excluded middle.</p>

<p>The proof relies on the use of the full separation axiom. In constructive set theories with only the <a href="axiom_schema_of_predicative_separation" title="wikilink">predicative separation</a>, the form of <em>P</em> will be restricted to sentences with bound quantifiers only, giving only a restricted form of the law of the excluded middle. This restricted form is still not acceptable constructively.</p>

<p>In <a href="constructive_type_theory" title="wikilink">constructive type theory</a>, or in <a href="Heyting_arithmetic" title="wikilink">Heyting arithmetic</a> extended with finite types, there is typically no separation at all - subsets of a type are given different treatments. A form of the axiom of choice is a theorem, yet excluded middle is not.</p>
<h2 id="notes">Notes</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Constructivism_(mathematics)" title="wikilink">Category:Constructivism (mathematics)</a> <a href="Category:Set_theory" title="wikilink">Category:Set theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">R. Diaconescu, , Proceedings of the American Mathematical Society 51:176-178 (1975)<a href="#fnref1">↩</a></li>
<li id="fn2">N. D. Goodman and J. Myhill, “Choice Implies Excluded Middle”, Zeitschrift fur Mathematische Logik und Grundlagen der Mathematik 24:461 (1978)<a href="#fnref2">↩</a></li>
<li id="fn3">E. Bishop, "Foundations of constructive analysis", McGraw-Hill (1967)<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
