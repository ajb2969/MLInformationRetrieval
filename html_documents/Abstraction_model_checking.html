<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="421">Abstraction model checking</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Abstraction model checking</h1>
<hr/>

<p><strong>Abstraction Model checking</strong> is for systems where an actual representation is too complex in developing the model alone. So, the design undergoes a kind of translation to scaled down "abstract" version.</p>

<p>The set of <a href="Variable_(mathematics)" title="wikilink">variables</a> are partitioned into visible and invisible depending on their change of values. The real <a href="state_space" title="wikilink">state space</a> is summarized into a smaller set of the visible ones.</p>
<h2 id="galois-connected">Galois connected</h2>

<p>The real and the abstract state spaces are <a href="Galois_connection" title="wikilink">Galois connected</a>. This means that if we take an element from the <a href="abstract_space" title="wikilink">abstract space</a>, concretize it and abstract the concretized version, the result will be equal to the original. On the other hand, if you pick an element from the real space, abstract it and concretize the abstract version, the final result will be a super set of the original.</p>

<p>That is,</p>

<p>

<math display="inline" id="Abstraction_model_checking:0">
 <semantics>
  <mi>η</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>η</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta
  </annotation>
 </semantics>
</math>

(

<math display="inline" id="Abstraction_model_checking:1">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

(abstract)) = abstract<br/>


<math display="inline" id="Abstraction_model_checking:2">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

(

<math display="inline" id="Abstraction_model_checking:3">
 <semantics>
  <mi>η</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>η</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta
  </annotation>
 </semantics>
</math>

(real)) 

<math display="inline" id="Abstraction_model_checking:4">
 <semantics>
  <mo>⊃</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">superset-of</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \supset
  </annotation>
 </semantics>
</math>

 real</p>
<h2 id="abstraction-refinement-loop">Abstraction refinement loop</h2>

<p>A problem with abstraction <a href="model_checking" title="wikilink">model checking</a> is that although the abstraction simulates the real, when the abstraction does not satisfy a property, it does not mean that this property actually fails in the real model. Counter examples are checked against the real state space because we obtain "spurious" counter examples. So a part of the abstraction refinement loop is:</p>
<ol>
<li>Obtain the abstract model</li>
<li>Model check and see if everything is ok.</li>
<li>If there is a counter example, then go back to the real state space and find out if it actually a counter model.</li>
<li>If not, return and continue model checking.</li>
</ol>

<p>Spurious examples are mostly generated because dead end states and bad states are abstracted to the same kind. To solve this we need to create a segregation between the 2 kinds. The next step is to find the subset of invisible variables that actually make a difference between the dead end and bad states and add this subset to the set of visible or monitored variables. If the separation proves expensive, refinement could be based on learning from samples.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Model_checking" title="wikilink">Category:Model checking</a></p>
</body>
</html>
