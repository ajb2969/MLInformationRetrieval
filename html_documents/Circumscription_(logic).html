<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1008">Circumscription (logic)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Circumscription (logic)</h1>
<hr/>

<p><strong>Circumscription</strong> is a <a href="non-monotonic_logic" title="wikilink">non-monotonic logic</a> created by <a href="John_McCarthy_(computer_scientist)" title="wikilink">John McCarthy</a> to formalize the <a href="common_sense" title="wikilink">common sense</a> assumption that things are as expected unless otherwise specified. Circumscription was later used by McCarthy in an attempt to solve the <a href="frame_problem" title="wikilink">frame problem</a>. In its original <a href="first-order_logic" title="wikilink">first-order logic</a> formulation, circumscription minimizes the <a href="extension_(semantics)" title="wikilink">extension</a> of some predicates, where the extension of a predicate is the set of tuples of values the predicate is true on. This minimization is similar to the <a href="closed_world_assumption" title="wikilink">closed world assumption</a> that what is not known to be true is false.</p>

<p>The original problem considered by McCarthy was that of <a href="missionaries_and_cannibals_problem" title="wikilink">missionaries and cannibals</a>: there are three missionaries and three cannibals on one bank of a river; they have to cross the river using a boat that can only take two, with the additional constraint that cannibals must never outnumber the missionaries on either bank (as otherwise the missionaries would be killed and, presumably, eaten). The problem considered by McCarthy was not that of finding a sequence of steps to reach the goal (the article on the <a href="missionaries_and_cannibals_problem" title="wikilink">missionaries and cannibals problem</a> contains one such solution), but rather that of excluding conditions that are not explicitly stated. For example, the solution “go half a mile south and cross the river on the bridge” is intuitively not valid because the statement of the problem does not mention such a bridge. On the other hand, the existence of this bridge is not excluded by the statement of the problem either. That the bridge does not exist is a consequence of the implicit assumption that the statement of the problem contains everything that is relevant to its solution. Explicitly stating that a bridge does not exist is not a solution to this problem, as there are many other exceptional conditions that should be excluded (such as the presence of a rope for fastening the cannibals, the presence of a larger boat nearby, etc.)</p>

<p>Circumscription was later used by McCarthy to formalize the implicit assumption of <a class="uri" href="inertia" title="wikilink">inertia</a>: things do not change unless otherwise specified. Circumscription seemed to be useful to avoid specifying that conditions are not changed by all actions except those explicitly known to change them; this is known as the <a href="frame_problem" title="wikilink">frame problem</a>. However, the solution proposed by McCarthy was later shown leading to wrong results in some cases, like in the <a href="Yale_shooting_problem" title="wikilink">Yale shooting problem</a> scenario. Other solutions to the frame problem that correctly formalize the Yale shooting problem exist; some use circumscription but in a different way.</p>
<h2 id="the-propositional-case">The propositional case</h2>

<p>While circumscription was initially defined in the first-order logic case, the particularization to the propositional case is easier to define. Given a <a href="propositional_formula" title="wikilink">propositional formula</a> 

<math display="inline" id="Circumscription_(logic):0">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

, its circumscription is the formula having only the <a href="Structure_(mathematical_logic)" title="wikilink">models</a> of 

<math display="inline" id="Circumscription_(logic):1">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 that do not assign a variable to true unless necessary.</p>

<p>Formally, propositional models can be represented by sets of <a href="propositional_variable" title="wikilink">propositional variables</a>; namely, each model is represented by the set of propositional variables it assigns to true. For example, the model assigning true to 

<math display="inline" id="Circumscription_(logic):2">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, false to 

<math display="inline" id="Circumscription_(logic):3">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

, and true to 

<math display="inline" id="Circumscription_(logic):4">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 is represented by the set 

<math display="inline" id="Circumscription_(logic):5">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>c</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>a</ci>
    <ci>c</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a,c\}
  </annotation>
 </semantics>
</math>

, because 

<math display="inline" id="Circumscription_(logic):6">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Circumscription_(logic):7">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 are exactly the variables that are assigned to true by this model.</p>

<p>Given two models 

<math display="inline" id="Circumscription_(logic):8">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Circumscription_(logic):9">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 represented this way, the condition 

<math display="inline" id="Circumscription_(logic):10">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>⊆</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>N</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\subseteq M
  </annotation>
 </semantics>
</math>

 is equivalent to 

<math display="inline" id="Circumscription_(logic):11">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 setting to true every variable that 

<math display="inline" id="Circumscription_(logic):12">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 sets to true. In other words, 

<math display="inline" id="Circumscription_(logic):13">
 <semantics>
  <mo>⊆</mo>
  <annotation-xml encoding="MathML-Content">
   <subset></subset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subseteq
  </annotation>
 </semantics>
</math>

 models the relation of “setting to true less variables”. 

<math display="inline" id="Circumscription_(logic):14">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>⊂</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>N</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\subset M
  </annotation>
 </semantics>
</math>

 means that 

<math display="inline" id="Circumscription_(logic):15">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>⊆</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>N</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\subseteq M
  </annotation>
 </semantics>
</math>

 but these two models do not coincide.</p>

<p>This lets us define models that do not assign variables to true unless necessary. A model 

<math display="inline" id="Circumscription_(logic):16">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 of a <a href="Theory_(logic)" title="wikilink">theory</a> 

<math display="inline" id="Circumscription_(logic):17">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is called <strong>minimal</strong>, if and only if there is no model 

<math display="inline" id="Circumscription_(logic):18">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Circumscription_(logic):19">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 for which 

<math display="inline" id="Circumscription_(logic):20">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>⊂</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>N</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\subset M
  </annotation>
 </semantics>
</math>

.</p>

<p>Circumscription is expressed by selecting only the minimal models. It is defined as follows:</p>

<p>

<math display="block" id="Circumscription_(logic):21">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mi>I</mi>
    <mi>R</mi>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mpadded width="+3.3pt">
     <mi>M</mi>
    </mpadded>
    <mo rspace="5.8pt" stretchy="false">|</mo>
    <mrow>
     <mi>M</mi>
     <mtext>is a minimal model of</mtext>
     <mi>T</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>I</ci>
     <ci>R</ci>
     <ci>C</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>M</ci>
     <apply>
      <times></times>
      <ci>M</ci>
      <mtext>is a minimal model of</mtext>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   CIRC(T)=\{M~{}|~{}M\mbox{ is a minimal model of }T\}
  </annotation>
 </semantics>
</math>

</p>

<p>Alternatively, one can define 

<math display="inline" id="Circumscription_(logic):22">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>I</mi>
   <mi>R</mi>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>I</ci>
    <ci>R</ci>
    <ci>C</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   CIRC(T)
  </annotation>
 </semantics>
</math>

 as a formula having exactly the above set of models; furthermore, one can also avoid giving a definition of 

<math display="inline" id="Circumscription_(logic):23">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>I</mi>
   <mi>R</mi>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>I</ci>
    <ci>R</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   CIRC
  </annotation>
 </semantics>
</math>

 and only define minimal inference as 

<math display="inline" id="Circumscription_(logic):24">
 <semantics>
  <mrow>
   <mi>T</mi>
   <msub>
    <mo>⊧</mo>
    <mi>M</mi>
   </msub>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">models</csymbol>
     <ci>M</ci>
    </apply>
    <ci>T</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\models_{M}Q
  </annotation>
 </semantics>
</math>

 if and only if every minimal model of 

<math display="inline" id="Circumscription_(logic):25">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is also a model of 

<math display="inline" id="Circumscription_(logic):26">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

.</p>

<p>As an example, the formula 

<math display="inline" id="Circumscription_(logic):27">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mo>∨</mo>
      <mi>c</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <and></and>
     <ci>a</ci>
     <apply>
      <or></or>
      <ci>b</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=a\land(b\lor c)
  </annotation>
 </semantics>
</math>

 has three models:</p>
<ol>
<li>

<math display="inline" id="Circumscription_(logic):28">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Circumscription_(logic):29">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Circumscription_(logic):30">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 are true, i.e. 

<math display="inline" id="Circumscription_(logic):31">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo>,</mo>
   <mi>c</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>a</ci>
    <ci>b</ci>
    <ci>c</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a,b,c\}
  </annotation>
 </semantics>
</math>

;</li>
<li>

<math display="inline" id="Circumscription_(logic):32">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Circumscription_(logic):33">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 are true, 

<math display="inline" id="Circumscription_(logic):34">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 is false, i.e. 

<math display="inline" id="Circumscription_(logic):35">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>a</ci>
    <ci>b</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a,b\}
  </annotation>
 </semantics>
</math>

;</li>
<li>

<math display="inline" id="Circumscription_(logic):36">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Circumscription_(logic):37">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 are true, 

<math display="inline" id="Circumscription_(logic):38">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 is false, i.e. 

<math display="inline" id="Circumscription_(logic):39">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>c</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>a</ci>
    <ci>c</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a,c\}
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>The first model is not minimal in the set of variables it assigns to true. Indeed, the second model makes the same assignments except for 

<math display="inline" id="Circumscription_(logic):40">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

, which is assigned to false and not to true. Therefore, the first model is not minimal. The second and third models are incomparable: while the second assigns true to 

<math display="inline" id="Circumscription_(logic):41">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

, the third assigns true to 

<math display="inline" id="Circumscription_(logic):42">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 instead. Therefore, the models circumscribing 

<math display="inline" id="Circumscription_(logic):43">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 are the second and third models of the list. A propositional formula having exactly these two models is the following one:</p>

<p>

<math display="block" id="Circumscription_(logic):44">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∧</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mo>↔</mo>
      <mi>c</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>a</ci>
    <apply>
     <not></not>
     <apply>
      <ci>normal-↔</ci>
      <ci>b</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\land\neg(b\leftrightarrow c)
  </annotation>
 </semantics>
</math>

</p>

<p>Intuitively, in circumscription a variable is assigned to true only if this is necessary. Dually, if a variable <strong>can</strong> be false, it <strong>must</strong> be false. For example, at least one of 

<math display="inline" id="Circumscription_(logic):45">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Circumscription_(logic):46">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 must be assigned to true according to 

<math display="inline" id="Circumscription_(logic):47">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

; in the circumscription exactly one of the two variables must be true. The variable 

<math display="inline" id="Circumscription_(logic):48">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 cannot be false in any model of 

<math display="inline" id="Circumscription_(logic):49">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 and neither of the circumscription.</p>
<h2 id="fixed-and-varying-predicates">Fixed and varying predicates</h2>

<p>The extension of circumscription with fixed and varying predicates is due to <a href="Vladimir_Lifschitz" title="wikilink">Vladimir Lifschitz</a>. The idea is that some conditions are not to be minimized. In propositional logic terms, some variables are not to be falsified if possible. In particular, two kind of variables can be considered:</p>
<dl>
<dt>varying : these are variables that are not to be taken into account at all in the course of minimization;</dt>
</dl>
<dl>
<dt>fixed : these are variables considered fixed while doing a minimization; in other words, minimization can be done only by comparing models with the same values of these variables.</dt>
</dl>

<p>The difference is that the value of the varying conditions are simply assumed not to matter. The fixed conditions instead characterize a possible situation, so that comparing two situations where these conditions have different value makes no sense.</p>

<p>Formally, the extension of circumscription that incorporate varying and fixed variables is as follows, where 

<math display="inline" id="Circumscription_(logic):50">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is the set of variables to minimize, 

<math display="inline" id="Circumscription_(logic):51">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 the fixed variables, and the varying variables are those not in 

<math display="inline" id="Circumscription_(logic):52">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>∪</mo>
   <mi>Z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>P</ci>
    <ci>Z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\cup Z
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Circumscription_(logic):53">
 <semantics>
  <mrow>
   <mrow>
    <mtext>CIRC</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo>;</mo>
     <mi>P</mi>
     <mo>,</mo>
     <mi>Z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mpadded width="+3.3pt">
     <mi>M</mi>
    </mpadded>
    <mo rspace="5.8pt" stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>M</mi>
      <mo>⊧</mo>
      <mrow>
       <mi>T</mi>
       <mtext>and</mtext>
       <mrow>
        <mo>∄</mo>
        <mrow>
         <mi>N</mi>
         <mtext>such that</mtext>
         <mi>N</mi>
        </mrow>
       </mrow>
      </mrow>
      <mo>⊧</mo>
      <mi>T</mi>
     </mrow>
     <mo rspace="5.8pt">,</mo>
     <mrow>
      <mrow>
       <mi>N</mi>
       <mo>∩</mo>
       <mi>P</mi>
      </mrow>
      <mo>⊂</mo>
      <mrow>
       <mi>M</mi>
       <mo>∩</mo>
       <mrow>
        <mi>P</mi>
        <mtext>and</mtext>
        <mi>N</mi>
       </mrow>
       <mo>∩</mo>
       <mi>Z</mi>
      </mrow>
      <mo>=</mo>
      <mrow>
       <mi>M</mi>
       <mo>∩</mo>
       <mi>Z</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>CIRC</mtext>
     <list>
      <ci>T</ci>
      <ci>P</ci>
      <ci>Z</ci>
     </list>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>M</ci>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <and></and>
       <apply>
        <csymbol cd="latexml">models</csymbol>
        <ci>M</ci>
        <apply>
         <times></times>
         <ci>T</ci>
         <mtext>and</mtext>
         <apply>
          <csymbol cd="latexml">not-exists</csymbol>
          <apply>
           <times></times>
           <ci>N</ci>
           <mtext>such that</mtext>
           <ci>N</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">models</csymbol>
        <share href="#.cmml">
        </share>
        <ci>T</ci>
       </apply>
      </apply>
      <apply>
       <and></and>
       <apply>
        <subset></subset>
        <apply>
         <intersect></intersect>
         <ci>N</ci>
         <ci>P</ci>
        </apply>
        <apply>
         <intersect></intersect>
         <ci>M</ci>
         <apply>
          <times></times>
          <ci>P</ci>
          <mtext>and</mtext>
          <ci>N</ci>
         </apply>
         <ci>Z</ci>
        </apply>
       </apply>
       <apply>
        <eq></eq>
        <share href="#.cmml">
        </share>
        <apply>
         <intersect></intersect>
         <ci>M</ci>
         <ci>Z</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{CIRC}(T;P,Z)=\{M~{}|~{}M\models T\text{ and }\not\exists N\text{ such %
that }N\models T,~{}N\cap P\subset M\cap P\text{ and }N\cap Z=M\cap Z\}
  </annotation>
 </semantics>
</math>

</p>

<p>In words, minimization of the variables assigned to true is only done for the variables in 

<math display="inline" id="Circumscription_(logic):54">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

; moreover, models are only compared if they assign the same values to the variables of 

<math display="inline" id="Circumscription_(logic):55">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

. All other variables are not taken into account while comparing models.</p>

<p>The solution to the frame problem proposed by McCarthy is based on circumscription with no fixed conditions. In the propositional case, this solution can be described as follows: in addition to the formulae directly encoding what is known, one also define new variables representing changes in the values of the conditions; these new variables are then minimized.</p>

<p>For example, of the domain in which there is a door that is closed at time 0 and in which the action of opening the door is executed at time 2, what is explicitly known is represented by the two formulae:</p>

<p>

<math display="block" id="Circumscription_(logic):56">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <msub>
    <mtext>open</mtext>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext>open</mtext>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\text{open}_{0}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Circumscription_(logic):57">
 <semantics>
  <mrow>
   <mtext>true</mtext>
   <mo>→</mo>
   <msub>
    <mtext>open</mtext>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <mtext>true</mtext>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext>open</mtext>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{true}\rightarrow\text{open}_{2}
  </annotation>
 </semantics>
</math>

</p>

<p>The frame problem shows in this example as the problem that 

<math display="inline" id="Circumscription_(logic):58">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>o</mi>
   <mi>p</mi>
   <mi>e</mi>
   <msub>
    <mi>n</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>o</ci>
    <ci>p</ci>
    <ci>e</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg open_{1}
  </annotation>
 </semantics>
</math>

 is not a consequence of the above formulae, while the door is supposed to stay closed until the action of opening it is performed. Circumscription can be used to this aim by defining new variables 

<math display="inline" id="Circumscription_(logic):59">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mi>h</mi>
   <mi>a</mi>
   <mi>n</mi>
   <mi>g</mi>
   <mi>e</mi>
   <mi mathvariant="normal">_</mi>
   <mi>o</mi>
   <mi>p</mi>
   <mi>e</mi>
   <msub>
    <mi>n</mi>
    <mi>t</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <ci>h</ci>
    <ci>a</ci>
    <ci>n</ci>
    <ci>g</ci>
    <ci>e</ci>
    <ci>normal-_</ci>
    <ci>o</ci>
    <ci>p</ci>
    <ci>e</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   change\_open_{t}
  </annotation>
 </semantics>
</math>

 to model changes and then minimizing them:</p>

<p>

<math display="block" id="Circumscription_(logic):60">
 <semantics>
  <mrow>
   <msub>
    <mtext>change open</mtext>
    <mn>0</mn>
   </msub>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mtext>open</mtext>
     <mn>0</mn>
    </msub>
    <mo>≢</mo>
    <msub>
     <mtext>open</mtext>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext>change open</mtext>
     <cn type="integer">0</cn>
    </apply>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>open</mtext>
      <cn type="integer">0</cn>
     </apply>
     <csymbol cd="latexml">not-equivalent-to</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>open</mtext>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{change open}_{0}\equiv(\text{open}_{0}\not\equiv\text{open}_{1})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Circumscription_(logic):61">
 <semantics>
  <mrow>
   <msub>
    <mtext>change open</mtext>
    <mn>1</mn>
   </msub>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mtext>open</mtext>
     <mn>1</mn>
    </msub>
    <mo>≢</mo>
    <msub>
     <mtext>open</mtext>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext>change open</mtext>
     <cn type="integer">1</cn>
    </apply>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>open</mtext>
      <cn type="integer">1</cn>
     </apply>
     <csymbol cd="latexml">not-equivalent-to</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>open</mtext>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{change open}_{1}\equiv(\text{open}_{1}\not\equiv\text{open}_{2})
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd>...
</dd>
</dl>

<p>As shown by the <a href="Yale_shooting_problem" title="wikilink">Yale shooting problem</a>, this kind of solution does not work. For example, 

<math display="inline" id="Circumscription_(logic):62">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <msub>
    <mtext>open</mtext>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext>open</mtext>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\text{open}_{1}
  </annotation>
 </semantics>
</math>

 is not yet entailed by the circumscription of the formulae above: the model in which 

<math display="inline" id="Circumscription_(logic):63">
 <semantics>
  <msub>
   <mtext>change open</mtext>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>change open</mtext>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{change open}_{0}
  </annotation>
 </semantics>
</math>

 is true and 

<math display="inline" id="Circumscription_(logic):64">
 <semantics>
  <msub>
   <mtext>change open</mtext>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>change open</mtext>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{change open}_{1}
  </annotation>
 </semantics>
</math>

 is false is incomparable with the model with the opposite values. Therefore, the situation in which the door becomes open at time 1 and then remains open as a consequence of the action is not excluded by circumscription.</p>

<p>Several other formalizations of dynamical domains not suffering from such problems have been developed (see <a href="frame_problem" title="wikilink">frame problem</a> for an overview). Many use circumscription but in a different way.</p>
<h2 id="predicate-circumscription">Predicate circumscription</h2>

<p>The original definition of circumscription proposed by McCarthy is about first-order logic. The role of variables in propositional logic (something that can be true or false) is played in first-order logic by predicates. Namely, a propositional formula can be expressed in first-order logic by replacing each propositional variable with a predicate of zero arity (i.e., a predicate with no arguments). Therefore, minimization is done on predicates in the first-order logic version of circumscription: the circumscription of a formula is obtained forcing predicates to be false whenever possible.</p>

<p>Given a first-order logic formula 

<math display="inline" id="Circumscription_(logic):65">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 containing a <a href="Predicate_(logic)" title="wikilink">predicate</a> 

<math display="inline" id="Circumscription_(logic):66">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, circumscribing this predicate amounts to selecting only the models of 

<math display="inline" id="Circumscription_(logic):67">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 in which 

<math display="inline" id="Circumscription_(logic):68">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is assigned to true on a minimal set of tuples of values.</p>

<p>Formally, the <em>extension</em> of a predicate in a first-order model is the set of tuples of values this predicate assign to true in the model. First-order models indeed includes the evaluation of each predicate symbol; such an evaluation tells whether the predicate is true or false for any possible value of its arguments. Since each argument of a predicate must be a term, and each term evaluates to a value, the models tells whether 

<math display="inline" id="Circumscription_(logic):69">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(v_{1},\ldots,v_{n})
  </annotation>
 </semantics>
</math>

 is true for any possible tuple of values 

<math display="inline" id="Circumscription_(logic):70">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <msub>
    <mi>v</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle v_{1},\ldots,v_{n}\rangle
  </annotation>
 </semantics>
</math>

. The extension of 

<math display="inline" id="Circumscription_(logic):71">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 in a model is the set of tuples of terms such that 

<math display="inline" id="Circumscription_(logic):72">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(v_{1},\ldots,v_{n})
  </annotation>
 </semantics>
</math>

 is true in the model.</p>

<p>The circumscription of a predicate 

<math display="inline" id="Circumscription_(logic):73">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 in a formula 

<math display="inline" id="Circumscription_(logic):74">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is obtained by selecting only the models of 

<math display="inline" id="Circumscription_(logic):75">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 with a minimal extension of 

<math display="inline" id="Circumscription_(logic):76">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

. For example, if a formula has only two models, differing only because 

<math display="inline" id="Circumscription_(logic):77">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(v_{1},\ldots,v_{n})
  </annotation>
 </semantics>
</math>

 is true in one and false in the second, then only the second model is selected. This is because 

<math display="inline" id="Circumscription_(logic):78">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <msub>
    <mi>v</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle v_{1},\ldots,v_{n}\rangle
  </annotation>
 </semantics>
</math>

 is in the extension of 

<math display="inline" id="Circumscription_(logic):79">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 in the first model but not in the second.</p>

<p>The original definition by McCarthy was syntactical rather than semantical. Given a formula 

<math display="inline" id="Circumscription_(logic):80">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 and a predicate 

<math display="inline" id="Circumscription_(logic):81">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, circumscribing 

<math display="inline" id="Circumscription_(logic):82">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Circumscription_(logic):83">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is the following second-order formula:</p>

<p>

<math display="inline" id="Circumscription_(logic):84">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is a predicate of the same arity as 

<math display="inline" id="Circumscription_(logic):85">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. This is a second-order formula because it contains a quantification over a predicate. The subformula 

<math display="inline" id="Circumscription_(logic):86">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

</p>

<p>In this formula, 

<math display="inline" id="Circumscription_(logic):87">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is a n-tuple of terms, where n is the arity of 

<math display="inline" id="Circumscription_(logic):88">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

. This formula states that extension minimization has to be done: in order for a truth evaluation on 

<math display="inline" id="Circumscription_(logic):89">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 of a model being considered, it must be the case that no other predicate 

<math display="inline" id="Circumscription_(logic):90">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 can assign to false every tuple that 

<math display="inline" id="Circumscription_(logic):91">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>A</mi>
   <mi>b</mi>
   <mi>n</mi>
   <mi>o</mi>
   <mi>r</mi>
   <mi>m</mi>
   <mi>a</mi>
   <mi>l</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">…</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>A</ci>
    <ci>b</ci>
    <ci>n</ci>
    <ci>o</ci>
    <ci>r</ci>
    <ci>m</ci>
    <ci>a</ci>
    <ci>l</ci>
    <ci>normal-…</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg Abnormal(...)
  </annotation>
 </semantics>
</math>

 assigns to false and yet being different from 

<math display="inline" id="Circumscription_(logic):92">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(a)\equiv P(b)
  </annotation>
 </semantics>
</math>

.</p>

<p>This definition only allows circumscribing a single predicate. While the extension to more than one predicate is trivial, minimizing the extension of a single predicate has an important application: capturing the idea that things are usually as expected. This idea can be formalized by minimizing a single predicate expressing the abnormality of situations. In particular, every known fact is expressed in logic with the addition of a literal 

<math display="inline" id="Circumscription_(logic):93">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>a</ci>
    <ci>b</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a,b\}
  </annotation>
 </semantics>
</math>

 stating that the fact holds only in normal situations. Minimizing the extension of this predicate allows for reasoning under the implicit assumption that things are as expected (that is, they are not abnormal), and that this assumption is made only if possible (abnormality can be assumed false only if this is consistent with the facts.)</p>
<h2 id="pointwise-circumscription">Pointwise circumscription</h2>

<p>Pointwise circumscription is a variant of first-order circumscription that has been introduced by <a href="Vladimir_Lifschitz" title="wikilink">Vladimir Lifschitz</a>. In the propositional case, pointwise and predicate circumscription coincide. The rationale of pointwise circumscription it minimize the value of a predicate for each tuple of values separately, rather than minimizing the extension of the predicate. For example, there are two models of 

<math display="inline" id="Circumscription_(logic):94">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mi>a</mi>
    <mi>l</mi>
    <mi>s</mi>
    <mi>e</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>a</ci>
      <ci>l</ci>
      <ci>s</ci>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(a)=P(b)=false
  </annotation>
 </semantics>
</math>

 with domain 

<math display="inline" id="Circumscription_(logic):95">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>t</mi>
    <mi>r</mi>
    <mi>u</mi>
    <mi>e</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>t</ci>
      <ci>r</ci>
      <ci>u</ci>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(a)=P(b)=true
  </annotation>
 </semantics>
</math>

, one setting 

<math display="inline" id="Circumscription_(logic):96">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and the other setting 

<math display="inline" id="Circumscription_(logic):97">
 <semantics>
  <mi mathvariant="normal">∅</mi>
  <annotation-xml encoding="MathML-Content">
   <emptyset></emptyset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \emptyset
  </annotation>
 </semantics>
</math>

. Since the extension of 

<math display="inline" id="Circumscription_(logic):98">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>a</ci>
    <ci>b</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a,b\}
  </annotation>
 </semantics>
</math>

 in the first model is 

<math display="inline" id="Circumscription_(logic):99">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(a)\equiv P(b)
  </annotation>
 </semantics>
</math>

 while the extension for the second is 

<math display="inline" id="Circumscription_(logic):100">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(a)
  </annotation>
 </semantics>
</math>

, circumscription only selects the first model.</p>

<p>In pointwise circumscription, each tuple of values is considered separately. For example, in the formula 

<math display="inline" id="Circumscription_(logic):101">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(b)
  </annotation>
 </semantics>
</math>

 one would consider the value of 

<math display="inline" id="Circumscription_(logic):102">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>t</mi>
    <mi>r</mi>
    <mi>u</mi>
    <mi>e</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>t</ci>
      <ci>r</ci>
      <ci>u</ci>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(a)=P(b)=true
  </annotation>
 </semantics>
</math>

 separately from 

<math display="inline" id="Circumscription_(logic):103">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(a)
  </annotation>
 </semantics>
</math>

. A model is minimal only it is not possible to turn any such value from true to false while still satisfying the formula. As a result, the model in which 

<math display="inline" id="Circumscription_(logic):104">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(b)
  </annotation>
 </semantics>
</math>

 is selected by pointwise circumscription because turning only 

<math display="inline" id="Circumscription_(logic):105">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   On
  </annotation>
 </semantics>
</math>

 into false does not satisfy the formula, and the same happens for 

<math display="inline" id="Circumscription_(logic):106">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mtext>coin</mtext>
    <mo>,</mo>
    <mtext>moon</mtext>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
    <interval closure="open">
     <mtext>coin</mtext>
     <mtext>moon</mtext>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   On(\text{coin},\text{moon})
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="domain-and-formula-circumscription">Domain and formula circumscription</h2>

<p>An earlier formulation of circumscription by McCarthy is based on minimizing the <a href="Domain_(mathematics)" title="wikilink">domain</a> of first-order models, rather than the extension of predicates. Namely, a model is considered less than another if it has a smaller domain, and the two models coincide on the evaluation of the common tuples of values. This version of circumscription can be reduced to predicate circumscription.</p>

<p>Formula circumscription was a later formalism introduced by McCarthy. This is a generalization of circumscription in which the extension of a formula is minimized, rather than the extension of a predicate. In other words, a formula can be specified so that the set of tuples of values of the domain that satisfy the formula is made as small as possible.</p>
<h2 id="theory-curbing">Theory curbing</h2>

<p>Circumscription does not always correctly handle disjunctive information. <a href="Raymond_Reiter" title="wikilink">Ray Reiter</a> provided the following example: a coin is tossed over a checkboard, and the result is that the coin is either on a black area, or on a white area, or both. However, there are a large number of other possible places where the coin is not supposed to be on; for example, it is implicit that the coin is not on the floor, or on the refrigerator, or on the moon surface. Circumscription can therefore be used to minimize the extension of 

<math display="inline" id="Circumscription_(logic):107">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   On
  </annotation>
 </semantics>
</math>

 predicate, so that 

<math display="inline" id="Circumscription_(logic):108">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   On
  </annotation>
 </semantics>
</math>

 is false even if this is not explicitly stated.</p>

<p>On the other hand, the minimization of the 

<math display="inline" id="Circumscription_(logic):109">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mtext>coin</mtext>
   <mo>,</mo>
   <mtext>white area</mtext>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <mtext>coin</mtext>
    <mtext>white area</mtext>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\text{coin},\text{white area})
  </annotation>
 </semantics>
</math>

 predicate leads to the wrong result that the coin is either on a black area or on a white area, <em>but not both</em>. This is because the models in which 

<math display="inline" id="Circumscription_(logic):110">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mtext>coin</mtext>
   <mo>,</mo>
   <mtext>black area</mtext>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <mtext>coin</mtext>
    <mtext>black area</mtext>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\text{coin},\text{black area})
  </annotation>
 </semantics>
</math>

 is true only on 

<math display="inline" id="Circumscription_(logic):111">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   On
  </annotation>
 </semantics>
</math>

 and only on 

<math display="inline" id="Circumscription_(logic):112">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   On
  </annotation>
 </semantics>
</math>

 have a minimal extension of 

<math display="inline" id="Circumscription_(logic):113">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mtext>coin</mtext>
    <mo>,</mo>
    <mtext>white area</mtext>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
    <interval closure="open">
     <mtext>coin</mtext>
     <mtext>white area</mtext>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   On(\text{coin},\text{white area})
  </annotation>
 </semantics>
</math>

, while the model in which the extension of 

<math display="inline" id="Circumscription_(logic):114">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mtext>coin</mtext>
    <mo>,</mo>
    <mtext>black area</mtext>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
    <interval closure="open">
     <mtext>coin</mtext>
     <mtext>black area</mtext>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   On(\text{coin},\text{black area})
  </annotation>
 </semantics>
</math>

 is composed of both pairs is not minimal.</p>

<p>Theory curbing is a solution proposed by <a href="Thomas_Eiter" title="wikilink">Thomas Eiter</a>, <a href="Georg_Gottlob" title="wikilink">Georg Gottlob</a>, and <a href="Yuri_Gurevich" title="wikilink">Yuri Gurevich</a>. The idea is that the model that circumscription fails to select, the one in which both 

<math display="inline" id="Circumscription_(logic):115">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   On
  </annotation>
 </semantics>
</math>

 and <span class="LaTeX">$On(\text{coin},\text{black area})$</span> are true, is a model of the formula that is greater (w.r.t. the extension of <span class="LaTeX">$On$</span>) than both the two models that are selected. More specifically, among the models of the formula, the excluded model is the least upper bound of the two selected models. Theory curbing selects such least upper bounds models in addition to the ones selected by circumscription. This inclusion is done until the set of models is closed, in the sense that it includes all least upper bounds of all sets of models it contains.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Defeasible_reasoning" title="wikilink">Defeasible reasoning</a></li>
<li><a href="Preferential_entailment" title="wikilink">Preferential entailment</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www-formal.stanford.edu/jmc/circumscription.html">Circumscription – a form of nonmonotonic reasoning</a>, a paper by McCarthy.</li>
<li><a href="http://plato.stanford.edu/entries/reasoning-defeasible/#5.5">An explanation in the Stanford encyclopedia on philosophy</a></li>
</ul>

<p>"</p>

<p><a href="Category:Logic_programming" title="wikilink">Category:Logic programming</a> <a href="Category:Non-classical_logic" title="wikilink">Category:Non-classical logic</a></p>
</body>
</html>
