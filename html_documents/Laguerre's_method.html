<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1776">Laguerre's method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Laguerre's method</h1>
<hr/>

<p>In <a href="numerical_analysis" title="wikilink">numerical analysis</a>, <strong>Laguerre's method</strong> is a <a href="root-finding_algorithm" title="wikilink">root-finding algorithm</a> tailored to <a href="polynomial" title="wikilink">polynomials</a>. In other words, Laguerre's method can be used to numerically solve the equation</p>

<p>

<math display="block" id="Laguerre's_method:0">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="5pt" width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ p(x)=0
  </annotation>
 </semantics>
</math>

</p>

<p>for a given polynomial <em>p</em>. One of the most useful properties of this method is that it is, from extensive empirical study, very close to being a "sure-fire" method, meaning that it is almost guaranteed to always converge to <em>some</em> root of the polynomial, no matter what initial guess is chosen. This method is named in honour of <a href="Edmond_Laguerre" title="wikilink">Edmond Laguerre</a>, a French mathematician.</p>
<h2 id="definition">Definition</h2>

<p>The algorithm of the Laguerre method to find one root of a polynomial <em>p</em> of degree <em>n</em> is:</p>
<ul>
<li>Choose an initial guess 

<math display="inline" id="Laguerre's_method:1">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

</li>
<li>For <em>k</em> = 0, 1, 2, …
<ul>
<li>If 

<math display="inline" id="Laguerre's_method:2">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x_{k})
  </annotation>
 </semantics>
</math>

 is very small, exit the loop</li>
<li>Calculate 

<math display="inline" id="Laguerre's_method:3">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msup>
      <mi>p</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=\frac{p^{\prime}(x_{k})}{p(x_{k})}
  </annotation>
 </semantics>
</math>

</li>
<li>Calculate 

<math display="inline" id="Laguerre's_method:4">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>G</mi>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <msup>
       <mi>p</mi>
       <mi>′′</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>G</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <ci>′′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>p</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=G^{2}-\frac{p^{\prime\prime}(x_{k})}{p(x_{k})}
  </annotation>
 </semantics>
</math>

</li>
<li>Calculate 

<math display="inline" id="Laguerre's_method:5">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mfrac>
    <mi>n</mi>
    <mrow>
     <mi>G</mi>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\plusmn</mtext>
     </merror>
     <msqrt>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mi>n</mi>
          <mi>H</mi>
         </mrow>
         <mo>-</mo>
         <msup>
          <mi>G</mi>
          <mn>2</mn>
         </msup>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msqrt>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>G</ci>
      <mtext>\plusmn</mtext>
      <apply>
       <root></root>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>n</ci>
          <ci>H</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>G</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=\frac{n}{G\plusmn\sqrt{(n-1)(nH-G^{2})}}
  </annotation>
 </semantics>
</math>

, where the sign is chosen to give the denominator with the larger absolute value, to avoid <a href="loss_of_significance" title="wikilink">loss of significance</a> as iteration proceeds.</li>
<li>Set 

<math display="inline" id="Laguerre's_method:6">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mo>-</mo>
    <mi>a</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}=x_{k}-a
  </annotation>
 </semantics>
</math>

</li>
</ul></li>
<li>Repeat until <em>a</em> is small enough or if the maximum number of iterations has been reached.</li>
</ul>

<p>If a root has been found, the corresponding linear factor can be removed from <em>p</em>. This deflation step reduces the degree of the polynomial by one, so that eventually, approximations for all roots of <em>p</em> can be found. Note however that deflation can lead to approximate factors that differ significantly from the corresponding exact factors. This error is least if the roots are found in the order of increasing magnitude.</p>
<h2 id="derivation">Derivation</h2>

<p>The <a href="fundamental_theorem_of_algebra" title="wikilink">fundamental theorem of algebra</a> states that every <em>n</em>th degree polynomial 

<math display="inline" id="Laguerre's_method:7">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 can be written in the form</p>

<p>

<math display="block" id="Laguerre's_method:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">⋯</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>C</ci>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)=C(x-x_{1})(x-x_{2})\cdots(x-x_{n}),
  </annotation>
 </semantics>
</math>

</p>

<p>such that 

<math display="inline" id="Laguerre's_method:9">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Laguerre's_method:10">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <list>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (k=1,2,...,n)
  </annotation>
 </semantics>
</math>

 are the roots of the polynomial. If we take the <a href="natural_logarithm" title="wikilink">natural logarithm</a> of both sides, we find that</p>

<p>

<math display="block" id="Laguerre's_method:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ln</mi>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>ln</mi>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>C</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>ln</mi>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>ln</mi>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>+</mo>
     <mrow>
      <mi>ln</mi>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ln></ln>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <ln></ln>
      <apply>
       <abs></abs>
       <ci>C</ci>
      </apply>
     </apply>
     <apply>
      <ln></ln>
      <apply>
       <abs></abs>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <ln></ln>
      <apply>
       <abs></abs>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <ln></ln>
      <apply>
       <abs></abs>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ln|p(x)|=\ln|C|+\ln|x-x_{1}|+\ln|x-x_{2}|+\cdots+\ln|x-x_{n}|.
  </annotation>
 </semantics>
</math>

</p>

<p>Denote the derivative by</p>

<p>

<math display="block" id="Laguerre's_method:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mi>d</mi>
      <mrow>
       <mi>d</mi>
       <mi>x</mi>
      </mrow>
     </mfrac>
     <mrow>
      <mi>ln</mi>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
      </mrow>
     </mfrac>
     <mo>+</mo>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
      </mrow>
     </mfrac>
     <mo>+</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>+</mo>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>G</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>d</ci>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <ln></ln>
       <apply>
        <abs></abs>
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=\frac{d}{dx}\ln|p(x)|=\frac{1}{x-x_{1}}+\frac{1}{x-x_{2}}+\cdots+\frac{1}{x-%
x_{n}},
  </annotation>
 </semantics>
</math>

</p>

<p>and the negated second derivative by</p>

<p>

<math display="block" id="Laguerre's_method:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <msup>
        <mi>d</mi>
        <mn>2</mn>
       </msup>
       <mrow>
        <mi>d</mi>
        <msup>
         <mi>x</mi>
         <mn>2</mn>
        </msup>
       </mrow>
      </mfrac>
      <mrow>
       <mi>ln</mi>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <mi>p</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>-</mo>
         <msub>
          <mi>x</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mfrac>
     <mo>+</mo>
     <mfrac>
      <mn>1</mn>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>-</mo>
         <msub>
          <mi>x</mi>
          <mn>2</mn>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mfrac>
     <mo>+</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>+</mo>
     <mfrac>
      <mn>1</mn>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>-</mo>
         <msub>
          <mi>x</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>H</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>d</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <times></times>
         <ci>d</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <ln></ln>
        <apply>
         <abs></abs>
         <apply>
          <times></times>
          <ci>p</ci>
          <ci>x</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>x</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>x</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>x</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=-\frac{d^{2}}{dx^{2}}\ln|p(x)|=\frac{1}{(x-x_{1})^{2}}+\frac{1}{(x-x_{2})^{2%
}}+\cdots+\frac{1}{(x-x_{n})^{2}}.
  </annotation>
 </semantics>
</math>

</p>

<p>We then make what Acton calls a 'drastic set of assumptions', that the root we are looking for, say, 

<math display="inline" id="Laguerre's_method:14">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 is a certain distance away from our guess 

<math display="inline" id="Laguerre's_method:15">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, and all the other roots are clustered together some distance away. If we denote these distances by</p>

<p>

<math display="block" id="Laguerre's_method:16">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>-</mo>
    <mpadded width="+1.7pt">
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <apply>
     <minus></minus>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=x-x_{1}\,
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Laguerre's_method:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mo>=</mo>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mrow>
     <mn>2</mn>
     <mo>,</mo>
     <mn>3</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>b</ci>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>i</ci>
     <list>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
      <ci>normal-…</ci>
      <ci>n</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b=x-x_{i},\quad i=2,3,\ldots,n
  </annotation>
 </semantics>
</math>

 then our equation for 

<math display="inline" id="Laguerre's_method:18">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 may be written as</p>

<p>

<math display="block" id="Laguerre's_method:19">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>a</mi>
    </mfrac>
    <mo>+</mo>
    <mfrac>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mi>b</mi>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>a</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=\frac{1}{a}+\frac{n-1}{b}
  </annotation>
 </semantics>
</math>

 and the expression for 

<math display="inline" id="Laguerre's_method:20">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 becomes</p>

<p>

<math display="block" id="Laguerre's_method:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msup>
       <mi>a</mi>
       <mn>2</mn>
      </msup>
     </mfrac>
     <mo>+</mo>
     <mfrac>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <msup>
       <mi>b</mi>
       <mn>2</mn>
      </msup>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=\frac{1}{a^{2}}+\frac{n-1}{b^{2}}.
  </annotation>
 </semantics>
</math>

 Solving these equations for 

<math display="inline" id="Laguerre's_method:22">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, we find that</p>

<p>

<math display="block" id="Laguerre's_method:23">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mfrac>
    <mi>n</mi>
    <mrow>
     <mi>G</mi>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\plusmn</mtext>
     </merror>
     <msqrt>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mi>n</mi>
          <mi>H</mi>
         </mrow>
         <mo>-</mo>
         <msup>
          <mi>G</mi>
          <mn>2</mn>
         </msup>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msqrt>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>G</ci>
      <mtext>\plusmn</mtext>
      <apply>
       <root></root>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>n</ci>
          <ci>H</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>G</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=\frac{n}{G\plusmn\sqrt{(n-1)(nH-G^{2})}}
  </annotation>
 </semantics>
</math>

, where the square root of a complex number is chosen to produce larger absolute value of the denominator, or equivalently, to satisfy:</p>

<p>

<math display="block" id="Laguerre's_method:24">
 <semantics>
  <mrow>
   <mrow>
    <mo rspace="4.2pt">Re</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mover accent="true">
       <mi>G</mi>
       <mo>¯</mo>
      </mover>
      <mpadded width="+1.7pt">
       <msqrt>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mrow>
            <mi>n</mi>
            <mi>H</mi>
           </mrow>
           <mo>-</mo>
           <msup>
            <mi>G</mi>
            <mn>2</mn>
           </msup>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </msqrt>
      </mpadded>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <ci>Re</ci>
     <apply>
      <times></times>
      <apply>
       <ci>normal-¯</ci>
       <ci>G</ci>
      </apply>
      <apply>
       <root></root>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>n</ci>
          <ci>H</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>G</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Re}\,(\overline{G}\sqrt{(n-1)(nH-G^{2})}\,)>0
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Laguerre's_method:25">
 <semantics>
  <mo>Re</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>Re</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Re}
  </annotation>
 </semantics>
</math>

 denotes real part of a complex number, and 

<math display="inline" id="Laguerre's_method:26">
 <semantics>
  <mover accent="true">
   <mi>G</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{G}
  </annotation>
 </semantics>
</math>

 is a complex conjugation of 

<math display="inline" id="Laguerre's_method:27">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

; or</p>

<p>

<math display="block" id="Laguerre's_method:28">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <msup>
       <mi>p</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mo>⋅</mo>
    <msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mi>n</mi>
       </mfrac>
       <mo>+</mo>
       <mrow>
        <mpadded width="+1.7pt">
         <mfrac>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mi>n</mi>
         </mfrac>
        </mpadded>
        <msqrt>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mrow>
           <mpadded width="+1.7pt">
            <mfrac>
             <mi>n</mi>
             <mrow>
              <mi>n</mi>
              <mo>-</mo>
              <mn>1</mn>
             </mrow>
            </mfrac>
           </mpadded>
           <mfrac>
            <mrow>
             <mi>p</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>x</mi>
              <mo stretchy="false">)</mo>
             </mrow>
             <msup>
              <mi>p</mi>
              <mi>′′</mi>
             </msup>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>x</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mrow>
             <msup>
              <mi>p</mi>
              <mo>′</mo>
             </msup>
             <msup>
              <mrow>
               <mo stretchy="false">(</mo>
               <mi>x</mi>
               <mo stretchy="false">)</mo>
              </mrow>
              <mn>2</mn>
             </msup>
            </mrow>
           </mfrac>
          </mrow>
         </mrow>
        </msqrt>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <root></root>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <apply>
           <times></times>
           <apply>
            <divide></divide>
            <ci>n</ci>
            <apply>
             <minus></minus>
             <ci>n</ci>
             <cn type="integer">1</cn>
            </apply>
           </apply>
           <apply>
            <divide></divide>
            <apply>
             <times></times>
             <ci>p</ci>
             <ci>x</ci>
             <apply>
              <csymbol cd="ambiguous">superscript</csymbol>
              <ci>p</ci>
              <ci>′′</ci>
             </apply>
             <ci>x</ci>
            </apply>
            <apply>
             <times></times>
             <apply>
              <csymbol cd="ambiguous">superscript</csymbol>
              <ci>p</ci>
              <ci>normal-′</ci>
             </apply>
             <apply>
              <csymbol cd="ambiguous">superscript</csymbol>
              <ci>x</ci>
              <cn type="integer">2</cn>
             </apply>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=\frac{p(x)}{p^{\prime}(x)}\cdot\left(\frac{1}{n}+\frac{n-1}{n}\,\sqrt{1-%
\frac{n}{n-1}\,\frac{p(x)p^{\prime\prime}(x)}{p^{\prime}(x)^{2}}}\right)^{-1}
  </annotation>
 </semantics>
</math>

, where the square root of a complex number is chosen to have a non-negative real part.</p>

<p>For small values of 

<math display="inline" id="Laguerre's_method:29">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)
  </annotation>
 </semantics>
</math>

 this formula differs from the offset of the third order <a href="Halley's_method" title="wikilink">Halley's method</a> by an error of 

<math display="inline" id="Laguerre's_method:30">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>p</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>3</mn>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(p(x)^{3})
  </annotation>
 </semantics>
</math>

, so convergence close to a root will be cubic as well.</p>

<p>Note that, even if the 'drastic set of assumptions' does not work for some particular polynomial 

<math display="inline" id="Laguerre's_method:31">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Laguerre's_method:32">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>


 can be transformed into a related polynomial 

<math display="inline" id="Laguerre's_method:33">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 for which the assumptions are correct, e.g. by shifting the origin towards a suitable complex number 

<math display="inline" id="Laguerre's_method:34">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

, giving 

<math display="inline" id="Laguerre's_method:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>z</mi>
      <mo>-</mo>
      <mi>w</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>q</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <apply>
      <minus></minus>
      <ci>z</ci>
      <ci>w</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q(z)=p(z-w)
  </annotation>
 </semantics>
</math>

, to give distinct roots distinct magnitudes if necessary (which it will be if some roots are complex conjugates), and then getting 

<math display="inline" id="Laguerre's_method:36">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Laguerre's_method:37">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>


 by repeatedly applying the root squaring transformation used in <a href="Graeffe's_method" title="wikilink">Graeffe's method</a> enough times to make the smaller roots significantly smaller than the largest root (and so, clustered in comparison); the approximate root from Graeffe's method can then be used to start the new iteration for Laguerre's method on 

<math display="inline" id="Laguerre's_method:38">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

. An approximate root for 

<math display="inline" id="Laguerre's_method:39">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 may then be obtained straightforwardly from that for 

<math display="inline" id="Laguerre's_method:40">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

.</p>

<p>If we make the stronger assumption that the terms in 

<math display="inline" id="Laguerre's_method:41">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 corresponding to the roots 

<math display="inline" id="Laguerre's_method:42">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo rspace="12.5pt">,</mo>
     <mi>i</mi>
    </mrow>
    <mo>=</mo>
    <mn>2</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mn>3</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <ci>i</ci>
     </list>
     <cn type="integer">2</cn>
    </apply>
    <list>
     <cn type="integer">3</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i},\quad i=2,3,\ldots,n
  </annotation>
 </semantics>
</math>


 are negligibly small in comparison to the term corresponding to the root 

<math display="inline" id="Laguerre's_method:43">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

, this leads to <a href="Newton's_method" title="wikilink">Newton's method</a>.</p>
<h2 id="properties">Properties</h2>

<p>If <em>x</em> is a simple root of the polynomial <em>p</em>, then Laguerre's method converges <a href="rate_of_convergence" title="wikilink">cubically</a> whenever the initial guess <em>x</em><sub>0</sub> is close enough to the root <em>x</em>. On the other hand, if <em>x</em> is a <a href="multiple_root" title="wikilink">multiple root</a> then the convergence is only linear. This is obtained with the penalty of calculating values for the polynomial and its first and second derivatives at each stage of the iteration.</p>

<p>A major advantage of Laguerre's method is that it is almost guaranteed to converge to <em>some</em> root of the polynomial <em>no matter where the initial approximation is chosen</em>. This is in contrast to other methods such as the <a href="Newton's_method" title="wikilink">Newton–Raphson method</a> which may fail to converge for poorly chosen initial guesses. It may even converge to a complex root of the polynomial, because of the square root being taken in the calculation of <em>a</em> above may be of a negative number. This may be considered an advantage or a liability depending on the application to which the method is being used. Empirical evidence has shown that convergence failure is extremely rare, making this a good candidate for a general purpose polynomial root finding algorithm. However, given the fairly limited theoretical understanding of the algorithm, many numerical analysts are hesitant to use it as such, and prefer better understood methods such as the <a href="Jenkins–Traub_algorithm" title="wikilink">Jenkins–Traub algorithm</a>, for which more solid theory has been developed. Nevertheless, the algorithm is fairly simple to use compared to these other "sure-fire" methods, easy enough to be used by hand or with the aid of a pocket calculator when an automatic computer is unavailable. The speed at which the method converges means that one is only very rarely required to compute more than a few iterations to get high accuracy.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Root-finding_algorithms" title="wikilink">Category:Root-finding algorithms</a></p>
</body>
</html>
