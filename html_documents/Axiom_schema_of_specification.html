<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1687">Axiom schema of specification</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Axiom schema of specification</h1>
<hr/>

<p>In many popular versions of <a href="axiomatic_set_theory" title="wikilink">axiomatic set theory</a> the <strong>axiom schema of specification</strong>, also known as the <strong>axiom schema of separation</strong>, <strong>subset axiom scheme</strong> or <strong>axiom schema of restricted comprehension</strong> is an <a href="axiom_schema" title="wikilink">axiom schema</a>. Essentially, it says that any definable <a href="subclass_(set_theory)" title="wikilink">subclass</a> of a set is a set.</p>

<p>Some mathematicians call it the <strong>axiom schema of comprehension</strong>, although others use that term for <strong><em>unrestricted</em> comprehension</strong>, discussed below.</p>

<p>Because restricted comprehension solved <a href="Russell's_paradox" title="wikilink">Russell's paradox</a>, several mathematicians including <a class="uri" href="Zermelo" title="wikilink">Zermelo</a>, <a href="Abraham_Fraenkel" title="wikilink">Fraenkel</a>, and <a class="uri" href="Gödel" title="wikilink">Gödel</a> considered it the most important axiom of set theory.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="statement">Statement</h2>

<p>One instance of the schema is included for each formula φ in the language of set theory with free <a href="Variable_(mathematics)" title="wikilink">variables</a> among <em>x</em>, <em>w</em><sub>1</sub>, ..., <em>w</em><sub><em>n</em></sub>, <em>A</em>. So <em>B</em> is not free in φ. In the formal language of set theory, the axiom schema is:</p>

<p>

<math display="block" id="Axiom_schema_of_specification:0">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <msub>
    <mi>w</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mpadded width="+1.7pt">
    <msub>
     <mi>w</mi>
     <mi>n</mi>
    </msub>
   </mpadded>
   <mo>∀</mo>
   <mpadded width="+1.7pt">
    <mi>A</mi>
   </mpadded>
   <mo>∃</mo>
   <mpadded width="+1.7pt">
    <mi>B</mi>
   </mpadded>
   <mo>∀</mo>
   <mpadded width="+1.7pt">
    <mi>x</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>B</mi>
    <mo>⇔</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mo>∈</mo>
     <mi>A</mi>
     <mi mathvariant="italic">and</mi>
     <mi>φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <msub>
       <mi>w</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>w</mi>
       <mi>n</mi>
      </msub>
      <mo>,</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-,</ci>
    <ci>normal-…</ci>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>n</ci>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <exists></exists>
    <csymbol cd="unknown">B</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-⇔</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">x</csymbol>
      <in></in>
      <csymbol cd="unknown">A</csymbol>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">φ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-,</ci>
       <ci>normal-…</ci>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>n</ci>
       </apply>
       <ci>normal-,</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall w_{1},\ldots,w_{n}\,\forall A\,\exists B\,\forall x\,(x\in B%
\Leftrightarrow[x\in A\and\varphi(x,w_{1},\ldots,w_{n},A)])
  </annotation>
 </semantics>
</math>

</p>

<p>or in words:</p>
<dl>
<dd>Given any <a href="Set_(mathematics)" title="wikilink">set</a> <em>A</em>, <a href="Existential_quantification" title="wikilink">there is</a> a set <em>B</em> such that, given any set <em>x</em>, <em>x</em> is a member of <em>B</em> <a href="if_and_only_if" title="wikilink">if and only if</a> <em>x</em> is a member of <em>A</em> <a href="logical_conjunction" title="wikilink">and</a> φ holds for <em>x</em>.
</dd>
</dl>

<p>Note that there is one axiom for every such <a href="predicate_(mathematics)" title="wikilink">predicate</a> φ; thus, this is an <a href="axiom_schema" title="wikilink">axiom schema</a>.</p>

<p>To understand this axiom schema, note that the set <em>B</em> must be a <a class="uri" href="subset" title="wikilink">subset</a> of <em>A</em>. Thus, what the axiom schema is really saying is that, given a set <em>A</em> and a predicate <em>P</em>, we can find a subset <em>B</em> of <em>A</em> whose members are precisely the members of <em>A</em> that satisfy <em>P</em>. By the <a href="axiom_of_extensionality" title="wikilink">axiom of extensionality</a> this set is unique. We usually denote this set using <a href="set-builder_notation" title="wikilink">set-builder notation</a> as {<em>C</em> ∈ <em>A</em> : <em>P</em>(<em>C</em>)}. Thus the essence of the axiom is:</p>
<dl>
<dd>Every <a href="Subclass_(set_theory)" title="wikilink">subclass</a> of a set that is defined by a predicate is itself a set.
</dd>
</dl>

<p>The axiom schema of specification is characteristic of systems of <a href="axiomatic_set_theory" title="wikilink">axiomatic set theory</a> related to the usual set theory <a class="uri" href="ZFC" title="wikilink">ZFC</a>, but does not usually appear in radically different systems of <a href="alternative_set_theory" title="wikilink">alternative set theory</a>. For example, <a href="New_Foundations" title="wikilink">New Foundations</a> and <a href="positive_set_theory" title="wikilink">positive set theory</a> use different restrictions of the <a href="#Unrestricted_comprehension" title="wikilink">axiom of comprehension</a> of <a href="naive_set_theory" title="wikilink">naive set theory</a>. The <a href="Alternative_Set_Theory" title="wikilink">Alternative Set Theory</a> of Vopenka makes a specific point of allowing proper subclasses of sets, called <a href="semiset" title="wikilink">semisets</a>. Even in systems related to ZFC, this scheme is sometimes restricted to formulas with bounded quantifiers, as in <a href="Kripke–Platek_set_theory_with_urelements" title="wikilink">Kripke–Platek set theory with urelements</a>.</p>
<h2 id="relation-to-the-axiom-schema-of-replacement">Relation to the axiom schema of replacement</h2>

<p>The axiom schema of separation can almost be derived from the <a href="axiom_schema_of_replacement" title="wikilink">axiom schema of replacement</a>.</p>

<p>First, recall this axiom schema:</p>

<p>

<math display="block" id="Axiom_schema_of_specification:1">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mpadded width="+1.7pt">
    <mi>A</mi>
   </mpadded>
   <mo>∃</mo>
   <mpadded width="+1.7pt">
    <mi>B</mi>
   </mpadded>
   <mo>∀</mo>
   <mpadded width="+1.7pt">
    <mi>C</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo>∈</mo>
    <mi>B</mi>
    <mo>⇔</mo>
    <mo>∃</mo>
    <mpadded width="+1.7pt">
     <mi>D</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>D</mi>
     <mo>∈</mo>
     <mi>A</mi>
     <mi mathvariant="italic">and</mi>
     <mi>C</mi>
     <mo>=</mo>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>D</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <exists></exists>
    <csymbol cd="unknown">B</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">C</csymbol>
     <in></in>
     <csymbol cd="unknown">B</csymbol>
     <csymbol cd="latexml">iff</csymbol>
     <exists></exists>
     <csymbol cd="unknown">D</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">D</csymbol>
      <in></in>
      <csymbol cd="unknown">A</csymbol>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <eq></eq>
      <csymbol cd="unknown">F</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">D</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall A\,\exists B\,\forall C\,(C\in B\iff\exists D\,[D\in A\and C=F(D)])
  </annotation>
 </semantics>
</math>

</p>

<p>for any <a href="functional_predicate" title="wikilink">functional predicate</a> <em>F</em> in one <a href="Variable_(mathematics)" title="wikilink">variable</a> that doesn't use the symbols <em>A</em>, <em>B</em>, <em>C</em> or <em>D</em>. Given a suitable predicate <em>P</em> for the axiom of specification, define the mapping <em>F</em> by <em>F</em>(<em>D</em>) = <em>D</em> if <em>P</em>(<em>D</em>) is true and <em>F</em>(<em>D</em>) = <em>E</em> if <em>P</em>(<em>D</em>) is false, where <em>E</em> is any member of <em>A</em> such that <em>P</em>(<em>E</em>) is true. Then the set <em>B</em> guaranteed by the axiom of replacement is precisely the set <em>B</em> required for the axiom of specification. The only problem is if no such <em>E</em> exists. But in this case, the set <em>B</em> required for the axiom of separation is the <a href="empty_set" title="wikilink">empty set</a>, so the axiom of separation follows from the axiom of replacement together with the <a href="axiom_of_empty_set" title="wikilink">axiom of empty set</a>.</p>

<p>For this reason, the axiom schema of separation is often left out of modern lists of the Zermelo–Fraenkel axioms. However, it's still important for historical considerations, and for comparison with alternative axiomatizations of set theory, as can be seen for example in the following sections.</p>
<h2 id="unrestricted-comprehension">Unrestricted comprehension</h2>

<p>The <em>axiom schema of comprehension</em> (unrestricted) reads:</p>

<p>

<math display="block" id="Axiom_schema_of_specification:2">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <msub>
    <mi>w</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mpadded width="+1.7pt">
    <msub>
     <mi>w</mi>
     <mi>n</mi>
    </msub>
   </mpadded>
   <mo>∃</mo>
   <mpadded width="+1.7pt">
    <mi>B</mi>
   </mpadded>
   <mo>∀</mo>
   <mpadded width="+1.7pt">
    <mi>x</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>B</mi>
    <mo>⇔</mo>
    <mi>φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <msub>
      <mi>w</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>w</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-,</ci>
    <ci>normal-…</ci>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>n</ci>
    </apply>
    <exists></exists>
    <csymbol cd="unknown">B</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-⇔</ci>
     <csymbol cd="unknown">φ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <ci>normal-…</ci>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>n</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall w_{1},\ldots,w_{n}\,\exists B\,\forall x\,(x\in B\Leftrightarrow%
\varphi(x,w_{1},\ldots,w_{n}))
  </annotation>
 </semantics>
</math>

</p>

<p>that is:</p>
<dl>
<dd>There exists a set <em>B</em> whose members are precisely those objects that satisfy the predicate φ.
</dd>
</dl>

<p>This set <em>B</em> is again unique, and is usually denoted as {<em>x</em> : φ(<em>x</em>, w<sub>1</sub>, ... w<sub>n</sub>)}.</p>

<p>This axiom schema was tacitly used in the early days of <a href="naive_set_theory" title="wikilink">naive set theory</a>, before a strict axiomatization was adopted. Unfortunately, it leads directly to <a href="Russell's_paradox" title="wikilink">Russell's paradox</a> by taking φ(<em>x</em>) to be ¬(<em>x</em>∈<em>x</em>) (i.e., the property that set <em>x</em> is not a member of itself). Therefore, no useful axiomatization of set theory can use unrestricted comprehension, at least not with <a href="classical_logic" title="wikilink">classical logic</a>.</p>

<p>Accepting only the axiom schema of specification was the beginning of axiomatic set theory. Most of the other Zermelo–Fraenkel axioms (but not the <a href="axiom_of_extensionality" title="wikilink">axiom of extensionality</a> or the <a href="axiom_of_regularity" title="wikilink">axiom of regularity</a>) then became necessary to make up for some of what was lost by changing the axiom schema of comprehension to the axiom schema of specification – each of these axioms states that a certain set exists, and defines that set by giving a predicate for its members to satisfy, i.e. it is a special case of the axiom schema of comprehension.</p>
<h2 id="in-nbg-class-theory">In NBG class theory</h2>

<p>In <a href="von_Neumann–Bernays–Gödel_set_theory" title="wikilink">von Neumann–Bernays–Gödel set theory</a>, a distinction is made between sets and <a href="class_(set_theory)" title="wikilink">classes</a>. A class <em>C</em> is a set if and only if it belongs to some class <em>E</em>. In this theory, there is a <a class="uri" href="theorem" title="wikilink">theorem</a> schema that reads</p>

<p>

<math display="block" id="Axiom_schema_of_specification:3">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mi>D</mi>
   <mo>∀</mo>
   <mpadded width="+1.7pt">
    <mi>C</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>C</mi>
     <mo>∈</mo>
     <mi>D</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>⇔</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>C</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="italic">and</mi>
     <mo>∃</mo>
     <mpadded width="+1.7pt">
      <mi>E</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>C</mi>
      <mo>∈</mo>
      <mi>E</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <exists></exists>
    <csymbol cd="unknown">D</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">C</csymbol>
      <in></in>
      <csymbol cd="unknown">D</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <csymbol cd="latexml">iff</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">C</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">and</csymbol>
      <exists></exists>
      <csymbol cd="unknown">E</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">C</csymbol>
       <in></in>
       <csymbol cd="unknown">E</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists D\forall C\,([C\in D]\iff[P(C)\and\exists E\,(C\in E)])\,,
  </annotation>
 </semantics>
</math>

</p>

<p>that is,</p>
<dl>
<dd>"There is a class <em>D</em> such that any class <em>C</em> is a member of <em>D</em> if and only if <em>C</em> is a set that satisfies <em>P</em>."
</dd>
</dl>

<p>provided that the quantifiers in the predicate <em>P</em> are restricted to sets.</p>

<p>This theorem schema is itself a restricted form of comprehension, which avoids Russell's paradox because of the requirement that <em>C</em> be a set. Then specification for sets themselves can be written as a single axiom</p>

<p>

<math display="block" id="Axiom_schema_of_specification:4">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>D</mi>
   <mo>∀</mo>
   <mpadded width="+1.7pt">
    <mi>A</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∃</mo>
    <mpadded width="+1.7pt">
     <mi>E</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>A</mi>
     <mo>∈</mo>
     <mi>E</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>⟹</mo>
    <mo>∃</mo>
    <mpadded width="+1.7pt">
     <mi>B</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">[</mo>
     <mo>∃</mo>
     <mpadded width="+1.7pt">
      <mi>E</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo>∈</mo>
      <mi>E</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="italic">and</mi>
     <mo>∀</mo>
     <mpadded width="+1.7pt">
      <mi>C</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>C</mi>
      <mo>∈</mo>
      <mi>B</mi>
      <mo>⇔</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>C</mi>
       <mo>∈</mo>
       <mi>A</mi>
       <mi mathvariant="italic">and</mi>
       <mi>C</mi>
       <mo>∈</mo>
       <mi>D</mi>
       <mo stretchy="false">]</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">D</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">E</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">A</csymbol>
      <in></in>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <implies></implies>
     <exists></exists>
     <csymbol cd="unknown">B</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <exists></exists>
      <csymbol cd="unknown">E</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">B</csymbol>
       <in></in>
       <csymbol cd="unknown">E</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">C</csymbol>
       <in></in>
       <csymbol cd="unknown">B</csymbol>
       <csymbol cd="latexml">iff</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-[</ci>
        <csymbol cd="unknown">C</csymbol>
        <in></in>
        <csymbol cd="unknown">A</csymbol>
        <csymbol cd="unknown">and</csymbol>
        <csymbol cd="unknown">C</csymbol>
        <in></in>
        <csymbol cd="unknown">D</csymbol>
        <ci>normal-]</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall D\forall A\,(\exists E\,[A\in E]\implies\exists B\,[\exists E\,(B\in E%
)\and\forall C\,(C\in B\iff[C\in A\and C\in D])])\,,
  </annotation>
 </semantics>
</math>

</p>

<p>that is,</p>
<dl>
<dd>"Given any class <em>D</em> and any set <em>A</em>, there is a set <em>B</em> whose members are precisely those classes that are members of both <em>A</em> and <em>D</em>."
</dd>
</dl>

<p>or even more simply</p>
<dl>
<dd>"The <a href="intersection_(set_theory)" title="wikilink">intersection</a> of a class <em>D</em> and a set <em>A</em> is itself a set <em>B</em>.".
</dd>
</dl>

<p>In this axiom, the predicate <em>P</em> is replaced by the class <em>D</em>, which can be quantified over. Another simpler axiom which achieves the same effect is</p>

<p>

<math display="block" id="Axiom_schema_of_specification:5">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>A</mi>
   <mo>∀</mo>
   <mpadded width="+1.7pt">
    <mi>B</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mo>∃</mo>
     <mpadded width="+1.7pt">
      <mi>E</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo>∈</mo>
      <mi>E</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="italic">and</mi>
     <mo>∀</mo>
     <mpadded width="+1.7pt">
      <mi>C</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>C</mi>
      <mo>∈</mo>
      <mi>B</mi>
      <mo>⟹</mo>
      <mi>C</mi>
      <mo>∈</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>⟹</mo>
    <mo>∃</mo>
    <mpadded width="+1.7pt">
     <mi>E</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>B</mi>
     <mo>∈</mo>
     <mi>E</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">B</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <exists></exists>
      <csymbol cd="unknown">E</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <in></in>
       <csymbol cd="unknown">E</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">and</csymbol>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">C</csymbol>
       <in></in>
       <csymbol cd="unknown">B</csymbol>
       <implies></implies>
       <csymbol cd="unknown">C</csymbol>
       <in></in>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <implies></implies>
     <exists></exists>
     <csymbol cd="unknown">E</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">B</csymbol>
      <in></in>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall A\forall B\,([\exists E\,(A\in E)\and\forall C\,(C\in B\implies C\in A%
)]\implies\exists E\,[B\in E])\,,
  </annotation>
 </semantics>
</math>

</p>

<p>that is,</p>
<dl>
<dd>"A subclass of a set is a set.".
</dd>
</dl>
<h2 id="in-higher-order-settings">In higher-order settings</h2>

<p>In a <a href="type_theory" title="wikilink">typed</a> language where we can quantify over predicates, the axiom schema of specification becomes a simple axiom. This is much the same trick as was used in the NBG axioms of the previous section, where the predicate was replaced by a class that was then quantified over.</p>

<p>In <a href="second-order_logic" title="wikilink">second-order logic</a> and <a href="higher-order_logic" title="wikilink">higher-order logic</a> with higher-order semantics, the axiom of specification is a logical validity and does not need to be explicitly included in a theory.</p>
<h2 id="in-quines-new-foundations">In Quine's New Foundations</h2>

<p>In the <a href="New_Foundations" title="wikilink">New Foundations</a> approach to set theory pioneered by <a href="W.V.O._Quine" title="wikilink">W.V.O. Quine</a>, the axiom of comprehension for a given predicate takes the unrestricted form, but the predicates that may be used in the schema are themselves restricted. The predicate (<em>C</em> is not in <em>C</em>) is forbidden, because the same symbol <em>C</em> appears on both sides of the membership symbol (and so at different "relative types"); thus, Russell's paradox is avoided. However, by taking <em>P</em>(<em>C</em>) to be (<em>C</em> = <em>C</em>), which is allowed, we can form a set of all sets. For details, see <a href="stratification_(mathematics)" title="wikilink">stratification</a>.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li><a href="Paul_Halmos" title="wikilink">Halmos, Paul</a>, <em><a href="Naive_Set_Theory_(book)" title="wikilink">Naive Set Theory</a></em>. Princeton, NJ: D. Van Nostrand Company, 1960. Reprinted by Springer-Verlag, New York, 1974. ISBN 0-387-90092-6 (Springer-Verlag edition).</li>
<li>Jech, Thomas, 2003. <em>Set Theory: The Third Millennium Edition, Revised and Expanded</em>. Springer. ISBN 3-540-44085-2.</li>
<li>Kunen, Kenneth, 1980. <em>Set Theory: An Introduction to Independence Proofs</em>. Elsevier. ISBN 0-444-86839-9.</li>
</ul>

<p>"</p>

<p><a href="Category:Axioms_of_set_theory" title="wikilink">Category:Axioms of set theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
