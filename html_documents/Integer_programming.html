<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="725">Integer programming</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Integer programming</h1>
<hr/>

<p>An <strong>integer programming</strong> problem is a mathematical <a href="Optimization_(mathematics)" title="wikilink">optimization</a> or <a href="Constraint_satisfaction_problem" title="wikilink">feasibility</a> program in which some or all of the variables are restricted to be integers. In many settings the term refers to <strong>integer <a href="linear_programming" title="wikilink">linear programming</a></strong> (ILP), in which the objective function and the constraints (other than the integer constraints) are <a href="Linear_function_(calculus)" title="wikilink">linear</a>.</p>

<p>Integer programming is <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>. A special case, 0-1 integer linear programming, in which unknowns are binary, and only the restrictions must be satisfied, is one of <a href="Karp's_21_NP-complete_problems" title="wikilink">Karp's 21 NP-complete problems</a>.</p>
<h2 id="canonical-and-standard-form-for-ilps">Canonical and standard form for ILPs</h2>

<p>An integer linear program in canonical form is expressed as:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>

<math display="inline" id="Integer_programming:0">
 <semantics>
  <mrow>
   <msup>
    <mi>𝐜</mi>
    <mi mathvariant="normal">T</mi>
   </msup>
   <mi>𝐱</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐜</ci>
     <ci>normal-T</ci>
    </apply>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\mathbf{c}^{\mathrm{T}}\mathbf{x}
  </annotation>
 </semantics>
</math>


,</p>

<p>and an ILP in standard form is expressed as</p>

<p>

<math display="inline" id="Integer_programming:1">
 <semantics>
  <mrow>
   <msup>
    <mi>𝐜</mi>
    <mi mathvariant="normal">T</mi>
   </msup>
   <mi>𝐱</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐜</ci>
     <ci>normal-T</ci>
    </apply>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\mathbf{c}^{\mathrm{T}}\mathbf{x}
  </annotation>
 </semantics>
</math>


 where the entries of 

<math display="inline" id="Integer_programming:2">
 <semantics>
  <mrow>
   <mi>𝐜</mi>
   <mo>,</mo>
   <mi>𝐛</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>𝐜</ci>
    <ci>𝐛</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{c},\mathbf{b}
  </annotation>
 </semantics>
</math>

 are vectors and 

<math display="inline" id="Integer_programming:3">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is a matrix, having integer values. Note that similar to linear programs, ILPs not in standard form can be <a href="simplex_algorithm#Standard_form" title="wikilink">converted to standard form</a> by eliminating inequalities by introducing slack variables (

<math display="inline" id="Integer_programming:4">
 <semantics>
  <mi>𝐬</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐬</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}
  </annotation>
 </semantics>
</math>

) and replacing variables that are not sign-constrained with the difference of two sign-constrained variables</p>
<h2 id="example">Example</h2>

<p> The graph on the right shows the following problem.</p>

<p>

<math display="inline" id="Integer_programming:5">
 <semantics>
  <mi>max</mi>
  <annotation-xml encoding="MathML-Content">
   <max></max>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\max
  </annotation>
 </semantics>
</math>


</p>

<p>The feasible integer points are shown in red, and the red dashed lines indicate their convex hull, which is the smallest polyhedron that contains all of these points. The blue lines together with the coordinate axes define the polyhedron of the LP relaxation, which is given by the inequalities without the integrality constraint. The goal of the optimization is to move the black dotted line as far upward while still touching the polyhedron. The optimal solutions of the integer problem are the points 

<math display="inline" id="Integer_programming:6">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1,2)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Integer_programming:7">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">2</cn>
    <cn type="integer">2</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (2,2)
  </annotation>
 </semantics>
</math>

 which both have an objective value of 2. The unique optimum of the relaxation is 

<math display="inline" id="Integer_programming:8">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>1.8</mn>
   <mo>,</mo>
   <mn>2.8</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="float">1.8</cn>
    <cn type="float">2.8</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1.8,2.8)
  </annotation>
 </semantics>
</math>

 with objective value of 2.8. Note that if the solution of the relaxation is rounded to the nearest integers, it is not feasible for the ILP.</p>
<h2 id="proof-of-np-hardness">Proof of NP-hardness</h2>

<p>The following is a reduction from Minimum <a href="Vertex_Cover" title="wikilink">Vertex Cover</a> to Integer Programming that will serve as the proof of NP-hardness.</p>

<p>Let 

<math display="inline" id="Integer_programming:9">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

 be an undirected graph. Define a linear program as follows:</p>

<p>

<math display="inline" id="Integer_programming:10">
 <semantics>
  <mrow>
   <mi>min</mi>
   <mrow>
    <mstyle displaystyle="true">
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>v</mi>
       <mo>∈</mo>
       <mi>V</mi>
      </mrow>
     </munder>
    </mstyle>
    <msub>
     <mi>y</mi>
     <mi>v</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <min></min>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>v</ci>
       <ci>V</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\min\sum_{v\in V}y_{v}
  </annotation>
 </semantics>
</math>


</p>

<p>Given that the constraints limit 

<math display="inline" id="Integer_programming:11">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>v</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{v}
  </annotation>
 </semantics>
</math>

 to either 0 or 1, any feasible solution to the integer program is a subset of vertices. The first constraint implies that at least one end point of every edge is included in this subset. Therefore the solution describes a vertex cover. Additionally given some vertex cover C, 

<math display="inline" id="Integer_programming:12">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>v</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{v}
  </annotation>
 </semantics>
</math>

 can be set to 1 for any 

<math display="inline" id="Integer_programming:13">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in C
  </annotation>
 </semantics>
</math>

 and to 0 for any 

<math display="inline" id="Integer_programming:14">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∉</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>v</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\not\in C
  </annotation>
 </semantics>
</math>

 thus giving us a feasible solution to the integer program. Thus we can conclude that if we minimize the sum of 

<math display="inline" id="Integer_programming:15">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>v</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{v}
  </annotation>
 </semantics>
</math>

 we have also found the minimum vertex cover. <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="variants">Variants</h2>

<p><strong>Mixed integer linear programming</strong> (MILP) involves problems in which only some of the variables, 

<math display="inline" id="Integer_programming:16">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

, are constrained to be integers, while other variables are allowed to be non-integers.</p>

<p><strong>Zero-one linear programming</strong> involves problems in which the variables are restricted to be either 0 or 1. Note that any bounded integer variable can be expressed as a combination of binary variables.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> For example, given an integer variable, 

<math display="inline" id="Integer_programming:17">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <mi>x</mi>
   <mo>≤</mo>
   <mi>U</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>x</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>U</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq x\leq U
  </annotation>
 </semantics>
</math>

, the variable can be expressed using 

<math display="inline" id="Integer_programming:18">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⌊</mo>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>2</mn>
     </msub>
     <mi>U</mi>
    </mrow>
    <mo stretchy="false">⌋</mo>
   </mrow>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <floor></floor>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <ci>U</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lfloor\log_{2}U\rfloor+1
  </annotation>
 </semantics>
</math>

 binary variables:</p>

<p>

<math display="block" id="Integer_programming:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>+</mo>
     <mrow>
      <mn>2</mn>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mn>4</mn>
      <msub>
       <mi>x</mi>
       <mn>3</mn>
      </msub>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">…</mi>
     <mo>+</mo>
     <mrow>
      <msup>
       <mn>2</mn>
       <mrow>
        <mo stretchy="false">⌊</mo>
        <mrow>
         <msub>
          <mi>log</mi>
          <mn>2</mn>
         </msub>
         <mi>U</mi>
        </mrow>
        <mo stretchy="false">⌋</mo>
       </mrow>
      </msup>
      <msub>
       <mi>x</mi>
       <mrow>
        <mrow>
         <mo stretchy="false">⌊</mo>
         <mrow>
          <msub>
           <mi>log</mi>
           <mn>2</mn>
          </msub>
          <mi>U</mi>
         </mrow>
         <mo stretchy="false">⌋</mo>
        </mrow>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">4</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <floor></floor>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <log></log>
          <cn type="integer">2</cn>
         </apply>
         <ci>U</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <apply>
         <floor></floor>
         <apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <log></log>
           <cn type="integer">2</cn>
          </apply>
          <ci>U</ci>
         </apply>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=x_{1}+2x_{2}+4x_{3}+\ldots+2^{\lfloor\log_{2}U\rfloor}x_{\lfloor\log_{2}U%
\rfloor+1}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="example-problems-that-can-be-formulated-as-ilps">Example problems that can be formulated as ILPs</h2>

<p>A large number of problems can be formulated as ILPs. These include</p>
<ul>
<li><a href="Traveling_salesman_problem#Integer_linear_programming_formulation" title="wikilink">Traveling Salesman</a></li>
<li><a href="vertex_cover#ILP_formulation" title="wikilink">Vertex Cover</a> and other <a href="Covering_problem" title="wikilink">Covering problems</a></li>
<li><a href="Set_packing#Integer_linear_program_formulation" title="wikilink">Set packing</a> and other <a href="Packing_problem" title="wikilink">Packing problems</a></li>
<li><a href="Boolean_satisfiability_problem" title="wikilink">Boolean satisfiability</a></li>
</ul>

<p>Since the decision version of integer linear programming is in <a href="NP_(complexity)" title="wikilink">NP</a> (solutions can be verified in polynomial time) and there are <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problems that can be polynomially reduced to ILPs, the decision version of integer linear programming is NP-complete.</p>
<h2 id="applications">Applications</h2>

<p>There are two main reasons for using integer variables when modeling problems as a linear program:</p>
<ol>
<li>The integer variables represent quantities that can only be integer. For example, it is not possible to build 3.7 cars.</li>
<li>The integer variables represent decisions and so should only take on the value 0 or 1 .</li>
</ol>

<p>These considerations occur frequently in practice and so integer linear programming can be used in many applications areas, some of which are briefly described below.</p>
<h3 id="production-planning">Production planning</h3>

<p>Mixed integer programming has many applications in industrial production, including job-shop modelling. One important example happens In agricultural <a href="production_planning" title="wikilink">production planning</a> involves determining production yield for several crops that can share resources (e.g. Land, labor, capital seeds fertilizer, etc.). A possible objective is to maximize the total production, without exceeding the available resources. In some cases, this can be expressed in terms of a linear program, but variables must be constrained to be integer.</p>
<h3 id="scheduling">Scheduling</h3>

<p>These problems involve service and vehicle scheduling in transportation networks. For example, a problem may involve assigning buses or subways to individual routes so that a timetable can be met, and also to equip them with drivers. Here binary decision variables indicate whether a bus or subway is assigned to a route and whether a driver is assigned to a particular train or subway.</p>
<h3 id="telecommunications-networks">Telecommunications networks</h3>

<p>The goal of these problems is to design a network of lines to install so that a predefined set of communication requirements are met and the total cost of the network is minimal.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> This requires optimizing both the topology of the network along with the setting the capacities of the various lines. In many cases, the capacities are constrained to be integer quantities. Usually there are, depending on the technology used, additional restrictions that can be modeled as a linear inequalities with integer or binary variables.</p>
<h3 id="cellular-networks">Cellular networks</h3>

<p>The task of frequency planning in <a class="uri" href="GSM" title="wikilink">GSM</a> mobile networks involves distributing available frequencies across the antennas so that users can be served and interference is minimized between the antennas.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> This problem can be formulated as an integer linear program in which binary variables indicate whether a frequency is assigned to an antenna.</p>
<h2 id="algorithms">Algorithms</h2>

<p>The naive way to solve an ILP is to simply remove the constraint that <strong>x</strong> is integral, solve the corresponding LP (called the <a href="Linear_programming_relaxation" title="wikilink">LP relaxation</a> of the ILP), and then round the entries of the solution to the LP relaxation. But, not only may this solution not be optimal, it may not even be feasible, that is it may violate some constraint.</p>
<h3 id="using-total-unimodularity">Using total unimodularity</h3>

<p>While in general the solution to LP relaxation will not be guaranteed to be optimal, if the ILP has the form 

<math display="inline" id="Integer_programming:20">
 <semantics>
  <mrow>
   <mi>max</mi>
   <mrow>
    <msup>
     <mi>𝐜</mi>
     <mi mathvariant="normal">T</mi>
    </msup>
    <mi>𝐱</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <max></max>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐜</ci>
      <ci>normal-T</ci>
     </apply>
     <ci>𝐱</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max\mathbf{c}^{\mathrm{T}}\mathbf{x}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Integer_programming:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>𝐱</mi>
   </mrow>
   <mo>=</mo>
   <mi>𝐛</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>𝐱</ci>
    </apply>
    <ci>𝐛</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\mathbf{x}=\mathbf{b}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Integer_programming:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>,</mo>
    <mi>𝐛</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>A</ci>
    <ci>𝐛</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A,\mathbf{b},
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Integer_programming:23">
 <semantics>
  <mi>𝐜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{c}
  </annotation>
 </semantics>
</math>

 have all integer entries and 

<math display="inline" id="Integer_programming:24">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is <a href="unimodular_matrix#Total_unimodularity" title="wikilink">totally unimodular</a>, then every basic feasible solution is integral. Consequently, the solution returned by the <a href="simplex_algorithm" title="wikilink">simplex algorithm</a> is guaranteed to be integral. To show that every basic feasible solution is integral, let 

<math display="inline" id="Integer_programming:25">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 be an arbitrary basic feasible solution . Since 

<math display="inline" id="Integer_programming:26">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 is feasible, we know that 

<math display="inline" id="Integer_programming:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>𝐱</mi>
   </mrow>
   <mo>=</mo>
   <mi>𝐛</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>𝐱</ci>
    </apply>
    <ci>𝐛</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\mathbf{x}=\mathbf{b}
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Integer_programming:28">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐱</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>x</mi>
     <msub>
      <mi>n</mi>
      <mn>1</mn>
     </msub>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <msub>
      <mi>n</mi>
      <mn>2</mn>
     </msub>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <msub>
      <mi>n</mi>
      <mi>j</mi>
     </msub>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <cn type="integer">0</cn>
    </apply>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{0}=[x_{n_{1}},x_{n_{2}},\cdots,x_{n_{j}}]
  </annotation>
 </semantics>
</math>

 be the elements corresponding to the basis columns for the basic solution 

<math display="inline" id="Integer_programming:29">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

. By definition of a basis, there is some square submatrix 

<math display="inline" id="Integer_programming:30">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Integer_programming:31">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 with linearly independent columns such that 

<math display="inline" id="Integer_programming:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>B</mi>
    <msub>
     <mi>𝐱</mi>
     <mn>0</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>𝐛</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>B</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <ci>𝐛</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\mathbf{x}_{0}=\mathbf{b}
  </annotation>
 </semantics>
</math>

.</p>

<p>Since the columns of 

<math display="inline" id="Integer_programming:33">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 are linearly independent and 

<math display="inline" id="Integer_programming:34">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is square, 

<math display="inline" id="Integer_programming:35">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is nonsingular, and therefore by assumption, 

<math display="inline" id="Integer_programming:36">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is <a href="unimodular_matrix" title="wikilink">unimodular</a> and so 

<math display="inline" id="Integer_programming:37">
 <semantics>
  <mrow>
   <mrow>
    <mo>det</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>±</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <determinant></determinant>
     <ci>B</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">plus-or-minus</csymbol>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \det(B)=\pm 1
  </annotation>
 </semantics>
</math>

. Also, since 

<math display="inline" id="Integer_programming:38">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is nonsingular, it is invertible and therefore 

<math display="inline" id="Integer_programming:39">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐱</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>B</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>𝐛</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>𝐛</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{0}=B^{-1}\mathbf{b}
  </annotation>
 </semantics>
</math>

. By definition, 

<math display="inline" id="Integer_programming:40">
 <semantics>
  <mrow>
   <msup>
    <mi>B</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>=</mo>
   <mfrac>
    <msup>
     <mi>B</mi>
     <mrow>
      <mi>a</mi>
      <mi>d</mi>
      <mi>j</mi>
     </mrow>
    </msup>
    <mrow>
     <mo>det</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mo>±</mo>
    <msup>
     <mi>B</mi>
     <mrow>
      <mi>a</mi>
      <mi>d</mi>
      <mi>j</mi>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>d</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <determinant></determinant>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">plus-or-minus</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>d</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{-1}=\frac{B^{adj}}{\det(B)}=\pm B^{adj}
  </annotation>
 </semantics>
</math>

. Note that 

<math display="inline" id="Integer_programming:41">
 <semantics>
  <msup>
   <mi>B</mi>
   <mrow>
    <mi>a</mi>
    <mi>d</mi>
    <mi>j</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>B</ci>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>d</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{adj}
  </annotation>
 </semantics>
</math>

 denotes the <a href="Adjugate_matrix" title="wikilink">adjugate</a> of 

<math display="inline" id="Integer_programming:42">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 and is integral because 

<math display="inline" id="Integer_programming:43">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is integer. Therefore,</p>

<p>

<math display="inline" id="Integer_programming:44">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⇒</mo>
   <msup>
    <mi>B</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo>±</mo>
    <mrow>
     <msup>
      <mi>B</mi>
      <mrow>
       <mi>a</mi>
       <mi>d</mi>
       <mi>j</mi>
      </mrow>
     </msup>
     <mtext>is integral.</mtext>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-⇒</ci>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">plus-or-minus</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>B</ci>
        <apply>
         <times></times>
         <ci>a</ci>
         <ci>d</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <mtext>is integral.</mtext>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\Rightarrow B^{-1}=\pm B^{adj}\text{ is integral.}
  </annotation>
 </semantics>
</math>


 Thus, if the matrix 

<math display="inline" id="Integer_programming:45">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>


 of an ILP is totally unimodular, rather than use an ILP algorithm, the simplex method can be used to solve the LP relaxation and the solution will be integer.</p>
<h3 id="exact-algorithms">Exact algorithms</h3>

<p>When the matrix 

<math display="inline" id="Integer_programming:46">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is not totally unimodular, there are a variety of algorithms that can be used to solve integer linear programs exactly. One class of algorithms are <a href="Cutting-plane_method" title="wikilink">cutting plane methods</a> which work by solving the LP relaxation and then adding linear constraints that drive the solution towards being integer without excluding any integer feasible points.</p>

<p>Another class of algorithms are variants of the <a href="branch_and_bound" title="wikilink">branch and bound</a> method. For example, the <a href="branch_and_cut" title="wikilink">branch and cut</a> method that combines both branch and bound and cutting plane methods. Branch and bound algorithms have a number of advantages over algorithms that only use cutting planes. One advantage is that the algorithms can be terminated early and as long as at least one integral solution has been found, a feasible, although not necessarily optimal, solution can be returned. Further, the solutions of the LP relaxations can be used to provide a worst-case estimate of how far from optimality the returned solution is. Finally, branch and bound methods can be used to return multiple optimal solutions.</p>

<p>Lenstra in 1983 showed,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> that when number of variables is fixed, integer programming problem can be solved in a polynomial time.</p>
<h3 id="heuristic-methods">Heuristic methods</h3>

<p>Since integer linear programming is <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>, many problem instances are intractable and so heuristic methods must be used instead. For example, <a href="tabu_search" title="wikilink">tabu search</a> can be used to search for solutions to ILPs.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> To use tabu search to solve ILPs, moves can be defined as incrementing or decrementing an integer constrained variable of a feasible solution, while keeping all other integer-constrained variables constant. The unrestricted variables are then solved for. Short term memory can consist of previous tried solutions while medium term memory can consist of values for the integer constrained variables that have resulted in high objective values (assuming the ILP is a maximization problem). Finally, long term memory can guide the search towards integer values that have not previously been tried.</p>

<p>Other heuristic methods that can be applied to ILPs include</p>
<ul>
<li><a href="Hill_climbing" title="wikilink">Hill climbing</a></li>
<li><a href="Simulated_annealing" title="wikilink">Simulated annealing</a></li>
<li><a href="Reactive_search_optimization" title="wikilink">Reactive search optimization</a></li>
<li><a href="Ant_colony_optimization_algorithms" title="wikilink">Ant colony optimization</a></li>
<li><a href="Hopfield_network" title="wikilink">Hopfield neural networks</a></li>
</ul>

<p>There are also a variety of other problem-specific heuristics, such as the <a href="Travelling_salesman_problem#Iterative_improvement" title="wikilink">k-opt heuristic</a> for the travelling salesman problem. Note that a disadvantage of heuristic methods is that if they fail to find a solution, it cannot be determined whether it is because there is no feasible solution or whether the algorithm simply was unable to find one. Further, it is usually impossible to quantify how close to optimal a solution returned by these methods is.</p>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://mat.gsia.cmu.edu/orclass/integer/integer.html">A Tutorial on Integer Programming</a></li>
<li>Conference <a href="http://www.mathopt.org/?nav=ipco">Integer Programming and Combinatorial Optimization, IPCO</a></li>
<li><a href="http://www.iasi.cnr.it/aussois">The Aussois Combinatorial Optimization Workshop</a></li>
</ul>

<p>"</p>

<p><a href="Category:Operations_research" title="wikilink">Category:Operations research</a> <a href="Category:Combinatorial_optimization" title="wikilink">Category:Combinatorial optimization</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="Hendrik_Lenstra" title="wikilink">H.W. Lenstra</a>, "Integer programming with a fixed number of variables", Mathematics of operations research, Vol 8, No 8, November 1983<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
