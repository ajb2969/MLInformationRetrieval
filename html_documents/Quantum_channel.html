<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1365">Quantum channel</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Quantum channel</h1>
<hr/>

<p>In <a href="quantum_information_theory" title="wikilink">quantum information theory</a>, a <strong>quantum channel</strong> is a communication channel which can transmit <a href="quantum_information" title="wikilink">quantum information</a>, as well as classical information. An example of quantum information is the state of a <a class="uri" href="qubit" title="wikilink">qubit</a>. An example of classical information is a text document transmitted over the <a class="uri" href="Internet" title="wikilink">Internet</a>.</p>

<p>More formally, quantum channels are <a href="completely_positive" title="wikilink">completely positive</a> (CP) trace-preserving maps between spaces of operators. In other words, a quantum channel is just a <a href="quantum_operation" title="wikilink">quantum operation</a> viewed not merely as the <a href="reduced_dynamics" title="wikilink">reduced dynamics</a> of a system but as a pipeline intended to carry quantum information. (Some authors use the term "quantum operation" to also include trace-decreasing maps while reserving "quantum channel" for strictly trace-preserving maps.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>)</p>
<h2 id="memoryless-quantum-channel">Memoryless quantum channel</h2>

<p>We will assume for the moment that all state spaces of the systems considered, classical or quantum, are finite-dimensional.</p>

<p>The <strong>memoryless</strong> in the section title carries the same meaning as in classical <a href="information_theory" title="wikilink">information theory</a>: the output of a channel at a given time depends only upon the corresponding input and not any previous ones.</p>
<h3 id="schrödinger-picture">Schrödinger picture</h3>

<p>Consider quantum channels that transmit only quantum information. This is precisely a <a href="quantum_operation" title="wikilink">quantum operation</a>, whose properties we now summarize.</p>

<p>Let 

<math display="inline" id="Quantum_channel:0">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{A}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_channel:1">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{B}
  </annotation>
 </semantics>
</math>

 be the state spaces (finite-dimensional <a href="Hilbert_space" title="wikilink">Hilbert spaces</a>) of the sending and receiving ends, respectively, of a channel. 

<math display="inline" id="Quantum_channel:2">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>H</mi>
     <mi>A</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(H_{A})
  </annotation>
 </semantics>
</math>

 will denote the family of operators on 

<math display="inline" id="Quantum_channel:3">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{A}
  </annotation>
 </semantics>
</math>

. In the <a href="Schrödinger_picture" title="wikilink">Schrödinger picture</a>, a purely quantum channel is a map Φ between <a href="density_matrix" title="wikilink">density matrices</a> acting on 

<math display="inline" id="Quantum_channel:4">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{A}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_channel:5">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{B}
  </annotation>
 </semantics>
</math>

 with the following properties:</p>
<ol>
<li>As required by postulates of quantum mechanics, Φ needs to be linear.</li>
<li>Since density matrices are positive, Φ must preserve the <a href="cone_(linear_algebra)" title="wikilink">cone</a> of positive elements. In other words, Φ is a <a href="Choi's_theorem_on_completely_positive_maps" title="wikilink">positive map</a>.</li>
<li>If an <a href="ancilla_(quantum_computing)" title="wikilink">ancilla</a> of arbitrary finite dimension <em>n</em> is coupled to the system, then the induced map 

<math display="inline" id="Quantum_channel:6">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mi>n</mi>
   </msub>
   <mo>⊗</mo>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>n</ci>
    </apply>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{n}\otimes\Phi
  </annotation>
 </semantics>
</math>

, where <em>I</em><sub><em>n</em></sub> is the identity map on the ancilla, must also be positive. Therefore it is required that 

<math display="inline" id="Quantum_channel:7">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mi>n</mi>
   </msub>
   <mo>⊗</mo>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>n</ci>
    </apply>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{n}\otimes\Phi
  </annotation>
 </semantics>
</math>

 is positive for all <em>n</em>. Such maps are called <a href="completely_positive" title="wikilink">completely positive</a>.</li>
<li>Density matrices are specified to have trace 1, so Φ has to preserve the trace.</li>
</ol>

<p>The adjectives <strong>completely positive and trace preserving</strong> used to describe a map are sometimes abbreviated <strong>CPTP</strong>. In the literature, sometimes the fourth property is weakened so that Φ is only required to be not trace-increasing. In this article, it will be assumed that all channels are CPTP.</p>
<h3 id="heisenberg-picture">Heisenberg picture</h3>

<p>Density matrices acting on <em>H<sub>A</sub></em> only constitute a proper subset of the operators on <em>H<sub>A</sub></em> and same can be said for system <em>B</em>. However, once a linear map Φ between the density matrices is specified, a standard linearity argument, together with the finite-dimensional assumption, allow us to extend Φ uniquely to the full space of operators. This leads to the adjoint map Φ<sup>*</sup>, which describes the action of Φ in the <a href="Heisenberg_picture" title="wikilink">Heisenberg picture</a>:</p>

<p>The spaces of operators <em>L</em>(<em>H</em><sub><em>A</em></sub>) and <em>L</em>(<em>H</em><sub><em>B</em></sub>) are Hilbert spaces with the <a href="Hilbert–Schmidt_operator" title="wikilink">Hilbert–Schmidt</a> inner product. Therefore, viewing 

<math display="inline" id="Quantum_channel:8">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>H</mi>
       <mi>A</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>H</mi>
       <mi>B</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>normal-Φ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>A</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi:L(H_{A})\rightarrow L(H_{B})
  </annotation>
 </semantics>
</math>

 as a map between Hilbert spaces, we obtain its adjoint Φ<sup>*</sup> given by</p>

<p>

<math display="block" id="Quantum_channel:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mrow>
      <mi mathvariant="normal">Φ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ρ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <msup>
       <mi mathvariant="normal">Φ</mi>
       <mo>*</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>ρ</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>normal-Φ</ci>
      <ci>ρ</ci>
     </apply>
    </list>
    <list>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Φ</ci>
       <times></times>
      </apply>
      <ci>A</ci>
     </apply>
     <ci>ρ</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle A,\Phi(\rho)\rangle=\langle\Phi^{*}(A),\rho\rangle.
  </annotation>
 </semantics>
</math>

</p>

<p>While Φ takes states on <em>A</em> to those on <em>B</em>, Φ<sup>*</sup> maps observables on system <em>B</em> to observables on <em>A</em>. This relationship is same as that between the Schrödinger and Heisenberg descriptions of dynamics. The measurement statistics remain unchanged whether the observables are considered fixed while the states undergo operation or vice versa.</p>

<p>It can be directly checked that if Φ is assumed to be trace preserving, Φ<sup>*</sup> is <a href="unital_map" title="wikilink">unital</a>, that is,Φ<sup>*</sup>(<em>I</em>) = <em>I</em>. Physically speaking, this means that, in the Heisenberg picture, the trivial observable remains trivial after applying the channel.</p>
<h3 id="classical-information">Classical information</h3>

<p>So far we have only defined quantum channel that transmits only quantum information. As stated in the introduction, the input and output of a channel can include classical information as well. To describe this, the formulation given so far needs to be generalized somewhat. A purely quantum channel, in the Heisenberg picture, is a linear map Ψ between spaces of operators:</p>

<p>

<math display="block" id="Quantum_channel:10">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ψ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>H</mi>
       <mi>B</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>H</mi>
       <mi>A</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>normal-Ψ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi:L(H_{B})\rightarrow L(H_{A})
  </annotation>
 </semantics>
</math>

</p>

<p>that is unital and completely positive (<strong>CP</strong>). The operator spaces can be viewed as finite-dimensional <a href="C*-algebra" title="wikilink">C*-algebras</a>. Therefore we can say a channel is a unital CP map between C*-algebras:</p>

<p>

<math display="block" id="Quantum_channel:11">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Ψ</mi>
    <mo>:</mo>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">ℬ</mi>
     <mo>→</mo>
     <mi class="ltx_font_mathcaligraphic">𝒜</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>normal-Ψ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>ℬ</ci>
     <ci>𝒜</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi:\mathcal{B}\rightarrow\mathcal{A}.
  </annotation>
 </semantics>
</math>

</p>

<p>Classical information can then be included in this formulation. The observables of a classical system can be assumed to be a commutative C*-algebra, i.e. the space of continuous functions <em>C</em>(<em>X</em>) on some set <em>X</em>. We assume <em>X</em> is finite so <em>C</em>(<em>X</em>) can be identified with the <em>n</em>-dimensional Euclidean space 

<math display="inline" id="Quantum_channel:12">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

 with entry-wise multiplication.</p>

<p>Therefore, in the Heisenberg picture, if the classical information is part of, say, the input, we would define 

<math display="inline" id="Quantum_channel:13">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

 to include the relevant classical observables. An example of this would be a channel</p>

<p>

<math display="block" id="Quantum_channel:14">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Ψ</mi>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mrow>
       <mrow>
        <mi>L</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>H</mi>
          <mi>B</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⊗</mo>
       <mi>C</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>→</mo>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>H</mi>
        <mi>A</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>normal-Ψ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <ci>L</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <ci>B</ci>
        </apply>
       </apply>
       <ci>C</ci>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi:L(H_{B})\otimes C(X)\rightarrow L(H_{A}).
  </annotation>
 </semantics>
</math>

</p>

<p>Notice 

<math display="inline" id="Quantum_channel:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>H</mi>
       <mi>B</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊗</mo>
    <mi>C</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <ci>C</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(H_{B})\otimes C(X)
  </annotation>
 </semantics>
</math>

 is still a C*-algebra. An element <em>a</em> of a C*-algebra 

<math display="inline" id="Quantum_channel:16">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 is called positive if <em>a</em> = <em>x*x</em> for some <em>x</em>. Positivity of a map is defined accordingly. This characterization is not universally accepted; the <a href="quantum_instrument" title="wikilink">quantum instrument</a> is sometimes given as the generalized mathematical framework for conveying both quantum and classical information. In axiomatizations of quantum mechanics, the classical information is carried in a <a href="Frobenius_algebra" title="wikilink">Frobenius algebra</a> or <a href="Frobenius_category" title="wikilink">Frobenius category</a>.</p>
<h2 id="examples">Examples</h2>
<h3 id="states">States</h3>

<p>A state, viewed as a mapping from observables to their expectation values, is an immediate example of a channel.</p>
<h3 id="time-evolution">Time evolution</h3>

<p>For a purely quantum system, the time evolution, at certain time <em>t</em>, is given by</p>

<p>

<math display="block" id="Quantum_channel:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mo>→</mo>
    <mrow>
     <mi>U</mi>
     <mpadded width="+2.8pt">
      <mi>ρ</mi>
     </mpadded>
     <msup>
      <mi>U</mi>
      <mo>*</mo>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ρ</ci>
    <apply>
     <times></times>
     <ci>U</ci>
     <ci>ρ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>U</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho\rightarrow U\rho\;U^{*},
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Quantum_channel:18">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mi>i</mi>
       <mi>H</mi>
       <mi>t</mi>
      </mrow>
      <mo>/</mo>
      <mi mathvariant="normal">ℏ</mi>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>U</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>H</ci>
        <ci>t</ci>
       </apply>
       <csymbol cd="latexml">Planck-constant-over-2-pi</csymbol>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U=e^{-iHt/\hbar}
  </annotation>
 </semantics>
</math>

 and <em>H</em> is the <a href="Hamiltonian_(quantum_mechanics)" title="wikilink">Hamiltonian</a> and <em>t</em> is the time. Clearly this gives a CPTP map in the Schrödinger picture and is therefore a channel. The dual map in the Heisenberg picture is</p>

<p>

<math display="block" id="Quantum_channel:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>→</mo>
    <mrow>
     <msup>
      <mi>U</mi>
      <mo>*</mo>
     </msup>
     <mi>A</mi>
     <mi>U</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>A</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>U</ci>
      <times></times>
     </apply>
     <ci>A</ci>
     <ci>U</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\rightarrow U^{*}AU.
  </annotation>
 </semantics>
</math>

</p>
<h3 id="restriction">Restriction</h3>

<p>Consider a composite quantum system with state space 

<math display="inline" id="Quantum_channel:20">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>A</mi>
    </msub>
    <mo>⊗</mo>
    <msub>
     <mi>H</mi>
     <mi>B</mi>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{A}\otimes H_{B}.
  </annotation>
 </semantics>
</math>

 For a state</p>

<p>

<math display="block" id="Quantum_channel:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mo>∈</mo>
    <mrow>
     <msub>
      <mi>H</mi>
      <mi>A</mi>
     </msub>
     <mo>⊗</mo>
     <msub>
      <mi>H</mi>
      <mi>B</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ρ</ci>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho\in H_{A}\otimes H_{B},
  </annotation>
 </semantics>
</math>

</p>

<p>the reduced state of <em>ρ</em> on system <em>A</em>, <em>ρ</em><sup><em>A</em></sup>, is obtained by taking the <a href="partial_trace" title="wikilink">partial trace</a> of <em>ρ</em> with respect to the <em>B</em> system:</p>

<p>

<math display="block" id="Quantum_channel:22">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>ρ</mi>
     <mi>A</mi>
    </msup>
    <mo>=</mo>
    <mrow>
     <mpadded width="+2.8pt">
      <msub>
       <mo>Tr</mo>
       <mi>B</mi>
      </msub>
     </mpadded>
     <mi>ρ</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ρ</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Tr</ci>
      <ci>B</ci>
     </apply>
     <ci>ρ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho^{A}=\operatorname{Tr}_{B}\;\rho.
  </annotation>
 </semantics>
</math>

</p>

<p>The partial trace operation is a CPTP map, therefore a quantum channel in the Schrödinger picture. In the Heisenberg picture, the dual map of this channel is</p>

<p>

<math display="block" id="Quantum_channel:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>→</mo>
    <mrow>
     <mi>A</mi>
     <mo>⊗</mo>
     <msub>
      <mi>I</mi>
      <mi>B</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>A</ci>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\rightarrow A\otimes I_{B},
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>A</em> is an observable of system <em>A</em>.</p>
<h3 id="observable">Observable</h3>

<p>An observable associates a numerical value 

<math display="inline" id="Quantum_channel:24">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mi>ℂ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>i</ci>
    </apply>
    <ci>ℂ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}\in\mathbb{C}
  </annotation>
 </semantics>
</math>

 to a quantum mechanical <em>effect</em> 

<math display="inline" id="Quantum_channel:25">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{i}
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Quantum_channel:26">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{i}
  </annotation>
 </semantics>
</math>

's are assumed to be positive operators acting on appropriate state space and 

<math display="inline" id="Quantum_channel:27">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" symmetric="true">∑</mo>
    <msub>
     <mi>F</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <sum></sum>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum F_{i}=I
  </annotation>
 </semantics>
</math>

. (Such a collection is called a <a class="uri" href="POVM" title="wikilink">POVM</a>.) In the Heisenberg picture, the corresponding <em>observable map</em> Ψ maps a classical observable</p>

<p>

<math display="block" id="Quantum_channel:28">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>f</mi>
        <mn>1</mn>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>f</mi>
        <mi>n</mi>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>f</ci>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <ci>normal-⋮</ci>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>n</ci>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=\begin{bmatrix}f_{1}\\
\vdots\\
f_{n}\end{bmatrix}\in C(X)
  </annotation>
 </semantics>
</math>

</p>

<p>to the quantum mechanical one</p>

<p>

<math display="block" id="Quantum_channel:29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded lspace="2.8pt" width="+2.8pt">
      <mi mathvariant="normal">Ψ</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <mrow>
      <msub>
       <mi>f</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>F</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Ψ</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;\Psi(f)=\sum_{i}f_{i}F_{i}.
  </annotation>
 </semantics>
</math>

</p>

<p>In other words, one <a href="Naimark's_dilation_theorem" title="wikilink">integrate <em>f</em> against the POVM</a> to obtain the quantum mechanical observable. It can be easily checked that Ψ is CP and unital.</p>

<p>The corresponding Schrödinger map Ψ<sup>*</sup> takes density matrices to classical states:</p>

<p>

<math display="block" id="Quantum_channel:30">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Ψ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ρ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo stretchy="false">⟨</mo>
        <msub>
         <mi>F</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mi>ρ</mi>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo stretchy="false">⟨</mo>
        <msub>
         <mi>F</mi>
         <mi>n</mi>
        </msub>
        <mo>,</mo>
        <mi>ρ</mi>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Ψ</ci>
     <ci>ρ</ci>
    </apply>
    <matrix>
     <matrixrow>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>ρ</ci>
      </list>
     </matrixrow>
     <matrixrow>
      <ci>normal-⋮</ci>
     </matrixrow>
     <matrixrow>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <ci>n</ci>
       </apply>
       <ci>ρ</ci>
      </list>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi(\rho)=\begin{bmatrix}\langle F_{1},\rho\rangle\\
\vdots\\
\langle F_{n},\rho\rangle\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>,where the inner product is the Hilbert–Schmidt inner product. Furthermore, viewing states as normalized <a href="density_matrix#C*-algebraic_formulation_of_states" title="wikilink">functionals</a>, and invoking the <a href="Riesz_representation_theorem" title="wikilink">Riesz representation theorem</a>, we can put</p>

<p>

<math display="block" id="Quantum_channel:31">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Ψ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ρ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mi>ρ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>F</mi>
           <mn>1</mn>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋮</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mi>ρ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>F</mi>
           <mi>n</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Ψ</ci>
     <ci>ρ</ci>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <times></times>
       <ci>ρ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <ci>normal-⋮</ci>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>ρ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi(\rho)=\begin{bmatrix}\rho(F_{1})\\
\vdots\\
\rho(F_{n})\end{bmatrix}.
  </annotation>
 </semantics>
</math>

</p>
<h3 id="instrument">Instrument</h3>

<p>The observable map, in the Schrödinger picture, has a purely classical output algebra and therefore only describe measurement statistics. To take the state change into account as well, we define what is called an <a href="quantum_instrument" title="wikilink">quantum instrument</a>. Let 

<math display="inline" id="Quantum_channel:32">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>F</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>,</mo>
   <msub>
    <mi>F</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{F_{1},\cdots,F_{n}\}
  </annotation>
 </semantics>
</math>

 be the effects (POVM) associated to an observable. In the Schrödinger picture, an instrument is a map Φ with pure quantum input 

<math display="inline" id="Quantum_channel:33">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mo>∈</mo>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>H</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ρ</ci>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho\in L(H)
  </annotation>
 </semantics>
</math>

 and with output space 

<math display="inline" id="Quantum_channel:34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊗</mo>
    <mi>L</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>X</ci>
     </apply>
     <ci>L</ci>
    </apply>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(X)\otimes L(H)
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Quantum_channel:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ρ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mrow>
          <mi>ρ</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>F</mi>
            <mn>1</mn>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>⋅</mo>
         <msub>
          <mi>F</mi>
          <mn>1</mn>
         </msub>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋮</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mrow>
          <mi>ρ</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>F</mi>
            <mi>n</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>⋅</mo>
         <msub>
          <mi>F</mi>
          <mi>n</mi>
         </msub>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <ci>ρ</ci>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <ci>ρ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>F</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <ci>normal-⋮</ci>
     </matrixrow>
     <matrixrow>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <ci>ρ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>F</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(\rho)=\begin{bmatrix}\rho(F_{1})\cdot F_{1}\\
\vdots\\
\rho(F_{n})\cdot F_{n}\end{bmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>Let</p>

<p>

<math display="block" id="Quantum_channel:36">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>f</mi>
         <mn>1</mn>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋮</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>f</mi>
         <mi>n</mi>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>f</ci>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <ci>normal-⋮</ci>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>n</ci>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=\begin{bmatrix}f_{1}\\
\vdots\\
f_{n}\end{bmatrix}\in C(X).
  </annotation>
 </semantics>
</math>

</p>

<p>The dual map in the Heisenberg picture is</p>

<p>

<math display="block" id="Quantum_channel:37">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Ψ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mo>⊗</mo>
      <mi>A</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msub>
         <mi>f</mi>
         <mn>1</mn>
        </msub>
        <msub>
         <mi mathvariant="normal">Ψ</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>A</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">⋮</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msub>
         <mi>f</mi>
         <mi>n</mi>
        </msub>
        <msub>
         <mi mathvariant="normal">Ψ</mi>
         <mi>n</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>A</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Ψ</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>f</ci>
      <ci>A</ci>
     </apply>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Ψ</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>A</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <ci>normal-⋮</ci>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Ψ</ci>
        <ci>n</ci>
       </apply>
       <ci>A</ci>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi(f\otimes A)=\begin{bmatrix}f_{1}\Psi_{1}(A)\\
\vdots\\
f_{n}\Psi_{n}(A)\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Quantum_channel:38">
 <semantics>
  <msub>
   <mi mathvariant="normal">Ψ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Ψ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi_{i}
  </annotation>
 </semantics>
</math>

 is defined in the following way: Factor 

<math display="inline" id="Quantum_channel:39">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <msubsup>
    <mi>M</mi>
    <mi>i</mi>
    <mn>2</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>i</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{i}=M_{i}^{2}
  </annotation>
 </semantics>
</math>

 (this can always be done since elements of a POVM are positive) then 

<math display="inline" id="Quantum_channel:40">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mpadded lspace="2.8pt" width="+2.8pt">
      <mi mathvariant="normal">Ψ</mi>
     </mpadded>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>M</mi>
     <mi>i</mi>
    </msub>
    <mi>A</mi>
    <msub>
     <mi>M</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ψ</ci>
      <ci>i</ci>
     </apply>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>i</ci>
     </apply>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;\Psi_{i}(A)=M_{i}AM_{i}
  </annotation>
 </semantics>
</math>

. We see that Ψ is CP and unital.</p>

<p>Notice that 

<math display="inline" id="Quantum_channel:41">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ψ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>f</mi>
     <mo>⊗</mo>
     <mi>I</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ψ</ci>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>f</ci>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi(f\otimes I)
  </annotation>
 </semantics>
</math>

 gives precisely the observable map. The map</p>

<p>

<math display="block" id="Quantum_channel:42">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi mathvariant="normal">Ψ</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <msub>
      <mi mathvariant="normal">Ψ</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <msub>
      <mi>M</mi>
      <mi>i</mi>
     </msub>
     <mi>A</mi>
     <msub>
      <mi>M</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-~</ci>
       <ci>normal-Ψ</ci>
      </apply>
      <ci>A</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Ψ</ci>
        <ci>i</ci>
       </apply>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <ci>i</ci>
       </apply>
       <ci>A</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\tilde{\Psi}}(A)=\sum_{i}\Psi_{i}(A)=\sum_{i}M_{i}AM_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>describes the overall state change.</p>
<h3 id="separable-channel">Separable channel</h3>

<p>A separable channel is an example of <a href="LOCC" title="wikilink">local operation and classical communication (LOCC)</a>. Suppose two parties <em>A</em> and <em>B</em> wish to communicate in the following manner: <em>A</em> performs measurement on an observable and communicates the measurement outcome to <em>B</em> classically. According to the message he receives, <em>B</em> prepares his (quantum) system in a state that is previously agreed upon by both parties. In the Schrödinger picture, the first part of the channel Φ<sub>1</sub> simply consists of <em>A</em> making a measurement, i.e. it is the observable map:</p>

<p>

<math display="block" id="Quantum_channel:43">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mpadded lspace="2.8pt" width="+2.8pt">
       <mi mathvariant="normal">Φ</mi>
      </mpadded>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ρ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mi>ρ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>F</mi>
           <mn>1</mn>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋮</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mi>ρ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>F</mi>
           <mi>n</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Φ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>ρ</ci>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <times></times>
       <ci>ρ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <ci>normal-⋮</ci>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>ρ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;\Phi_{1}(\rho)=\begin{bmatrix}\rho(F_{1})\\
\vdots\\
\rho(F_{n})\end{bmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>If, in the event of the <em>i</em>-th measurement outcome, <em>B</em> prepares his system in state <em>R<sub>i</sub></em>, the second part of the channel Φ<sub>2</sub> takes the above classical state to the density matrix</p>

<p>

<math display="block" id="Quantum_channel:44">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi mathvariant="normal">Φ</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>[</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <mi>ρ</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>F</mi>
             <mn>1</mn>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mi mathvariant="normal">⋮</mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <mi>ρ</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>F</mi>
             <mi>n</mi>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mtd>
        </mtr>
       </mtable>
       <mo>]</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <mrow>
      <mi>ρ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>F</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>R</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Φ</ci>
      <cn type="integer">2</cn>
     </apply>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <ci>ρ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>F</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <ci>normal-⋮</ci>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>ρ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>F</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ρ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi_{2}(\begin{bmatrix}\rho(F_{1})\\
\vdots\\
\rho(F_{n})\end{bmatrix})=\sum_{i}\rho(F_{i})R_{i}.
  </annotation>
 </semantics>
</math>

</p>

<p>The total operation is the composition</p>

<p>

<math display="block" id="Quantum_channel:45">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ρ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi mathvariant="normal">Φ</mi>
       <mn>2</mn>
      </msub>
      <mo>∘</mo>
      <msub>
       <mi mathvariant="normal">Φ</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ρ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <mrow>
      <mi>ρ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>F</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>R</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>normal-Φ</ci>
      <ci>ρ</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <compose></compose>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Φ</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Φ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>ρ</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <ci>ρ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(\rho)=\Phi_{2}\circ\Phi_{1}(\rho)=\sum_{i}\rho(F_{i})R_{i}.
  </annotation>
 </semantics>
</math>

</p>

<p>Channels of this form are called <em>separable</em> or in <a href="Alexander_Holevo" title="wikilink">Holevo</a> form.</p>

<p>In the Heisenberg picture, the dual map 

<math display="inline" id="Quantum_channel:46">
 <semantics>
  <mrow>
   <msup>
    <mi mathvariant="normal">Φ</mi>
    <mo>*</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi mathvariant="normal">Φ</mi>
     <mn>1</mn>
     <mo>*</mo>
    </msubsup>
    <mo>∘</mo>
    <msubsup>
     <mi mathvariant="normal">Φ</mi>
     <mn>2</mn>
     <mo>*</mo>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Φ</ci>
     <times></times>
    </apply>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Φ</ci>
       <cn type="integer">1</cn>
      </apply>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Φ</ci>
       <cn type="integer">2</cn>
      </apply>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi^{*}=\Phi_{1}^{*}\circ\Phi_{2}^{*}
  </annotation>
 </semantics>
</math>

 is defined by</p>

<p>

<math display="block" id="Quantum_channel:47">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mpadded lspace="2.8pt" width="+2.8pt">
       <mi mathvariant="normal">Φ</mi>
      </mpadded>
      <mo>*</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <mrow>
      <msub>
       <mi>R</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>F</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Φ</ci>
      <times></times>
     </apply>
     <ci>A</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>i</ci>
      </apply>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;\Phi^{*}(A)=\sum_{i}R_{i}(A)F_{i}.
  </annotation>
 </semantics>
</math>

</p>

<p>A separable channel can not be the identity map. This is precisely the statement of the <a href="no_teleportation_theorem" title="wikilink">no teleportation theorem</a>, which says classical teleportation (not to be confused with <a href="quantum_teleportation" title="wikilink">entanglement-assisted teleportation</a>) is impossible. In other words, a quantum state can not be measured reliably.</p>

<p>In the <a href="channel-state_duality" title="wikilink">channel-state duality</a>, a channel is separable if and only if the corresponding state is <a href="separable_state" title="wikilink">separable</a>. Several other characterizations of separable channels are known, notably that a channel is separable if and only if it is entanglement-breaking.</p>
<h3 id="pure-channel">Pure channel</h3>

<p>Consider the case of a purely quantum channel Ψ in the Heisenberg picture. With the assumption that everything is finite-dimensional, Ψ is a unital CP map between spaces of matrices</p>

<p>

<math display="block" id="Quantum_channel:48">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Ψ</mi>
    <mo>:</mo>
    <mrow>
     <msup>
      <mi>ℂ</mi>
      <mrow>
       <mi>n</mi>
       <mo>×</mo>
       <mi>n</mi>
      </mrow>
     </msup>
     <mo>→</mo>
     <msup>
      <mi>ℂ</mi>
      <mrow>
       <mi>m</mi>
       <mo>×</mo>
       <mi>m</mi>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>normal-Ψ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℂ</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℂ</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi:\mathbb{C}^{n\times n}\rightarrow\mathbb{C}^{m\times m}.
  </annotation>
 </semantics>
</math>

</p>

<p>By <a href="Choi's_theorem_on_completely_positive_maps" title="wikilink">Choi's theorem on completely positive maps</a>, Ψ must take the form</p>

<p>

<math display="block" id="Quantum_channel:49">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Ψ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>K</mi>
      <mi>i</mi>
     </msub>
     <mi>A</mi>
     <msubsup>
      <mi>K</mi>
      <mi>i</mi>
      <mo>*</mo>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Ψ</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>i</ci>
      </apply>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>i</ci>
       </apply>
       <times></times>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi(A)=\sum_{i=1}^{N}K_{i}AK_{i}^{*}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>N</em> ≤ <em>nm</em>. The matrices <em>K</em><sub><em>i</em></sub> are called <strong><a href="Kraus_operator" title="wikilink">Kraus operators</a></strong> of Ψ (after the German physicist <a href="Karl_Kraus_(physicist)" title="wikilink">Karl Kraus</a>, who introduced them). The minimum number of Kraus operators is call the Kraus rank of Ψ. A channel with Kraus rank 1 is called <strong>pure</strong>. The time evolution is one example of a pure channel. This terminology again comes from the channel-state duality. A channel is pure if and only if its dual state is a pure state. Since this duality preserves the extremal points, the extremal points in the convex set of channels are precisely the pure channels.</p>
<h3 id="teleportation">Teleportation</h3>

<p>In <a href="quantum_teleportation" title="wikilink">quantum teleportation</a>, a sender wishes to transmit an arbitrary quantum state of a particle to a possibly distant receiver. Consequently, the teleportation process is a quantum channel. The apparatus for the process itself requires a quantum channel for the transmission of one particle of an entangled-state to the receiver. Teleportation occurs by a joint measurement of the send particle and the remaining entangled particle. This measurement results in classical information which must be sent to the receiver to complete the teleportation. Importantly, the classical information can be sent after the quantum channel has ceased to exist.</p>
<h2 id="in-the-experimental-setting">In the experimental setting</h2>

<p>Experimentally, a simple implementation of a quantum channel is <a href="fiber_optic" title="wikilink">fiber optic</a> (or free-space for that matter) transmission of single <a href="photon" title="wikilink">photons</a>. Single photons can be transmitted up to 100 km in standard fiber optics before losses dominate. The photon's time-of-arrival (<em>time-bin entanglement</em>) or <a href="Polarization_(waves)" title="wikilink">polarization</a> are used as a basis to encode quantum information for purposes such as <a href="quantum_cryptography" title="wikilink">quantum cryptography</a>. The channel is capable of transmitting not only basis states (e.g. |0&gt;, |1&gt;) but also superpositions of them (e.g. |0&gt;+|1&gt;). The <a href="quantum_coherence" title="wikilink">coherence</a> of the state is maintained during transmission through the channel. Contrast this with the transmission of electrical pulses through wires (a classical channel), where only classical information (e.g. 0s and 1s) can be sent.</p>
<h2 id="channel-capacity">Channel capacity</h2>
<h3 id="the-cb-norm-of-a-channel">The cb-norm of a channel</h3>

<p>Before giving the definition of channel capacity, the preliminary notion of the <strong>norm of complete boundedness</strong>, or <strong>cb-norm</strong> of a channel needs to be discussed. When considering the capacity of a channel Φ, we need to compare it with an "ideal channel" Λ. For instance, when the input and output algebras are identical, we can choose Λ to be the identity map. Such a comparison requires a <a href="metric_(mathematics)" title="wikilink">metric</a> between channels. Since a channel can be viewed as a linear operator, it is tempting to use the natural <a href="operator_norm" title="wikilink">operator norm</a>. In other words, the closeness of Φ to the ideal channel Λ can be defined by</p>

<p>

<math display="block" id="Quantum_channel:50">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi mathvariant="normal">Φ</mi>
      <mo>-</mo>
      <mi mathvariant="normal">Λ</mi>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo movablelimits="false">sup</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mo>∥</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi mathvariant="normal">Φ</mi>
          <mo>-</mo>
          <mi mathvariant="normal">Λ</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>A</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo rspace="5.3pt">∥</mo>
      </mrow>
      <mo rspace="5.3pt" stretchy="false">|</mo>
      <mrow>
       <mrow>
        <mo>∥</mo>
        <mi>A</mi>
        <mo>∥</mo>
       </mrow>
       <mo>≤</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <minus></minus>
      <ci>normal-Φ</ci>
      <ci>normal-Λ</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">supremum</csymbol>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <ci>normal-Φ</ci>
         <ci>normal-Λ</ci>
        </apply>
        <ci>A</ci>
       </apply>
      </apply>
      <apply>
       <leq></leq>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>A</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\Phi-\Lambda\|=\sup\{\|(\Phi-\Lambda)(A)\|\;|\;\|A\|\leq 1\}.
  </annotation>
 </semantics>
</math>

</p>

<p>However, the operator norm may increase when we tensor Φ with the identity map on some ancilla.</p>

<p>To make the operator norm even a more undesirable candidate, the quantity</p>

<p>

<math display="block" id="Quantum_channel:51">
 <semantics>
  <mrow>
   <mo>∥</mo>
   <mrow>
    <mi mathvariant="normal">Φ</mi>
    <mo>⊗</mo>
    <msub>
     <mi>I</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>∥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">norm</csymbol>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>normal-Φ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\Phi\otimes I_{n}\|
  </annotation>
 </semantics>
</math>

</p>

<p>may increase without bound as 

<math display="inline" id="Quantum_channel:52">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mo>→</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>n</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\rightarrow\infty.
  </annotation>
 </semantics>
</math>

 The solution is to introduce, for any linear map Φ between C*-algebras, the cb-norm</p>

<p>

<math display="block" id="Quantum_channel:53">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo>∥</mo>
      <mi mathvariant="normal">Φ</mi>
      <mo>∥</mo>
     </mrow>
     <mrow>
      <mi>c</mi>
      <mi>b</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo movablelimits="false">sup</mo>
      <mi>n</mi>
     </munder>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mi mathvariant="normal">Φ</mi>
       <mo>⊗</mo>
       <msub>
        <mi>I</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mo>∥</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>normal-Φ</ci>
     </apply>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">supremum</csymbol>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>normal-Φ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\Phi\|_{cb}=\sup_{n}\|\Phi\otimes I_{n}\|.
  </annotation>
 </semantics>
</math>

</p>
<h3 id="definition-of-channel-capacity">Definition of channel capacity</h3>

<p>The mathematical model of a channel used here is same as the <a href="channel_capacity" title="wikilink">classical one</a>.</p>

<p>Let 

<math display="inline" id="Quantum_channel:54">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ψ</mi>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi class="ltx_font_mathcaligraphic">ℬ</mi>
     <mn>1</mn>
    </msub>
    <mo>→</mo>
    <msub>
     <mi class="ltx_font_mathcaligraphic">𝒜</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>normal-Ψ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℬ</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒜</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi:\mathcal{B}_{1}\rightarrow\mathcal{A}_{1}
  </annotation>
 </semantics>
</math>

 be a channel in the Heisenberg picture and 

<math display="inline" id="Quantum_channel:55">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Ψ</mi>
    <mrow>
     <mi>i</mi>
     <mi>d</mi>
    </mrow>
   </msub>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi class="ltx_font_mathcaligraphic">ℬ</mi>
     <mn>2</mn>
    </msub>
    <mo>→</mo>
    <msub>
     <mi class="ltx_font_mathcaligraphic">𝒜</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Ψ</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>d</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℬ</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒜</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi_{id}:\mathcal{B}_{2}\rightarrow\mathcal{A}_{2}
  </annotation>
 </semantics>
</math>

 be a chosen ideal channel. To make the comparison possible, one needs to encode and decode Φ via appropriate devices, i.e. we consider the composition</p>

<p>

<math display="block" id="Quantum_channel:56">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi mathvariant="normal">Ψ</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>=</mo>
    <mrow>
     <mi>D</mi>
     <mo>∘</mo>
     <mi mathvariant="normal">Φ</mi>
     <mo>∘</mo>
     <mi>E</mi>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi class="ltx_font_mathcaligraphic">ℬ</mi>
     <mn>2</mn>
    </msub>
    <mo>→</mo>
    <msub>
     <mi class="ltx_font_mathcaligraphic">𝒜</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-^</ci>
      <ci>normal-Ψ</ci>
     </apply>
     <apply>
      <compose></compose>
      <ci>D</ci>
      <ci>normal-Φ</ci>
      <ci>E</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℬ</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝒜</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\hat{\Psi}}=D\circ\Phi\circ E:\mathcal{B}_{2}\rightarrow\mathcal{A}_{2}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>E</em> is an <a class="uri" href="encoder" title="wikilink">encoder</a> and <em>D</em> is a decoder. In this context, <em>E</em> and <em>D</em> are unital CP maps with appropriate domains. The quantity of interest is the <em>best case scenario</em>:</p>

<p>

<math display="block" id="Quantum_channel:57">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi mathvariant="normal">Ψ</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mo>,</mo>
     <msub>
      <mi mathvariant="normal">Ψ</mi>
      <mrow>
       <mi>i</mi>
       <mi>d</mi>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo movablelimits="false">inf</mo>
     <mrow>
      <mi>E</mi>
      <mo>,</mo>
      <mi>D</mi>
     </mrow>
    </munder>
    <msub>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mover accent="true">
        <mi mathvariant="normal">Ψ</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mo>-</mo>
       <msub>
        <mi mathvariant="normal">Ψ</mi>
        <mrow>
         <mi>i</mi>
         <mi>d</mi>
        </mrow>
       </msub>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mrow>
      <mi>c</mi>
      <mi>b</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <interval closure="open">
      <apply>
       <ci>normal-^</ci>
       <ci>normal-Ψ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Ψ</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>d</ci>
       </apply>
      </apply>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">infimum</csymbol>
      <list>
       <ci>E</ci>
       <ci>D</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <ci>normal-^</ci>
         <ci>normal-Ψ</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-Ψ</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>d</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta({\hat{\Psi}},\Psi_{id})=\inf_{E,D}\|{\hat{\Psi}}-\Psi_{id}\|_{cb}
  </annotation>
 </semantics>
</math>

</p>

<p>with the infimum being taken over all possible encoders and decoders.</p>

<p>To transmit words of length <em>n</em>, the ideal channel is to be applied <em>n</em> times, so we consider the tensor power</p>

<p>

<math display="block" id="Quantum_channel:58">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi mathvariant="normal">Ψ</mi>
     <mrow>
      <mi>i</mi>
      <mi>d</mi>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>⊗</mo>
      <mi>n</mi>
     </mrow>
    </msubsup>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi mathvariant="normal">Ψ</mi>
      <mrow>
       <mi>i</mi>
       <mi>d</mi>
      </mrow>
     </msub>
     <mo>⊗</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>⊗</mo>
     <msub>
      <mi mathvariant="normal">Ψ</mi>
      <mrow>
       <mi>i</mi>
       <mi>d</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ψ</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>d</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ψ</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>d</ci>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ψ</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>d</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi_{id}^{\otimes n}=\Psi_{id}\otimes\cdots\otimes\Psi_{id}.
  </annotation>
 </semantics>
</math>

</p>

<p>The 

<math display="inline" id="Quantum_channel:59">
 <semantics>
  <mo>⊗</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">tensor-product</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \otimes
  </annotation>
 </semantics>
</math>

 operation describes <em>n</em> inputs undergoing the operation 

<math display="inline" id="Quantum_channel:60">
 <semantics>
  <msub>
   <mi mathvariant="normal">Ψ</mi>
   <mrow>
    <mi>i</mi>
    <mi>d</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Ψ</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi_{id}
  </annotation>
 </semantics>
</math>

 independently and is the quantum mechanical counterpart of <a class="uri" href="concatenation" title="wikilink">concatenation</a>. Similarly, <em>m invocations of the channel</em> corresponds to 

<math display="inline" id="Quantum_channel:61">
 <semantics>
  <msup>
   <mover accent="true">
    <mi mathvariant="normal">Ψ</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mi></mi>
    <mo>⊗</mo>
    <mi>m</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>normal-Ψ</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\hat{\Psi}}^{\otimes m}
  </annotation>
 </semantics>
</math>

.</p>

<p>The quantity</p>

<p>

<math display="block" id="Quantum_channel:62">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mover accent="true">
      <mi mathvariant="normal">Ψ</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mi></mi>
      <mo>⊗</mo>
      <mi>m</mi>
     </mrow>
    </msup>
    <mo>,</mo>
    <msubsup>
     <mi mathvariant="normal">Ψ</mi>
     <mrow>
      <mi>i</mi>
      <mi>d</mi>
     </mrow>
     <mrow>
      <mi></mi>
      <mo>⊗</mo>
      <mi>n</mi>
     </mrow>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>normal-Ψ</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <ci>m</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Ψ</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>d</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <ci>n</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta({\hat{\Psi}}^{\otimes m},\Psi_{id}^{\otimes n})
  </annotation>
 </semantics>
</math>

</p>

<p>is therefore a measure of the ability of the channel to transmit words of length <em>n</em> faithfully by being invoked <em>m</em> times.</p>

<p>This leads to the following definition:</p>
<dl>
<dd>An a non-negative real number <em>r</em> is an <strong>achievable rate of 

<math display="inline" id="Quantum_channel:63">
 <semantics>
  <mi mathvariant="normal">Ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi
  </annotation>
 </semantics>
</math>

 with respect to 

<math display="inline" id="Quantum_channel:64">
 <semantics>
  <msub>
   <mi mathvariant="normal">Ψ</mi>
   <mrow>
    <mi>i</mi>
    <mi>d</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Ψ</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi_{id}
  </annotation>
 </semantics>
</math>

</strong> if
</dd>
</dl>
<dl>
<dd>For all sequences 

<math display="inline" id="Quantum_channel:65">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">{</mo>
     <msub>
      <mi>n</mi>
      <mi>α</mi>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <msub>
      <mi>m</mi>
      <mi>α</mi>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>⊂</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <list>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>α</ci>
      </apply>
     </set>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>α</ci>
      </apply>
     </set>
    </list>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{n_{\alpha}\},\{m_{\alpha}\}\subset\mathbb{N}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Quantum_channel:66">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mi>α</mi>
   </msub>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>α</ci>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{\alpha}\rightarrow\infty
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_channel:67">
 <semantics>
  <mrow>
   <mrow>
    <mo>lim</mo>
    <mrow>
     <msub>
      <mo>sup</mo>
      <mi>α</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>n</mi>
        <mi>α</mi>
       </msub>
       <mo>/</mo>
       <msub>
        <mi>m</mi>
        <mi>α</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo><</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <limit></limit>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">supremum</csymbol>
       <ci>α</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>α</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <ci>α</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim\sup_{\alpha}(n_{\alpha}/m_{\alpha})<r
  </annotation>
 </semantics>
</math>

, we have
</dd>
</dl>

<p>

<math display="block" id="Quantum_channel:68">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo movablelimits="false">lim</mo>
     <mi>α</mi>
    </munder>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mover accent="true">
        <mi mathvariant="normal">Ψ</mi>
        <mo stretchy="false">^</mo>
       </mover>
       <mrow>
        <mi></mi>
        <mo>⊗</mo>
        <msub>
         <mi>m</mi>
         <mi>α</mi>
        </msub>
       </mrow>
      </msup>
      <mo>,</mo>
      <msubsup>
       <mi mathvariant="normal">Ψ</mi>
       <mrow>
        <mi>i</mi>
        <mi>d</mi>
       </mrow>
       <mrow>
        <mi></mi>
        <mo>⊗</mo>
        <msub>
         <mi>n</mi>
         <mi>α</mi>
        </msub>
       </mrow>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <ci>α</ci>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <ci>normal-^</ci>
         <ci>normal-Ψ</ci>
        </apply>
        <apply>
         <csymbol cd="latexml">tensor-product</csymbol>
         <csymbol cd="latexml">absent</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <ci>α</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-Ψ</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>d</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="latexml">tensor-product</csymbol>
         <csymbol cd="latexml">absent</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>α</ci>
         </apply>
        </apply>
       </apply>
      </interval>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim_{\alpha}\Delta({\hat{\Psi}}^{\otimes m_{\alpha}},\Psi_{id}^{\otimes n_{%
\alpha}})=0.
  </annotation>
 </semantics>
</math>

</p>

<p>A sequence 

<math display="inline" id="Quantum_channel:69">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>n</mi>
    <mi>α</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>α</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{n_{\alpha}\}
  </annotation>
 </semantics>
</math>

 can be viewed as representing a message consisting of possibly infinite number of words. The limit supremum condition in the definition says that, in the limit, faithful transmission can be achieved by invoking the channel no more than <em>r</em> times the length of a word. One can also say that <em>r</em> is the number of letters per invokation of the channel that can be sent without error.</p>

<p>The <strong>channel capacity of 

<math display="inline" id="Quantum_channel:70">
 <semantics>
  <mi mathvariant="normal">Ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi
  </annotation>
 </semantics>
</math>

 with respect to 

<math display="inline" id="Quantum_channel:71">
 <semantics>
  <msub>
   <mi mathvariant="normal">Ψ</mi>
   <mrow>
    <mi>i</mi>
    <mi>d</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Ψ</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi_{id}
  </annotation>
 </semantics>
</math>

</strong>, denoted by 

<math display="inline" id="Quantum_channel:72">
 <semantics>
  <mrow>
   <mpadded lspace="2.8pt" width="+2.8pt">
    <mi>C</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Ψ</mi>
    <mo>,</mo>
    <msub>
     <mi mathvariant="normal">Ψ</mi>
     <mrow>
      <mi>i</mi>
      <mi>d</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <interval closure="open">
     <ci>normal-Ψ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ψ</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>d</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;C(\Psi,\Psi_{id})
  </annotation>
 </semantics>
</math>

 is the supremum of all achievable rates.</p>

<p>From the definition, it is vacuously true that 0 is an achievable rate for any channel.</p>
<h3 id="important-examples">Important examples</h3>

<p>As stated before, for a system with observable algebra 

<math display="inline" id="Quantum_channel:73">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℬ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}
  </annotation>
 </semantics>
</math>

, the ideal channel 

<math display="inline" id="Quantum_channel:74">
 <semantics>
  <msub>
   <mi mathvariant="normal">Ψ</mi>
   <mrow>
    <mi>i</mi>
    <mi>d</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Ψ</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi_{id}
  </annotation>
 </semantics>
</math>

 is by definition the identity map 

<math display="inline" id="Quantum_channel:75">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi class="ltx_font_mathcaligraphic">ℬ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>ℬ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{\mathcal{B}}
  </annotation>
 </semantics>
</math>

. Thus for a purely <em>n</em> dimensional quantum system, the ideal channel is the identity map on the space of <em>n</em> × <em>n</em> matrices 

<math display="inline" id="Quantum_channel:76">
 <semantics>
  <msup>
   <mi>ℂ</mi>
   <mrow>
    <mi>n</mi>
    <mo>×</mo>
    <mi>n</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℂ</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}^{n\times n}
  </annotation>
 </semantics>
</math>

. As a slight abuse of notation, this ideal quantum channel will be also denoted by 

<math display="inline" id="Quantum_channel:77">
 <semantics>
  <msup>
   <mi>ℂ</mi>
   <mrow>
    <mi>n</mi>
    <mo>×</mo>
    <mi>n</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℂ</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}^{n\times n}
  </annotation>
 </semantics>
</math>

. Similarly for a classical system with output algebra 

<math display="inline" id="Quantum_channel:78">
 <semantics>
  <msup>
   <mi>ℂ</mi>
   <mi>m</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℂ</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}^{m}
  </annotation>
 </semantics>
</math>

 will have an ideal channel denoted by the same symbol. We can now state some fundamental channel capacities.</p>

<p>The channel capacity of the classical ideal channel 

<math display="inline" id="Quantum_channel:79">
 <semantics>
  <msup>
   <mi>ℂ</mi>
   <mi>m</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℂ</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}^{m}
  </annotation>
 </semantics>
</math>

 with respect to a quantum ideal channel 

<math display="inline" id="Quantum_channel:80">
 <semantics>
  <msup>
   <mi>ℂ</mi>
   <mrow>
    <mi>n</mi>
    <mo>×</mo>
    <mi>n</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℂ</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}^{n\times n}
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="block" id="Quantum_channel:81">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>ℂ</mi>
      <mi>m</mi>
     </msup>
     <mo>,</mo>
     <msup>
      <mi>ℂ</mi>
      <mrow>
       <mi>n</mi>
       <mo>×</mo>
       <mi>n</mi>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℂ</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℂ</ci>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </interval>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(\mathbb{C}^{m},\mathbb{C}^{n\times n})=0.
  </annotation>
 </semantics>
</math>

</p>

<p>This is equivalent to the no-teleportation theorem: it is impossible to transmit quantum information via a classical channel.</p>

<p>Moreover, the following equalities hold:</p>

<p>

<math display="block" id="Quantum_channel:82">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>ℂ</mi>
     <mi>m</mi>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>ℂ</mi>
     <mi>n</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>ℂ</mi>
     <mrow>
      <mi>m</mi>
      <mo>×</mo>
      <mi>m</mi>
     </mrow>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>ℂ</mi>
     <mrow>
      <mi>n</mi>
      <mo>×</mo>
      <mi>n</mi>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo>=</mo>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>ℂ</mi>
     <mrow>
      <mi>m</mi>
      <mo>×</mo>
      <mi>m</mi>
     </mrow>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>ℂ</mi>
     <mi>n</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mrow>
     <mi>log</mi>
     <mi>m</mi>
    </mrow>
   </mfrac>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℂ</ci>
      <ci>m</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℂ</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℂ</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>m</ci>
      </apply>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℂ</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <eq></eq>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℂ</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>m</ci>
      </apply>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℂ</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
     <apply>
      <log></log>
      <ci>m</ci>
     </apply>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(\mathbb{C}^{m},\mathbb{C}^{n})=C(\mathbb{C}^{m\times m},\mathbb{C}^{n\times n%
})==C(\mathbb{C}^{m\times m},\mathbb{C}^{n})==\frac{\log n}{\log m}.
  </annotation>
 </semantics>
</math>

</p>

<p>The above says, for instance, an ideal quantum channel is no more efficient at transmitting classical information than an ideal classical channel. When <em>n</em> = <em>m</em>, the best one can achieve is <em>one bit per qubit</em>.</p>

<p>It is relevant to note here that both of the above bounds on capacities can be broken, with the aid of <a href="quantum_entanglement" title="wikilink">entanglement</a>. The <a href="quantum_teleportation" title="wikilink">entanglement-assisted teleportation scheme</a> allows one to transmit quantum information using a classical channel. <a href="Superdense_coding" title="wikilink">Superdense coding</a>. achieves <em>two bit per qubit</em>. These results indicate the significant role played by entanglement in quantum communication.</p>
<h3 id="classical-and-quantum-channel-capacities">Classical and quantum channel capacities</h3>

<p>Using the same notation as the previous subsection, the <strong>classical capacity</strong> of a channel Ψ is</p>

<p>

<math display="block" id="Quantum_channel:83">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">Ψ</mi>
     <mo>,</mo>
     <msup>
      <mi>ℂ</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <interval closure="open">
     <ci>normal-Ψ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℂ</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(\Psi,\mathbb{C}^{2}),
  </annotation>
 </semantics>
</math>

</p>

<p>that is, it is the capacity of Ψ with respect to the ideal channel on the classical one-bit system 

<math display="inline" id="Quantum_channel:84">
 <semantics>
  <msup>
   <mi>ℂ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℂ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}^{2}
  </annotation>
 </semantics>
</math>

.</p>

<p>Similarly the <strong>quantum capacity</strong> of Ψ is</p>

<p>

<math display="block" id="Quantum_channel:85">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">Ψ</mi>
     <mo>,</mo>
     <msup>
      <mi>ℂ</mi>
      <mrow>
       <mn>2</mn>
       <mo>×</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <interval closure="open">
     <ci>normal-Ψ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℂ</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(\Psi,\mathbb{C}^{2\times 2}),
  </annotation>
 </semantics>
</math>

</p>

<p>where the reference system is now the one qubit system 

<math display="inline" id="Quantum_channel:86">
 <semantics>
  <msup>
   <mi>ℂ</mi>
   <mrow>
    <mn>2</mn>
    <mo>×</mo>
    <mn>2</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℂ</ci>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}^{2\times 2}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="channel-fidelity">Channel fidelity</h2>

<p>Another measure of how well a quantum channel preserves information is called <strong>channel fidelity</strong>, and it arises from <a href="fidelity_of_quantum_states" title="wikilink">fidelity of quantum states</a>.</p>
<h2 id="quantum-channel-with-memory">Quantum channel with memory</h2>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="No-communication_theorem" title="wikilink">No-communication theorem</a></li>
<li><a href="Amplitude_damping_channel" title="wikilink">Amplitude damping channel</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>M. Keyl and R.F. Werner, <em>How to Correct Small Quantum Errors</em>, Lecture Notes in Physics Volume 611, Springer, 2002.</li>
<li>Mark M. Wilde, <a href="http://arxiv.org/abs/1106.1445">"From Classical to Quantum Shannon Theory", arXiv:1106.1445</a>.</li>
</ul>

<p>"</p>

<p><a href="Category:Quantum_information_theory" title="wikilink">Category:Quantum information theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">C. Weedbrook at al., <a href="http://journals.aps.org/rmp/abstract/10.1103/RevModPhys.84.621">"Gaussian quantum information"</a>, <em>Rev. Mod. Phys.</em> <strong>84</strong>, 621 (2012).<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
