<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1159">Abel–Jacobi map</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Abel–Jacobi map</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the <strong>Abel–Jacobi map</strong> is a construction of <a href="algebraic_geometry" title="wikilink">algebraic geometry</a> which relates an <a href="algebraic_curve" title="wikilink">algebraic curve</a> to its <a href="Jacobian_variety" title="wikilink">Jacobian variety</a>. In <a href="Riemannian_geometry" title="wikilink">Riemannian geometry</a>, it is a more general construction mapping a <a class="uri" href="manifold" title="wikilink">manifold</a> to its Jacobi torus. The name derives from the <a href="#Abel–Jacobi_theorem" title="wikilink">theorem</a> of <a href="Niels_Henrik_Abel" title="wikilink">Abel</a> and <a href="Carl_Gustav_Jacob_Jacobi" title="wikilink">Jacobi</a> that two <a href="effective_divisor" title="wikilink">effective divisors</a> are <a href="linearly_equivalent" title="wikilink">linearly equivalent</a> if and only if they are indistinguishable under the Abel–Jacobi map.</p>
<h2 id="construction-of-the-map">Construction of the map</h2>

<p>In <a href="complex_algebraic_geometry" title="wikilink">complex algebraic geometry</a>, the Jacobian of a curve <em>C</em> is constructed using path integration. Namely, suppose <em>C</em> has <a href="genus_of_a_curve" title="wikilink">genus</a> <em>g</em>, which means topologically that</p>

<p>

<math display="block" id="Abel–Jacobi_map:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>H</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>C</mi>
      <mo>,</mo>
      <mi>ℤ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≅</mo>
    <msup>
     <mi>ℤ</mi>
     <mrow>
      <mn>2</mn>
      <mi>g</mi>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">1</cn>
     </apply>
     <interval closure="open">
      <ci>C</ci>
      <ci>ℤ</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℤ</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>g</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}(C,\mathbb{Z})\cong\mathbb{Z}^{2g}.
  </annotation>
 </semantics>
</math>

 Geometrically, this homology group consists of (homology classes of) <em>cycles</em> in <em>C</em>, or in other words, closed loops. Therefore we can choose 2<em>g</em> loops 

<math display="inline" id="Abel–Jacobi_map:1">
 <semantics>
  <mrow>
   <msub>
    <mi>γ</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>γ</mi>
    <mrow>
     <mn>2</mn>
     <mi>g</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>g</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma_{1},\dots,\gamma_{2g}
  </annotation>
 </semantics>
</math>

 generating it. On the other hand, another, more algebro-geometric way of saying that the genus of <em>C</em> is <em>g</em>, is that</p>

<p>

<math display="block" id="Abel–Jacobi_map:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>H</mi>
      <mn>0</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>C</mi>
      <mo>,</mo>
      <mi>K</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≅</mo>
    <msup>
     <mi>ℂ</mi>
     <mi>g</mi>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>H</ci>
      <cn type="integer">0</cn>
     </apply>
     <interval closure="open">
      <ci>C</ci>
      <ci>K</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℂ</ci>
     <ci>g</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{0}(C,K)\cong\mathbb{C}^{g},
  </annotation>
 </semantics>
</math>

 where <em>K</em> is the <a href="canonical_bundle" title="wikilink">canonical bundle</a> on <em>C</em>. By definition, this is the space of globally defined holomorphic <a href="differential_form" title="wikilink">differential forms</a> on <em>C</em>, so we can choose <em>g</em> linearly independent forms 

<math display="inline" id="Abel–Jacobi_map:3">
 <semantics>
  <mrow>
   <msub>
    <mi>ω</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>ω</mi>
    <mi>g</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <ci>g</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{1},\dots,\omega_{g}
  </annotation>
 </semantics>
</math>

. Given forms and closed loops we can integrate, and we define 2<em>g</em> vectors</p>

<p>

<math display="block" id="Abel–Jacobi_map:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Ω</mi>
     <mi>j</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∫</mo>
       <msub>
        <mi>γ</mi>
        <mi>j</mi>
       </msub>
      </msub>
      <msub>
       <mi>ω</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∫</mo>
       <msub>
        <mi>γ</mi>
        <mi>j</mi>
       </msub>
      </msub>
      <msub>
       <mi>ω</mi>
       <mi>g</mi>
      </msub>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>∈</mo>
    <msup>
     <mi>ℂ</mi>
     <mi>g</mi>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Ω</ci>
      <ci>j</ci>
     </apply>
     <vector>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>γ</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>γ</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>g</ci>
       </apply>
      </apply>
     </vector>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℂ</ci>
      <ci>g</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{j}=\left(\int_{\gamma_{j}}\omega_{1},\dots,\int_{\gamma_{j}}\omega_{g}%
\right)\in\mathbb{C}^{g}.
  </annotation>
 </semantics>
</math>

 It follows from the <a href="Riemann_bilinear_relations" title="wikilink">Riemann bilinear relations</a> that the 

<math display="inline" id="Abel–Jacobi_map:5">
 <semantics>
  <msub>
   <mi mathvariant="normal">Ω</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Ω</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{j}
  </annotation>
 </semantics>
</math>

 generate a nondegenerate <a href="lattice_(group)" title="wikilink">lattice</a> 

<math display="inline" id="Abel–Jacobi_map:6">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda
  </annotation>
 </semantics>
</math>

 (that is, they are a real basis for 

<math display="inline" id="Abel–Jacobi_map:7">
 <semantics>
  <mrow>
   <msup>
    <mi>ℂ</mi>
    <mi>g</mi>
   </msup>
   <mo>≅</mo>
   <msup>
    <mi>ℝ</mi>
    <mrow>
     <mn>2</mn>
     <mi>g</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℂ</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>g</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}^{g}\cong\mathbb{R}^{2g}
  </annotation>
 </semantics>
</math>

), and the Jacobian is defined by</p>

<p>

<math display="block" id="Abel–Jacobi_map:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>J</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>C</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>ℂ</mi>
      <mi>g</mi>
     </msup>
     <mo>/</mo>
     <mi mathvariant="normal">Λ</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>J</ci>
     <ci>C</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℂ</ci>
      <ci>g</ci>
     </apply>
     <ci>normal-Λ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J(C)=\mathbb{C}^{g}/\Lambda.
  </annotation>
 </semantics>
</math>

</p>

<p>The <strong>Abel–Jacobi map</strong> is then defined as follows. We pick some base point 

<math display="inline" id="Abel–Jacobi_map:9">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>0</mn>
   </msub>
   <mo>∈</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{0}\in C
  </annotation>
 </semantics>
</math>

 and, nearly mimicking the definition of 

<math display="inline" id="Abel–Jacobi_map:10">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda
  </annotation>
 </semantics>
</math>

, define the map</p>

<p>

<math display="block" id="Abel–Jacobi_map:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mi>C</mi>
      <mo>→</mo>
      <mrow>
       <mi>J</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mi>u</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>p</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
       <mrow>
        <mo>(</mo>
        <mrow>
         <msubsup>
          <mo largeop="true" symmetric="true">∫</mo>
          <msub>
           <mi>p</mi>
           <mn>0</mn>
          </msub>
          <mi>p</mi>
         </msubsup>
         <msub>
          <mi>ω</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <mrow>
         <msubsup>
          <mo largeop="true" symmetric="true">∫</mo>
          <msub>
           <mi>p</mi>
           <mn>0</mn>
          </msub>
          <mi>p</mi>
         </msubsup>
         <msub>
          <mi>ω</mi>
          <mi>g</mi>
         </msub>
        </mrow>
        <mo>)</mo>
       </mrow>
       <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
       <mi mathvariant="normal">Λ</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>u</ci>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <ci>normal-→</ci>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>J</ci>
       <ci>C</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>u</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">modulo</csymbol>
       <vector>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <int></int>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>p</ci>
            <cn type="integer">0</cn>
           </apply>
          </apply>
          <ci>p</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <int></int>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>p</ci>
            <cn type="integer">0</cn>
           </apply>
          </apply>
          <ci>p</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ω</ci>
          <ci>g</ci>
         </apply>
        </apply>
       </vector>
       <ci>normal-Λ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\colon C\to J(C),u(p)=\left(\int_{p_{0}}^{p}\omega_{1},\dots,\int_{p_{0}}^{p}%
\omega_{g}\right)\bmod\Lambda.
  </annotation>
 </semantics>
</math>

 Although this is seemingly dependent on a path from 

<math display="inline" id="Abel–Jacobi_map:12">
 <semantics>
  <msub>
   <mi>p</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{0}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Abel–Jacobi_map:13">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p,
  </annotation>
 </semantics>
</math>

 any two such paths define a closed loop in 

<math display="inline" id="Abel–Jacobi_map:14">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 and, therefore, an element of 

<math display="inline" id="Abel–Jacobi_map:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo>,</mo>
     <mi>ℤ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">1</cn>
    </apply>
    <interval closure="open">
     <ci>C</ci>
     <ci>ℤ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}(C,\mathbb{Z}),
  </annotation>
 </semantics>
</math>

 so integration over it gives an element of 

<math display="inline" id="Abel–Jacobi_map:16">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Λ</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda.
  </annotation>
 </semantics>
</math>

 Thus the difference is erased in the passage to the quotient by 

<math display="inline" id="Abel–Jacobi_map:17">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda
  </annotation>
 </semantics>
</math>

. Changing base-point 

<math display="inline" id="Abel–Jacobi_map:18">
 <semantics>
  <msub>
   <mi>p</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{0}
  </annotation>
 </semantics>
</math>

 does change the map, but only by a translation of the torus.</p>
<h2 id="the-abeljacobi-map-of-a-riemannian-manifold">The Abel–Jacobi map of a Riemannian manifold</h2>

<p>Let 

<math display="inline" id="Abel–Jacobi_map:19">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 be a smooth compact <a class="uri" href="manifold" title="wikilink">manifold</a>. Let 

<math display="inline" id="Abel–Jacobi_map:20">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>π</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>π</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi=\pi_{1}(M)
  </annotation>
 </semantics>
</math>

 be its fundamental group. Let 

<math display="inline" id="Abel–Jacobi_map:21">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>π</mi>
    <mo>→</mo>
    <msup>
     <mi>π</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>π</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>π</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\pi\to\pi^{ab}
  </annotation>
 </semantics>
</math>

 be its <a class="uri" href="abelianisation" title="wikilink">abelianisation</a> map. Let 

<math display="inline" id="Abel–Jacobi_map:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mi>o</mi>
    <mi>r</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>t</mi>
    <mi>o</mi>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>π</mi>
      <mrow>
       <mi>a</mi>
       <mi>b</mi>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>o</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>o</ci>
     <ci>r</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>π</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   tor=tor(\pi^{ab})
  </annotation>
 </semantics>
</math>

 be the torsion subgroup of 

<math display="inline" id="Abel–Jacobi_map:23">
 <semantics>
  <msup>
   <mi>π</mi>
   <mrow>
    <mi>a</mi>
    <mi>b</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>π</ci>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi^{ab}
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Abel–Jacobi_map:24">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>π</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </msup>
    <mo>→</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>π</mi>
       <mrow>
        <mi>a</mi>
        <mi>b</mi>
       </mrow>
      </msup>
      <mo>/</mo>
      <mi>t</mi>
     </mrow>
     <mi>o</mi>
     <mi>r</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>π</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>π</ci>
        <apply>
         <times></times>
         <ci>a</ci>
         <ci>b</ci>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
      <ci>o</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g:\pi^{ab}\to\pi^{ab}/tor
  </annotation>
 </semantics>
</math>

 be the quotient by torsion. If 

<math display="inline" id="Abel–Jacobi_map:25">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is a surface, 

<math display="inline" id="Abel–Jacobi_map:26">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>π</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </msup>
    <mo>/</mo>
    <mi>t</mi>
   </mrow>
   <mi>o</mi>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>π</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
    <ci>o</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi^{ab}/tor
  </annotation>
 </semantics>
</math>

 is non-canonically isomorphic to 

<math display="inline" id="Abel–Jacobi_map:27">
 <semantics>
  <msup>
   <mi>ℤ</mi>
   <mrow>
    <mn>2</mn>
    <mi>g</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℤ</ci>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>g</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}^{2g}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Abel–Jacobi_map:28">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is the genus; more generally, 

<math display="inline" id="Abel–Jacobi_map:29">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>π</mi>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </msup>
    <mo>/</mo>
    <mi>t</mi>
   </mrow>
   <mi>o</mi>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>π</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
    <ci>o</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi^{ab}/tor
  </annotation>
 </semantics>
</math>

 is non-canonically isomorphic to 

<math display="inline" id="Abel–Jacobi_map:30">
 <semantics>
  <msup>
   <mi>ℤ</mi>
   <mi>b</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℤ</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}^{b}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Abel–Jacobi_map:31">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 is the first Betti number. Let 

<math display="inline" id="Abel–Jacobi_map:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mo>=</mo>
    <mrow>
     <mi>g</mi>
     <mo>∘</mo>
     <mi>f</mi>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>π</mi>
    <mo>→</mo>
    <msup>
     <mi>ℤ</mi>
     <mi>b</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <eq></eq>
     <ci>ϕ</ci>
     <apply>
      <compose></compose>
      <ci>g</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>π</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℤ</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi=g\circ f:\pi\to\mathbb{Z}^{b}
  </annotation>
 </semantics>
</math>

 be the composite homomorphism.</p>

<p>Definition. The cover 

<math display="inline" id="Abel–Jacobi_map:33">
 <semantics>
  <mover accent="true">
   <mi>M</mi>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{M}
  </annotation>
 </semantics>
</math>

 of the manifold 

<math display="inline" id="Abel–Jacobi_map:34">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 corresponding the subgroup 

<math display="inline" id="Abel–Jacobi_map:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>Ker</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ϕ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⊂</mo>
   <mi>π</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <ci>Ker</ci>
     <ci>ϕ</ci>
    </apply>
    <ci>π</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Ker}(\phi)\subset\pi
  </annotation>
 </semantics>
</math>

 is called the universal (or maximal) free abelian cover.</p>

<p>Now assume <em>M</em> has a <a href="Riemannian_metric" title="wikilink">Riemannian metric</a>. Let 

<math display="inline" id="Abel–Jacobi_map:36">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 be the space of harmonic 

<math display="inline" id="Abel–Jacobi_map:37">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

-forms on 

<math display="inline" id="Abel–Jacobi_map:38">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

, with dual 

<math display="inline" id="Abel–Jacobi_map:39">
 <semantics>
  <msup>
   <mi>E</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>E</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E^{*}
  </annotation>
 </semantics>
</math>

 canonically identified with 

<math display="inline" id="Abel–Jacobi_map:40">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo>,</mo>
    <mi>ℝ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">1</cn>
    </apply>
    <interval closure="open">
     <ci>M</ci>
     <ci>ℝ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}(M,\mathbb{R})
  </annotation>
 </semantics>
</math>

. By integrating an integral harmonic 

<math display="inline" id="Abel–Jacobi_map:41">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

-form along paths from a basepoint 

<math display="inline" id="Abel–Jacobi_map:42">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>∈</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}\in M
  </annotation>
 </semantics>
</math>

, we obtain a map to the circle 

<math display="inline" id="Abel–Jacobi_map:43">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℝ</mi>
    <mo>/</mo>
    <mi>ℤ</mi>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>S</mi>
    <mn>1</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>ℝ</ci>
     <ci>ℤ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}/\mathbb{Z}=S^{1}
  </annotation>
 </semantics>
</math>

.</p>

<p>Similarly, in order to define a map 

<math display="inline" id="Abel–Jacobi_map:44">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>H</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>M</mi>
       <mo>,</mo>
       <mi>ℝ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>/</mo>
     <msub>
      <mi>H</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo>,</mo>
      <mi>ℤ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>ℝ</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>M</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <cn type="integer">1</cn>
       </apply>
       <interval closure="open">
        <ci>M</ci>
        <ci>ℝ</ci>
       </interval>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <interval closure="open">
       <ci>M</ci>
       <ci>ℤ</ci>
      </interval>
      <ci>ℝ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\to H_{1}(M,\mathbb{R})/H_{1}(M,\mathbb{Z})_{\mathbb{R}}
  </annotation>
 </semantics>
</math>

 without choosing a basis for cohomology, we argue as follows. Let 

<math display="inline" id="Abel–Jacobi_map:45">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 be a point in the <a href="universal_cover" title="wikilink">universal cover</a> 

<math display="inline" id="Abel–Jacobi_map:46">
 <semantics>
  <mover accent="true">
   <mi>M</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{M}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Abel–Jacobi_map:47">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

. Thus 

<math display="inline" id="Abel–Jacobi_map:48">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is represented by a point of 

<math display="inline" id="Abel–Jacobi_map:49">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 together with a path 

<math display="inline" id="Abel–Jacobi_map:50">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Abel–Jacobi_map:51">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

 to it. By integrating along the path 

<math display="inline" id="Abel–Jacobi_map:52">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

, we obtain a linear form, 

<math display="inline" id="Abel–Jacobi_map:53">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>→</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi>c</mi>
    </msub>
    <mi>h</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>h</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>c</ci>
     </apply>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h\to\int_{c}h
  </annotation>
 </semantics>
</math>

, on 

<math display="inline" id="Abel–Jacobi_map:54">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

. We thus obtain a map 

<math display="inline" id="Abel–Jacobi_map:55">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>M</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>→</mo>
   <msup>
    <mi>E</mi>
    <mo>*</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo>,</mo>
     <mi>ℝ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>M</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>E</ci>
      <times></times>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <cn type="integer">1</cn>
      </apply>
      <interval closure="open">
       <ci>M</ci>
       <ci>ℝ</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{M}\to E^{*}=H_{1}(M,\mathbb{R})
  </annotation>
 </semantics>
</math>

, which, furthermore, descends to a map</p>

<p>

<math display="block" id="Abel–Jacobi_map:56">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>A</mi>
     <mo>¯</mo>
    </mover>
    <mi>M</mi>
   </msub>
   <mo>:</mo>
   <mover accent="true">
    <mi>M</mi>
    <mo>¯</mo>
   </mover>
   <mo>→</mo>
   <msup>
    <mi>E</mi>
    <mo>*</mo>
   </msup>
   <mo rspace="8.1pt">,</mo>
   <mi>c</mi>
   <mo>↦</mo>
   <mrow>
    <mo>(</mo>
    <mi>h</mi>
    <mo>↦</mo>
    <msub>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi>c</mi>
    </msub>
    <mi>h</mi>
    <mo>)</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-¯</ci>
      <ci>A</ci>
     </apply>
     <ci>M</ci>
    </apply>
    <ci>normal-:</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>M</ci>
    </apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>E</ci>
     <times></times>
    </apply>
    <ci>normal-,</ci>
    <csymbol cd="unknown">c</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">h</csymbol>
     <csymbol cd="latexml">maps-to</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>c</ci>
     </apply>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{A}_{M}:\overline{M}\to E^{*},\;\;c\mapsto\left(h\mapsto\int_{c}h%
\right),
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Abel–Jacobi_map:57">
 <semantics>
  <mover accent="true">
   <mi>M</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{M}
  </annotation>
 </semantics>
</math>

 is the universal free abelian cover.</p>

<p>Definition. The Jacobi variety (Jacobi torus) of 

<math display="inline" id="Abel–Jacobi_map:58">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is the torus</p>

<p>

<math display="block" id="Abel–Jacobi_map:59">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>J</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mi>H</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>M</mi>
        <mo>,</mo>
        <mi>ℝ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>/</mo>
      <msub>
       <mi>H</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>M</mi>
       <mo>,</mo>
       <mi>ℤ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>ℝ</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>J</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>M</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <cn type="integer">1</cn>
       </apply>
       <interval closure="open">
        <ci>M</ci>
        <ci>ℝ</ci>
       </interval>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <interval closure="open">
       <ci>M</ci>
       <ci>ℤ</ci>
      </interval>
      <ci>ℝ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J_{1}(M)=H_{1}(M,\mathbb{R})/H_{1}(M,\mathbb{Z})_{\mathbb{R}}.
  </annotation>
 </semantics>
</math>

</p>

<p>Definition. The <em>Abel–Jacobi map</em></p>

<p>

<math display="block" id="Abel–Jacobi_map:60">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>A</mi>
     <mi>M</mi>
    </msub>
    <mo>:</mo>
    <mrow>
     <mi>M</mi>
     <mo>→</mo>
     <mrow>
      <msub>
       <mi>J</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>M</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>M</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>J</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{M}:M\to J_{1}(M),
  </annotation>
 </semantics>
</math>

</p>

<p>is obtained from the map above by passing to quotients.</p>

<p>The Abel–Jacobi map is unique up to translations of the Jacobi torus. The map has applications in <a href="Systolic_geometry" title="wikilink">Systolic geometry</a>. Interestingly, the Abel-Jacobi map of a Riemannian manifold show up in a large time asymptotic of the heat kernel on a periodic manifold ( and ).</p>

<p>In much the same way, one can define a graph-theoretic analogue of Abel-Jacobi map as a P-L map from a finite graph into a flat torus (or a Cayley graph associated with a finite abelian group), which is closely related to asymptotic behaviors of random walks on crystal lattices, and can be used for design of crystal structures.</p>
<h2 id="abeljacobi-theorem">Abel–Jacobi theorem</h2>

<p>The following theorem was proved by Abel: Suppose that</p>

<p>

<math display="block" id="Abel–Jacobi_map:61">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <msub>
      <mi>n</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>p</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=\sum_{i}n_{i}p_{i}
  </annotation>
 </semantics>
</math>

 is a divisor (meaning a formal integer-linear combination of points of <em>C</em>). We can define</p>

<p>

<math display="block" id="Abel–Jacobi_map:62">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>D</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <msub>
      <mi>n</mi>
      <mi>i</mi>
     </msub>
     <mi>u</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>p</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>u</ci>
     <ci>D</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>i</ci>
      </apply>
      <ci>u</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(D)=\sum_{i}n_{i}u(p_{i})
  </annotation>
 </semantics>
</math>

 and therefore speak of the value of the Abel–Jacobi map on divisors. The theorem is then that if <em>D</em> and <em>E</em> are two <em>effective</em> divisors, meaning that the 

<math display="inline" id="Abel–Jacobi_map:63">
 <semantics>
  <msub>
   <mi>n</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{i}
  </annotation>
 </semantics>
</math>

 are all positive integers, then</p>

<p>

<math display="block" id="Abel–Jacobi_map:64">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>D</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>E</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>u</ci>
     <ci>D</ci>
    </apply>
    <apply>
     <times></times>
     <ci>u</ci>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(D)=u(E)
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Abel–Jacobi_map:65">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 is <a href="linearly_equivalent" title="wikilink">linearly equivalent</a> to 

<math display="inline" id="Abel–Jacobi_map:66">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E.
  </annotation>
 </semantics>
</math>

 This implies that the Abel–Jacobi map induces an injective map (of abelian groups) from the space of divisor classes of degree zero to the Jacobian. Jacobi proved that this map is also surjective, so the two groups are naturally isomorphic.</p>

<p>The Abel–Jacobi theorem implies that the <a href="Albanese_variety" title="wikilink">Albanese variety</a> of a compact complex curve (dual of holomorphic 1-forms modulo periods) is isomorphic to its <a href="Jacobian_variety" title="wikilink">Jacobian variety</a> (divisors of degree 0 modulo equivalence). For higher-dimensional compact projective varieties the Albanese variety and the Picard variety are dual but need not be isomorphic.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Algebraic_curves" title="wikilink">Category:Algebraic curves</a> <a href="Category:Riemannian_geometry" title="wikilink">Category:Riemannian geometry</a> <a href="Category:Niels_Henrik_Abel" title="wikilink">Category:Niels Henrik Abel</a></p>
</body>
</html>
