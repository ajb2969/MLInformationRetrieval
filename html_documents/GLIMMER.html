<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1610">GLIMMER</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>GLIMMER</h1>
<hr/>

<p>In <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a>, <strong>GLIMMER (Gene Locator and Interpolated Markov ModelER)</strong> is used to <a href="gene_prediction" title="wikilink">find genes</a> in prokaryotic <a class="uri" href="DNA" title="wikilink">DNA</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> "It is effective at finding genes in <a class="uri" href="bacteria" title="wikilink">bacteria</a>, <a class="uri" href="archea" title="wikilink">archea</a>, <a class="uri" href="viruses" title="wikilink">viruses</a>, typically finding <strong>98-99%</strong> of all <a href="genetic_code" title="wikilink">protein coding genes</a>".<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> GLIMMER was the first system that used the <a class="uri" href="interpolated" title="wikilink">interpolated</a> <a href="Markov_model" title="wikilink">Markov model</a> <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> to identify coding regions. The GLIMMER software is open source and is maintained by <a href="Steven_Salzberg" title="wikilink">Steven Salzberg</a>, Art Delcher, and their colleagues at the <em>Center for Computational Biology</em><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> at <a href="Johns_Hopkins_University" title="wikilink">Johns Hopkins University</a>.</p>
<h2 id="versions">Versions</h2>
<h3 id="glimmer-1.0">GLIMMER 1.0</h3>

<p>First Version of GLIMMER "i.e., GLIMMER 1.0" was released in 1998 and it was published in the paper <em>Microbial gene identification using interpolated Markov model</em>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Markov models were used to identify microbial genes in GLIMMER 1.0. GLIMMER considers the local composition sequence dependencies which makes GLIMMER more flexible and more powerful when compared to fixed-order <a href="Markov_model" title="wikilink">Markov model</a>.</p>

<p>There was a comparison made between <a class="uri" href="interpolated" title="wikilink">interpolated</a> Markov model used by GLIMMER and fifth order Markov model in the paper <em>Microbial gene identification using interpolated Markov models</em>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> "GLIMMER algorithm found 1680 genes out of 1717 annotated genes in <a href="Haemophilus_influenzae" title="wikilink">Haemophilus influenzae</a> where fifth order <a href="Markov_model" title="wikilink">Markov model</a> found 1574 genes. GLIMMER found 209 additional genes which were not included in 1717 annotated genes where fifth order <a href="Markov_model" title="wikilink">Markov model</a> found 104 genes."'<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="glimmer-2.0">GLIMMER 2.0</h3>

<p>Second Version of GLIMMER i.e., GLIMMER 2.0 was released in 1999 and it was published in the paper <em>Improved microbial identification with GLIMMER</em>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> This paper<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> provides significant technical improvements such as using interpolated context model instead of interpolated Markov model and resolving overlapping genes which improves the accuracy of GLIMMER.</p>

<p><a class="uri" href="Interpolated" title="wikilink">Interpolated</a> context models are used instead of <a class="uri" href="interpolated" title="wikilink">interpolated</a> Markov model which gives the flexibility to select any base. In interpolated Markov model probability distribution of a base is determined from the immediate preceding bases. If the immediate preceding base is irrelevant <a href="amino_acid" title="wikilink">amino acid</a> translation, interpolated Markov model still considers the preceding base to determine the probability of given base where as interpolated context model which was used in GLIMMER 2.0 can ignore irrelevant bases. False positive predictions were increased in GLIMMER 2.0 to reduce the number of false negative predictions. Overlapped genes are also resolved in GLIMMER 2.0.</p>

<p>Various comparisons between GLIMMER 1.0 and GLIMMER 2.0 were made in the paper <em>Improved microbial identification with GLIMMER</em><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> which shows improvement in the later version. "Sensitivity of GLIMMER 1.0 ranges from 98.4 to 99.7% with an average of 99.1% where as GLIMMER 2.0 has a sensitivity range from 98.6 to 99.8% with an average of 99.3%. GLIMMER 2.0 is very effective in finding genes of high density. The parasite <a href="Trypanosoma_brucei" title="wikilink">Trypanosoma brucei</a>, responsible for causing <a href="African_trypanosomiasis" title="wikilink">African sleeping sickness</a> is being identified by GLIMMER 2.0" <a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h3 id="glimmer-3.0">GLIMMER 3.0</h3>

<p>Third version of GLIMMER, "GLIMMER 3.0" was released in 2007 and it was published in the paper <em>Identifying bacterial genes and endosymbiont DNA with Glimmer</em>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> This paper describes several major changes made to the GLIMMER system including improved methods to identify coding regions and start <a href="genetic_code" title="wikilink">codon</a>. Scoring of ORF in GLIMMER 3.0 is done in reverse order i.e., starting from stop codon and moves back towards the start codon. Reverse scanning helps in identifying the coding portion of the gene more accurately which is contained in the context window of IMM. GLIMMER 3.0 also improves the generated training set data by comparing the long-ORF with universal amino acid distribution of widely disparate bacterial genomes."GLIMMER 3.0 has an average long-ORF output of 57% for various organisms where as GLIMMER 2.0 has an average long-ORF output of 39%."<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>GLIMMER 3.0 reduces the rate of false positive predictions which were increased in GLIMMER 2.0 to reduce the number of false negative predictions. "GLIMMER 3.0 has a start-site prediction accuracy of 99.5% for 3'5' matches where as GLIMMER 2.0 has 99.1% for 3'5' matches. GLIMMER 3.0 uses a new algorithm for scanning coding regions, a new start site detection module, and architecture which integrates all gene predictions across an entire genome."<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="access">Access</h2>

<p>GLIMMER can be downloaded from <a href="http://ccb.jhu.edu/software/glimmer/index.shtml">The Glimmer home page</a> (requires a C++ <a class="uri" href="compiler" title="wikilink">compiler</a>). Alternatively, an online version is hosted by <a href="National_Center_for_Biotechnology_Information" title="wikilink">NCBI</a> <a href="http://www.ncbi.nlm.nih.gov/genomes/MICROBES/glimmer_3.cgi">1</a>.</p>
<h2 id="how-it-works">How it works</h2>

<p>1. GLIMMER primarily searches for long-<a href="open_reading_frame" title="wikilink">ORFS</a>. An open reading frame might overlap with any other open reading frame which will be resolved using the technique described in the sub section. Using these long-ORFS and following certain amino acid distribution GLIMMER generates <a href="training_set" title="wikilink">training set</a> data.</p>

<p>2. Using these training data, GLIMMER trains all the six Markov models of coding DNA from zero to eight order and also train the model for <a href="noncoding_DNA" title="wikilink">noncoding DNA</a></p>

<p>3. GLIMMER tries to calculate the probabilities from the data. Based on the number of observations, GLIMMER determines whether to use fixed order <a href="Markov_model" title="wikilink">Markov model</a> or <a class="uri" href="interpolated" title="wikilink">interpolated</a> Markov model.</p>

<p><code>   a. If the number of observations are greater than 400, GLIMMER uses fixed order Markov model to obtain there probabilities.</code></p>

<p><code>   b. If the number of observations are less than 400, GLIMMER uses </code><a href="interpolated" title="wikilink"><code>interpolated</code></a><code> Markov model which is briefly explained in the next sub section.</code></p>

<p>4. GLIMMER obtains score for every long-ORF generated using all the six coding DNA models and also using non-coding DNA model.</p>

<p>5. If the score obtained in the previous step is greater than a certain threshold then GLIMMER predicts it to be a gene.</p>

<p>The steps explained above describres the basic functionality of GLIMMER. There are various improvements made to GLIMMER and some of them are described in the following sub-sections.</p>
<h3 id="the-glimmer-system">The GLIMMER system</h3>

<p>GLIMMER system consists of two programs. First program called build-imm, which takes an input set of sequences and outputs the <a class="uri" href="interpolated" title="wikilink">interpolated</a> Markov model as follows.</p>

<p>The probability for each base i.e., A,C,G,T for all <a href="k-mer" title="wikilink">k-mers</a> for 0 ≤ k ≤ 8 is computed. Then, for each <a class="uri" href="k-mer" title="wikilink">k-mer</a>, GLIMMER computes weight. New sequence probability is computed as follows.</p>
<center>

<p>

<math display="inline" id="GLIMMER:0">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">S</mi>
      <mo>/</mo>
      <mi mathvariant="normal">M</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi mathvariant="normal">x</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi mathvariant="normal">n</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>IMM</mi>
      <mn>8</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi mathvariant="normal">S</mi>
       <mi mathvariant="normal">x</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-P</ci>
     <apply>
      <divide></divide>
      <ci>normal-S</ci>
      <ci>normal-M</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>normal-x</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>IMM</ci>
       <cn type="integer">8</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-S</ci>
       <ci>normal-x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{P(S/M)=\sum_{x=1}^{n}{IMM_{8}(S_{x})}}
  </annotation>
 </semantics>
</math>

</p>
</center>

<p>where n is the length of the sequence 

<math display="inline" id="GLIMMER:1">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{x}
  </annotation>
 </semantics>
</math>

 is the <a class="uri" href="oligomer" title="wikilink">oligomer</a> at position x. 

<math display="inline" id="GLIMMER:2">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mi>M</mi>
   <msub>
    <mi>M</mi>
    <mn>8</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mi>x</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>M</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">8</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   IMM_{8}(S_{x})
  </annotation>
 </semantics>
</math>

, the 

<math display="inline" id="GLIMMER:3">
 <semantics>
  <msup>
   <mn>8</mn>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">8</cn>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   8^{th}
  </annotation>
 </semantics>
</math>

-order <a class="uri" href="interpolated" title="wikilink">interpolated</a> Markov model score is computed as</p>
<center>

<p>

<math display="inline" id="GLIMMER:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>IMM</mi>
     <mi mathvariant="normal">k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi mathvariant="normal">S</mi>
      <mi mathvariant="normal">x</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mi mathvariant="normal">Y</mi>
        <mi mathvariant="normal">k</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi mathvariant="normal">S</mi>
         <mrow>
          <mi mathvariant="normal">x</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>*</mo>
      <msub>
       <mi mathvariant="normal">P</mi>
       <mi mathvariant="normal">k</mi>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi mathvariant="normal">S</mi>
       <mi mathvariant="normal">x</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <msub>
          <mi mathvariant="normal">Y</mi>
          <mi mathvariant="normal">k</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mrow>
            <msub>
             <mi mathvariant="normal">S</mi>
             <mo stretchy="false">(</mo>
            </msub>
            <mi mathvariant="normal">x</mi>
           </mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
      <mo>*</mo>
      <msub>
       <mi>IMM</mi>
       <mrow>
        <mi mathvariant="normal">k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi mathvariant="normal">S</mi>
       <mi mathvariant="normal">x</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>IMM</ci>
      <ci>normal-k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-S</ci>
      <ci>normal-x</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-Y</ci>
         <ci>normal-k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-S</ci>
         <apply>
          <minus></minus>
          <ci>normal-x</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-P</ci>
        <ci>normal-k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-S</ci>
       <ci>normal-x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>normal-Y</ci>
           <ci>normal-k</ci>
          </apply>
          <apply>
           <minus></minus>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>normal-S</ci>
             <ci>normal-(</ci>
            </apply>
            <ci>normal-x</ci>
           </apply>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>IMM</ci>
        <apply>
         <minus></minus>
         <ci>normal-k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-S</ci>
       <ci>normal-x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{IMM_{k}(S_{x})=Y_{k}(S_{x-1})*P_{k}(S_{x})+[1-{Y_{k}(S_{(}x-1)]*%
IMM_{k-1}(S_{x})}}
  </annotation>
 </semantics>
</math>

</p>
</center>

<p>"where 

<math display="inline" id="GLIMMER:5">
 <semantics>
  <mrow>
   <msub>
    <mi>Y</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{k}(S_{x-1})
  </annotation>
 </semantics>
</math>

 is the weight of the <a class="uri" href="k-mer" title="wikilink">k-mer</a> at position x-1 in the sequence S and 

<math display="inline" id="GLIMMER:6">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mi>x</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{k}(S_{x})
  </annotation>
 </semantics>
</math>

 is the estimate obtained from the training data of the probability of the base located at position x in the 

<math display="inline" id="GLIMMER:7">
 <semantics>
  <msup>
   <mi>k</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{th}
  </annotation>
 </semantics>
</math>

-order model."<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>The probability of base 

<math display="inline" id="GLIMMER:8">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{x}
  </annotation>
 </semantics>
</math>

 given the i previous bases is computed as follows.</p>
<center>

<p>

<math display="inline" id="GLIMMER:9">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">P</mi>
     <mi mathvariant="normal">i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi mathvariant="normal">S</mi>
      <mi mathvariant="normal">x</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi mathvariant="normal">s</mi>
       <mi mathvariant="normal">x</mi>
      </msub>
      <mo>/</mo>
      <msub>
       <mi mathvariant="normal">S</mi>
       <mrow>
        <mi mathvariant="normal">x</mi>
        <mo>,</mo>
        <mi mathvariant="normal">j</mi>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi mathvariant="normal">S</mi>
       <mrow>
        <mi mathvariant="normal">x</mi>
        <mo>,</mo>
        <mi mathvariant="normal">j</mi>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>be</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>acgt</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </msub>
     <mrow>
      <mi mathvariant="normal">f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi mathvariant="normal">S</mi>
        <mrow>
         <mi mathvariant="normal">x</mi>
         <mo>,</mo>
         <mi mathvariant="normal">i</mi>
        </mrow>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-P</ci>
       <ci>normal-i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-S</ci>
       <ci>normal-x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>normal-P</ci>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-s</ci>
        <ci>normal-x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-S</ci>
        <list>
         <ci>normal-x</ci>
         <ci>normal-j</ci>
        </list>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>normal-f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-S</ci>
        <list>
         <ci>normal-x</ci>
         <ci>normal-j</ci>
        </list>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <times></times>
         <ci>be</ci>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <ci>acgt</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>normal-f</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>normal-S</ci>
          <list>
           <ci>normal-x</ci>
           <ci>normal-i</ci>
          </list>
         </apply>
         <ci>normal-b</ci>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{P_{i}(S_{x})=P(s_{x}/S_{x,j})=f(S_{x,j})/\sum_{be{[acgt]}}%
\operatorname{f(S_{x,i},b)}}
  </annotation>
 </semantics>
</math>

</p>
</center>

<p>"The value of 

<math display="inline" id="GLIMMER:10">
 <semantics>
  <mrow>
   <msub>
    <mi>Y</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mi>x</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{i}(S_{x})
  </annotation>
 </semantics>
</math>

 associated with 

<math display="inline" id="GLIMMER:11">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mi>x</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}(S_{x})
  </annotation>
 </semantics>
</math>

 can be regarded as a measure of confidence in the accuracy of this value as an estimate of the true probability. GLIMMER uses two criteria to determine 

<math display="inline" id="GLIMMER:12">
 <semantics>
  <mrow>
   <msub>
    <mi>Y</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mi>x</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{i}(S_{x})
  </annotation>
 </semantics>
</math>

. The first of these is simple frequency occurrence in which the number of occurrences of context string 

<math display="inline" id="GLIMMER:13">
 <semantics>
  <msub>
   <mi>S</mi>
   <mrow>
    <mi>x</mi>
    <mo>,</mo>
    <mi>i</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <list>
     <ci>x</ci>
     <ci>i</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{x,i}
  </annotation>
 </semantics>
</math>

 in the training data exceeds a specific threshold value, then 

<math display="inline" id="GLIMMER:14">
 <semantics>
  <mrow>
   <msub>
    <mi>Y</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mi>x</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{i}(S_{x})
  </annotation>
 </semantics>
</math>

 is set to 1.0. The current default value for threshold is 400, which gives 95% confidence. When there are insufficient sample occurrences of a context string, build-imm employ additional criteria to determine 

<math display="inline" id="GLIMMER:15">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 value. For a given context string 

<math display="inline" id="GLIMMER:16">
 <semantics>
  <msub>
   <mi>S</mi>
   <mrow>
    <mi>x</mi>
    <mo>,</mo>
    <mi>i</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <list>
     <ci>x</ci>
     <ci>i</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{x,i}
  </annotation>
 </semantics>
</math>

 of length i, build-imm compare the observed frequencies of the following base 

<math display="inline" id="GLIMMER:17">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mrow>
      <mi>x</mi>
      <mo>,</mo>
      <mi>i</mi>
     </mrow>
    </msub>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <list>
       <ci>x</ci>
       <ci>i</ci>
      </list>
     </apply>
     <ci>a</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(S_{x,i},a)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="GLIMMER:18">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mrow>
      <mi>x</mi>
      <mo>,</mo>
      <mi>i</mi>
     </mrow>
    </msub>
    <mo>,</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <list>
       <ci>x</ci>
       <ci>i</ci>
      </list>
     </apply>
     <ci>c</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(S_{x,i},c)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="GLIMMER:19">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mrow>
      <mi>x</mi>
      <mo>,</mo>
      <mi>i</mi>
     </mrow>
    </msub>
    <mo>,</mo>
    <mi>g</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <list>
       <ci>x</ci>
       <ci>i</ci>
      </list>
     </apply>
     <ci>g</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(S_{x,i},g)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="GLIMMER:20">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mrow>
      <mi>x</mi>
      <mo>,</mo>
      <mi>i</mi>
     </mrow>
    </msub>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <list>
       <ci>x</ci>
       <ci>i</ci>
      </list>
     </apply>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(S_{x,i},t)
  </annotation>
 </semantics>
</math>

 with the previously calculated <a class="uri" href="interpolated" title="wikilink">interpolated</a> Markov model probabilities using the next shorter context, 

<math display="inline" id="GLIMMER:21">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mi>M</mi>
   <msub>
    <mi>M</mi>
    <mrow>
     <mi>i</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mrow>
      <mi>x</mi>
      <mo>,</mo>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mrow>
    </msub>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>M</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <apply>
      <minus></minus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <list>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </list>
     </apply>
     <ci>a</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   IMM_{i-1}(S_{x,{i-1}},a)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="GLIMMER:22">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mi>M</mi>
   <msub>
    <mi>M</mi>
    <mrow>
     <mi>i</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mrow>
      <mi>x</mi>
      <mo>,</mo>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mrow>
    </msub>
    <mo>,</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>M</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <apply>
      <minus></minus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <list>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </list>
     </apply>
     <ci>c</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   IMM_{i-1}(S_{x,{i-1}},c)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="GLIMMER:23">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mi>M</mi>
   <msub>
    <mi>M</mi>
    <mrow>
     <mi>i</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mrow>
      <mi>x</mi>
      <mo>,</mo>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mrow>
    </msub>
    <mo>,</mo>
    <mi>g</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>M</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <apply>
      <minus></minus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <list>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </list>
     </apply>
     <ci>g</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   IMM_{i-1}(S_{x,{i-1}},g)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="GLIMMER:24">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mi>M</mi>
   <msub>
    <mi>M</mi>
    <mrow>
     <mi>i</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mrow>
      <mi>x</mi>
      <mo>,</mo>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mrow>
    </msub>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>M</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <apply>
      <minus></minus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <list>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </list>
     </apply>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   IMM_{i-1}(S_{x,{i-1}},t)
  </annotation>
 </semantics>
</math>

. Using a 

<math display="inline" id="GLIMMER:25">
 <semantics>
  <msup>
   <mi>X</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>X</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{2}
  </annotation>
 </semantics>
</math>

 test, build-imm determine how likely it is that the four observed frequencies are consistent with the IMM values from the next shorter context."<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>The second program called glimmer, then uses this IMM to identify putative gene in an entire genome. GLIMMER identifies all the <a href="open_reading_frame" title="wikilink">open reading frame</a> which score higher than threshold and check for overlapping genes. Resolving overlapping genes is explained in the next sub-section.</p>

<p>Equations and explanation of the terms used above are taken from the paper 'Microbial gene identification using interpolated Markov models<em><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></em></p>
<h3 id="resolving-overlapping-genes">Resolving overlapping genes</h3>

<p>In GLIMMER 1.0, when two genes A and B overlap, the overlap region is scored. If A is longer than B, and if A scores higher on the overlap region, and if moving B's start site will not resolve the overlap, then B is rejected.</p>

<p>GLIMMER 2.0 provided a better solution to resolve the overlap. In GLIMMER 2.0, when two potential genes A and B overlap, the overlap region is scored. Suppose gene A scores higher, four different orientations are considered.</p>
<figure><b>(Figure)</b>
<figcaption>Case 1</figcaption>
</figure>

<p>In the above case, moving of start sites does not remove the overlap. If A is significantly longer than B, then B is rejected or else both A and B are called genes, with a doubtful overlap.</p>
<figure><b>(Figure)</b>
<figcaption>Case 2</figcaption>
</figure>

<p>In the above case, moving of B can resolve the overlap, A and B can be called non overlapped genes but if B is significantly shorter than A, then B is rejected.</p>
<figure><b>(Figure)</b>
<figcaption>Case 3</figcaption>
</figure>

<p>In the above case, moving of A can resolve the overlap. A is only moved if overlap is a small fraction of A or else B is rejected.</p>
<figure><b>(Figure)</b>
<figcaption>Case 4</figcaption>
</figure>

<p>In the above case, both A and B can be moved. We first move the start of B until the overlap region scores higher for B. Then we move the start of A until it scores higher. Then B again, and so on, until either the overlap is eliminated or no further moves can be made.</p>

<p>The above example has been taken from the paper 'Identifying bacterial genes and endosymbiont DNA with Glimmer''''<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h3 id="ribosome-binding-sites">Ribosome binding sites</h3>

<p><a href="ribosomal_binding_site" title="wikilink">Ribosome binding site</a>(RBS) signal can be used to find true start site position. GLIMMER results are passed as an input for RBSfinder program to predict ribosome binding sites. GLIMMER 3.0 integrates RBSfinder program into gene predicting function itself.</p>

<p>ELPH software( which was determined as highly effective at identifying RBS in the paper<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a>) is used for identifying RBS and is available at this <a href="http://cbcb.umd.edu/software/ELPH/">website</a>. <a href="Gibbs_sampling" title="wikilink">Gibbs sampling</a> algorithm is used to identify shared <a href="Sequence_motif" title="wikilink">motif</a> in any set of sequences. This shared <a href="Sequence_motif" title="wikilink">motif</a> sequences and their length is given as input to ELPH. ELPH then computes the position weight matrix(PWM) which will be used by GLIMMER 3 to score any potential RBS found by RBSfinder. The above process is done when we have a substantial amount of training genes. If there are inadequate number of training genes, GLIMMER 3 can bootstrap itself to generate a set of gene predictions which can be used as input to ELPH. ELPH now computes PWM and this PWM can be again used on the same set of genes to get more accurate results for start-sites. This process can be repeated for many iterations to obtain more consistent PWM and gene prediction results.</p>
<h2 id="performance">Performance</h2>

<p>Glimmer supports genome annotation efforts on a wide range of bacterial, archaeal, and viral species. In a large-scale reannotation effort at the DNA Data Bank of Japan (DDBJ, which mirrors <a class="uri" href="Genbank" title="wikilink">Genbank</a>). Kosuge <em>et al.</em> (2006)<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> examined the gene finding methods used for 183 genomes. They reported that of these projects, Glimmer was the gene finder for 49%, followed by <a class="uri" href="GeneMark" title="wikilink">GeneMark</a> with 12%, with other algorithms used in 3% or fewer of the projects. (They also reported that 33% of genomes used "other" programs, which in many cases meant that they could not identify the method. Excluding those cases, Glimmer was used for 73% of the genomes for which the methods could be unambiguously identified.) Glimmer was used by the DDBJ to re-annotate all bacterial genomes in the International Nucleotide Sequence Databases.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> It is also being used by this group to annotate viruses.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> Glimmer is part of the bacterial annotation pipeline at the National Center for Biotechnology Information (NCBI),<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> which also maintains a web server for Glimmer,<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> as do sites in Germany,<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> Canada,.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>

<p>According to Google Scholar, as of early 2011 the original Glimmer article (Salzberg et al., 1998)<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> has been cited 581 times, and the Glimmer 2.0 article (Delcher et al., 1999)<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> has been cited 950 times.</p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://ccb.jhu.edu/software/glimmer/index.shtml">The Glimmer home page at CCB, Johns Hopkins University</a>, from which the software can be downloaded.</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Bioinformatics" title="wikilink">Category:Bioinformatics</a> <a href="Category:Markov_models" title="wikilink">Category:Markov models</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"></li>
<li id="fn28"></li>
</ol>
</section>
</body>
</html>
