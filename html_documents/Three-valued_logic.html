<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1452">Three-valued logic</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Three-valued logic</h1>
<hr/>

<p>In <a class="uri" href="logic" title="wikilink">logic</a>, a <strong>three-valued logic</strong> (also <strong>trinary logic</strong>, <strong>trivalent</strong>, <strong>ternary</strong>, or <strong>trilean</strong>, sometimes abbreviated <strong>3VL</strong>) is any of several <a href="many-valued_logic" title="wikilink">many-valued logic</a> systems in which there are three <a href="truth_value" title="wikilink">truth values</a> indicating <em>true</em>, <em>false</em> and some indeterminate third value. This is contrasted with the more commonly known <a href="Principle_of_bivalence" title="wikilink">bivalent</a> logics (such as classical sentential or <a href="Boolean_logic" title="wikilink">Boolean logic</a>) which provide only for <em>true</em> and <em>false</em>. Conceptual form and basic ideas were initially created by <a href="Jan_Łukasiewicz" title="wikilink">Jan Łukasiewicz</a> and <a href="C._I._Lewis" title="wikilink">C. I. Lewis</a>. These were then re-formulated by <a href="Grigore_Moisil" title="wikilink">Grigore Moisil</a> in an axiomatic algebraic form, and also extended to <em>n</em>-valued logics in 1945.</p>
<h2 id="representation-of-values">Representation of values</h2>

<p>As with bivalent logic, truth values in ternary logic may be represented numerically using various representations of the <a href="ternary_numeral_system" title="wikilink">ternary numeral system</a>. A few of the more common examples are:</p>
<ul>
<li>in <a href="balanced_ternary" title="wikilink">balanced ternary</a>, each digit has one of 3 values: −1, 0, or +1; these values may also be simplified to −, 0, +, respectively.<ref></ref></li>
</ul>

<p></p>
<ul>
<li>in the <a href="redundant_binary_representation" title="wikilink">redundant binary representation</a>, each digit can have a value of -1, 0, 0, or 1 (the value 0 has two different representations)</li>
<li>in the <a href="ternary_numeral_system" title="wikilink">ternary numeral system</a>, each <a href="numerical_digit" title="wikilink">digit</a> is a <em><a href="trit_(computing)" title="wikilink">trit</a></em> (trinary digit) having a value of: 0, 1, or 2</li>
<li>in the <a href="skew_binary_number_system" title="wikilink">skew binary number system</a>, only most-significant non-zero digit has a value 2, and the remaining digits have a value of 0 or 1</li>
<li>1 for <em>true</em>, 2 for <em>false</em>, and 0 for <em>unknown</em>, <em>unknowable</em>/<em>undecidable</em>, <em>irrelevant</em>, or <em>both</em>.<ref></ref></li>
</ul>

<p></p>
<ul>
<li>0 for <em>false</em>, 1 for <em>true</em>, and a third non-integer "maybe" symbol such as ?, #, ½,<ref></ref></li>
</ul>

<p> or xy.</p>

<p>Inside a <a href="ternary_computer" title="wikilink">ternary computer</a>, ternary values are represented by <a href="ternary_signal" title="wikilink">ternary signals</a>.</p>

<p>This article mainly illustrates a system of ternary <a href="propositional_logic" title="wikilink">propositional logic</a> using the truth values {<em>false, unknown,</em> and <em>true</em>}, and extends conventional Boolean <a class="uri" href="connectives" title="wikilink">connectives</a> to a trivalent context. Ternary <a href="predicate_logic" title="wikilink">predicate logics</a> exist as well; these may have readings of the <a href="quantifier_(logic)" title="wikilink">quantifier</a> different from classical (binary) predicate logic, and may include alternative quantifiers as well.</p>
<h2 id="logics">Logics</h2>

<p>Where <a href="Boolean_Logic" title="wikilink">Boolean Logic</a> has 4 <a href="monadic_operator" title="wikilink">monadic operators</a>, the addition of a third value in ternary logic leads to a total of 27 distinct operators on a single input value. Similarly, where Boolean logic has 16 distinct diadic operators (operators with 2 inputs), ternary logic has 19,683 such operators. Where we can easily name a significant fraction of the Boolean operators (<a href="Not_(logic)" title="wikilink">not</a>, <a href="And_(logic)" title="wikilink">and</a>, <a href="Or_(logic)" title="wikilink">or</a>, <a href="Logical_NAND" title="wikilink">nand</a>, <a href="logical_NOR" title="wikilink">nor</a>, <a href="exclusive_or" title="wikilink">exclusive or</a>), it is unreasonable to attempt to name all but a small fraction of the possible ternary operators.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h3 id="kleene-and-priest-logics">Kleene and Priest logics</h3>

<p>Below is a set of <a href="truth_table" title="wikilink">truth tables</a> showing the logic operations for <a href="Stephen_Cole_Kleene" title="wikilink">Kleene</a>'s "strong logic of indeterminacy" and Priest's "logic of paradox".</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>(F, false; U, unknown; T, true)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>NOT(A)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>A</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>scope="row" F}}</p>
</td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>scope="row" U}}</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>scope="row" T}}</p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>(−1, false; 0, unknown; +1, true)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>NEG(A)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>A</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>scope="row" −1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>scope="row" 0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>scope="row" +1</p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table>

<p>In these truth tables, the <em>unknown</em> state can be thought of as neither true nor false in Kleene logic, or thought of as both true and false in Priest logic. The difference lies in the definition of tautologies. Where Kleene logic's only designated truth value is T, Priest logic's designated truth values are both T and U. In Kleene logic, the knowledge of whether any particular <em>unknown</em> state secretly represents <em>true</em> or <em>false</em> at any moment in time is not available. However, certain logical operations can yield an unambiguous result, even if they involve at least one <em>unknown</em> operand. For example, since <em>true</em> OR <em>true</em> equals <em>true</em>, and <em>true</em> OR <em>false</em> also equals <em>true</em>, one can infer that <em>true</em> OR <em>unknown</em> equals <em>true</em>, as well. In this example, since either bivalent state could be underlying the <em>unknown</em> state, but either state also yields the same result, a definitive <em>true</em> results in all three cases.</p>

<p>If numeric values, e.g. <a href="balanced_ternary" title="wikilink">balanced ternary</a> values, are assigned to <em>false</em>, <em>unknown</em> and <em>true</em> such that <em>false</em> is less than <em>unknown</em> and <em>unknown</em> is less than <em>true</em>, then A AND B AND C... = MIN(A, B, C ...) and A OR B OR C ... = MAX(A, B, C...).</p>

<p>Material implication for Kleene logic can be defined as:</p>

<p>

<math display="inline" id="Three-valued_logic:0">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>B</mi>
    </mpadded>
    <mpadded width="+5pt">
     <mover accent="true">
      <mo>=</mo>
      <munder accentunder="true">
       <mi></mi>
       <mo>def</mo>
      </munder>
     </mover>
    </mpadded>
    <mtext>NOT</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
    <mpadded width="+5pt">
     <mtext>OR</mtext>
    </mpadded>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>B</ci>
     <apply>
      <apply>
       <ci>def</ci>
       <csymbol cd="latexml">absent</csymbol>
      </apply>
      <eq></eq>
     </apply>
     <mtext>NOT</mtext>
     <ci>A</ci>
     <mtext>OR</mtext>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\rightarrow B\ \overset{\underset{\mathrm{def}}{}}{=}\ \mbox{NOT}(A)\ \mbox{%
OR}\ B
  </annotation>
 </semantics>
</math>

, and its truth table is</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>IMP

<math display="inline" id="Three-valued_logic:1">
 <semantics>
  <msub>
   <mi></mi>
   <mi>K</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}_{K}
  </annotation>
 </semantics>
</math>

(A, B), OR(¬A, B)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>rowspan="2" A → B</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>T}}</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>A</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>scope="row" U}}</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>scope="row" F}}</p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>IMP

<math display="inline" id="Three-valued_logic:2">
 <semantics>
  <msub>
   <mi></mi>
   <mi>K</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}_{K}
  </annotation>
 </semantics>
</math>

(A, B), MAX(−A, B)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>rowspan="2" A → B</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>+1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>A</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>scope="row" 0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>scope="row" −1</p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table>

<p>which differs from that for Łukasiewicz logic (described below).</p>

<p>Kleene logic has no tautologies (valid formulas) because whenever all of the atomic components of a well-formed formula are assigned the value Unknown, the formula itself must also have the value Unknown. (And the only <em>designated</em> truth value for Kleene logic is True.) However, the lack of valid formulas does not mean that it lacks valid arguments and/or inference rules. An argument is semantically valid in Kleene logic if, whenever (for any interpretation/model) all of its premises are True, the conclusion must also be True. (Note that the <a href="paraconsistent_logic" title="wikilink">Logic of Paradox</a> (LP) has the same truth tables as Kleene logic, but it has two <em>designated</em> truth values instead of one; these are: True and Both (the analogue of Unknown), so that LP does have tautologies but it has fewer valid inference rules.)<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h3 id="łukasiewicz-logic">Łukasiewicz logic</h3>

<p>The Łukasiewicz Ł3 has the same tables for AND, OR, and NOT as the Kleene logic given above, but differs in its definition of implication. This section follows the presentation from Malinowski's chapter of the <em>Handbook of the History of Logic</em>, vol 8.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>IMP

<math display="inline" id="Three-valued_logic:3">
 <semantics>
  <msub>
   <mi></mi>
   <mi>Ł</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>Ł</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}_{Ł}
  </annotation>
 </semantics>
</math>

(A, B)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>rowspan="2" A → B</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>T}}</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>A</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>scope="row" U}}</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>scope="row" F}}</p></td>
</tr>
<tr class="odd">
</tr>
</tbody>
</table></td>
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>IMP

<math display="inline" id="Three-valued_logic:4">
 <semantics>
  <msub>
   <mi></mi>
   <mi>Ł</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>Ł</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}_{Ł}
  </annotation>
 </semantics>
</math>

(A, B)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>rowspan="2" A → B</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>+1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>A</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>scope="row" 0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>scope="row" −1</p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table>

<p>In fact, using Łukasiewicz's implication and negation, the other usual connectives may be derived as:</p>
<ul>
<li><em>A</em> ∨ <em>B</em> = (<em>A</em> → <em>B</em>) → <em>B</em></li>
<li><em>A</em> ∧ <em>B</em> = ¬(¬<em>A</em> ∨ ¬ <em>B</em>)</li>
<li><em>A</em> ↔ <em>B</em> = (<em>A</em> → <em>B</em>) ∧ (<em>B</em> → <em>A</em>)</li>
</ul>

<p>It's also possible to derive a few other useful unary operators (first derived by Tarski in 1921):</p>
<ul>
<li><strong>M</strong><em>A</em> = ¬<em>A</em> → <em>A</em></li>
<li><strong>L</strong><em>A</em> = ¬<strong>M</strong>¬<em>A</em></li>
<li><strong>I</strong><em>A</em> = <strong>M</strong><em>A</em> ∧ ¬<strong>L</strong><em>A</em></li>
</ul>

<p>They have the following truth tables:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p><em>A</em></p></th>
<th style="text-align: left;">
<p>M<em>A</em></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>F}}</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>U}}</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>T}}</p></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>|</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p><em>A</em></p></th>
<th style="text-align: left;">
<p>L<em>A</em></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>F}}</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>U}}</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>T}}</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>|</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p><em>A</em></p></th>
<th style="text-align: left;">
<p>I<em>A</em></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>F}}</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>U}}</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>T}}</p></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table>

<p>M is read as "it is not false that..." or in the (unsuccessful) Tarski–Łukasiewicz attempt to axiomatize <a href="modal_logic" title="wikilink">modal logic</a> using a three-valued logic, "it is possible that..." L is read "it is true that..." or "it is necessary that..." Finally I is read "it is unknown that..." or "it is contingent that..."</p>

<p>In Łukasiewicz's Ł3 the <a href="designated_value" title="wikilink">designated value</a> is True, meaning that only a proposition having this value everywhere is considered a <a href="tautology_(logic)" title="wikilink">tautology</a>. For example <em>A</em> → <em>A</em> and <em>A</em> ↔ <em>A</em> are tautologies in Ł3 and also in classical logic. Not all tautologies of classical logic lift to Ł3 "as is". For example, the <a href="law_of_excluded_middle" title="wikilink">law of excluded middle</a>, <em>A</em> ∨ ¬<em>A</em>, and the <a href="law_of_non-contradiction" title="wikilink">law of non-contradiction</a>, ¬(<em>A</em> ∧ ¬<em>A</em>) are not tautologies in Ł3. However, using the operator <strong>I</strong> defined above, it is possible to state tautologies that are their analogues:</p>
<ul>
<li><em>A</em> ∨ <strong>I</strong><em>A</em> ∨ ¬<em>A</em> [law of excluded fourth]</li>
<li>¬(<em>A</em> ∧ ¬<strong>I</strong><em>A</em> ∧ ¬<em>A</em>) [extended contradiction principle].</li>
</ul>
<h3 id="bochvar-logic">Bochvar logic</h3>
<h3 id="ternary-post-logic">ternary Post logic</h3>
<h3 id="modular-algebras">Modular algebras</h3>

<p>Some 3VL <a href="modular_algebra" title="wikilink">modular algebras</a> have been introduced more recently, motivated by circuit problems rather than philosophical issues:<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<ul>
<li>Cohn algebra</li>
<li>Pradhan algebra</li>
<li>Dubrova and Muzio algebra</li>
</ul>
<h2 id="application-in-sql">Application in SQL</h2>

<p>The database structural query language <a class="uri" href="SQL" title="wikilink">SQL</a> implements ternary logic as a means of handling comparisons with <a href="Null_(SQL)" title="wikilink">NULL</a> field content. The original intent of NULL in SQL was to represent missing data in a database, i.e. the assumption that an actual value exists, but that the value is not currently recorded in the database. SQL uses a common fragment of the Kleene K3 logic, restricted to AND, OR, and NOT tables. In SQL, the intermediate value is intended to be interpreted as UNKNOWN. Explicit comparisons with NULL, including that of another NULL yields UNKNOWN. However this choice of semantics is abandoned for some set operations, e.g. UNION or INTERSECT, where NULLs are treated as equal with each other. Critics assert that this inconsistency deprives SQL of intuitive semantics in its treatment of NULLs.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The SQL standard defines an optional feature called F571, which adds some unary operators, among which IS UNKNOWN corresponding to the Łukasiewicz <strong>I</strong> in this article. The addition of IS UNKNOWN to the other operators of SQL's three-valued logic makes the SQL three-valued logic <a href="functionally_complete" title="wikilink">functionally complete</a>,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> meaning its logical operators can express (in combination) any conceivable three-valued logical function.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Aymara_language" title="wikilink">Aymara language</a> – a Bolivian language famous for using ternary rather than binary logic<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></li>
<li><a href="Binary_logic_(disambiguation)" title="wikilink">Binary logic (disambiguation)</a></li>
<li><a href="Boolean_algebra_(structure)" title="wikilink">Boolean algebra (structure)</a></li>
<li><a href="Boolean_function" title="wikilink">Boolean function</a></li>
<li><a href="Digital_circuit" title="wikilink">Digital circuit</a></li>
<li><a href="Four-valued_logic" title="wikilink">Four-valued logic</a></li>
<li><a class="uri" href="Setun" title="wikilink">Setun</a> - an experimental Russian computer which was based on ternary logic</li>
<li><a href="Ternary_numeral_system" title="wikilink">Ternary numeral system</a> (and <a href="Balanced_ternary" title="wikilink">Balanced ternary</a>)</li>
<li><a href="Three-state_logic" title="wikilink">Three-state logic</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>

<p>, chapters 5-9</p></li>
<li>Mundici, D. The C*-Algebras of Three-Valued Logic. Logic Colloquium ’88, Proceedings of the Colloquium held in Padova 61–77 (1989). </li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.wv.inf.tu-dresden.de/Teaching/SS-2011/mvl/mval.HANDOUT2.pdf">Introduction to Many-Valued Logics</a> by Bertram Fronhöfer. Handout from a Technische Universität Dresden 2011 summer class. (Despite the title, this is almost entirely about three-valued logics.)</li>
</ul>

<p>"</p>

<p><a href="Category:Many-valued_logic" title="wikilink">Category:Many-valued logic</a> <a href="Category:Ternary_computers" title="wikilink">Category:Ternary computers</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Douglas W. Jones, <a href="http://homepage.cs.uiowa.edu/~jones/ternary/logic.shtml">Standard Ternary Logic</a>, Feb. 11, 2013<a href="#fnref1">↩</a></li>
<li id="fn2"><a class="uri" href="http://www.uky.edu/~look/Phi520-Lecture7.pdf">http://www.uky.edu/~look/Phi520-Lecture7.pdf</a><a href="#fnref2">↩</a></li>
<li id="fn3">Grzegorz Malinowski, "Many-valued Logic and its Philosophy" in Dov M. Gabbay, John Woods (eds.) <em>Handbook of the History of Logic Volume 8. The Many Valued and Nonmonotonic Turn in Logic</em>, Elsevier, 2009<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">Ron van der Meyden, "[<a class="uri" href="http://books.google.com/books?id=gF0b85IuqQwC&amp;pg">http://books.google.com/books?id=gF0b85IuqQwC&amp;pg;</a>;=PA344 Logical approaches to incomplete information: a survey]" in Chomicki, Jan; Saake, Gunter (Eds.) <em>Logics for Databases and Information Systems</em>, Kluwer Academic Publishers ISBN 978-0-7923-8129-7, p. 344; <a href="http://www.cse.unsw.edu.au/~meyden/research/indef-review.ps">PS preprint</a> (note: page numbering differs in preprint from the published version)<a href="#fnref5">↩</a></li>
<li id="fn6">C. J. Date, <em>Relational database writings, 1991-1994</em>, Addison-Wesley, 1995, p. 371<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
