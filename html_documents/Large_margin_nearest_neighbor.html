<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="149">Large margin nearest neighbor</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Large margin nearest neighbor</h1>
<hr/>

<p><strong>Large margin nearest neighbor (LMNN)<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> classification</strong> is a statistical <a href="machine_learning" title="wikilink">machine learning</a> <a class="uri" href="algorithm" title="wikilink">algorithm</a>. It learns a <a class="uri" href="Pseudometric" title="wikilink">Pseudometric</a> designed for <a href="k-nearest_neighbor" title="wikilink">k-nearest neighbor</a> classification. The algorithm is based on <a href="semidefinite_programming" title="wikilink">semidefinite programming</a>, a sub-class of <a href="convex_optimization" title="wikilink">convex optimization</a>.</p>

<p>The goal of <a href="supervised_learning" title="wikilink">supervised learning</a> (more specifically classification) is to learn a decision rule that can categorize data instances into pre-defined classes. The <a href="k-nearest_neighbor" title="wikilink">k-nearest neighbor</a> rule assumes a <em>training</em> data set of labeled instances (i.e. the classes are known). It classifies a new data instance with the class obtained from the majority vote of the k closest (labeled) training instances. Closeness is measured with a pre-defined <a href="Metric_(mathematics)" title="wikilink">metric</a>. Large Margin Nearest Neighbors is an algorithm that learns this global (pseudo-)metric in a supervised fashion to improve the classification accuracy of the k-nearest neighbor rule.</p>
<h2 id="setup">Setup</h2>

<p>The main intuition behind LMNN is to learn a <a href="Pseudometric_space" title="wikilink">pseudometric</a> under which all data instances in the training set are surrounded by at least k instances that share the same class label. If this is achieved, the <a class="uri" href="leave-one-out" title="wikilink">leave-one-out</a> error (a special case of <a href="Cross-validation_(statistics)" title="wikilink">cross validation</a>) is minimized. Let the training data consist of a data set 

<math display="inline" id="Large_margin_nearest_neighbor:0">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mover accent="true">
       <mi>x</mi>
       <mo stretchy="false">‚Üí</mo>
      </mover>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mover accent="true">
       <mi>x</mi>
       <mo stretchy="false">‚Üí</mo>
      </mover>
      <mi>n</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>‚äÇ</mo>
   <mrow>
    <msup>
     <mi>R</mi>
     <mi>d</mi>
    </msup>
    <mo>√ó</mo>
    <mi>C</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>D</ci>
     <set>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-‚Üí</ci>
         <ci>x</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
      </interval>
      <ci>normal-‚Ä¶</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-‚Üí</ci>
         <ci>x</ci>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>n</ci>
       </apply>
      </interval>
     </set>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <ci>d</ci>
      </apply>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=\{(\vec{x}_{1},y_{1}),\dots,(\vec{x}_{n},y_{n})\}\subset R^{d}\times C
  </annotation>
 </semantics>
</math>

, where the set of possible class categories is 

<math display="inline" id="Large_margin_nearest_neighbor:1">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <mi>c</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <set>
     <cn type="integer">1</cn>
     <ci>normal-‚Ä¶</ci>
     <ci>c</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=\{1,\dots,c\}
  </annotation>
 </semantics>
</math>

.</p>

<p>The algorithm learns a <a href="Pseudometric_space" title="wikilink">pseudometric</a> of the type</p>

<p>

<math display="block" id="Large_margin_nearest_neighbor:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mover accent="true">
       <mi>x</mi>
       <mo stretchy="false">‚Üí</mo>
      </mover>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mover accent="true">
       <mi>x</mi>
       <mo stretchy="false">‚Üí</mo>
      </mover>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mover accent="true">
         <mi>x</mi>
         <mo stretchy="false">‚Üí</mo>
        </mover>
        <mi>i</mi>
       </msub>
       <mo>-</mo>
       <msub>
        <mover accent="true">
         <mi>x</mi>
         <mo stretchy="false">‚Üí</mo>
        </mover>
        <mi>j</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>‚ä§</mo>
    </msup>
    <mi>ùêå</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mover accent="true">
        <mi>x</mi>
        <mo stretchy="false">‚Üí</mo>
       </mover>
       <mi>i</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mover accent="true">
        <mi>x</mi>
        <mo stretchy="false">‚Üí</mo>
       </mover>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-‚Üí</ci>
        <ci>x</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-‚Üí</ci>
        <ci>x</ci>
       </apply>
       <ci>j</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-‚Üí</ci>
         <ci>x</ci>
        </apply>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-‚Üí</ci>
         <ci>x</ci>
        </apply>
        <ci>j</ci>
       </apply>
      </apply>
      <csymbol cd="latexml">top</csymbol>
     </apply>
     <ci>ùêå</ci>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-‚Üí</ci>
        <ci>x</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-‚Üí</ci>
        <ci>x</ci>
       </apply>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(\vec{x}_{i},\vec{x}_{j})=(\vec{x}_{i}-\vec{x}_{j})^{\top}\mathbf{M}(\vec{x}_%
{i}-\vec{x}_{j})
  </annotation>
 </semantics>
</math>

. For 

<math display="inline" id="Large_margin_nearest_neighbor:3">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>‚ãÖ</mo>
    <mo>,</mo>
    <mo>‚ãÖ</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <interval closure="open">
     <ci>normal-‚ãÖ</ci>
     <ci>normal-‚ãÖ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(\cdot,\cdot)
  </annotation>
 </semantics>
</math>

 to be well defined, the matrix 

<math display="inline" id="Large_margin_nearest_neighbor:4">
 <semantics>
  <mi>ùêå</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêå</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 needs to be <a href="positive_semi-definite" title="wikilink">positive semi-definite</a>. The Euclidean metric is a special case, where 

<math display="inline" id="Large_margin_nearest_neighbor:5">
 <semantics>
  <mi>ùêå</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêå</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 is the identity matrix. This generalization is often (falsely) referred to as <a href="Mahalanobis_metric" title="wikilink">Mahalanobis metric</a>.</p>

<p>Figure 1 illustrates the effect of the metric under varying 

<math display="inline" id="Large_margin_nearest_neighbor:6">
 <semantics>
  <mi>ùêå</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêå</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

. The two circles show the set of points with equal distance to the center 

<math display="inline" id="Large_margin_nearest_neighbor:7">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">‚Üí</mo>
   </mover>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>x</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{x}_{i}
  </annotation>
 </semantics>
</math>

. In the Euclidean case this set is a circle, whereas under the modified (Mahalanobis) metric it becomes an <a class="uri" href="ellipsoid" title="wikilink">ellipsoid</a>.</p>
<figure><b>(Figure)</b>
<figcaption>Figure 1: Schematic illustration of LMNN.</figcaption>
</figure>

<p>The algorithm distinguishes between two types of special data points: <em>target neighbors</em> and <em>impostors</em>.</p>
<h3 id="target-neighbors">Target Neighbors</h3>

<p>Target neighbors are selected before learning. Each instance 

<math display="inline" id="Large_margin_nearest_neighbor:8">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">‚Üí</mo>
   </mover>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>x</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{x}_{i}
  </annotation>
 </semantics>
</math>

 has exactly 

<math display="inline" id="Large_margin_nearest_neighbor:9">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 different target neighbors within 

<math display="inline" id="Large_margin_nearest_neighbor:10">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

, which all share the same class label 

<math display="inline" id="Large_margin_nearest_neighbor:11">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}
  </annotation>
 </semantics>
</math>

. The target neighbors are the data points that <em>should become</em> nearest neighbors <em>under the learned metric</em>. Let us denote the set of target neighbors for a data point 

<math display="inline" id="Large_margin_nearest_neighbor:12">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">‚Üí</mo>
   </mover>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>x</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{x}_{i}
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Large_margin_nearest_neighbor:13">
 <semantics>
  <msub>
   <mi>N</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>N</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{i}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="impostors">Impostors</h3>

<p>An impostor of a data point 

<math display="inline" id="Large_margin_nearest_neighbor:14">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">‚Üí</mo>
   </mover>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>x</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{x}_{i}
  </annotation>
 </semantics>
</math>

 is another data point 

<math display="inline" id="Large_margin_nearest_neighbor:15">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">‚Üí</mo>
   </mover>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>x</ci>
    </apply>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{x}_{j}
  </annotation>
 </semantics>
</math>

 with a different class label (i.e. 

<math display="inline" id="Large_margin_nearest_neighbor:16">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo>‚â†</mo>
   <msub>
    <mi>y</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}\neq y_{j}
  </annotation>
 </semantics>
</math>

) which is one of the nearest neighbors of 

<math display="inline" id="Large_margin_nearest_neighbor:17">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">‚Üí</mo>
   </mover>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>x</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{x}_{i}
  </annotation>
 </semantics>
</math>

. During learning the algorithm tries to minimize the number of impostors for all data instances in the training set.</p>
<h2 id="algorithm">Algorithm</h2>

<p>Large Margin Nearest Neighbors optimizes the matrix 

<math display="inline" id="Large_margin_nearest_neighbor:18">
 <semantics>
  <mi>ùêå</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêå</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 with the help of <a href="semidefinite_programming" title="wikilink">semidefinite programming</a>. The objective is twofold: For every data point 

<math display="inline" id="Large_margin_nearest_neighbor:19">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">‚Üí</mo>
   </mover>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>x</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{x}_{i}
  </annotation>
 </semantics>
</math>

, the <em>target neighbors</em> should be <em>close</em> and the <em>impostors</em> should be <em>far away</em>. Figure 1 shows the effect of such an optimization on an illustrative example. The learned metric causes the input vector 

<math display="inline" id="Large_margin_nearest_neighbor:20">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">‚Üí</mo>
   </mover>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>x</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{x}_{i}
  </annotation>
 </semantics>
</math>

 to be surrounded by training instances of the same class. If it was a test point, it would be classified correctly under the 

<math display="inline" id="Large_margin_nearest_neighbor:21">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=3
  </annotation>
 </semantics>
</math>

 nearest neighbor rule.</p>

<p>The first optimization goal is achieved by minimizing the average distance between instances and their target neighbors</p>

<p>

<math display="block" id="Large_margin_nearest_neighbor:22">
 <semantics>
  <mrow>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
    <mrow>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
     </mrow>
     <mo>‚àà</mo>
     <msub>
      <mi>N</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </munder>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mover accent="true">
       <mi>x</mi>
       <mo stretchy="false">‚Üí</mo>
      </mover>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mover accent="true">
       <mi>x</mi>
       <mo stretchy="false">‚Üí</mo>
      </mover>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <list>
       <ci>i</ci>
       <ci>j</ci>
      </list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-‚Üí</ci>
        <ci>x</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-‚Üí</ci>
        <ci>x</ci>
       </apply>
       <ci>j</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i,j\in N_{i}}d(\vec{x}_{i},\vec{x}_{j})
  </annotation>
 </semantics>
</math>

. The second goal is achieved by constraining impostors 

<math display="inline" id="Large_margin_nearest_neighbor:23">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">‚Üí</mo>
   </mover>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>x</ci>
    </apply>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{x}_{l}
  </annotation>
 </semantics>
</math>

 to be one unit further away than target neighbors 

<math display="inline" id="Large_margin_nearest_neighbor:24">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">‚Üí</mo>
   </mover>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>x</ci>
    </apply>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{x}_{j}
  </annotation>
 </semantics>
</math>

 (and therefore pushing them out of the local neighborhood of 

<math display="inline" id="Large_margin_nearest_neighbor:25">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">‚Üí</mo>
   </mover>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>x</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{x}_{i}
  </annotation>
 </semantics>
</math>

). The resulting inequality constraint can be stated as:</p>

<p>

<math display="block" id="Large_margin_nearest_neighbor:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo>‚àÄ</mo>
      <mrow>
       <mrow>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mi>j</mi>
        </mrow>
        <mo>‚àà</mo>
        <msub>
         <mi>N</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mrow>
         <mi>l</mi>
         <mo>,</mo>
         <msub>
          <mi>y</mi>
          <mi>l</mi>
         </msub>
        </mrow>
        <mo>‚â†</mo>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mrow>
     </msub>
     <mrow>
      <mi>d</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mover accent="true">
         <mi>x</mi>
         <mo stretchy="false">‚Üí</mo>
        </mover>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mover accent="true">
         <mi>x</mi>
         <mo stretchy="false">‚Üí</mo>
        </mover>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>‚â§</mo>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mover accent="true">
       <mi>x</mi>
       <mo stretchy="false">‚Üí</mo>
      </mover>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mover accent="true">
       <mi>x</mi>
       <mo stretchy="false">‚Üí</mo>
      </mover>
      <mi>l</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <in></in>
         <list>
          <ci>i</ci>
          <ci>j</ci>
         </list>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>N</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <neq></neq>
         <list>
          <ci>l</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>l</ci>
          </apply>
         </list>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-‚Üí</ci>
          <ci>x</ci>
         </apply>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-‚Üí</ci>
          <ci>x</ci>
         </apply>
         <ci>j</ci>
        </apply>
       </interval>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-‚Üí</ci>
        <ci>x</ci>
       </apply>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-‚Üí</ci>
        <ci>x</ci>
       </apply>
       <ci>l</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall_{i,j\in N_{i},l,y_{l}\neq y_{i}}d(\vec{x}_{i},\vec{x}_{j})+1\leq d(%
\vec{x}_{i},\vec{x}_{l})
  </annotation>
 </semantics>
</math>

 The margin of exactly one unit fixes the scale of the matrix 

<math display="inline" id="Large_margin_nearest_neighbor:27">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

. Any alternative choice 

<math display="inline" id="Large_margin_nearest_neighbor:28">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>c</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c>0
  </annotation>
 </semantics>
</math>

 would result in a rescaling of 

<math display="inline" id="Large_margin_nearest_neighbor:29">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 by a factor of 

<math display="inline" id="Large_margin_nearest_neighbor:30">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/c
  </annotation>
 </semantics>
</math>

.</p>

<p>The final optimization problem becomes:</p>

<p>

<math display="block" id="Large_margin_nearest_neighbor:31">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mi>min</mi>
     <mi>ùêå</mi>
    </munder>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mrow>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mi>j</mi>
       </mrow>
       <mo>‚àà</mo>
       <msub>
        <mi>N</mi>
        <mi>i</mi>
       </msub>
      </mrow>
     </munder>
     <mrow>
      <mi>d</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mover accent="true">
         <mi>x</mi>
         <mo stretchy="false">‚Üí</mo>
        </mover>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mover accent="true">
         <mi>x</mi>
         <mo stretchy="false">‚Üí</mo>
        </mover>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
      <mo>,</mo>
      <mi>l</mi>
     </mrow>
    </munder>
    <msub>
     <mi>Œæ</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
      <mi>l</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <ci>ùêå</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <list>
         <ci>i</ci>
         <ci>j</ci>
        </list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>N</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-‚Üí</ci>
          <ci>x</ci>
         </apply>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-‚Üí</ci>
          <ci>x</ci>
         </apply>
         <ci>j</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <list>
       <ci>i</ci>
       <ci>j</ci>
       <ci>l</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Œæ</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
       <ci>l</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min_{\mathbf{M}}\sum_{i,j\in N_{i}}d(\vec{x}_{i},\vec{x}_{j})+\sum_{i,j,l}\xi%
_{ijl}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Large_margin_nearest_neighbor:32">
 <semantics>
  <msub>
   <mo>‚àÄ</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
     </mrow>
     <mo>‚àà</mo>
     <msub>
      <mi>N</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mi>l</mi>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mi>l</mi>
      </msub>
     </mrow>
     <mo>‚â†</mo>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <list>
       <ci>i</ci>
       <ci>j</ci>
      </list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <neq></neq>
      <list>
       <ci>l</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>l</ci>
       </apply>
      </list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall_{i,j\in N_{i},l,y_{l}\neq y_{i}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Large_margin_nearest_neighbor:33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mover accent="true">
        <mi>x</mi>
        <mo stretchy="false">‚Üí</mo>
       </mover>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mover accent="true">
        <mi>x</mi>
        <mo stretchy="false">‚Üí</mo>
       </mover>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>‚â§</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mover accent="true">
        <mi>x</mi>
        <mo stretchy="false">‚Üí</mo>
       </mover>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mover accent="true">
        <mi>x</mi>
        <mo stretchy="false">‚Üí</mo>
       </mover>
       <mi>l</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>Œæ</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
      <mi>l</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>d</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-‚Üí</ci>
         <ci>x</ci>
        </apply>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-‚Üí</ci>
         <ci>x</ci>
        </apply>
        <ci>j</ci>
       </apply>
      </interval>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>d</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-‚Üí</ci>
         <ci>x</ci>
        </apply>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-‚Üí</ci>
         <ci>x</ci>
        </apply>
        <ci>l</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Œæ</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
       <ci>l</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(\vec{x}_{i},\vec{x}_{j})+1\leq d(\vec{x}_{i},\vec{x}_{l})+\xi_{ijl}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Large_margin_nearest_neighbor:34">
 <semantics>
  <mrow>
   <msub>
    <mi>Œæ</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
     <mi>l</mi>
    </mrow>
   </msub>
   <mo>‚â•</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Œæ</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
      <ci>l</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{ijl}\geq 0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Large_margin_nearest_neighbor:35">
 <semantics>
  <mrow>
   <mi>ùêå</mi>
   <mo>‚™∞</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">succeeds-or-equals</csymbol>
    <ci>ùêå</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}\succeq 0
  </annotation>
 </semantics>
</math>

</p>

<p>Here the <a href="slack_variable" title="wikilink">slack variables</a> 

<math display="inline" id="Large_margin_nearest_neighbor:36">
 <semantics>
  <msub>
   <mi>Œæ</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
    <mi>l</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Œæ</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{ijl}
  </annotation>
 </semantics>
</math>

 absorb the amount of violations of the impostor constraints. Their overall sum is minimized. The last constraint ensures that 

<math display="inline" id="Large_margin_nearest_neighbor:37">
 <semantics>
  <mi>ùêå</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùêå</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 is <a href="positive_semi-definite" title="wikilink">positive semi-definite</a>. The optimization problem is an instance of <a href="semidefinite_programming" title="wikilink">semidefinite programming</a> (SDP). Although SDPs tend to suffer from high computational complexity, this particular SDP instance can be solved very efficiently due to the underlying geometric properties of the problem. In particular, most impostor constraints are naturally satisfied and do not need to be enforced during runtime. A particularly well suited solver technique is the <a href="working_set" title="wikilink">working set</a> method, which keeps a small set of constraints that are actively enforced and monitors the remaining (likely satisfied) constraints only occasionally to ensure correctness.</p>
<h2 id="extensions-and-efficient-solvers">Extensions and efficient solvers</h2>

<p>LMNN was extended to multiple local metrics in the 2008 paper.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> This extension significantly improves the classification error, but involves a more expensive optimization problem. In their 2009 publication in the Journal of Machine Learning Research,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Weinberger and Saul derive an efficient solver for the semi-definite program. It can learn a metric for the <a href="http://yann.lecun.com/exdb/mnist/">MNIST handwritten digit data set</a> in several hours, involving billions of pairwise constraints. An <a href="open_source" title="wikilink">open source</a> <a class="uri" href="Matlab" title="wikilink">Matlab</a> implementation is freely available at the <a href="http://www.cse.wustl.edu/~kilian/code/code.html">authors web page</a>.</p>

<p>Kumal et al.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> extended the algorithm to incorporate local invariances to multivariate <a href="polynomial_transformations" title="wikilink">polynomial transformations</a> and improved regularization.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Similarity_learning" title="wikilink">Similarity learning</a></li>
<li><a href="Linear_discriminant_analysis" title="wikilink">Linear discriminant analysis</a></li>
<li><a href="Learning_Vector_Quantization" title="wikilink">Learning Vector Quantization</a></li>
<li><a class="uri" href="Pseudometric" title="wikilink">Pseudometric</a></li>
<li><a href="Nearest_neighbor_search" title="wikilink">Nearest neighbor search</a></li>
<li><a href="Cluster_analysis" title="wikilink">Cluster analysis</a></li>
<li><a href="Classification_(machine_learning)" title="wikilink">Data classification</a></li>
<li><a href="Data_mining" title="wikilink">Data mining</a></li>
<li><a href="Machine_learning" title="wikilink">Machine learning</a></li>
<li><a href="Pattern_recognition" title="wikilink">Pattern recognition</a></li>
<li><a href="Predictive_analytics" title="wikilink">Predictive analytics</a></li>
<li><a href="Dimension_reduction" title="wikilink">Dimension reduction</a></li>
<li><a href="Neighbourhood_components_analysis" title="wikilink">Neighbourhood components analysis</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cse.wustl.edu/~kilian/code/code.html">Matlab Implementation</a></li>
<li><a href="http://compscicenter.ru/sites/default/files/materials/2012_05_03_MachineLearning_lecture_09.pdf">ICML 2010 Tutorial on Metric Learning</a></li>
</ul>

<p>"</p>

<p><a href="Category:Classification_algorithms" title="wikilink">Category:Classification algorithms</a> <a href="Category:Machine_learning" title="wikilink">Category:Machine learning</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">‚Ü©</a></li>
<li id="fn2"><a href="#fnref2">‚Ü©</a></li>
<li id="fn3"><a href="#fnref3">‚Ü©</a></li>
<li id="fn4"><a href="#fnref4">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
