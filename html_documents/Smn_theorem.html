<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="541">Smn theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Smn theorem</h1>
<hr/>

<p><mtpl></mtpl> In <a href="recursion_theory" title="wikilink">computability theory</a> the <strong><em>s</em><sub><em>mn</em></sub> theorem</strong>, (also called the <strong>translation lemma</strong>, <strong>parameter theorem</strong>, or <strong>parameterization theorem</strong>) is a basic result about <a href="programming_language" title="wikilink">programming languages</a> (and, more generally, <a href="Gödel_numbering" title="wikilink">Gödel numberings</a> of the <a href="computable_function" title="wikilink">computable functions</a>) (Soare 1987, Rogers 1967). It was first proved by <a href="Stephen_Cole_Kleene" title="wikilink">Stephen Cole Kleene</a> (Kleene 1943).</p>

<p>In practical terms, the theorem says that for a given programming language and positive integers <em>m</em> and <em>n</em>, there is a particular <a class="uri" href="algorithm" title="wikilink">algorithm</a> that operates on the <a href="source_code" title="wikilink">source code</a> of programs with <em>m</em> + <em>n</em> <a href="free_variables" title="wikilink">free variables</a>. This algorithm produces source code that effectively substitutes <em>m</em> given values for the first <em>m</em> free variables in the program and leaves the rest free.</p>
<h2 id="details">Details</h2>

<p>The basic form of the theorem applies to functions of two arguments (Nies 2009, p. 6). Given a Gödel numbering 

<math display="inline" id="Smn_theorem:0">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 of recursive functions, there is a <a href="primitive_recursive_function" title="wikilink">primitive recursive function</a> <em>s</em> of two arguments with the following property: for every Gödel number <em>p</em> of a partial computable function <em>f</em> with two arguments, the expressions 

<math display="inline" id="Smn_theorem:1">
 <semantics>
  <mrow>
   <msub>
    <mi>φ</mi>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>p</mi>
      <mo>,</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>φ</ci>
     <apply>
      <times></times>
      <ci>s</ci>
      <interval closure="open">
       <ci>p</ci>
       <ci>x</ci>
      </interval>
     </apply>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{s(p,x)}(y)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Smn_theorem:2">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)
  </annotation>
 </semantics>
</math>

 are defined for the same combinations of natural numbers <em>x</em> and <em>y</em>, and their values are equal for any such combination. In other words, the following <a href="extensional_equality" title="wikilink">extensional equality</a> of functions holds for every <em>x</em>:</p>

<p>

<math display="block" id="Smn_theorem:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>φ</mi>
      <mrow>
       <mi>s</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>p</mi>
        <mo>,</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msub>
     <mo>≃</mo>
     <mrow>
      <mi>λ</mi>
      <mi>y</mi>
     </mrow>
    </mrow>
    <mo>.</mo>
    <mrow>
     <msub>
      <mi>φ</mi>
      <mi>p</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">similar-to-or-equals</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <apply>
       <times></times>
       <ci>s</ci>
       <interval closure="open">
        <ci>p</ci>
        <ci>x</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <ci>p</ci>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{s(p,x)}\simeq\lambda y.\varphi_{p}(x,y).\,
  </annotation>
 </semantics>
</math>

</p>

<p>More generally, for any <em>m</em>, <em>n</em> &gt; 0, there exists a primitive recursive function 

<math display="inline" id="Smn_theorem:4">
 <semantics>
  <msubsup>
   <mi>s</mi>
   <mi>n</mi>
   <mi>m</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>m</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{m}_{n}
  </annotation>
 </semantics>
</math>

 of <em>m</em> + 1 arguments that behaves as follows: for every Gödel number <em>p</em> of a partial computable function with <em>m</em> + <em>n</em> arguments, and all values of <em>x</em><sub>1</sub>,…,<em>x</em><sub><em>m</em></sub>:</p>

<p>

<math display="block" id="Smn_theorem:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>φ</mi>
      <mrow>
       <msubsup>
        <mi>s</mi>
        <mi>n</mi>
        <mi>m</mi>
       </msubsup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>p</mi>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mi>m</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msub>
     <mo>≃</mo>
     <mrow>
      <mrow>
       <mi>λ</mi>
       <msub>
        <mi>y</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </mrow>
    <mo>.</mo>
    <mrow>
     <msub>
      <mi>φ</mi>
      <mi>p</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>m</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">similar-to-or-equals</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>s</ci>
         <ci>m</ci>
        </apply>
        <ci>n</ci>
       </apply>
       <vector>
        <ci>p</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>m</ci>
        </apply>
       </vector>
      </apply>
     </apply>
     <list>
      <apply>
       <times></times>
       <ci>λ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>φ</ci>
      <ci>p</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{s^{m}_{n}(p,x_{1},\dots,x_{m})}\simeq\lambda y_{1},\dots,y_{n}.%
\varphi_{p}(x_{1},\dots,x_{m},y_{1},\dots,y_{n}).\,
  </annotation>
 </semantics>
</math>

</p>

<p>The function <em>s</em> described above can be taken to be 

<math display="inline" id="Smn_theorem:6">
 <semantics>
  <msubsup>
   <mi>s</mi>
   <mn>1</mn>
   <mn>1</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{1}_{1}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="example">Example</h2>

<p>The following <a href="Lisp_programming_language" title="wikilink">Lisp</a> code implements s<sub>11</sub> for Lisp.</p>
<pre class="lisp"><code> (defun s11 (f x)
   (let ((y (gensym)))
     (list 'lambda (list y) (list f x y))))</code></pre>

<p>For example,  evaluates to .</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Currying" title="wikilink">Currying</a></li>
<li><a href="Kleene's_recursion_theorem" title="wikilink">Kleene's recursion theorem</a></li>
<li><a href="Partial_evaluation" title="wikilink">Partial evaluation</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>

<p>(This is the reference that the 1989 edition of Odifreddi's "Classical Recursion Theory" gives on p.131 for the s<sub>mn</sub> theorem.)</p></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a> <a href="Category:Theorems_in_theory_of_computation" title="wikilink">Category:Theorems in theory of computation</a></p>
</body>
</html>
