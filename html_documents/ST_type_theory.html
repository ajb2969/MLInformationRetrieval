<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1284">ST type theory</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>ST type theory</h1>
<hr/>

<p>The following system is Mendelson's (1997, 289–293) <strong>ST</strong> <a href="type_theory" title="wikilink">type theory</a>. ST is equivalent with Russell's ramified theory plus the <a href="Axiom_of_reducibility" title="wikilink">Axiom of reducibility</a>. The <a href="domain_of_discourse" title="wikilink">domain of quantification</a> is partitioned into an ascending hierarchy of types, with all <a href="individual" title="wikilink">individuals</a> assigned a type. Quantified variables range over only one type; hence the underlying logic is <a href="first-order_logic" title="wikilink">first-order logic</a>. <strong>ST</strong> is "simple" (relative to the type theory of <em><a href="Principia_Mathematica" title="wikilink">Principia Mathematica</a></em>) primarily because all members of the <a href="relation_(mathematics)" title="wikilink">domain</a> and <a href="relation_(mathematics)" title="wikilink">codomain</a> of any <a href="relation_(mathematics)" title="wikilink">relation</a> must be of the same type. There is a lowest type, whose individuals have no members and are members of the second lowest type. Individuals of the lowest type correspond to the <a href="urelement" title="wikilink">urelements</a> of certain set theories. Each type has a next higher type, analogous to the notion of <a href="successor_function" title="wikilink">successor</a> in <a href="Peano_arithmetic" title="wikilink">Peano arithmetic</a>. While <strong>ST</strong> is silent as to whether there is a maximal type, a <a href="transfinite_number" title="wikilink">transfinite number</a> of types poses no difficulty. These facts, reminiscent of the Peano axioms, make it convenient and conventional to assign a <a href="natural_number" title="wikilink">natural number</a> to each type, starting with 0 for the lowest type. But type theory does not require a prior definition of the naturals.</p>

<p>The symbols peculiar to <strong>ST</strong> are primed variables and infix 

<math display="inline" id="ST_type_theory:0">
 <semantics>
  <mo>∈</mo>
  <annotation-xml encoding="MathML-Content">
   <in></in>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in
  </annotation>
 </semantics>
</math>

. In any given formula, unprimed variables all have the same type, while primed variables (

<math display="inline" id="ST_type_theory:1">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
 </semantics>
</math>

) range over the next higher type. The <a href="atomic_formula" title="wikilink">atomic formulas</a> of <strong>ST</strong> are of two forms, 

<math display="inline" id="ST_type_theory:2">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=y
  </annotation>
 </semantics>
</math>

 (<a href="identity_(mathematics)" title="wikilink">identity</a>) and 

<math display="inline" id="ST_type_theory:3">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>∈</mo>
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in x^{\prime}
  </annotation>
 </semantics>
</math>

. The <a class="uri" href="infix" title="wikilink">infix</a> symbol 

<math display="inline" id="ST_type_theory:4">
 <semantics>
  <mo>∈</mo>
  <annotation-xml encoding="MathML-Content">
   <in></in>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in
  </annotation>
 </semantics>
</math>

 suggests the intended <a href="model_theory" title="wikilink">interpretation</a>, set membership.</p>

<p>All variables appearing in the definition of identity and in the axioms <em>Extensionality</em> and <em>Comprehension</em>, range over individuals of one of two consecutive types. Only unprimed variables (ranging over the "lower" type) can appear to the left of '

<math display="inline" id="ST_type_theory:5">
 <semantics>
  <mo>∈</mo>
  <annotation-xml encoding="MathML-Content">
   <in></in>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in
  </annotation>
 </semantics>
</math>

', whereas to its right, only primed variables (ranging over the "higher" type) can appear. The first-order formulation of <strong>ST</strong> rules out quantifying over types. Hence each pair of consecutive types requires its own axiom of Extensionality and of Comprehension, which is possible if <em>Extensionality</em> and <em>Comprehension</em> below are taken as <a href="axiom_scheme" title="wikilink">axiom schemata</a> "ranging over" types.</p>
<ul>
<li><strong>Identity</strong>, defined by 

<math display="inline" id="ST_type_theory:6">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>y</mi>
   <mo>↔</mo>
   <mo>∀</mo>
   <msup>
    <mi>z</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <msup>
     <mi>z</mi>
     <mo>′</mo>
    </msup>
    <mo>↔</mo>
    <mi>y</mi>
    <mo>∈</mo>
    <msup>
     <mi>z</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-↔</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>z</ci>
     <ci>normal-′</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-↔</ci>
     <csymbol cd="unknown">y</csymbol>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=y\leftrightarrow\forall z^{\prime}[x\in z^{\prime}\leftrightarrow y\in z^{%
\prime}]
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li><strong><a href="Axiom_of_extensionality" title="wikilink">Extensionality</a></strong>. An <a href="axiom_schema" title="wikilink">axiom schema</a>. 

<math display="inline" id="ST_type_theory:7">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <msup>
     <mi>y</mi>
     <mo>′</mo>
    </msup>
    <mo>↔</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <msup>
     <mi>z</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msup>
     <mi>y</mi>
     <mo>′</mo>
    </msup>
    <mo>=</mo>
    <msup>
     <mi>z</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-↔</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-′</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x[x\in y^{\prime}\leftrightarrow x\in z^{\prime}]\rightarrow[y^{\prime%
}=z^{\prime}]
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>Let 

<math display="inline" id="ST_type_theory:8">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Φ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(x)
  </annotation>
 </semantics>
</math>

 denote any <a href="first-order_logic" title="wikilink">first-order formula</a> containing the <a href="free_variable" title="wikilink">free variable</a> 

<math display="inline" id="ST_type_theory:9">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

.</p>
<ul>
<li><strong>Comprehension</strong>. An <a href="axiom_schema" title="wikilink">axiom schema</a>. 

<math display="inline" id="ST_type_theory:10">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <msup>
    <mi>z</mi>
    <mo>′</mo>
   </msup>
   <mo>∀</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <msup>
     <mi>z</mi>
     <mo>′</mo>
    </msup>
    <mo>↔</mo>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <exists></exists>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>z</ci>
     <ci>normal-′</ci>
    </apply>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-↔</ci>
     <csymbol cd="unknown">Φ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists z^{\prime}\forall x[x\in z^{\prime}\leftrightarrow\Phi(x)]
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<dl>
<dd><em>Remark</em>. Any collection of elements of the same type may form an object of the next higher type. Comprehension is schematic with respect to 

<math display="inline" id="ST_type_theory:11">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Φ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(x)
  </annotation>
 </semantics>
</math>

 as well as to types.
</dd>
</dl>
<ul>
<li><strong><a href="Axiom_of_infinity" title="wikilink">Infinity</a></strong>. There exists a nonempty <a href="binary_relation" title="wikilink">binary relation</a> 

<math display="inline" id="ST_type_theory:12">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 over the individuals of the lowest type, that is <a href="Reflexive_relation" title="wikilink">irreflexive</a>, <a href="transitive_relation" title="wikilink">transitive</a>, and strongly connected

<math display="block" id="ST_type_theory:13">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>≠</mo>
    <mi>y</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>x</mi>
     <mi>R</mi>
     <mi>y</mi>
     <mo>∨</mo>
     <mi>y</mi>
     <mi>R</mi>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">y</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <neq></neq>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="unknown">R</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <or></or>
      <csymbol cd="unknown">y</csymbol>
      <csymbol cd="unknown">R</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x,y[x\neq y\rightarrow[xRy\vee yRx]]
  </annotation>
 </semantics>
</math>

 and with codomain contained in domain.</li>
</ul>
<dl>
<dd><em>Remark</em>. Infinity is the only true axiom of <strong>ST</strong> and is entirely mathematical in nature. It asserts that 

<math display="inline" id="ST_type_theory:14">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is a strict <a href="total_order" title="wikilink">total order</a>, with a <a href="relation_(mathematics)" title="wikilink">codomain</a> contained in its <a href="relation_(mathematics)" title="wikilink">domain</a>. If 0 is assigned to the lowest type, the type of 

<math display="inline" id="ST_type_theory:15">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is 3. Infinity can be satisfied only if the (co)domain of 

<math display="inline" id="ST_type_theory:16">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is <a href="Infinity" title="wikilink">infinite</a>, thus forcing the existence of an infinite set. If relations are defined in terms of <a href="ordered_pair" title="wikilink">ordered pairs</a>, this axiom requires a prior definition of ordered pair; the Kuratowski definition, adapted to <strong>ST</strong>, will do. The literature does not explain why the usual <a href="axiom_of_infinity" title="wikilink">axiom of infinity</a> (there exists an <a href="inductive_set_(axiom_of_infinity)" title="wikilink">inductive set</a>) of <a class="uri" href="ZFC" title="wikilink">ZFC</a> of other set theories could not be married to <strong>ST</strong>.
</dd>
</dl>

<p><strong>ST</strong> reveals how type theory can be made very similar to <a href="axiomatic_set_theory" title="wikilink">axiomatic set theory</a>. Moreover, the more elaborate <a href="Ontology_(information_science)" title="wikilink">ontology</a> of <strong>ST</strong>, grounded in what is now called the "iterative conception of set," makes for axiom (schemata) that are far simpler than those of conventional set theories, such as <a class="uri" href="ZFC" title="wikilink">ZFC</a>, with simpler ontologies. Set theories whose point of departure is type theory, but whose axioms, <a href="Ontology_(information_science)" title="wikilink">ontology</a>, and terminology differ from the above, include <a href="New_Foundations" title="wikilink">New Foundations</a> and <a href="Scott–Potter_set_theory" title="wikilink">Scott–Potter set theory</a>.</p>
<h2 id="formulations-based-on-equality">Formulations based on equality</h2>

<p>Church's type theory has been extensively studied by two of Church's students, <a href="Leon_Henkin" title="wikilink">Leon Henkin</a> and <a href="Peter_B._Andrews_(mathematician)" title="wikilink">Peter B. Andrews</a>. Since <strong>ST</strong> is a <a href="higher_order_logic" title="wikilink">higher order logic</a>, and in higher order logics one can define propositional connectives in terms of <a href="logical_equivalence" title="wikilink">logical equivalence</a> and quantifiers, in 1963 Henkin developed a formulation of <strong>ST</strong> based on equality, but in which he restricted attention to propositional types. This was simplified later that year by Andrews in his <a href="Q_zero" title="wikilink">theory <strong>Q<sub>0</sub></strong></a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> In this respect <strong>ST</strong> can be seen as a particular kind of a higher-order logic, classified by <a href="P.T._Johnstone" title="wikilink">P.T. Johnstone</a> in <em>Sketches of an Elephant</em>, as having a <a class="uri" href="lambda-signature" title="wikilink">lambda-signature</a>, that is a higher-order <a href="signature_(logic)" title="wikilink">signature</a> that contains no relations, and uses only products and arrows (function types) as <a href="type_constructors" title="wikilink">type constructors</a>. Furthermore, as Johnstone put it, <strong>ST</strong> is "logic-free" in the sense that it contains no logical connectives or quantifiers in its formulae.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="type_theory" title="wikilink">type theory</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Mendelson, Elliot, 1997. <em>Introduction to Mathematical Logic</em>, 4th ed. Chapman &amp; Hall.</li>
<li>W. Farmer, <em>The seven virtues of simple type theory</em>, Journal of Applied Logic, Vol. 6, No. 3. (September 2008), pp. 267–286.</li>
</ul>

<p>"</p>

<p><a href="Category:Type_theory" title="wikilink">Category:Type theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Stanford_Encyclopedia_of_Philosophy" title="wikilink">Stanford Encyclopedia of Philosophy</a>: <a href="http://plato.stanford.edu/entries/type-theory-church/">Church's Type Theory</a>" – by Peter Andrews (adapted from his book).<a href="#fnref1">↩</a></li>
<li id="fn2">P.T. Johnstone, <em>Sketches of an elephant</em>, p. 952<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
