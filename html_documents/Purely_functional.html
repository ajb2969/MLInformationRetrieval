<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1096">Purely functional</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Purely functional</h1>
<hr/>

<p>In <a class="uri" href="computing" title="wikilink">computing</a>, <a href="algorithm" title="wikilink">algorithms</a>, <a href="data_structure" title="wikilink">data structures</a>, or <a href="programming_language" title="wikilink">programming languages</a> are called <strong>purely functional</strong> if they guarantee the (weak) equivalence of <a href="Evaluation_strategy#Call_by_name" title="wikilink">call-by-name</a>, <a href="Evaluation_strategy#Call_by_value" title="wikilink">call-by-value</a> and <a href="Evaluation_strategy#Call_by_need" title="wikilink">call-by-need</a> evaluation strategies, often by excluding <em>destructive modifications</em> (updates) of entities in the program's <a href="running_environment" title="wikilink">running environment</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> According to this restriction, <a href="Variable_(programming)" title="wikilink">variables</a> are used in a mathematical sense, with identifiers referring to <a class="uri" href="immutable" title="wikilink">immutable</a>, persistent values.</p>

<p>To represent computations that perform side-effects in a purely functional programming language, one can use <a href="Monad_(functional_programming)" title="wikilink">Monads</a>, as proposed by <a href="Philip_Wadler" title="wikilink">Philip Wadler</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p><a href="Haskell_(programming_language)" title="wikilink">Haskell</a> is the most common modern example of a pure <a href="functional_programming" title="wikilink">functional programming language</a>.</p>

<p>Purely functional <a href="data_structure" title="wikilink">data structures</a> are often represented in a different way than their <a href="imperative_programming" title="wikilink">imperative</a> counterparts.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="benefits-and-applications">Benefits and applications</h2>

<p>The persistence property of purely functional data structures can be advantageous in the development of many applications that deal with multiple versions of an object.</p>

<p>For example, consider a comprehensive web-based thesaurus service that uses a large <a href="red-black_tree" title="wikilink">red-black tree</a> to store its list of synonym relationships, and that allows each user to add their own custom words to their personal thesaurus. One way to do this is to make a copy of the tree for each user, and then add their custom words to it; however, this duplication is wasteful, both of space and of time.</p>

<p>A better approach is to store the words in an immutable (and therefore purely functional) red-black tree. Then, one can simply take the original version and produce a new tree based on it for each set of custom words. Because these new trees share large amounts of structure with the main tree, the space overhead for each additional user is at most 

<math display="inline" id="Purely_functional:0">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>k</mi>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>k</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2k\log_{2}n
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Purely_functional:1">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is the number of custom nodes. With a single mutable red-black tree, this approach would not work, since changes to the main tree would affect all users.</p>

<p>Besides their efficiency benefits, the inherent <a href="Referential_transparency_(computer_science)" title="wikilink">referential transparency</a> of functional data structures tends to make purely functional computation more amenable to analysis and optimization, both formal and informal.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Pure_function" title="wikilink">Pure function</a></li>
<li><a href="Persistent_data_structure" title="wikilink">Persistent data structure</a></li>
<li><a class="uri" href="VList" title="wikilink">VList</a></li>
<li><a href="Identity_(object-oriented_programming)" title="wikilink">Identity (object-oriented programming)</a></li>
<li><a href="List_of_programming_languages_by_category#Pure" title="wikilink">List of Pure Functional Programming Languages</a></li>
</ul>
<h2 id="bibliography">Bibliography</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf">Purely Functional Data Structures</a> thesis by Chris Okasaki (PDF format)</li>
<li><a href="http://www.cs.cmu.edu/~sleator/papers/making-data-structures-persistent.pdf">Making Data-Structures Persistent</a> by James R. Driscoll, Neil Sarnak, Daniel D. Sleator, Robert E. Tarjan (PDF)</li>
<li><a href="http://www.cs.cmu.edu/~sleator/papers/fully-persistent-lists.pdf">Fully Persistent Lists with Catenation</a> by James R. Driscoll, Daniel D. Sleator, Robert E. Tarjan (PDF)</li>
<li><a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-854j-advanced-algorithms-fall-2005/lecture-notes/persistent.pdf">Persistent Data Structures</a> from MIT open course <a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-854j-advanced-algorithms-fall-2005">Advanced Algorithms</a></li>
</ul>

<p>"</p>

<p><a href="Category:Functional_programming" title="wikilink">Category:Functional programming</a> <a href="Category:Functional_data_structures" title="wikilink"> </a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">[<a class="uri" href="http://journals.cambridge.org/action/displayAbstract?fromPage=online&amp;aid">http://journals.cambridge.org/action/displayAbstract?fromPage=online&amp;aid;</a>;=4439732 <em>Comprehending Monads</em>] by <a href="Philip_Wadler" title="wikilink">Philip Wadler</a>, <a href="Cambridge_University_Press" title="wikilink">Cambridge University Press</a>, Mathematical Structures in Computer Science / Volume 2 / Issue 04 / December 1992, pp 461-493<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://www.cambridge.org/us/academic/subjects/computer-science/algorithmics-complexity-computer-algebra-and-computational-g/purely-functional-data-structures"><em>Purely functional data structures</em></a> by <a href="Chris_Okasaki" title="wikilink">Chris Okasaki</a>, <a href="Cambridge_University_Press" title="wikilink">Cambridge University Press</a>, 1998, ISBN 0-521-66350-4<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
