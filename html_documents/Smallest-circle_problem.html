<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="285">Smallest-circle problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Smallest-circle problem</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Smallest circle problem.svg</figcaption>
</figure>

<p>The <strong>smallest-circle problem</strong> or <strong>minimum covering circle problem</strong> is a <a href="mathematical_problem" title="wikilink">mathematical problem</a> of computing the smallest <a class="uri" href="circle" title="wikilink">circle</a> that contains all of a given <a href="set_(mathematics)" title="wikilink">set</a> of <a href="point_(geometry)" title="wikilink">points</a> in the <a href="Euclidean_plane" title="wikilink">Euclidean plane</a>. The corresponding problem in <a href="n-dimensional_space" title="wikilink"><em>n</em>-dimensional space</a>, the smallest <a href="bounding_sphere" title="wikilink">bounding-sphere</a> problem, is to compute the smallest <a href="n-sphere" title="wikilink"><em>n</em>-sphere</a> that contains all of a given set of points.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The smallest-circle problem was initially proposed by the English mathematician <a href="James_Joseph_Sylvester" title="wikilink">James Joseph Sylvester</a> in 1857.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>The smallest-circle problem in <a href="the_plane" title="wikilink">the plane</a> is an example of a <a href="facility_location" title="wikilink">facility location</a> problem (the <a href="1-center_problem" title="wikilink">1-center problem</a>) in which the location of a new facility must be chosen to provide service to a number of customers, minimizing the farthest distance that any customer must travel to reach the new facility.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Both the smallest circle problem in the plane, and the smallest bounding sphere problem in any higher-dimensional space of bounded dimension, may be solved in <a href="linear_time" title="wikilink">linear time</a>.</p>
<h2 id="characterization">Characterization</h2>

<p>Most of the geometric approaches for the problem look for points that lie on the boundary of the minimum circle and are based on the following simple facts:</p>
<ul>
<li>The minimum covering circle is unique.</li>
<li>The minimum covering circle of a set <em>S</em> can be determined by at most three points in <em>S</em> which lie on the boundary of the circle. If it is determined by only two points, then the line segment joining those two points must be a diameter of the minimum circle. If it is determined by three points, then the triangle consisting of those three points is not obtuse.</li>
</ul>
<h2 id="linear-time-solutions">Linear-time solutions</h2>

<p>As <a href="Nimrod_Megiddo" title="wikilink">Nimrod Megiddo</a> showed,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> the minimum enclosing circle can be found in linear time, and the same linear time bound also applies to the <a href="smallest_enclosing_sphere" title="wikilink">smallest enclosing sphere</a> in Euclidean spaces of any constant dimension.</p>

<p><a href="Emo_Welzl" title="wikilink">Emo Welzl</a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> proposed a simple randomized algorithm for the minimum covering circle problem that runs in expected 

<math display="inline" id="Smallest-circle_problem:0">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(N)
  </annotation>
 </semantics>
</math>

 time, based on a <a href="linear_programming" title="wikilink">linear programming</a> algorithm of <a href="Raimund_Seidel" title="wikilink">Raimund Seidel</a>. The algorithm is <a href="recursive_algorithm" title="wikilink">recursive</a>, and takes as arguments two sets of points <em>S</em> and <em>Q</em>; it computes the smallest enclosing circle of the union of <em>S</em> and <em>Q</em>, as long as every point of <em>Q</em> is one of the boundary points of the eventual smallest enclosing circle. Thus, the original smallest enclosing circle problem can be solved by calling the algorithm with <em>S</em> equal to the set of points to be enclosed and <em>Q</em> equal to the <a href="empty_set" title="wikilink">empty set</a>; as the algorithm calls itself recursively, it will enlarge the set <em>Q</em> passed into the recursive calls until it includes all the boundary points of the circle.</p>

<p>The algorithm processes the points of <em>S</em> in a random order, maintaining as it does the set <em>P</em> of processed points and the smallest circle that encloses the union of <em>P</em> and <em>Q</em>. At each step, it tests whether the next point <em>r</em> to be processed belongs to this circle; if it does not, the algorithm replaces the enclosing circle by the result of a recursive call of the algorithm on the sets <em>P</em> and <em>Q</em>+<em>r</em>. Whether the circle was replaced or not, <em>r</em> is then included in the set <em>P</em>. Processing each point, therefore, consists of testing in constant time whether the point belongs to a single circle and possibly performing a recursive call to the algorithm. It can be shown that the <em>i</em>th point to be processed has probability 

<math display="inline" id="Smallest-circle_problem:1">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>i</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1/i)
  </annotation>
 </semantics>
</math>

 of generating a recursive call, and therefore that the overall time is linear.</p>

<p>Subsequently, the smallest-circle problem was included in a general class of <a href="LP-type_problem" title="wikilink">LP-type problems</a> that can be solved by algorithms like Welzl's based on linear programming. As a consequence of membership in this class, it was shown that the dependence on the dimension of the constant factor in the 

<math display="inline" id="Smallest-circle_problem:2">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(N)
  </annotation>
 </semantics>
</math>


 time bound, which was factorial for Seidel's method, could be reduced to subexponential, while still maintaining only linear dependence on <em>N</em>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="other-algorithms">Other algorithms</h2>

<p>Prior to Megiddo's result showing that the smallest-circle problem may be solved in linear time, several algorithms of higher complexity appeared in the literature. A naive algorithm solves the problem in time O(<em>n</em><sup>4</sup>) by testing the circles determined by all pairs and triples of points.</p>
<ul>
<li>An algorithm of Chrystal and Peirce applies a <a href="Local_search_(optimization)" title="wikilink">local optimization</a> strategy that maintains two points on the boundary of an enclosing circle and repeatedly shrinks the circle, replacing the pair of boundary points, until an optimal circle is found. Chakraborty and Chaudhuri<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> propose a linear-time method for selecting a suitable initial circle and a pair of boundary points on that circle. Each step of the algorithm includes as one of the two boundary points a new vertex of the <a href="convex_hull" title="wikilink">convex hull</a>, so if the hull has <em>h</em> vertices this method can be implemented to run in time O(<em>nh</em>).</li>
<li>Elzinga and Hearn<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> described an algorithm which maintains a covering circle for a subset of the points. At each step, a point not covered by the current sphere is used to find a larger sphere that covers a new subset of points, including the point found. Although its worst case running time is O(<em>h</em><sup>3</sup><em>n</em>), the authors report that it ran in linear time in their experiments. The complexity of the method has been analyzed by Drezner and Shelah.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Both Fortran and C codes are available from .<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></li>
<li>The smallest sphere problem can be formulated as a <a href="quadratic_program" title="wikilink">quadratic program</a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> defined by a system of linear constraints with a convex quadratic objective function. Therefore, any feasible direction algorithm can give the solution of the problem.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Hearn and Vijay<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> proved that the feasible direction approach chosen by Jacobsen is equivalent to the Chrystal–Peirce algorithm.</li>
<li>The dual to this quadratic program may also be formulated explicitly;<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> an algorithm of Lawson<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> can be described in this way as a primal dual algorithm.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></li>
<li>Shamos and Hoey<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> proposed an O(<em>n</em> log <em>n</em>) time algorithm for the problem based on the observation that the center of the smallest enclosing circle must be a vertex of the farthest-point <a href="Voronoi_diagram" title="wikilink">Voronoi diagram</a> of the input point set.</li>
</ul>
<h2 id="weighted-variants-of-the-problem">Weighted variants of the problem</h2>

<p>The weighted version of the minimum covering circle problem takes as input a set of points in a Euclidean space, each with weights; the goal is to find a single point that minimizes the maximum weighted distance to any point. The original minimum covering circle problem can be recovered by setting all weights to the same number. As with the unweighted problem, the weighted problem may be solved in linear time in any space of bounded dimension, using approaches closely related to bounded dimension linear programming algorithms, although slower algorithms are again frequent in the literature.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Bounding_sphere" title="wikilink">Bounding sphere</a></li>
<li><a href="Closest_string" title="wikilink">Closest string</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.inf.ethz.ch/personal/gaertner/miniball.html">Bernd Gärtner's smallest enclosing ball code</a></li>
<li><a href="http://www.cgal.org/Manual/latest/doc_html/cgal_manual/Bounding_volumes/Chapter_main.html">CGAL</a> the <em>Min_sphere_of_spheres</em> package of the <em>Computational Geometry Algorithms Library</em> (CGAL)</li>
<li><a href="http://github.com/hbf/miniball">Miniball</a> an open-source implementation of an algorithm for the smallest enclosing ball problem for low and moderately high dimensions</li>
</ul>

<p>"</p>

<p><a href="Category:Computational_geometry" title="wikilink">Category:Computational geometry</a> <a href="Category:Combinatorial_optimization" title="wikilink">Category:Combinatorial optimization</a> <a class="uri" href="Category:Circles" title="wikilink">Category:Circles</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4">.<a href="#fnref4">↩</a></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6">.<a href="#fnref6">↩</a></li>
<li id="fn7">.<a href="#fnref7">↩</a></li>
<li id="fn8">.<a href="#fnref8">↩</a></li>
<li id="fn9">.<a href="#fnref9">↩</a></li>
<li id="fn10">.<a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12">.<a href="#fnref12">↩</a></li>
<li id="fn13">.<a href="#fnref13">↩</a></li>
<li id="fn14">.<a href="#fnref14">↩</a></li>
<li id="fn15">.<a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17">.<a href="#fnref17">↩</a></li>
<li id="fn18"></li>
<li id="fn19">.<a href="#fnref19">↩</a></li>
<li id="fn20">.<a href="#fnref20">↩</a></li>
</ol>
</section>
</body>
</html>
