<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1620">List comprehension</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>List comprehension</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>A <strong>list comprehension</strong> is a <a href="Syntax_of_programming_languages" title="wikilink">syntactic</a> construct available in some <a href="programming_language" title="wikilink">programming languages</a> for creating a list based on existing <a href="list_(computing)" title="wikilink">lists</a>. It follows the form of the mathematical <em><a href="set-builder_notation" title="wikilink">set-builder notation</a></em> (<em>set comprehension</em>) as distinct from the use of <a href="Map_(higher-order_function)" title="wikilink">map</a> and <a href="Filter_(higher-order_function)" title="wikilink">filter</a> functions.</p>
<h2 id="overview">Overview</h2>

<p>Consider the following example in <a href="set-builder_notation" title="wikilink">set-builder notation</a>.</p>

<p>

<math display="block" id="List_comprehension:0">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mo>⋅</mo>
      <mi>x</mi>
     </mrow>
     <mrow>
      <mo fence="true">∣</mo>
      <mrow>
       <mi>x</mi>
       <mo>∈</mo>
       <mrow>
        <mi>ℕ</mi>
        <mo rspace="7.5pt">,</mo>
        <msup>
         <mi>x</mi>
         <mn>2</mn>
        </msup>
       </mrow>
      </mrow>
      <mo>></mo>
     </mrow>
     <mpadded width="+1.7pt">
      <mn>3</mn>
     </mpadded>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <set>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="float">2</cn>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <apply>
        <in></in>
        <ci>x</ci>
        <list>
         <ci>ℕ</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <cn type="integer">2</cn>
         </apply>
        </list>
       </apply>
      </apply>
      <cn type="integer">3</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\{\,2\cdot x\mid x\in\mathbb{N},\ x^{2}>3\,\}
  </annotation>
 </semantics>
</math>

</p>

<p>This can be read, "

<math display="inline" id="List_comprehension:1">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is the set of all numbers "2 times 

<math display="inline" id="List_comprehension:2">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

" where 

<math display="inline" id="List_comprehension:3">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is an item in the set of <a href="natural_number" title="wikilink">natural numbers</a> (

<math display="inline" id="List_comprehension:4">
 <semantics>
  <mi>ℕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{N}
  </annotation>
 </semantics>
</math>

), for which 

<math display="inline" id="List_comprehension:5">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 squared is greater than 

<math display="inline" id="List_comprehension:6">
 <semantics>
  <mn>3</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">3</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3
  </annotation>
 </semantics>
</math>

."</p>

<p>In this annotated version of the example:</p>

<p>

<math display="block" id="List_comprehension:7">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo rspace="4.2pt" stretchy="false">{</mo>
    <munder>
     <munder accentunder="true">
      <mrow>
       <mn>2</mn>
       <mo movablelimits="false">⋅</mo>
       <mi>x</mi>
      </mrow>
      <mo movablelimits="false">⏟</mo>
     </munder>
     <mrow>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\color</mtext>
      </merror>
      <mi>V</mi>
      <mi>i</mi>
      <mi>o</mi>
      <mi>l</mi>
      <mi>e</mi>
      <mi>t</mi>
      <mtext>output expression</mtext>
     </mrow>
    </munder>
    <mo>∣</mo>
    <mrow>
     <munder>
      <munder accentunder="true">
       <mi>x</mi>
       <mo movablelimits="false">⏟</mo>
      </munder>
      <mrow>
       <merror class="ltx_ERROR undefined undefined">
        <mtext>\color</mtext>
       </merror>
       <mi>V</mi>
       <mi>i</mi>
       <mi>o</mi>
       <mi>l</mi>
       <mi>e</mi>
       <mi>t</mi>
       <mtext>variable</mtext>
      </mrow>
     </munder>
     <mo>∈</mo>
     <mrow>
      <munder>
       <munder accentunder="true">
        <mi>ℕ</mi>
        <mo movablelimits="false">⏟</mo>
       </munder>
       <mrow>
        <merror class="ltx_ERROR undefined undefined">
         <mtext>\color</mtext>
        </merror>
        <mi>V</mi>
        <mi>i</mi>
        <mi>o</mi>
        <mi>l</mi>
        <mi>e</mi>
        <mi>t</mi>
        <mtext>input set</mtext>
       </mrow>
      </munder>
      <mo rspace="7.5pt">,</mo>
      <mpadded width="+1.7pt">
       <munder>
        <munder accentunder="true">
         <mrow>
          <msup>
           <mi>x</mi>
           <mn>2</mn>
          </msup>
          <mo movablelimits="false">></mo>
          <mn>3</mn>
         </mrow>
         <mo movablelimits="false">⏟</mo>
        </munder>
        <mrow>
         <merror class="ltx_ERROR undefined undefined">
          <mtext>\color</mtext>
         </merror>
         <mi>V</mi>
         <mi>i</mi>
         <mi>o</mi>
         <mi>l</mi>
         <mi>e</mi>
         <mi>t</mi>
         <mtext>predicate</mtext>
        </mrow>
       </munder>
      </mpadded>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-⏟</ci>
       <apply>
        <ci>normal-⋅</ci>
        <cn type="integer">2</cn>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <mtext>\color</mtext>
       <ci>V</ci>
       <ci>i</ci>
       <ci>o</ci>
       <ci>l</ci>
       <ci>e</ci>
       <ci>t</ci>
       <mtext>output expression</mtext>
      </apply>
     </apply>
     <apply>
      <in></in>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-⏟</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <times></times>
        <mtext>\color</mtext>
        <ci>V</ci>
        <ci>i</ci>
        <ci>o</ci>
        <ci>l</ci>
        <ci>e</ci>
        <ci>t</ci>
        <mtext>variable</mtext>
       </apply>
      </apply>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-⏟</ci>
         <ci>ℕ</ci>
        </apply>
        <apply>
         <times></times>
         <mtext>\color</mtext>
         <ci>V</ci>
         <ci>i</ci>
         <ci>o</ci>
         <ci>l</ci>
         <ci>e</ci>
         <ci>t</ci>
         <mtext>input set</mtext>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-⏟</ci>
         <apply>
          <gt></gt>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>x</ci>
           <cn type="integer">2</cn>
          </apply>
          <cn type="integer">3</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <mtext>\color</mtext>
         <ci>V</ci>
         <ci>i</ci>
         <ci>o</ci>
         <ci>l</ci>
         <ci>e</ci>
         <ci>t</ci>
         <mtext>predicate</mtext>
        </apply>
       </apply>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\{\,\underbrace{2\cdot x}_{\color{Violet}{\text{output expression}}}\mid%
\underbrace{x}_{\color{Violet}{\text{variable}}}\in\underbrace{\mathbb{N}}_{%
\color{Violet}{\text{input set}}},\ \underbrace{x^{2}>3}_{\color{Violet}{\text%
{predicate}}}\,\}
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>

<math display="inline" id="List_comprehension:8">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is the variable representing members of an input set.</li>
<li>

<math display="inline" id="List_comprehension:9">
 <semantics>
  <mi>ℕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{N}
  </annotation>
 </semantics>
</math>

 represents the input set, which in this example is the set of natural numbers</li>
<li>

<math display="inline" id="List_comprehension:10">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>></mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}>3
  </annotation>
 </semantics>
</math>

 is a <a href="Predicate_(logic)" title="wikilink">predicate</a> expression acting as a filter on members of the input set.</li>
<li>

<math display="inline" id="List_comprehension:11">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>⋅</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <cn type="integer">2</cn>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\cdot x
  </annotation>
 </semantics>
</math>

 is an output expression producing members of the new set from members of the input set that satisfy the predicate expression.</li>
<li>

<math display="inline" id="List_comprehension:12">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list></list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\}
  </annotation>
 </semantics>
</math>

 braces contain the expression</li>
<li>

<math display="inline" id="List_comprehension:13">
 <semantics>
  <mo>∣</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-∣</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mid
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="List_comprehension:14">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">absent</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ,
  </annotation>
 </semantics>
</math>

 the vertical bar and the comma are separators.</li>
</ul>

<p>A list comprehension has the same syntactic components to represent generation of a list in order from an input <a href="List_(computing)" title="wikilink">list</a> or <a class="uri" href="iterator" title="wikilink">iterator</a>:</p>
<ul>
<li>A variable representing members of an input list.</li>
<li>An input list (or iterator).</li>
<li>An optional predicate expression.</li>
<li>And an output expression producing members of the output list from members of the input iterable that satisfy the predicate.</li>
</ul>

<p>The order of generation of members of the output list is based on the order of items in the input.</p>

<p>In <a href="Haskell_(programming_language)" title="wikilink">Haskell's</a> list comprehension syntax, this set-builder construct would be written similarly, as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">s <span class="fu">=</span> [ <span class="dv">2</span><span class="fu">*</span>x <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="fu">..</span>], x<span class="fu">^</span><span class="dv">2</span> <span class="fu">&gt;</span> <span class="dv">3</span> ]</code></pre></div>

<p>Here, the list <code>[0..]</code> represents 

<math display="inline" id="List_comprehension:15">
 <semantics>
  <mi>ℕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{N}
  </annotation>
 </semantics>
</math>

, <code>x^2&gt;3</code> represents the predicate, and <code>2*x</code> represents the output expression.</p>

<p>List comprehensions give results in a defined order (unlike the members of sets); and list comprehensions may <a href="Generator_(computer_science)" title="wikilink">generate</a> the members of a list in order, rather than produce the entirety of the list thus allowing, for example, the previous Haskell definition of the members of an infinite list.</p>
<h2 id="history">History</h2>

<p>The <a href="SETL_programming_language" title="wikilink">SETL programming language</a> (later 1960s) had a set formation construct, and the <a href="computer_algebra_system" title="wikilink">computer algebra system</a> <a href="Axiom_(computer_algebra_system)" title="wikilink">AXIOM</a> (1973) has a similar construct that processes <a href="stream_(computing)" title="wikilink">streams</a>, but the first use of the term "comprehension" for such constructs was in Rod Burstall and John Darlington's description of their functional programming language <a href="NPL_programming_language" title="wikilink">NPL</a> from 1977.</p>

<p><a class="uri" href="Smalltalk" title="wikilink">Smalltalk</a> block context messages which constitute list comprehensions have been in that language since at least Smalltalk-80.</p>

<p>Burstall and Darlington's work with NPL influenced many functional programming languages during the 1980s, but not all included list comprehensions. An exception was the influential pure lazy functional programming language <a href="Miranda_programming_language" title="wikilink">Miranda</a>, which was released in 1985. The subsequently developed standard pure lazy functional language <a href="Haskell_programming_language" title="wikilink">Haskell</a> includes many of Miranda's features, including list comprehensions.</p>

<p>Comprehensions were proposed as a query notation for databases<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and were implemented in the <em>Kleisli</em> database query language.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="examples-in-different-programming-languages">Examples in different programming languages</h2>

<p>The following provides a few examples of specific syntax used in programming languages.</p>

<p>Although the original example denotes an infinite list, few languages can express that, so in some of those cases we show how to take a subset of 

<math display="inline" id="List_comprehension:16">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mn>100</mn>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
    <ci>normal-…</ci>
    <cn type="integer">100</cn>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{0,1,...,100\}
  </annotation>
 </semantics>
</math>

 rather than a subset of 

<math display="inline" id="List_comprehension:17">
 <semantics>
  <mi>ℕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{N}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="b-prolog">B-Prolog</h3>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span class="dt">L</span> @= [<span class="dt">Y</span> <span class="fu">:</span> <span class="dt">X</span> in <span class="dv">1</span>..<span class="dv">100</span>, [<span class="dt">Y</span>], (<span class="dt">X</span><span class="fu">*</span><span class="dt">X&gt;</span><span class="dv">3</span><span class="kw">,</span> <span class="dt">Y</span> <span class="dt">is</span> <span class="dv">2</span><span class="dt">*X</span>)]</code></pre></div>

<p>A list of the form <code>[T : E1 in D1, ..., En in Dn, LocalVars, Goal]</code> is interpreted as a list comprehension in calls to <code>@=/2</code> and constraints. A list comprehension is translated into a foreach construct with an accumulator.</p>
<h3 id="c">C#</h3>
<pre class="Csharp"><code>from x in Enumerable.Range(0, 100)
where x * x &gt; 3
select x * 2</code></pre>

<p>C# lazily generates results on demand. Results can be automatically processed in parallel on a multi-core system using <a href="Parallel_LINQ" title="wikilink">Parallel LINQ</a>.</p>
<h3 id="ceylon">Ceylon</h3>
<pre><code>{ for (x in 0..100) if ( x**2 &gt; 3) x * 2 }</code></pre>
<h3 id="clojure">Clojure</h3>

<p>Clojure generates infinite lazy sequences (similar to Haskell's lazy lists or Python's generators). Use <strong>take</strong> to get the first N results from the infinite sequence.</p>
<pre class="lisp"><code> (take 20
   (for [x (range) :when (&gt; (* x x) 3)]
     (* 2 x)))
 ;; ⇒ (4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42)</code></pre>

<p>An example without the infinite sequence:</p>
<pre class="lisp"><code> (for [x (range 20) :when (&gt; (* x x) 3)]
   (* 2 x))</code></pre>
<h3 id="coffeescript">CoffeeScript</h3>

<p>CoffeeScript brings pretty list comprehensions to JavaScript.</p>
<pre class="CoffeeScript"><code> (x * 2 for x in [0..20] when x*x &gt; 3)</code></pre>
<h3 id="common-lisp">Common Lisp</h3>

<p>List comprehensions can be expressed with the <code>loop</code> macro's <code>collect</code> keyword. Conditionals are expressed with <code>if</code>, as follows:</p>
<pre class="lisp"><code>(loop for x from 0 to 100 if (&gt; (* x x) 3) collect (* 2 x))</code></pre>

<p>An infinite lazy sequence can be created in a variety of ways, such as the <a class="uri" href="CLOS" title="wikilink">CLOS</a> object system or a <a href="Generator_(computer_science)" title="wikilink">yield</a> macro.</p>
<h3 id="elixir">Elixir</h3>

<p>The same example in Elixir:</p>
<div class="sourceCode"><pre class="sourceCode erlang"><code class="sourceCode erlang"><span class="ch">for</span> <span class="ch">x</span> <span class="kw">&lt;-</span> <span class="dv">0</span><span class="fu">..</span><span class="dv">100</span><span class="fu">,</span> <span class="ch">x</span><span class="kw">*</span><span class="ch">x</span> <span class="kw">&gt;</span> <span class="dv">3</span><span class="fu">,</span> <span class="ch">do</span><span class="fu">:</span> <span class="ch">x</span><span class="kw">*</span><span class="dv">2</span></code></pre></div>
<h3 id="erlang">Erlang</h3>

<p>The same example in Erlang:</p>
<div class="sourceCode"><pre class="sourceCode erlang"><code class="sourceCode erlang"> <span class="dt">S</span> <span class="kw">=</span> <span class="fu">[</span><span class="dv">2</span><span class="kw">*</span><span class="dt">X</span> <span class="fu">||</span> <span class="dt">X</span> <span class="kw">&lt;-</span> <span class="fu">lists:seq(</span><span class="dv">0</span><span class="fu">,</span><span class="dv">100</span><span class="fu">),</span> <span class="dt">X</span><span class="kw">*</span><span class="dt">X</span> <span class="kw">&gt;</span> <span class="dv">3</span><span class="fu">].</span></code></pre></div>
<h3 id="f">F#</h3>

<p>The F# generator comprehension has the list comprehension syntax elements. Generator comprehensions can be used to generate Lists, Sequences (lazy lists) and Arrays (not discussed here).</p>

<p>Generators are of the form <code>[for x in collection do ... yield expr]</code> for lists and <code>seq {for x in collection do ... yield expr}</code> for sequences. For example:</p>
<div class="sourceCode"><pre class="sourceCode fsharp"><code class="sourceCode fsharp">&gt; <span class="dt">seq</span> { <span class="kw">for</span> x <span class="kw">in</span> <span class="fl">0.</span>.<span class="dv">100</span> <span class="kw">do</span>
          <span class="kw">if</span> x*x &gt; <span class="dv">3</span> <span class="kw">then</span> <span class="kw">yield</span> <span class="dv">2</span>*x } ;;
<span class="kw">val</span> it : <span class="dt">seq</span>&lt;<span class="dt">int</span>&gt; = <span class="dt">seq</span> [<span class="dv">4</span>; <span class="dv">6</span>; <span class="dv">8</span>; <span class="dv">10</span>; ...]<!--<span class="dt"-->int</code></pre></div></body>&gt;
<h3 id="falcon">Falcon</h3>

<p>The "comp" generic method family provides wide support for comprehension. For example, the "mfcomp" method can be applied to an array:</p>
<pre class="text"><code>  s = [].mfcomp( { i =&gt; if i*i &gt; 3: return 2*i; return oob(1)}, [1:101] )</code></pre>

<p>Falcon can also use functional generators to provide input lists. For example, the following code uses a continuation to create a set of pairs.</p>
<pre class="text"><code>  gen = Continuation( function( max, c )
         i = 0
         while i &lt; max: c(++i)
         return oob(0)
      end )
  data = [10,11,12]
  s = Set().mfcomp( {x, y =&gt; x+y}, .[gen 3], data )</code></pre>

<p>Method "comp" was introduced in version 0.9.6, and methods "mcomp" and "mfcomp" in version 0.9.6.2.</p>
<h3 id="groovy">Groovy</h3>

<p>Groovy supports list comprehension style expressions for any kind of Java Collection including lists, sets, and maps.</p>
<pre class="groovy"><code>s = (1..100).grep { it ** 2 &gt; 3 }.collect { it * 2 }</code></pre>

<p>The "it" variable is shorthand for the implicit parameter to a closure. The above is equivalent to:</p>
<pre class="groovy"><code>s = (1..100).grep { x -&gt; x ** 2 &gt; 3 }.collect { x -&gt; x * 2 }</code></pre>
<h3 id="haskell">Haskell</h3>

<p>Please refer to the main example in the <a href="#Overview" title="wikilink">overview</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">s <span class="fu">=</span> [ <span class="dv">2</span><span class="fu">*</span>x <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="fu">..</span>], x<span class="fu">^</span><span class="dv">2</span> <span class="fu">&gt;</span> <span class="dv">3</span> ]</code></pre></div>

<p>Here, the list <code>[0..]</code> generates natural numbers one by one which get bound to variable <code>x</code>, <code>x^2&gt;3</code> represents the predicate that either accepts or rejects a given variable's value, and <code>2*x</code> represents the result expression. There might be several generators and test predicates in one list comprehension expression in Haskell, in effect defining nested loops, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">s <span class="fu">=</span> [ <span class="dv">2</span><span class="fu">*</span>x<span class="fu">*</span>y <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="fu">..</span>], x<span class="fu">^</span><span class="dv">2</span> <span class="fu">&gt;</span> <span class="dv">3</span>, y <span class="ot">&lt;-</span> [<span class="dv">1</span>,<span class="dv">3</span><span class="fu">..</span>x], y<span class="fu">^</span><span class="dv">2</span> <span class="fu">&lt;</span> <span class="dv">100</span><span class="fu">-</span>x<span class="fu">^</span><span class="dv">2</span>]
<span class="co">--   for each x from 0 by 1: </span>
<span class="co">--     if x^2 &gt; 3:</span>
<span class="co">--       for each y from 1 by 2 upto x:</span>
<span class="co">--         if y^2 &lt; 100 - x^2:</span>
<span class="co">--           produce 2*x*y</span></code></pre></div>

<p>The above expression becomes unproductive (<em>"stuck"</em>) at some point, when new <strong><em>x</em></strong>s keep being generated only to be rejected later on. This is so because any test can only reject a value it is given, not any future ones (there is no <em>cut</em> mechanism here, in <a class="uri" href="Prolog" title="wikilink">Prolog</a> terms - a generator in general might produce its values unordered, like e.g. the above expression itself). This can be dealt with using bounded list generators always or by enclosing a generator inside a <code>'''take'''</code> or <code>'''takeWhile'''</code> call, limiting the number of generated values.</p>
<h3 id="haxe">Haxe</h3>

<p>Haxe 3 released with array and map comprehension.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<div class="sourceCode"><pre class="sourceCode haxe"><code class="sourceCode haxe">  <span class="kw">var</span> s = [<span class="kw">for</span>(x <span class="kw">in</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>]) <span class="kw">if</span>(x * x &lt; <span class="dv">5</span>) x];</code></pre></div>

<p>However, Haxe 2's syntax required use of Lambda:</p>
<div class="sourceCode"><pre class="sourceCode haxe"><code class="sourceCode haxe">  <span class="kw">var</span> a = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>];
  <span class="kw">var</span> s = Lambda.array(Lambda.filter(a, <span class="kw">function</span>(x) <span class="kw">return</span> x * x &lt; <span class="dv">5</span>));</code></pre></div>
<h3 id="javascript-1.7">JavaScript 1.7</h3>

<p>JavaScript 1.7 has array comprehensions. The <a href="JavaScript_engine" title="wikilink">JavaScript engine</a> of the popular <a href="Firefox_browser" title="wikilink">Firefox browser</a> from <a href="Mozilla_Foundation" title="wikilink">Mozilla Foundation</a>---<a href="SpiderMonkey_(JavaScript_engine)" title="wikilink">SpiderMonkey</a>---supports them,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> for example,</p>
<div class="sourceCode"><pre class="sourceCode Javascript"><code class="sourceCode javascript"> js<span class="op">&gt;</span> [<span class="dv">2</span><span class="op">*</span>x <span class="cf">for</span> <span class="at">each</span> (x <span class="kw">in</span> [<span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">,</span><span class="dv">6</span><span class="op">,</span><span class="dv">7</span>]) <span class="cf">if</span> (x<span class="op">*</span>x<span class="op">&lt;</span><span class="dv">5</span>)]
 [<span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">4</span>]</code></pre></div>

<p>The sequence of integers can be obtained by prototyping the Number object,</p>
<div class="sourceCode"><pre class="sourceCode Javascript"><code class="sourceCode javascript"><span class="va">Number</span>.<span class="va">prototype</span>.<span class="at">__iterator__</span><span class="op">=</span><span class="kw">function</span>()<span class="op">{</span><span class="cf">for</span> (<span class="kw">var</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span><span class="kw">this</span><span class="op">;</span> (x<span class="op">=</span><span class="st">""</span> (x<span class="op">*</span>x<span class="op">&lt;</span><span class="dv">5</span>)]<span class="op">=</span><span class="st">""</span> <span class="dv">100</span>)<span class="op">=</span><span class="st">""</span> <span class="op">&lt;=</span><span class="st">""</span> <span class="cf">for</span><span class="op">=</span><span class="st">""</span> i<span class="op">++</span>)<span class="op">=</span><span class="st">""</span> <span class="cf">if</span><span class="op">=</span><span class="st">""</span> <span class="kw">in</span><span class="op">=</span><span class="st">""</span> i<span class="op">}=</span><span class="st">""</span> s<span class="op">=</span><span class="st">"[2*x"</span> source<span class="op">=</span><span class="st">""</span> <span class="kw">var</span><span class="op">=</span><span class="st">""</span> <span class="kw">yield</span><span class="op">=</span><span class="st">""</span><span class="op">&gt;</span>
Or introducing a range <span class="kw">function</span><span class="op">,</span>
<span class="op">&lt;</span>source lang<span class="op">=</span><span class="st">"Javascript"</span><span class="op">&gt;</span>
<span class="kw">var</span> range <span class="op">=</span> <span class="kw">function</span>(start<span class="op">,</span>end)<span class="op">{</span><span class="cf">for</span> (<span class="kw">var</span> i<span class="op">=</span>start<span class="op">;</span> i<span class="op">&lt;=</span>end<span class="op">;</span> i<span class="op">++</span>) <span class="kw">yield</span> i<span class="op">}</span>
<span class="kw">var</span> s <span class="op">=</span> [<span class="dv">2</span><span class="op">*</span>x <span class="cf">for</span> (x <span class="kw">in</span> <span class="at">range</span>(<span class="dv">0</span><span class="op">,</span><span class="dv">100</span>)) <span class="cf">if</span> (x<span class="op">*</span>x<span class="op">&lt;</span><span class="dv">5</span>)]</code></pre></div>
<h3 id="julia">Julia</h3>

<p>Julia supports comprehensions using the syntax:</p>
<div class="sourceCode"><pre class="sourceCode julia"><code class="sourceCode julia"> y = [x^<span class="fl">2</span>+<span class="fl">1</span> <span class="kw">for</span> x <span class="kw">in</span> <span class="fl">1</span>:<span class="fl">10</span>]</code></pre></div>

<p>and multidimensional comprehensions like:</p>
<div class="sourceCode"><pre class="sourceCode julia"><code class="sourceCode julia"> z = [(x-<span class="fl">5</span>)^<span class="fl">2</span>+(y-<span class="fl">5</span>)^<span class="fl">2</span> <span class="kw">for</span> x = <span class="fl">0</span>:<span class="fl">10</span>, y = <span class="fl">0</span>:<span class="fl">10</span>]</code></pre></div>
<h3 id="mathematica">Mathematica</h3>

<p>The Cases command with a <code>RuleDelayed</code> in the second argument provides a list comprehension mechanism:</p>
<div class="sourceCode"><pre class="sourceCode mathematica"><code class="sourceCode mathematica">  <span class="fu">s</span> = <span class="fu">Cases</span>[<span class="fu">Range</span>[<span class="dv">0</span>,<span class="dv">100</span>], <span class="dt">i_</span> /; <span class="fu">i</span>^<span class="dv">2</span> &gt; <span class="dv">3</span> :&gt; 2i]</code></pre></div>

<p>Alternatively</p>
<div class="sourceCode"><pre class="sourceCode mathematica"><code class="sourceCode mathematica">  <span class="fu">Table</span>[<span class="fu">If</span>[<span class="fu">i</span>^<span class="dv">2</span> &gt; <span class="dv">3</span>, 2i, <span class="fu">Unevaluated</span>[]], {<span class="fu">i</span>, <span class="dv">0</span>, <span class="dv">100</span>}]

  <span class="fu">Do</span>[<span class="fu">If</span>[<span class="fu">i</span>^<span class="dv">2</span> &gt; <span class="dv">3</span>, <span class="fu">Sow</span>[2i]], {<span class="fu">i</span>, <span class="dv">0</span>, <span class="dv">100</span>}] // <span class="fu">Reap</span></code></pre></div>
<h3 id="ocaml">OCaml</h3>
<h4 id="with-batteries">- With Batteries</h4>

<p>OCaml Batteries Included has uniform comprehension syntax for lists, arrays, enumerations (like streams), lazy lists (like lists but evaluated on-demand), sets, hashtables, etc.</p>

<p>Comprehension are of the form <code>[? expression | x &lt;- enumeration ; condition; condition ; ... ?]</code>.</p>

<p>For instance,</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml">#   [? <span class="dv">2</span> * x | x &lt;- <span class="dv">0</span> -- max_int ; x * x &gt; <span class="dv">3</span> ?];;
- : <span class="dt">int</span> Enum<span class="kw">.</span>t = <abstr>
</abstr></code></pre></div>

<p>or, to compute a list,</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml">#   [? <span class="dt">List</span>: <span class="dv">2</span> * x | x &lt;- <span class="dv">0</span> -- <span class="dv">5</span> ; x * x &gt; <span class="dv">3</span> ?];;
- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">4</span>; <span class="dv">6</span>; <span class="dv">8</span>; <span class="dv">10</span>]</code></pre></div>

<p>or, to compute a set,</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml">#   [? <span class="dt">PSet</span>: <span class="dv">2</span> * x | x &lt;- <span class="dv">0</span> -- <span class="dv">5</span> ; x * x &gt; <span class="dv">3</span> ?];;
- : <span class="dt">int</span> PSet<span class="kw">.</span>t = <abstr>
</abstr></code></pre></div>

<p>etc.</p>

<p>For example :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml">#    #use <span class="st">"topfind"</span>;;
#    #require <span class="st">"batteries"</span>;;
#    #require <span class="st">"pa_comprehension"</span>;;
#    <span class="ot">module</span> Enum = <span class="dt">BatEnum</span>;;
#    [? <span class="dv">2</span> * x | x &lt;- <span class="dv">0</span> -- <span class="dv">10</span>; (x * x) <span class="kw">mod</span> <span class="dv">3</span> = <span class="dv">0</span> ?] |&gt; Enum<span class="kw">.</span>iter (<span class="kw">fun</span> n -&gt; Printf<span class="kw">.</span>printf <span class="st">"%d</span><span class="ch">\n</span><span class="st">"</span> n);;
<span class="dv">0</span>, <span class="dv">6</span>, <span class="dv">12</span>, <span class="dv">18</span>,
- : <span class="dt">unit</span> = ()</code></pre></div>
<h4 id="with-camlp4-extension">- With Camlp4 extension</h4>

<p>You can also use the Camlp4 extension :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml">#   #use <span class="st">"topfind"</span>;;
#   #camlp4o;;
#   #load <span class="st">"Camlp4Parsers/Camlp4ListComprehension.cmo"</span>;;
#   <span class="kw">let</span> <span class="kw">rec</span> range a b = <span class="kw">if</span> a &gt; b <span class="kw">then</span> [] <span class="kw">else</span> a :: (range (a+<span class="dv">1</span>) b);;
- : <span class="kw">val</span> range : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;
#   <span class="kw">let</span> triples n = [ (a,b,c) | a &lt;- range <span class="dv">0</span> n; b &lt;- range a n; c &lt;- range b n; a*a + b*b = c*c ];;
- : <span class="kw">val</span> triples : <span class="dt">int</span> -&gt; (<span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">int</span>) <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;
#   triples <span class="dv">10</span>;;
- : (<span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">int</span>) <span class="dt">list</span> = [(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>); (<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>); (<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">2</span>); (<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">3</span>); (<span class="dv">0</span>, <span class="dv">4</span>, <span class="dv">4</span>); (<span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">5</span>); (<span class="dv">0</span>, <span class="dv">6</span>, <span class="dv">6</span>); (<span class="dv">0</span>, <span class="dv">7</span>, <span class="dv">7</span>); (<span class="dv">0</span>, <span class="dv">8</span>, <span class="dv">8</span>); (<span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">9</span>); (<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">10</span>); (<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>); (<span class="dv">6</span>, <span class="dv">8</span>, <span class="dv">10</span>)]      
<!--<span class="kw"-->fun</code></pre></div>&gt;<!--<span class="kw"-->fun&gt;
<h3 id="octave">Octave</h3>

<p><a href="GNU_Octave" title="wikilink">GNU Octave</a> can do list (vector) comprehensions in the form <code>(vector expression)(vector condition)</code>.</p>

<p>For example,</p>
<div class="sourceCode"><pre class="sourceCode octave"><code class="sourceCode octave"> octave:<span class="fl">1</span>&gt; x=<span class="fl">0</span>:<span class="fl">100</span>; s=(<span class="fl">2</span>*x)(x.**<span class="fl">2</span>&lt;<span class="fl">5</span>)
 s =
  <span class="fl">0</span> <span class="fl">2</span> <span class="fl">4</span></code></pre></div>
<h3 id="perl-6">Perl 6</h3>

<p><a href="Perl_6" title="wikilink">Perl 6</a> provides more than one way to implement list comprehensions.</p>
<pre class="perl6"><code>my @s = ($_ * 2 if $_ ** 2 &gt; 3 for ^100);</code></pre>

<p>Or, using <a href="Perl_6#Gather" title="wikilink">gather</a>:</p>
<pre class="perl6"><code>my @s = gather { for ^100 { take 2 * $_ if $_ ** 2 &gt; 3 } };</code></pre>
<h3 id="picat">Picat</h3>
<pre class="text"><code>[2*X : X in 1..100, X*X&gt;3]</code></pre>

<p>A list comprehension in Picat takes the form <code>[T : E1 in D1, Cond1, ..., En in Dn, Condn]</code>. A list comprehension is compiled into a <a href="foreach_loop" title="wikilink">foreach loop</a>, which is further compiled into a tail-recursive predicate.</p>
<h3 id="powershell">PowerShell</h3>
<pre class="PowerShell"><code>0..100 | Where {$_ * $_ -gt 3} | ForEach {$_ * 2}</code></pre>
<h3 id="pure">Pure</h3>

<p>The same example in Pure:</p>

<p><code>s = [2*n | n=1..100; n*n &gt; 3];</code></p>
<h3 id="python">Python</h3>

<p>The <a href="Python_(programming_language)" title="wikilink">Python programming language</a> (starting in version 2.0) has a corresponding syntax for expressing list comprehensions. The near-equivalent in Python to the example above is as follows:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">S <span class="op">=</span> [<span class="dv">2</span> <span class="op">*</span> x <span class="cf">for</span> x <span class="op">in</span> <span class="bu">range</span>(<span class="dv">101</span>) <span class="cf">if</span> x <span class="op">**</span> <span class="dv">2</span> <span class="op">&gt;</span> <span class="dv">3</span>]</code></pre></div>

<p>List comprehensions were introduced in Python version 2.0.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="racket">Racket</h3>

<p>Racket provides functional versions of for-loops, which are essentially list comprehension syntax:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(for/list ([x (in-range <span class="dv">100</span>)] #:when (<span class="kw">&gt;</span> (* x x) <span class="dv">3</span>))
  (* <span class="dv">2</span> x))</code></pre></div>

<p>The imperative <code>for</code> can also be used, combined with Racket's generator library to produce an infinite generator:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(require racket/generator)
(generator ()
  (for ([x (in-naturals)] #:when (<span class="kw">&gt;</span> (* x x) <span class="dv">3</span>))
    (yield (* <span class="dv">2</span> x))))</code></pre></div>
<h3 id="ruby">Ruby</h3>

<p>In the Ruby language you can use multiple ways to simulate this function, for example:</p>
<div class="sourceCode"><pre class="sourceCode Ruby"><code class="sourceCode ruby">(<span class="dv">1</span>..<span class="dv">100</span>).select{|x| x ** <span class="dv">2</span> &gt; <span class="dv">3</span> }.collect{|x| <span class="dv">2</span> * x}</code></pre></div>

<p>Or you can define your own method:</p>
<div class="sourceCode"><pre class="sourceCode Ruby"><code class="sourceCode ruby"><span class="kw">module</span> <span class="dt">Enumerable</span>
  <span class="kw">def</span> comprehend(&amp;block;)
    <span class="kw">return</span> <span class="dv">self</span> <span class="kw">if</span> block.nil?
    collect(&amp;block;).compact
  <span class="kw">end</span>
<span class="kw">end</span>

(<span class="dv">1</span>..<span class="dv">100</span>).comprehend {|x| <span class="dv">2</span> * x <span class="kw">if</span> x ** <span class="dv">2</span> &gt; <span class="dv">3</span>}</code></pre></div>
<h3 id="scala">Scala</h3>

<p>Using a for-expression:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> s = <span class="kw">for</span> (x &lt;- Stream from <span class="dv">0</span> <span class="kw">if</span> x * x &gt; <span class="dv">3</span>) <span class="kw">yield</span> <span class="dv">2</span> * x
<span class="kw">val</span> s = <span class="kw">for</span> {x &lt;- <span class="dv">0</span> to <span class="dv">100</span> <span class="kw">if</span> x * x &gt; <span class="dv">3</span>} <span class="kw">yield</span>  x * <span class="dv">2</span></code></pre></div>

<p>Using a collections:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> s = (<span class="dv">0</span> to <span class="dv">100</span>).<span class="fu">filter</span>(x =&gt; x * x &gt; <span class="dv">3</span>).<span class="fu">map</span>(_ * <span class="dv">2</span>)</code></pre></div>
<h3 id="scheme">Scheme</h3>

<p>Although there is no standard list comprehension syntax in <a class="uri" href="R5RS" title="wikilink">R5RS</a>, many implementations provide an extension for this. For example, in <a href="Chicken_(Scheme_implementation)" title="wikilink">Chicken Scheme</a>:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(require-extension list-of)
(list-of (* <span class="dv">2</span> x) (x range <span class="dv">0</span> <span class="dv">101</span>) (<span class="kw">&gt;</span> (* x x) <span class="dv">3</span>))</code></pre></div>

<p>There is also a portable library SRFI/42 "Eager Comprehensions", which in particular includes list comprehensions:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(require srfi/<span class="dv">42</span>) <span class="co">; example import into Racket Scheme</span>
(list-ec (: x <span class="dv">101</span>) (<span class="kw">if</span> (<span class="kw">&gt;</span> (* x x) <span class="dv">3</span>)) (* <span class="dv">2</span> x))</code></pre></div>
<h3 id="setl">SETL</h3>
<pre class="html4strict"><code>s := {2*x : x in {0..100} | x**2 &gt; 3 };</code></pre>
<h3 id="smalltalk">Smalltalk</h3>
<pre class="smalltalk"><code>((1 to: 100) select: [:x|x*x&gt;3]) collect: [:x|2*x]</code></pre>
<h3 id="supercollider">SuperCollider</h3>

<p>In SuperCollider list comprehensions are implemented as Routines, whose results can be collected with the message 'all'. A shortcut syntax is provided for defining list comprehensions, which internally translates to a routine.</p>
<pre class="text"><code>all {: x * 2, x &lt;- (1..100), x ** 2 &gt; 3 }</code></pre>
<h3 id="visual-prolog">Visual Prolog</h3>
<pre class="VisualProlog"><code>S = [ 2*X || X = std::fromTo(1, 100), X^2 &gt; 3 ]</code></pre>
<h2 id="similar-constructs">Similar constructs</h2>
<h3 id="monad-comprehension">Monad comprehension</h3>

<p>In Haskell, a <a href="monads_in_functional_programming#do-notation" title="wikilink">monad comprehension</a> is a generalization of the list comprehension to other <a href="monads_in_functional_programming" title="wikilink">monads in functional programming</a>.</p>
<h3 id="set-comprehension">Set comprehension</h3>

<p>Version 3.x and 2.7 of the Python language introduces syntax for <a href="set_(computer_science)" title="wikilink">set</a> comprehensions. Similar in form to list comprehensions, set comprehensions generate Python sets instead of lists.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">&gt;&gt;&gt;</span> s <span class="op">=</span> {v <span class="cf">for</span> v <span class="op">in</span> <span class="st">'ABCDABCD'</span> <span class="cf">if</span> v <span class="op">not</span> <span class="op">in</span> <span class="st">'CB'</span>}
<span class="op">&gt;&gt;&gt;</span> <span class="bu">print</span>(s)
{<span class="st">'A'</span>, <span class="st">'D'</span>}
<span class="op">&gt;&gt;&gt;</span> <span class="bu">type</span>(s)
<span class="op">&lt;</span><span class="kw">class</span> <span class="st">'set'</span><span class="op">=</span><span class="st">""</span><span class="op">&gt;</span>
<span class="op">&gt;&gt;&gt;</span> 
<span class="op"><!--</span--><span class="kw">class</span><span class="op">&gt;</span></span></code></pre></div>

<p>Racket set comprehensions generate Racket sets instead of lists.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(for/set ([v <span class="st">"ABCDABCD"</span>] #:unless (<span class="kw">member</span> v (<span class="kw">string-&gt;list</span> <span class="st">"CB"</span>)))
         v))</code></pre></div>
<h3 id="dictionary-comprehension">Dictionary comprehension</h3>

<p>Version 3.x and 2.7 of the Python language introduced a new syntax for <a href="associative_array" title="wikilink">dictionary</a> comprehensions, similar in form to list comprehensions but which generate Python <a href="https://docs.python.org/library/stdtypes.html#dict">dicts</a> instead of lists.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">&gt;&gt;&gt;</span> s <span class="op">=</span> {key: val <span class="cf">for</span> key, val <span class="op">in</span> <span class="bu">enumerate</span>(<span class="st">'ABCD'</span>) <span class="cf">if</span> val <span class="op">not</span> <span class="op">in</span> <span class="st">'CB'</span>}
<span class="op">&gt;&gt;&gt;</span> s
{<span class="dv">0</span>: <span class="st">'A'</span>, <span class="dv">3</span>: <span class="st">'D'</span>}
<span class="op">&gt;&gt;&gt;</span> </code></pre></div>

<p>Racket hash table comprehensions generate Racket hash tables (one implementation of the Racket dictionary type).</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(for/hash ([(val key) (in-indexed <span class="st">"ABCD"</span>)]
           #:unless (<span class="kw">member</span> val (<span class="kw">string-&gt;list</span> <span class="st">"CB"</span>)))
  (<span class="kw">values</span> key val))</code></pre></div>
<h3 id="parallel-list-comprehension">Parallel list comprehension</h3>

<p>The <a href="Glasgow_Haskell_Compiler" title="wikilink">Glasgow Haskell Compiler</a> has an extension called <strong>parallel list comprehension</strong> (also known as <strong>zip-comprehension</strong>) that permits multiple independent branches of qualifiers within the list comprehension syntax. Whereas qualifiers separated by commas are dependent ("nested"), qualifier branches separated by pipes are evaluated in parallel (this does not refer to any form of multithreadedness: it merely means that the branches are <a href="Map_(higher-order_function)" title="wikilink">zipped</a>).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- regular list comprehension</span>
a <span class="fu">=</span> [(x,y) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>], y <span class="ot">&lt;-</span> [<span class="dv">3</span><span class="fu">..</span><span class="dv">5</span>]]
<span class="co">-- [(1,3),(1,4),(1,5),(2,3),(2,4) ...</span>

<span class="co">-- zipped list comprehension</span>
b <span class="fu">=</span> [(x,y) <span class="fu">|</span> (x,y) <span class="ot">&lt;-</span> zip [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>] [<span class="dv">3</span><span class="fu">..</span><span class="dv">5</span>]]
<span class="co">-- [(1,3),(2,4),(3,5)]</span>

<span class="co">-- parallel list comprehension</span>
c <span class="fu">=</span> [(x,y) <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>] <span class="fu">|</span> y <span class="ot">&lt;-</span> [<span class="dv">3</span><span class="fu">..</span><span class="dv">5</span>]]
<span class="co">-- [(1,3),(2,4),(3,5)]</span></code></pre></div>

<p>Racket's comprehensions standard library contains parallel and nested versions of its comprehensions, distinguished by "for" vs "for*" in the name. For example, the vector comprehensions "for/vector" and "for*/vector" create vectors by parallel versus nested iteration over sequences. The following is Racket code for the Haskell list comprehension examples.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span class="kw">&gt;</span> (for*/list ([x (in-range <span class="dv">1</span> <span class="dv">6</span>)] [y (in-range <span class="dv">3</span> <span class="dv">6</span>)]) (<span class="kw">list</span> x y))
'((<span class="dv">1</span> <span class="dv">3</span>) (<span class="dv">1</span> <span class="dv">4</span>) (<span class="dv">1</span> <span class="dv">5</span>) (<span class="dv">2</span> <span class="dv">3</span>) (<span class="dv">2</span> <span class="dv">4</span>) (<span class="dv">2</span> <span class="dv">5</span>) (<span class="dv">3</span> <span class="dv">3</span>) (<span class="dv">3</span> <span class="dv">4</span>) (<span class="dv">3</span> <span class="dv">5</span>) (<span class="dv">4</span> <span class="dv">3</span>) (<span class="dv">4</span> <span class="dv">4</span>) (<span class="dv">4</span> <span class="dv">5</span>) (<span class="dv">5</span> <span class="dv">3</span>) (<span class="dv">5</span> <span class="dv">4</span>) (<span class="dv">5</span> <span class="dv">5</span>))
<span class="kw">&gt;</span> (for/list ([x (in-range <span class="dv">1</span> <span class="dv">6</span>)] [y (in-range <span class="dv">3</span> <span class="dv">6</span>)]) (<span class="kw">list</span> x y))
'((<span class="dv">1</span> <span class="dv">3</span>) (<span class="dv">2</span> <span class="dv">4</span>) (<span class="dv">3</span> <span class="dv">5</span>))</code></pre></div>

<p>In Python we could do as follows:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># regular list comprehension</span>
<span class="op">&gt;&gt;&gt;</span> a <span class="op">=</span> [(x, y) <span class="cf">for</span> x <span class="op">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">6</span>) <span class="cf">for</span> y <span class="op">in</span> <span class="bu">range</span>(<span class="dv">3</span>, <span class="dv">6</span>)]
[(<span class="dv">1</span>, <span class="dv">3</span>), (<span class="dv">1</span>, <span class="dv">4</span>), (<span class="dv">1</span>, <span class="dv">5</span>), (<span class="dv">2</span>, <span class="dv">3</span>), (<span class="dv">2</span>, <span class="dv">4</span>), ...

<span class="co"># parallel/zipped list comprehension</span>
<span class="op">&gt;&gt;&gt;</span> b <span class="op">=</span> [x <span class="cf">for</span> x <span class="op">in</span> <span class="bu">zip</span>(<span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">6</span>), <span class="bu">range</span>(<span class="dv">3</span>, <span class="dv">6</span>))]
[(<span class="dv">1</span>, <span class="dv">3</span>), (<span class="dv">2</span>, <span class="dv">4</span>), (<span class="dv">3</span>, <span class="dv">5</span>)]</code></pre></div>
<h3 id="xquery-and-xpath">XQuery and XPath</h3>

<p>Like the original NPL use, these are fundamentally database access languages.</p>

<p>This makes the comprehension concept more important, because it is computationally infeasible to retrieve the entire list and operate on it (the initial 'entire list' may be an entire XML database).</p>

<p>In XPath, the expression:</p>
<pre class="xquery"><code> /library/book//paragraph[@style='first-in-chapter']</code></pre>

<p>is conceptually evaluated as a series of "steps" where each step produces a list and the next step applies a filter function to each element in the previous step's output.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>In XQuery, full XPath is available, but <a class="uri" href="FLWOR" title="wikilink">FLWOR</a> statements are also used, which is a more powerful comprehension construct.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<pre class="xquery"><code> for $b in //book
 where $b[@pages &lt; 400]
 order by $b//title
 return
   <shortbook>
<title>{$b//title}</title>
<firstpara>{($book//paragraph)[1]}</firstpara>
</shortbook></code></pre>

<p>Here the XPath //book is evaluated to create a sequence (aka list); the where clause is a functional "filter", the order by sorts the result, and the  XML snippet is actually an anonymous function that builds/transforms XML for each element in the sequence using the 'map' approach found in other functional languages.</p>

<p>So, in another functional language the above FLWOR statement may be implemented like this:</p>
<pre class="xquery"><code> map(
   newXML(shortBook, newXML(title, $1.title), newXML(firstPara, $1...))
   filter(
     lt($1.pages, 400),
     xpath(//book)
   )
 )</code></pre>
<h3 id="linq-in-c">LINQ in C#</h3>

<p><a href="C_Sharp_(programming_language)" title="wikilink">C#</a> 3.0 has a group of related features called <a class="uri" href="LINQ" title="wikilink">LINQ</a>, which defines a set of query operators for manipulating object enumerations.</p>
<pre class="csharp"><code>var s = Enumerable.Range(0, 100).Where(x =&gt; x*x &gt; 3).Select(x =&gt; x*2);</code></pre>

<p>It also offers an alternative comprehension syntax, reminiscent of SQL:</p>
<pre class="csharp"><code>var s = from x in Enumerable.Range(0, 100) where x*x &gt; 3 select x*2;</code></pre>

<p>LINQ provides a capability over typical List Comprehension implementations. When the root object of the comprehension implements the IQueryable interface, rather than just executing the chained methods of the comprehension, the entire sequence of commands are converted into an Abstract Syntax Tree (AST) object, which is passed to the IQueryable object to interpret and execute.</p>

<p>This allows, amongst other things, for the IQueryable to</p>
<ul>
<li>rewrite an incompatible or inefficient comprehension</li>
<li>translate the AST into another query language (e.g. SQL) for execution</li>
</ul>
<h3 id="c-1">C++</h3>

<p>C++ does not have any language features directly supporting list comprehensions but operator overloading (e.g., overloading |, &gt;&gt;, &gt;&gt;=) has been used successfully to provide expressive syntax for "embedded" query DSLs. Alternatively, list comprehensions can be constructed using the <a href="erase-remove_idiom" title="wikilink">erase-remove idiom</a> to select elements in a container and the STL algorithm for_each to transform them.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include <algorithm></algorithm></span>
<span class="ot">#include <list></list></span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">template</span>&lt;<span class="kw">class</span> c,=<span class="st">""</span> <span class="kw">class</span>=<span class="st">""</span> p,=<span class="st">""</span> t=<span class="st">""</span>&gt;
C&amp;&amp; comprehend(C&amp;&amp; source, <span class="dt">const</span> P&amp; predicate, <span class="dt">const</span> T&amp; transformation)
{
  <span class="co">// initialize destination</span>
  C d = forward(source);

  <span class="co">// filter elements</span>
  d.erase(remove_if(begin(d), end(d), predicate), end(d));

  <span class="co">// apply transformation</span>
  for_each(begin(d), end(d), transformation);

  <span class="kw">return</span> d;
}

<span class="dt">int</span> main()
{
  list&lt;<span class="dt">int</span>&gt; range(<span class="dv">10</span>);  
      <span class="co">// range is a list of 10 elements, all zero</span>
  iota(begin(range), end(range), <span class="dv">1</span>);
      <span class="co">// range now contains 1,2,...,10</span>

  list&lt;<span class="dt">int</span>&gt; result = comprehend(
      range,
      [](<span class="dt">int</span> x){<span class="kw">return</span> x*x &lt;= <span class="dv">3</span>;},
      [](<span class="dt">int</span> &amp;x;){x *= <span class="dv">2</span>;});
      <span class="co">// result now contains 4,6,...,20</span>
}
<!--<span class="dt"-->int</code></pre></div>&gt;<!--<span class="dt"-->int&gt;<!--<span class="kw"-->class&gt;

<p>There is some effort in providing C++ with list-comprehension constructs/syntax similar to the set builder notation.</p>
<ul>
<li>In <a href="Boost_C++_Libraries" title="wikilink">Boost</a>.Range <a href="http://www.boost.org/libs/range">1</a> library there is a notion of adaptors <a href="http://www.boost.org/libs/range/doc/html/range/reference/adaptors.html">2</a> that can be applied to any range and do filtering, transformation etc. With this library, the original Haskell example would look like (using Boost.Lambda <a href="http://www.boost.org/libs/lambda">3</a> for anonymous filtering and transforming functions):</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">counting_range(<span class="dv">1</span>,<span class="dv">10</span>) | filtered( _1*_1 &gt; <span class="dv">3</span> ) | transformed(ret&lt;<span class="dt">int</span>&gt;( _1*<span class="dv">2</span> ))
<!--<span class="dt"-->int</code></pre></div>&gt;

<p>Full example is here: <a class="uri" href="http://codepad.org/y4bpgLJu">http://codepad.org/y4bpgLJu</a></p>
<ul>
<li>This<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> implementation uses a macro and overloads the &lt;&lt; operator. It evaluates any expression valid inside an 'if', and any variable name may be chosen. It's not <a href="thread_safety" title="wikilink">threadsafe</a>, however. Usage example:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">list&lt;<span class="dt">int</span>&gt; N;
list&lt;<span class="dt">double</span>&gt; S;

<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; i++)
     N.push_back(i);

S &lt;&lt; list_comprehension(<span class="fl">3.</span><span class="dv">1415</span> * x, x, N, x*x &gt; <span class="dv">3</span>)
<!--<span class="dt"-->double</code></pre></div>&gt;<!--<span class="dt"-->int&gt;
<ul>
<li>This<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> implementation provides head/tail slicing using classes and operator overloading, and the | operator for filtering lists (using functions). Usage example:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> even(<span class="dt">int</span> x) { <span class="kw">return</span> x % <span class="dv">2</span> == <span class="dv">0</span>; }
<span class="dt">bool</span> x2(<span class="dt">int</span> &amp;x;) { x *= <span class="dv">2</span>; <span class="kw">return</span> <span class="kw">true</span>; }

list&lt;<span class="dt">int</span>&gt; l, t;
<span class="dt">int</span> x, y;

<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; i++)
     l.push_back(i);

(x, t) = l | x2;
(t, y) = t;

t = l &lt; <span class="dv">9</span>;
t = t &lt; <span class="dv">7</span> | even | x2;
<!--<span class="dt"-->int</code></pre></div>&gt;
<ul>
<li>Language for Embedded Query and Traversal (LEESA<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a>) is an embedded DSL in C++ that implements X-Path-like queries using operator overloading. The queries are executed on richly typed xml trees obtained using xml-to-c++ binding from an XSD. There is absolutely no string encoding. Even the names of the xml tags are classes and therefore, there is no way for typos. If a LEESA expression forms an incorrect path that does not exist in the data model, the C++ compiler will reject the code.</li>
</ul>

<p>Consider a catalog xml.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw"><catalog></catalog></span>
<span class="kw"><book></book></span>
<span class="kw"><title></title></span>Hamlet<span class="kw"></span></code></pre></div>
<span class="kw"><price></price></span>9.99<span class="kw"></span>
<span class="kw"><author></author></span>
<span class="kw"><name></name></span>William Shakespeare<span class="kw"></span>
<span class="kw"><country></country></span>England<span class="kw"></span>
<span class="kw"></span>
<span class="kw"></span>
<span class="kw"><book></book></span>...<span class="kw"></span>
...
<span class="kw"></span>

<p>LEESA provides &gt;&gt; for X-Path's / separator. Interestingly, X-Path's // separator that "skips" intermediate nodes in the tree is implemented in LEESA using what's known as Strategic Programming. In the example below, catalog_, book_, author_, and name_ are instances of catalog, book, author, and name classes, respectively.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Equivalent X-Path: "catalog/book/author/name"</span>
std::vector<name> author_names = 
evaluate(root, catalog_ &gt;&gt; book_ &gt;&gt; author_ &gt;&gt; name_);

<span class="co">// Equivalent X-Path: "catalog//name"</span>
std::vector<name> author_names = 
evaluate(root, catalog_ &gt;&gt; DescendantsOf(catalog_, name_));

<span class="co">// Equivalent X-Path: "catalog//author[country=="England"]"</span>
std::vector<name> author_names = 
evaluate(root, catalog_  &gt;&gt; DescendantsOf(catalog_, author_)
                         &gt;&gt; Select(author_, [](<span class="dt">const</span> author &amp; a) { <span class="kw">return</span> a.country()==<span class="st">"England"</span>; })
                         &gt;&gt; name_);
</name></name></name></code></pre></div>
<h2 id="see-also">See also</h2>
<ul>
<li>The <a href="Select_(SQL)" title="wikilink">SELECT</a> statement together with its FROM and WHERE clauses in <a href="SQL#Queries" title="wikilink">SQL</a></li>
<li><a href="Programming_language" title="wikilink">Programming language</a></li>
<li><a href="Mathematical_notation" title="wikilink">Mathematical notation</a></li>
<li><a href="Monads_in_functional_programming" title="wikilink">Monads in functional programming</a> for monads and monadic notation in general</li>
<li>For other programming language constructs used to process sequences:
<ul>
<li><a href="Generator_(computer_science)" title="wikilink">Generator (computer science)</a></li>
<li><a href="Map_(higher-order_function)" title="wikilink">Map (higher-order function)</a></li>
</ul></li>
<li>For other programming language constructs copied from the mathematical notation:
<ul>
<li><a href="Guard_(computing)" title="wikilink">Guard (computing)</a></li>
<li><a href="Pattern_matching" title="wikilink">Pattern matching</a></li>
<li><a href="Operator_(programming)" title="wikilink">Operator (programming)</a></li>
</ul></li>
</ul>
<h2 id="notes-and-references">Notes and references</h2>
<ul>
<li><a href="http://ftp.sunet.se/foldoc/foldoc.cgi?list+comprehension">List Comprehension</a> in The Free On-line Dictionary of Computing, Editor Denis Howe.</li>
<li></li>
<li></li>
<li></li>
</ul>
<h3 id="haskell-1">Haskell</h3>
<ul>
<li>The Haskell 98 Report, chapter <a href="http://haskell.org/onlinereport/exps.html#list-comprehensions">3.11 List Comprehensions</a>.</li>
<li>The Glorious Glasgow Haskell Compilation System User's Guide, chapter <a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#parallel-list-comprehensions">7.3.4 Parallel List Comprehensions</a>.</li>
<li>The Hugs 98 User's Guide, chapter <a href="http://cvs.haskell.org/Hugs/pages/users_guide/hugs-ghc.html#ZIP-COMPREHENSION">5.1.2 Parallel list comprehensions (a.k.a. zip-comprehensions)</a>.</li>
</ul>
<h3 id="ocaml-1">OCaml</h3>
<ul>
<li><a href="http://batteries.forge.ocamlcore.org/">OCaml Batteries Included</a></li>
<li><a href="http://batteries.forge.ocamlcore.org/doc.preview:batteries-alpha3/html/extensions.html">Language extensions introduced in OCaml Batteries Included</a></li>
</ul>
<h3 id="python-1">Python</h3>
<ul>
<li>Python Reference Manual, chapter <a href="https://www.python.org/doc/2.4.1/ref/lists.html">5.2.4 List displays</a>.</li>
<li>Python Enhancement Proposal <a href="https://www.python.org/peps/pep-0202.html">PEP 202: List Comprehensions</a>.</li>
<li>Python Reference Manual, chapter <a href="https://www.python.org/doc/2.4.1/ref/genexpr.html">5.2.5 Generator expressions</a>.</li>
<li>Python Enhancement Proposal <a href="https://python.org/peps/pep-0289.html">PEP 289: Generator Expressions</a>.</li>
</ul>
<h3 id="common-lisp-1">Common Lisp</h3>
<ul>
<li><a href="http://rali.iro.umontreal.ca/Publications/urls/LapalmeLispComp.pdf">Implementation of a Lisp comprehension macro</a> by Guy Lapalme</li>
</ul>
<h3 id="clojure-1">Clojure</h3>
<ul>
<li><a href="http://clojure.org/api#for">Clojure API documentation - <em>for</em> macro</a></li>
</ul>
<h3 id="axiom">Axiom</h3>
<ul>
<li><a href="http://page.axiom-developer.org/zope/mathaction/Streams">Axiom stream examples</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>SQL-like set operations with list comprehension one-liners in the <a href="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/159974">Python Cookbook</a></li>
<li><a href="http://lambda-the-ultimate.org/classic/message11326.html">Discussion on list comprehensions in Scheme and related constructs</a></li>
<li><a href="http://langexplr.blogspot.com/2007/02/list-comprehensions-across-languages_18.html">List Comprehensions across languages</a></li>
</ul>

<p>"</p>

<p><a href="Category:Programming_constructs" title="wikilink">Category:Programming constructs</a> <a href="Category:Articles_with_example_code" title="wikilink">Category:Articles with example code</a> <a href="Category:Articles_with_example_Haskell_code" title="wikilink">Category:Articles with example Haskell code</a> <a href="Category:Articles_with_example_Python_code" title="wikilink">Category:Articles with example Python code</a> <a href="Category:Articles_with_example_Racket_code" title="wikilink">Category:Articles with example Racket code</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">[<a class="uri" href="http://portal.acm.org/citation.cfm?coll=GUIDE&amp;dl">http://portal.acm.org/citation.cfm?coll=GUIDE&amp;dl;</a>;=GUIDE&amp;id;=135271 Comprehensions, a query notation for DBPLs]<a href="#fnref1">↩</a></li>
<li id="fn2">[<a class="uri" href="http://portal.acm.org/citation.cfm?id=351241&amp;dl">http://portal.acm.org/citation.cfm?id=351241&amp;dl;</a>;=ACM&amp;coll;=portal The functional guts of the Kleisli query system]<a href="#fnref2">↩</a></li>
<li id="fn3"><a class="uri" href="http://haxe.org/manual/haxe3/features#array-comprehension">http://haxe.org/manual/haxe3/features#array-comprehension</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a class="uri" href="https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Predefined_Core_Objects#Array_comprehensions">https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Predefined_Core_Objects#Array_comprehensions</a><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
</ol>
</section>


