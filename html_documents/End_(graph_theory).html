<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1669">End (graph theory)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>End (graph theory)</h1>
<hr/>

<p>In the <a class="uri" href="mathematics" title="wikilink">mathematics</a> of <a href="infinite_graph" title="wikilink">infinite graphs</a>, an <strong>end</strong> of a graph represents, intuitively, a direction in which the graph extends to infinity. Ends may be formalized mathematically as <a href="equivalence_class" title="wikilink">equivalence classes</a> of infinite <a href="path_(graph_theory)" title="wikilink">paths</a>, as <a href="Haven_(graph_theory)" title="wikilink">havens</a> describing strategies for <a class="uri" href="pursuit-evasion" title="wikilink">pursuit-evasion</a> games on the graph, or (in the case of locally finite graphs) as <a href="end_(topology)" title="wikilink">topological ends</a> of <a href="topological_space" title="wikilink">topological spaces</a> associated with the graph.</p>

<p>Ends of graphs may be used (via <a href="Cayley_graph" title="wikilink">Cayley graphs</a>) to define ends of <a href="finitely_generated_group" title="wikilink">finitely generated groups</a>. Finitely generated infinite groups have one, two, or infinitely many ends, and the <a href="Stallings_theorem_about_ends_of_groups" title="wikilink">Stallings theorem about ends of groups</a> provides a decomposition for groups with more than one end.</p>
<h2 id="definition-and-characterization">Definition and characterization</h2>

<p>Ends of graphs were defined by  in terms of equivalence classes of infinite paths.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> A <strong></strong> in an infinite graph is a semi-infinite <a href="simple_path_(graph_theory)" title="wikilink">simple path</a>; that is, it is an infinite sequence of vertices <em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>, ... in which each vertex appears at most once in the sequence and each two consecutive vertices in the sequence are the two endpoints of an edge in the graph. According to Halin's definition, two rays <em>r</em><sub>0</sub> and <em>r</em><sub>1</sub> are equivalent if there is another ray <em>r</em><sub>2</sub> (not necessarily different from either of the first two rays) that contains infinitely many of the vertices in each of <em>r</em><sub>0</sub> and <em>r</em><sub>1</sub>. This is an <a href="equivalence_relation" title="wikilink">equivalence relation</a>: each ray is equivalent to itself, the definition is symmetric with regard to the ordering of the two rays, and it can be shown to be <a href="transitive_relation" title="wikilink">transitive</a>. Therefore, it partitions the set of all rays into <a href="equivalence_classes" title="wikilink">equivalence classes</a>, and Halin defined an end as one of these equivalence classes.</p>

<p>An alternative definition of the same equivalence relation has also been used:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> two rays <em>r</em><sub>0</sub> and <em>r</em><sub>1</sub> are equivalent if there is no finite set <em>X</em> of vertices that <a href="Vertex_separator" title="wikilink">separates</a> infinitely many vertices of <em>r</em><sub>0</sub> from infinitely many vertices of <em>r</em><sub>1</sub>. This is equivalent to Halin's definition: if the ray <em>r</em><sub>2</sub> from Halin's definition exists, then any separator must contain infinitely many points of <em>r</em><sub>2</sub> and therefore cannot be finite, and conversely if <em>r</em><sub>2</sub> does not exist then a path that alternates as many times as possible between <em>r</em><sub>0</sub> and <em>r</em><sub>1</sub> must form the desired finite separator.</p>

<p>Ends also have a more concrete characterization in terms of <a href="Haven_(graph_theory)" title="wikilink">havens</a>, functions that describe evasion strategies for <a class="uri" href="pursuit-evasion" title="wikilink">pursuit-evasion</a> games on a graph <em>G</em>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> In the game in question, a robber is trying to evade a set of policemen by moving from vertex to vertex along the edges of <em>G</em>. The police have helicopters and therefore do not need to follow the edges; however the robber can see the police coming and can choose where to move next before the helicopters land. A haven is a function β that maps each set <em>X</em> of police locations to one of the connected components of the subgraph formed by deleting <em>X</em>; a robber can evade the police by moving in each round of the game to a vertex within this component. Havens must satisfy a consistency property (corresponding to the requirement that the robber cannot move through vertices on which police have already landed): if <em>X</em> is a subset of <em>Y</em>, and both <em>X</em> and <em>Y</em> are valid sets of locations for the given set of police, then β(<em>X</em>) must be a superset of β(<em>Y</em>). A haven has order <em>k</em> if the collection of police locations for which it provides an escape strategy includes all subsets of fewer than <em>k</em> vertices in the graph; in particular, it has order <a href="Aleph_number" title="wikilink">ℵ<sub>0</sub></a> if it maps every finite subset <em>X</em> of vertices to a component of <em>G</em> \ <em>X</em>. Every ray in <em>G</em> corresponds to a haven of order ℵ<sub>0</sub>, namely, the function β that maps every finite set <em>X</em> to the unique component of <em>G</em> \ <em>X</em> that contains infinitely many vertices of the ray. Conversely, every haven of order ℵ<sub>0</sub> can be defined in this way by a ray.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Two rays are equivalent if and only if they define the same haven, so the ends of a graph are in one to one correspondence with its havens of order ℵ<sub>0</sub>.</p>
<h2 id="examples">Examples</h2>

<p> If the infinite graph <em>G</em> is itself a ray, then it has infinitely many ray subgraphs, one starting from each vertex of <em>G</em>. However, all of these rays are equivalent to each other, so <em>G</em> only has one end.</p>

<p>If <em>G</em> is a forest (that is, a graph with no finite cycles), then the intersection of any two rays is either a path or a ray; two rays are equivalent if their intersection is a ray. If a base vertex is chosen in each connected component of <em>G</em>, then each end of <em>G</em> contains a unique ray starting from one of the base vertices, so the ends may be placed in one-to-one correspondence with these canonical rays. Every countable graph <em>G</em> has a <a href="spanning_forest" title="wikilink">spanning forest</a> with the same set of ends as <em>G</em>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> However, there exist uncountably infinite graphs with only one end in which every spanning tree has infinitely many ends.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>If <em>G</em> is an infinite <a href="grid_graph" title="wikilink">grid graph</a>, then it has many rays, and arbitrarily large sets of vertex-disjoint rays. However, it has only one end. This may be seen most easily using the characterization of ends in terms of havens: the removal of any finite set of vertices leaves exactly one infinite connected component, so there is only one haven (the one that maps each finite set to the unique infinite connected component).</p>
<h2 id="relation-to-topological-ends">Relation to topological ends</h2>

<p>In <a href="point-set_topology" title="wikilink">point-set topology</a>, there is a concept of an end that is similar to, but not quite the same as, the concept of an end in graph theory, dating back much earlier to . If a topological space can be covered by a nested sequence of <a href="compact_set" title="wikilink">compact sets</a> 

<math display="inline" id="End_(graph_theory):0">
 <semantics>
  <mrow>
   <msub>
    <mi>κ</mi>
    <mn>0</mn>
   </msub>
   <mo>⊂</mo>
   <msub>
    <mi>κ</mi>
    <mn>1</mn>
   </msub>
   <mo>⊂</mo>
   <mrow>
    <msub>
     <mi>κ</mi>
     <mn>2</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <subset></subset>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>κ</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>κ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>κ</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa_{0}\subset\kappa_{1}\subset\kappa_{2}\dots
  </annotation>
 </semantics>
</math>

, then an end of the space is a sequence of components 

<math display="inline" id="End_(graph_theory):1">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mn>0</mn>
   </msub>
   <mo>⊃</mo>
   <msub>
    <mi>U</mi>
    <mn>1</mn>
   </msub>
   <mo>⊃</mo>
   <mrow>
    <msub>
     <mi>U</mi>
     <mn>2</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">superset-of</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">superset-of</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{0}\supset U_{1}\supset U_{2}\dots
  </annotation>
 </semantics>
</math>

 of the complements of the compact sets. This definition does not depend on the choice of the compact sets: the ends defined by one such choice may be placed in one-to-one correspondence with the ends defined by any other choice.</p>

<p>An infinite graph <em>G</em> may be made into a topological space in two different but related ways:</p>
<ul>
<li>Replacing each vertex of the graph by a point and each edge of the graph by an open <a href="unit_interval" title="wikilink">unit interval</a> produces a <a href="Hausdorff_space" title="wikilink">Hausdorff space</a> from the graph in which a set <em>S</em> is defined to be open whenever each intersection of <em>S</em> with an edge of the graph is an open subset of the unit interval.</li>
<li>Replacing each vertex of the graph by a point and each edge of the graph by a point produces a non-Hausdorff space in which the open sets are the sets <em>S</em> with the property that, if a vertex <em>v</em> of <em>G</em> belongs to <em>S</em>, then so does every edge having <em>v</em> as one of its endpoints.</li>
</ul>

<p>In either case, every finite subgraph of <em>G</em> corresponds to a compact subspace of the topological space, and every compact subspace corresponds to a finite subgraph together with, in the Hausdorff case, finitely many compact proper subsets of edges. Thus, a graph may be covered by a nested sequence of compact sets if and only if it is locally finite, having a finite number of edges at every vertex.</p>

<p>If a graph <em>G</em> is connected and locally finite, then it has a compact cover in which the set κ<sub><em>i</em></sub> is the set of vertices at distance at most <em>i</em> from some arbitrarily chosen starting vertex. In this case any haven β defines an end of the topological space in which 

<math display="inline" id="End_(graph_theory):2">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>β</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>κ</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>β</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>κ</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{i}=\beta(\kappa_{i})
  </annotation>
 </semantics>
</math>

. And conversely, if 

<math display="inline" id="End_(graph_theory):3">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mn>0</mn>
   </msub>
   <mo>⊃</mo>
   <msub>
    <mi>U</mi>
    <mn>1</mn>
   </msub>
   <mo>⊃</mo>
   <mrow>
    <msub>
     <mi>U</mi>
     <mn>2</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">superset-of</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">superset-of</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{0}\supset U_{1}\supset U_{2}\dots
  </annotation>
 </semantics>
</math>

 is an end of the topological space defined from <em>G</em>, it defines a haven in which β(<em>X</em>) is the component containing <em>U</em><sub><em>i</em></sub>, where <em>i</em> is any number large enough that κ<sub><em>i</em></sub> contains <em>X</em>. Thus, for connected and locally finite graphs, the topological ends are in one-to-one correspondence with the graph-theoretic ends.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>For graphs that may not be locally finite, it is still possible to define a topological space from the graph and its ends. This space can be represented as a <a href="metric_space" title="wikilink">metric space</a> if and only if the graph has a <a href="Trémaux_tree" title="wikilink">normal spanning tree</a>, a rooted <a href="spanning_tree" title="wikilink">spanning tree</a> such that each graph edge connects an ancestor-descendant pair. If a normal spanning tree exists, it has the same set of ends as the given graph: each end of the graph must contain exactly one infinite path in the tree.</p>
<h2 id="special-kinds-of-ends">Special kinds of ends</h2>
<h3 id="free-ends">Free ends</h3>

<p>An end <em>E</em> of a graph <em>G</em> is defined to be a <strong>free end</strong> if there is a finite set <em>X</em> of vertices with the property that <em>X</em> separates <em>E</em> from all other ends of the graph. (That is, in terms of havens, β<sub><em>E</em></sub>(<em>X</em>) is disjoint from β<sub><em>D</em></sub>(<em>X</em>) for every other end <em>D</em>.) In a graph with finitely many ends, every end must be free.  proves that, if <em>G</em> has infinitely many ends, then either there exists an end that is not free, or there exists an infinite family of rays that share a common starting vertex and are otherwise disjoint from each other.</p>
<h3 id="thick-ends">Thick ends</h3>

<p>A <strong>thick end</strong> of a graph <em>G</em> is an end that contains infinitely many pairwise-<a href="disjoint_sets" title="wikilink">disjoint</a> rays. <a href="Halin's_grid_theorem" title="wikilink">Halin's grid theorem</a> characterizes the graphs that contain thick ends: they are exactly the graphs that have a <a href="Homeomorphism_(graph_theory)" title="wikilink">subdivision</a> of the <a href="hexagonal_tiling" title="wikilink">hexagonal tiling</a> as a subgraph.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="special-kinds-of-graphs">Special kinds of graphs</h2>
<h3 id="symmetric-and-almost-symmetric-graphs">Symmetric and almost-symmetric graphs</h3>

<p>defines a connected locally-finite graph to be "almost symmetric" if there exist a vertex <em>v</em> and a number <em>D</em> such that, for every other vertex <em>w</em>, there is an <a href="graph_isomorphism" title="wikilink">automorphism</a> of the graph for which the image of <em>v</em> is within distance <em>D</em> of <em>w</em>; equivalently, a connected locally-finite graph is almost symmetric if its automorphism group has finitely many orbits. As he shows, for every connected locally-finite almost-symmetric graph, the number of ends is either at most two or uncountable; if it is uncountable, the ends have the topology of a <a href="Cantor_set" title="wikilink">Cantor set</a>. Additionally, Mohar shows that the number of ends controls the <a href="Cheeger_constant_(graph_theory)" title="wikilink">Cheeger constant</a></p>

<p>

<math display="block" id="End_(graph_theory):4">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mo>=</mo>
    <mrow>
     <mo movablelimits="false">inf</mo>
     <mrow>
      <mo>{</mo>
      <mfrac>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <mo>∂</mo>
         <mi>V</mi>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>V</mi>
        <mo stretchy="false">|</mo>
       </mrow>
      </mfrac>
      <mo>}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>h</ci>
    <apply>
     <csymbol cd="latexml">infimum</csymbol>
     <set>
      <apply>
       <divide></divide>
       <apply>
        <abs></abs>
        <apply>
         <partialdiff></partialdiff>
         <ci>V</ci>
        </apply>
       </apply>
       <apply>
        <abs></abs>
        <ci>V</ci>
       </apply>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h=\inf\left\{\frac{|\partial V|}{|V|}\right\},
  </annotation>
 </semantics>
</math>

 where <em>V</em> ranges over all finite nonempty sets of vertices of the graph and where 

<math display="inline" id="End_(graph_theory):5">
 <semantics>
  <mrow>
   <mo>∂</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <partialdiff></partialdiff>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial V
  </annotation>
 </semantics>
</math>

 denotes the set of edges with one endpoint in <em>V</em>. For almost-symmetric graphs with uncountably many ends, <em>h</em> &gt; 0; however, for almost-symmetric graphs with only two ends, <em>h</em> = 0.</p>
<h3 id="cayley-graphs">Cayley graphs</h3>

<p> Every <a href="group_(mathematics)" title="wikilink">group</a> and a set of generators for the group determine a <a href="Cayley_graph" title="wikilink">Cayley graph</a>, a graph whose vertices are the group elements and the edges are pairs of elements (<em>x</em>,<em>gx</em>) where <em>g</em> is one of the generators. In the case of a <a href="finitely-generated_group" title="wikilink">finitely-generated group</a>, the ends of the group are defined to be the ends of the Cayley graph for the finite set of generators; this definition is invariant under the choice of generators, in the sense that if two different finite set of generators are chosen, the ends of the two Cayley graphs are in one-to-one correspondence with each other.</p>

<p>For instance, every <a href="free_group" title="wikilink">free group</a> has a Cayley graph (for its free generators) that is a tree. The free group on one generator has a doubly-infinite path as its Cayley graph, with two ends. Every other free group has infinitely many ends.</p>

<p>Every finitely-generated infinite group has either 1, 2, or infinitely many ends, and the <a href="Stallings_theorem_about_ends_of_groups" title="wikilink">Stallings theorem about ends of groups</a> provides a decomposition of groups with more than one end.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> In particular:</p>
<ol>
<li>A finitely-generated infinite group has 2 ends if and only if it has a <a href="cyclic_group" title="wikilink">cyclic</a> <a class="uri" href="subgroup" title="wikilink">subgroup</a> of finite <a href="index_of_a_subgroup" title="wikilink">index</a>.</li>
<li>A finitely-generated infinite group has infinitely many ends if and only if it is either a nontrivial <a href="free_product_with_amalgamation" title="wikilink">free product with amalgamation</a> or <a class="uri" href="HNN-extension" title="wikilink">HNN-extension</a> with finite amalgamation.</li>
<li>All other finitely-generated infinite groups have exactly one end.</li>
</ol>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Graph_theory_objects" title="wikilink">Category:Graph theory objects</a> <a href="Category:Infinite_graphs" title="wikilink">Category:Infinite graphs</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">However, as  point out, ends of graphs were already considered by .<a href="#fnref1">↩</a></li>
<li id="fn2">E.g., this is the form of the equivalence relation used by .<a href="#fnref2">↩</a></li>
<li id="fn3">The haven nomenclature, and the fact that two rays define the same haven if and only if they are equivalent, is due to .  proved that every haven comes from an end, completing the bijection between ends and havens, using a different nomenclature in which they called havens "directions".<a href="#fnref3">↩</a></li>
<li id="fn4">The proof by  that every haven can be defined by a ray is nontrivial and involves two cases. If the set 

<math display="inline" id="End_(graph_theory):6">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋂</mo>
     <mi>X</mi>
    </msub>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mi>β</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>∪</mo>
      <mi>X</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <intersect></intersect>
      <ci>X</ci>
     </apply>
     <apply>
      <union></union>
      <apply>
       <times></times>
       <ci>β</ci>
       <ci>X</ci>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\bigcap_{X}\left(\beta(X)\cup X\right)
  </annotation>
 </semantics>
</math>

 (where <em>X</em> ranges over all finite sets of vertices) is infinite, then there exists a ray that passes through infinitely many vertices of <em>S</em>, which necessarily determines β. On the other hand, if <em>S</em> is finite, then  show that in this case there exists a sequence of finite sets <em>X</em><sub><em>i</em></sub> that separate the end from all points whose distance from an arbitrarily chosen starting point in <em>G</em> \ <em>S</em> is <em>i</em>. In this case, the haven is defined by any ray that is followed by a robber using the haven to escape police who land at set <em>X</em><sub><em>i</em></sub> in round <em>i</em> of the pursuit-evasion game.<a href="#fnref4">↩</a></li>
<li id="fn5">More precisely, in the original formulation of this result by  in which ends are defined as equivalence classes of rays, every equivalence class of rays of <em>G</em> contains a unique nonempty equivalence class of rays of the spanning forest. In terms of havens, there is a one-to-one correspondence of havens of order ℵ<sub>0</sub> between <em>G</em> and its spanning tree <em>T</em> for which 

<math display="inline" id="End_(graph_theory):7">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>β</mi>
     <mi>T</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⊂</mo>
   <mrow>
    <msub>
     <mi>β</mi>
     <mi>G</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>T</ci>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>G</ci>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{T}(X)\subset\beta_{G}(X)
  </annotation>
 </semantics>
</math>

 for every finite set <em>X</em> and every corresponding pair of havens β<sub><em>T</em></sub> and β<sub><em>G</em></sub>.<a href="#fnref5">↩</a></li>
<li id="fn6">; ; .<a href="#fnref6">↩</a></li>
<li id="fn7">.<a href="#fnref7">↩</a></li>
<li id="fn8">; .<a href="#fnref8">↩</a></li>
<li id="fn9">.<a href="#fnref9">↩</a></li>
</ol>
</section>
</body>
</html>
