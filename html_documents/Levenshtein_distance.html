<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="675">Levenshtein distance</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Levenshtein distance</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a href="information_theory" title="wikilink">information theory</a> and <a href="computer_science" title="wikilink">computer science</a>, the <strong>Levenshtein distance</strong> is a <a href="string_metric" title="wikilink">string metric</a> for measuring the difference between two sequences. Informally, the Levenshtein distance between two words is the minimum number of single-character edits (i.e. insertions, deletions or substitutions) required to change one word into the other. It is named after <a href="Vladimir_Levenshtein" title="wikilink">Vladimir Levenshtein</a>, who considered this distance in 1965.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Levenshtein distance may also be referred to as <strong>edit distance</strong>, although that may also denote a larger <a href="Edit_distance" title="wikilink">family of distance metrics</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> It is closely related to <a href="Sequence_alignment#Pairwise_alignment" title="wikilink">pairwise string alignments</a>.</p>
<h2 id="definition">Definition</h2>

<p>Mathematically, the Levenshtein distance between two strings 

<math display="inline" id="Levenshtein_distance:0">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>a</ci>
    <ci>b</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a,b
  </annotation>
 </semantics>
</math>

 (of length 

<math display="inline" id="Levenshtein_distance:1">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>a</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |a|
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Levenshtein_distance:2">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>b</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |b|
  </annotation>
 </semantics>
</math>

 respectively) is given by 

<math display="inline" id="Levenshtein_distance:3">
 <semantics>
  <mrow>
   <msub>
    <mo>lev</mo>
    <mrow>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>a</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>b</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>lev</ci>
     <list>
      <ci>a</ci>
      <ci>b</ci>
     </list>
    </apply>
    <apply>
     <abs></abs>
     <ci>a</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{lev}_{a,b}(|a|,|b|)
  </annotation>
 </semantics>
</math>

 where</p>

<p>

<math display="block" id="Levenshtein_distance:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo lspace="22.5pt">lev</mo>
     <mrow>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>max</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>i</mi>
         <mo>,</mo>
         <mi>j</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mrow>
           <mi>min</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>i</mi>
            <mo>,</mo>
            <mi>j</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>min</mi>
        <mrow>
         <mo>{</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="left">
            <mrow>
             <mrow>
              <msub>
               <mo>lev</mo>
               <mrow>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
               </mrow>
              </msub>
              <mrow>
               <mo stretchy="false">(</mo>
               <mrow>
                <mi>i</mi>
                <mo>-</mo>
                <mn>1</mn>
               </mrow>
               <mo>,</mo>
               <mi>j</mi>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
             <mo>+</mo>
             <mn>1</mn>
            </mrow>
           </mtd>
           <mtd></mtd>
          </mtr>
          <mtr>
           <mtd columnalign="left">
            <mrow>
             <mrow>
              <msub>
               <mo>lev</mo>
               <mrow>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
               </mrow>
              </msub>
              <mrow>
               <mo stretchy="false">(</mo>
               <mi>i</mi>
               <mo>,</mo>
               <mrow>
                <mi>j</mi>
                <mo>-</mo>
                <mn>1</mn>
               </mrow>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
             <mo>+</mo>
             <mn>1</mn>
            </mrow>
           </mtd>
           <mtd></mtd>
          </mtr>
          <mtr>
           <mtd columnalign="left">
            <mrow>
             <mrow>
              <msub>
               <mo>lev</mo>
               <mrow>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
               </mrow>
              </msub>
              <mrow>
               <mo stretchy="false">(</mo>
               <mrow>
                <mi>i</mi>
                <mo>-</mo>
                <mn>1</mn>
               </mrow>
               <mo>,</mo>
               <mrow>
                <mi>j</mi>
                <mo>-</mo>
                <mn>1</mn>
               </mrow>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
             <mo>+</mo>
             <msub>
              <mn>1</mn>
              <mrow>
               <mo stretchy="false">(</mo>
               <msub>
                <mi>a</mi>
                <mi>i</mi>
               </msub>
               <mo>≠</mo>
               <msub>
                <mi>b</mi>
                <mi>j</mi>
               </msub>
               <mo stretchy="false">)</mo>
              </mrow>
             </msub>
            </mrow>
           </mtd>
           <mtd></mtd>
          </mtr>
         </mtable>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise.</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>lev</ci>
      <list>
       <ci>a</ci>
       <ci>b</ci>
      </list>
     </apply>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <max></max>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <apply>
        <min></min>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <min></min>
      <apply>
       <csymbol cd="latexml">cases</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>lev</ci>
          <list>
           <ci>a</ci>
           <ci>b</ci>
          </list>
         </apply>
         <apply>
          <minus></minus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>j</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <mtext>otherwise</mtext>
       <apply>
        <plus></plus>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>lev</ci>
          <list>
           <ci>a</ci>
           <ci>b</ci>
          </list>
         </apply>
         <ci>i</ci>
         <apply>
          <minus></minus>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <mtext>otherwise</mtext>
       <apply>
        <plus></plus>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>lev</ci>
          <list>
           <ci>a</ci>
           <ci>b</ci>
          </list>
         </apply>
         <apply>
          <minus></minus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <minus></minus>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <cn type="integer">1</cn>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <ci>normal-(</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>a</ci>
           <ci>i</ci>
          </apply>
          <neq></neq>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>b</ci>
           <ci>j</ci>
          </apply>
          <ci>normal-)</ci>
         </cerror>
        </apply>
       </apply>
       <mtext>otherwise</mtext>
      </apply>
     </apply>
     <mtext>otherwise.</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \qquad\operatorname{lev}_{a,b}(i,j)=\begin{cases}\max(i,j)&\text{ if}\min(i,j)%
=0,\\
\min\begin{cases}\operatorname{lev}_{a,b}(i-1,j)+1\\
\operatorname{lev}_{a,b}(i,j-1)+1\\
\operatorname{lev}_{a,b}(i-1,j-1)+1_{(a_{i}\neq b_{j})}\end{cases}&\text{ %
otherwise.}\end{cases}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Levenshtein_distance:5">
 <semantics>
  <msub>
   <mn>1</mn>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
    <mo>≠</mo>
    <msub>
     <mi>b</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cn type="integer">1</cn>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <neq></neq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1_{(a_{i}\neq b_{j})}
  </annotation>
 </semantics>
</math>

 is the <a href="indicator_function" title="wikilink">indicator function</a> equal to 0 when 

<math display="inline" id="Levenshtein_distance:6">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>b</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}=b_{j}
  </annotation>
 </semantics>
</math>

 and equal to 1 otherwise.</p>

<p>Note that the first element in the minimum corresponds to deletion (from 

<math display="inline" id="Levenshtein_distance:7">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Levenshtein_distance:8">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

), the second to insertion and the third to match or mismatch, depending on whether the respective symbols are the same.</p>
<h3 id="example">Example</h3>

<p>For example, the Levenshtein distance between "kitten" and "sitting" is 3, since the following three edits change one into the other, and there is no way to do it with fewer than three edits:</p>
<ol>
<li><strong>k</strong>itten → <strong>s</strong>itten (substitution of "s" for "k")</li>
<li>sitt<strong>e</strong>n → sitt<strong>i</strong>n (substitution of "i" for "e")</li>
<li>sittin → sittin<strong>g</strong> (insertion of "g" at the end).</li>
</ol>
<h3 id="upper-and-lower-bounds">Upper and lower bounds</h3>

<p>The Levenshtein distance has several simple upper and lower bounds. These include:</p>
<ul>
<li>It is always at least the difference of the sizes of the two strings.</li>
<li>It is at most the length of the longer string.</li>
<li>It is zero if and only if the strings are equal.</li>
<li>If the strings are the same size, the <a href="Hamming_distance" title="wikilink">Hamming distance</a> is an upper bound on the Levenshtein distance.</li>
<li>The Levenshtein distance between two strings is no greater than the sum of their Levenshtein distances from a third string (<a href="triangle_inequality" title="wikilink">triangle inequality</a>).</li>
</ul>

<p>An example where the Levenshtein distance between two strings of the same length is strictly less than the Hamming distance is given by the pair "flaw" and "lawn". Here the Levenshtein distance equals 2 (delete "f" from the front; insert "n" at the end). The Hamming distance is 4.</p>
<h2 id="applications">Applications</h2>

<p>In <a href="approximate_string_matching" title="wikilink">approximate string matching</a>, the objective is to find matches for short strings in many longer texts, in situations where a small number of differences is to be expected. The short strings could come from a dictionary, for instance. Here, one of the strings is typically short, while the other is arbitrarily long. This has a wide range of applications, for instance, <a href="spell_checker" title="wikilink">spell checkers</a>, correction systems for <a href="optical_character_recognition" title="wikilink">optical character recognition</a>, and software to assist natural language translation based on <a href="translation_memory" title="wikilink">translation memory</a>.</p>

<p>The Levenshtein distance can also be computed between two longer strings, but the cost to compute it, which is roughly proportional to the product of the two string lengths, makes this impractical. Thus, when used to aid in <a href="fuzzy_string_searching" title="wikilink">fuzzy string searching</a> in applications such as <a href="record_linkage" title="wikilink">record linkage</a>, the compared strings are usually short to help improve speed of comparisons.</p>
<h2 id="relationship-with-other-edit-distance-metrics">Relationship with other edit distance metrics</h2>

<p>There are other popular measures of <a href="edit_distance" title="wikilink">edit distance</a>, which are calculated using a different set of allowable edit operations. For instance,</p>
<ul>
<li>the <a href="Damerau–Levenshtein_distance" title="wikilink">Damerau–Levenshtein distance</a> allows insertion, deletion, substitution, and the <a href="Transposition_(mathematics)" title="wikilink">transposition</a> of two adjacent characters;</li>
<li>the <a href="longest_common_subsequence_problem" title="wikilink">longest common subsequence</a> metric allows only insertion and deletion, not substitution;</li>
<li>the <a href="Hamming_distance" title="wikilink">Hamming distance</a> allows only substitution, hence, it only applies to strings of the same length.</li>
</ul>

<p><a href="Edit_distance" title="wikilink">Edit distance</a> is usually defined as a parameterizable metric calculated with a specific set of allowed edit operations, and each operation is assigned a cost (possibly infinite). This is further generalized by DNA <a href="sequence_alignment" title="wikilink">sequence alignment</a> algorithms such as the <a href="Smith–Waterman_algorithm" title="wikilink">Smith–Waterman algorithm</a>, which make an operation's cost depend on where it is applied.</p>
<h2 id="computing-levenshtein-distance">Computing Levenshtein distance</h2>
<h3 id="recursive">Recursive</h3>

<p>This is a straightforward, but inefficient, recursive <a href="C_(programming_language)" title="wikilink">C</a> implementation of a <code>LevenshteinDistance</code> function that takes two strings, <em>s</em> and <em>t</em>, together with their lengths, and returns the Levenshtein distance between them:</p>
<div class="sourceCode"><pre class="sourceCode C"><code class="sourceCode c"><span class="co">// len_s and len_t are the number of characters in string s and t respectively</span>
<span class="dt">int</span> LevenshteinDistance(string s, <span class="dt">int</span> len_s, string t, <span class="dt">int</span> len_t)
{ <span class="dt">int</span> cost;

  <span class="co">/* base case: empty strings */</span>
  <span class="kw">if</span> (len_s == <span class="dv">0</span>) <span class="kw">return</span> len_t;
  <span class="kw">if</span> (len_t == <span class="dv">0</span>) <span class="kw">return</span> len_s;

  <span class="co">/* test if last characters of the strings match */</span>
  <span class="kw">if</span> (s[len_s<span class="dv">-1</span>] == t[len_t<span class="dv">-1</span>])
      cost = <span class="dv">0</span>;
  <span class="kw">else</span>
      cost = <span class="dv">1</span>;

  <span class="co">/* return minimum of delete char from s, delete char from t, and delete char from both */</span>
  <span class="kw">return</span> minimum(LevenshteinDistance(s, len_s - <span class="dv">1</span>, t, len_t    ) + <span class="dv">1</span>,
                 LevenshteinDistance(s, len_s    , t, len_t - <span class="dv">1</span>) + <span class="dv">1</span>,
                 LevenshteinDistance(s, len_s - <span class="dv">1</span>, t, len_t - <span class="dv">1</span>) + cost);
}</code></pre></div>

<p>This recursive implementation is straightforward, but very inefficient, because it recomputes the Levenshtein distance of the same substrings many times.</p>

<p>A more efficient method would never repeat the same distance calculation. For example, the Levenshtein distance of all possible prefixes might be stored in an array <code>d[][]</code> where <code>d[i][j]</code> is the distance between the first <code>i</code> characters of string <code>s</code> and the first <code>j</code> characters of string <code>t</code>. The table is easy to construct one row at a time starting with row 0. When the entire table has been built, the desired distance is <code>d[len_s][len_t]</code>. While this technique is significantly faster, it will consume <code>len_s * len_t</code> more memory than the straightforward recursive implementation.</p>
<h3 id="iterative-with-full-matrix">Iterative with full matrix</h3>
<dl>
<dd><dl>
<dd>
</dd>
</dl>
</dd>
</dl>

<p>Computing the Levenshtein distance is based on the observation that if we reserve a <a href="Matrix_(mathematics)" title="wikilink">matrix</a> to hold the Levenshtein distances between all <a href="prefix_(computer_science)" title="wikilink">prefixes</a> of the first string and all prefixes of the second, then we can compute the values in the matrix in a <a href="dynamic_programming" title="wikilink">dynamic programming</a> fashion, and thus find the distance between the two full strings as the last value computed.</p>

<p>This algorithm, an example of bottom-up <a href="dynamic_programming" title="wikilink">dynamic programming</a>, is discussed, with variants, in the 1974 article <em>The <a href="String-to-string_correction_problem" title="wikilink">String-to-string correction problem</a></em> by Robert A. Wagner and Michael J. Fischer.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>This is a straightforward pseudocode implementation for a function <em>LevenshteinDistance</em> that takes two strings, <em>s</em> of length <em>m</em>, and <em>t</em> of length <em>n</em>, and returns the Levenshtein distance between them:</p>
<div class="sourceCode"><pre class="sourceCode C"><code class="sourceCode c">function LevenshteinDistance(<span class="dt">char</span> s[<span class="dv">1</span>..m], <span class="dt">char</span> t[<span class="dv">1</span>..n]):
  <span class="co">// for all i and j, d[i,j] will hold the Levenshtein distance between</span>
  <span class="co">// the first i characters of s and the first j characters of t;</span>
  <span class="co">// note that d has (m+1)*(n+1) values</span>
  declare <span class="dt">int</span> d[<span class="dv">0</span>..m, <span class="dv">0</span>..n]
 
  set each element in d to zero
 
  <span class="co">// source prefixes can be transformed into empty string by</span>
  <span class="co">// dropping all characters</span>
  <span class="kw">for</span> i from <span class="dv">1</span> to m:
      d[i, <span class="dv">0</span>] := i
 
  <span class="co">// target prefixes can be reached from empty source prefix</span>
  <span class="co">// by inserting every character</span>
  <span class="kw">for</span> j from <span class="dv">1</span> to n:
      d[<span class="dv">0</span>, j] := j
 
  <span class="kw">for</span> j from <span class="dv">1</span> to n:
      <span class="kw">for</span> i from <span class="dv">1</span> to m:
          <span class="kw">if</span> s[i] = t[j]:
            d[i, j] := d[i<span class="dv">-1</span>, j<span class="dv">-1</span>]              <span class="co">// no operation required</span>
          <span class="kw">else</span>:
            d[i, j] := minimum(d[i<span class="dv">-1</span>, j] + <span class="dv">1</span>,   <span class="co">// a deletion</span>
                               d[i, j<span class="dv">-1</span>] + <span class="dv">1</span>,   <span class="co">// an insertion</span>
                               d[i<span class="dv">-1</span>, j<span class="dv">-1</span>] + <span class="dv">1</span>) <span class="co">// a substitution</span>
 
  <span class="kw">return</span> d[m, n]</code></pre></div>

<p>Note that this implementation does not fit the <a href="#Definition" title="wikilink">definition</a> precisely: it always prefers matches, even if insertions or deletions provided a better score. This is equivalent; it can be shown that for every optimal alignment (which induces the Levenshtein distance) there is another optimal alignment that prefers matches in the sense of this implementation.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Two examples of the resulting matrix (hovering over a number reveals the operation performed to get that number):</p>
<center>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>k</p></td>
<td style="text-align: left;">
<p>i</p></td>
<td style="text-align: left;">
<p>t</p></td>
<td style="text-align: left;">
<p>t</p></td>
<td style="text-align: left;">
<p>e</p></td>
<td style="text-align: left;">
<p>n</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>6</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>s</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>6</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>i</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>5</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>t</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>4</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>t</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>i</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>3</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>n</p></td>
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>g</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>S</p></td>
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>t</p></td>
<td style="text-align: left;">
<p>u</p></td>
<td style="text-align: left;">
<p>r</p></td>
<td style="text-align: left;">
<p>d</p></td>
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>y</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>8</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>S</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>7</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>u</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>6</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>n</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>6</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>d</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>5</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>4</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>y</p></td>
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</center>

<p>The <a href="invariant_(mathematics)" title="wikilink">invariant</a> maintained throughout the algorithm is that we can transform the initial segment <code>s[1..i]</code> into <code>t[1..j]</code> using a minimum of <code>d[i,j]</code> operations. At the end, the bottom-right element of the array contains the answer.</p>
<h3 id="iterative-with-two-matrix-rows">Iterative with two matrix rows</h3>

<p>It turns out that only two rows of the table are needed for the construction if one does not want to reconstruct the edited input strings (the previous row and the current row being calculated).</p>

<p>The Levenshtein distance may be calculated iteratively using the following algorithm:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<pre class="CSharp"><code>int LevenshteinDistance(string s, string t)
{
    // degenerate cases
    if (s == t) return 0;
    if (s.Length == 0) return t.Length;
    if (t.Length == 0) return s.Length;

    // create two work vectors of integer distances
    int[] v0 = new int[t.Length + 1];
    int[] v1 = new int[t.Length + 1];

    // initialize v0 (the previous row of distances)
    // this row is A[0][i]: edit distance for an empty s
    // the distance is just the number of characters to delete from t
    for (int i = 0; i &lt; v0.Length; i++)
        v0[i] = i;

    for (int i = 0; i &lt; s.Length; i++)
    {
        // calculate v1 (current row distances) from the previous row v0

        // first element of v1 is A[i+1][0]
        //   edit distance is delete (i+1) chars from s to match empty t
        v1[0] = i + 1;

        // use formula to fill in the rest of the row
        for (int j = 0; j &lt; t.Length; j++)
        {
            var cost = (s[i] == t[j]) ? 0 : 1;
            v1[j + 1] = Minimum(v1[j] + 1, v0[j + 1] + 1, v0[j] + cost);
        }

        // copy v1 (current row) to v0 (previous row) for next iteration
        for (int j = 0; j &lt; v0.Length; j++)
            v0[j] = v1[j];
    }

    return v1[t.Length];
}</code></pre>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="agrep" title="wikilink">agrep</a></li>
<li><a href="Approximate_string_matching" title="wikilink">Approximate string matching</a></li>
<li><a href="Bitap_algorithm" title="wikilink">Bitap algorithm</a></li>
<li><a href="Damerau–Levenshtein_distance" title="wikilink">Damerau–Levenshtein distance</a></li>
<li><a class="uri" href="diff" title="wikilink">diff</a></li>
<li><a class="uri" href="MinHash" title="wikilink">MinHash</a></li>
<li><a href="Dynamic_time_warping" title="wikilink">Dynamic time warping</a></li>
<li><a href="Euclidean_distance" title="wikilink">Euclidean distance</a></li>
<li><a href="Fuzzy_string_searching" title="wikilink">Fuzzy string searching</a></li>
<li><a href="Hamming_weight" title="wikilink">Hamming weight</a></li>
<li><a href="Hirschberg's_algorithm" title="wikilink">Hirschberg's algorithm</a></li>
<li><a href="Homology_(biology)#Sequence_homology" title="wikilink">Homology of sequences in genetics</a></li>
<li><a href="Hunt–McIlroy_algorithm" title="wikilink">Hunt–McIlroy algorithm</a></li>
<li><a href="Jaccard_index" title="wikilink">Jaccard index</a></li>
<li><a href="Jaro–Winkler_distance" title="wikilink">Jaro–Winkler distance</a></li>
<li><a href="Levenshtein_automaton" title="wikilink">Levenshtein automaton</a></li>
<li><a href="Locality-sensitive_hashing" title="wikilink">Locality-sensitive hashing</a></li>
<li><a href="Longest_common_subsequence_problem" title="wikilink">Longest common subsequence problem</a></li>
<li><a class="uri" href="Lucene" title="wikilink">Lucene</a> (an open source search engine that implements edit distance)</li>
<li><a href="Manhattan_distance" title="wikilink">Manhattan distance</a></li>
<li><a href="Metric_space" title="wikilink">Metric space</a></li>
<li><a href="Most_frequent_k_characters" title="wikilink">Most frequent k characters</a></li>
<li><a href="Needleman–Wunsch_algorithm" title="wikilink">Needleman–Wunsch algorithm</a></li>
<li><a href="Optimal_matching" title="wikilink">Optimal matching</a> algorithm</li>
<li><a href="Sequence_alignment" title="wikilink">Sequence alignment</a></li>
<li><a href="Similarity_space" title="wikilink">Similarity space</a> on <a href="Numerical_taxonomy" title="wikilink">Numerical taxonomy</a></li>
<li><a href="Smith–Waterman_algorithm" title="wikilink">Smith–Waterman algorithm</a></li>
<li><a href="Sørensen_similarity_index" title="wikilink">Sørensen similarity index</a></li>
<li><a href="String_distance_metric" title="wikilink">String distance metric</a></li>
<li><a href="Wagner-Fischer_algorithm" title="wikilink">Wagner-Fischer algorithm</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.postgresql.org/docs/current/static/fuzzystrmatch.html">Levenshtein in PostgreSQL</a></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:String_similarity_measures" title="wikilink">Category:String similarity measures</a> <a href="Category:Dynamic_programming" title="wikilink">Category:Dynamic programming</a> <a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a> <a href="Category:Quantitative_linguistics" title="wikilink">Category:Quantitative linguistics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"> Appeared in English as: <a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="http://cs.stackexchange.com/a/2997">Micro-optimisation for edit distance computation: is it valid?</a><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>

