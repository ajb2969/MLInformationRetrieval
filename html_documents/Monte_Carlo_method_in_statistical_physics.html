<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="134">Monte Carlo method in statistical physics</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Monte Carlo method in statistical physics</h1>
<hr/>

<p><strong>Monte Carlo in statistical physics</strong> refers to the application of the <a href="Monte_Carlo_method" title="wikilink">Monte Carlo method</a> to problems in <a href="statistical_physics" title="wikilink">statistical physics</a>, or <a href="statistical_mechanics" title="wikilink">statistical mechanics</a>.</p>
<h2 id="overview">Overview</h2>

<p>The general motivation to use the Monte Carlo method in statistical physics is to evaluate a multivariable integral. The typical problem begins with a system for which the Hamiltonian is known, it is at a given temperature and it follows the <a href="Boltzmann_statistics" title="wikilink">Boltzmann statistics</a>. To obtain the mean value of some macroscopic variable, say A, the general approach is to compute, over all the <a href="phase_space" title="wikilink">phase space</a>, PS for simplicity, the mean value of A using the Boltzmann distribution:</p>

<p>

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:0">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>A</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mi>P</mi>
      <mi>S</mi>
     </mrow>
    </msub>
    <mrow>
     <msub>
      <mi>A</mi>
      <mover accent="true">
       <mi>r</mi>
       <mo stretchy="false">→</mo>
      </mover>
     </msub>
     <mfrac>
      <msup>
       <mi>e</mi>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>β</mi>
         <msub>
          <mi>E</mi>
          <mover accent="true">
           <mi>r</mi>
           <mo stretchy="false">→</mo>
          </mover>
         </msub>
        </mrow>
       </mrow>
      </msup>
      <mi>Z</mi>
     </mfrac>
     <mi>d</mi>
     <mover accent="true">
      <mi>r</mi>
      <mo stretchy="false">→</mo>
     </mover>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">delimited-⟨⟩</csymbol>
     <ci>A</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>r</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>β</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>E</ci>
           <apply>
            <ci>normal-→</ci>
            <ci>r</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <ci>Z</ci>
      </apply>
      <ci>d</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>r</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle A\rangle=\int_{PS}A_{\vec{r}}\frac{e^{-\beta E_{\vec{r}}}}{Z}d\vec{r}
  </annotation>
 </semantics>
</math>

.</p>

<p>where 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>r</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>E</mi>
    <mover accent="true">
     <mi>r</mi>
     <mo stretchy="false">→</mo>
    </mover>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\vec{r})=E_{\vec{r}}
  </annotation>
 </semantics>
</math>

 is the energy of the system for a given state defined by 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:2">
 <semantics>
  <mover accent="true">
   <mi>r</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{r}
  </annotation>
 </semantics>
</math>

 - a vector with all the degrees of freedom (for instance, for a mechanical system, 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:3">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>r</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mover accent="true">
     <mi>q</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo>,</mo>
    <mover accent="true">
     <mi>p</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-→</ci>
     <ci>r</ci>
    </apply>
    <interval closure="open">
     <apply>
      <ci>normal-→</ci>
      <ci>q</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <ci>p</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{r}=\left(\vec{q},\vec{p}\right)
  </annotation>
 </semantics>
</math>

), 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:4">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <msub>
      <mi>k</mi>
      <mi>b</mi>
     </msub>
    </mrow>
    <mi>T</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>β</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta\equiv 1/k_{b}T
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:5">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mi>P</mi>
      <mi>S</mi>
     </mrow>
    </msub>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>r</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mover accent="true">
      <mi>r</mi>
      <mo stretchy="false">→</mo>
     </mover>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Z</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>r</ci>
      </apply>
      <ci>d</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>r</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z=\int_{PS}P(\vec{r})d\vec{r}
  </annotation>
 </semantics>
</math>

</p>

<p>is the <a href="Partition_function_(statistical_mechanics)" title="wikilink">partition function</a>.</p>

<p>One possible approach to solve this multivariable integral is to exactly enumerate all possible configurations of the system, and calculate averages at will. This is done in exactly solvable systems, and in simulations of simple systems with few particles. In realistic systems, on the other hand, an exact enumeration can be difficult or impossible to implement.</p>

<p>For those systems, the <a href="Monte_Carlo_integration" title="wikilink">Monte Carlo integration</a> (and not to be confused with <a href="Monte_Carlo_method" title="wikilink">Monte Carlo method</a>, which is used to simulate molecular chains) is generally employed. The main motivation for its use is the fact that, with the Monte Carlo integration, the error goes as 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:6">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <msqrt>
    <mi>N</mi>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <root></root>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/\sqrt{N}
  </annotation>
 </semantics>
</math>

, independently of the dimension of the integral. Another important concept related to the Monte Carlo integration is the <a href="importance_sampling" title="wikilink">importance sampling</a>, a technique that improves the computational time of the simulation.</p>

<p>In the following sections, the general implementation of the Monte Carlo integration for solving this kind of problems is discussed.</p>
<h2 id="importance-sampling">Importance sampling</h2>

<p>An estimation, under Monte Carlo integration, of an integral defined as</p>

<p>

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:7">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>A</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mi>P</mi>
      <mi>S</mi>
     </mrow>
    </msub>
    <mrow>
     <mrow>
      <msub>
       <mi>A</mi>
       <mover accent="true">
        <mi>r</mi>
        <mo stretchy="false">→</mo>
       </mover>
      </msub>
      <msup>
       <mi>e</mi>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>β</mi>
         <msub>
          <mi>E</mi>
          <mover accent="true">
           <mi>r</mi>
           <mo stretchy="false">→</mo>
          </mover>
         </msub>
        </mrow>
       </mrow>
      </msup>
      <mi>d</mi>
      <mover accent="true">
       <mi>r</mi>
       <mo stretchy="false">→</mo>
      </mover>
     </mrow>
     <mo>/</mo>
     <mi>Z</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">delimited-⟨⟩</csymbol>
     <ci>A</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <apply>
         <ci>normal-→</ci>
         <ci>r</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>β</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>E</ci>
           <apply>
            <ci>normal-→</ci>
            <ci>r</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <ci>d</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>r</ci>
       </apply>
      </apply>
      <ci>Z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle A\rangle=\int_{PS}A_{\vec{r}}e^{-\beta E_{\vec{r}}}d\vec{r}/Z
  </annotation>
 </semantics>
</math>

</p>

<p>is</p>

<p>

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:8">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>A</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>≃</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>N</mi>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </msubsup>
     <mrow>
      <mrow>
       <msub>
        <mi>A</mi>
        <msub>
         <mover accent="true">
          <mi>r</mi>
          <mo stretchy="false">→</mo>
         </mover>
         <mi>i</mi>
        </msub>
       </msub>
       <msup>
        <mi>e</mi>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mi>β</mi>
          <msub>
           <mi>E</mi>
           <msub>
            <mover accent="true">
             <mi>r</mi>
             <mo stretchy="false">→</mo>
            </mover>
            <mi>i</mi>
           </msub>
          </msub>
         </mrow>
        </mrow>
       </msup>
      </mrow>
      <mo>/</mo>
      <mi>Z</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to-or-equals</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-⟨⟩</csymbol>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>A</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-→</ci>
           <ci>r</ci>
          </apply>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <ci>β</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>E</ci>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <apply>
              <ci>normal-→</ci>
              <ci>r</ci>
             </apply>
             <ci>i</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <ci>Z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle A\rangle\simeq\frac{1}{N}\sum_{i=1}^{N}A_{\vec{r}_{i}}e^{-\beta E_{%
\vec{r}_{i}}}/Z
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:9">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>r</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-→</ci>
     <ci>r</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{r}_{i}
  </annotation>
 </semantics>
</math>

 are uniformly obtained from all the phase space (PS) and N is the number of sampling points (or function evaluations).</p>

<p>From all the phase space, some zones of it are generally more important to the mean of the variable 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:10">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 than others. In particular, those that have the value of 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:11">
 <semantics>
  <msup>
   <mi>e</mi>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>β</mi>
     <msub>
      <mi>E</mi>
      <msub>
       <mover accent="true">
        <mi>r</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mi>i</mi>
      </msub>
     </msub>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>e</ci>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>β</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-→</ci>
         <ci>r</ci>
        </apply>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{-\beta E_{\vec{r}_{i}}}
  </annotation>
 </semantics>
</math>

 sufficiently high when compared to the rest of the energy spectra are the most relevant for the integral. Using this fact, the natural question to ask is: is it possible to choose, with more frequency, the states that are known to be more relevant to the integral? The answer is yes, using the <a href="importance_sampling" title="wikilink">importance sampling</a> technique.</p>

<p>Lets assume 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:12">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>r</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\vec{r})
  </annotation>
 </semantics>
</math>

 is a distribution that chooses the states that are known to be more relevant to the integral.</p>

<p>The mean value of 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:13">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 can be rewritten as</p>

<p>

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:14">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>A</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mi>P</mi>
      <mi>S</mi>
     </mrow>
    </msub>
    <mrow>
     <mrow>
      <mrow>
       <msup>
        <mi>p</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mover accent="true">
         <mi>r</mi>
         <mo stretchy="false">→</mo>
        </mover>
        <mo stretchy="false">)</mo>
       </mrow>
       <mfrac>
        <msub>
         <mi>A</mi>
         <mover accent="true">
          <mi>r</mi>
          <mo stretchy="false">→</mo>
         </mover>
        </msub>
        <mrow>
         <msup>
          <mi>p</mi>
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mover accent="true">
           <mi>r</mi>
           <mo stretchy="false">→</mo>
          </mover>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mfrac>
       <msup>
        <mi>e</mi>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mi>β</mi>
          <msub>
           <mi>E</mi>
           <mover accent="true">
            <mi>r</mi>
            <mo stretchy="false">→</mo>
           </mover>
          </msub>
         </mrow>
        </mrow>
       </msup>
      </mrow>
      <mo>/</mo>
      <mi>Z</mi>
     </mrow>
     <mi>d</mi>
     <mover accent="true">
      <mi>r</mi>
      <mo stretchy="false">→</mo>
     </mover>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mi>P</mi>
      <mi>S</mi>
     </mrow>
    </msub>
    <mrow>
     <mrow>
      <mrow>
       <msup>
        <mi>p</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mover accent="true">
         <mi>r</mi>
         <mo stretchy="false">→</mo>
        </mover>
        <mo stretchy="false">)</mo>
       </mrow>
       <msubsup>
        <mi>A</mi>
        <mover accent="true">
         <mi>r</mi>
         <mo stretchy="false">→</mo>
        </mover>
        <mo>*</mo>
       </msubsup>
       <msup>
        <mi>e</mi>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mi>β</mi>
          <msub>
           <mi>E</mi>
           <mover accent="true">
            <mi>r</mi>
            <mo stretchy="false">→</mo>
           </mover>
          </msub>
         </mrow>
        </mrow>
       </msup>
      </mrow>
      <mo>/</mo>
      <mi>Z</mi>
     </mrow>
     <mi>d</mi>
     <mover accent="true">
      <mi>r</mi>
      <mo stretchy="false">→</mo>
     </mover>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <ci>A</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <times></times>
        <ci>P</ci>
        <ci>S</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>p</ci>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <ci>normal-→</ci>
          <ci>r</ci>
         </apply>
         <apply>
          <divide></divide>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>A</ci>
           <apply>
            <ci>normal-→</ci>
            <ci>r</ci>
           </apply>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>p</ci>
            <apply>
             <minus></minus>
             <cn type="integer">1</cn>
            </apply>
           </apply>
           <apply>
            <ci>normal-→</ci>
            <ci>r</ci>
           </apply>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>e</ci>
          <apply>
           <minus></minus>
           <apply>
            <times></times>
            <ci>β</ci>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>E</ci>
             <apply>
              <ci>normal-→</ci>
              <ci>r</ci>
             </apply>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
        <ci>Z</ci>
       </apply>
       <ci>d</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>r</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <times></times>
        <ci>P</ci>
        <ci>S</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>p</ci>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <ci>normal-→</ci>
          <ci>r</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>A</ci>
           <times></times>
          </apply>
          <apply>
           <ci>normal-→</ci>
           <ci>r</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>e</ci>
          <apply>
           <minus></minus>
           <apply>
            <times></times>
            <ci>β</ci>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>E</ci>
             <apply>
              <ci>normal-→</ci>
              <ci>r</ci>
             </apply>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
        <ci>Z</ci>
       </apply>
       <ci>d</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>r</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle A\rangle=\int_{PS}p^{-1}(\vec{r})\frac{A_{\vec{r}}}{p^{-1}(\vec{r})}e^%
{-\beta E_{\vec{r}}}/Zd\vec{r}=\int_{PS}p^{-1}(\vec{r})A^{*}_{\vec{r}}e^{-%
\beta E_{\vec{r}}}/Zd\vec{r}
  </annotation>
 </semantics>
</math>

,</p>

<p>where 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:15">
 <semantics>
  <msubsup>
   <mi>A</mi>
   <mover accent="true">
    <mi>r</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mo>*</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <times></times>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{*}_{\vec{r}}
  </annotation>
 </semantics>
</math>

 are the sampled values taking into account the importance probability 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:16">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>r</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\vec{r})
  </annotation>
 </semantics>
</math>

. This integral can be estimated by</p>

<p>

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:17">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>A</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>≃</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>N</mi>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </msubsup>
     <mrow>
      <mrow>
       <msup>
        <mi>p</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mover accent="true">
          <mi>r</mi>
          <mo stretchy="false">→</mo>
         </mover>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <msubsup>
        <mi>A</mi>
        <msub>
         <mover accent="true">
          <mi>r</mi>
          <mo stretchy="false">→</mo>
         </mover>
         <mi>i</mi>
        </msub>
        <mo>*</mo>
       </msubsup>
       <msup>
        <mi>e</mi>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mi>β</mi>
          <msub>
           <mi>E</mi>
           <msub>
            <mover accent="true">
             <mi>r</mi>
             <mo stretchy="false">→</mo>
            </mover>
            <mi>i</mi>
           </msub>
          </msub>
         </mrow>
        </mrow>
       </msup>
      </mrow>
      <mo>/</mo>
      <mi>Z</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to-or-equals</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-⟨⟩</csymbol>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>p</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-→</ci>
          <ci>r</ci>
         </apply>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>A</ci>
          <times></times>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-→</ci>
           <ci>r</ci>
          </apply>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <ci>β</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>E</ci>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <apply>
              <ci>normal-→</ci>
              <ci>r</ci>
             </apply>
             <ci>i</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <ci>Z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle A\rangle\simeq\frac{1}{N}\sum_{i=1}^{N}p^{-1}(\vec{r}_{i})A^{*}_{\vec{%
r}_{i}}e^{-\beta E_{\vec{r}_{i}}}/Z
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:18">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>r</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-→</ci>
     <ci>r</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{r}_{i}
  </annotation>
 </semantics>
</math>

 are now randomly generated using the 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:19">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>r</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\vec{r})
  </annotation>
 </semantics>
</math>

 distribution. Since most of the times it is not easy to find a way of generating states with a given distribution, the <a href="Metropolis_algorithm" title="wikilink">Metropolis algorithm</a> must be used.</p>
<h3 id="canonical">Canonical</h3>

<p>Because it is known that the most likely states are those that maximize the Boltzmann distribution, a good distribution, 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:20">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>r</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\vec{r})
  </annotation>
 </semantics>
</math>

, to choose for the importance sampling is the Boltzmann distribution or canonic distribution. Let</p>

<p>

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>r</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>β</mi>
       <msub>
        <mi>E</mi>
        <mover accent="true">
         <mi>r</mi>
         <mo stretchy="false">→</mo>
        </mover>
       </msub>
      </mrow>
     </mrow>
    </msup>
    <mi>Z</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>β</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>E</ci>
         <apply>
          <ci>normal-→</ci>
          <ci>r</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\vec{r})=\frac{e^{-\beta E_{\vec{r}}}}{Z}
  </annotation>
 </semantics>
</math>

</p>

<p>be the distribution to use. Substituting on the previous sum,</p>

<p>

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:22">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>A</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>≃</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>N</mi>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </msubsup>
     <msubsup>
      <mi>A</mi>
      <msub>
       <mover accent="true">
        <mi>r</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mi>i</mi>
      </msub>
      <mo>*</mo>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to-or-equals</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-⟨⟩</csymbol>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <times></times>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-→</ci>
         <ci>r</ci>
        </apply>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle A\rangle\simeq\frac{1}{N}\sum_{i=1}^{N}A^{*}_{\vec{r}_{i}}
  </annotation>
 </semantics>
</math>

.</p>

<p>So, the procedure to obtain a mean value of a given variable, using metropolis algorithm, with the canonical distribution, is to use the Metropolis algorithm to generate states given by the distribution 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:23">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>r</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\vec{r})
  </annotation>
 </semantics>
</math>

 and perform means over 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:24">
 <semantics>
  <msubsup>
   <mi>A</mi>
   <mover accent="true">
    <mi>r</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mo>*</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <times></times>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{*}_{\vec{r}}
  </annotation>
 </semantics>
</math>

.</p>

<p>One important issue must be considered when using the metropolis algorithm with the canonical distribution: when performing a given measure, i.e. realization of 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:25">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>r</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-→</ci>
     <ci>r</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{r}_{i}
  </annotation>
 </semantics>
</math>

, one must ensure that that realization is not correlated with the previous state of the system (otherwise the states are not being "randomly" generated). On systems with relevant energy gaps, this is the major drawback of the use of the canonical distribution because the time needed to the system de-correlate from the previous state can tend to infinity.</p>
<h3 id="multi-canonical">Multi-canonical</h3>

<p>As stated before, micro-canonical approach has a major drawback, which becomes relevant in most of the systems that use Monte Carlo Integration. For those systems with "rough energy landscapes", the multicanonic approach can be used.</p>

<p>The multicanonic approach uses a different choice for importance sampling:</p>

<p>

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>r</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi mathvariant="normal">Ω</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>E</mi>
       <mover accent="true">
        <mi>r</mi>
        <mo stretchy="false">→</mo>
       </mover>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>normal-Ω</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>r</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\vec{r})=\frac{1}{\Omega(E_{\vec{r}})}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:27">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(E)
  </annotation>
 </semantics>
</math>

 is the <a href="density_of_states" title="wikilink">density of states</a> of the system. The major advantage of this choice is that the energy histogram is flat, i.e. the generated states are equally distributed on energy. This means that, when using the Metropolis algorithm, the simulation doesn't see the "rough energy landscape", because every energy is treated equally.</p>

<p>The major drawback of this choice is the fact that, on most systems, 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:28">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(E)
  </annotation>
 </semantics>
</math>

 is unknown. To overcome this, the <a href="Wang_and_Landau_algorithm" title="wikilink">Wang and Landau algorithm</a> is normally used to obtain the DOS during the simulation. Note that after the DOS is known, the mean values of every variable can be calculated for every temperature, since the generation of states does not depend on 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:29">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="implementation">Implementation</h2>

<p>On this section, the implementation will focus on the <a href="Ising_model" title="wikilink">Ising model</a>. Lets consider a two-dimensional spin network, with L spins (lattice sites) on each side. There are naturally 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:30">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <msup>
    <mi>L</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>L</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=L^{2}
  </annotation>
 </semantics>
</math>

 spins, and so, the phase space is discrete and is characterized by N spins, 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:31">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>r</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>σ</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>σ</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>σ</mi>
     <mi>N</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-→</ci>
     <ci>r</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>N</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{r}=(\sigma_{1},\sigma_{2},...,\sigma_{N})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:32">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>i</ci>
    </apply>
    <set>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{i}\in\{-1,1\}
  </annotation>
 </semantics>
</math>

 is the spin of each lattice site. The system's energy is given by 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>r</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </msubsup>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>∈</mo>
       <mrow>
        <mi>v</mi>
        <mi>i</mi>
        <msub>
         <mi>z</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>J</mi>
         <mrow>
          <mi>i</mi>
          <mi>j</mi>
         </mrow>
        </msub>
        <msub>
         <mi>σ</mi>
         <mi>i</mi>
        </msub>
        <msub>
         <mi>σ</mi>
         <mi>j</mi>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>j</ci>
        <apply>
         <times></times>
         <ci>v</ci>
         <ci>i</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>J</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(\vec{r})=\sum_{i=1}^{N}\sum_{j\in viz_{i}}(1-J_{ij}\sigma_{i}\sigma_{j})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:34">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mi>i</mi>
   <msub>
    <mi>z</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>v</ci>
    <ci>i</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   viz_{i}
  </annotation>
 </semantics>
</math>

 are the set of first neighborhood spins of i and J is the interaction matrix (for a ferromagnetic ising model, J is the identity matrix). The problem is stated.</p>

<p>On this example, the objective is to obtain 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:35">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>M</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-⟨⟩</csymbol>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle M\rangle
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:36">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <msup>
    <mi>M</mi>
    <mn>2</mn>
   </msup>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-⟨⟩</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>M</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle M^{2}\rangle
  </annotation>
 </semantics>
</math>

 (for instance, to obtain the <a href="magnetic_susceptibility" title="wikilink">magnetic susceptibility</a> of the system) since it is straightforward to generalize to other observables. According to the definition, 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>r</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>N</mi>
    </msubsup>
    <msub>
     <mi>σ</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>M</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M(\vec{r})=\sum_{i=1}^{N}\sigma_{i}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="canonical-1">Canonical</h3>

<p>First, the system must be initialized: let 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:38">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <msub>
      <mi>k</mi>
      <mi>b</mi>
     </msub>
    </mrow>
    <mi>T</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>β</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta=1/k_{b}T
  </annotation>
 </semantics>
</math>

 be the system's Boltzmann temperature and initialize the system with an initial state (which can be anything since the final result should not depend on it).</p>

<p>With micro-canonic choice, the metropolis method must be employed. Because there is no right way of choosing which state is to be picked, one can particularize and choose to try to flip one spin at the time. This choice is usually called <em>single spin flip</em>. The following steps are to be made to perform a single measurement.</p>

<p>step 1: generate a state that follows the 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:39">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>r</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\vec{r})
  </annotation>
 </semantics>
</math>

 distribution:</p>

<p>step 1.1: Perform TT times the following iteration:</p>

<p>step 1.1.1: pick a lattice site at random (with probability 1/N), which will be called i, with spin 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:40">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{i}
  </annotation>
 </semantics>
</math>

.</p>

<p>step 1.1.2: pick a random number 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:41">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>α</ci>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\in[0,1]
  </annotation>
 </semantics>
</math>

.</p>

<p>step 1.1.3: calculate the energy change of trying to flip the spin i:</p>

<p>

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:42">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>E</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <msub>
     <mi>σ</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>∈</mo>
       <mrow>
        <mi>v</mi>
        <mi>i</mi>
        <msub>
         <mi>z</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mrow>
     </msub>
     <msub>
      <mi>σ</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>E</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>j</ci>
        <apply>
         <times></times>
         <ci>v</ci>
         <ci>i</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta E=2\sigma_{i}\sum_{j\in viz_{i}}\sigma_{j}
  </annotation>
 </semantics>
</math>

</p>

<p>and its magnetization change

<math display="block" id="Monte_Carlo_method_in_statistical_physics:43">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>M</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <msub>
      <mi>σ</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta M=-2\sigma_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>step 1.1.4: if 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:44">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo><</mo>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo>,</mo>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>β</mi>
        <mi mathvariant="normal">Δ</mi>
        <mi>E</mi>
       </mrow>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>α</ci>
    <apply>
     <min></min>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>β</ci>
        <ci>normal-Δ</ci>
        <ci>E</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha<\min(1,e^{-\beta\Delta E})
  </annotation>
 </semantics>
</math>

, flip the spin (

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:45">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <msub>
     <mi>σ</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{i}=-\sigma_{i}
  </annotation>
 </semantics>
</math>

 ), otherwise, don't.</p>

<p>step 1.1.5: update the several macroscopic variables in case the spin flipped

<math display="block" id="Monte_Carlo_method_in_statistical_physics:46">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mo>+</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>E</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>E</ci>
    <apply>
     <plus></plus>
     <ci>E</ci>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>E</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=E+\Delta E
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:47">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mrow>
    <mi>M</mi>
    <mo>+</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>M</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <apply>
     <plus></plus>
     <ci>M</ci>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=M+\Delta M
  </annotation>
 </semantics>
</math>

</p>

<p>after TT times, the system is considered to be not correlated from its previous state, which means that, at this moment, the probability of the system to be on a given state follows the Boltzmann distribution, which is the objective proposed by this method.</p>

<p>step 2 -&gt; perform the measurement:</p>

<p>step 2.1: save, on an histogram, the values of M and M^2.</p>

<p>As a final note, one should note that TT is not easy to estimate because it is not easy to say when the system is de-correlated from the previous state. To surpass this point, one generally do not use a fixed TT, but TT as a <em>tunneling time</em>. One tunneling time is defined as the number of steps 1. the system needs to make to go from the minimum of its energy to the maximum of its energy and return.</p>

<p>A major drawback of this method with the <em>single spin flip</em> choice in systems like Ising model is that the tunneling time scales as a power law as 

<math display="inline" id="Monte_Carlo_method_in_statistical_physics:48">
 <semantics>
  <msup>
   <mi>N</mi>
   <mrow>
    <mn>2</mn>
    <mo>+</mo>
    <mi>z</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>N</ci>
    <apply>
     <plus></plus>
     <cn type="integer">2</cn>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N^{2+z}
  </annotation>
 </semantics>
</math>

 where z is greater than 0.5, phenomenon known as <em>critical slowing down</em>.</p>
<h2 id="applicability">Applicability</h2>

<p>The method thus neglects dynamics, which can be a major drawback, or a great advantage. Indeed, the method can only be applied to static quantities, but the freedom to choose moves makes the method very flexible. An additional advantage is that some systems, such as the <a href="Ising_model" title="wikilink">Ising model</a>, lack a dynamical description and are only defined by an energy prescription; for these the Monte Carlo approach is the only one feasible.</p>
<h2 id="generalizations">Generalizations</h2>

<p>The great success of this method in statistical mechanics has led to various generalizations such as the method of <a href="simulated_annealing" title="wikilink">simulated annealing</a> for optimization, in which a fictitious temperature is introduced and then gradually lowered.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Monte_Carlo_integration" title="wikilink">Monte Carlo integration</a></li>
<li><a href="Metropolis_algorithm" title="wikilink">Metropolis algorithm</a></li>
<li><a href="Importance_sampling" title="wikilink">Importance sampling</a></li>
<li><a href="Quantum_Monte_Carlo" title="wikilink">Quantum Monte Carlo</a></li>
<li><a href="Monte_Carlo_molecular_modeling" title="wikilink">Monte Carlo molecular modeling</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Computational_chemistry" title="wikilink">Category:Computational chemistry</a> <a href="Category:Theoretical_chemistry" title="wikilink">Category:Theoretical chemistry</a> <a href="Category:Computational_physics" title="wikilink">Category:Computational physics</a></p>
</body>
</html>
