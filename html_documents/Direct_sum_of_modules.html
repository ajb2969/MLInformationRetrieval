<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1816">Direct sum of modules</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Direct sum of modules</h1>
<hr/>

<p>In <a href="abstract_algebra" title="wikilink">abstract algebra</a>, the <strong>direct sum</strong> is a construction which combines several <a href="module_(mathematics)" title="wikilink">modules</a> into a new, larger module. The direct sum of modules is the smallest module which contains the given modules as submodules with no "unnecessary" constraints, making it an example of a <a class="uri" href="coproduct" title="wikilink">coproduct</a>. Contrast with the <a href="direct_product" title="wikilink">direct product</a>, which is the <a href="duality_(category_theory)" title="wikilink">dual</a> notion.</p>

<p>The most familiar examples of this construction occur when considering <a href="vector_space" title="wikilink">vector spaces</a> (modules over a <a href="field_(mathematics)" title="wikilink">field</a>) and <a href="abelian_group" title="wikilink">abelian groups</a> (modules over the ring <strong>Z</strong> of <a href="integer" title="wikilink">integers</a>). The construction may also be extended to cover <a href="Banach_space" title="wikilink">Banach spaces</a> and <a href="Hilbert_space" title="wikilink">Hilbert spaces</a>.</p>
<h2 id="construction-for-vector-spaces-and-abelian-groups">Construction for vector spaces and abelian groups</h2>

<p>We give the construction first in these two cases, under the assumption that we have only two objects. Then we generalise to an arbitrary family of arbitrary modules. The key elements of the general construction are more clearly identified by considering these two cases in depth.</p>
<h3 id="construction-for-two-vector-spaces">Construction for two vector spaces</h3>

<p>Suppose <em>V</em> and <em>W</em> are <a href="vector_space" title="wikilink">vector spaces</a> over the <a href="field_(mathematics)" title="wikilink">field</a> <em>K</em>. The <a href="cartesian_product" title="wikilink">cartesian product</a> <em>V</em> × <em>W</em> can be given the structure of a vector space over <em>K</em>  by defining the operations componentwise:</p>
<ul>
<li>(<em>v</em><sub>1</sub>, <em>w</em><sub>1</sub>) + (<em>v</em><sub>2</sub>, <em>w</em><sub>2</sub>) = (<em>v</em><sub>1</sub> + <em>v</em><sub>2</sub>, <em>w</em><sub>1</sub> + <em>w</em><sub>2</sub>)</li>
<li>α (<em>v</em>, <em>w</em>) = (α <em>v</em>, α <em>w</em>)</li>
</ul>

<p>for <em>v</em>, <em>v</em><sub>1</sub>, <em>v</em><sub>2</sub> ∈ <em>V</em>, <em>w</em>, <em>w</em><sub>1</sub>, <em>w</em><sub>2</sub> ∈ <em>W</em>, and α ∈ <em>K</em>.</p>

<p>The resulting vector space is called the <em>direct sum</em> of <em>V</em> and <em>W</em> and is usually denoted by a plus symbol inside a circle:</p>

<p>
<math display="block" id="Direct_sum_of_modules:0">
<semantics>
<mrow>
<mi>V</mi>
<mo>⊕</mo>
<mi>W</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">direct-sum</csymbol>
<ci>V</ci>
<ci>W</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   V\oplus W
  </annotation>
</semantics>
</math>
</p>

<p>It is customary to write the elements of an ordered sum not as ordered pairs (<em>v</em>, <em>w</em>), but as a sum <em>v</em> + <em>w</em>.</p>

<p>The subspace <em>V</em> × {0} of <em>V</em> ⊕ <em>W</em> is isomorphic to <em>V</em> and is often identified with <em>V</em>; similarly for {0} × <em>W</em> and <em>W</em>. (See <em>internal direct sum</em> below.) With this identification, every element of <em>V</em> ⊕ <em>W</em> can be written in one and only one way as the sum of an element of <em>V</em> and an element of <em>W</em>. The <a href="dimension_of_a_vector_space" title="wikilink">dimension</a> of <em>V</em> ⊕ <em>W</em> is equal to the sum of the dimensions of <em>V</em> and <em>W</em>.</p>

<p>This construction readily generalises to any <a href="finite_set" title="wikilink">finite</a> number of vector spaces.</p>
<h3 id="construction-for-two-abelian-groups">Construction for two abelian groups</h3>

<p>For <a href="abelian_group" title="wikilink">abelian groups</a> <em>G</em> and <em>H</em> which are written additively, the <a href="direct_product" title="wikilink">direct product</a> of <em>G</em> and <em>H</em> is also called a direct sum . Thus the <a href="cartesian_product" title="wikilink">cartesian product</a> <em>G</em> × <em>H</em> is equipped with the structure of an abelian group by defining the operations componentwise:</p>
<ul>
<li>(<em>g</em><sub>1</sub>, <em>h</em><sub>1</sub>) + (<em>g</em><sub>2</sub>, <em>h</em><sub>2</sub>) = (<em>g</em><sub>1</sub> + <em>g</em><sub>2</sub>, <em>h</em><sub>1</sub> + <em>h</em><sub>2</sub>)</li>
</ul>

<p>for <em>g</em><sub>1</sub>, <em>g</em><sub>2</sub> in <em>G</em>, and <em>h</em><sub>1</sub>, <em>h</em><sub>2</sub> in <em>H</em>.</p>

<p>Integral multiples are similarly defined componentwise by</p>
<ul>
<li><em>n</em>(<em>g</em>, <em>h</em>) = (<em>ng</em>, <em>nh</em>)</li>
</ul>

<p>for <em>g</em> in <em>G</em>, <em>h</em> in <em>H</em>, and <em>n</em> an <a class="uri" href="integer" title="wikilink">integer</a>. This parallels the extension of the scalar product of vector spaces to the direct sum above.</p>

<p>The resulting abelian group is called the <em>direct sum</em> of <em>G</em> and <em>H</em> and is usually denoted by a plus symbol inside a circle:</p>

<p>
<math display="block" id="Direct_sum_of_modules:1">
<semantics>
<mrow>
<mi>G</mi>
<mo>⊕</mo>
<mi>H</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">direct-sum</csymbol>
<ci>G</ci>
<ci>H</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   G\oplus H
  </annotation>
</semantics>
</math>
</p>

<p>It is customary to write the elements of an ordered sum not as ordered pairs (<em>g</em>, <em>h</em>), but as a sum <em>g</em> + <em>h</em>.</p>

<p>The subgroup <em>G</em> × {0} of <em>G</em> ⊕ <em>H</em> is isomorphic to <em>G</em> and is often identified with <em>G</em>; similarly for {0} × <em>H</em> and <em>H</em>. (See <em>internal direct sum</em> below.) With this identification, it is true that every element of <em>G</em> ⊕ <em>H</em> can be written in one and only one way as the sum of an element of <em>G</em> and an element of <em>H</em>. The <a href="rank_of_an_abelian_group" title="wikilink">rank</a> of <em>G</em> ⊕ <em>H</em> is equal to the sum of the ranks of <em>G</em> and <em>H</em>.</p>

<p>This construction readily generalises to any <a href="finite_set" title="wikilink">finite</a> number of abelian groups.</p>
<h2 id="construction-for-an-arbitrary-family-of-modules">Construction for an arbitrary family of modules</h2>

<p>One should notice a clear similarity between the definitions of the direct sum of two vector spaces and of two abelian groups. In fact, each is a special case of the construction of the direct sum of two <a href="module_(mathematics)" title="wikilink">modules</a>. Additionally, by modifying the definition one can accommodate the direct sum of an infinite family of modules. The precise definition is as follows .</p>

<p>Let <em>R</em> be a ring, and {<em>M</em><sub><em>i</em></sub> : <em>i</em> ∈ <em>I</em>} a <a href="indexed_family" title="wikilink">family</a> of left <em>R</em>-modules indexed by the <a href="Set_(mathematics)" title="wikilink">set</a> <em>I</em>. The <em>direct sum</em> of {<em>M</em><sub><em>i</em></sub>} is then defined to be the set of all sequences 

<math display="inline" id="Direct_sum_of_modules:2">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>α</mi>
<mi>i</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>α</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (\alpha_{i})
  </annotation>
</semantics>
</math>

 where 

<math display="inline" id="Direct_sum_of_modules:3">
<semantics>
<mrow>
<msub>
<mi>α</mi>
<mi>i</mi>
</msub>
<mo>∈</mo>
<msub>
<mi>M</mi>
<mi>i</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>α</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>i</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \alpha_{i}\in M_{i}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Direct_sum_of_modules:4">
<semantics>
<mrow>
<msub>
<mi>α</mi>
<mi>i</mi>
</msub>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>α</ci>
<ci>i</ci>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \alpha_{i}=0
  </annotation>
</semantics>
</math>

 for <a href="cofinitely_many" title="wikilink">cofinitely many</a> indices <em>i</em>. (The <a href="direct_product" title="wikilink">direct product</a> is analogous but the indices do not need to cofinitely vanish.)</p>

<p>It can also be defined as <a href="function_(mathematics)" title="wikilink">functions</a> α from <em>I</em> to the <a href="disjoint_union" title="wikilink">disjoint union</a> of the modules <em>M</em><sub><em>i</em></sub> such that α(<em>i</em>) ∈ <em>M</em><sub><em>i</em></sub> for all <em>i</em> ∈ <em>I</em> and α(<em>i</em>) = 0 for <a href="cofinitely_many" title="wikilink">cofinitely many</a> indices <em>i</em>. These functions can equivalently be regarded as <a href="compact_support" title="wikilink">finitely supported</a> sections of the <a href="fiber_bundle" title="wikilink">fiber bundle</a> over the index set <em>I</em>, with the fiber over 

<math display="inline" id="Direct_sum_of_modules:5">
<semantics>
<mrow>
<mi>i</mi>
<mo>∈</mo>
<mi>I</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>i</ci>
<ci>I</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   i\in I
  </annotation>
</semantics>
</math>

 being 

<math display="inline" id="Direct_sum_of_modules:6">
<semantics>
<msub>
<mi>M</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   M_{i}
  </annotation>
</semantics>
</math>

.</p>

<p>This set inherits the module structure via component-wise addition and scalar multiplication. Explicitly, two such sequences (or functions) α and β can be added by writing 

<math display="inline" id="Direct_sum_of_modules:7">
<semantics>
<mrow>
<msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>α</mi>
<mo>+</mo>
<mi>β</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>i</mi>
</msub>
<mo>=</mo>
<mrow>
<msub>
<mi>α</mi>
<mi>i</mi>
</msub>
<mo>+</mo>
<msub>
<mi>β</mi>
<mi>i</mi>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<plus></plus>
<ci>α</ci>
<ci>β</ci>
</apply>
<ci>i</ci>
</apply>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>α</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>β</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (\alpha+\beta)_{i}=\alpha_{i}+\beta_{i}
  </annotation>
</semantics>
</math>

 for all <em>i</em> (note that this is again zero for all but finitely many indices), and such a function can be multiplied with an element <em>r</em> from <em>R</em> by defining 

<math display="inline" id="Direct_sum_of_modules:8">
<semantics>
<mrow>
<mrow>
<mi>r</mi>
<msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>α</mi>
<mo stretchy="false">)</mo>
</mrow>
<mi>i</mi>
</msub>
</mrow>
<mo>=</mo>
<msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>r</mi>
<mi>α</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>i</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>r</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>α</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<times></times>
<ci>r</ci>
<ci>α</ci>
</apply>
<ci>i</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   r(\alpha)_{i}=(r\alpha)_{i}
  </annotation>
</semantics>
</math>

 for all <em>i</em>. In this way, the direct sum becomes a left <em>R</em>-module, and it is denoted</p>

<p>
<math display="block" id="Direct_sum_of_modules:9">
<semantics>
<mrow>
<mrow>
<munder>
<mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
<mrow>
<mi>i</mi>
<mo>∈</mo>
<mi>I</mi>
</mrow>
</munder>
<msub>
<mi>M</mi>
<mi>i</mi>
</msub>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">direct-sum</csymbol>
<apply>
<in></in>
<ci>i</ci>
<ci>I</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>i</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \bigoplus_{i\in I}M_{i}.
  </annotation>
</semantics>
</math>
</p>

<p>It is customary to write the sequence 

<math display="inline" id="Direct_sum_of_modules:10">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>α</mi>
<mi>i</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>α</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (\alpha_{i})
  </annotation>
</semantics>
</math>

 as a sum 

<math display="inline" id="Direct_sum_of_modules:11">
<semantics>
<mrow>
<mi mathvariant="normal">Σ</mi>
<msub>
<mi>α</mi>
<mi>i</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>normal-Σ</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>α</ci>
<ci>i</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Sigma\alpha_{i}
  </annotation>
</semantics>
</math>

. Sometimes a primed summation 

<math display="inline" id="Direct_sum_of_modules:12">
<semantics>
<mrow>
<msup>
<mi mathvariant="normal">Σ</mi>
<mo>′</mo>
</msup>
<msub>
<mi>α</mi>
<mi>i</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>normal-Σ</ci>
<ci>normal-′</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>α</ci>
<ci>i</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Sigma^{\prime}\alpha_{i}
  </annotation>
</semantics>
</math>

 is used to indicate that <a href="cofinitely_many" title="wikilink">cofinitely many</a> of the terms are zero.</p>
<h2 id="properties">Properties</h2>
<ul>
<li>The direct sum is a <a class="uri" href="submodule" title="wikilink">submodule</a> of the <a href="direct_product" title="wikilink">direct product</a> of the modules <em>M</em><sub><em>i</em></sub> . The direct product is the set of all functions <em>α</em> from <em>I</em> to the disjoint union of the modules <em>M</em><sub><em>i</em></sub> with <em>α</em>(<em>i</em>)∈<em>M</em><sub><em>i</em></sub>, but not necessarily vanishing for all but finitely many <em>i</em>. If the index set <em>I</em> is finite, then the direct sum and the direct product are equal.</li>
<li>Each of the modules <em>M</em><sub><em>i</em></sub> may be identified with the submodule of the direct sum consisting of those functions which vanish on all indices different from <em>i</em>. With these identifications, every element <em>x</em> of the direct sum can be written in one and only one way as a sum of finitely many elements from the modules <em>M</em><sub><em>i</em></sub>.</li>
<li>If the <em>M</em><sub><em>i</em></sub> are actually vector spaces, then the dimension of the direct sum is equal to the sum of the dimensions of the <em>M</em><sub><em>i</em></sub>. The same is true for the <a href="rank_of_an_abelian_group" title="wikilink">rank of abelian groups</a> and the <a href="length_of_a_module" title="wikilink">length of modules</a>.</li>
<li>Every vector space over the field <em>K</em> is isomorphic to a direct sum of sufficiently many copies of <em>K</em>, so in a sense only these direct sums have to be considered. This is not true for modules over arbitrary rings.</li>
<li>The <a href="tensor_product" title="wikilink">tensor product</a> distributes over direct sums in the following sense: if <em>N</em> is some right <em>R</em>-module, then the direct sum of the tensor products of <em>N</em> with <em>M</em><sub><em>i</em></sub> (which are abelian groups) is naturally isomorphic to the tensor product of <em>N</em> with the direct sum of the <em>M</em><sub><em>i</em></sub>.</li>
<li>Direct sums are also commutative and associative (up to isomorphism), meaning that it doesn't matter in which order one forms the direct sum.</li>
<li>The group of <em>R</em>-linear homomorphisms from the direct sum to some left <em>R</em>-module <em>L</em> is naturally isomorphic to the <a href="direct_product" title="wikilink">direct product</a> of the groups of <em>R</em>-linear homomorphisms from <em>M</em><sub><em>i</em></sub> to <em>L</em>:
<dl>
<dd><dl>
<dd>
<math display="inline" id="Direct_sum_of_modules:13">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Hom</mo>
<mi>R</mi>
</msub>
<mrow>
<mo maxsize="210%" minsize="210%">(</mo>
<mrow>
<msub>
<mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⊕</mo>
<mrow>
<mi>i</mi>
<mo>∈</mo>
<mi>I</mi>
</mrow>
</msub>
<msub>
<mi>M</mi>
<mi>i</mi>
</msub>
</mrow>
<mo>,</mo>
<mi>L</mi>
<mo maxsize="210%" minsize="210%">)</mo>
</mrow>
</mrow>
<mo>≅</mo>
<mrow>
<msub>
<mo largeop="true" symmetric="true">∏</mo>
<mrow>
<mi>i</mi>
<mo>∈</mo>
<mi>I</mi>
</mrow>
</msub>
<mrow>
<msub>
<mo>Hom</mo>
<mi>R</mi>
</msub>
<mrow>
<mo>(</mo>
<msub>
<mi>M</mi>
<mi>i</mi>
</msub>
<mo>,</mo>
<mi>L</mi>
<mo>)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<approx></approx>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Hom</ci>
<ci>R</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">direct-sum</csymbol>
<apply>
<in></in>
<ci>i</ci>
<ci>I</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>i</ci>
</apply>
</apply>
<ci>L</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">product</csymbol>
<apply>
<in></in>
<ci>i</ci>
<ci>I</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Hom</ci>
<ci>R</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>i</ci>
</apply>
<ci>L</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Hom}_{R}\biggl(\bigoplus_{i\in I}M_{i},L\biggr)\cong\prod_{i\in I%
}\operatorname{Hom}_{R}\left(M_{i},L\right).
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
<dd>Indeed, there is clearly a homomorphism <em>τ</em> from the left hand side to the right hand side, where <em>τ</em>(<em>θ</em>)(i) is the <em>R</em>-linear homomorphism sending <em>x</em>∈<em>M</em><sub><em>i</em></sub> to <em>θ</em>(<em>x</em>) (using the natural inclusion of <em>M</em><sub><em>i</em></sub> into the direct sum). The inverse of the homomorphism <em>τ</em> is defined by
</dd>
<dd>
<math display="inline" id="Direct_sum_of_modules:14">
<semantics>
<mrow>
<mrow>
<msup>
<mi>τ</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>β</mi>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>α</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mo largeop="true" symmetric="true">∑</mo>
<mrow>
<mi>i</mi>
<mo>∈</mo>
<mi>I</mi>
</mrow>
</msub>
<mrow>
<mi>β</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>i</mi>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>α</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>i</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>τ</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>β</ci>
<ci>α</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<in></in>
<ci>i</ci>
<ci>I</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>β</ci>
<ci>i</ci>
<apply>
<times></times>
<ci>α</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \tau^{-1}(\beta)(\alpha)=\sum_{i\in I}\beta(i)(\alpha(i))
  </annotation>
</semantics>
</math>
</dd>
<dd>for any <em>α</em> in the direct sum of the modules <em>M</em><sub><em>i</em></sub>. The key point is that the definition of <em>τ</em><sup>−1</sup> makes sense because <em>α</em>(<em>i</em>) is zero for all but finitely many <em>i</em>, and so the sum is finite.
</dd>
<dd>In particular, the <a href="dual_space" title="wikilink">dual vector space</a> of a direct sum of vector spaces is isomorphic to the <a href="direct_product" title="wikilink">direct product</a> of the duals of those spaces.
</dd>
</dl></li>
<li>The <em>finite</em> direct sum of modules is a <a class="uri" href="biproduct" title="wikilink">biproduct</a>: If
<dl>
<dd><dl>
<dd>
<math display="inline" id="Direct_sum_of_modules:15">
<semantics>
<mrow>
<msub>
<mi>p</mi>
<mi>k</mi>
</msub>
<mo>:</mo>
<mrow>
<mrow>
<msub>
<mi>A</mi>
<mn>1</mn>
</msub>
<mo>⊕</mo>
<mi mathvariant="normal">⋯</mi>
<mo>⊕</mo>
<msub>
<mi>A</mi>
<mi>n</mi>
</msub>
</mrow>
<mo>→</mo>
<msub>
<mi>A</mi>
<mi>k</mi>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<ci>k</ci>
</apply>
<apply>
<ci>normal-→</ci>
<apply>
<csymbol cd="latexml">direct-sum</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>A</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-⋯</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>A</ci>
<ci>n</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>A</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{k}:A_{1}\oplus\cdots\oplus A_{n}\to A_{k}
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
<dd>are the canonical projection mappings and


<p>
<math display="block" id="Direct_sum_of_modules:16">
<semantics>
<mrow>
<msub>
<mi>i</mi>
<mi>k</mi>
</msub>
<mo>:</mo>
<mrow>
<msub>
<mi>A</mi>
<mi>k</mi>
</msub>
<mo>↦</mo>
<mrow>
<msub>
<mi>A</mi>
<mn>1</mn>
</msub>
<mo>⊕</mo>
<mi mathvariant="normal">⋯</mi>
<mo>⊕</mo>
<msub>
<mi>A</mi>
<mi>n</mi>
</msub>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>i</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="latexml">maps-to</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>A</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="latexml">direct-sum</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>A</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-⋯</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>A</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   i_{k}:A_{k}\mapsto A_{1}\oplus\cdots\oplus A_{n}
  </annotation>
</semantics>
</math>
</p>
</dd>
<dd>are the inclusion mappings, then


<p>
<math display="block" id="Direct_sum_of_modules:17">
<semantics>
<mrow>
<mrow>
<msub>
<mi>i</mi>
<mn>1</mn>
</msub>
<mo>∘</mo>
<msub>
<mi>p</mi>
<mn>1</mn>
</msub>
</mrow>
<mo>+</mo>
<mi mathvariant="normal">⋯</mi>
<mo>+</mo>
<mrow>
<msub>
<mi>i</mi>
<mi>n</mi>
</msub>
<mo>∘</mo>
<msub>
<mi>p</mi>
<mi>n</mi>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<plus></plus>
<apply>
<compose></compose>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>i</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>normal-⋯</ci>
<apply>
<compose></compose>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>i</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   i_{1}\circ p_{1}+\cdots+i_{n}\circ p_{n}
  </annotation>
</semantics>
</math>
</p>
</dd>
<dd>equals the identity morphism of <em>A</em><sub>1</sub> ⊕ ··· ⊕ <em>A</em><sub><em>n</em></sub>, and


<p>
<math display="block" id="Direct_sum_of_modules:18">
<semantics>
<mrow>
<msub>
<mi>p</mi>
<mi>k</mi>
</msub>
<mo>∘</mo>
<msub>
<mi>i</mi>
<mi>l</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<compose></compose>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>i</ci>
<ci>l</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{k}\circ i_{l}
  </annotation>
</semantics>
</math>
</p>
</dd>
<dd>is the identity morphism of <em>A</em><sub><em>k</em></sub> in the case <em>l=k</em>, and is the zero map otherwise.
</dd>
</dl></li>
</ul>
<h2 id="internal-direct-sum">Internal direct sum</h2>

<p>Suppose <em>M</em> is some <em>R</em>-module, and <em>M</em><sub><em>i</em></sub> is a <a class="uri" href="submodule" title="wikilink">submodule</a> of <em>M</em> for every <em>i</em> in <em>I</em>. If every <em>x</em> in <em>M</em> can be written in one and only one way as a sum of finitely many elements of the <em>M</em><sub><em>i</em></sub>, then we say that <em>M</em> is the <strong>internal direct sum</strong> of the submodules <em>M</em><sub><em>i</em></sub> . In this case, <em>M</em> is naturally isomorphic to the (external) direct sum of the <em>M</em><sub><em>i</em></sub> as defined above .</p>

<p>A submodule <em>N</em> of <em>M</em> is a <strong>direct summand</strong> of <em>M</em> if there exists some other submodule <em>N′</em> of <em>M</em> such that <em>M</em> is the <em>internal</em> direct sum of <em>N</em> and <em>N′</em>. In this case, <em>N</em> and <em>N′</em> are <strong>complementary subspaces</strong>.</p>
<h2 id="universal-property">Universal property</h2>

<p>In the language of <a href="category_theory" title="wikilink">category theory</a>, the direct sum is a <a class="uri" href="coproduct" title="wikilink">coproduct</a> and hence a <a href="limit_(category_theory)" title="wikilink">colimit</a> in the category of left <em>R</em>-modules, which means that it is characterized by the following <a href="universal_property" title="wikilink">universal property</a>. For every <em>i</em> in <em>I</em>, consider the <em>natural embedding</em></p>

<p>
<math display="block" id="Direct_sum_of_modules:19">
<semantics>
<mrow>
<msub>
<mi>j</mi>
<mi>i</mi>
</msub>
<mo>:</mo>
<mrow>
<msub>
<mi>M</mi>
<mi>i</mi>
</msub>
<mo>→</mo>
<mrow>
<munder>
<mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
<mrow>
<mi>k</mi>
<mo>∈</mo>
<mi>I</mi>
</mrow>
</munder>
<msub>
<mi>M</mi>
<mi>k</mi>
</msub>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>j</ci>
<ci>i</ci>
</apply>
<apply>
<ci>normal-→</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>i</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">direct-sum</csymbol>
<apply>
<in></in>
<ci>k</ci>
<ci>I</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   j_{i}:M_{i}\rightarrow\bigoplus_{k\in I}M_{k}
  </annotation>
</semantics>
</math>
</p>

<p>which sends the elements of <em>M</em><sub><em>i</em></sub> to those functions which are zero for all arguments but <em>i</em>. If <em>f</em><sub><em>i</em></sub> : <em>M</em><sub><em>i</em></sub> → <em>M</em> are arbitrary <em>R</em>-linear maps for every <em>i</em>, then there exists precisely one <em>R</em>-linear map</p>

<p>
<math display="block" id="Direct_sum_of_modules:20">
<semantics>
<mrow>
<mi>f</mi>
<mo>:</mo>
<mrow>
<mrow>
<munder>
<mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
<mrow>
<mi>i</mi>
<mo>∈</mo>
<mi>I</mi>
</mrow>
</munder>
<msub>
<mi>M</mi>
<mi>i</mi>
</msub>
</mrow>
<mo>→</mo>
<mi>M</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<ci>f</ci>
<apply>
<ci>normal-→</ci>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">direct-sum</csymbol>
<apply>
<in></in>
<ci>i</ci>
<ci>I</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>M</ci>
<ci>i</ci>
</apply>
</apply>
<ci>M</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f:\bigoplus_{i\in I}M_{i}\rightarrow M
  </annotation>
</semantics>
</math>
</p>

<p>such that <em>f</em> o <em>j<sub>i</sub></em> = <em>f</em><sub><em>i</em></sub> for all <em>i</em>.</p>

<p>Dually, the <a href="direct_product" title="wikilink">direct product</a> is the <a href="Product_(category_theory)" title="wikilink">product</a>.</p>
<h2 id="grothendieck-group">Grothendieck group</h2>

<p>The direct sum gives a collection of objects the structure of a commutative <a class="uri" href="monoid" title="wikilink">monoid</a>, in that the addition of objects is defined, but not subtraction. In fact, subtraction can be defined, and every commutative monoid can be extended to an <a href="abelian_group" title="wikilink">abelian group</a>. This extension is known as the <a href="Grothendieck_group" title="wikilink">Grothendieck group</a>. The extension is done by defining equivalence classes of pairs of objects, which allows certain pairs to be treated as inverses. The construction, detailed in the article on the Grothendieck group, is "universal", in that it has the <a href="universal_property" title="wikilink">universal property</a> of being unique, and homomorphic to any other embedding of an abelian monoid in an abelian group.</p>
<h2 id="direct-sum-of-modules-with-additional-structure">Direct sum of modules with additional structure</h2>

<p>If the modules we are considering carry some additional structure (e.g. a <a href="norm_(mathematics)" title="wikilink">norm</a> or an <a href="inner_product" title="wikilink">inner product</a>), then the direct sum of the modules can often be made to carry this additional structure, as well. In this case, we obtain the <a class="uri" href="coproduct" title="wikilink">coproduct</a> in the appropriate <a href="category_(category_theory)" title="wikilink">category</a> of all objects carrying the additional structure. Two prominent examples occur for <a href="Banach_space" title="wikilink">Banach spaces</a> and <a href="Hilbert_space" title="wikilink">Hilbert spaces</a>.</p>

<p>In some classical texts, the notion of direct sum of <a href="algebra_over_a_field" title="wikilink">algebras over a field</a> is also introduced. This construction, however, does not provide a coproduct in the category of algebras, but a direct product (<em>see note below</em> and the remark on <a href="Direct_sum#Direct_sum_of_rings" title="wikilink">direct sums of rings</a>).</p>
<h3 id="direct-sum-of-algebras">Direct sum of algebras</h3>

<p>A direct sum of <a href="algebra_over_a_field" title="wikilink">algebras</a> <em>X</em> and <em>Y</em> is the direct sum as vector spaces, with product</p>

<p>
<math display="block" id="Direct_sum_of_modules:21">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>+</mo>
<msub>
<mi>y</mi>
<mn>1</mn>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>x</mi>
<mn>2</mn>
</msub>
<mo>+</mo>
<msub>
<mi>y</mi>
<mn>2</mn>
</msub>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<msub>
<mi>x</mi>
<mn>2</mn>
</msub>
</mrow>
<mo>+</mo>
<mrow>
<msub>
<mi>y</mi>
<mn>1</mn>
</msub>
<msub>
<mi>y</mi>
<mn>2</mn>
</msub>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (x_{1}+y_{1})(x_{2}+y_{2})=(x_{1}x_{2}+y_{1}y_{2}).
  </annotation>
</semantics>
</math>

 Consider these classical examples:</p>

<p>
<math display="block" id="Direct_sum_of_modules:22">
<semantics>
<mrow>
<mi>R</mi>
<mo>⊕</mo>
<mi>R</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">direct-sum</csymbol>
<ci>R</ci>
<ci>R</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   R\oplus R
  </annotation>
</semantics>
</math>

 is <a href="ring_isomorphism" title="wikilink">ring isomorphic</a> to <a href="split-complex_number" title="wikilink">split-complex numbers</a>, also used in <a href="interval_analysis" title="wikilink">interval analysis</a>.</p>

<p>
<math display="block" id="Direct_sum_of_modules:23">
<semantics>
<mrow>
<mi>C</mi>
<mo>⊕</mo>
<mi>C</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">direct-sum</csymbol>
<ci>C</ci>
<ci>C</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   C\oplus C
  </annotation>
</semantics>
</math>

 is the algebra of <a href="tessarine" title="wikilink">tessarines</a> introduced by <a href="James_Cockle_(lawyer)" title="wikilink">James Cockle</a> in 1848.</p>

<p>
<math display="block" id="Direct_sum_of_modules:24">
<semantics>
<mrow>
<mi>H</mi>
<mo>⊕</mo>
<mi>H</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">direct-sum</csymbol>
<ci>H</ci>
<ci>H</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H\oplus H
  </annotation>
</semantics>
</math>

, called the <a href="split-biquaternion" title="wikilink">split-biquaternions</a>, was introduced by <a href="William_Kingdon_Clifford" title="wikilink">William Kingdon Clifford</a> in 1873. <a href="Joseph_Wedderburn" title="wikilink">Joseph Wedderburn</a> exploited the concept of a direct sum of algebras in his classification of <a href="hypercomplex_number" title="wikilink">hypercomplex numbers</a>. See his <em>Lectures on Matrices</em> (1934), page 151. Wedderburn makes clear the distinction between a direct sum and a direct product of algebras: For the direct sum the field of scalars acts jointly on both parts

<math display="block" id="Direct_sum_of_modules:25">
<semantics>
<mrow>
<mrow>
<mi>λ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>⊕</mo>
<mi>y</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mi>λ</mi>
<mi>x</mi>
</mrow>
<mo>⊕</mo>
<mrow>
<mi>λ</mi>
<mi>y</mi>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>λ</ci>
<apply>
<csymbol cd="latexml">direct-sum</csymbol>
<ci>x</ci>
<ci>y</ci>
</apply>
</apply>
<apply>
<csymbol cd="latexml">direct-sum</csymbol>
<apply>
<times></times>
<ci>λ</ci>
<ci>x</ci>
</apply>
<apply>
<times></times>
<ci>λ</ci>
<ci>y</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lambda(x\oplus y)=\lambda x\oplus\lambda y
  </annotation>
</semantics>
</math>

 while for the direct product a scalar factor may be collected alternately with the parts, but not both

<math display="block" id="Direct_sum_of_modules:26">
<semantics>
<mrow>
<mrow>
<mi>λ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>λ</mi>
<mi>x</mi>
</mrow>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mrow>
<mi>λ</mi>
<mi>y</mi>
</mrow>
<mo rspace="0.8pt" stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<times></times>
<ci>λ</ci>
<interval closure="open">
<ci>x</ci>
<ci>y</ci>
</interval>
</apply>
<interval closure="open">
<apply>
<times></times>
<ci>λ</ci>
<ci>x</ci>
</apply>
<ci>y</ci>
</interval>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<interval closure="open">
<ci>x</ci>
<apply>
<times></times>
<ci>λ</ci>
<ci>y</ci>
</apply>
</interval>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lambda(x,y)=(\lambda x,y)=(x,\lambda y)\!
  </annotation>
</semantics>
</math>

. <a href="Ian_R._Porteous" title="wikilink">Ian R. Porteous</a> uses the three direct sums above, denoting them 

<math display="inline" id="Direct_sum_of_modules:27">
<semantics>
<mrow>
<mmultiscripts>
<mi>R</mi>
<mprescripts></mprescripts>
<none></none>
<mn>2</mn>
</mmultiscripts>
<msup>
<mo rspace="7.5pt">,</mo>
<mn>2</mn>
</msup>
<mi>C</mi>
<msup>
<mo rspace="7.5pt">,</mo>
<mn>2</mn>
</msup>
<mpadded width="-1.7pt">
<mi>H</mi>
</mpadded>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>R</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>normal-,</ci>
<cn type="integer">2</cn>
</apply>
<csymbol cd="unknown">C</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>normal-,</ci>
<cn type="integer">2</cn>
</apply>
<csymbol cd="unknown">H</csymbol>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   {}^{2}R,\ ^{2}C,\ ^{2}H\!
  </annotation>
</semantics>
</math>

, as rings of scalars in his analysis of <em>Clifford Algebras and the Classical Groups</em> (1995). These direct sums also arise in the classification of <a href="composition_algebra" title="wikilink">composition algebras</a>.</p>

<p>It is worth mentioning that the construction described above, as well as Wedderburn's use of the terms <em>direct sum</em> and <em>direct product</em> follow a different convention from the one in <a href="category_theory" title="wikilink">category theory</a>. In categorical terms, Wedderburn's <em>direct sum</em> is a <a href="Product_(category_theory)" title="wikilink">categorical product</a>, whilst Wedderburn's <em>direct product</em> is a <a href="Coproduct" title="wikilink">coproduct (or categorical sum)</a>, which (for commutative algebras) actually corresponds to the <a href="tensor_product_of_algebras" title="wikilink">tensor product of algebras</a>.</p>
<h3 id="direct-sum-of-banach-spaces">Direct sum of Banach spaces</h3>

<p><span id="Banachspaces"></span></p>

<p>The direct sum of two <a href="Banach_space" title="wikilink">Banach spaces</a> <em>X</em> and <em>Y</em> is the direct sum of <em>X</em> and <em>Y</em> considered as vector spaces, with the norm ||(<em>x</em>,<em>y</em>)|| = ||<em>x</em>||<sub>X</sub> + ||<em>y</em>||<sub>Y</sub> for all <em>x</em> in <em>X</em> and <em>y</em> in <em>Y</em>.</p>

<p>Generally, if <em>X</em><sub><em>i</em></sub> is a collection of Banach spaces, where <em>i</em> traverses the <a href="index_set" title="wikilink">index set</a> <em>I</em>, then the direct sum ⨁<sub><em>i</em>∈<em>I</em></sub> <em>X</em><sub><em>i</em></sub> is a module consisting of all functions <em>x</em> <a href="Domain_of_a_function" title="wikilink">defined over</a> <em>I</em> such that <em>x</em>(<em>i</em>) ∈ <em>X</em><sub><em>i</em></sub> for all <em>i</em> ∈ <em>I</em> and</p>

<p>
<math display="block" id="Direct_sum_of_modules:28">
<semantics>
<mrow>
<mrow>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>i</mi>
<mo>∈</mo>
<mi>I</mi>
</mrow>
</munder>
<msub>
<mrow>
<mo>∥</mo>
<mrow>
<mi>x</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>i</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>∥</mo>
</mrow>
<msub>
<mi>X</mi>
<mi>i</mi>
</msub>
</msub>
</mrow>
<mo>&lt;</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<lt></lt>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<in></in>
<ci>i</ci>
<ci>I</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="latexml">norm</csymbol>
<apply>
<times></times>
<ci>x</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>X</ci>
<ci>i</ci>
</apply>
</apply>
</apply>
<infinity></infinity>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sum_{i\in I}\|x(i)\|_{X_{i}}&lt;\infty.
  </annotation>
</semantics>
</math>
</p>

<p>The norm is given by the sum above. The direct sum with this norm is again a Banach space.</p>

<p>For example, if we take the index set <em>I</em> = <strong>N</strong> and <em>X</em><sub><em>i</em></sub> = <strong>R</strong>, then the direct sum ⨁<sub><em>i</em>∈<strong>N</strong></sub><em>X</em><sub><em>i</em></sub> is the space <em>l</em><sub>1</sub>, which consists of all the sequences (<em>a</em><sub><em>i</em></sub>) of reals with finite norm ||<em>a</em>|| = ∑<sub><em>i</em></sub> |<em>a</em><sub><em>i</em></sub>|.</p>

<p>A closed subspace <em>A</em> of a Banach space <em>X</em> is <strong>complemented</strong> if there is another closed subspace <em>B</em> of <em>X</em> such that <em>X</em> is equal to the internal direct sum 

<math display="inline" id="Direct_sum_of_modules:29">
<semantics>
<mrow>
<mi>A</mi>
<mo>⊕</mo>
<mi>B</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">direct-sum</csymbol>
<ci>A</ci>
<ci>B</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A\oplus B
  </annotation>
</semantics>
</math>

. Note that not every closed subspace is complemented, e.g. <a href="c0_space" title="wikilink"><em>c</em><sub>0</sub></a> is not complemented in 

<math display="inline" id="Direct_sum_of_modules:30">
<semantics>
<msup>
<mi mathvariant="normal">ℓ</mi>
<mi mathvariant="normal">∞</mi>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>normal-ℓ</ci>
<infinity></infinity>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \ell^{\infty}
  </annotation>
</semantics>
</math>

.</p>
<h3 id="direct-sum-of-modules-with-bilinear-forms">Direct sum of modules with bilinear forms</h3>

<p>Let {(<em>M</em><sub><em>i</em></sub>,<em>b</em><sub><em>i</em></sub> : <em>i</em> ∈ <em>I</em>} be a <a href="indexed_family" title="wikilink">family</a> indexed by <em>I</em> of modules equipped with <a href="bilinear_form" title="wikilink">bilinear forms</a>. The <strong>orthogonal direct sum</strong> is the module direct sum with bilinear form <em>B</em> defined by<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>
<math display="block" id="Direct_sum_of_modules:31">
<semantics>
<mrow>
<mrow>
<mi>B</mi>
<mrow>
<mo>(</mo>
<mrow>
<mo>(</mo>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<mo>)</mo>
</mrow>
<mo>,</mo>
<mrow>
<mo>(</mo>
<msub>
<mi>y</mi>
<mi>i</mi>
</msub>
<mo>)</mo>
</mrow>
<mo>)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>i</mi>
<mo>∈</mo>
<mi>I</mi>
</mrow>
</munder>
<mrow>
<msub>
<mi>b</mi>
<mi>i</mi>
</msub>
<mrow>
<mo>(</mo>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<mo>,</mo>
<msub>
<mi>y</mi>
<mi>i</mi>
</msub>
<mo>)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>B</ci>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>i</ci>
</apply>
</interval>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<in></in>
<ci>i</ci>
<ci>I</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>b</ci>
<ci>i</ci>
</apply>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>i</ci>
</apply>
</interval>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   B\left({\left({x_{i}}\right),\left({y_{i}}\right)}\right)=\sum_{i\in I}b_{i}%
\left({x_{i},y_{i}}\right)
  </annotation>
</semantics>
</math>
</p>

<p>in which the summation makes sense even for infinite index sets <em>I</em> because only finitely many of the terms are non-zero.</p>
<h3 id="direct-sum-of-hilbert-spaces"><span id="Hilbertspaces"></span> Direct sum of Hilbert spaces</h3>

<p>If finitely many <a href="Hilbert_space" title="wikilink">Hilbert spaces</a> <em>H</em><sub>1</sub>,...,<em>H</em><sub><em>n</em></sub> are given, one can construct their orthogonal direct sum as above (since they are vector spaces), defining the inner product as:</p>

<p>
<math display="block" id="Direct_sum_of_modules:32">
<semantics>
<mrow>
<mrow>
<mrow>
<mo stretchy="false">⟨</mo>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>x</mi>
<mi>n</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<mo>,</mo>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>y</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>y</mi>
<mi>n</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">⟩</mo>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mo stretchy="false">⟨</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>y</mi>
<mn>1</mn>
</msub>
<mo stretchy="false">⟩</mo>
</mrow>
<mo>+</mo>
<mi mathvariant="normal">…</mi>
<mo>+</mo>
<mrow>
<mo stretchy="false">⟨</mo>
<msub>
<mi>x</mi>
<mi>n</mi>
</msub>
<mo>,</mo>
<msub>
<mi>y</mi>
<mi>n</mi>
</msub>
<mo stretchy="false">⟩</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<list>
<vector>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>n</ci>
</apply>
</vector>
<vector>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>n</ci>
</apply>
</vector>
</list>
<apply>
<plus></plus>
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<cn type="integer">1</cn>
</apply>
</list>
<ci>normal-…</ci>
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>y</ci>
<ci>n</ci>
</apply>
</list>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \langle(x_{1},...,x_{n}),(y_{1},...,y_{n})\rangle=\langle x_{1},y_{1}\rangle+.%
..+\langle x_{n},y_{n}\rangle.
  </annotation>
</semantics>
</math>
</p>

<p>The resulting direct sum is a Hilbert space which contains the given Hilbert spaces as mutually <a class="uri" href="orthogonal" title="wikilink">orthogonal</a> subspaces.</p>

<p>If infinitely many Hilbert spaces <em>H</em><sub><em>i</em></sub> for <em>i</em> in <em>I</em> are given, we can carry out the same construction; notice that when defining the inner product, only finitely many summands will be non-zero. However, the result will only be an <a href="inner_product_space" title="wikilink">inner product space</a> and it will not necessarily be <a href="completeness_(topology)" title="wikilink">complete</a>. We then define the direct sum of the Hilbert spaces <em>H</em><sub><em>i</em></sub> to be the completion of this inner product space.</p>

<p>Alternatively and equivalently, one can define the direct sum of the Hilbert spaces <em>H</em><sub><em>i</em></sub> as the space of all functions α with domain <em>I</em>, such that α(<em>i</em>) is an element of <em>H</em><sub><em>i</em></sub> for every <em>i</em> in <em>I</em> and:</p>

<p>
<math display="block" id="Direct_sum_of_modules:33">
<semantics>
<mrow>
<mrow>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mi>i</mi>
</munder>
<msup>
<mrow>
<mo>∥</mo>
<msub>
<mi>α</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>i</mi>
<mo stretchy="false">)</mo>
</mrow>
</msub>
<mo>∥</mo>
</mrow>
<mn>2</mn>
</msup>
</mrow>
<mo>&lt;</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<lt></lt>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="latexml">norm</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>α</ci>
<ci>i</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
<infinity></infinity>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sum_{i}\left\|\alpha_{(i)}\right\|^{2}&lt;\infty.
  </annotation>
</semantics>
</math>
</p>

<p>The inner product of two such function α and β is then defined as:</p>

<p>
<math display="block" id="Direct_sum_of_modules:34">
<semantics>
<mrow>
<mrow>
<mrow>
<mo stretchy="false">⟨</mo>
<mi>α</mi>
<mo>,</mo>
<mi>β</mi>
<mo stretchy="false">⟩</mo>
</mrow>
<mo>=</mo>
<mrow>
<munder>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mi>i</mi>
</munder>
<mrow>
<mo stretchy="false">⟨</mo>
<msub>
<mi>α</mi>
<mi>i</mi>
</msub>
<mo>,</mo>
<msub>
<mi>β</mi>
<mi>i</mi>
</msub>
<mo stretchy="false">⟩</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<list>
<ci>α</ci>
<ci>β</ci>
</list>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>i</ci>
</apply>
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>α</ci>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>β</ci>
<ci>i</ci>
</apply>
</list>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \langle\alpha,\beta\rangle=\sum_{i}\langle\alpha_{i},\beta_{i}\rangle.
  </annotation>
</semantics>
</math>
</p>

<p>This space is complete and we get a Hilbert space.</p>

<p>For example, if we take the index set <em>I</em> = <strong>N</strong> and <em>X</em><sub><em>i</em></sub> = <strong>R</strong>, then the direct sum ⨁<sub><em>i</em>∈<strong>N</strong></sub> <em>X</em><sub><em>i</em></sub> is the space <em>l</em><sub>2</sub>, which consists of all the sequences (<em>a</em><sub><em>i</em></sub>) of reals with finite norm 

<math display="inline" id="Direct_sum_of_modules:35">
<semantics>
<mrow>
<mrow>
<mo>∥</mo>
<mi>a</mi>
<mo>∥</mo>
</mrow>
<mo>=</mo>
<msqrt>
<mrow>
<msub>
<mo largeop="true" symmetric="true">∑</mo>
<mi>i</mi>
</msub>
<msup>
<mrow>
<mo>∥</mo>
<msub>
<mi>a</mi>
<mi>i</mi>
</msub>
<mo>∥</mo>
</mrow>
<mn>2</mn>
</msup>
</mrow>
</msqrt>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="latexml">norm</csymbol>
<ci>a</ci>
</apply>
<apply>
<root></root>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<ci>i</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="latexml">norm</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>a</ci>
<ci>i</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \left\|a\right\|=\sqrt{\sum_{i}\left\|a_{i}\right\|^{2}}
  </annotation>
</semantics>
</math>

. Comparing this with the example for Banach spaces, we see that the Banach space direct sum and the Hilbert space direct sum are not necessarily the same. But if there are only finitely many summands, then the Banach space direct sum is isomorphic to the Hilbert space direct sum, although the norm will be different.</p>

<p>Every Hilbert space is isomorphic to a direct sum of sufficiently many copies of the base field (either <strong>R</strong> or <strong>C</strong>). This is equivalent to the assertion that every Hilbert space has an orthonormal basis. More generally, every closed subspace of a Hilbert space is complemented: it admits an <a href="orthogonal_complement" title="wikilink">orthogonal complement</a>. Conversely, the <a href="Lindenstrauss–Tzafriri_theorem" title="wikilink">Lindenstrauss–Tzafriri theorem</a> asserts that if every closed subspace of a Banach space is complemented, then the Banach space is isomorphic (topologically) to a Hilbert space.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Biproduct" title="wikilink">Biproduct</a></li>
<li><a href="Indecomposable_module" title="wikilink">Indecomposable module</a></li>
<li><a href="Jordan–Hölder_theorem" title="wikilink">Jordan–Hölder theorem</a></li>
<li><a href="Krull–Schmidt_theorem" title="wikilink">Krull–Schmidt theorem</a></li>
<li><a href="Split_exact_sequence" title="wikilink">Split exact sequence</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li></li>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Linear_algebra" title="wikilink">Category:Linear algebra</a> <a href="Category:Module_theory" title="wikilink">Category:Module theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
