<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="598">Explicit and implicit methods</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Explicit and implicit methods</h1>
<hr/>

<p><strong>Explicit and implicit methods</strong> are approaches used in <a href="numerical_analysis" title="wikilink">numerical analysis</a> for obtaining numerical solutions of time-dependent <a href="ordinary_differential_equation" title="wikilink">ordinary</a> and <a href="partial_differential_equation" title="wikilink">partial differential equations</a>, as is required in <a href="computer_simulation" title="wikilink">computer simulations</a> of <a href="Process_(science)" title="wikilink">physical processes</a>.</p>

<p><strong>Explicit methods</strong> calculate the state of a system at a later time from the state of the system at the current time, while <strong>implicit methods</strong> find a solution by solving an equation involving both the current state of the system and the later one. Mathematically, if 

<math display="inline" id="Explicit_and_implicit_methods:0">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Y</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y(t)
  </annotation>
 </semantics>
</math>

 is the current system state and 

<math display="inline" id="Explicit_and_implicit_methods:1">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>t</mi>
     <mo>+</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Y</ci>
    <apply>
     <plus></plus>
     <ci>t</ci>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y(t+\Delta t)
  </annotation>
 </semantics>
</math>

 is the state at the later time (

<math display="inline" id="Explicit_and_implicit_methods:2">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta t
  </annotation>
 </semantics>
</math>

 is a small time step), then, for an explicit method</p>

<p>

<math display="block" id="Explicit_and_implicit_methods:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>Y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>t</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>Y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Y</ci>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>F</ci>
     <apply>
      <times></times>
      <ci>Y</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y(t+\Delta t)=F(Y(t))\,
  </annotation>
 </semantics>
</math>

 while for an implicit method one solves an equation</p>

<p>

<math display="block" id="Explicit_and_implicit_methods:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>Y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>Y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>t</mi>
        <mo>+</mo>
        <mrow>
         <mi mathvariant="normal">Δ</mi>
         <mi>t</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>Y</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <ci>Y</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <apply>
         <times></times>
         <ci>normal-Δ</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </interval>
    </apply>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(Y(t),Y(t+\Delta t))=0\quad\quad(1)\,
  </annotation>
 </semantics>
</math>

 to find 

<math display="inline" id="Explicit_and_implicit_methods:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>Y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>t</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Y</ci>
    <apply>
     <plus></plus>
     <ci>t</ci>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y(t+\Delta t).
  </annotation>
 </semantics>
</math>

</p>

<p>It is clear that implicit methods require an extra computation (solving the above equation), and they can be much harder to implement. Implicit methods are used because many problems arising in practice are <a href="Stiff_equation" title="wikilink">stiff</a>, for which the use of an explicit method requires impractically small time steps 

<math display="inline" id="Explicit_and_implicit_methods:6">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta t
  </annotation>
 </semantics>
</math>

 to keep the error in the result bounded (see <a href="numerical_stability" title="wikilink">numerical stability</a>). For such problems, to achieve given accuracy, it takes much less computational time to use an implicit method with larger time steps, even taking into account that one needs to solve an equation of the form (1) at each time step. That said, whether one should use an explicit or implicit method depends upon the problem to be solved.</p>
<h2 id="illustration-using-the-forward-and-backward-euler-methods">Illustration using the forward and backward Euler methods</h2>

<p>Consider the <a href="ordinary_differential_equation" title="wikilink">ordinary differential equation</a></p>

<p>

<math display="block" id="Explicit_and_implicit_methods:7">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <mi>d</mi>
      <mi>y</mi>
     </mrow>
     <mrow>
      <mi>d</mi>
      <mi>t</mi>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <msup>
      <mi>y</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <mi>t</mi>
    <mo>∈</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mi>a</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>t</ci>
     <list>
      <interval closure="closed">
       <cn type="integer">0</cn>
       <ci>a</ci>
      </interval>
      <cn type="integer">2</cn>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{dy}{dt}=-y^{2},\ t\in[0,a]\quad\quad(2)
  </annotation>
 </semantics>
</math>

</p>

<p>with the initial condition 

<math display="inline" id="Explicit_and_implicit_methods:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="float">1.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(0)=1.
  </annotation>
 </semantics>
</math>

 Consider a grid 

<math display="inline" id="Explicit_and_implicit_methods:9">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <mfrac>
     <mi>k</mi>
     <mi>n</mi>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <ci>a</ci>
     <apply>
      <divide></divide>
      <ci>k</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{k}=a\frac{k}{n}
  </annotation>
 </semantics>
</math>

 for 0 ≤ <em>k</em> ≤ <em>n</em>, that is, the time step is 

<math display="inline" id="Explicit_and_implicit_methods:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>t</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>a</mi>
     <mo>/</mo>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <divide></divide>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta t=a/n,
  </annotation>
 </semantics>
</math>

 and denote 

<math display="inline" id="Explicit_and_implicit_methods:11">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>t</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <ci>y</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}=y(t_{k})
  </annotation>
 </semantics>
</math>

 for each 

<math display="inline" id="Explicit_and_implicit_methods:12">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. <a href="Discretization" title="wikilink">Discretize</a> this equation using the simplest explicit and implicit methods, which are the <em>forward Euler</em> and ''backward Euler '' methods (see <a href="numerical_ordinary_differential_equations" title="wikilink">numerical ordinary differential equations</a>) and compare the obtained schemes.</p>
<dl>
<dt>Forward Euler method:</dt>
</dl>

<p>The forward <a href="Euler_method" title="wikilink">Euler method</a></p>

<p>

<math display="block" id="Explicit_and_implicit_methods:13">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mrow>
       <mi>d</mi>
       <mi>y</mi>
      </mrow>
      <mrow>
       <mi>d</mi>
       <mi>t</mi>
      </mrow>
     </mfrac>
     <mo>)</mo>
    </mrow>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>y</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>y</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>t</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <msubsup>
     <mi>y</mi>
     <mi>k</mi>
     <mn>2</mn>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>y</ci>
       </apply>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>k</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\frac{dy}{dt}\right)_{k}=\frac{y_{k+1}-y_{k}}{\Delta t}=-y_{k}^{2}
  </annotation>
 </semantics>
</math>

 yields</p>

<p>

<math display="block" id="Explicit_and_implicit_methods:14">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>k</mi>
     </msub>
     <mo>-</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mi>t</mi>
      <msubsup>
       <mi>y</mi>
       <mi>k</mi>
       <mn>2</mn>
      </msubsup>
     </mrow>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>3</mn>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <list>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>k</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <cn type="integer">3</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k+1}=y_{k}-\Delta ty_{k}^{2}\quad\quad\quad(3)\,
  </annotation>
 </semantics>
</math>

 for each 

<math display="inline" id="Explicit_and_implicit_methods:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mrow>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=0,1,\dots,n.
  </annotation>
 </semantics>
</math>

 This is an explicit formula for 

<math display="inline" id="Explicit_and_implicit_methods:16">
 <semantics>
  <msub>
   <mi>y</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k+1}
  </annotation>
 </semantics>
</math>

.</p>
<dl>
<dt>Backward Euler method:</dt>
</dl>

<p>With the <a href="backward_Euler_method" title="wikilink">backward Euler method</a></p>

<p>

<math display="block" id="Explicit_and_implicit_methods:17">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <msub>
      <mi>y</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>y</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>t</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <msubsup>
     <mi>y</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mn>2</mn>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{y_{k+1}-y_{k}}{\Delta t}=-y_{k+1}^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>one finds the implicit equation</p>

<p>

<math display="block" id="Explicit_and_implicit_methods:18">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>t</mi>
     <msubsup>
      <mi>y</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mn>2</mn>
     </msubsup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>y</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k+1}+\Delta ty_{k+1}^{2}=y_{k}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Explicit_and_implicit_methods:19">
 <semantics>
  <msub>
   <mi>y</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k+1}
  </annotation>
 </semantics>
</math>

 (compare this with formula (3) where 

<math display="inline" id="Explicit_and_implicit_methods:20">
 <semantics>
  <msub>
   <mi>y</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k+1}
  </annotation>
 </semantics>
</math>

 was given explicitly rather than as an unknown in an equation).</p>

<p>This is a <a href="quadratic_equation" title="wikilink">quadratic equation</a>, having one negative and one positive <a href="Root_of_a_function" title="wikilink">root</a>. The positive root is picked because in the original equation the initial condition is positive, and then 

<math display="inline" id="Explicit_and_implicit_methods:21">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 at the next time step is given by</p>

<p>

<math display="block" id="Explicit_and_implicit_methods:22">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>+</mo>
     <msqrt>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mrow>
        <mn>4</mn>
        <mi mathvariant="normal">Δ</mi>
        <mi>t</mi>
        <msub>
         <mi>y</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mrow>
     </msqrt>
    </mrow>
    <mrow>
     <mn>2</mn>
     <mi mathvariant="normal">Δ</mi>
     <mi>t</mi>
    </mrow>
   </mfrac>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>4</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <root></root>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <cn type="integer">4</cn>
         <ci>normal-Δ</ci>
         <ci>t</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>normal-Δ</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <ci>normal-.</ci>
    <ci>italic-</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">4</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k+1}=\frac{-1+\sqrt{1+4\Delta ty_{k}}}{2\Delta t}.\quad\quad(4)
  </annotation>
 </semantics>
</math>

</p>

<p>In the vast majority of cases, the equation to be solved when using an implicit scheme is much more complicated than a quadratic equation, and no analytical solution exists. Then one uses <a href="root-finding_algorithm" title="wikilink">root-finding algorithms</a>, such as <a href="Newton's_method" title="wikilink">Newton's method</a>, to find the numerical solution.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Courant–Friedrichs–Lewy_condition" title="wikilink">Courant–Friedrichs–Lewy condition</a></li>
<li><a href="SIMPLE_algorithm" title="wikilink">SIMPLE algorithm</a>, a semi-implicit method for pressure-linked equations</li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_differential_equations" title="wikilink">Category:Numerical differential equations</a></p>
</body>
</html>
