<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1023">Modular exponentiation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Modular exponentiation</h1>
<hr/>

<p><strong>Modular exponentiation</strong> is a type of <a class="uri" href="exponentiation" title="wikilink">exponentiation</a> performed over a <a href="modular_arithmetic" title="wikilink">modulus</a>. It is useful in <a href="computer_science" title="wikilink">computer science</a>, especially in the field of <a href="public-key_cryptography" title="wikilink">public-key cryptography</a>.</p>

<p>The operation of modular exponentiation calculates the remainder when an integer <em>b</em> (the base) raised to the <em>e</em>th power (the exponent), <em>b</em><sup><em>e</em></sup>, is divided by a <a href="positive_integer" title="wikilink">positive integer</a> <em>m</em> (the modulus). In symbols, given base <em>b</em>, exponent <em>e</em>, and modulus <em>m</em>, the modular exponentiation <em>c</em> is: <mtpl></mtpl>).</p>

<p>For example, given ,  and , the solution  is the remainder of dividing 5<sup>3</sup> = 125 by 13.</p>

<p>Given integers <em>b</em> and <em>e</em>, and a positive integer <em>m</em>, a unique solution <em>c</em> exists with the property .</p>

<p>Modular exponentiation can be performed with a <em>negative</em> exponent <em>e</em> by finding the <a href="modular_multiplicative_inverse" title="wikilink">modular multiplicative inverse</a> <em>d</em> of <em>b</em> modulo <em>m</em> using the <a href="extended_Euclidean_algorithm" title="wikilink">extended Euclidean algorithm</a>. That is:<br/>


<math display="block" id="Modular_exponentiation:0">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>≡</mo>
   <msup>
    <mi>b</mi>
    <mi>e</mi>
   </msup>
   <mo>≡</mo>
   <mrow>
    <msup>
     <mi>d</mi>
     <mrow>
      <mo>-</mo>
      <mi>e</mi>
     </mrow>
    </msup>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>m</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <ci>c</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <ci>e</ci>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>d</ci>
       <apply>
        <minus></minus>
        <ci>e</ci>
       </apply>
      </apply>
      <apply>
       <ci>pmod</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\equiv b^{e}\equiv d^{-e}\;\;(\mathop{{\rm mod}}m)
  </annotation>
 </semantics>
</math>

 where  and 

<math display="inline" id="Modular_exponentiation:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mo>⋅</mo>
    <mi>d</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mn>1</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>m</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <ci>normal-⋅</ci>
     <ci>b</ci>
     <ci>d</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <ci>pmod</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\cdot d\equiv 1\;\;(\mathop{{\rm mod}}m)
  </annotation>
 </semantics>
</math>

</p>

<p>Modular exponentiation similar to the one described above are considered easy to compute, even when the numbers involved are enormous. On the other hand, computing the <a href="discrete_logarithm" title="wikilink">discrete logarithm</a> – that is, the task of finding the exponent <em>e</em> when given <em>b</em>, <em>c</em>, and <em>m</em> – is believed to be difficult. This <a href="one-way_function" title="wikilink">one-way function</a> behavior makes modular exponentiation a candidate for use in cryptographic algorithms.</p>
<h2 id="straightforward-method">Straightforward method</h2>

<p>The most straightforward method of calculating a modular exponent is to calculate <em>b</em><sup><em>e</em></sup> directly, then to take this number modulo <em>m</em>. Consider trying to compute <em>c</em>, given <em>b</em> = 4, <em>e</em> = 13, and <em>m</em> = 497:<br/>


<math display="block" id="Modular_exponentiation:2">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>≡</mo>
   <mrow>
    <msup>
     <mn>4</mn>
     <mn>13</mn>
    </msup>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>497</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>c</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">4</cn>
      <cn type="integer">13</cn>
     </apply>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">497</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\equiv 4^{13}\;\;(\mathop{{\rm mod}}497)
  </annotation>
 </semantics>
</math>

</p>

<p>One could use a calculator to compute 4<sup>13</sup>; this comes out to 67,108,864. Taking this value modulo 497, the answer <em>c</em> is determined to be 445.</p>

<p>Note that <em>b</em> is only one digit in length and that <em>e</em> is only two digits in length, but the value <em>b</em><sup><em>e</em></sup> is 8 digits in length.</p>

<p>In strong cryptography, <em>b</em> is often at least 256 binary digits (77 decimal digits). Consider <em>b</em> = 5 × 10<sup>76</sup> and <em>e</em> = 17, both of which are perfectly reasonable values. In this example, <em>b</em> is 77 digits in length and <em>e</em> is 2 digits in length, but the value <em>b</em><sup><em>e</em></sup> is 1,304 decimal digits in length. Such calculations are possible on modern computers, but the sheer magnitude of such numbers causes the speed of calculations to slow considerably. As <em>b</em> and <em>e</em> increase even further to provide better security, the value <em>b</em><sup><em>e</em></sup> becomes unwieldy.</p>

<p>The time required to perform the exponentiation depends on the operating environment and the processor. The method described above requires <a href="Big_O_notation" title="wikilink">O</a>(<em>e</em>) multiplications to complete.</p>
<h2 id="memory-efficient-method">Memory-efficient method</h2>

<p>A second method to compute modular exponentiation requires more operations than the first method. Because the required memory is substantially less, however, operations take less time than before. The end result is that the algorithm is faster.</p>

<p>This algorithm makes use of the fact that, given two integers <em>a</em> and <em>b</em>, the following two equations are equivalent:<br/>


<math display="block" id="Modular_exponentiation:3">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>c</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mtext>mod</mtext>
      </mpadded>
      <mi>m</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mo>⋅</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>m</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>c</ci>
     <apply>
      <times></times>
      <mtext>mod</mtext>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <ci>normal-⋅</ci>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\ (\mbox{mod}\ m)=(a\cdot b)\;\;(\mathop{{\rm mod}}m)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Modular_exponentiation:4">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>c</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mtext>mod</mtext>
      </mpadded>
      <mi>m</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mpadded width="+5pt">
       <mi>a</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+5pt">
         <mtext>mod</mtext>
        </mpadded>
        <mi>m</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+5pt">
        <mi>b</mi>
       </mpadded>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mpadded width="+5pt">
          <mtext>mod</mtext>
         </mpadded>
         <mi>m</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>c</ci>
     <apply>
      <times></times>
      <mtext>mod</mtext>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <times></times>
       <mtext>mod</mtext>
       <ci>m</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>b</ci>
      <apply>
       <times></times>
       <mtext>mod</mtext>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\ (\mbox{mod}\ m)=(a\ (\mbox{mod}\ m)\cdot(b\ (\mbox{mod}\ m)))
  </annotation>
 </semantics>
</math>

</p>

<p>The algorithm is as follows:</p>
<ol>
<li>Set <em>c</em> = 1, <em>e</em>′ = 0.</li>
<li>Increase <em>e</em>′ by 1.</li>
<li>Set 

<math display="inline" id="Modular_exponentiation:5">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mo>⋅</mo>
      <mi>c</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <ci>normal-⋅</ci>
      <ci>b</ci>
      <ci>c</ci>
     </apply>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=(b\cdot c)\bmod{m}
  </annotation>
 </semantics>
</math>

.</li>
<li>If <em>e</em>′ c \equiv b^e \pmod{m}.</li>
</ol>

<p>Note that in every pass through step 3, the equation 

<math display="inline" id="Modular_exponentiation:6">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>≡</mo>
   <mrow>
    <msup>
     <mi>b</mi>
     <msup>
      <mi>e</mi>
      <mo>′</mo>
     </msup>
    </msup>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>m</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>c</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\equiv b^{e^{\prime}}\;\;(\mathop{{\rm mod}}m)
  </annotation>
 </semantics>
</math>

 holds true. When step 3 has been executed <em>e</em> times, then, <em>c</em> contains the answer that was sought. In summary, this algorithm basically counts up <em>e′</em> by ones until <em>e′</em> reaches <em>e</em>, doing a multiply by b and the modulo operation each time it adds one (to ensure the results stay small).</p>

<p>The example <em>b</em> = 4, <em>e</em> = 13, and <em>m</em> = 497 is presented again. The algorithm passes through step 3 thirteen times:</p>
<ul>
<li><em>e</em>′ = 1. <em>c</em> = (1 ⋅ 4) mod 497 = 4 mod 497 = <strong>4</strong>.</li>
<li><em>e</em>′ = 2. <em>c</em> = (4 ⋅ 4) mod 497 = 16 mod 497 = <strong>16</strong>.</li>
<li><em>e</em>′ = 3. <em>c</em> = (16 ⋅ 4) mod 497 = 64 mod 497 = <strong>64</strong>.</li>
<li><em>e</em>′ = 4. <em>c</em> = (64 ⋅ 4) mod 497 = 256 mod 497 = <strong>256</strong>.</li>
<li><em>e</em>′ = 5. <em>c</em> = (256 ⋅ 4) mod 497 = 1024 mod 497 = <strong>30</strong>.</li>
<li><em>e</em>′ = 6. <em>c</em> = (30 ⋅ 4) mod 497 = 120 mod 497 = <strong>120</strong>.</li>
<li><em>e</em>′ = 7. <em>c</em> = (120 ⋅ 4) mod 497 = 480 mod 497 = <strong>480</strong>.</li>
<li><em>e</em>′ = 8. <em>c</em> = (480 ⋅ 4) mod 497 = 1920 mod 497 = <strong>429</strong>.</li>
<li><em>e</em>′ = 9. <em>c</em> = (429 ⋅ 4) mod 497 = 1716 mod 497 = <strong>225</strong>.</li>
<li><em>e</em>′ = 10. <em>c</em> = (225 ⋅ 4) mod 497 = 900 mod 497 = <strong>403</strong>.</li>
<li><em>e</em>′ = 11. <em>c</em> = (403 ⋅ 4) mod 497 = 1612 mod 497 = <strong>121</strong>.</li>
<li><em>e</em>′ = 12. <em>c</em> = (121 ⋅ 4) mod 497 = 484 mod 497 = <strong>484</strong>.</li>
<li><em>e</em>′ = 13. <em>c</em> = (484 ⋅ 4) mod 497 = 1936 mod 497 = <strong>445</strong>.</li>
</ul>

<p>The final answer for <em>c</em> is therefore 445, as in the first method.</p>

<p>Like the first method, this requires O(<em>e</em>) multiplications to complete. However, since the numbers used in these calculations are much smaller than the numbers used in the first algorithm's calculations, the computation time decreases by a factor of at least O(<em>e</em>) in this method.</p>

<p>In pseudocode, this method can be performed the following way:</p>

<p><strong><code>function</code></strong><code> modular_pow(base, exponent, modulus)</code><br/>
<code>    c := 1</code><br/>
<code>    </code><strong><code>for</code></strong><code> e_prime = 1 </code><strong><code>to</code></strong><code> exponent </code><br/>
<code>        c := (c * base) </code><strong><code>mod</code></strong><code> modulus</code><br/>
<code>    </code><strong><code>return</code></strong><code> c</code></p>
<h2 id="right-to-left-binary-method">Right-to-left binary method</h2>

<p>A third method drastically reduces the number of operations to perform modular exponentiation, while keeping the same memory footprint as in the previous method. It is a combination of the previous method and a more general principle called <a href="exponentiation_by_squaring" title="wikilink">exponentiation by squaring</a> (also known as <em>binary exponentiation</em>).</p>

<p>First, it is required that the exponent <em>e</em> be <a href="Binary_numeral_system#Decimal" title="wikilink">converted to binary notation</a>. That is, <em>e</em> can be written as:<br/>


<math display="block" id="Modular_exponentiation:7">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <msup>
      <mn>2</mn>
      <mi>i</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>e</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e=\sum_{i=0}^{n-1}a_{i}2^{i}
  </annotation>
 </semantics>
</math>

</p>

<p>In such notation, the <em>length</em> of <em>e</em> is <em>n</em> bits. <em>a</em><sub><em>i</em></sub> can take the value 0 or 1 for any <em>i</em> such that 0 ≤ <em>i</em> <em>n</em> - 1 = 1.</p>

<p>The value <em>b</em><sup><em>e</em></sup> can then be written as:<br/>


<math display="block" id="Modular_exponentiation:8">
 <semantics>
  <mrow>
   <msup>
    <mi>b</mi>
    <mi>e</mi>
   </msup>
   <mo>=</mo>
   <msup>
    <mi>b</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mstyle displaystyle="false">
       <msubsup>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msubsup>
      </mstyle>
      <mrow>
       <msub>
        <mi>a</mi>
        <mi>i</mi>
       </msub>
       <msup>
        <mn>2</mn>
        <mi>i</mi>
       </msup>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <msup>
     <mrow>
      <mo>(</mo>
      <msup>
       <mi>b</mi>
       <msup>
        <mn>2</mn>
        <mi>i</mi>
       </msup>
      </msup>
      <mo>)</mo>
     </mrow>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <ci>e</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b^{e}=b^{\left(\sum_{i=0}^{n-1}a_{i}2^{i}\right)}=\prod_{i=0}^{n-1}\left(b^{2^%
{i}}\right)^{a_{i}}
  </annotation>
 </semantics>
</math>

</p>

<p>The solution <em>c</em> is therefore:</p>

<p>

<math display="block" id="Modular_exponentiation:9">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>≡</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <mpadded width="+5pt">
      <msup>
       <mrow>
        <mo>(</mo>
        <msup>
         <mi>b</mi>
         <msup>
          <mn>2</mn>
          <mi>i</mi>
         </msup>
        </msup>
        <mo>)</mo>
       </mrow>
       <msub>
        <mi>a</mi>
        <mi>i</mi>
       </msub>
      </msup>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mpadded width="+5pt">
        <mtext>mod</mtext>
       </mpadded>
       <mi>m</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>c</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <mtext>mod</mtext>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\equiv\prod_{i=0}^{n-1}\left(b^{2^{i}}\right)^{a_{i}}\ (\mbox{mod}\ m)
  </annotation>
 </semantics>
</math>

</p>

<p>The following is an example in pseudocode based on Applied Cryptography by <a href="Bruce_Schneier" title="wikilink">Bruce Schneier</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The inputs <em>base</em>, <em>exponent</em>, and <em>modulus</em> correspond to <em>b</em>, <em>e</em>, and <em>m</em> in the equations given above.</p>

<p><strong><code>function</code></strong><code> modular_pow(base, exponent, modulus)</code><br/>
<code>    </code><a href="Assertion_(computing)" title="wikilink"><code>Assert</code></a><code> :: (modulus - 1) * (modulus - 1) does not overflow base</code><br/>
<code>    result := 1</code><br/>
<code>    base := base </code><strong><code>mod</code></strong><code> modulus</code><br/>
<code>    </code><strong><code>while</code></strong><code> exponent &gt; 0</code><br/>
<code>        </code><strong><code>if</code></strong><code> (exponent </code><strong><code>mod</code></strong><code> 2 == 1):</code><br/>
<code>           result := (result * base) </code><strong><code>mod</code></strong><code> modulus</code><br/>
<code>        exponent := exponent &gt;&gt; 1</code><br/>
<code>        base := (base * base) </code><strong><code>mod</code></strong><code> modulus</code><br/>
<code>    </code><strong><code>return</code></strong><code> result</code></p>

<p>Note that upon entering the loop for the first time, the code variable <em>base</em> is equivalent to 

<math display="inline" id="Modular_exponentiation:10">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

. However, the repeated squaring in the third line of code ensures that at the completion of every loop, the variable <em>base</em> is equivalent to 

<math display="inline" id="Modular_exponentiation:11">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <msup>
     <mi>b</mi>
     <msup>
      <mn>2</mn>
      <mi>i</mi>
     </msup>
    </msup>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mpadded width="+5pt">
      <mtext>mod</mtext>
     </mpadded>
     <mi>m</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>b</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <mtext>mod</mtext>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b^{2^{i}}\ (\mbox{mod}\ m)
  </annotation>
 </semantics>
</math>

, where <em>i</em> is the number of times the loop has been iterated. (This makes <em>i</em> the next working bit of the binary exponent <em>exponent</em>, where the least-significant bit is <em>exponent</em><sub>0</sub>).</p>

<p>The first line of code simply carries out the multiplication in 

<math display="inline" id="Modular_exponentiation:12">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">∏</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <mrow>
    <mpadded width="+5pt">
     <msup>
      <mrow>
       <mo>(</mo>
       <msup>
        <mi>b</mi>
        <msup>
         <mn>2</mn>
         <mi>i</mi>
        </msup>
       </msup>
       <mo>)</mo>
      </mrow>
      <msub>
       <mi>a</mi>
       <mi>i</mi>
      </msub>
     </msup>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mtext>mod</mtext>
      </mpadded>
      <mi>m</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <mtext>mod</mtext>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \prod_{i=0}^{n-1}\left(b^{2^{i}}\right)^{a_{i}}\ (\mbox{mod}\ m)
  </annotation>
 </semantics>
</math>

. If <em>a</em><sub><em>i</em></sub> is zero, no code executes since this effectively multiplies the running total by one. If <em>a</em><sub><em>i</em></sub> instead is one, the variable <em>base</em> (containing the value 

<math display="inline" id="Modular_exponentiation:13">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <msup>
     <mi>b</mi>
     <msup>
      <mn>2</mn>
      <mi>i</mi>
     </msup>
    </msup>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mpadded width="+5pt">
      <mtext>mod</mtext>
     </mpadded>
     <mi>m</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>b</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <mtext>mod</mtext>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b^{2^{i}}\ (\mbox{mod}\ m)
  </annotation>
 </semantics>
</math>

 of the original base) is simply multiplied in.</p>

<p>Example: <em>base</em> = 4, <em>exponent</em> = 13, and <em>modulus</em> = 497. Note that <em>exponent</em> is 1101 in binary notation. Because <em>exponent</em> is four binary digits in length, the loop executes only four times:</p>
<ul>
<li>Upon entering the loop for the first time, variables <em>base</em> = 4, <em>exponent</em> = 1101 (binary), and <em>result</em> = 1. Because the right-most bit of <em>exponent</em> is 1, <em>result</em> is changed to be (1 * 4)% 497, or <strong>4</strong>. <em>exponent</em> is right-shifted to become 110 (binary), and <em>base</em> is squared to be (4 * 4)% 497, or 16.</li>
<li>The second time through the loop, the right-most bit of <em>exponent</em> is 0, causing <em>result</em> to retain its present value of <strong>4</strong>. <em>exponent</em> is right-shifted to become 11 (binary), and <em>base</em> is squared to be (16 * 16)% 497, or 256.</li>
<li>The third time through the loop, the right-most bit of <em>e</em> is 1. <em>result</em> is changed to be (4 * 256)% 497, or <strong>30</strong>. <em>exponent</em> is right-shifted to become 1, and <em>base</em> is squared to be (256 * 256)% 497, or 429.</li>
<li>The fourth time through the loop, the right-most bit of <em>exponent</em> is 1. <em>result</em> is changed to be (30 * 429)% 497, or <strong>445</strong>. <em>exponent</em> is right-shifted to become 0, and <em>base</em> is squared to be (429 * 429)% 497, or 151.</li>
</ul>

<p>The loop then terminates since <em>exponent</em> is zero, and the result <strong>445</strong> is returned. This agrees with the previous two algorithms.</p>

<p>The running time of this algorithm is O(log <em>exponent</em>). When working with large values of <em>exponent</em>, this offers a substantial speed benefit over both of the previous two algorithms.</p>
<h2 id="matrices">Matrices</h2>

<p>The <a href="Fibonacci_numbers" title="wikilink">Fibonacci numbers</a> modulo n can be computed efficiently by computing A<sup>m</sup> (mod n) for a certain m and a certain matrix A. The above methods adapt easily to this application. This provides a very good <a href="Fibonacci_numbers#Primality_Testing" title="wikilink">primality test</a> for large--say 500-bit--numbers n.</p>
<h3 id="pseudocode">Pseudocode</h3>

<p>A Recursive Algorithm for ModExp(A, b, c) = A<sup>b</sup> (mod c), where A is a square matrix.</p>

<p><strong><code>function</code></strong><code> Matrix_ModExp(Matrix A, int b, int c)</code><br/>
<code>   </code><strong><code>if</code></strong><code> (b == 0):</code><br/>
<code>         </code><strong><code>return</code></strong><code> I  // The identity matrix</code><br/>
<code>   </code><strong><code>if</code></strong><code> (b </code><strong><code>mod</code></strong><code> 2 == 1):</code><br/>
<code>         </code><strong><code>return</code></strong><code> (A * Matrix_ModExp(A, b - 1, c)) </code><strong><code>mod</code></strong><code> c </code><br/>
<code>   Matrix D := Matrix_ModExp(A, b / 2, c)</code><br/>
<code>   </code><strong><code>return</code></strong><code> (D * D) </code><strong><code>mod</code></strong><code> c</code></p>
<h2 id="finite-cyclic-groups">Finite cyclic groups</h2>

<p><a href="Diffie-Hellman_key_exchange" title="wikilink">Diffie-Hellman key exchange</a> uses exponentiation in finite cyclic groups. The above methods for modular matrix exponentiation clearly extend to this context. The modular matrix multiplication  is simply replaced everywhere by the group multiplication .</p>
<h2 id="reversible-and-quantum-modular-exponentiation">Reversible and quantum modular exponentiation</h2>

<p>In <a href="quantum_computing" title="wikilink">quantum computing</a>, modular exponentiation appears as the bottleneck of <a href="Shor's_algorithm" title="wikilink">Shor's algorithm</a>, where it must be computed by a circuit consisting of <a href="reversible_computing" title="wikilink">reversible gates</a>, which can be further broken down into <a href="quantum_gate" title="wikilink">quantum gates</a> appropriate for a specific physical device. Furthermore, in Shor's algorithm it is possible to know the base and the modulus of exponentiation at every call, which enables various circuit optimizations.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="in-programming-languages">In programming languages</h2>

<p>Because modular exponentiation is an important operation in computer science, and there are efficient algorithms (see above) that are much faster than simply exponentiating and then taking the remainder, many programming languages and arbitrary-precision integer libraries have a dedicated function to perform modular exponentiation:</p>
<ul>
<li><a href="Python_(programming_language)" title="wikilink">Python</a>'s built-in <code>pow()</code> (exponentiation) function <a href="https://docs.python.org/library/functions.html#pow">1</a> takes an optional third argument which is the number to modulo by</li>
<li><a href=".NET_Framework" title="wikilink">.NET Framework</a>'s <code>BigInteger</code> class has a <a href="http://msdn.microsoft.com/en-us/library/system.numerics.biginteger.modpow%28v=vs.100%29.aspx#pow">ModPow()</a> method to perform modular exponentiation</li>
<li><a href="Java_(programming_language)" title="wikilink">Java</a>'s <code>java.math.BigInteger</code> class has a  method to perform modular exponentiation</li>
<li><a class="uri" href="Perl" title="wikilink">Perl</a>'s <code>Math::BigInt</code> module has a <code>bmodpow()</code> method <a href="http://perldoc.perl.org/Math/BigInt.html#bmodpow%28%29">2</a> to perform modular exponentiation</li>
<li><a href="Go_(programming_language)" title="wikilink">Go</a>'s <code>big.Int</code> type contains an <code>Exp()</code> (exponentiation) method <a href="http://golang.org/pkg/big/#Int.Exp">3</a> whose third parameter, if non-nil, is the number to modulo by</li>
<li><a class="uri" href="PHP" title="wikilink">PHP</a>'s BC Math library has a <code>bcpowmod()</code> function <a href="http://www.php.net/manual/en/function.bcpowmod.php">4</a> to perform modular exponentiation</li>
<li>The <a href="GNU_Multiple_Precision_Arithmetic_Library" title="wikilink">GNU Multiple Precision Arithmetic Library</a> (GMP) library contains a <code>mpz_powm()</code> function <a href="http://gmplib.org/manual/Integer-Exponentiation.html">5</a> to perform modular exponentiation</li>
<li>Custom Function <code>[http://www.briandunning.com/cf/1482 @PowerMod()]</code> for <a href="FileMaker" title="wikilink">FileMaker Pro</a> (with 1024-bit <a href="RSA_(algorithm)" title="wikilink">RSA</a> encryption example)</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Montgomery_reduction" title="wikilink">Montgomery reduction</a>, for calculating the remainder when the modulus is very large.</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.math.umn.edu/~garrett/crypto/a01/FastPow.html">Fast Modular Exponentiation Java Applet</a> - <a href="University_of_Minnesota" title="wikilink">University of Minnesota</a> Math Department</li>
</ul>

<p>"</p>

<p><a href="Category:Cryptographic_algorithms" title="wikilink">Category:Cryptographic algorithms</a> <a href="Category:Number_theoretic_algorithms" title="wikilink">Category:Number theoretic algorithms</a> <a href="Category:Modular_arithmetic" title="wikilink">Category:Modular arithmetic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#Schneier96" title="wikilink">Schneier 1996</a>, p. 244.<a href="#fnref1">↩</a></li>
<li id="fn2">Igor L. Markov, Mehdi Saeedi, "Constant-Optimized Quantum Circuits for Modular Multiplication and Exponentiation", Quantum Information and Computation, Vol. 12, No. 5&amp;6, pp. 0361-0394, 2012.http://arxiv.org/abs/1202.6614<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
