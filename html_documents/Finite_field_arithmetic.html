<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1714">Finite field arithmetic</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Finite field arithmetic</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p><strong>Arithmetic in a <a href="finite_field" title="wikilink">finite field</a></strong> is different from standard integer <a class="uri" href="arithmetic" title="wikilink">arithmetic</a>. There are a limited number of elements in the finite field; all operations performed in the finite field result in an element within that field.</p>

<p>While each finite field is itself not infinite, there are infinitely many different finite fields; their number of elements (which is also called <a href="cardinal_number" title="wikilink">cardinality</a>) is necessarily of the form <em>p</em><sup><em>n</em></sup> where <em>p</em> is a <a href="prime_number" title="wikilink">prime number</a> and <em>n</em> is a <a href="positive_integer" title="wikilink">positive integer</a>, and two finite fields of the same size are <a href="isomorphism" title="wikilink">isomorphic</a>. The prime <em>p</em> is called the <a href="characteristic_(algebra)" title="wikilink">characteristic</a> of the field, and the positive integer <em>n</em> is called the <a href="dimension_(vector_space)" title="wikilink">dimension</a> of the field over its <a href="characteristic_(algebra)#Case_of_fields" title="wikilink">prime field</a>.</p>

<p>Finite fields are used in a variety of applications, including in classical <a href="coding_theory" title="wikilink">coding theory</a> in <a href="linear_block_code" title="wikilink">linear block codes</a> such as <a href="BCH_code" title="wikilink">BCH codes</a> and <a href="Reed–Solomon_error_correction" title="wikilink">Reed–Solomon error correction</a> and in <a class="uri" href="cryptography" title="wikilink">cryptography</a> algorithms such as the <a class="uri" href="Rijndael" title="wikilink">Rijndael</a> encryption algorithm.</p>
<h2 id="effective-polynomial-representation">Effective polynomial representation</h2>

<p>The finite field with <em>p</em><sup><em>n</em></sup> elements is denoted GF(<em>p</em><sup><em>n</em></sup>) and is also called the <strong>Galois Field</strong>, in honor of the founder of finite field theory, <a href="Évariste_Galois" title="wikilink">Évariste Galois</a>. GF(<em>p</em>), where <em>p</em> is a prime number, is simply the <a href="ring_(algebra)" title="wikilink">ring</a> of integers <a href="Modular_arithmetic" title="wikilink">modulo</a> <em>p</em>. That is, one can perform operations (addition, subtraction, multiplication) using the usual operation on integers, followed by reduction modulo <em>p</em>. For instance, in GF(5), 4+3=7 is reduced to 2 modulo 5. Division is multiplication by the inverse modulo <em>p</em>, which may be computed using the <a href="extended_Euclidean_algorithm" title="wikilink">extended Euclidean algorithm</a>.</p>

<p>A particular case is GF(2), where addition is <a href="XOR_gate" title="wikilink">exclusive OR</a> (XOR) and multiplication is <a href="AND_gate" title="wikilink">AND</a>. Since the only invertible element is 1, division is the <a href="identity_function" title="wikilink">identity function</a>.</p>

<p>Elements of GF(<em>p</em><sup><em>n</em></sup>) may be represented as <a href="polynomial" title="wikilink">polynomials</a> of degree strictly less than <em>n</em> over GF(<em>p</em>). Operations are then performed modulo <em>R</em> where <em>R</em> is an <a href="irreducible_polynomial" title="wikilink">irreducible polynomial</a> of degree <em>n</em> over GF(<em>p</em>), for instance using <a href="polynomial_long_division" title="wikilink">polynomial long division</a>. The addition of two polynomials <em>P</em> and <em>Q</em> is done as usual; multiplication may be done as follows: compute <em>W</em> =<em>P</em>.<em>Q</em> as usual, then compute the remainder modulo <em>R</em> (there exist better ways to do this).</p>

<p>When the prime is 2, it is conventional to express elements of GF(<em>p</em><sup><em>n</em></sup>) as <a href="binary_numeral_system" title="wikilink">binary numbers</a>, with each term in a polynomial represented by one bit in the corresponding element's binary expression. Braces ( "{" and "}" ) or similar delimiters are commonly added to binary numbers, or to their hexadecimal equivalents, to indicate that the value is an element of a field. For example, the following are equivalent representations of the same value in a characteristic 2 finite field:</p>
<dl>
<dt>Polynomial: <em>x</em><sup>6</sup> + <em>x</em><sup>4</sup> + <em>x</em> + 1<br/>
Binary: {01010011}<br/>
Hexadecimal: {53}</dt>
</dl>
<h2 id="addition-and-subtraction">Addition and subtraction</h2>

<p>Addition and subtraction are performed by adding or subtracting two of these polynomials together, and reducing the result modulo the characteristic.</p>

<p>In a finite field with characteristic 2, addition modulo 2, subtraction modulo 2, and XOR are identical. Thus,</p>
<dl>
<dt>Polynomial: (<em>x</em><sup>6</sup> + <em>x</em><sup>4</sup> + <em>x</em> + 1) + (<em>x</em><sup>7</sup> + <em>x</em><sup>6</sup> + <em>x</em><sup>3</sup> + <em>x</em>) = <em>x</em><sup>7</sup> + <em>x</em><sup>4</sup> + <em>x</em><sup>3</sup> + 1<br/>
Binary: {01010011} + {11001010} = {10011001}<br/>
Hexadecimal: {53} + {CA} = {99}</dt>
</dl>

<p>Notice that under regular addition of polynomials, the sum would contain a term 2<em>x</em><sup>6</sup>, but that this term becomes 0<em>x</em><sup>6</sup> and is dropped when the answer is reduced modulo 2.</p>

<p>Here is a table with both the normal algebraic sum and the characteristic 2 finite field sum of a few polynomials:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>p<sub>1</sub></p></td>
<td style="text-align: left;">
<p>p<sub>2</sub></p></td>
<td style="text-align: left;">
<p>p<sub>1</sub> + p<sub>2</sub> (normal algebra)</p></td>
<td style="text-align: left;">
<p>p<sub>1</sub> + p<sub>2</sub> in GF(2<sup>n</sup>)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>x<sup>3</sup> + x + 1</p></td>
<td style="text-align: left;">
<p>x<sup>3</sup> + x<sup>2</sup></p></td>
<td style="text-align: left;">
<p>2x<sup>3</sup> + x<sup>2</sup> + x + 1</p></td>
<td style="text-align: left;">
<p>x<sup>2</sup> + x + 1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>x<sup>4</sup> + x<sup>2</sup></p></td>
<td style="text-align: left;">
<p>x<sup>6</sup> + x<sup>2</sup></p></td>
<td style="text-align: left;">
<p>x<sup>6</sup> + x<sup>4</sup> + 2x<sup>2</sup></p></td>
<td style="text-align: left;">
<p>x<sup>6</sup> + x<sup>4</sup></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>x + 1</p></td>
<td style="text-align: left;">
<p>x<sup>2</sup> + 1</p></td>
<td style="text-align: left;">
<p>x<sup>2</sup> + x + 2</p></td>
<td style="text-align: left;">
<p>x<sup>2</sup> + x</p>
</td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>x<sup>3</sup> + x</p></td>
<td style="text-align: left;">
<p>x<sup>2</sup> + 1</p></td>
<td style="text-align: left;">
<p>x<sup>3</sup> + x<sup>2</sup> + x + 1</p></td>
<td style="text-align: left;">
<p>x<sup>3</sup> + x<sup>2</sup> + x + 1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>x<sup>2</sup> + x</p></td>
<td style="text-align: left;">
<p>x<sup>2</sup> + x</p></td>
<td style="text-align: left;">
<p>2x<sup>2</sup> + 2x</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
</tbody>
</table>

<p>Note: In computer science applications, the operations are simplified for finite fields of characteristic 2, also called GF(2<sup>n</sup>) <a href="Galois_field" title="wikilink">Galois fields</a>, making these fields especially popular choices for applications.</p>
<h2 id="multiplication">Multiplication</h2>

<p>Multiplication in a finite field is multiplication <a href="Equivalence_relation" title="wikilink">modulo</a> an <a href="irreducible_polynomial" title="wikilink">irreducible</a> reducing polynomial used to define the finite field. (I.e., it is multiplication followed by division using the reducing polynomial as the divisor—the remainder is the product.) The symbol "•" may be used to denote multiplication in a finite field.</p>
<h3 id="rijndaels-finite-field">Rijndael's finite field</h3>

<p><a class="uri" href="Rijndael" title="wikilink">Rijndael</a> uses a characteristic 2 finite field with 256 elements, which can also be called the Galois field <strong>GF</strong>(2<sup>8</sup>). It employs the following reducing polynomial for multiplication:</p>
<dl>
<dd><em>x</em><sup>8</sup> + <em>x</em><sup>4</sup> + <em>x</em><sup>3</sup> + <em>x</em> + 1.
</dd>
</dl>

<p>For example, {53} • {CA} = {01} in Rijndael's field because</p>

<p>(<em>x</em><sup>6</sup> + <em>x</em><sup>4</sup> + <em>x</em> + 1)(<em>x</em><sup>7</sup> + <em>x</em><sup>6</sup> + <em>x</em><sup>3</sup> + <em>x</em>) =</p>

<p>(<em>x</em><sup>13</sup> + <em>x</em><sup>12</sup> + <em>x</em><sup>9</sup> + <strong>x<sup>7</sup></strong>) + (<em>x</em><sup>11</sup> + <em>x</em><sup>10</sup> + <strong>x<sup>7</sup></strong> + <em>x</em><sup>5</sup>) + (<em>x</em><sup>8</sup> + <strong>x<sup>7</sup></strong> + <em>x</em><sup>4</sup> + <em>x</em><sup>2</sup>) + (<strong>x<sup>7</sup></strong> + <em>x</em><sup>6</sup> + <em>x</em><sup>3</sup> + <em>x</em>) =</p>

<p><em>x</em><sup>13</sup> + <em>x</em><sup>12</sup> + <em>x</em><sup>9</sup> + <em>x</em><sup>11</sup> + <em>x</em><sup>10</sup> + <em>x</em><sup>5</sup> + <em>x</em><sup>8</sup> + <em>x</em><sup>4</sup> + <em>x</em><sup>2</sup> + <em>x</em><sup>6</sup> + <em>x</em><sup>3</sup> + <em>x</em> =</p>

<p><em>x</em><sup>13</sup> + <em>x</em><sup>12</sup> + <em>x</em><sup>11</sup> + <em>x</em><sup>10</sup> + <em>x</em><sup>9</sup> + <em>x</em><sup>8</sup> + <em>x</em><sup>6</sup> + <em>x</em><sup>5</sup> + <em>x</em><sup>4</sup> + <em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + <em>x</em></p>

<p>and</p>

<p><em>x</em><sup>13</sup> + <em>x</em><sup>12</sup> + <em>x</em><sup>11</sup> + <em>x</em><sup>10</sup> + <em>x</em><sup>9</sup> + <em>x</em><sup>8</sup> + <em>x</em><sup>6</sup> + <em>x</em><sup>5</sup> + <em>x</em><sup>4</sup> + <em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + <em>x</em> modulo <em>x</em><sup>8</sup> + <em>x</em><sup>4</sup> + <em>x</em><sup>3</sup> + <em>x</em><sup>1</sup> + 1 = (11111101111110 mod 100011011) = {3F7E mod 11B} = {01} = 1 (decimal), which can be demonstrated through <a href="long_division" title="wikilink">long division</a> (shown using binary notation, since it lends itself well to the task. Notice that <a href="Exclusive_or#Truth_table" title="wikilink">exclusive OR</a> is applied in the example and not arithmetic subtraction, as one might use in grade-school long division.):</p>

<p><code>         </code><u><code> </code></u><br/>
<code>          11111101111110 (mod) 100011011</code><br/>
<code>         </code><u><code>^100011011     </code></u><br/>
<code>           1110000011110</code><br/>
<code>          </code><u><code>^100011011    </code></u><br/>
<code>            110110101110</code><br/>
<code>           </code><u><code>^100011011   </code></u><br/>
<code>             10101110110</code><br/>
<code>            </code><u><code>^100011011  </code></u><br/>
<code>              0100011010</code><br/>
<code>              </code><u><code>^100011011 </code></u><br/>
<code>                00000001</code></p>

<p>(The elements {53} and {CA} are <a href="multiplicative_inverse" title="wikilink">multiplicative inverses</a> of one another since their product is <a href="1_(number)" title="wikilink">1</a>.)</p>

<p>Multiplication in this particular finite field can also be done using a modified version of the "<a href="Multiplication_algorithm#Peasant_or_binary_multiplication" title="wikilink">peasant's algorithm</a>". Each polynomial is represented using the same binary notation as above. Eight bits is sufficient because only degrees 0 to 7 are possible in the terms of each (reduced) polynomial.</p>

<p>This algorithm uses three <a href="Variable_(programming)" title="wikilink">variables</a> (in the computer programming sense), each holding an eight-bit representation. <strong>a</strong> and <strong>b</strong> are initialized with the multiplicands; <strong>p</strong> accumulates the product and must be initialized to 0.</p>

<p>At the start and end of the algorithm, and the start and end of each iteration, this <a href="invariant_(computer_science)" title="wikilink">invariant</a> is true: <strong>a</strong> <strong>b</strong> + <strong>p</strong> is the product. This is obviously true when the algorithm starts. When the algorithm terminates, <strong>a</strong> or <strong>b</strong> will be zero so <strong>p</strong> will contain the product.</p>
<ul>
<li>Run the following loop eight times (once per bit). It is OK to stop when <strong>a</strong> or <strong>b</strong> are zero before an iteration:
<ol>
<li>If the rightmost bit of <strong>b</strong> is set, exclusive OR the product <strong>p</strong> by the value of <strong>a</strong>. This is polynomial addition.</li>
<li>Shift <strong>b</strong> one bit to the right, discarding the rightmost bit, and making the leftmost bit have a value of zero. This divides the polynomial by <strong>x</strong>, discarding the <em>x</em><sup>0</sup> term.</li>
<li>Keep track of whether the leftmost bit of <strong>a</strong> is set to one and call this value <strong>carry</strong>.</li>
<li>Shift <strong>a</strong> one bit to the left, discarding the leftmost bit, and making the new rightmost bit zero. This multiplies the polynomial by <strong>x</strong>, but we still need to take account of <strong>carry</strong> which represented the coefficient of <em>x</em><sup>7</sup>.</li>
<li>If <strong>carry</strong> had a value of one, exclusive or <strong>a</strong> with the hexadecimal number <code>0x1b</code> (00011011 in binary). <code>0x1b</code> corresponds to the irreducible polynomial with the high term eliminated. Conceptually, the high term of the irreducible polynomial and <strong>carry</strong> add modulo 2 to 0.</li>
</ol></li>
<li><strong>p</strong> now has the product</li>
</ul>

<p>This algorithm generalizes easily to multiplication over other fields of characteristic 2, changing the lengths of <strong>a</strong>, <strong>b</strong>, and <strong>p</strong> and the value <code>0x1b</code> appropriately.</p>
<h2 id="multiplicative-inverse">Multiplicative inverse</h2>

<p>The <a href="multiplicative_inverse" title="wikilink">multiplicative inverse</a> for an element <strong>a</strong> of a finite field can be calculated a number of different ways:</p>
<ul>
<li>By multiplying <strong>a</strong> by every number in the field until the product is one. This is a <a href="Brute-force_search" title="wikilink">Brute-force search</a>.</li>
</ul>
<ul>
<li>Since the nonzero elements of GF(<em>p</em><sup><em>n</em></sup>) form a <a href="finite_group" title="wikilink">finite group</a> with respect to multiplication, <em>a</em><sup><em>p</em><sup><em>n</em></sup>-1</sup> = 1 (for <em>a</em> ≠ 0), thus the inverse of <em>a</em> is ''a<sup>''p<sup><em>n</em></sup>-2</sup>.</li>
</ul>
<ul>
<li>By using the <a href="Extended_Euclidean_algorithm" title="wikilink">Extended Euclidean algorithm</a>.</li>
</ul>
<ul>
<li>By making a <a class="uri" href="logarithm" title="wikilink">logarithm</a> table of the finite field, and performing subtraction in the table. Subtraction of logarithms is the same as division.</li>
</ul>
<h2 id="implementation-tricks">Implementation tricks</h2>

<p>When developing algorithms for Galois field computation on small Galois fields, a common performance optimization approach is to find a <a href="Generating_set_of_a_group#Finitely_generated_group" title="wikilink">generator</a> g and use the identity:</p>

<p>

<math display="block" id="Finite_field_arithmetic:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mi>b</mi>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>g</mi>
    <mrow>
     <msub>
      <mi>log</mi>
      <mi>g</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mo>=</mo>
   <msup>
    <mi>g</mi>
    <mrow>
     <mrow>
      <msub>
       <mi>log</mi>
       <mi>g</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>log</mi>
       <mi>g</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <ci>g</ci>
       </apply>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <apply>
       <plus></plus>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <ci>g</ci>
        </apply>
        <ci>a</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <ci>g</ci>
        </apply>
        <ci>b</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ab=g^{\log_{g}(ab)}=g^{\log_{g}(a)+\log_{g}(b)}
  </annotation>
 </semantics>
</math>

</p>

<p>to implement multiplication as a sequence of table look ups for the log<sub>g</sub>(x) and g<sup>(x)</sup> functions and an integer addition operation. This exploits the property that all finite fields contain generators. In the Rijndael field example, the polynomial x + 1 (or {03}) is one such generator, since it is <a href="Irreducible_polynomial" title="wikilink">irreducible</a>.</p>

<p>This same strategy can be used to determine the multiplicative inverse with the identity:</p>

<p>

<math display="block" id="Finite_field_arithmetic:1">
 <semantics>
  <mrow>
   <msup>
    <mi>a</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>=</mo>
   <msup>
    <mi>g</mi>
    <mrow>
     <msub>
      <mi>log</mi>
      <mi>g</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>a</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mo>=</mo>
   <msup>
    <mi>g</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>log</mi>
       <mi>g</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
   <mo>=</mo>
   <msup>
    <mi>g</mi>
    <mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>g</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>log</mi>
       <mi>g</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <ci>g</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <apply>
       <minus></minus>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <ci>g</ci>
        </apply>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <apply>
       <minus></minus>
       <apply>
        <abs></abs>
        <ci>g</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <ci>g</ci>
        </apply>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{-1}=g^{\log_{g}(a^{-1})}=g^{-\log_{g}(a)}=g^{|g|-\log_{g}(a)}
  </annotation>
 </semantics>
</math>

</p>

<p>Here, the <a href="Order_(group_theory)" title="wikilink">order</a> of the generator, |g|, is the number of non-zero elements of the field. In the case of GF(2<sup>8</sup>) this is 2<sup>8</sup>-1 = 255. That is to say, for the Rijndael example: (x + 1)<sup>255</sup> = 1. So this can be performed with two look up tables and an integer subtract. Using this idea for exponentiation also derives benefit:</p>

<p>

<math display="block" id="Finite_field_arithmetic:2">
 <semantics>
  <mrow>
   <msup>
    <mi>a</mi>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <msup>
    <mi>g</mi>
    <mrow>
     <msub>
      <mi>log</mi>
      <mi>g</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>a</mi>
       <mi>n</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mo>=</mo>
   <msup>
    <mi>g</mi>
    <mrow>
     <mi>n</mi>
     <mrow>
      <msub>
       <mi>log</mi>
       <mi>g</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
   <mo>=</mo>
   <msup>
    <mi>g</mi>
    <mrow>
     <mi>n</mi>
     <mrow>
      <msub>
       <mi>log</mi>
       <mi>g</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>m</mi>
       <mi>o</mi>
       <mi>d</mi>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>g</mi>
        <mo stretchy="false">|</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <ci>g</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <ci>g</ci>
        </apply>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <ci>g</ci>
        </apply>
        <ci>a</ci>
       </apply>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>o</ci>
        <ci>d</ci>
        <apply>
         <abs></abs>
         <ci>g</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{n}=g^{\log_{g}(a^{n})}=g^{n\log_{g}(a)}=g^{n\log_{g}(a)(mod|g|)}
  </annotation>
 </semantics>
</math>

</p>

<p>This requires two table look ups, an integer multiplication and an integer modulo operation.</p>

<p>However, in cryptographic implementations, one has to be careful with such implementations since the <a href="CPU_cache" title="wikilink">cache architecture</a> of many microprocessors leads to variable timing for memory access. This can lead to implementations that are vulnerable to a <a href="timing_attack" title="wikilink">timing attack</a>.</p>
<h2 id="program-examples">Program examples</h2>
<h3 id="c-programming-example">C programming example</h3>

<p>Here is some <a href="C_(programming_language)" title="wikilink">C</a> code which will add, subtract, and multiply numbers in a finite field of characteristic 2^8, used for example by Rijndael algorithm or Reed-Solomon, using the <a href="Ancient_Egyptian_multiplication#Russian_peasant_multiplication" title="wikilink">Russian Peasant Multiplication algorithm</a>:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* Add two numbers in a GF(2^8) finite field */</span>
<span class="dt">unsigned</span> <span class="dt">int</span> gadd(<span class="dt">unsigned</span> <span class="dt">int</span> a, <span class="dt">unsigned</span> <span class="dt">int</span> b) {
    <span class="kw">return</span> a ^ b;
}

<span class="co">/* Subtract two numbers in a GF(2^8) finite field */</span>
<span class="dt">unsigned</span> <span class="dt">int</span> gsub(<span class="dt">unsigned</span> <span class="dt">int</span> a, <span class="dt">unsigned</span> <span class="dt">int</span> b) {
    <span class="kw">return</span> a ^ b;
}

<span class="co">/* Multiply two numbers in the GF(2^8) finite field defined </span>
<span class="co"> * by the polynomial x^8 + x^4 + x^3 + x + 1 = 0</span>
<span class="co"> * using the Russian Peasant Multiplication algorithm</span>
<span class="co"> * (the other way being to do carry-less multiplication followed by a modular reduction)</span>
<span class="co"> */</span>
<span class="dt">unsigned</span> <span class="dt">int</span> gmul(<span class="dt">unsigned</span> <span class="dt">int</span> a, <span class="dt">unsigned</span> <span class="dt">int</span> b) {
    <span class="dt">unsigned</span> <span class="dt">int</span> p = <span class="dv">0</span>; <span class="co">/* the product of the multiplication */</span>
    <span class="dt">int</span> counter;
    <span class="kw">for</span> (counter = <span class="dv">0</span>; counter &lt; <span class="dv">8</span>; counter++) {
            <span class="kw">if</span> (b &amp; <span class="dv">1</span>) <span class="co">/* if b is odd, then add the corresponding a to p (final product = sum of all a's corresponding to odd b's) */</span>
                p ^= a; <span class="co">/* since we're in GF(2^m), addition is an XOR */</span>
            a &lt;&lt;= <span class="dv">1</span>; <span class="co">/* equivalent to a*2 */</span>
            <span class="kw">if</span> (a &amp; <span class="bn">0x100</span>) <span class="co">/* GF modulo: if a &gt;= 256 (2^8 + 1) then apply modular reduction using the primitive polynomial */</span>
                a ^= <span class="bn">0x11b</span>; <span class="co">/* XOR with the primitive polynomial x^8 + x^4 + x^3 + x + 1 -- you can change it but it must be irreducible */</span>
            b &gt;&gt;= <span class="dv">1</span>; <span class="co">/* equivalent to b // 2 */</span>
    }
    <span class="kw">return</span> p;
}</code></pre></div>

<p>This example has <a href="Timing_attack" title="wikilink">cache, timing, and branch prediction side-channel</a> leaks, and is not suitable for use in cryptography.</p>
<h3 id="d-programming-example">D programming example</h3>

<p>This <a href="D_(programming_language)" title="wikilink">D</a> program will multiply numbers in Rijndael's finite field and generate a <a href="Netpbm_format#PGM_example" title="wikilink">PGM</a> image:</p>
<div class="sourceCode"><pre class="sourceCode D"><code class="sourceCode d"><span class="co">/**</span>
<span class="co">Multiply two numbers in the GF(2^8) finite field defined</span>
<span class="co">by the polynomial x^8 + x^4 + x^3 + x + 1.</span>
<span class="co">*/</span>
<span class="dt">ubyte</span> gMul(<span class="dt">ubyte</span> a, <span class="dt">ubyte</span> b) <span class="kw">pure</span> <span class="kw">nothrow</span> {
    <span class="dt">ubyte</span> p = <span class="dv">0</span>;

    <span class="kw">foreach</span> (<span class="kw">immutable</span> <span class="dt">ubyte</span> counter; <span class="dv">0</span> .. <span class="dv">8</span>) {
        <span class="kw">if</span> (b &amp; <span class="dv">1</span>)
            p ^= a;
        <span class="kw">immutable</span> <span class="dt">ubyte</span> carry = a &amp; <span class="bn">0x80</span>;
        a &lt;&lt;= <span class="dv">1</span>;
        <span class="kw">if</span> (carry != <span class="dv">0</span>)
            a ^= <span class="bn">0b1_0001_1011</span>; <span class="co">// x^8 + x^4 + x^3 + x + 1.</span>
        b &gt;&gt;= <span class="dv">1</span>;
    }

    <span class="kw">return</span> p;
}

<span class="dt">void</span> main() {
    <span class="kw">import</span> std.stdio, std.conv;
    <span class="kw">enum</span> width = <span class="dt">ubyte</span>.<span class="dt">max</span> + <span class="dv">1</span>, height = width;

    <span class="kw">auto</span> f = File(<span class="st">"rijndael_finite_field_multiplication.pgm"</span>, <span class="st">"wb"</span>);
    f.writefln(<span class="st">"P5\n%d %d\n255"</span>, width, height);
    <span class="kw">foreach</span> (<span class="kw">immutable</span> y; <span class="dv">0</span> .. height)
        <span class="kw">foreach</span> (<span class="kw">immutable</span> x; <span class="dv">0</span> .. width) {
            <span class="kw">immutable</span> <span class="dt">char</span> c = gMul(x.to!<span class="dt">ubyte</span>, y.to!<span class="dt">ubyte</span>);
            f.write(c);
        }
}</code></pre></div>

<p>This example has <a href="Timing_attack" title="wikilink">cache, timing, and branch prediction side-channel</a> leaks, and is not suitable for use in cryptography.</p>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.samiam.org/galois.html">A description of Rijndael's finite field</a></li>
<li><a href="http://web.eecs.utk.edu/~plank/plank/papers/CS-07-593/">Fast Galois Field Arithmetic Library in C/C++</a></li>
<li><a href="https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders#Finite_field_arithmetic">Wikiversity: Reed-Solomon for Coders - Finite Field Arithmetic</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Arithmetic" title="wikilink">Category:Arithmetic</a> <a href="Category:Finite_fields" title="wikilink">Arithmetic</a> <a href="Category:Articles_with_example_D_code" title="wikilink">Category:Articles with example D code</a></p>
</body>

