<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1142">Deutsch–Jozsa algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Deutsch–Jozsa algorithm</h1>
<hr/>

<p>The <strong>Deutsch–Jozsa algorithm</strong> is a <a href="quantum_algorithm" title="wikilink">quantum algorithm</a>, proposed by <a href="David_Deutsch" title="wikilink">David Deutsch</a> and <a href="Richard_Jozsa" title="wikilink">Richard Jozsa</a> in 1992<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> with improvements by <a href="Richard_Cleve" title="wikilink">Richard Cleve</a>, <a href="Artur_Ekert" title="wikilink">Artur Ekert</a>, Chiara Macchiavello, and <a href="Michele_Mosca" title="wikilink">Michele Mosca</a> in 1998.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Although of little practical use, it is one of the first examples of a quantum algorithm that is exponentially faster than any possible deterministic classical algorithm. It is also a <a href="deterministic_algorithm" title="wikilink">deterministic algorithm</a>, meaning that it always produces an answer, and that answer is always correct.</p>
<h2 id="problem-statement">Problem statement</h2>

<p>In the Deutsch-Jozsa problem, we are given a black box quantum computer known as an <a href="Oracle_machine" title="wikilink">oracle</a> that implements the function 

<math display="inline" id="Deutsch–Jozsa_algorithm:0">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
     <mi>n</mi>
    </msup>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <ci>n</ci>
     </apply>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\{0,1\}^{n}\rightarrow\{0,1\}
  </annotation>
 </semantics>
</math>

. In layman's terms, it takes n-digit binary values as input and produces either a 0 or a 1 as output for each such value. We are <a href="promise_problem" title="wikilink">promised</a> that the function is either <a href="constant_function" title="wikilink">constant</a> (0 on all inputs or 1 on all inputs) or <em>balanced</em><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> (returns 1 for half of the input <a href="function_domain" title="wikilink">domain</a> and 0 for the other half); the task then is to determine if 

<math display="inline" id="Deutsch–Jozsa_algorithm:1">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is constant or balanced by using the oracle.</p>
<h2 id="motivation">Motivation</h2>

<p>The Deutsch–Jozsa problem is specifically designed to be easy for a quantum algorithm and hard for any deterministic classical algorithm. The motivation is to show a black box problem that can be solved efficiently by a quantum computer with no error, whereas a deterministic classical computer would need exponentially many queries to the black box to solve the problem. More formally, it yields an oracle relative to which <strong><a href="EQP_(complexity)" title="wikilink">EQP</a></strong>, the class of problems that can be solved exactly in polynomial time on a quantum computer, and <strong>P</strong> are different.</p>

<p>Since the problem is easy to solve on a probabilistic classical computer, it does not yield an oracle separation with <strong><a href="BPP_(complexity)" title="wikilink">BPP</a></strong>, the class of problems that can be solved with bounded error in polynomial time on a probabilistic classical computer. <a href="Simon's_problem" title="wikilink">Simon's problem</a> is an example of a problem that yields a separation between <strong>BQP</strong> and <strong>BPP</strong>.</p>
<h2 id="classical-solution">Classical solution</h2>

<p>For a conventional <a class="uri" href="deterministic" title="wikilink">deterministic</a> algorithm where <em>n</em> is number of bits/qubits, 

<math display="inline" id="Deutsch–Jozsa_algorithm:2">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n-1}+1
  </annotation>
 </semantics>
</math>

 evaluations of 

<math display="inline" id="Deutsch–Jozsa_algorithm:3">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 will be required in the worst case. To prove that 

<math display="inline" id="Deutsch–Jozsa_algorithm:4">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is constant, just over half the set of inputs must be evaluated and their outputs found to be identical (remembering that the function is guaranteed to be either balanced or constant, not somewhere in between). The best case occurs where the function is balanced and the first two output values that happen to be selected are different. For a conventional <a href="randomized_algorithm" title="wikilink">randomized algorithm</a>, a constant 

<math display="inline" id="Deutsch–Jozsa_algorithm:5">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 evaluations of the function suffices to produce the correct answer with a high probability (failing with probability 

<math display="inline" id="Deutsch–Jozsa_algorithm:6">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo>≤</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>k</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>ϵ</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon\leq 1/2^{k-1}
  </annotation>
 </semantics>
</math>

). However, 

<math display="inline" id="Deutsch–Jozsa_algorithm:7">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=2^{n-1}+1
  </annotation>
 </semantics>
</math>

 evaluations are still required if we want an answer that is always correct. The Deutsch-Jozsa quantum algorithm produces an answer that is always correct with a single evaluation of 

<math display="inline" id="Deutsch–Jozsa_algorithm:8">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="history">History</h2>

<p>The Deutsch–Jozsa Algorithm generalizes earlier (1985) work by David Deutsch, which provided a solution for the simple case.<br/>
Specifically we were given a boolean function whose input is 1 bit, 

<math display="inline" id="Deutsch–Jozsa_algorithm:9">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\{0,1\}\rightarrow\{0,1\}
  </annotation>
 </semantics>
</math>

 and asked if it is constant.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>The algorithm as Deutsch had originally proposed it was not, in fact, deterministic. The algorithm was successful with a probability of one half. In 1992, Deutsch and Jozsa produced a deterministic algorithm which was generalized to a function which takes 

<math display="inline" id="Deutsch–Jozsa_algorithm:10">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 bits for its input. Unlike Deutsch's Algorithm, this algorithm required two function evaluations instead of only one.</p>

<p>Further improvements to the Deutsch–Jozsa algorithm were made by Cleve et al.,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> resulting in an algorithm that is both deterministic and requires only a single query of 

<math display="inline" id="Deutsch–Jozsa_algorithm:11">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

. This algorithm is still referred to as Deutsch–Jozsa algorithm in honour of the groundbreaking techniques they employed.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>The Deutsch–Jozsa algorithm provided inspiration for <a href="Shor's_algorithm" title="wikilink">Shor's algorithm</a> and <a href="Grover's_algorithm" title="wikilink">Grover's algorithm</a>, two of the most revolutionary quantum algorithms.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="decoherence">Decoherence</h2>

<p>For the Deutsch–Jozsa algorithm to work, the oracle computing f(x) from x has to be a quantum oracle which doesn't decohere x. It also mustn't leave any copy of x lying around at the end of the oracle call.</p>
<figure><b>(Figure)</b>
<figcaption>The Deutsch-Jozsa algorithm's <a href="quantum_circuit" title="wikilink">quantum circuit</a></figcaption>
</figure>

<p>The algorithm begins with the n+1 bit state 

<math display="inline" id="Deutsch–Jozsa_algorithm:12">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mn>0</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mi></mi>
     <mo>⊗</mo>
     <mi>n</mi>
    </mrow>
   </msup>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mn>1</mn>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |0\rangle^{\otimes n}|1\rangle
  </annotation>
 </semantics>
</math>

. That is, the first n bits are each in the state 

<math display="inline" id="Deutsch–Jozsa_algorithm:13">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mn>0</mn>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |0\rangle
  </annotation>
 </semantics>
</math>

 and the final bit is 

<math display="inline" id="Deutsch–Jozsa_algorithm:14">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mn>1</mn>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |1\rangle
  </annotation>
 </semantics>
</math>

. A <a href="Hadamard_transformation" title="wikilink">Hadamard transformation</a> is applied to each bit to obtain the state</p>

<p>

<math display="block" id="Deutsch–Jozsa_algorithm:15">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <msqrt>
     <msup>
      <mn>2</mn>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </msqrt>
   </mfrac>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>x</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <msup>
       <mn>2</mn>
       <mi>n</mi>
      </msup>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>x</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>0</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>1</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>x</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>n</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <ci>x</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{\sqrt{2^{n+1}}}\sum_{x=0}^{2^{n}-1}|x\rangle(|0\rangle-|1\rangle)
  </annotation>
 </semantics>
</math>

.</p>

<p>We have the function 

<math display="inline" id="Deutsch–Jozsa_algorithm:16">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 implemented as quantum oracle. The oracle maps the state 

<math display="inline" id="Deutsch–Jozsa_algorithm:17">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>y</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x\rangle|y\rangle
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Deutsch–Jozsa_algorithm:18">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mrow>
     <mi>y</mi>
     <mo>⊕</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>y</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x\rangle|y\oplus f(x)\rangle
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Deutsch–Jozsa_algorithm:19">
 <semantics>
  <mo>⊕</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">direct-sum</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \oplus
  </annotation>
 </semantics>
</math>

 is addition modulo 2 (see below for details of implementation). Applying the quantum oracle gives</p>

<p>

<math display="block" id="Deutsch–Jozsa_algorithm:20">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <msqrt>
     <msup>
      <mn>2</mn>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </msqrt>
   </mfrac>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>x</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <msup>
       <mn>2</mn>
       <mi>n</mi>
      </msup>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>x</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mrow>
         <mn>1</mn>
         <mo>⊕</mo>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>x</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>n</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <ci>x</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="latexml">direct-sum</csymbol>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <ci>f</ci>
          <ci>x</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{\sqrt{2^{n+1}}}\sum_{x=0}^{2^{n}-1}|x\rangle(|f(x)\rangle-|1\oplus f(%
x)\rangle)
  </annotation>
 </semantics>
</math>

.</p>

<p>For each 

<math display="inline" id="Deutsch–Jozsa_algorithm:21">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Deutsch–Jozsa_algorithm:22">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 is either 

<math display="inline" id="Deutsch–Jozsa_algorithm:23">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 or 

<math display="inline" id="Deutsch–Jozsa_algorithm:24">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

. A quick check of these two possibilities yields</p>

<p>

<math display="block" id="Deutsch–Jozsa_algorithm:25">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <msqrt>
     <msup>
      <mn>2</mn>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </msqrt>
   </mfrac>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>x</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <msup>
       <mn>2</mn>
       <mi>n</mi>
      </msup>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </munderover>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>x</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>0</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>1</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>x</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>n</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <ci>x</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{\sqrt{2^{n+1}}}\sum_{x=0}^{2^{n}-1}(-1)^{f(x)}|x\rangle(|0\rangle-|1\rangle)
  </annotation>
 </semantics>
</math>

.</p>

<p>At this point the last qubit may be ignored. We apply a <a href="Hadamard_transformation" title="wikilink">Hadamard transformation</a> to each qubit to obtain</p>

<p>

<math display="block" id="Deutsch–Jozsa_algorithm:26">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msup>
      <mn>2</mn>
      <mi>n</mi>
     </msup>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>x</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <msup>
        <mn>2</mn>
        <mi>n</mi>
       </msup>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </munderover>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msup>
      <mrow>
       <mo>[</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>y</mi>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
         <mrow>
          <msup>
           <mn>2</mn>
           <mi>n</mi>
          </msup>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </munderover>
        <mrow>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mrow>
           <mi>x</mi>
           <mo>⋅</mo>
           <mi>y</mi>
          </mrow>
         </msup>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mi>y</mi>
          <mo stretchy="false">⟩</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msup>
      <mn>2</mn>
      <mi>n</mi>
     </msup>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>y</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <msup>
        <mn>2</mn>
        <mi>n</mi>
       </msup>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </munderover>
     <mrow>
      <mrow>
       <mo>[</mo>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>x</mi>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
         <mrow>
          <msup>
           <mn>2</mn>
           <mi>n</mi>
          </msup>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </munderover>
        <mrow>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mrow>
           <mi>f</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>x</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </msup>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mrow>
           <mi>x</mi>
           <mo>⋅</mo>
           <mi>y</mi>
          </mrow>
         </msup>
        </mrow>
       </mrow>
       <mo>]</mo>
      </mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mi>y</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>y</ci>
            <cn type="integer">0</cn>
           </apply>
          </apply>
          <apply>
           <minus></minus>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <cn type="integer">2</cn>
            <ci>n</ci>
           </apply>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <minus></minus>
            <cn type="integer">1</cn>
           </apply>
           <apply>
            <ci>normal-⋅</ci>
            <ci>x</ci>
            <ci>y</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="latexml">ket</csymbol>
           <ci>y</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>y</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>x</ci>
            <cn type="integer">0</cn>
           </apply>
          </apply>
          <apply>
           <minus></minus>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <cn type="integer">2</cn>
            <ci>n</ci>
           </apply>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <minus></minus>
            <cn type="integer">1</cn>
           </apply>
           <apply>
            <times></times>
            <ci>f</ci>
            <ci>x</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <minus></minus>
            <cn type="integer">1</cn>
           </apply>
           <apply>
            <ci>normal-⋅</ci>
            <ci>x</ci>
            <ci>y</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2^{n}}\sum_{x=0}^{2^{n}-1}(-1)^{f(x)}\left[\sum_{y=0}^{2^{n}-1}(-1)^{%
x\cdot y}|y\rangle\right]=\frac{1}{2^{n}}\sum_{y=0}^{2^{n}-1}\left[\sum_{x=0}^%
{2^{n}-1}(-1)^{f(x)}(-1)^{x\cdot y}\right]|y\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Deutsch–Jozsa_algorithm:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>⋅</mo>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <msub>
      <mi>y</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo>⊕</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>⊕</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>⊕</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msub>
      <mi>y</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\cdot y=x_{0}y_{0}\oplus x_{1}y_{1}\oplus\cdots\oplus x_{n-1}y_{n-1}
  </annotation>
 </semantics>
</math>

 is the sum of the bitwise product.</p>

<p>Finally we examine the probability of measuring 

<math display="inline" id="Deutsch–Jozsa_algorithm:28">
 <semantics>
  <msup>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mn>0</mn>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mrow>
    <mi></mi>
    <mo>⊗</mo>
    <mi>n</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |0\rangle^{\otimes n}
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Deutsch–Jozsa_algorithm:29">
 <semantics>
  <msup>
   <mrow>
    <mo mathsize="210%" stretchy="false">|</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msup>
       <mn>2</mn>
       <mi>n</mi>
      </msup>
     </mfrac>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>x</mi>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <msup>
         <mn>2</mn>
         <mi>n</mi>
        </msup>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </munderover>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msup>
     </mrow>
    </mrow>
    <mo mathsize="210%" stretchy="false">|</mo>
   </mrow>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>x</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <cn type="integer">2</cn>
          <ci>n</ci>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigg|\frac{1}{2^{n}}\sum_{x=0}^{2^{n}-1}(-1)^{f(x)}\bigg|^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>which evaluates to 1 if 

<math display="inline" id="Deutsch–Jozsa_algorithm:30">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 is constant (<a href="constructive_interference" title="wikilink">constructive interference</a>) and 0 if 

<math display="inline" id="Deutsch–Jozsa_algorithm:31">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>


 is balanced (<a href="destructive_interference" title="wikilink">destructive interference</a>).</p>
<h2 id="deutschs-algorithm">Deutsch's Algorithm</h2>

<p>Deutsch's algorithm is a special case of the general Deutsch–Jozsa algorithm. We need to check the condition 

<math display="inline" id="Deutsch–Jozsa_algorithm:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(0)=f(1)
  </annotation>
 </semantics>
</math>

. It is equivalent to check 

<math display="inline" id="Deutsch–Jozsa_algorithm:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⊕</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">direct-sum</csymbol>
    <apply>
     <times></times>
     <ci>f</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(0)\oplus f(1)
  </annotation>
 </semantics>
</math>

 (where 

<math display="inline" id="Deutsch–Jozsa_algorithm:34">
 <semantics>
  <mo>⊕</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">direct-sum</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \oplus
  </annotation>
 </semantics>
</math>

 is addition modulo 2, which can also be viewed as a quantum <a href="XOR_gate" title="wikilink">XOR gate</a> implemented as a <a href="Controlled_NOT_gate" title="wikilink">Controlled NOT gate</a>), if zero, then 

<math display="inline" id="Deutsch–Jozsa_algorithm:35">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is constant, otherwise 

<math display="inline" id="Deutsch–Jozsa_algorithm:36">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>


 is not constant.</p>

<p>We begin with the two-qubit state 

<math display="inline" id="Deutsch–Jozsa_algorithm:37">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mn>0</mn>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mn>1</mn>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |0\rangle|1\rangle
  </annotation>
 </semantics>
</math>

 and apply a <a href="Hadamard_transform" title="wikilink">Hadamard transform</a> to each qubit. This yields</p>

<p>

<math display="block" id="Deutsch–Jozsa_algorithm:38">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>0</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>1</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>0</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>1</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}(|0\rangle+|1\rangle)(|0\rangle-|1\rangle).
  </annotation>
 </semantics>
</math>

</p>

<p>We are given a quantum implementation of the function 

<math display="inline" id="Deutsch–Jozsa_algorithm:39">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 that maps 

<math display="inline" id="Deutsch–Jozsa_algorithm:40">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>y</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x\rangle|y\rangle
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Deutsch–Jozsa_algorithm:41">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⊕</mo>
     <mi>y</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x\rangle|f(x)\oplus y\rangle
  </annotation>
 </semantics>
</math>


. Applying this function to our current state we obtain</p>

<p>

<math display="block" id="Deutsch–Jozsa_algorithm:42">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>0</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mo fence="true" stretchy="false">|</mo>
         <mrow>
          <mrow>
           <mi>f</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mn>0</mn>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>⊕</mo>
          <mn>0</mn>
         </mrow>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mo fence="true" stretchy="false">|</mo>
         <mrow>
          <mrow>
           <mi>f</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mn>0</mn>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>⊕</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">⟩</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>1</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mo fence="true" stretchy="false">|</mo>
         <mrow>
          <mrow>
           <mi>f</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mn>1</mn>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>⊕</mo>
          <mn>0</mn>
         </mrow>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mo fence="true" stretchy="false">|</mo>
         <mrow>
          <mrow>
           <mi>f</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mn>1</mn>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>⊕</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">⟩</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="latexml">direct-sum</csymbol>
         <apply>
          <times></times>
          <ci>f</ci>
          <cn type="integer">0</cn>
         </apply>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="latexml">direct-sum</csymbol>
         <apply>
          <times></times>
          <ci>f</ci>
          <cn type="integer">0</cn>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="latexml">direct-sum</csymbol>
         <apply>
          <times></times>
          <ci>f</ci>
          <cn type="integer">1</cn>
         </apply>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="latexml">direct-sum</csymbol>
         <apply>
          <times></times>
          <ci>f</ci>
          <cn type="integer">1</cn>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}(|0\rangle(|f(0)\oplus 0\rangle-|f(0)\oplus 1\rangle)+|1\rangle(|f(%
1)\oplus 0\rangle-|f(1)\oplus 1\rangle))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deutsch–Jozsa_algorithm:43">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>0</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </msup>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>0</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>0</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>1</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </msup>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>1</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>0</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>1</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\frac{1}{2}((-1)^{f(0)}|0\rangle(|0\rangle-|1\rangle)+(-1)^{f(1)}|1\rangle(|0%
\rangle-|1\rangle))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deutsch–Jozsa_algorithm:44">
 <semantics>
  <mrow>
   <mrow>
    <mi></mi>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>0</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mrow>
          <mrow>
           <mi>f</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mn>0</mn>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>⊕</mo>
          <mrow>
           <mi>f</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mn>1</mn>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
        </msup>
        <mrow>
         <mo fence="true" stretchy="false">|</mo>
         <mn>1</mn>
         <mo stretchy="false">⟩</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>0</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>1</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="latexml">direct-sum</csymbol>
         <apply>
          <times></times>
          <ci>f</ci>
          <cn type="integer">0</cn>
         </apply>
         <apply>
          <times></times>
          <ci>f</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =(-1)^{f(0)}\frac{1}{2}\left(|0\rangle+(-1)^{f(0)\oplus f(1)}|1\rangle\right)(%
|0\rangle-|1\rangle).
  </annotation>
 </semantics>
</math>

</p>

<p>We ignore the last bit and the global phase and therefore have the state</p>

<p>

<math display="block" id="Deutsch–Jozsa_algorithm:45">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mn>2</mn>
     </msqrt>
    </mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>0</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>0</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>⊕</mo>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>1</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </msup>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>1</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="latexml">direct-sum</csymbol>
        <apply>
         <times></times>
         <ci>f</ci>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{\sqrt{2}}(|0\rangle+(-1)^{f(0)\oplus f(1)}|1\rangle).
  </annotation>
 </semantics>
</math>

</p>

<p>Applying a Hadamard transform to this state we have</p>

<p>

<math display="block" id="Deutsch–Jozsa_algorithm:46">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>0</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>1</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>0</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>⊕</mo>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>1</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </msup>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>0</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>0</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>⊕</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>1</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </msup>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>1</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="latexml">direct-sum</csymbol>
         <apply>
          <times></times>
          <ci>f</ci>
          <cn type="integer">0</cn>
         </apply>
         <apply>
          <times></times>
          <ci>f</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="latexml">direct-sum</csymbol>
        <apply>
         <times></times>
         <ci>f</ci>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}(|0\rangle+|1\rangle+(-1)^{f(0)\oplus f(1)}|0\rangle-(-1)^{f(0)%
\oplus f(1)}|1\rangle)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Deutsch–Jozsa_algorithm:47">
 <semantics>
  <mrow>
   <mrow>
    <mi></mi>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>+</mo>
          <msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
           <mrow>
            <mrow>
             <mi>f</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mn>0</mn>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo>⊕</mo>
            <mrow>
             <mi>f</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mn>1</mn>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
           </mrow>
          </msup>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo fence="true" stretchy="false">|</mo>
         <mn>0</mn>
         <mo stretchy="false">⟩</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
           <mrow>
            <mrow>
             <mi>f</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mn>0</mn>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo>⊕</mo>
            <mrow>
             <mi>f</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mn>1</mn>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
           </mrow>
          </msup>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo fence="true" stretchy="false">|</mo>
         <mn>1</mn>
         <mo stretchy="false">⟩</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="latexml">direct-sum</csymbol>
          <apply>
           <times></times>
           <ci>f</ci>
           <cn type="integer">0</cn>
          </apply>
          <apply>
           <times></times>
           <ci>f</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="latexml">direct-sum</csymbol>
          <apply>
           <times></times>
           <ci>f</ci>
           <cn type="integer">0</cn>
          </apply>
          <apply>
           <times></times>
           <ci>f</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\frac{1}{2}((1+(-1)^{f(0)\oplus f(1)})|0\rangle+(1-(-1)^{f(0)\oplus f(1)})|1%
\rangle).
  </annotation>
 </semantics>
</math>

</p>

<p>Obviously 

<math display="inline" id="Deutsch–Jozsa_algorithm:48">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊕</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <times></times>
      <ci>f</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(0)\oplus f(1)=0
  </annotation>
 </semantics>
</math>

 if and only if we measure a zero and 

<math display="inline" id="Deutsch–Jozsa_algorithm:49">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊕</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <times></times>
      <ci>f</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(0)\oplus f(1)=1
  </annotation>
 </semantics>
</math>

 if and only if we measure a one. So with certainty we know whether 

<math display="inline" id="Deutsch–Jozsa_algorithm:50">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 is constant or balanced.</p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.quiprocone.org/Protected/Lecture_5.htm">Deutsch's lecture about Deutsch algorithm</a></li>
<li><a href="http://code.google.com/p/quala-scala/">Implementation of the Deutsch-Jozsa algorithm in the Scala programming language</a></li>
</ul>

<p>"</p>

<p><a href="Category:Quantum_algorithms" title="wikilink">Category:Quantum algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://www.fortunecity.com/emachines/e11/86/qcomp2.html">Certainty from Uncertainty</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
</ol>
</section>
</body>
</html>
