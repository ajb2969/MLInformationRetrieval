<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1840">Detection theory</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Detection theory</h1>
<hr/>

<p><strong>Detection theory</strong>, or <strong>signal detection theory</strong>, is a means to quantify the ability to discern between information-bearing patterns (called <a href="Stimulus_(psychology)" title="wikilink">stimulus</a> in humans, <a href="Signal_(electronics)" title="wikilink">signal</a> in machines) and random patterns that distract from the information (called <a href="Noise_(electronics)" title="wikilink">noise</a>, consisting of background stimuli and random activity of the detection machine and of the nervous system of the operator). In the field of <a class="uri" href="electronics" title="wikilink">electronics</a>, the separation of such patterns from a disguising background is referred to as <strong><em>signal recovery</em></strong>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>According to the theory, there are a number of determiners of how a detecting system will detect a signal, and where its threshold levels will be. The theory can explain how changing the threshold will affect the ability to discern, often exposing how adapted the system is to the task, purpose or goal at which it is aimed.</p>

<p>When the detecting system is a human being, experience, expectations, physiological state (e.g., fatigue) and other factors can affect the threshold applied. For instance, a sentry in wartime might be likely to detect fainter stimuli than the same sentry in peacetime due to a lower criterion, however they might also be more likely to treat innocuous stimuli as a threat.</p>

<p>Much of the early work in detection theory was done by <a class="uri" href="radar" title="wikilink">radar</a> researchers.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> By 1954, the theory was fully developed on the theoretical side as described by <a href="W._Wesley_Peterson" title="wikilink">Peterson</a>, Birdsall and Fox<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and the foundation for the psychological theory was made by Wilson P. Tanner, David M. Green, and <a href="John_A._Swets" title="wikilink">John A. Swets</a>, also in 1954.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Detection theory was used in 1966 by <a href="John_A._Swets" title="wikilink">John A. Swets</a> and David M. Green for <a class="uri" href="psychophysics" title="wikilink">psychophysics</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Green and <a href="John_A._Swets" title="wikilink">Swets</a> criticized the traditional methods of psychophysics for their inability to discriminate between the real sensitivity of subjects and their (potential) <a href="response_bias" title="wikilink">response biases</a>.<ref name="Green&amp;Swets">Green, D.M., Swets J.A. (1966) <em>Signal Detection Theory and Psychophysics</em>. New York: Wiley. (ISBN 0-471-32420-5)</ref></p>

<p>Detection theory has applications in many fields such as <a class="uri" href="diagnostics" title="wikilink">diagnostics</a> of any kind, <a href="quality_control" title="wikilink">quality control</a>, <a class="uri" href="telecommunications" title="wikilink">telecommunications</a>, and <a class="uri" href="psychology" title="wikilink">psychology</a>. The concept is similar to the <a href="signal_to_noise_ratio" title="wikilink">signal to noise ratio</a> used in the sciences and <a href="confusion_matrix" title="wikilink">confusion matrices</a> used in <a href="artificial_intelligence" title="wikilink">artificial intelligence</a>. It is also usable in <a href="alarm_management" title="wikilink">alarm management</a>, where it is important to separate important events from <a href="background_noise" title="wikilink">background</a> <a href="noise_(environmental)" title="wikilink">noise</a>.</p>
<h2 id="psychology">Psychology</h2>

<p>Signal detection theory (SDT) is used when psychologists want to measure the way we make decisions under conditions of uncertainty, such as how we would perceive distances in foggy conditions. SDT assumes that the decision maker is not a passive receiver of information, but an active decision-maker who makes difficult perceptual judgments under conditions of uncertainty. In foggy circumstances, we are forced to decide how far away from us an object is, based solely upon visual stimulus which is impaired by the fog. Since the brightness of the object, such as a traffic light, is used by the brain to discriminate the distance of an object, and the fog reduces the brightness of objects, we perceive the object to be much farther away than it actually is (see also <a href="decision_theory" title="wikilink">decision theory</a>).</p>

<p>To apply signal detection theory to a data set where stimuli were either present or absent, and the observer categorized each trial as having the stimulus present or absent, the trials are sorted into one of four categories:</p>
<dl>
<dd>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">
<p>Respond "Absent"</p></th>
<th style="text-align: left;">
<p>Respond "Present"</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Stimulus Present</p></td>
<td style="text-align: left;">
<p><a href="Type_1_error#Type_I_and_type_II_errors" title="wikilink">Miss</a></p></td>
<td style="text-align: left;">
<p>Hit</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Stimulus Absent</p></td>
<td style="text-align: left;">
<p>Correct Rejection</p></td>
<td style="text-align: left;">
<p><a href="Type_1_error#Type_I_and_type_II_errors" title="wikilink">False Alarm</a></p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>Based on the proportions of these types of trials, numerical estimates of sensitivity can be obtained with statistics like the <a href="sensitivity_index" title="wikilink">sensitivity index <em>d</em>'</a> and A',<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> and response bias can be estimated with statistics like c and β.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>Signal detection theory can also be applied to memory experiments, where items are presented on a study list for later testing. A test list is created by combining these 'old' items with novel, 'new' items that did not appear on the study list. On each test trial the subject will respond 'yes, this was on the study list' or 'no, this was not on the study list'. Items presented on the study list are called Targets, and new items are called Distractors. Saying 'Yes' to a target constitutes a Hit, while saying 'Yes' to a distractor constitutes a False Alarm.</p>
<dl>
<dd>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">
<p>Respond "No"</p></th>
<th style="text-align: left;">
<p>Respond "Yes"</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Target</p></td>
<td style="text-align: left;">
<p><a href="Type_1_error#Type_I_and_type_II_errors" title="wikilink">Miss</a></p></td>
<td style="text-align: left;">
<p>Hit</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Distractor</p></td>
<td style="text-align: left;">
<p>Correct Rejection</p></td>
<td style="text-align: left;">
<p><a href="Type_1_error#Type_I_and_type_II_errors" title="wikilink">False Alarm</a></p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<h2 id="applications">Applications</h2>

<p>Signal Detection Theory has wide application, both in humans and <a href="Comparative_psychology" title="wikilink">other animals</a>. Topics include <a class="uri" href="memory" title="wikilink">memory</a>, stimulus characterists of schedules of reinforcement, etc.</p>
<h3 id="sensitivity-or-discriminability">Sensitivity or discriminability</h3>

<p>Conceptually, sensitivity refers to how hard or easy it is to detect that a target stimulus is present from background events. For example, in a recognition memory paradigm, having longer to study to-be-remembered words makes it easier to recognize previously seen or heard words. In contrast, having to remember 30 words rather than 5 makes the discrimination harder. One of the most commonly used statistics for computing sensitivity is the so-called <a href="sensitivity_index" title="wikilink">sensitivity index</a> or <em>d</em>'. There are also <a class="uri" href="non-parametric" title="wikilink">non-parametric</a> measures, such as the area under the <a href="Receiver_operating_characteristic" title="wikilink">ROC-curve</a>.<ref name="Green&amp;Swets"></ref></p>
<h3 id="bias">Bias</h3>

<p>Bias is the extent to which one response is more probable than another. That is, a receiver may be more likely to respond that a stimulus is present or more likely to respond that a stimulus is not present. Bias is independent of sensitivity. For example, if there is a penalty for either false alarms or misses, this may influence bias. If the stimulus is a bomber, then a miss (failing to detect the plane) may increase deaths, so a liberal bias is likely. In contrast, <a href="crying_wolf" title="wikilink">crying wolf</a> (a false alarm) too often may make people less likely to respond, grounds for a conservative bias.</p>
<h2 id="mathematics">Mathematics</h2>
<h3 id="ph1y-ph2y-map-testing">P(H1|y) &gt; P(H2|y) / MAP Testing</h3>

<p>In the case of making a decision between two <a href="Hypothesis" title="wikilink">hypotheses</a>, <em>H1</em>, absent, and <em>H2</em>, present, in the event of a particular <a class="uri" href="observation" title="wikilink">observation</a>, <em>y</em>, a classical approach is to choose <em>H1</em> when <em>p(H1|y) &gt; p(H2|y)</em> and <em>H2</em> in the reverse case.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> In the event that the two <em><a href="a_posteriori" title="wikilink">a posteriori</a></em> <a href="probability" title="wikilink">probabilities</a> are equal, one typically defaults to a single choice, say <em>H2</em>. One could also flip a coin although the expected number of errors would be the same.</p>

<p>When taking this approach, usually what one knows are the conditional probabilities, <em>p(y|H1)</em> and <em>p(y|H2)</em>, and the <em><a href="A_priori_and_a_posteriori" title="wikilink">a priori</a></em> probabilities 

<math display="inline" id="Detection_theory:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>H</mi>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>π</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <apply>
      <times></times>
      <ci>H</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(H1)=\pi_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Detection_theory:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>H</mi>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>π</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <apply>
      <times></times>
      <ci>H</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(H2)=\pi_{2}
  </annotation>
 </semantics>
</math>

. In this case,</p>

<p>

<math display="inline" id="Detection_theory:2">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mn>1</mn>
    <mo stretchy="false">|</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">|</mo>
      <mi>H</mi>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <msub>
      <mi>π</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">H</csymbol>
     <cn type="integer">1</cn>
     <ci>normal-|</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">H</csymbol>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">1</cn>
      </apply>
     </cerror>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(H1|y)=\frac{p(y|H1)\cdot\pi_{1}}{p(y)}
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="inline" id="Detection_theory:3">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mn>2</mn>
    <mo stretchy="false">|</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">|</mo>
      <mi>H</mi>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <msub>
      <mi>π</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">H</csymbol>
     <cn type="integer">2</cn>
     <ci>normal-|</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">H</csymbol>
       <cn type="integer">2</cn>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">2</cn>
      </apply>
     </cerror>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(H2|y)=\frac{p(y|H2)\cdot\pi_{2}}{p(y)}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>p(y)</em> is the total probability of event <em>y</em>,</p>

<p>

<math display="inline" id="Detection_theory:4">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>H</mi>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⋅</mo>
   <msub>
    <mi>π</mi>
    <mn>1</mn>
   </msub>
   <mo>+</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>H</mi>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⋅</mo>
   <msub>
    <mi>π</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">H</csymbol>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⋅</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">1</cn>
    </apply>
    <plus></plus>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">H</csymbol>
     <cn type="integer">2</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⋅</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">2</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(y|H1)\cdot\pi_{1}+p(y|H2)\cdot\pi_{2}
  </annotation>
 </semantics>
</math>

.</p>

<p><em>H2</em> is chosen in case</p>

<p>

<math display="inline" id="Detection_theory:5">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">|</mo>
      <mi>H</mi>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <msub>
      <mi>π</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">|</mo>
      <mi>H</mi>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <msub>
      <mi>π</mi>
      <mn>1</mn>
     </msub>
     <mo>+</mo>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">|</mo>
      <mi>H</mi>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <msub>
      <mi>π</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </mfrac>
   <mo>≥</mo>
   <mfrac>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">|</mo>
      <mi>H</mi>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <msub>
      <mi>π</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">|</mo>
      <mi>H</mi>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <msub>
      <mi>π</mi>
      <mn>1</mn>
     </msub>
     <mo>+</mo>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">|</mo>
      <mi>H</mi>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <msub>
      <mi>π</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">H</csymbol>
       <cn type="integer">2</cn>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">2</cn>
      </apply>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">H</csymbol>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">1</cn>
      </apply>
      <plus></plus>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">H</csymbol>
       <cn type="integer">2</cn>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">2</cn>
      </apply>
     </cerror>
    </apply>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">H</csymbol>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">1</cn>
      </apply>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">H</csymbol>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">1</cn>
      </apply>
      <plus></plus>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-|</ci>
       <csymbol cd="unknown">H</csymbol>
       <cn type="integer">2</cn>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">2</cn>
      </apply>
     </cerror>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{p(y|H2)\cdot\pi_{2}}{p(y|H1)\cdot\pi_{1}+p(y|H2)\cdot\pi_{2}}\geq\frac{p%
(y|H1)\cdot\pi_{1}}{p(y|H1)\cdot\pi_{1}+p(y|H2)\cdot\pi_{2}}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Detection_theory:6">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⇒</mo>
   <mfrac>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">|</mo>
      <mi>H</mi>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">|</mo>
      <mi>H</mi>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>≥</mo>
   <mfrac>
    <msub>
     <mi>π</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>π</mi>
     <mn>2</mn>
    </msub>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-⇒</ci>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <divide></divide>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">y</csymbol>
        <ci>normal-|</ci>
        <csymbol cd="unknown">H</csymbol>
        <cn type="integer">2</cn>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">y</csymbol>
        <ci>normal-|</ci>
        <csymbol cd="unknown">H</csymbol>
        <cn type="integer">1</cn>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Rightarrow\frac{p(y|H2)}{p(y|H1)}\geq\frac{\pi_{1}}{\pi_{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>and <em>H1</em> otherwise.</p>

<p>Often, the ratio 

<math display="inline" id="Detection_theory:7">
 <semantics>
  <mfrac>
   <msub>
    <mi>π</mi>
    <mn>1</mn>
   </msub>
   <msub>
    <mi>π</mi>
    <mn>2</mn>
   </msub>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\pi_{1}}{\pi_{2}}
  </annotation>
 </semantics>
</math>

 is called 

<math display="inline" id="Detection_theory:8">
 <semantics>
  <msub>
   <mi>τ</mi>
   <mrow>
    <mi>M</mi>
    <mi>A</mi>
    <mi>P</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>τ</ci>
    <apply>
     <times></times>
     <ci>M</ci>
     <ci>A</ci>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{MAP}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Detection_theory:9">
 <semantics>
  <mfrac>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">|</mo>
     <mi>H</mi>
     <mn>2</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">|</mo>
     <mi>H</mi>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">H</csymbol>
      <cn type="integer">2</cn>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">H</csymbol>
      <cn type="integer">1</cn>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{p(y|H2)}{p(y|H1)}
  </annotation>
 </semantics>
</math>

 is called 

<math display="inline" id="Detection_theory:10">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(y)
  </annotation>
 </semantics>
</math>

, the <em><a href="Likelihood_function" title="wikilink">likelihood ratio</a></em>.</p>

<p>Using this terminology, <em>H2</em> is chosen in case 

<math display="inline" id="Detection_theory:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <msub>
    <mi>τ</mi>
    <mrow>
     <mi>M</mi>
     <mi>A</mi>
     <mi>P</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>τ</ci>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>A</ci>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(y)\geq\tau_{MAP}
  </annotation>
 </semantics>
</math>

. This is called MAP testing, where MAP stands for "maximum <em>a posteriori</em>").</p>

<p>Taking this approach minimizes the expected number of errors one will make.</p>
<h3 id="bayes-criterion">Bayes Criterion</h3>

<p>In some cases, it is far more important to respond appropriately to <em>H1</em> than it is to respond appropriately to <em>H2</em>. For example, if an alarm goes off, indicating H1 (an incoming bomber is carrying a <a href="nuclear_weapon" title="wikilink">nuclear weapon</a>), it is much more important to shoot down the bomber if H1 = TRUE, than it is to send a fighter squadron to inspect a <a href="false_alarm" title="wikilink">false alarm</a> (i.e., H1 = FALSE, H2 = TRUE) (assuming a large supply of fighter squadrons). The <a href="Thomas_Bayes" title="wikilink">Bayes</a> criterion is an approach suitable for such cases.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>Here a <a class="uri" href="utility" title="wikilink">utility</a> is associated with each of four situations:</p>
<ul>
<li>

<math display="inline" id="Detection_theory:12">
 <semantics>
  <msub>
   <mi>U</mi>
   <mn>11</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <cn type="integer">11</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{11}
  </annotation>
 </semantics>
</math>

: One responds with behavior appropriate to H1 and H1 is true: fighters destroy bomber, incurring fuel, maintenance, and weapons costs, take risk of some being shot down;</li>
<li>

<math display="inline" id="Detection_theory:13">
 <semantics>
  <msub>
   <mi>U</mi>
   <mn>12</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <cn type="integer">12</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{12}
  </annotation>
 </semantics>
</math>

: One responds with behavior appropriate to H1 and H2 is true: fighters sent out, incurring fuel and maintenance costs, bomber location remains unknown;</li>
<li>

<math display="inline" id="Detection_theory:14">
 <semantics>
  <msub>
   <mi>U</mi>
   <mn>21</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <cn type="integer">21</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{21}
  </annotation>
 </semantics>
</math>

: One responds with behavior appropriate to H2 and H1 is true: city destroyed;</li>
<li>

<math display="inline" id="Detection_theory:15">
 <semantics>
  <msub>
   <mi>U</mi>
   <mn>22</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <cn type="integer">22</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{22}
  </annotation>
 </semantics>
</math>

: One responds with behavior appropriate to H2 and H2 is true: fighters stay home, bomber location remains unknown;</li>
</ul>

<p>As is shown below, what is important are the differences, 

<math display="inline" id="Detection_theory:16">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mn>11</mn>
   </msub>
   <mo>-</mo>
   <msub>
    <mi>U</mi>
    <mn>21</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <cn type="integer">11</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <cn type="integer">21</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{11}-U_{21}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Detection_theory:17">
 <semantics>
  <mrow>
   <msub>
    <mi>U</mi>
    <mn>22</mn>
   </msub>
   <mo>-</mo>
   <msub>
    <mi>U</mi>
    <mn>12</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <cn type="integer">22</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>U</ci>
     <cn type="integer">12</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{22}-U_{12}
  </annotation>
 </semantics>
</math>

.</p>

<p>Similarly, there are four probabilities, 

<math display="inline" id="Detection_theory:18">
 <semantics>
  <msub>
   <mi>P</mi>
   <mn>11</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <cn type="integer">11</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{11}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Detection_theory:19">
 <semantics>
  <msub>
   <mi>P</mi>
   <mn>12</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <cn type="integer">12</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{12}
  </annotation>
 </semantics>
</math>

, etc., for each of the cases (which are dependent on one's decision strategy).</p>

<p>The Bayes criterion approach is to maximize the expected utility:</p>

<p>

<math display="inline" id="Detection_theory:20">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>11</mn>
     </msub>
     <mo>⋅</mo>
     <msub>
      <mi>U</mi>
      <mn>11</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>21</mn>
     </msub>
     <mo>⋅</mo>
     <msub>
      <mi>U</mi>
      <mn>21</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>12</mn>
     </msub>
     <mo>⋅</mo>
     <msub>
      <mi>U</mi>
      <mn>12</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>22</mn>
     </msub>
     <mo>⋅</mo>
     <msub>
      <mi>U</mi>
      <mn>22</mn>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>U</ci>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">11</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <cn type="integer">11</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">21</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <cn type="integer">21</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">12</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <cn type="integer">12</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">22</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <cn type="integer">22</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U=P_{11}\cdot U_{11}+P_{21}\cdot U_{21}+P_{12}\cdot U_{12}+P_{22}\cdot U_{22}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Detection_theory:21">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>11</mn>
     </msub>
     <mo>⋅</mo>
     <msub>
      <mi>U</mi>
      <mn>11</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <msub>
        <mi>P</mi>
        <mn>11</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <msub>
      <mi>U</mi>
      <mn>21</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>12</mn>
     </msub>
     <mo>⋅</mo>
     <msub>
      <mi>U</mi>
      <mn>12</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <msub>
        <mi>P</mi>
        <mn>12</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <msub>
      <mi>U</mi>
      <mn>22</mn>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>U</ci>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">11</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <cn type="integer">11</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <cn type="integer">11</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <cn type="integer">21</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">12</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <cn type="integer">12</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <cn type="integer">12</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <cn type="integer">22</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U=P_{11}\cdot U_{11}+(1-P_{11})\cdot U_{21}+P_{12}\cdot U_{12}+(1-P_{12})\cdot
U%
_{22}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Detection_theory:22">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>U</mi>
      <mn>21</mn>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>U</mi>
      <mn>22</mn>
     </msub>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>P</mi>
       <mn>11</mn>
      </msub>
      <mo>⋅</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>U</mi>
         <mn>11</mn>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>U</mi>
         <mn>21</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>12</mn>
     </msub>
     <mo>⋅</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>U</mi>
        <mn>22</mn>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>U</mi>
        <mn>12</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>U</ci>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <cn type="integer">21</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <cn type="integer">22</cn>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <cn type="integer">11</cn>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>U</ci>
         <cn type="integer">11</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>U</ci>
         <cn type="integer">21</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">12</cn>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>U</ci>
        <cn type="integer">22</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>U</ci>
        <cn type="integer">12</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U=U_{21}+U_{22}+P_{11}\cdot(U_{11}-U_{21})-P_{12}\cdot(U_{22}-U_{12})
  </annotation>
 </semantics>
</math>

</p>

<p>Effectively, one may maximize the sum,</p>

<p>

<math display="inline" id="Detection_theory:23">
 <semantics>
  <mrow>
   <msup>
    <mi>U</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>11</mn>
     </msub>
     <mo>⋅</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>U</mi>
        <mn>11</mn>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>U</mi>
        <mn>21</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>12</mn>
     </msub>
     <mo>⋅</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>U</mi>
        <mn>22</mn>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>U</mi>
        <mn>12</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>U</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">11</cn>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>U</ci>
        <cn type="integer">11</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>U</ci>
        <cn type="integer">21</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">12</cn>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>U</ci>
        <cn type="integer">22</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>U</ci>
        <cn type="integer">12</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U^{\prime}=P_{11}\cdot(U_{11}-U_{21})-P_{12}\cdot(U_{22}-U_{12})
  </annotation>
 </semantics>
</math>

,</p>

<p>and make the following substitutions:</p>

<p>

<math display="inline" id="Detection_theory:24">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mn>11</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>π</mi>
    <mn>1</mn>
   </msub>
   <mo>⋅</mo>
   <msub>
    <mo largeop="true" symmetric="true">∫</mo>
    <msub>
     <mi>R</mi>
     <mn>1</mn>
    </msub>
   </msub>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>H</mi>
    <mn>1</mn>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
   <mi>d</mi>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">11</cn>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-⋅</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <int></int>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">H</csymbol>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{11}=\pi_{1}\cdot\int_{R_{1}}p(y|H1)\,dy
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Detection_theory:25">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mn>12</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>π</mi>
    <mn>2</mn>
   </msub>
   <mo>⋅</mo>
   <msub>
    <mo largeop="true" symmetric="true">∫</mo>
    <msub>
     <mi>R</mi>
     <mn>1</mn>
    </msub>
   </msub>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>H</mi>
    <mn>2</mn>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
   <mi>d</mi>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">12</cn>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-⋅</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <int></int>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">H</csymbol>
     <cn type="integer">2</cn>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{12}=\pi_{2}\cdot\int_{R_{1}}p(y|H2)\,dy
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Detection_theory:26">
 <semantics>
  <msub>
   <mi>π</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Detection_theory:27">
 <semantics>
  <msub>
   <mi>π</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{2}
  </annotation>
 </semantics>
</math>

 are the <em>a priori</em> probabilities, 

<math display="inline" id="Detection_theory:28">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>H</mi>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <times></times>
     <ci>H</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(H1)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Detection_theory:29">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>H</mi>
     <mn>2</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <times></times>
     <ci>H</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(H2)
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Detection_theory:30">
 <semantics>
  <msub>
   <mi>R</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{1}
  </annotation>
 </semantics>
</math>

 is the region of observation events, <em>y</em>, that are responded to as though <em>H1</em> is true.</p>

<p>

<math display="inline" id="Detection_theory:31">
 <semantics>
  <mrow>
   <mo>⇒</mo>
   <msup>
    <mi>U</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <msub>
    <mo largeop="true" symmetric="true">∫</mo>
    <msub>
     <mi>R</mi>
     <mn>1</mn>
    </msub>
   </msub>
   <mrow>
    <mo>{</mo>
    <msub>
     <mi>π</mi>
     <mn>1</mn>
    </msub>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>U</mi>
      <mn>11</mn>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>U</mi>
      <mn>21</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⋅</mo>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">|</mo>
     <mi>H</mi>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>-</mo>
    <msub>
     <mi>π</mi>
     <mn>2</mn>
    </msub>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>U</mi>
      <mn>22</mn>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>U</mi>
      <mn>12</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⋅</mo>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">|</mo>
     <mi>H</mi>
     <mn>2</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="4.2pt">}</mo>
   </mrow>
   <mi>d</mi>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-⇒</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>U</ci>
     <ci>normal-′</ci>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <int></int>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋅</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <cn type="integer">11</cn>
      </apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <cn type="integer">21</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-⋅</ci>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">H</csymbol>
      <cn type="integer">1</cn>
      <ci>normal-)</ci>
     </cerror>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⋅</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <cn type="integer">22</cn>
      </apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>U</ci>
       <cn type="integer">12</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-⋅</ci>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">H</csymbol>
      <cn type="integer">2</cn>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-}</ci>
    </cerror>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Rightarrow U^{\prime}=\int_{R_{1}}\left\{\pi_{1}\cdot(U_{11}-U_{21})\cdot p(y%
|H1)-\pi_{2}\cdot(U_{22}-U_{12})\cdot p(y|H2)\right\}\,dy
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Detection_theory:32">
 <semantics>
  <msup>
   <mi>U</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>U</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U^{\prime}
  </annotation>
 </semantics>
</math>

 and thus 

<math display="inline" id="Detection_theory:33">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 are maximized by extending 

<math display="inline" id="Detection_theory:34">
 <semantics>
  <msub>
   <mi>R</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{1}
  </annotation>
 </semantics>
</math>

 over the region where</p>

<p>

<math display="inline" id="Detection_theory:35">
 <semantics>
  <mrow>
   <msub>
    <mi>π</mi>
    <mn>1</mn>
   </msub>
   <mo>⋅</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>U</mi>
     <mn>11</mn>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>U</mi>
     <mn>21</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⋅</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>H</mi>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>-</mo>
   <msub>
    <mi>π</mi>
    <mn>2</mn>
   </msub>
   <mo>⋅</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>U</mi>
     <mn>22</mn>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>U</mi>
     <mn>12</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⋅</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>H</mi>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-⋅</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <cn type="integer">11</cn>
     </apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <cn type="integer">21</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⋅</ci>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">H</csymbol>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-⋅</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <cn type="integer">22</cn>
     </apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <cn type="integer">12</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⋅</ci>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">H</csymbol>
     <cn type="integer">2</cn>
     <ci>normal-)</ci>
    </cerror>
    <gt></gt>
    <cn type="integer">0</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{1}\cdot(U_{11}-U_{21})\cdot p(y|H1)-\pi_{2}\cdot(U_{22}-U_{12})\cdot p(y|%
H2)>0
  </annotation>
 </semantics>
</math>

</p>

<p>This is accomplished by deciding H2 in case</p>

<p>

<math display="inline" id="Detection_theory:36">
 <semantics>
  <mrow>
   <msub>
    <mi>π</mi>
    <mn>2</mn>
   </msub>
   <mo>⋅</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>U</mi>
     <mn>22</mn>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>U</mi>
     <mn>12</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⋅</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>H</mi>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≥</mo>
   <msub>
    <mi>π</mi>
    <mn>1</mn>
   </msub>
   <mo>⋅</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>U</mi>
     <mn>11</mn>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>U</mi>
     <mn>21</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⋅</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>H</mi>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-⋅</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <cn type="integer">22</cn>
     </apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <cn type="integer">12</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⋅</ci>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">H</csymbol>
     <cn type="integer">2</cn>
     <ci>normal-)</ci>
    </cerror>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-⋅</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <cn type="integer">11</cn>
     </apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <cn type="integer">21</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-⋅</ci>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">H</csymbol>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{2}\cdot(U_{22}-U_{12})\cdot p(y|H2)\geq\pi_{1}\cdot(U_{11}-U_{21})\cdot p%
(y|H1)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Detection_theory:37">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⇒</mo>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mfrac>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">|</mo>
      <mi>H</mi>
      <mn>2</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">|</mo>
      <mi>H</mi>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>≥</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>π</mi>
      <mn>1</mn>
     </msub>
     <mo>⋅</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>U</mi>
        <mn>11</mn>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>U</mi>
        <mn>21</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mi>π</mi>
      <mn>2</mn>
     </msub>
     <mo>⋅</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>U</mi>
        <mn>22</mn>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>U</mi>
        <mn>12</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>≡</mo>
   <msub>
    <mi>τ</mi>
    <mi>B</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-⇒</ci>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">y</csymbol>
        <ci>normal-|</ci>
        <csymbol cd="unknown">H</csymbol>
        <cn type="integer">2</cn>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">y</csymbol>
        <ci>normal-|</ci>
        <csymbol cd="unknown">H</csymbol>
        <cn type="integer">1</cn>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>π</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>U</ci>
         <cn type="integer">11</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>U</ci>
         <cn type="integer">21</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>π</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>U</ci>
         <cn type="integer">22</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>U</ci>
         <cn type="integer">12</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Rightarrow L(y)\equiv\frac{p(y|H2)}{p(y|H1)}\geq\frac{\pi_{1}\cdot(U_{11}-U_{%
21})}{\pi_{2}\cdot(U_{22}-U_{12})}\equiv\tau_{B}
  </annotation>
 </semantics>
</math>

</p>

<p>and H1 otherwise, where <em>L(y)</em> is the so-defined <em><a href="Likelihood_function" title="wikilink">likelihood ratio</a></em>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Binary_classification" title="wikilink">Binary classification</a></li>
<li><a href="Constant_false_alarm_rate" title="wikilink">Constant false alarm rate</a></li>
<li><a class="uri" href="Demodulation" title="wikilink">Demodulation</a></li>
<li><a href="Detector_(radio)" title="wikilink">Detector (radio)</a></li>
<li><a href="Decision_theory" title="wikilink">Decision theory</a></li>
<li><a href="Estimation_theory" title="wikilink">Estimation theory</a></li>
<li><a href="Likelihood-ratio_test" title="wikilink">Likelihood-ratio test</a></li>
<li><a class="uri" href="Modulation" title="wikilink">Modulation</a></li>
<li><a href="Neyman-Pearson_lemma" title="wikilink">Neyman-Pearson lemma</a></li>
<li><a href="Receiver_operating_characteristic" title="wikilink">Receiver operating characteristic</a></li>
<li><a href="Statistical_signal_processing" title="wikilink">Statistical signal processing</a></li>
<li><a href="Just_noticeable_difference" title="wikilink">Just noticeable difference</a></li>
<li><a href="Psychometric_function" title="wikilink">Psychometric function</a></li>
<li><a href="Statistical_hypothesis_testing" title="wikilink">Statistical hypothesis testing</a></li>
<li><a href="Two-alternative_forced_choice" title="wikilink">Two-alternative forced choice</a></li>
<li><a href="Type_I_and_type_II_errors" title="wikilink">Type I and type II errors</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<ul>
<li>Coren, S., Ward, L.M., Enns, J. T. (1994) <em>Sensation and Perception</em>. (4th Ed.) Toronto: Harcourt Brace.</li>
<li>Kay, SM. <em>Fundamentals of Statistical Signal Processing: Detection Theory</em> (ISBN 0-13-504135-X)</li>
<li>McNichol, D. (1972) <em>A Primer of Signal Detection Theory</em>. London: George Allen &amp; Unwin.</li>
<li>Van Trees HL. <em>Detection, Estimation, and Modulation Theory, Part 1</em> (ISBN 0-471-09517-6; <a href="http://gunston.gmu.edu/demt/demtp1/">website</a>)</li>
<li>Wickens, Thomas D., (2002) <em>Elementary Signal Detection Theory</em>. New York: Oxford University Press. (ISBN 0-19-509250-3)</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cns.nyu.edu/~david/sdt/sdt.html">A Description of Signal Detection Theory</a></li>
<li><a href="http://strobos.cee.vt.edu/IGLC11/PDF%20Files/19.pdf">An application of SDT to safety</a></li>
<li><a href="http://demonstrations.wolfram.com/SignalDetectionTheory/">Signal Detection Theory</a> by Garrett Neske, <a href="The_Wolfram_Demonstrations_Project" title="wikilink">The Wolfram Demonstrations Project</a></li>
</ul>

<p>"</p>

<p><a href="Category:Detection_theory" title="wikilink"> </a> <a href="Category:Signal_processing" title="wikilink">Category:Signal processing</a> <a href="Category:Telecommunication_theory" title="wikilink">Category:Telecommunication theory</a> <a class="uri" href="Category:Psychophysics" title="wikilink">Category:Psychophysics</a> <a href="Category:Mathematical_psychology" title="wikilink">Category:Mathematical psychology</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">Peterson,W.W., Birdsall, T. G. &amp; Fox, W. C. (1954) The theory of signal detectability. Proceedings of the IRE Professional Group on Information Theory 4, 171-212.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">Swets, J.A. (ed.) (1964) <em>Signal detection and recognition by human observers</em>. New York: Wiley<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8">Schonhoff, T.A. and Giordano, A.A. (2006) <em>Detection and Estimation Theory and Its Applications</em>. New Jersey: Pearson Education (ISBN 0-13-089499-0)<a href="#fnref8">↩</a></li>
<li id="fn9"></li>
</ol>
</section>
</body>
</html>
