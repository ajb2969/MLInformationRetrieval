<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title offset="1937">Low (complexity)</title>
   <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js">
    </script>
</head>
<body>
<h1>Low (complexity)</h1>
<hr/>
<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, a <a href="complexity_class" title="wikilink">complexity class</a> <em>B</em> is said to be <strong>low</strong> for a complexity class <em>A</em> if <em>A</em><sup><em>B</em></sup> = <em>A</em>; that is, <em>A</em> with an <a href="oracle_machine" title="wikilink">oracle</a> for <em>B</em> is equal to <em>A</em>. Such a statement implies that an <a href="abstract_machine" title="wikilink">abstract machine</a> which solves problems in <em>A</em> achieves no additional power if it is given the ability to solve problems in <em>B</em> at unit cost. In particular, this means that if <em>B</em> is low for <em>A</em> then <em>B</em> is contained in <em>A</em>. Informally, lowness means that problems in <em>B</em> are not only solvable by machines which can solve problems in <em>A</em>, but are "easy to solve." An <em>A</em> machine can simulate many oracle queries to <em>B</em> without exceeding its resource bounds.</p>
<p>Results and relationships that establish one class as low for another are often called <strong>lowness</strong> results.</p>
<h2 id="results">Results</h2>
<p>Several natural complexity classes are known to be low for themselves. For instance, <a href="P_(complexity)" title="wikilink">P</a> is low for itself (that is, P<sup>P</sup> = P) because polynomial-time algorithms are closed under composition: a polynomial-time algorithm can make polynomially many queries to other polynomial-time algorithms, while retaining a polynomial running time. <a class="uri" href="PSPACE" title="wikilink">PSPACE</a> is also low for itself, and this can be established by exactly the same argument. Similarly, <a href="L_(complexity)" title="wikilink">L</a> is low for itself because it can simulate log space oracle queries in log space, reusing the same space for each query.</p>
<p><a href="Bounded-error_probabilistic_polynomial" title="wikilink">BPP</a> is also low for itself and the same arguments almost work for BPP, but one has to account for errors, making it slightly harder to show that BPP is low for itself. Similarly, the argument for BPP almost goes through for <a class="uri" href="BQP" title="wikilink">BQP</a>, but we have to additionally show that quantum queries can be performed in coherent superposition.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<p>Every class which is low for itself is closed under <a href="complement_(complexity)" title="wikilink">complement</a>, provided that it is powerful enough to negate the boolean result. This implies that <strong>NP</strong> isn't low for itself unless <strong>NP</strong> = co-<strong>NP</strong>, which is considered unlikely because it implies that the <a href="polynomial_hierarchy" title="wikilink">polynomial hierarchy</a> collapses to the first level, whereas it is widely believed that the hierarchy is infinite. The converse to this statement is not true. If a class is closed under complement, it does not mean that the class is low for itself. An example of such a class is <a class="uri" href="EXP" title="wikilink">EXP</a>, which is closed under complement, but is not low for itself.</p>
<p>Some of the more complex and famous results regarding lowness of classes include:</p>
<ul>
<li>Both <a href="Parity_P" title="wikilink">Parity P</a> (<span class="LaTeX">${\oplus}\hbox{P}$</span>) and <a href="Bounded-error_probabilistic_polynomial" title="wikilink">BPP</a> are low for themselves. These were important in showing <a href="Toda's_theorem" title="wikilink">Toda's theorem</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></li>
<li><a class="uri" href="BQP" title="wikilink">BQP</a> is low for <a href="PP_(complexity)" title="wikilink">PP</a> <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> In other words, a program based around taking the majority decision of an unbounded number of iterations of a poly-time <a href="randomized_algorithm" title="wikilink">randomized algorithm</a> can easily solve all the problems that a <a href="quantum_computer" title="wikilink">quantum computer</a> can solve efficiently.</li>
<li>The <a href="graph_isomorphism_problem" title="wikilink">graph isomorphism problem</a> is low for <a href="Parity_P" title="wikilink">Parity P</a> (<span class="LaTeX">${\oplus}\hbox{P}$</span>).<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> This means that if we can determine whether an <strong>NP</strong> machine has an even or odd number of accepting paths, we can easily solve graph isomorphism. In fact, it was later shown that graph isomorphism is low for <strong><a href="ZPP_(complexity)" title="wikilink">ZPP</a><sup>NP</sup></strong>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
<li><a href="Amplified_PP" title="wikilink">Amplified PP</a> is low for <a href="PP_(complexity)" title="wikilink">PP</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></li>
</ul>
<h2 id="applications">Applications</h2>
<p>Lowness is particularly valuable in relativization arguments, where it can be used to establish that the power of a class does not change in the "relativized universe" where a particular oracle machine is available for free. This allows us to reason about it in the same manner we normally would. For example, in the relativized universe of <strong>BQP</strong>, <strong>PP</strong> is still closed under union and intersection. It's also useful when seeking to expand the power of a machine with oracles, because lowness results determine when the machine's power remains the same.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Low_(computability)" title="wikilink">Low (computability)</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<p>"</p>
<p><a href="Category:Computational_complexity_theory" title="wikilink">Category:Computational complexity theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Bernstein and Vazirani, Quantum complexity theory, <a href="SIAM_Journal_on_Computing" title="wikilink">SIAM Journal on Computing</a>, 26(5):1411-1473, 1997. <a href="http://www.cs.berkeley.edu/~vazirani/bv.ps">1</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://www.cs.rutgers.edu/~allender/538/murata3.pdf">2</a><a href="#fnref2">↩</a></li>
<li id="fn3">L. Fortnow and J. D. Rogers. Complexity limitations on quantum computation. In <em>Proceedings of IEEE Complexity '98</em>, p.202-209. 1998. .<a href="#fnref3">↩</a></li>
<li id="fn4">V. Arvind and P. Kurur. Graph isomorphism is in SPP. . 2002.<a href="#fnref4">↩</a></li>
<li id="fn5">Vikraman Arvind and Johannes Köbler. Graph Isomorphism Is Low for ZPP(NP) and Other Lowness Results. <em>Proceedings of the 17th Annual Symposium on Theoretical Aspects of Computer Science</em>, ISBN 3-540-67141-2, p.431-442. 2000.<a href="#fnref5">↩</a></li>
<li id="fn6">L. Li. On the Counting Functions. PhD thesis, University of Chicago. 1993.<a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
