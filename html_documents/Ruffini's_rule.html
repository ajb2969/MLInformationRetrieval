<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="627">Ruffini's rule</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Ruffini's rule</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <strong>Ruffini's rule</strong> is an efficient technique for dividing a <a class="uri" href="polynomial" title="wikilink">polynomial</a> by a <a class="uri" href="binomial" title="wikilink">binomial</a> of the form <em>x</em> − <em>r</em>. It was described by <a href="Paolo_Ruffini" title="wikilink">Paolo Ruffini</a> in 1804.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Ruffini's rule is a special case of <a href="synthetic_division" title="wikilink">synthetic division</a> when the divisor is a linear factor.</p>
<h2 id="algorithm">Algorithm</h2>

<p>The rule establishes a method for dividing the polynomial</p>

<p>

<math display="block" id="Ruffini's_rule:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>n</mi>
     </msub>
     <msup>
      <mi>x</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msup>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>a</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)=a_{n}x^{n}+a_{n-1}x^{n-1}+\cdots+a_{1}x+a_{0}
  </annotation>
 </semantics>
</math>

 by the binomial</p>

<p>

<math display="block" id="Ruffini's_rule:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>-</mo>
    <mi>r</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>x</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x)=x-r\,\!
  </annotation>
 </semantics>
</math>

 to obtain the quotient polynomial</p>

<p>

<math display="block" id="Ruffini's_rule:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>b</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msup>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>b</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
     </msub>
     <msup>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>b</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(x)=b_{n-1}x^{n-1}+b_{n-2}x^{n-2}+\cdots+b_{1}x+b_{0}
  </annotation>
 </semantics>
</math>

;</p>

<p>The algorithm is in fact the <a href="polynomial_long_division" title="wikilink">long division</a> of <em>P</em>(<em>x</em>) by <em>Q</em>(<em>x</em>).</p>

<p>To divide <em>P</em>(<em>x</em>) by <em>Q</em>(<em>x</em>):</p>

<p>1. Take the coefficients of <em>P</em>(<em>x</em>) and write them down in order. Then write <em>r</em> at the bottom left edge, just over the line:</p>

<p><code>    |        a</code><sub><code>n</code></sub><code>        a</code><sub><code>n-1</code></sub><code>        ...        a</code><sub><code>1</code></sub><code>         a</code><sub><code>0</code></sub><br/>
<code>    |                                    </code><br/>
<code>  r |                                    </code><br/>
<code>----|---------------------------------------------------------</code><br/>
<code>    |                                    </code><br/>
<code>    |                                    </code></p>

<p>2. Pass the leftmost coefficient (<em>a</em><sub><em>n</em></sub>) to the bottom, just under the line:</p>

<p><code>    |        a</code><sub><code>n</code></sub><code>        a</code><sub><code>n-1</code></sub><code>        ...        a</code><sub><code>1</code></sub><code>         a</code><sub><code>0</code></sub><br/>
<code>    |                                    </code><br/>
<code>  r |                                    </code><br/>
<code>----|---------------------------------------------------------</code><br/>
<code>    |        a</code><sub><code>n</code></sub><br/>
<code>    |</code><br/>
<code>    |      = b</code><sub><code>n-1</code></sub><code>                                </code><br/>
<code>    |</code></p>

<p>3. Multiply the rightmost number under the line by <em>r</em> and write it over the line and one position to the right:</p>

<p><code>    |        a</code><sub><code>n</code></sub><code>        a</code><sub><code>n-1</code></sub><code>        ...        a</code><sub><code>1</code></sub><code>         a</code><sub><code>0</code></sub><br/>
<code>    |</code><br/>
<code>  r |                  b</code><sub><code>n-1</code></sub><code>r</code><br/>
<code>----|---------------------------------------------------------</code><br/>
<code>    |        a</code><sub><code>n</code></sub><br/>
<code>    |</code><br/>
<code>    |      = b</code><sub><code>n-1</code></sub><code>                                </code><br/>
<code>    |</code></p>

<p>4. Add the two values just placed in the same column</p>

<p><code>    |        a</code><sub><code>n</code></sub><code>        a</code><sub><code>n-1</code></sub><code>        ...        a</code><sub><code>1</code></sub><code>         a</code><sub><code>0</code></sub><br/>
<code>    |</code><br/>
<code>  r |                  b</code><sub><code>n-1</code></sub><code>r</code><br/>
<code>----|---------------------------------------------------------</code><br/>
<code>    |        a</code><sub><code>n</code></sub><code>     a</code><sub><code>n-1</code></sub><code>+(b</code><sub><code>n-1</code></sub><code>r)</code><br/>
<code>    |</code><br/>
<code>    |      = b</code><sub><code>n-1</code></sub><code>     = b</code><sub><code>n-2</code></sub><code>                                </code><br/>
<code>    |</code></p>

<p>5. Repeat steps 3 and 4 until no numbers remain</p>

<p><code>    |        a</code><sub><code>n</code></sub><code>        a</code><sub><code>n-1</code></sub><code>        ...        a</code><sub><code>1</code></sub><code>         a</code><sub><code>0</code></sub><br/>
<code>    |</code><br/>
<code>  r |                  b</code><sub><code>n-1</code></sub><code>r       ...        b</code><sub><code>1</code></sub><code>r        b</code><sub><code>0</code></sub><code>r</code><br/>
<code>----|---------------------------------------------------------</code><br/>
<code>    |        a</code><sub><code>n</code></sub><code>     a</code><sub><code>n-1</code></sub><code>+(b</code><sub><code>n-1</code></sub><code>r)   ...       a</code><sub><code>1</code></sub><code>+b</code><sub><code>1</code></sub><code>r       a</code><sub><code>0</code></sub><code>+b</code><sub><code>0</code></sub><code>r</code><br/>
<code>    |</code><br/>
<code>    |      = b</code><sub><code>n-1</code></sub><code>     = b</code><sub><code>n-2</code></sub><code>       ...       = b</code><sub><code>0</code></sub><code>        = s</code><br/>
<code>    |</code></p>

<p>The <em>b</em> values are the coefficients of the result (<em>R</em>(<em>x</em>)) polynomial, the degree of which is one less than that of <em>P</em>(<em>x</em>). The final value obtained, <em>s</em>, is the remainder. As shown in the <a href="polynomial_remainder_theorem" title="wikilink">polynomial remainder theorem</a>, this remainder is equal to <em>P</em>(<em>r</em>), the value of the polynomial at <em>r</em>.</p>
<h2 id="uses-of-the-rule">Uses of the rule</h2>

<p>Ruffini's rule has many practical applications; most of them rely on simple division (as demonstrated below) or the common extensions given still further below.</p>
<h3 id="polynomial-division-by-x-r">Polynomial division by <em>x</em> − <em>r</em></h3>

<p>A worked example of polynomial division, as described above.</p>

<p>Let:</p>

<p>

<math display="block" id="Ruffini's_rule:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mn>2</mn>
      <msup>
       <mi>x</mi>
       <mn>3</mn>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mn>3</mn>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mn>4</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)=2x^{3}+3x^{2}-4\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Ruffini's_rule:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mn>1.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <cn type="float">1.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x)=x+1.\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>We want to divide <em>P</em>(<em>x</em>) by <em>Q</em>(<em>x</em>) using Ruffini's rule. The main problem is that <em>Q</em>(<em>x</em>) is not a binomial of the form <em>x</em> − <em>r</em>, but rather <em>x</em> + <em>r</em>. We must rewrite <em>Q</em>(<em>x</em>) in this way:</p>

<p>

<math display="block" id="Ruffini's_rule:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>x</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x)=x+1=x-(-1).\,\!
  </annotation>
 </semantics>
</math>

 Now we apply the algorithm:</p>

<p>1. Write down the coefficients and <em>r</em>. Note that, as <em>P</em>(<em>x</em>) didn't contain a coefficient for <em>x</em>, we've written 0:</p>

<p><code>    |     2     3     0     -4</code><br/>
<code>    |                                    </code><br/>
<code> -1 |                                    </code><br/>
<code>----|----------------------------</code><br/>
<code>    |                                    </code><br/>
<code>    |</code></p>

<p>2. Pass the first coefficient down:</p>

<p><code>    |     2     3     0     -4</code><br/>
<code>    |                                    </code><br/>
<code> -1 |                                    </code><br/>
<code>----|----------------------------</code><br/>
<code>    |     2                              </code><br/>
<code>    |</code></p>

<p>3. Multiply the last obtained value by <em>r</em>:</p>

<p><code>    |     2     3     0     -4</code><br/>
<code>    |                                    </code><br/>
<code> -1 |          -2                         </code><br/>
<code>----|----------------------------</code><br/>
<code>    |     2                              </code><br/>
<code>    |</code></p>

<p>4. Add the values:</p>

<p><code>    |     2     3     0     -4</code><br/>
<code>    |</code><br/>
<code> -1 |          -2</code><br/>
<code>----|----------------------------</code><br/>
<code>    |     2     1</code><br/>
<code>    |</code></p>

<p>5. Repeat steps 3 and 4 until we've finished:</p>

<p><code>    |     2     3     0     -4</code><br/>
<code>    |</code><br/>
<code> -1 |          -2    -1      1</code><br/>
<code>----|----------------------------</code><br/>
<code>    |     2     1    -1     -3</code><br/>
<code>    |{result coefficients}{remainder}</code></p>

<p>So, if <em>original number</em> = <em>divisor</em> × <em>quotient</em> + <em>remainder</em>, then</p>

<p>

<math display="block" id="Ruffini's_rule:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi>s</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>x</ci>
      <ci>R</ci>
      <ci>x</ci>
     </apply>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)=Q(x)R(x)+s\,\!
  </annotation>
 </semantics>
</math>

, where</p>

<p>

<math display="block" id="Ruffini's_rule:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mn>2</mn>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>+</mo>
     <mi>x</mi>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(x)=2x^{2}+x-1\,\!
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ruffini's_rule:8">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mo>-</mo>
   <mn>3</mn>
   <mo rspace="12.5pt">;</mo>
   <mo>⇒</mo>
   <mn>2</mn>
   <msup>
    <mi>x</mi>
    <mn>3</mn>
   </msup>
   <mo>+</mo>
   <mn>3</mn>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>-</mo>
   <mn>4</mn>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mi>x</mi>
    <mo>-</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>-</mo>
   <mpadded width="-1.7pt">
    <mn>3</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <eq></eq>
    <minus></minus>
    <cn type="integer">3</cn>
    <ci>normal-;</ci>
    <ci>normal-⇒</ci>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
    <plus></plus>
    <cn type="integer">3</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <minus></minus>
    <cn type="integer">4</cn>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <plus></plus>
     <csymbol cd="unknown">x</csymbol>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <minus></minus>
    <cn type="integer">3</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=-3;\quad\Rightarrow 2x^{3}+3x^{2}-4=(2x^{2}+x-1)(x+1)-3\!
  </annotation>
 </semantics>
</math>


</p>
<h3 id="polynomial-root-finding">Polynomial root-finding</h3>

<p>The <a href="rational_root_theorem" title="wikilink">rational root theorem</a> tells us that for a polynomial <em>f</em>(<em>x</em>) = <em>a</em><sub><em>n</em></sub><em>x</em><sup><em>n</em></sup> + <em>a</em><sub><em>n</em>−1</sub><em>x</em><sup><em>n</em>−1</sup> + ... + <em>a</em><sub>1</sub><em>x</em> + <em>a</em><sub>0</sub> all of whose coefficients (<em>a</em><sub><em>n</em></sub> through <em>a</em><sub>0</sub>) are <a href="integer" title="wikilink">integers</a>, the real <a href="rational_number" title="wikilink">rational</a> roots are always of the form <em>p</em>/<em>q</em>, where <em>p</em> is an integer divisor of <em>a</em><sub>0</sub> and <em>q</em> is an integer divisor of <em>a</em><sub><em>n</em></sub>. Thus if our polynomial is</p>

<p>

<math display="block" id="Ruffini's_rule:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>x</mi>
       <mn>3</mn>
      </msup>
      <mo>+</mo>
      <mrow>
       <mn>2</mn>
       <msup>
        <mi>x</mi>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mi>x</mi>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)=x^{3}+2x^{2}-x-2=0\,\!,
  </annotation>
 </semantics>
</math>

</p>

<p>then the possible rational roots are all the integer divisors of <em>a</em><sub>0</sub> (−2):</p>

<p>

<math display="block" id="Ruffini's_rule:10">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Possible roots:</mtext>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>+</mo>
      <mn>2</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>Possible roots:</mtext>
    <set>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">2</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{Possible roots:}\left\{+1,-1,+2,-2\right\}.
  </annotation>
 </semantics>
</math>

</p>

<p>(This example is simple because the polynomial is <a href="monic_polynomial" title="wikilink">monic</a> (i.e. <em>a</em><sub><em>n</em></sub> = 1); for non-monic polynomials the set of possible roots will include some fractions, but only a finite number of them since <em>a</em><sub><em>n</em></sub> and <em>a</em><sub>0</sub> only have a finite number of integer divisors each.) In any case, for monic polynomials, every rational root is an integer, and so every integer root is just a divisor of the <a href="constant_term" title="wikilink">constant term</a>. It can be shown that this remains true for non-monic polynomials, i.e. <em>to find the integer roots of any polynomials with integer coefficients, it suffices to check the divisors of the constant term</em>.</p>

<p>So, setting <em>r</em> equal to each of these possible roots in turn, we will test-divide the polynomial by (<em>x</em> − <em>r</em>). If the resulting quotient has no remainder, we have found a root.</p>

<p>You can choose one of the following three methods: they will all yield the same results, with the exception that only through the second method and the third method (when applying Ruffini's rule to obtain a factorization) can you discover that a given root is repeated. (Neither method will discover irrational or complex roots.)</p>
<h4 id="method-1">Method 1</h4>

<p>We try to divide <em>P</em>(<em>x</em>) by the binomial (<em>x</em> − each possible root). If the remainder is 0, the selected number is a root (and vice versa):</p>

<p><code>    |    +1    +2    -1     -2                      |    +1    +2    -1    -2</code><br/>
<code>    |                                               |</code><br/>
<code> +1 |          +1    +3     +2                   -1 |          -1    -1    +2</code><br/>
<code>----|----------------------------               ----|---------------------------</code><br/>
<code>    |    +1    +3    +2      0                      |    +1    +1    -2     0</code></p>

<p><code>    |    +1    +2    -1     -2                      |    +1    +2    -1    -2</code><br/>
<code>    |                                               |</code><br/>
<code> +2 |          +2    +8    +14                   -2 |          -2     0    +2</code><br/>
<code>----|----------------------------               ----|---------------------------</code><br/>
<code>    |    +1    +4    +7    +12                      |    +1     0    -1     0</code></p>

<p>

<math display="block" id="Ruffini's_rule:11">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=+1\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Ruffini's_rule:12">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}=-1\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Ruffini's_rule:13">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{3}=-2\,\!
  </annotation>
 </semantics>
</math>

</p>
<h4 id="method-2">Method 2</h4>

<p>We start just as in Method 1 until we find a valid root. Then, instead of restarting the process with the other possible roots, we continue testing the possible roots against the result of the Ruffini on the valid root we've just found until we only have a coefficient remaining (remember that roots can be repeated: if you get stuck, try each valid root twice):</p>

<p><code>    |    +1    +2    -1    -2                      |    +1    +2    -1    -2</code><br/>
<code>    |                                              |</code><br/>
<code> -1 |          -1    -1    +2                   -1 |          -1    -1    +2</code><br/>
<code>----|---------------------------               ----|---------------------------</code><br/>
<code>    |    +1    +1    -2   | 0                      |    +1    +1    -2   | 0</code><br/>
<code>    |                                              |</code><br/>
<code> +2 |          +2    +6                         +1 |          +1    +2</code><br/>
<code>-------------------------                      -------------------------</code><br/>
<code>    |    +1    +3   |+4                            |    +1    +2   | 0</code><br/>
<code>                                                   |</code><br/>
<code>                                                -2 |          -2</code><br/>
<code>                                               -------------------</code><br/>
<code>                                                   |    +1   | 0</code></p>

<p>

<math display="block" id="Ruffini's_rule:14">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=-1\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Ruffini's_rule:15">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}=+1\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Ruffini's_rule:16">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{3}=-2\,\!
  </annotation>
 </semantics>
</math>

</p>
<h4 id="method-3">Method 3</h4>
<ul>
<li>Determine the set of the possible integer or rational roots of the polynomial according to the <a href="rational_root_theorem" title="wikilink">rational root theorem</a>.</li>
<li>For each possible root r, instead of performing the division P(x)/(x -r), apply the <a href="polynomial_remainder_theorem" title="wikilink">polynomial remainder theorem</a>, which states that the remainder of this division is P(r), i.e. the polynomial evaluated for x = r.</li>
</ul>

<p>Thus, for each r in our set, r is actually a root of the polynomial if and only if P(r) = 0</p>

<p>This shows that finding <em>integer and rational</em> roots of a polynomial neither requires any division nor the application of Ruffini's rule.</p>

<p>However, once a valid root has been found, call it r<sub>1</sub>: you can apply Ruffini's rule to determine<br/>
Q(x) = P(x)/(x-r<sub>1</sub>).<br/>
This allows you to partially factorize the polynomial as<br/>
P(x) = (x -r<sub>1</sub>)·Q(X)</p>

<p>Any additional (rational) root of the polynomial is also a root of Q(x) and, of course, is still to be found among the possible roots determined earlier which have not yet been checked (any value already determined <em>not</em> to be a root of P(x) is not a root of Q(x) either; more formally, P(r)≠0 → Q(r)≠0 ).</p>

<p>Thus, you can proceed evaluating Q(r) instead of P(r), and (as long as you can find another root, r<sub>2</sub>) dividing Q(r) by (x-r<sub>2</sub>).</p>

<p>Even if you're only searching for roots, this allows you to evaluate polynomials of successively smaller degree, as the factorization proceeds.</p>

<p>If, as is often the case, you're also factorizing a polynomial of degree n, then:</p>
<ul>
<li>if you've found p=n rational solutions you end up with a complete factorization (see below) into p=n linear factors;</li>
<li>if you've found p<n (see="" *p(1)="0" +2x²="" -1,="" -2="" -2}="" -x="" 2,="" =="" a="" and="" another="" applying="" below)="" complex="" degree="" end="" examples:="Finding" factor="" factorization="" factors="" have="" in="" into="" irrational="" linear="" may="" n-p,="" non-linear="" of="" or="" p="" partial="" possible="" rational="" roots="{1," roots.="" ruffini's="" rule="P(x)" solutions="" turn,="" up="" which,="" with="" without="" x="" x<sub="" you="">1


<p>= 1</p></n></li></ul></body></html>
<li>P(-1) = 0 → x<sub>2</sub> = -1</li>
<li>P(2) = 12 → 2 is not a root of the polynomial</li>


<p>and the remainder of (x³ +2x² -x -2)/(x-2) is 12</p>
<ul>
<li>P(-2) = 0 → x<sub>3</sub> = -2</li>
</ul>
<h5 id="finding-roots-applying-ruffinis-rule-and-obtaining-a-complete-factorization">Finding roots applying Ruffini's Rule and obtaining a (complete) factorization</h5>

<p>P(x) = x³ +2x² -x -2</p>

<p>Possible roots = {1, -1, 2, -2}</p>
<ul>
<li>P(1) = 0 → x<sub>1</sub> = 1</li>
</ul>

<p>Then, applying Ruffini's Rule:</p>

<p>(x³ +2x² -x -2) / (x -1) = (x² +3x +2) →<br/>
→ x³ +2x² -x -2 = (x-1)(x² +3x +2)</p>

<p>Here, r<sub>1</sub>=-1 and Q(x) = x² +3x +2</p>
<ul>
<li>Q(-1) = 0 → x<sub>2</sub> = -1</li>
</ul>

<p>Again, applying Ruffini's Rule:</p>

<p>(x² +3x +2) / (x +1) = (x +2) →<br/>
→ x³ +2x² -x -2 = (x-1)(x² +3x +2) = (x-1)(x+1)(x+2)</p>

<p>As it was possible to completely factorize the polynomial, it's clear that the last root is -2 (the previous procedure would have given the same result, with a final quotient of 1).</p>
<h3 id="polynomial-factoring">Polynomial factoring</h3>

<p>Having used the "<em>p</em>/<em>q</em>" result above (or, to be fair, any other means) to find all the real rational roots of a particular polynomial, it is but a trivial step further to partially <a href="factorization" title="wikilink">factor</a> that polynomial using those roots. As is well-known, each linear factor (<em>x</em> − <em>r</em>) which divides a given polynomial corresponds with a root <em>r</em>, and <em>vice versa</em>.</p>

<p>So if</p>

<p>

<math display="block" id="Ruffini's_rule:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>n</mi>
     </msub>
     <msup>
      <mi>x</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msup>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>a</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)=a_{n}x^{n}+a_{n-1}x^{n-1}+\cdots+a_{1}x+a_{0}\,\!
  </annotation>
 </semantics>
</math>

 is our polynomial; and</p>

<p>

<math display="block" id="Ruffini's_rule:18">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtext>roots of</mtext>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>ℚ</mi>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <mtext>roots of</mtext>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">Q</csymbol>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=\left\{\mbox{roots of }P(x)\in\mathbb{Q}\right\}\,\!
  </annotation>
 </semantics>
</math>

 are the roots we have found, then consider the product</p>

<p>

<math display="block" id="Ruffini's_rule:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>-</mo>
         <mi>r</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mtext>for all</mtext>
       <mi>r</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi>R</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <ci>x</ci>
         <ci>r</ci>
        </apply>
        <mtext>for all</mtext>
        <ci>r</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(x)=a_{n}{\prod(x-r)}\mbox{ for all }r\in R.\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>By the <a href="fundamental_theorem_of_algebra" title="wikilink">fundamental theorem of algebra</a>, <em>R</em>(<em>x</em>) should be equal to <em>P</em>(<em>x</em>), if all the roots of <em>P</em>(<em>x</em>) are rational. But since we have been using a method which finds only rational roots, it is very likely that <em>R</em>(<em>x</em>) is not equal to <em>P</em>(<em>x</em>); it is very likely that <em>P</em>(<em>x</em>) has some irrational or complex roots not in <em>R</em>. So consider</p>

<p>

<math display="block" id="Ruffini's_rule:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(x)=\frac{P(x)}{R(x)}\,\!
  </annotation>
 </semantics>
</math>

, which can be calculated using <a href="polynomial_long_division" title="wikilink">polynomial long division</a>.</p>

<p>If <em>S</em>(<em>x</em>) = 1, then we know <em>R</em>(<em>x</em>) = <em>P</em>(<em>x</em>) and we are done. Otherwise, <em>S</em>(<em>x</em>) will itself be a polynomial; this is another factor of <em>P</em>(<em>x</em>) which has no real rational roots. So write out the right-hand-side of the following equation in full:</p>

<p>

<math display="block" id="Ruffini's_rule:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>R</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⋅</mo>
      <mi>S</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <ci>R</ci>
       <ci>x</ci>
      </apply>
      <ci>S</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)=R(x)\cdot S(x).\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>We can call this a <em>complete factorization</em> of <em>P</em>(<em>x</em>) over <strong>Q</strong> (the rationals) if <em>S</em>(<em>x</em>) = 1. Otherwise, we only have a <em>partial factorization</em> of <em>P</em>(<em>x</em>) over <strong>Q</strong>, which may or may not be further factorable over the rationals; but which will certainly be further factorable over the reals or at worst the complex plane. (Note: by a "complete factorization" of <em>P</em>(<em>x</em>) over <strong>Q</strong>, we mean a factorization as a product of polynomials with rational coefficients, such that each factor is irreducible over <strong>Q</strong>, where "irreducible over <strong>Q</strong>" means that the factor cannot be written as the product of two non-constant polynomials with rational coefficients and smaller degree.)</p>
<h4 id="example-1-no-remainder">Example 1: no remainder</h4>

<p>Let</p>

<p>

<math display="block" id="Ruffini's_rule:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>x</mi>
      <mn>3</mn>
     </msup>
     <mo>+</mo>
     <mrow>
      <mn>2</mn>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mi>x</mi>
    <mo>-</mo>
    <mn>2.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <ci>x</ci>
     <cn type="float">2.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)=x^{3}+2x^{2}-x-2.\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Using the methods described above, the rational roots of <em>P</em>(<em>x</em>) are:</p>

<p>

<math display="block" id="Ruffini's_rule:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mo>=</mo>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <set>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">2</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=\left\{+1,-1,-2\right\}.\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Then, the product of (<em>x</em> − each root) is</p>

<p>

<math display="block" id="Ruffini's_rule:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>+</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(x)=1(x-1)(x+1)(x+2).\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>And <em>P</em>(<em>x</em>)/<em>R</em>(<em>x</em>):</p>

<p>

<math display="block" id="Ruffini's_rule:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>x</ci>
    </apply>
    <cn type="float">1.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(x)=1.\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Hence the factored polynomial is <em>P</em>(<em>x</em>) = <em>R</em>(<em>x</em>) · 1 = <em>R</em>(<em>x</em>):</p>

<p>

<math display="block" id="Ruffini's_rule:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>+</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)=(x-1)(x+1)(x+2).\,\!
  </annotation>
 </semantics>
</math>

</p>
<h4 id="example-2-with-remainder">Example 2: with remainder</h4>

<p>Let</p>

<p>

<math display="block" id="Ruffini's_rule:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mn>2</mn>
       <msup>
        <mi>x</mi>
        <mn>4</mn>
       </msup>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mn>3</mn>
       <msup>
        <mi>x</mi>
        <mn>3</mn>
       </msup>
      </mrow>
     </mrow>
     <mo>+</mo>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <mi>x</mi>
    </mrow>
    <mo>-</mo>
    <mn>8.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">4</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">3</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">3</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>x</ci>
     </apply>
     <cn type="float">8.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)=2x^{4}-3x^{3}+x^{2}-2x-8.\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Using the methods described above, the rational roots of <em>P</em>(<em>x</em>) are:</p>

<p>

<math display="block" id="Ruffini's_rule:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mo>=</mo>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>+</mo>
      <mn>2</mn>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <set>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">2</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=\left\{-1,+2\right\}.\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Then, the product of (<em>x</em> − each root) is</p>

<p>

<math display="block" id="Ruffini's_rule:29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(x)=(x+1)(x-2).\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>And <em>P</em>(<em>x</em>)/<em>R</em>(<em>x</em>)</p>

<p>

<math display="block" id="Ruffini's_rule:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mn>2</mn>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>-</mo>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mn>4.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
     <cn type="float">4.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(x)=2x^{2}-x+4.\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>As 

<math display="inline" id="Ruffini's_rule:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>x</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(x){\neq}1
  </annotation>
 </semantics>
</math>

, the factored polynomial is <em>P</em>(<em>x</em>) = <em>R</em>(<em>x</em>) · <em>S</em>(<em>x</em>):</p>

<p>

<math display="block" id="Ruffini's_rule:32">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mrow>
         <mn>2</mn>
         <msup>
          <mi>x</mi>
          <mn>2</mn>
         </msup>
        </mrow>
        <mo>-</mo>
        <mi>x</mi>
       </mrow>
       <mo>+</mo>
       <mn>4</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>x</ci>
      </apply>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)=(x+1)(x-2)(2x^{2}-x+4).\,\!
  </annotation>
 </semantics>
</math>

</p>
<h4 id="factoring-over-the-complexes">Factoring over the complexes</h4>

<p>To completely factor a given polynomial over <strong>C</strong>, the complex numbers, we must know all of its roots (and that could include irrational and/or complex numbers). For example, consider the polynomial above:</p>

<p>

<math display="block" id="Ruffini's_rule:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mn>2</mn>
       <msup>
        <mi>x</mi>
        <mn>4</mn>
       </msup>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mn>3</mn>
       <msup>
        <mi>x</mi>
        <mn>3</mn>
       </msup>
      </mrow>
     </mrow>
     <mo>+</mo>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <mi>x</mi>
    </mrow>
    <mo>-</mo>
    <mn>8.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">4</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">3</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">3</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>x</ci>
     </apply>
     <cn type="float">8.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)=2x^{4}-3x^{3}+x^{2}-2x-8.\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Extracting its rational roots and factoring it, we end with:</p>

<p>

<math display="block" id="Ruffini's_rule:34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mrow>
         <mn>2</mn>
         <msup>
          <mi>x</mi>
          <mn>2</mn>
         </msup>
        </mrow>
        <mo>-</mo>
        <mi>x</mi>
       </mrow>
       <mo>+</mo>
       <mn>4</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>x</ci>
      </apply>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)=(x+1)(x-2)(2x^{2}-x+4).\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>But that is not completely factored over <strong>C</strong>. If we need to factor our polynomial to a product of linear factors, we must deal with that quadratic factor</p>

<p>

<math display="block" id="Ruffini's_rule:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mn>2</mn>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>-</mo>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mn>4</mn>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
     <cn type="integer">4</cn>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {2x^{2}-x+4}=0.\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>The easiest way is to use <a href="quadratic_formula" title="wikilink">quadratic formula</a>, which gives us</p>

<p>

<math display="block" id="Ruffini's_rule:36">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mo>-</mo>
      <mi>b</mi>
     </mrow>
     <mo>±</mo>
     <msqrt>
      <mrow>
       <msup>
        <mi>b</mi>
        <mn>2</mn>
       </msup>
       <mo>-</mo>
       <mrow>
        <mn>4</mn>
        <mi>a</mi>
        <mi>c</mi>
       </mrow>
      </mrow>
     </msqrt>
    </mrow>
    <mrow>
     <mn>2</mn>
     <mi>a</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mn>1</mn>
     <mo>±</mo>
     <msqrt>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
       <mo>-</mo>
       <mrow>
        <mn>4</mn>
        <mo>⋅</mo>
        <mn>2</mn>
        <mo>⋅</mo>
        <mn>4</mn>
       </mrow>
      </mrow>
     </msqrt>
    </mrow>
    <mrow>
     <mn>2</mn>
     <mo>⋅</mo>
     <mn>2</mn>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mn>1</mn>
     <mo>±</mo>
     <msqrt>
      <mrow>
       <mo>-</mo>
       <mn>31</mn>
      </mrow>
     </msqrt>
    </mrow>
    <mn>4</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>x</ci>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="latexml">plus-or-minus</csymbol>
       <apply>
        <minus></minus>
        <ci>b</ci>
       </apply>
       <apply>
        <root></root>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>b</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">4</cn>
          <ci>a</ci>
          <ci>c</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>a</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="latexml">plus-or-minus</csymbol>
       <cn type="integer">1</cn>
       <apply>
        <root></root>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <ci>normal-⋅</ci>
          <cn type="integer">4</cn>
          <cn type="integer">2</cn>
          <cn type="integer">4</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">2</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="latexml">plus-or-minus</csymbol>
       <cn type="integer">1</cn>
       <apply>
        <root></root>
        <apply>
         <minus></minus>
         <cn type="integer">31</cn>
        </apply>
       </apply>
      </apply>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=\frac{-b\pm\sqrt{b^{2}-4ac}}{2a}=\frac{1\pm\sqrt{(-1)^{2}-4\cdot 2\cdot 4}}{%
2\cdot 2}=\frac{1\pm\sqrt{-31}}{4}\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>and the solutions</p>

<p>

<math display="block" id="Ruffini's_rule:37">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <msqrt>
      <mrow>
       <mo>-</mo>
       <mn>31</mn>
      </mrow>
     </msqrt>
    </mrow>
    <mn>4</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <apply>
        <minus></minus>
        <cn type="integer">31</cn>
       </apply>
      </apply>
     </apply>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=\frac{1+\sqrt{-31}}{4}\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Ruffini's_rule:38">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <msqrt>
       <mrow>
        <mo>-</mo>
        <mn>31</mn>
       </mrow>
      </msqrt>
     </mrow>
     <mn>4</mn>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <apply>
        <minus></minus>
        <cn type="integer">31</cn>
       </apply>
      </apply>
     </apply>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}=\frac{1-\sqrt{-31}}{4}.\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>So the completely factored polynomial over <strong>C</strong> will be:</p>

<p>

<math display="block" id="Ruffini's_rule:39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>2</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mfrac>
        <mrow>
         <mn>1</mn>
         <mo>+</mo>
         <mrow>
          <mi>i</mi>
          <msqrt>
           <mn>31</mn>
          </msqrt>
         </mrow>
        </mrow>
        <mn>4</mn>
       </mfrac>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mfrac>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mrow>
          <mi>i</mi>
          <msqrt>
           <mn>31</mn>
          </msqrt>
         </mrow>
        </mrow>
        <mn>4</mn>
       </mfrac>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>i</ci>
         <apply>
          <root></root>
          <cn type="integer">31</cn>
         </apply>
        </apply>
       </apply>
       <cn type="integer">4</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>i</ci>
         <apply>
          <root></root>
          <cn type="integer">31</cn>
         </apply>
        </apply>
       </apply>
       <cn type="integer">4</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)=2(x+1)(x-2)(x-\frac{1+i\sqrt{31}}{4})(x-\frac{1-i\sqrt{31}}{4}).\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>However, it should be noted that we cannot in every case expect things to be so easy; the quadratic formula's analogue for fourth-order polynomials is very messy and no such analogue exists for 5th-or-higher order polynomials. See <a href="Galois_theory" title="wikilink">Galois theory</a> for a theoretical explanation of why this is so, and see <a href="numerical_analysis" title="wikilink">numerical analysis</a> for ways to <em>approximate</em> roots of polynomials numerically.</p>
<h4 id="limitations">Limitations</h4>

<p>It is entirely possible that, when looking for a given polynomial's roots, we might obtain a messy higher-order polynomial for S(x) which is further factorable over the <em>rationals</em> even before considering irrational or complex factorings. Consider the polynomial <em>x</em><sup>5</sup> − 3<em>x</em><sup>4</sup> + 3<em>x</em><sup>3</sup> − 9<em>x</em><sup>2</sup> + 2<em>x</em> − 6. Using Ruffini's method we will find only one root (<em>x</em> = 3); factoring it out gives us <em>P</em>(<em>x</em>) = (<em>x</em><sup>4</sup> + 3<em>x</em><sup>2</sup> + 2)(<em>x</em> − 3).</p>

<p>As explained above, if our assignment was to "factor into irreducibles over <strong>C</strong>" we know that would have to find some way to dissect the quartic and look for its irrational and/or complex roots. But if we were asked to "factor into irreducibles over <strong>Q</strong>", we might think we are done; but it is important to realize that this might not necessarily be the case.</p>

<p>For in this instance the quartic is actually factorable as the product of two quadratics (<em>x</em><sup>2</sup> + 1)(<em>x</em><sup>2</sup> + 2). These, at last, are irreducible over the rationals (and, indeed, the reals as well in this example); so now we are done; <em>P</em>(<em>x</em>) = (<em>x</em><sup>2</sup> + 1)(<em>x</em><sup>2</sup> + 2)(<em>x</em> − 3). In this instance it is in fact easy to factor our quartic by treating it as a <a href="Quartic_equation#Biquadratic_equations" title="wikilink">biquadratic equation</a>; but finding such factorings of a higher degree polynomial can be very difficult.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Horner_scheme" title="wikilink">Horner's method</a></li>
<li><a href="Polynomial_long_division" title="wikilink">Polynomial long division</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://www.purplemath.com/modules/synthdiv.htm">Synthetic Division</a>, an article by Elizabeth Stapel on Purplemath</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Polynomials" title="wikilink">Category:Polynomials</a> <a href="Category:Root-finding_algorithms" title="wikilink">Category:Root-finding algorithms</a> <a href="Category:Division_(mathematics)" title="wikilink">Category:Division (mathematics)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>


