<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1598">Bruun's FFT algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Bruun's FFT algorithm</h1>
<hr/>

<p><strong>Bruun's algorithm</strong> is a <a href="fast_Fourier_transform" title="wikilink">fast Fourier transform</a> (FFT) algorithm based on an unusual recursive <a class="uri" href="polynomial" title="wikilink">polynomial</a>-factorization approach, proposed for powers of two by G. Bruun in 1978 and generalized to arbitrary even composite sizes by H. Murakami in 1996. Because its operations involve only real coefficients until the last computation stage, it was initially proposed as a way to efficiently compute the <a href="discrete_Fourier_transform" title="wikilink">discrete Fourier transform</a> (DFT) of real data. Bruun's algorithm has not seen widespread use, however, as approaches based on the ordinary <a href="Cooley–Tukey_FFT_algorithm" title="wikilink">Cooley–Tukey FFT algorithm</a> have been successfully adapted to real data with at least as much efficiency. Furthermore, there is evidence that Bruun's algorithm may be intrinsically less accurate than Cooley–Tukey in the face of finite numerical precision (Storn, 1993).</p>

<p>Nevertheless, Bruun's algorithm illustrates an alternative algorithmic framework that can express both itself and the Cooley–Tukey algorithm, and thus provides an interesting perspective on FFTs that permits mixtures of the two algorithms and other generalizations.</p>
<h2 id="a-polynomial-approach-to-the-dft">A polynomial approach to the DFT</h2>

<p>Recall that the DFT is defined by the formula:</p>

<p>

<math display="block" id="Bruun's_FFT_algorithm:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mi>k</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </munderover>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <msup>
       <mi>e</mi>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mfrac>
          <mrow>
           <mn>2</mn>
           <mi>π</mi>
           <mi>i</mi>
          </mrow>
          <mi>N</mi>
         </mfrac>
         <mi>n</mi>
         <mi>k</mi>
        </mrow>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mrow>
     <mn>0</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>1.</mn>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <divide></divide>
           <apply>
            <times></times>
            <cn type="integer">2</cn>
            <ci>π</ci>
            <ci>i</ci>
           </apply>
           <ci>N</ci>
          </apply>
          <ci>n</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>k</ci>
     <list>
      <cn type="integer">0</cn>
      <ci>normal-…</ci>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="float">1.</cn>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{k}=\sum_{n=0}^{N-1}x_{n}e^{-\frac{2\pi i}{N}nk}\qquad k=0,\dots,N-1.
  </annotation>
 </semantics>
</math>

</p>

<p>For convenience, let us denote the <em>N</em> <a href="root_of_unity" title="wikilink">roots of unity</a> by ω<sub><em>N</em></sub><sup><em>n</em></sup> (<em>n</em> = 0, ..., <em>N</em> − 1):</p>

<p>

<math display="block" id="Bruun's_FFT_algorithm:1">
 <semantics>
  <mrow>
   <msubsup>
    <mi>ω</mi>
    <mi>N</mi>
    <mi>n</mi>
   </msubsup>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <mrow>
        <mn>2</mn>
        <mi>π</mi>
        <mi>i</mi>
       </mrow>
       <mi>N</mi>
      </mfrac>
      <mi>n</mi>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>N</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>π</ci>
         <ci>i</ci>
        </apply>
        <ci>N</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{N}^{n}=e^{-\frac{2\pi i}{N}n}
  </annotation>
 </semantics>
</math>

</p>

<p>and define the polynomial <em>x</em>(<em>z</em>) whose coefficients are <em>x</em><sub><em>n</em></sub>:</p>

<p>

<math display="block" id="Bruun's_FFT_algorithm:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </munderover>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <msup>
       <mi>z</mi>
       <mi>n</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(z)=\sum_{n=0}^{N-1}x_{n}z^{n}.
  </annotation>
 </semantics>
</math>

</p>

<p>The DFT can then be understood as a <em>reduction</em> of this polynomial; that is, <em>X</em><sub><em>k</em></sub> is given by:</p>

<p>

<math display="block" id="Bruun's_FFT_algorithm:3">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>ω</mi>
      <mi>N</mi>
      <mi>k</mi>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>z</mi>
      <mo>-</mo>
      <msubsup>
       <mi>ω</mi>
       <mi>N</mi>
       <mi>k</mi>
      </msubsup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>N</ci>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">modulo</csymbol>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>z</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>z</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <ci>N</ci>
        </apply>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{k}=x(\omega_{N}^{k})=x(z)\mod(z-\omega_{N}^{k})
  </annotation>
 </semantics>
</math>

</p>

<p>where <strong>mod</strong> denotes the <a href="Polynomial_remainder_theorem" title="wikilink">polynomial remainder</a> operation. The key to fast algorithms like Bruun's or Cooley–Tukey comes from the fact that one can perform this set of <em>N</em> remainder operations in recursive stages.</p>
<h2 id="recursive-factorizations-and-ffts">Recursive factorizations and FFTs</h2>

<p>In order to compute the DFT, we need to evaluate the remainder of 

<math display="inline" id="Bruun's_FFT_algorithm:4">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(z)
  </annotation>
 </semantics>
</math>

 modulo <em>N</em> degree-1 polynomials as described above. Evaluating these remainders one by one is equivalent to the evaluating the usual DFT formula directly, and requires O(<em>N</em><sup>2</sup>) operations. However, one can <em>combine</em> these remainders recursively to reduce the cost, using the following trick: if we want to evaluate 

<math display="inline" id="Bruun's_FFT_algorithm:5">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(z)
  </annotation>
 </semantics>
</math>

 modulo two polynomials 

<math display="inline" id="Bruun's_FFT_algorithm:6">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(z)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bruun's_FFT_algorithm:7">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(z)
  </annotation>
 </semantics>
</math>

, we can first take the remainder modulo their product 

<math display="inline" id="Bruun's_FFT_algorithm:8">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(z)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Bruun's_FFT_algorithm:9">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(z)
  </annotation>
 </semantics>
</math>

, which reduces the <a href="Degree_of_a_polynomial" title="wikilink">degree</a> of the polynomial 

<math display="inline" id="Bruun's_FFT_algorithm:10">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(z)
  </annotation>
 </semantics>
</math>

 and makes subsequent modulo operations less computationally expensive.</p>

<p>The product of all of the monomials 

<math display="inline" id="Bruun's_FFT_algorithm:11">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>z</mi>
    <mo>-</mo>
    <msubsup>
     <mi>ω</mi>
     <mi>N</mi>
     <mi>k</mi>
    </msubsup>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>z</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>N</ci>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (z-\omega_{N}^{k})
  </annotation>
 </semantics>
</math>

 for <em>k</em>=0..<em>N</em>-1 is simply 

<math display="inline" id="Bruun's_FFT_algorithm:12">
 <semantics>
  <mrow>
   <msup>
    <mi>z</mi>
    <mi>N</mi>
   </msup>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>z</ci>
     <ci>N</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{N}-1
  </annotation>
 </semantics>
</math>

 (whose roots are clearly the <em>N</em> roots of unity). One then wishes to find a recursive factorization of 

<math display="inline" id="Bruun's_FFT_algorithm:13">
 <semantics>
  <mrow>
   <msup>
    <mi>z</mi>
    <mi>N</mi>
   </msup>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>z</ci>
     <ci>N</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{N}-1
  </annotation>
 </semantics>
</math>

 into polynomials of few terms and smaller and smaller degree. To compute the DFT, one takes 

<math display="inline" id="Bruun's_FFT_algorithm:14">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(z)
  </annotation>
 </semantics>
</math>

 modulo each level of this factorization in turn, recursively, until one arrives at the monomials and the final result. If each level of the factorization splits every polynomial into an O(1) (constant-bounded) number of smaller polynomials, each with an O(1) number of nonzero coefficients, then the modulo operations for that level take O(<em>N</em>) time; since there will be a logarithmic number of levels, the overall complexity is O (<em>N</em> log <em>N</em>).</p>

<p>More explicitly, suppose for example that 

<math display="inline" id="Bruun's_FFT_algorithm:15">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>z</mi>
     <mi>N</mi>
    </msup>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>F</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>F</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>F</mi>
     <mn>3</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <ci>N</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>z</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>z</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{N}-1=F_{1}(z)F_{2}(z)F_{3}(z)
  </annotation>
 </semantics>
</math>

, and that 

<math display="inline" id="Bruun's_FFT_algorithm:16">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>F</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>F</mi>
     <mrow>
      <mi>k</mi>
      <mo>,</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>F</mi>
     <mrow>
      <mi>k</mi>
      <mo>,</mo>
      <mn>2</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>k</ci>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <list>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </list>
     </apply>
     <ci>z</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <list>
       <ci>k</ci>
       <cn type="integer">2</cn>
      </list>
     </apply>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{k}(z)=F_{k,1}(z)F_{k,2}(z)
  </annotation>
 </semantics>
</math>

, and so on. The corresponding FFT algorithm would consist of first computing <em>x</em><sub><em>k</em></sub>(<em>z</em>) = <em>x</em>(<em>z</em>) mod <em>F</em><sub><em>k</em></sub>(<em>z</em>), then computing <em>x</em><sub><em>k</em>,<em>j</em></sub>(<em>z</em>) = <em>x</em><sub><em>k</em></sub>(<em>z</em>) mod <em>F</em><sub><em>k</em>,<em>j</em></sub>(<em>z</em>), and so on, recursively creating more and more remainder polynomials of smaller and smaller degree until one arrives at the final degree-0 results.</p>

<p>Moreover, as long as the polynomial factors at each stage are <a href="relatively_prime_polynomials" title="wikilink">relatively prime</a> (which for polynomials means that they have no common roots), one can construct a dual algorithm by reversing the process with the <a href="Chinese_Remainder_Theorem" title="wikilink">Chinese Remainder Theorem</a>.</p>
<h3 id="cooleytukey-as-polynomial-factorization">Cooley–Tukey as polynomial factorization</h3>

<p>The standard decimation-in-frequency (DIF) radix-<em>r</em> Cooley–Tukey algorithm corresponds closely to a recursive factorization. For example, radix-2 DIF Cooley–Tukey factors 

<math display="inline" id="Bruun's_FFT_algorithm:17">
 <semantics>
  <mrow>
   <msup>
    <mi>z</mi>
    <mi>N</mi>
   </msup>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>z</ci>
     <ci>N</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{N}-1
  </annotation>
 </semantics>
</math>

 into 

<math display="inline" id="Bruun's_FFT_algorithm:18">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>z</mi>
      <mrow>
       <mi>N</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <apply>
       <divide></divide>
       <ci>N</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{1}=(z^{N/2}-1)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bruun's_FFT_algorithm:19">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>z</mi>
      <mrow>
       <mi>N</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <apply>
       <divide></divide>
       <ci>N</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{2}=(z^{N/2}+1)
  </annotation>
 </semantics>
</math>

. These modulo operations reduce the degree of 

<math display="inline" id="Bruun's_FFT_algorithm:20">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(z)
  </annotation>
 </semantics>
</math>

 by 2, which corresponds to dividing the problem size by 2. Instead of recursively factorizing 

<math display="inline" id="Bruun's_FFT_algorithm:21">
 <semantics>
  <msub>
   <mi>F</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{2}
  </annotation>
 </semantics>
</math>

 directly, though, Cooley–Tukey instead first computes <em>x</em><sub>2</sub>(<em>z</em> ω<sub><em>N</em></sub>), shifting all the roots (by a <em>twiddle factor</em>) so that it can apply the recursive factorization of 

<math display="inline" id="Bruun's_FFT_algorithm:22">
 <semantics>
  <msub>
   <mi>F</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{1}
  </annotation>
 </semantics>
</math>

 to both subproblems. That is, Cooley–Tukey ensures that all subproblems are also DFTs, whereas this is not generally true for an arbitrary recursive factorization (such as Bruun's, below).</p>
<h2 id="the-bruun-factorization">The Bruun factorization</h2>

<p>The basic Bruun algorithm for <a href="power_of_two" title="wikilink">powers of two</a> <em>N</em>=<em>2</em><sup><em>n</em></sup> factorizes <em>z</em><sup><em>2</em><sup><em>n</em></sup></sup>-<em>1</em> recursively via the rules:</p>

<p>

<math display="block" id="Bruun's_FFT_algorithm:23">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>z</mi>
     <mrow>
      <mn>2</mn>
      <mi>M</mi>
     </mrow>
    </msup>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>z</mi>
       <mi>M</mi>
      </msup>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>z</mi>
       <mi>M</mi>
      </msup>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>M</ci>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>M</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>M</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{2M}-1=(z^{M}-1)(z^{M}+1)\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Bruun's_FFT_algorithm:24">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>z</mi>
     <mrow>
      <mn>4</mn>
      <mi>M</mi>
     </mrow>
    </msup>
    <mo>+</mo>
    <mrow>
     <mi>a</mi>
     <msup>
      <mi>z</mi>
      <mrow>
       <mn>2</mn>
       <mi>M</mi>
      </mrow>
     </msup>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>z</mi>
       <mrow>
        <mn>2</mn>
        <mi>M</mi>
       </mrow>
      </msup>
      <mo>+</mo>
      <mrow>
       <msqrt>
        <mrow>
         <mn>2</mn>
         <mo>-</mo>
         <mi>a</mi>
        </mrow>
       </msqrt>
       <msup>
        <mi>z</mi>
        <mi>M</mi>
       </msup>
      </mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msup>
        <mi>z</mi>
        <mrow>
         <mn>2</mn>
         <mi>M</mi>
        </mrow>
       </msup>
       <mo>-</mo>
       <mrow>
        <msqrt>
         <mrow>
          <mn>2</mn>
          <mo>-</mo>
          <mi>a</mi>
         </mrow>
        </msqrt>
        <msup>
         <mi>z</mi>
         <mi>M</mi>
        </msup>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <apply>
       <times></times>
       <cn type="integer">4</cn>
       <ci>M</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>M</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>M</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <root></root>
        <apply>
         <minus></minus>
         <cn type="integer">2</cn>
         <ci>a</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <ci>M</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>M</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <root></root>
         <apply>
          <minus></minus>
          <cn type="integer">2</cn>
          <ci>a</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <ci>M</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{4M}+az^{2M}+1=(z^{2M}+\sqrt{2-a}z^{M}+1)(z^{2M}-\sqrt{2-a}z^{M}+1)
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>a</em> is a real constant with |<em>a</em>| ≤ 2. If 

<math display="inline" id="Bruun's_FFT_algorithm:25">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mrow>
     <mi>cos</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ϕ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <cos></cos>
      <ci>ϕ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=2\cos(\phi)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Bruun's_FFT_algorithm:26">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi>π</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ϕ</ci>
    <interval closure="open">
     <cn type="integer">0</cn>
     <ci>π</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\in(0,\pi)
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Bruun's_FFT_algorithm:27">
 <semantics>
  <mrow>
   <msqrt>
    <mrow>
     <mn>2</mn>
     <mo>+</mo>
     <mi>a</mi>
    </mrow>
   </msqrt>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mrow>
     <mi>cos</mi>
     <mfrac>
      <mi>ϕ</mi>
      <mn>2</mn>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <root></root>
     <apply>
      <plus></plus>
      <cn type="integer">2</cn>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <cos></cos>
      <apply>
       <divide></divide>
       <ci>ϕ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{2+a}=2\cos\tfrac{\phi}{2}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bruun's_FFT_algorithm:28">
 <semantics>
  <mrow>
   <msqrt>
    <mrow>
     <mn>2</mn>
     <mo>-</mo>
     <mi>a</mi>
    </mrow>
   </msqrt>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mrow>
     <mi>cos</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>π</mi>
       <mo>-</mo>
       <mfrac>
        <mi>ϕ</mi>
        <mn>2</mn>
       </mfrac>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <root></root>
     <apply>
      <minus></minus>
      <cn type="integer">2</cn>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <cos></cos>
      <apply>
       <minus></minus>
       <ci>π</ci>
       <apply>
        <divide></divide>
        <ci>ϕ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{2-a}=2\cos(\pi-\tfrac{\phi}{2})
  </annotation>
 </semantics>
</math>

.</p>

<p>At stage <em>s</em>, <em>s</em>=0,1,2,<em>n</em>-1, the intermediate state consists of <em>2</em><sup><em>s</em></sup> polynomials 

<math display="inline" id="Bruun's_FFT_algorithm:29">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mrow>
     <mi>s</mi>
     <mo>,</mo>
     <mn>0</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>p</mi>
    <mrow>
     <mi>s</mi>
     <mo>,</mo>
     <mrow>
      <msup>
       <mn>2</mn>
       <mi>s</mi>
      </msup>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <list>
      <ci>s</ci>
      <cn type="integer">0</cn>
     </list>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <list>
      <ci>s</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>s</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </list>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{s,0},\dots,p_{s,2^{s}-1}
  </annotation>
 </semantics>
</math>

 of degree <em>2</em><sup><em>n</em>-<em>s</em></sup> - <em>1</em> or less , where</p>

<p>

<math display="inline" id="Bruun's_FFT_algorithm:30">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mrow>
     <mi>s</mi>
     <mo>,</mo>
     <mn>0</mn>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <list>
      <ci>s</ci>
      <cn type="integer">0</cn>
     </list>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle p_{s,0}(z)
  </annotation>
 </semantics>
</math>


</p>

<p>By the construction of the factorization of <em>z</em><sup><em>2</em><sup><em>n</em></sup></sup>-<em>1</em>, the polynomials <em>p</em><sub><em>s</em>,<em>m</em></sub>(<em>z</em>) each encode 2<sup><em>n</em>-<em>s</em></sup> values</p>

<p>

<math display="block" id="Bruun's_FFT_algorithm:31">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>e</mi>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
       <mi>i</mi>
       <mstyle scriptlevel="-1">
        <mfrac>
         <mi>k</mi>
         <msup>
          <mn>2</mn>
          <mi>n</mi>
         </msup>
        </mfrac>
       </mstyle>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>i</ci>
       <apply>
        <divide></divide>
        <ci>k</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{k}=p(e^{2\pi i\tfrac{k}{2^{n}}})
  </annotation>
 </semantics>
</math>

 of the Fourier transform, for <em>m</em>=0, the covered indices are <em>k</em>=<em>0</em>, 2<sup><em>k</em></sup>, 2∙2<sup><em>s</em></sup>, 3∙2<sup><em>s</em></sup>,…, (2<sup><em>n</em>-<em>s</em></sup>-1)∙2<sup><em>s</em></sup>, for <em>m</em>&gt;<em>0</em> the covered indices are <em>k</em>=<em>m</em>, 2<sup><em>s</em>+1</sup>-<em>m</em>, 2<sup><em>s</em>+1</sup>+<em>m</em>, 2∙2<sup><em>s</em>+1</sup>-<em>m</em>, 2∙2<sup><em>s</em>+1</sup>+<em>m</em>, …, 2<sup><em>n</em></sup>-<em>m</em>.</p>

<p>During the transition to the next stage, the polynomial 

<math display="inline" id="Bruun's_FFT_algorithm:32">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mrow>
     <mi>s</mi>
     <mo>,</mo>
     <mi mathvariant="normal">ℓ</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <list>
      <ci>s</ci>
      <ci>normal-ℓ</ci>
     </list>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{s,\ell}(z)
  </annotation>
 </semantics>
</math>

 is reduced to the polynomials 

<math display="inline" id="Bruun's_FFT_algorithm:33">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mrow>
     <mrow>
      <mi>s</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">ℓ</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <list>
      <apply>
       <plus></plus>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-ℓ</ci>
     </list>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{s+1,\ell}(z)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bruun's_FFT_algorithm:34">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mrow>
     <mrow>
      <mi>s</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msup>
       <mn>2</mn>
       <mi>s</mi>
      </msup>
      <mo>-</mo>
      <mi mathvariant="normal">ℓ</mi>
     </mrow>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <list>
      <apply>
       <plus></plus>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>s</ci>
       </apply>
       <ci>normal-ℓ</ci>
      </apply>
     </list>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{s+1,2^{s}-\ell}(z)
  </annotation>
 </semantics>
</math>

 via polynomial division. If one wants to keep the polynomials in increasing index order, this pattern requires an implementation with two arrays. An implementation in place produces a predictable, but highly unordered sequence of indices, for example for <em>N</em>=<em>16</em> the final order of the <em>8</em> linear remainders is (<em>0</em>, <em>4</em>, <em>2</em>, <em>6</em>, <em>1</em>, <em>7</em>, <em>3</em>, <em>5</em>).</p>

<p>At the end of the recursion, for <em>s</em>=<em>n</em>-<em>1</em>, there remain 2<sup><em>n</em>-<em>1</em></sup> linear polynomials encoding two Fourier coefficients <em>X</em><sub><em>0</em></sub> and <em>X</em><sub><em>2</em><sup><em>n</em>-1</sup></sub> for the first and for the any other <em>k</em>th polynomial the coefficients <em>X</em><sub><em>k</em></sub> and <em>X</em><sub>2<sup><em>n</em></sup>-<em>k</em></sub>.</p>

<p>At each recursive stage, all of the polynomials of the common degree <em>4M</em>-<em>1</em> are reduced to two parts of half the degree <em>2M</em>-<em>1</em>. The divisor of this polynomial remainder computation is a quadratic polynomial <em>z</em><sup><em>m</em></sup>, so that all reductions can be reduced to polynomial divisions of cubic by quadratic polynomials. There are <em>N</em>/<em>2</em>=<em>2</em><sup><em>n</em>-<em>1</em></sup> of these small divisions at each stage, leading to an O (<em>N</em> log <em>N</em>) algorithm for the FFT.</p>

<p>Moreover, since all of these polynomials have purely real coefficients (until the very last stage), they automatically exploit the special case where the inputs <em>x</em><sub><em>n</em></sub> are purely real to save roughly a factor of two in computation and storage. One can also take straightforward advantage of the case of real-symmetric data for computing the <a href="discrete_cosine_transform" title="wikilink">discrete cosine transform</a> (Chen and Sorensen, 1992).</p>
<h3 id="generalization-to-arbitrary-radices">Generalization to arbitrary radices</h3>

<p>The Bruun factorization, and thus the Bruun FFT algorithm, was generalized to handle arbitrary <em>even</em> composite lengths, i.e. dividing the polynomial degree by an arbitrary <em>radix</em> (factor), as follows. First, we define a set of polynomials φ<sub><em>N</em>,α</sub>(<em>z</em>) for positive integers <em>N</em> and for α in [0,1) by:</p>

<p>

<math display="block" id="Bruun's_FFT_algorithm:35">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mrow>
     <mi>N</mi>
     <mo>,</mo>
     <mi>α</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mrow>
         <msup>
          <mi>z</mi>
          <mrow>
           <mn>2</mn>
           <mi>N</mi>
          </mrow>
         </msup>
         <mo>-</mo>
         <mrow>
          <mn>2</mn>
          <mrow>
           <mi>cos</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mn>2</mn>
             <mi>π</mi>
             <mi>α</mi>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <msup>
           <mi>z</mi>
           <mi>N</mi>
          </msup>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mn>0</mn>
        </mrow>
        <mo><</mo>
        <mi>α</mi>
        <mo><</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msup>
         <mi>z</mi>
         <mrow>
          <mn>2</mn>
          <mi>N</mi>
         </mrow>
        </msup>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>α</mi>
        </mrow>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <list>
      <ci>N</ci>
      <ci>α</ci>
     </list>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <matrix>
      <matrixrow>
       <apply>
        <plus></plus>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>z</ci>
          <apply>
           <times></times>
           <cn type="integer">2</cn>
           <ci>N</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <apply>
           <cos></cos>
           <apply>
            <times></times>
            <cn type="integer">2</cn>
            <ci>π</ci>
            <ci>α</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>z</ci>
           <ci>N</ci>
          </apply>
         </apply>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <and></and>
        <apply>
         <lt></lt>
         <apply>
          <times></times>
          <mtext>if</mtext>
          <cn type="integer">0</cn>
         </apply>
         <ci>α</ci>
        </apply>
        <apply>
         <lt></lt>
         <share href="#.cmml">
         </share>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <csymbol cd="latexml">absent</csymbol>
      </matrixrow>
      <matrixrow>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>N</ci>
         </apply>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <mtext>if</mtext>
         <ci>α</ci>
        </apply>
        <cn type="integer">0</cn>
       </apply>
      </matrixrow>
     </matrix>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{N,\alpha}(z)=\left\{\begin{matrix}z^{2N}-2\cos(2\pi\alpha)z^{N}+1&\mbox{%
if }0<\alpha<1\\
\\
z^{2N}-1&\mbox{if }\alpha=0\end{matrix}\right.
  </annotation>
 </semantics>
</math>

</p>

<p>Note that all of the polynomials that appear in the Bruun factorization above can be written in this form. The zeroes of these polynomials are 

<math display="inline" id="Bruun's_FFT_algorithm:36">
 <semantics>
  <msup>
   <mi>e</mi>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>π</mi>
     <mi>i</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo>±</mo>
        <mi>α</mi>
       </mrow>
       <mo>+</mo>
       <mi>k</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mi>N</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>e</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>π</ci>
      <ci>i</ci>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="latexml">plus-or-minus</csymbol>
        <ci>α</ci>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{2\pi i(\pm\alpha+k)/N}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Bruun's_FFT_algorithm:37">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=0,1,\dots,N-1
  </annotation>
 </semantics>
</math>

 in the 

<math display="inline" id="Bruun's_FFT_algorithm:38">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>α</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\neq 0
  </annotation>
 </semantics>
</math>

 case, and 

<math display="inline" id="Bruun's_FFT_algorithm:39">
 <semantics>
  <msup>
   <mi>e</mi>
   <mrow>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
      <mi>i</mi>
      <mi>k</mi>
     </mrow>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
    <mi>N</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>e</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>i</ci>
       <ci>k</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{2\pi ik/2N}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Bruun's_FFT_algorithm:40">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>N</mi>
     </mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>N</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=0,1,\dots,2N-1
  </annotation>
 </semantics>
</math>

 in the 

<math display="inline" id="Bruun's_FFT_algorithm:41">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>α</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=0
  </annotation>
 </semantics>
</math>

 case. Hence these polynomials can be recursively factorized for a factor (radix) <em>r</em> via:</p>

<p>

<math display="block" id="Bruun's_FFT_algorithm:42">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ϕ</mi>
     <mrow>
      <mrow>
       <mi>r</mi>
       <mi>M</mi>
      </mrow>
      <mo>,</mo>
      <mi>α</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
         <mrow>
          <mi mathvariant="normal">ℓ</mi>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
         <mrow>
          <mi>r</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </munderover>
        <msub>
         <mi>ϕ</mi>
         <mrow>
          <mi>M</mi>
          <mo>,</mo>
          <mrow>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>α</mi>
             <mo>+</mo>
             <mi mathvariant="normal">ℓ</mi>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
           <mo>/</mo>
           <mi>r</mi>
          </mrow>
         </mrow>
        </msub>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mn>0</mn>
        </mrow>
        <mo><</mo>
        <mi>α</mi>
        <mo>≤</mo>
        <mn>0.5</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd></mtd>
      <mtd></mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
         <mrow>
          <mi mathvariant="normal">ℓ</mi>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
         <mrow>
          <mi>r</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </munderover>
        <msub>
         <mi>ϕ</mi>
         <mrow>
          <mi>M</mi>
          <mo>,</mo>
          <mrow>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mrow>
              <mn>1</mn>
              <mo>-</mo>
              <mi>α</mi>
             </mrow>
             <mo>+</mo>
             <mi mathvariant="normal">ℓ</mi>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
           <mo>/</mo>
           <mi>r</mi>
          </mrow>
         </mrow>
        </msub>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mn>0.5</mn>
        </mrow>
        <mo><</mo>
        <mi>α</mi>
        <mo><</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd></mtd>
      <mtd></mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
         <mrow>
          <mi mathvariant="normal">ℓ</mi>
          <mo>=</mo>
          <mn>0</mn>
         </mrow>
         <mrow>
          <mi>r</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </munderover>
        <msub>
         <mi>ϕ</mi>
         <mrow>
          <mi>M</mi>
          <mo>,</mo>
          <mrow>
           <mi mathvariant="normal">ℓ</mi>
           <mo>/</mo>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mn>2</mn>
             <mi>r</mi>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
        </msub>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>α</mi>
        </mrow>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mi></mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <list>
       <apply>
        <times></times>
        <ci>r</ci>
        <ci>M</ci>
       </apply>
       <ci>α</ci>
      </list>
     </apply>
     <ci>z</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <matrix>
      <matrixrow>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <csymbol cd="latexml">product</csymbol>
          <apply>
           <eq></eq>
           <ci>normal-ℓ</ci>
           <cn type="integer">0</cn>
          </apply>
         </apply>
         <apply>
          <minus></minus>
          <ci>r</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ϕ</ci>
         <list>
          <ci>M</ci>
          <apply>
           <divide></divide>
           <apply>
            <plus></plus>
            <ci>α</ci>
            <ci>normal-ℓ</ci>
           </apply>
           <ci>r</ci>
          </apply>
         </list>
        </apply>
       </apply>
       <apply>
        <and></and>
        <apply>
         <lt></lt>
         <apply>
          <times></times>
          <mtext>if</mtext>
          <cn type="integer">0</cn>
         </apply>
         <ci>α</ci>
        </apply>
        <apply>
         <leq></leq>
         <share href="#.cmml">
         </share>
         <cn type="float">0.5</cn>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
      </matrixrow>
      <matrixrow>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <csymbol cd="latexml">product</csymbol>
          <apply>
           <eq></eq>
           <ci>normal-ℓ</ci>
           <cn type="integer">0</cn>
          </apply>
         </apply>
         <apply>
          <minus></minus>
          <ci>r</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ϕ</ci>
         <list>
          <ci>M</ci>
          <apply>
           <divide></divide>
           <apply>
            <plus></plus>
            <apply>
             <minus></minus>
             <cn type="integer">1</cn>
             <ci>α</ci>
            </apply>
            <ci>normal-ℓ</ci>
           </apply>
           <ci>r</ci>
          </apply>
         </list>
        </apply>
       </apply>
       <apply>
        <and></and>
        <apply>
         <lt></lt>
         <apply>
          <times></times>
          <mtext>if</mtext>
          <cn type="float">0.5</cn>
         </apply>
         <ci>α</ci>
        </apply>
        <apply>
         <lt></lt>
         <share href="#.cmml">
         </share>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
       <cerror>
        <csymbol cd="ambiguous">missing-subexpression</csymbol>
       </cerror>
      </matrixrow>
      <matrixrow>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <csymbol cd="latexml">product</csymbol>
          <apply>
           <eq></eq>
           <ci>normal-ℓ</ci>
           <cn type="integer">0</cn>
          </apply>
         </apply>
         <apply>
          <minus></minus>
          <ci>r</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ϕ</ci>
         <list>
          <ci>M</ci>
          <apply>
           <divide></divide>
           <ci>normal-ℓ</ci>
           <apply>
            <times></times>
            <cn type="integer">2</cn>
            <ci>r</ci>
           </apply>
          </apply>
         </list>
        </apply>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <mtext>if</mtext>
         <ci>α</ci>
        </apply>
        <cn type="integer">0</cn>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{rM,\alpha}(z)=\left\{\begin{array}[]{ll}\prod_{\ell=0}^{r-1}\phi_{M,(%
\alpha+\ell)/r}&\mbox{if }0<\alpha\leq 0.5\\
\\
\prod_{\ell=0}^{r-1}\phi_{M,(1-\alpha+\ell)/r}&\mbox{if }0.5<\alpha<1\\
\\
\prod_{\ell=0}^{r-1}\phi_{M,\ell/(2r)}&\mbox{if }\alpha=0\end{array}\right.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="references">References</h2>
<ul>
<li>Georg Bruun, "<em>z</em>-Transform DFT filters and FFTs," <em><a class="uri" href="IEEE" title="wikilink">IEEE</a> Trans. on Acoustics, Speech and Signal Processing</em> (ASSP) <strong>26</strong> (1), 56-63 (1978).</li>
<li>H. J. Nussbaumer, <em>Fast Fourier Transform and Convolution Algorithms</em> (Springer-Verlag: Berlin, 1990).</li>
<li>Yuhang Wu, "New FFT structures based on the Bruun algorithm," <em>IEEE Trans. ASSP</em> <strong>38</strong> (1), 188-191 (1990)</li>
<li>Jianping Chen and Henrik Sorensen, "An efficient FFT algorithm for real-symmetric data," <em>Proc. ICASSP</em> <strong>5</strong>, 17-20 (1992).</li>
<li>Rainer Storn, "Some results in fixed point error analysis of the Bruun-FTT  algorithm," <em>IEEE Trans. Signal Processing</em> <strong>41</strong> (7), 2371-2375 (1993).</li>
<li>Hideo Murakami, "Real-valued decimation-in-time and decimation-in-frequency algorithms," <em>IEEE Trans. Circuits Syst. II: Analog and Digital Sig. Proc.</em> <strong>41</strong> (12), 808-816 (1994).</li>
<li>Hideo Murakami, "Real-valued fast discrete Fourier transform and cyclic convolution algorithms of highly composite even length," <em>Proc. <a class="uri" href="ICASSP" title="wikilink">ICASSP</a></em> <strong>3</strong>, 1311-1314 (1996).</li>
<li>Shashank Mittal, Md. Zafar Ali Khan, M. B. Srinivas, "A Comparative Study of Different FFT Architectures for Software Defined Radio", <em>Lecture Notes in Computer Science</em> <strong>4599</strong> (<em>Embedded Computer Systems: Architectures, Modeling, and Simulation</em>), 375-384 (2007). Proc. 7th Intl. Workshop, SAMOS 2007 (Samos, Greece, July 16–19, 2007).</li>
</ul>

<p>"</p>

<p><a href="Category:FFT_algorithms" title="wikilink">Category:FFT algorithms</a></p>
</body>
</html>
