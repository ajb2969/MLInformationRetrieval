<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="33">Dirichlet process</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Dirichlet process</h1>
<hr/>

<p> In <a href="probability_theory" title="wikilink">probability theory</a>, <strong>Dirichlet processes</strong> (after <a href="Peter_Gustav_Lejeune_Dirichlet" title="wikilink">Peter Gustav Lejeune Dirichlet</a>) are a family of <a href="stochastic_process" title="wikilink">stochastic processes</a> whose <a href="realization_(probability)" title="wikilink">realizations</a> are <a href="probability_distribution" title="wikilink">probability distributions</a>. In other words, a Dirichlet process is a probability distribution whose domain is itself a set of probability distributions. It is often used in <a href="Bayesian_inference" title="wikilink">Bayesian inference</a> to describe the <a href="prior_probability" title="wikilink">prior</a> knowledge about the distribution of <a href="random_variable" title="wikilink">random variables</a>, that is, how likely it is that the random variables are distributed according to one or another particular distribution.</p>

<p>The Dirichlet process is specified by a base distribution 

<math display="inline" id="Dirichlet_process:0">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 and a positive <a href="real_number" title="wikilink">real number</a> 

<math display="inline" id="Dirichlet_process:1">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 called the <a href="concentration_parameter" title="wikilink">concentration parameter</a>. The base distribution is the <a href="expected_value" title="wikilink">expected value</a> of the process, that is, the Dirichlet process draws distributions "around" the base distribution in the way that a <a href="normal_distribution" title="wikilink">normal distribution</a> draws real numbers around its mean. However, even if the base distribution is <a href="continuous_distribution" title="wikilink">continuous</a>, the distributions drawn from the Dirichlet process are <a href="almost_surely" title="wikilink">almost surely</a> <a href="discrete_distribution" title="wikilink">discrete</a>. The concentration parameter specifies how strong this discretization is: in the limit of 

<math display="inline" id="Dirichlet_process:2">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>→</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>α</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\rightarrow 0
  </annotation>
 </semantics>
</math>

, the realizations are all concentrated on a single value, while in the limit of 

<math display="inline" id="Dirichlet_process:3">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>α</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\rightarrow\infty
  </annotation>
 </semantics>
</math>

 the realizations become continuous. In between the two extremes the realizations are discrete distributions with less and less concentration as 

<math display="inline" id="Dirichlet_process:4">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 increases.</p>

<p>The Dirichlet process can also be seen as the infinite-dimensional generalization of the <a href="Dirichlet_distribution" title="wikilink">Dirichlet distribution</a>. In the same way as the Dirichlet distribution is the <a href="conjugate_prior" title="wikilink">conjugate prior</a> for the <a href="categorical_distribution" title="wikilink">categorical distribution</a>, the Dirichlet process is the conjugate prior for infinite, <a href="nonparametric_statistics" title="wikilink">nonparametric</a> discrete distributions. A particularly important application of Dirichlet processes is as a <a href="prior_probability" title="wikilink">prior probability</a> distribution in <a href="infinite_mixture_model" title="wikilink">infinite mixture models</a>.</p>

<p>The Dirichlet process was formally introduced by Thomas Ferguson in 1973<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and has since been applied in <a href="data_mining" title="wikilink">data mining</a> and <a href="machine_learning" title="wikilink">machine learning</a>, among others for <a href="natural_language_processing" title="wikilink">natural language processing</a>, <a href="computer_vision" title="wikilink">computer vision</a> and <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a>.</p>
<h2 id="introduction">Introduction</h2>

<p>Dirichlet processes are usually used when modeling data that tends to repeat previous values in a "<a href="The_rich_get_richer_(statistics)" title="wikilink">rich get richer</a>" fashion. Specifically, suppose that the generation of values 

<math display="inline" id="Dirichlet_process:5">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1},X_{2},\dots
  </annotation>
 </semantics>
</math>

 can be simulated by the following algorithm.</p>
<dl>
<dd><strong>Input:</strong> 

<math display="inline" id="Dirichlet_process:6">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 (a probability distribution called base distribution), 

<math display="inline" id="Dirichlet_process:7">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 (a positive real number called concentration parameter)
</dd>
</dl>
<ol>
<li>Draw 

<math display="inline" id="Dirichlet_process:8">
 <semantics>
  <msub>
   <mi>X</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1}
  </annotation>
 </semantics>
</math>

 from the distribution 

<math display="inline" id="Dirichlet_process:9">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

.</li>
<li>For 

<math display="inline" id="Dirichlet_process:10">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>></mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n>1
  </annotation>
 </semantics>
</math>

:
<ol>
<li>With probability 

<math display="inline" id="Dirichlet_process:11">
 <semantics>
  <mfrac>
   <mi>α</mi>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mo>+</mo>
     <mi>n</mi>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>α</ci>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <ci>α</ci>
      <ci>n</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\alpha}{\alpha+n-1}
  </annotation>
 </semantics>
</math>

 draw 

<math display="inline" id="Dirichlet_process:12">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{n}
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Dirichlet_process:13">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

.</li>
<li>With probability 

<math display="inline" id="Dirichlet_process:14">
 <semantics>
  <mfrac>
   <msub>
    <mi>n</mi>
    <mi>x</mi>
   </msub>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mo>+</mo>
     <mi>n</mi>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <ci>α</ci>
      <ci>n</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{n_{x}}{\alpha+n-1}
  </annotation>
 </semantics>
</math>

 set 

<math display="inline" id="Dirichlet_process:15">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>n</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{n}=x
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Dirichlet_process:16">
 <semantics>
  <msub>
   <mi>n</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{x}
  </annotation>
 </semantics>
</math>

 is the number of previous observations 

<math display="inline" id="Dirichlet_process:17">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1},X_{2},\dots
  </annotation>
 </semantics>
</math>

.</li>
</ol></li>
</ol>

<p>At the same time, another common model for data is that the observations 

<math display="inline" id="Dirichlet_process:18">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 are assumed to be <a href="independent_and_identically_distributed_random_variables" title="wikilink">independent and identically distributed</a> (i.i.d.) according to some distribution 

<math display="inline" id="Dirichlet_process:19">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1},X_{2},\dots
  </annotation>
 </semantics>
</math>

. The goal in introducing Dirichlet processes is to be able to describe the procedure outlined above in this i.i.d. model.</p>

<p>The 

<math display="inline" id="Dirichlet_process:20">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 observations are not <a href="independence_(probability_theory)" title="wikilink">independent</a>, since we have to consider the previous results when generating the next value. They are, however, <a href="exchangeable_random_variables" title="wikilink">exchangeable</a>. This fact can be shown by calculating the joint probability distribution of the observations and noticing that the resulting formula only depends on which 

<math display="inline" id="Dirichlet_process:21">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1},X_{2},\dots
  </annotation>
 </semantics>
</math>

 values occur among the observations and how many repetitions they each have. Because of this exchangeability, <a href="de_Finetti's_theorem" title="wikilink">de Finetti's representation theorem</a> applies and it implies that the observations 

<math display="inline" id="Dirichlet_process:22">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 are <a href="conditional_independence" title="wikilink">conditionally independent</a> given a (latent) distribution 

<math display="inline" id="Dirichlet_process:23">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

. This 

<math display="inline" id="Dirichlet_process:24">
 <semantics>
  <mi>DP</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>DP</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{DP}
  </annotation>
 </semantics>
</math>

 is a random variable itself and has a distribution. This distribution (over distributions) is called Dirichlet process (

<math display="inline" id="Dirichlet_process:25">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

). In summary, this means that we get an equivalent procedure to the above algorithm:</p>
<ol>
<li>Draw a distribution 

<math display="inline" id="Dirichlet_process:26">
 <semantics>
  <mrow>
   <mi>DP</mi>
   <mrow>
    <mo>(</mo>
    <mi>H</mi>
    <mo>,</mo>
    <mi>α</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>DP</ci>
    <interval closure="open">
     <ci>H</ci>
     <ci>α</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{DP}\left(H,\alpha\right)
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Dirichlet_process:27">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1},X_{2}\dots
  </annotation>
 </semantics>
</math>

</li>
<li>Draw observations 

<math display="inline" id="Dirichlet_process:28">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 independently from 

<math display="inline" id="Dirichlet_process:29">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>In practice, however, drawing a concrete distribution 

<math display="inline" id="Dirichlet_process:30">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is impossible, since its specification requires an infinite amount of information. This is a common phenomenon in the context of Bayesian <a href="non-parametric_statistics" title="wikilink">non-parametric statistics</a> where a typical task is to learn distributions on function spaces, which involve effectively infinitely many parameters. The key insight is that in many applications the infinite dimensional distributions appear only as an intermediary computational device and are not required for either the initial specification of prior beliefs or for the statement of the final inference. The Dirichlet process can be used to circumvent infinite computational requirements as described above.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>Given a <a href="measurable_set" title="wikilink">measurable set</a> <em>S</em>, a base probability distribution <em>H</em> and a positive <a href="real_number" title="wikilink">real number</a> 

<math display="inline" id="Dirichlet_process:31">
 <semantics>
  <mrow>
   <mi>DP</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo>,</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>DP</ci>
    <interval closure="open">
     <ci>H</ci>
     <ci>α</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{DP}(H,\alpha)
  </annotation>
 </semantics>
</math>

, the Dirichlet process 

<math display="inline" id="Dirichlet_process:32">
 <semantics>
  <msubsup>
   <mrow>
    <mo>{</mo>
    <msub>
     <mi>B</mi>
     <mi>i</mi>
    </msub>
    <mo>}</mo>
   </mrow>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>i</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{B_{i}\right\}_{i=1}^{n}
  </annotation>
 </semantics>
</math>

 is a <a href="stochastic_process" title="wikilink">stochastic process</a> whose <a href="sample_path" title="wikilink">sample path</a> (or <a href="realization_(probability)" title="wikilink">realization</a>, i.e. an infinite set of <a href="random_variate" title="wikilink">random variates</a> drawn from the process) is a probability distribution over <em>S</em> and the following holds. For any measureable finite <a href="partition_of_a_set" title="wikilink">partition</a> of <em>S</em>, say 

<math display="block" id="Dirichlet_process:33">
 <semantics>
  <mrow>
   <mrow>
    <mtext>if</mtext>
    <mi>X</mi>
   </mrow>
   <mo>∼</mo>
   <mrow>
    <mi>DP</mi>
    <mrow>
     <mo>(</mo>
     <mi>H</mi>
     <mo>,</mo>
     <mi>α</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <times></times>
     <mtext>if</mtext>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <ci>DP</ci>
     <interval closure="open">
      <ci>H</ci>
      <ci>α</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{if }X\sim\mathrm{DP}\left(H,\alpha\right)
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Dirichlet_process:34">
 <semantics>
  <mrow>
   <mrow>
    <mtext>then</mtext>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo>(</mo>
       <msub>
        <mi>B</mi>
        <mn>1</mn>
       </msub>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo>(</mo>
       <msub>
        <mi>B</mi>
        <mi>n</mi>
       </msub>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>∼</mo>
   <mrow>
    <mi>Dir</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>α</mi>
      <mi>H</mi>
      <mrow>
       <mo>(</mo>
       <msub>
        <mi>B</mi>
        <mn>1</mn>
       </msub>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mi>α</mi>
      <mi>H</mi>
      <mrow>
       <mo>(</mo>
       <msub>
        <mi>B</mi>
        <mi>n</mi>
       </msub>
       <mo>)</mo>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <times></times>
     <mtext>then</mtext>
     <vector>
      <apply>
       <times></times>
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <ci>X</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>Dir</ci>
     <vector>
      <apply>
       <times></times>
       <ci>α</ci>
       <ci>H</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <ci>α</ci>
       <ci>H</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{then }\left(X\left(B_{1}\right),\dots,X\left(B_{n}\right)\right)\sim%
\mathrm{Dir}\left(\alpha H\left(B_{1}\right),\dots,\alpha H\left(B_{n}\right)\right)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Dirichlet_process:35">
 <semantics>
  <mi>Dir</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Dir</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Dir}
  </annotation>
 </semantics>
</math>

,</p>

<p>where 

<math display="inline" id="Dirichlet_process:36">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>∼</mo>
   <mrow>
    <mi>DP</mi>
    <mrow>
     <mo>(</mo>
     <mi>H</mi>
     <mo>,</mo>
     <mi>α</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <ci>X</ci>
    <apply>
     <times></times>
     <ci>DP</ci>
     <interval closure="open">
      <ci>H</ci>
      <ci>α</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\sim\mathrm{DP}\left(H,\alpha\right)
  </annotation>
 </semantics>
</math>

 denotes the <a href="Dirichlet_distribution" title="wikilink">Dirichlet distribution</a> and the notation 

<math display="inline" id="Dirichlet_process:37">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 means that the random variable 

<math display="inline" id="Dirichlet_process:38">
 <semantics>
  <mrow>
   <mi>DP</mi>
   <mrow>
    <mo>(</mo>
    <mi>H</mi>
    <mo>,</mo>
    <mi>α</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>DP</ci>
    <interval closure="open">
     <ci>H</ci>
     <ci>α</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{DP}\left(H,\alpha\right)
  </annotation>
 </semantics>
</math>

 is distributed according to the distribution 

<math display="inline" id="Dirichlet_process:39">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

, i.e. according to the Dirichlet process with parameter base distribution 

<math display="inline" id="Dirichlet_process:40">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 and the real number 

<math display="inline" id="Dirichlet_process:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo>(</mo>
     <mi>x</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>β</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>δ</mi>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
     </msub>
     <mrow>
      <mo>(</mo>
      <mi>x</mi>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>δ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\left(x\right)=\sum_{k=1}^{\infty}\beta_{k}\delta_{x_{k}}\left(x\right)
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="alternative-views">Alternative views</h2>

<p>There are several equivalent views of the Dirichlet process. Besides the definition above, the Dirichlet process can be defined implicitly through de Finetti's theorem as described in the first section; this is often called the <a href="Chinese_restaurant_process" title="wikilink">Chinese restaurant process</a>. A third alternative is the <a href="stick-breaking_process" title="wikilink">stick-breaking process</a>, which defines the Dirichlet process constructively by writing a distribution sampled from the process as 

<math display="inline" id="Dirichlet_process:42">
 <semantics>
  <msubsup>
   <mrow>
    <mo>{</mo>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mo>}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi mathvariant="normal">∞</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{x_{k}\right\}_{k=1}^{\infty}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Dirichlet_process:43">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 are samples from the base distribution 

<math display="inline" id="Dirichlet_process:44">
 <semantics>
  <msub>
   <mi>δ</mi>
   <msub>
    <mi>x</mi>
    <mi>k</mi>
   </msub>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>δ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{x_{k}}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Dirichlet_process:45">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}
  </annotation>
 </semantics>
</math>

 is an <a href="indicator_function" title="wikilink">indicator function</a> centered on 

<math display="inline" id="Dirichlet_process:46">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>δ</mi>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{x_{k}}(x_{k})=1
  </annotation>
 </semantics>
</math>

 (zero everywhere except for 

<math display="inline" id="Dirichlet_process:47">
 <semantics>
  <msub>
   <mi>β</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k}
  </annotation>
 </semantics>
</math>

) and the 

<math display="inline" id="Dirichlet_process:48">
 <semantics>
  <mrow>
   <mi>Beta</mi>
   <mrow>
    <mo>(</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi>α</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Beta</ci>
    <interval closure="open">
     <cn type="integer">1</cn>
     <ci>α</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Beta}\left(1,\alpha\right)
  </annotation>
 </semantics>
</math>

 are defined by a recursive scheme that repeatedly samples from the <a href="beta_distribution" title="wikilink">beta distribution</a> 

<math display="inline" id="Dirichlet_process:49">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>μ</mi>
     <mi>k</mi>
    </msub>
    <mo>,</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mn>4</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">4</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N(\mu_{k},1/4)
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="use-in-dirichlet-mixture-models">Use in Dirichlet mixture models</h2>
<figure><b>(Figure)</b>
<figcaption>Simulation of 1000 observations drawn from a Dirichlet mixture model. Each observation within a cluster is drawn independently from the <a href="multivariate_normal_distribution" title="wikilink">multivariate normal distribution</a> 

<math display="inline" id="Dirichlet_process:50">
 <semantics>
  <msub>
   <mi>μ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>μ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{k}
  </annotation>
 </semantics>
</math>

. The cluster means 

<math display="inline" id="Dirichlet_process:51">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>=</mo>
   <mn>0.5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>α</ci>
    <cn type="float">0.5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=0.5
  </annotation>
 </semantics>
</math>

 are drawn from a distribution G which itself is drawn from a Dirichlet process with concentration parameter 

<math display="inline" id="Dirichlet_process:52">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mn>16</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <interval closure="open">
      <cn type="integer">2</cn>
      <cn type="integer">16</cn>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=N(2,16)
  </annotation>
 </semantics>
</math>

 and base distribution 

<math display="inline" id="Dirichlet_process:53">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo>∼</mo>
   <mrow>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>μ</mi>
      <mi>k</mi>
     </msub>
     <mo>,</mo>
     <msup>
      <mi>σ</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>N</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>σ</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}\sim N(\mu_{k},\sigma^{2})
  </annotation>
 </semantics>
</math>

. Each row is a new simulation.</figcaption>
</figure>

<p>To understand what Dirichlet processes are and the problem they solve we consider the example of <a href="data_clustering" title="wikilink">data clustering</a>. It is a common situation that data points are assumed to be distributed in a hierarchical fashion where each data point belongs to a (randomly chosen) cluster and the members of a cluster are further distributed randomly within that cluster.</p>
<h3 id="example-1">Example 1</h3>

<p>For example, we might be interested in how people will vote on a number of questions in an upcoming election. A reasonable model for this situation might be to classify each voter as a liberal, a conservative or a moderate and then model the event that a voter says “Yes” to any particular question as a <a href="Bernoulli_distribution" title="wikilink">Bernoulli random variable</a> with probability dependent on which political cluster they belong to. By looking at how votes were cast in previous years on similar pieces of legislation one could fit a predictive model using a simple clustering algorithm such as <a href="k-means_clustering" title="wikilink">k-means</a>. That algorithm, however, requires knowing in advance the number of clusters that generated the data. In many situations it is not possible to determine this ahead of time, and even when we can reasonably assume a number of clusters we would still like to be able to check this assumption. For example, in the voting example above the division into liberal, conservative and moderate might not be finely tuned enough; attributes such as a religion, class or race could also be critical for modeling voter behavior.</p>
<h3 id="example-2">Example 2</h3>

<p>As another example, we might be interested in modeling the velocities of galaxies using a simple model assuming that the velocities are clustered, for instance by assuming each velocity is distributed according to the <a href="normal_distribution" title="wikilink">normal distribution</a> 

<math display="inline" id="Dirichlet_process:54">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, where the 

<math display="inline" id="Dirichlet_process:55">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

th observation belongs to the 

<math display="inline" id="Dirichlet_process:56">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

th cluster of galaxies with common expected velocity. In this case it is far from obvious how to determine a priori how many clusters (of common velocities) there should be and any model for this would be highly suspect and should be checked against the data. By using a Dirichlet process prior for the distribution of cluster means we circumvent the need to explicitly specify ahead of time how many clusters there are, although the concentration parameter still controls it implicitly.</p>

<p>We consider this example in more detail. A first naive model is to presuppose that there are 

<math display="inline" id="Dirichlet_process:57">
 <semantics>
  <msup>
   <mi>σ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}
  </annotation>
 </semantics>
</math>

 clusters of normally distributed velocities with common known fixed <a class="uri" href="variance" title="wikilink">variance</a> 

<math display="inline" id="Dirichlet_process:58">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

. Denoting the event that the 

<math display="inline" id="Dirichlet_process:59">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

th observation is in the 

<math display="inline" id="Dirichlet_process:60">
 <semantics>
  <mrow>
   <msub>
    <mi>z</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <ci>i</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{i}=k
  </annotation>
 </semantics>
</math>

th cluster as 

<math display="inline" id="Dirichlet_process:61">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo>∣</mo>
   <msub>
    <mi>z</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mi>k</mi>
   <mo>,</mo>
   <msub>
    <mi>μ</mi>
    <mi>k</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">k</csymbol>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <ci>k</ci>
    </apply>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle(v_{i}\mid z_{i}=k,\mu_{k})
  </annotation>
 </semantics>
</math>


 we can write this model as:</p>

<p>

<math display="inline" id="Dirichlet_process:62">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

</p>

<p>That is, we assume that the data belongs to 

<math display="inline" id="Dirichlet_process:63">
 <semantics>
  <msub>
   <mi>μ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>μ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{k}
  </annotation>
 </semantics>
</math>

 distinct clusters with means 

<math display="inline" id="Dirichlet_process:64">
 <semantics>
  <msub>
   <mi>π</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{k}
  </annotation>
 </semantics>
</math>

 and that 

<math display="inline" id="Dirichlet_process:65">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is the (unknown) prior probability of a data point belonging to the 

<math display="inline" id="Dirichlet_process:66">
 <semantics>
  <mrow>
   <mi>Dir</mi>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mrow>
      <mi>α</mi>
      <mo>/</mo>
      <mi>K</mi>
     </mrow>
     <mo>⋅</mo>
     <msub>
      <mn>𝟏</mn>
      <mi>K</mi>
     </msub>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Dir</ci>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <divide></divide>
      <ci>α</ci>
      <ci>K</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">1</cn>
      <ci>K</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Dir}\left(\alpha/K\cdot\mathbf{1}_{K}\right)
  </annotation>
 </semantics>
</math>

th cluster. We assume that we have no initial information distinguishing the clusters, which is captured by the symmetric prior 

<math display="inline" id="Dirichlet_process:67">
 <semantics>
  <mi>Dir</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Dir</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Dir}
  </annotation>
 </semantics>
</math>

. Here 

<math display="inline" id="Dirichlet_process:68">
 <semantics>
  <msub>
   <mn>𝟏</mn>
   <mi>K</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <cn type="integer">1</cn>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{1}_{K}
  </annotation>
 </semantics>
</math>

 denotes the <a href="Dirichlet_distribution" title="wikilink">Dirichlet distribution</a> and 

<math display="inline" id="Dirichlet_process:69">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 denotes a vector of length 

<math display="inline" id="Dirichlet_process:70">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(\lambda)
  </annotation>
 </semantics>
</math>

 where each element is 1. We further assign independent and identical prior distributions 

<math display="inline" id="Dirichlet_process:71">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 to each of the cluster means, where 

<math display="inline" id="Dirichlet_process:72">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 may be any parametric distribution with parameters denoted as 

<math display="inline" id="Dirichlet_process:73">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

. The hyper-parameters 

<math display="inline" id="Dirichlet_process:74">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dirichlet_process:75">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo>∣</mo>
   <msub>
    <mover accent="true">
     <mi>μ</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>μ</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle(v_{i}\mid\tilde{\mu}_{i})
  </annotation>
 </semantics>
</math>


 are taken to be known fixed constants, chosen to reflect our prior beliefs about the system. To understand the connection to Dirichlet process priors we rewrite this model in an equivalent but more suggestive form:</p>

<p>

<math display="inline" id="Dirichlet_process:76">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>μ</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-~</ci>
     <ci>μ</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{\mu}_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>Instead of imagining that each data point is first assigned a cluster and then drawn from the distribution associated to that cluster we now think of each observation being associated with parameter 

<math display="inline" id="Dirichlet_process:77">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 drawn from some discrete distribution 

<math display="inline" id="Dirichlet_process:78">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 with support on the 

<math display="inline" id="Dirichlet_process:79">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>μ</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-~</ci>
     <ci>μ</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{\mu}_{i}
  </annotation>
 </semantics>
</math>

 means. That is, we are now treating the 

<math display="inline" id="Dirichlet_process:80">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 as being drawn from the random distribution 

<math display="inline" id="Dirichlet_process:81">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 and our prior information is incorporated into the model by the distribution over distributions 

<math display="inline" id="Dirichlet_process:82">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

.</p>

<p>We would now like to extend this model to work without pre-specifying a fixed number of clusters 

<math display="inline" id="Dirichlet_process:83">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mover accent="true">
       <mi>μ</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>π</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>δ</mi>
      <msub>
       <mi>μ</mi>
       <mi>k</mi>
      </msub>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mover accent="true">
        <mi>μ</mi>
        <mo stretchy="false">~</mo>
       </mover>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-~</ci>
       <ci>μ</ci>
      </apply>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>δ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>μ</ci>
       </apply>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(\tilde{\mu}_{i})=\sum_{k=1}^{\infty}\pi_{k}\delta_{\mu_{k}}(\tilde{\mu}_{i})
  </annotation>
 </semantics>
</math>

. Mathematically, this means we would like to select a random prior distribution 

<math display="inline" id="Dirichlet_process:84">
 <semantics>
  <msub>
   <mi>μ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>μ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{k}
  </annotation>
 </semantics>
</math>

 where the values of the clusters means 

<math display="inline" id="Dirichlet_process:85">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo>(</mo>
    <mi>λ</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H\left(\lambda\right)
  </annotation>
 </semantics>
</math>

 are again independently distributed according to 

<math display="inline" id="Dirichlet_process:86">
 <semantics>
  <msub>
   <mi>π</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{k}
  </annotation>
 </semantics>
</math>

 and the distribution over 

<math display="inline" id="Dirichlet_process:87">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo>∣</mo>
   <msub>
    <mover accent="true">
     <mi>μ</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>μ</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle(v_{i}\mid\tilde{\mu}_{i})
  </annotation>
 </semantics>
</math>


 is symmetric over the infinite set of clusters. This is exactly what is accomplished by the model:</p>

<p>

<math display="inline" id="Dirichlet_process:88">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

</p>

<p>With this in hand we can better understand the computational merits of the Dirichlet process. Suppose that we wanted to draw 

<math display="inline" id="Dirichlet_process:89">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 observations from the naive model with exactly 

<math display="inline" id="Dirichlet_process:90">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 clusters. A simple algorithm for doing this would be to draw 

<math display="inline" id="Dirichlet_process:91">
 <semantics>
  <msub>
   <mi>μ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>μ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{k}
  </annotation>
 </semantics>
</math>

 values of 

<math display="inline" id="Dirichlet_process:92">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(\lambda)
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Dirichlet_process:93">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

, a distribution 

<math display="inline" id="Dirichlet_process:94">
 <semantics>
  <mrow>
   <mi>Dir</mi>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mrow>
      <mi>α</mi>
      <mo>/</mo>
      <mi>K</mi>
     </mrow>
     <mo>⋅</mo>
     <msub>
      <mn>𝟏</mn>
      <mi>K</mi>
     </msub>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Dir</ci>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <divide></divide>
      <ci>α</ci>
      <ci>K</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cn type="integer">1</cn>
      <ci>K</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Dir}\left(\alpha/K\cdot\mathbf{1}_{K}\right)
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Dirichlet_process:95">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 and then for each observation independently sample the cluster 

<math display="inline" id="Dirichlet_process:96">
 <semantics>
  <msub>
   <mi>π</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{k}
  </annotation>
 </semantics>
</math>

 with probability 

<math display="inline" id="Dirichlet_process:97">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>μ</mi>
     <mi>k</mi>
    </msub>
    <mo>,</mo>
    <msup>
     <mi>σ</mi>
     <mn>2</mn>
    </msup>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\left(\mu_{k},\sigma^{2}\right)
  </annotation>
 </semantics>
</math>

 and the value of the observation according to 

<math display="inline" id="Dirichlet_process:98">
 <semantics>
  <mi>𝝅</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝝅</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\pi}
  </annotation>
 </semantics>
</math>

. It is easy to see that this algorithm does not work in case where we allow infinite clusters because this would require sampling an infinite dimensional parameter 

<math display="inline" id="Dirichlet_process:99">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

. However, as described above it is still possible to sample observations 

<math display="inline" id="Dirichlet_process:100">
 <semantics>
  <mi>𝝅</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝝅</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\pi}
  </annotation>
 </semantics>
</math>

 using the Chinese Restaurant algorithm, which avoids having to explicitly specify 

<math display="inline" id="Dirichlet_process:101">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 but is still equivalent, as implied by de Finetti's representation theorem.</p>

<p>Fitting the model described above based on observed data 

<math display="inline" id="Dirichlet_process:102">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo>(</mo>
    <mi>𝝅</mi>
    <mo>,</mo>
    <mi>𝝁</mi>
    <mo>∣</mo>
    <mi>D</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">μ</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\left(\boldsymbol{\pi},\boldsymbol{\mu}\mid D\right)
  </annotation>
 </semantics>
</math>

 means finding the <a href="posterior_distribution" title="wikilink">posterior distribution</a> 

<math display="inline" id="Dirichlet_process:103">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 over cluster probabilities and their associated means. In the infinite dimensional case it is obviously impossible to write down the posterior explicitly. It is, however, possible to draw samples from this posterior using a modified <a href="Gibbs_sampler" title="wikilink">Gibbs sampler</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> This is the critical fact that makes the Dirichlet process prior useful for <a href="statistical_inference" title="wikilink">inference</a>.</p>
<h2 id="the-chinese-restaurant-process">The Chinese restaurant process</h2>

<p>As shown above, a simple distribution, the so-called <strong>Chinese restaurant process</strong>, results from considering the conditional distribution of one component assignment given all previous ones in a Dirichlet distribution <a href="mixture_model" title="wikilink">mixture model</a> with 

<math display="inline" id="Dirichlet_process:104">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 components, and then taking the limit as 

<math display="inline" id="Dirichlet_process:105">
 <semantics>
  <mi>J</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>J</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J
  </annotation>
 </semantics>
</math>

 goes to infinity. It can be shown, using the above formal definition of the Dirichlet process and considering the process-centered view, that the conditional distribution of the component assignment of one sample from the process given all previous samples follows a Chinese restaurant process.</p>

<p>Suppose that 

<math display="inline" id="Dirichlet_process:106">
 <semantics>
  <msubsup>
   <mrow>
    <mo>{</mo>
    <msub>
     <mi>θ</mi>
     <mi>j</mi>
    </msub>
    <mo>}</mo>
   </mrow>
   <mrow>
    <mi>j</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>J</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <ci>j</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>j</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>J</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{\theta_{j}\right\}_{j=1}^{J}
  </annotation>
 </semantics>
</math>

 samples, 

<math display="inline" id="Dirichlet_process:107">
 <semantics>
  <msup>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mi>J</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mi>th</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <plus></plus>
     <ci>J</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>th</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(J+1\right)^{\mathrm{th}}
  </annotation>
 </semantics>
</math>

 have already been obtained. According to the Chinese restaurant process, the 

<math display="block" id="Dirichlet_process:108">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mrow>
     <mi>J</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>∼</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mrow>
       <mi>H</mi>
       <mrow>
        <mo>(</mo>
        <mi>S</mi>
        <mo>)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mi>J</mi>
     </mrow>
    </mfrac>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>H</mi>
      <mo>+</mo>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>j</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>J</mi>
       </munderover>
       <msub>
        <mi>δ</mi>
        <msub>
         <mi>θ</mi>
         <mi>j</mi>
        </msub>
       </msub>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <apply>
      <plus></plus>
      <ci>J</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>H</ci>
        <ci>S</ci>
       </apply>
       <ci>J</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <ci>H</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>J</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>δ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>θ</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{J+1}\sim\frac{1}{H\left(S\right)+J}\left(H+\sum_{j=1}^{J}\delta_{%
\theta_{j}}\right)
  </annotation>
 </semantics>
</math>

 sample should be drawn from</p>

<p>

<math display="inline" id="Dirichlet_process:109">
 <semantics>
  <msub>
   <mi>δ</mi>
   <mi>θ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>δ</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{\theta}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Dirichlet_process:110">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

 is an <a href="Dirac_delta_function" title="wikilink">atomic distribution</a> centered on 

<math display="inline" id="Dirichlet_process:111">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

. Interpreting this, two properties are clear:</p>
<ol>
<li>Even if 

<math display="inline" id="Dirichlet_process:112">
 <semantics>
  <mi>J</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>J</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J
  </annotation>
 </semantics>
</math>

 is an <a href="uncountable_set" title="wikilink">uncountable set</a>, there is a finite (i.e. nonzero) probability that two samples will have exactly the same value. Samples from a Dirichlet process are discrete.</li>
<li>The Dirichlet process exhibits a self-reinforcing property; the more often a given value has been sampled in the past, the more likely it is to be sampled again.</li>
</ol>

<p>The name "Chinese restaurant process" is derived from the following analogy: imagine an infinitely large restaurant containing an infinite number of tables, and able to serve an infinite number of dishes. The restaurant in question operates a somewhat unusual seating policy whereby new diners are seated either at a currently occupied table with probability proportional to the number of guests already seated there, or at an empty table with probability proportional to a constant. Guests who sit at an occupied table must order the same dish as those currently seated, whereas guests allocated a new table are served a new dish at random. The distribution of dishes after 

<math display="inline" id="Dirichlet_process:113">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 guests are served is a sample drawn as described above. The Chinese restaurant process is related to the <a href="Pólya_urn_model" title="wikilink">Pólya urn sampling scheme</a> for finite Dirichlet distributions.</p>
<h2 id="the-stick-breaking-process">The stick-breaking process</h2>

<p>A third approach to the Dirichlet process is the so-called stick-breaking process view. Remember that draws from a Dirichlet process are distributions over a set 

<math display="block" id="Dirichlet_process:114">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>θ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mrow>
     <mrow>
      <msub>
       <mi>β</mi>
       <mi>k</mi>
      </msub>
      <mo>⋅</mo>
      <msub>
       <mi>δ</mi>
       <msub>
        <mi>θ</mi>
        <mi>k</mi>
       </msub>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>θ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>θ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>β</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>δ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>θ</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <ci>θ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\theta)=\sum_{k=1}^{\infty}\beta_{k}\cdot\delta_{\theta_{k}}(\theta)
  </annotation>
 </semantics>
</math>

. As noted previously, the distribution drawn is discrete with probability 1. In the stick-breaking process view, we explicitly use the discreteness and give the <a href="probability_mass_function" title="wikilink">probability mass function</a> of this (random) discrete distribution as:</p>

<p>

<math display="inline" id="Dirichlet_process:115">
 <semantics>
  <msub>
   <mi>δ</mi>
   <msub>
    <mi>θ</mi>
    <mi>k</mi>
   </msub>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>δ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{\theta_{k}}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Dirichlet_process:116">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>δ</mi>
     <msub>
      <mi>θ</mi>
      <mi>k</mi>
     </msub>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>θ</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>δ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>θ</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{\theta_{k}}(\theta_{k})=1
  </annotation>
 </semantics>
</math>

 is the <a href="indicator_function" title="wikilink">indicator function</a> which evaluates to zero everywhere, except for 

<math display="inline" id="Dirichlet_process:117">
 <semantics>
  <msubsup>
   <mrow>
    <mo>{</mo>
    <msub>
     <mi>θ</mi>
     <mi>k</mi>
    </msub>
    <mo>}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi mathvariant="normal">∞</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <ci>k</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{\theta_{k}\right\}_{k=1}^{\infty}
  </annotation>
 </semantics>
</math>

. Since this distribution is random itself, its mass function is parameterized by two sets of random variables: the locations 

<math display="inline" id="Dirichlet_process:118">
 <semantics>
  <msubsup>
   <mrow>
    <mo>{</mo>
    <msub>
     <mi>β</mi>
     <mi>k</mi>
    </msub>
    <mo>}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi mathvariant="normal">∞</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>k</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{\beta_{k}\right\}_{k=1}^{\infty}
  </annotation>
 </semantics>
</math>

 and the corresponding probabilities 

<math display="inline" id="Dirichlet_process:119">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{k}
  </annotation>
 </semantics>
</math>

. In the following, we present without proof what these random variables are.</p>

<p>The locations 

<math display="inline" id="Dirichlet_process:120">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 are independent and identically distributed according to 

<math display="inline" id="Dirichlet_process:121">
 <semantics>
  <msub>
   <mi>β</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k}
  </annotation>
 </semantics>
</math>

, the base distribution of the Dirichlet process. The probabilities 

<math display="block" id="Dirichlet_process:122">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>β</mi>
     <mi>k</mi>
     <mo>′</mo>
    </msubsup>
    <mo>⋅</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </munderover>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <msubsup>
        <mi>β</mi>
        <mi>i</mi>
        <mo>′</mo>
       </msubsup>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>β</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>β</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k}=\beta^{\prime}_{k}\cdot\prod_{i=1}^{k-1}\left(1-\beta^{\prime}_{i}\right)
  </annotation>
 </semantics>
</math>

 are given by a procedure resembling the breaking of a unit-length stick (hence the name):</p>

<p>

<math display="inline" id="Dirichlet_process:123">
 <semantics>
  <msubsup>
   <mi>β</mi>
   <mi>k</mi>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>β</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta^{\prime}_{k}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Dirichlet_process:124">
 <semantics>
  <mrow>
   <mi>Beta</mi>
   <mrow>
    <mo>(</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi>α</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Beta</ci>
    <interval closure="open">
     <cn type="integer">1</cn>
     <ci>α</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Beta}\left(1,\alpha\right)
  </annotation>
 </semantics>
</math>

 are independent random variables with the <a href="beta_distribution" title="wikilink">beta distribution</a> 

<math display="inline" id="Dirichlet_process:125">
 <semantics>
  <msub>
   <mi>β</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k}
  </annotation>
 </semantics>
</math>

. The resemblance to 'stick-breaking' can be seen by considering 

<math display="inline" id="Dirichlet_process:126">
 <semantics>
  <msubsup>
   <mi>β</mi>
   <mi>k</mi>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>β</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta^{\prime}_{k}
  </annotation>
 </semantics>
</math>

 as the length of a piece of a stick. We start with a unit-length stick and in each step we break off a portion of the remaining stick according to 

<math display="inline" id="Dirichlet_process:127">
 <semantics>
  <msub>
   <mi>β</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k}
  </annotation>
 </semantics>
</math>

 and assign this broken-off piece to 

<math display="inline" id="Dirichlet_process:128">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">∏</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <msubsup>
      <mi>β</mi>
      <mi>i</mi>
      <mo>′</mo>
     </msubsup>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>β</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \prod_{i=1}^{k-1}\left(1-\beta^{\prime}_{i}\right)
  </annotation>
 </semantics>
</math>

. The formula can be understood by noting that after the first <em>k</em> − 1 values have their portions assigned, the length of the remainder of the stick is 

<math display="inline" id="Dirichlet_process:129">
 <semantics>
  <msubsup>
   <mi>β</mi>
   <mi>k</mi>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>β</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta^{\prime}_{k}
  </annotation>
 </semantics>
</math>

 and this piece is broken according to 

<math display="inline" id="Dirichlet_process:130">
 <semantics>
  <msub>
   <mi>β</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k}
  </annotation>
 </semantics>
</math>

 and gets assigned to 

<math display="inline" id="Dirichlet_process:131">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

.</p>

<p>The smaller 

<math display="inline" id="Dirichlet_process:132">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is, the less of the stick will be left for subsequent values (on average), yielding more concentrated distributions.</p>
<h2 id="the-pólya-urn-scheme">The Pólya urn scheme</h2>

<p>Yet another way to visualize the Dirichlet process and Chinese restaurant process is as a modified <a href="Pólya_urn_model" title="wikilink">Pólya urn scheme</a>. Imagine that we start with an urn filled with 

<math display="inline" id="Dirichlet_process:133">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 black balls. Then we proceed as follows:</p>
<ol>
<li>Each time we need an observation, we draw a ball from the urn.</li>
<li>If the ball is black, we generate a new (non-black) color uniformly, label a new ball this color, drop the new ball into the urn along with the ball we drew, and return the color we generated.</li>
<li>Otherwise, label a new ball with the color of the ball we drew, drop the new ball into the urn along with the ball we drew, and return the color we observed.</li>
</ol>

<p>The resulting distribution over colors is the same as the distribution over tables in the Chinese restaurant process. Furthermore, when we draw a black ball, if rather than generating a new color, we instead pick a random value from a base distribution 

<math display="inline" id="Dirichlet_process:134">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 and use that value to label the new ball, the resulting distribution over labels will be the same as the distribution over values in a Dirichlet process.</p>
<h2 id="applications-of-the-dirichlet-process">Applications of the Dirichlet process</h2>

<p>Dirichlet processes are frequently used in <em>Bayesian <a href="Non-parametric_statistics" title="wikilink">nonparametric statistics</a></em>. "Nonparametric" here does not mean a parameter-less model, rather a model in which representations grow as more data are observed. Bayesian nonparametric models have gained considerable popularity in the field of <a href="machine_learning" title="wikilink">machine learning</a> because of the above-mentioned flexibility, especially in <a href="unsupervised_learning" title="wikilink">unsupervised learning</a>. In a Bayesian nonparametric model, the prior and posterior distributions are not parametric distributions, but stochastic processes.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The fact that the Dirichlet distribution is a probability distribution on the <a class="uri" href="simplex" title="wikilink">simplex</a> of sets of non-negative numbers that sum to one makes it a good candidate to model distributions over distributions or distributions over functions. Additionally, the nonparametric nature of this model makes it an ideal candidate for clustering problems where the distinct number of clusters is unknown beforehand.</p>

<p>As draws from a Dirichlet process are discrete, an important use is as a <a href="prior_probability" title="wikilink">prior probability</a> in <a href="infinite_mixture_model" title="wikilink">infinite mixture models</a>. In this case, <span class="LaTeX">$S$</span> is the parametric set of component distributions. The generative process is therefore that a sample is drawn from a Dirichlet process, and for each data point in turn a value is drawn from this sample distribution and used as the component distribution for that data point. The fact that there is no limit to the number of distinct components which may be generated makes this kind of model appropriate for the case when the number of mixture components is not well-defined in advance. For example, the infinite mixture of Gaussians model.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>The infinite nature of these models also lends them to <a href="natural_language_processing" title="wikilink">natural language processing</a> applications, where it is often desirable to treat the vocabulary as an infinite, discrete set.</p>

<p>The Dirichlet Process can also be used for nonparametric hypothesis testing, i.e. to develop Bayesian nonparametric versions of the classical nonparametric hypothesis tests, e.g. <a href="sign_test" title="wikilink">sign test</a>, <a href="Wilcoxon_rank_sum_test" title="wikilink">Wilcoxon rank sum test</a>, <a href="Wilcoxon_signed-rank_test" title="wikilink">Wilcoxon signed-rank test</a>, etc. For instance, Bayesian nonparametric versions of the Wilcoxon rank sum test and the Wilcoxon signed-rank test have been developed by using the <a href="imprecise_Dirichlet_process" title="wikilink">imprecise Dirichlet process</a>, a prior ignorance Dirichlet process.</p>
<h2 id="related-distributions">Related distributions</h2>
<ul>
<li>The <a href="Pitman–Yor_process" title="wikilink">Pitman–Yor process</a> is a generalization of the Dirichlet process to accommodate power-law tails</li>
<li>The <a href="hierarchical_Dirichlet_process" title="wikilink">hierarchical Dirichlet process</a> extends the ordinary Dirichlet process for modelling grouped data.</li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="https://www.ee.washington.edu/techsite/papers/documents/UWEETR-2010-0006.pdf">Introduction to the Dirichlet Distribution and Related Processes by Frigyik, Kapila and Gupta</a></li>
<li><a href="http://www.gatsby.ucl.ac.uk/~ywteh/research/npbayes/Teh2010a.pdf">Yee Whye Teh's overview of Dirichlet processes</a></li>
<li><a href="http://www.cs.toronto.edu/~beal/npbayes/">Webpage for the NIPS 2003 workshop on non-parametric Bayesian methods</a></li>
<li><a href="http://www.cs.berkeley.edu/~jordan/nips-tutorial05.ps">Michael Jordan's NIPS 2005 tutorial: <em>Nonparametric Bayesian Methods: Dirichlet Processes, Chinese Restaurant Processes and All That</em></a></li>
<li><a href="http://www.maths.bris.ac.uk/~maxvd/cribsheet.pdf">Peter Green's summary of construction of Dirichlet Processes</a></li>
<li><a href="http://www.stats.bris.ac.uk/~peter/papers/GreenCDP.pdf">Peter Green's paper on probabilistic models of Dirichlet Processes with implications for statistical modelling and analysis</a></li>
<li><a href="http://learning.eng.cam.ac.uk/zoubin/talks/uai05tutorial-b.pdf">Zoubin Ghahramani's UAI 2005 tutorial on Nonparametric Bayesian methods</a></li>
<li><a href="http://ClusterAnalysis.org">GIMM software for performing cluster analysis using Infinite Mixture Models</a></li>
<li><a href="http://www.ece.sunysb.edu/~zyweng/dpcluster.html">A Toy Example of Clustering using Dirichlet Process.</a> by Zhiyuan Weng</li>
</ul>

<p>"</p>

<p><a href="Category:Stochastic_processes" title="wikilink">Category:Stochastic processes</a> <a href="Category:Non-parametric_Bayesian_methods" title="wikilink">Category:Non-parametric Bayesian methods</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
