<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1014">List (abstract data type)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>List (abstract data type)</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, a <strong>list</strong> or <strong>sequence</strong> is an <a href="abstract_data_type" title="wikilink">abstract data type</a> that represents an ordered sequence of <a href="value_(computer_science)" title="wikilink">values</a>, where the same value may occur more than once. An instance of a list is a computer representation of the <a href="mathematics" title="wikilink">mathematical</a> concept of a finite <a href="sequence_(mathematics)" title="wikilink">sequence</a>; the (potentially) infinite analog of a list is a <a href="Stream_(computing)" title="wikilink">stream</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Lists are a basic example of <a href="Container_(abstract_data_type)" title="wikilink">containers</a>, as they contain other values. If the same value occurs multiple times, each occurrence is considered a distinct item.</p>

<p> The name <strong>list</strong> is also used for several concrete <a href="data_structures" title="wikilink">data structures</a> that can be used to implement abstract lists, especially <a href="linked_list" title="wikilink">linked lists</a>.</p>

<p>Many <a href="programming_language" title="wikilink">programming languages</a> provide support for <strong>list data types</strong>, and have special syntax and semantics for lists and list operations. A list can often be constructed by writing the items in sequence, separated by <a href="comma" title="wikilink">commas</a>, <a href="semicolon" title="wikilink">semicolons</a>, or <a href="Space_(punctuation)" title="wikilink">spaces</a>, within a pair of delimiters such as <a class="uri" href="parentheses" title="wikilink">parentheses</a> '()', <a class="uri" href="brackets" title="wikilink">brackets</a> '[]', <a href="Braces_(punctuation)" title="wikilink">braces</a> '{}', or <a href="angle_brackets" title="wikilink">angle brackets</a> ''. Some languages may allow list types to be <a href="Array_index" title="wikilink">indexed</a> or <a href="array_slicing" title="wikilink">sliced</a> like <a href="array_data_type" title="wikilink">array types</a>, in which case the data type is more accurately described as an array. In <a href="object-oriented_programming_language" title="wikilink">object-oriented programming languages</a>, lists are usually provided as <a href="instance_(computer_science)" title="wikilink">instances</a> of subclasses of a generic "list" class, and traversed via separate <a href="iterator" title="wikilink">iterators</a>. List data types are often implemented using <a href="array_data_structure" title="wikilink">array data structures</a> or linked lists of some sort, but other <a href="data_structures" title="wikilink">data structures</a> may be more appropriate for some applications. In some contexts, such as in <a href="Lisp_programming_language" title="wikilink">Lisp</a> programming, the term list may refer specifically to a linked list rather than an array.</p>

<p>In <a href="type_theory" title="wikilink">type theory</a> and <a href="functional_programming" title="wikilink">functional programming</a>, abstract lists are usually defined <a href="inductive_type" title="wikilink">inductively</a> by two operations: <em>nil</em> that yields the empty list, and <em>cons</em>, which adds an item at the beginning of a list.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="operations">Operations</h2>

<p>Implementation of the list data structure may provide some of the following <a href="operation_(mathematics)" title="wikilink">operations</a>:</p>
<ul>
<li>a <a href="constructor_(computer_science)" title="wikilink">constructor</a> for creating an empty list;</li>
<li>an operation for testing whether or not a list is empty;</li>
<li>an operation for prepending an entity to a list</li>
<li>an operation for appending an entity to a list</li>
<li>an operation for determining the first component (or the "head") of a list</li>
<li>an operation for referring to the list consisting of all the components of a list except for its first (this is called the "tail" of the list.)</li>
</ul>
<h2 id="implementations">Implementations</h2>

<p>Lists are typically implemented either as <a href="linked_list" title="wikilink">linked lists</a> (either singly or doubly linked) or as <a href="Array_data_structure" title="wikilink">arrays</a>, usually variable length or <a href="dynamic_array" title="wikilink">dynamic arrays</a>.</p>

<p>The standard way of implementing lists, originating with the programming language <a href="Lisp_(programming_language)" title="wikilink">Lisp</a>, is to have each element of the list contain both its value and a pointer indicating the location of the next element in the list. This results in either a <a href="linked_list" title="wikilink">linked list</a> or a <a href="tree_data_structure" title="wikilink">tree</a>, depending on whether the list has nested sublists. Some older Lisp implementations (such as the Lisp implementation of the <a class="uri" href="Symbolics" title="wikilink">Symbolics</a> 3600) also supported "compressed lists" (using <a href="CDR_coding" title="wikilink">CDR coding</a>) which had a special internal representation (invisible to the user). Lists can be manipulated using <a class="uri" href="iteration" title="wikilink">iteration</a> or <a class="uri" href="recursion" title="wikilink">recursion</a>. The former is often preferred in <a href="imperative_programming" title="wikilink">imperative programming languages</a>, while the latter is the norm in <a href="functional_language" title="wikilink">functional languages</a>.</p>

<p>Lists can be implemented as <a href="self-balancing_binary_search_tree" title="wikilink">self-balancing binary search trees</a> holding index-value pairs, providing equal-time access to any element (e.g. all residing in the fringe, and internal nodes storing the right-most child's index, used to guide the search), taking the time logarithmic in the list's size, but as long as it doesn't change much will provide the illusion of <a href="random_access" title="wikilink">random access</a> and enable swap, prefix and append operations in logarithmic time as well.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="programming-language-support">Programming language support</h2>

<p>Some languages do not offer a list <a href="data_structure" title="wikilink">data structure</a>, but offer the use of <a href="associative_array" title="wikilink">associative arrays</a> or some kind of table to emulate lists. For example, <a href="Lua_programming_language" title="wikilink">Lua</a> provides tables. Although Lua stores lists that have numerical indices as arrays internally, they still appear as hash tables.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>In <a href="Lisp_programming_language" title="wikilink">Lisp</a>, lists are the fundamental data type and can represent both program code and data. In most dialects, the list of the first three prime numbers could be written as <code>(list 2 3 5)</code>. In several dialects of Lisp, including <a href="Scheme_(programming_language)" title="wikilink">Scheme</a>, a list is a collection of pairs, consisting of a value and a pointer to the next pair (or null value), making a singly linked list.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="applications">Applications</h2>

<p>As the name implies, lists can be used to store a list of records.</p>

<p>Because in computing, lists are easier to realize than sets, a finite <a href="set_(mathematics)" title="wikilink">set</a> in mathematical sense can be realized as a list with additional restrictions, that is, duplicate elements are disallowed and such that order is irrelevant. If the list is sorted, it speeds up determining if a given item is already in the set but in order to ensure the order, it requires more time to add new entry to the list. In efficient implementations, however, sets are implemented using <a href="self-balancing_binary_search_tree" title="wikilink">self-balancing binary search trees</a> or <a href="hash_table" title="wikilink">hash tables</a>, rather than a list.</p>
<h2 id="abstract-definition">Abstract definition</h2>

<p>The abstract list type <em>L</em> with elements of some type <em>E</em> (a <a href="Type_polymorphism" title="wikilink">monomorphic</a> list) is defined by the following functions:</p>
<dl>
<dd>nil: () → <em>L</em>
</dd>
<dd>cons: <em>E</em> × <em>L</em> → <em>L</em>
</dd>
<dd>first: <em>L</em> → <em>E</em>
</dd>
<dd>rest: <em>L</em> → <em>L</em>
</dd>
</dl>

<p>with the axioms</p>
<dl>
<dd>first (cons (<em>e</em>, <em>l</em>)) = <em>e</em>
</dd>
<dd>rest (cons (<em>e</em>, <em>l</em>)) = <em>l</em>
</dd>
</dl>

<p>for any element <em>e</em> and any list <em>l</em>. It is implicit that</p>
<dl>
<dd>cons (<em>e</em>, <em>l</em>) ≠ <em>l</em>
</dd>
<dd>cons (<em>e</em>, <em>l</em>) ≠ <em>e</em>
</dd>
<dd>cons (<em>e</em><sub>1</sub>, <em>l</em><sub>1</sub>) = cons (<em>e</em><sub>2</sub>, <em>l</em><sub>2</sub>) if <em>e</em><sub>1</sub> = <em>e</em><sub>2</sub> and <em>l</em><sub>1</sub> = <em>l</em><sub>2</sub>
</dd>
</dl>

<p>Note that first (nil ()) and rest (nil ()) are not defined.</p>

<p>These axioms are equivalent to those of the abstract <a href="Stack_(abstract_data_type)" title="wikilink">stack</a> data type.</p>

<p>In <a href="type_theory" title="wikilink">type theory</a>, the above definition is more simply regarded as an <a href="inductive_type" title="wikilink">inductive type</a> defined in terms of constructors: <em>nil</em> and <em>cons</em>. In algebraic terms, this can be represented as the transformation 1 + <em>E</em> × <em>L</em> → <em>L</em>. <em>first</em> and <em>rest</em> are then obtained by <a href="pattern_matching" title="wikilink">pattern matching</a> on the <em>cons</em> constructor and separately handling the <em>nil</em> case.</p>
<h3 id="the-list-monad">The list monad</h3>

<p>The list type forms a <a href="monad_(functional_programming)" title="wikilink">monad</a> with the following functions (using <em>E</em><sup>*</sup> rather than <em>L</em> to represent monomorphic lists with elements of type <em>E</em>):</p>

<p>

<math display="block" id="List_(abstract_data_type):0">
 <semantics>
  <mrow>
   <mtext>return</mtext>
   <mo>:</mo>
   <mrow>
    <mi>A</mi>
    <mo>→</mo>
    <msup>
     <mi>A</mi>
     <mo>*</mo>
    </msup>
    <mo>=</mo>
    <mi>a</mi>
    <mo>↦</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mtext>cons</mtext>
     </mpadded>
     <mpadded width="+1.7pt">
      <mi>a</mi>
     </mpadded>
     <mtext>nil</mtext>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <mtext>return</mtext>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <times></times>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <mtext>cons</mtext>
       <ci>a</ci>
       <mtext>nil</mtext>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{return}\colon A\to A^{*}=a\mapsto\text{cons}\,a\,\text{nil}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="List_(abstract_data_type):1">
 <semantics>
  <mrow>
   <mtext>bind</mtext>
   <mo>:</mo>
   <msup>
    <mi>A</mi>
    <mo>*</mo>
   </msup>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <msup>
     <mi>B</mi>
     <mo>*</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <msup>
    <mi>B</mi>
    <mo>*</mo>
   </msup>
   <mo>=</mo>
   <mi>l</mi>
   <mo>↦</mo>
   <mi>f</mi>
   <mo>↦</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mtext>nil</mtext>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mpadded width="+5pt">
          <mtext>if</mtext>
         </mpadded>
         <mi>l</mi>
        </mrow>
        <mo>=</mo>
        <mtext>nil</mtext>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mpadded width="+1.7pt">
         <mtext>append</mtext>
        </mpadded>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mpadded width="+1.7pt">
           <mi>f</mi>
          </mpadded>
          <mi>a</mi>
         </mrow>
         <mo rspace="4.2pt" stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mpadded width="+1.7pt">
           <mtext>bind</mtext>
          </mpadded>
          <mpadded width="+1.7pt">
           <msup>
            <mi>l</mi>
            <mo>′</mo>
           </msup>
          </mpadded>
          <mi>f</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mpadded width="+5pt">
          <mtext>if</mtext>
         </mpadded>
         <mi>l</mi>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mpadded width="+1.7pt">
          <mtext>cons</mtext>
         </mpadded>
         <mpadded width="+1.7pt">
          <mi>a</mi>
         </mpadded>
         <msup>
          <mi>l</mi>
          <mo>′</mo>
         </msup>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>bind</mtext>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <times></times>
    </apply>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <times></times>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <times></times>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">l</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <mtext>nil</mtext>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>l</ci>
      </apply>
      <mtext>nil</mtext>
     </apply>
     <apply>
      <times></times>
      <mtext>append</mtext>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <mtext>bind</mtext>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>l</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>f</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>l</ci>
      </apply>
      <apply>
       <times></times>
       <mtext>cons</mtext>
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>l</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{bind}\colon A^{*}\to(A\to B^{*})\to B^{*}=l\mapsto f\mapsto\begin{cases}%
\text{nil}&\text{if}\ l=\text{nil}\\
\text{append}\,(f\,a)\,(\text{bind}\,l^{\prime}\,f)&\text{if}\ l=\text{cons}\,%
a\,l^{\prime}\end{cases}
  </annotation>
 </semantics>
</math>

 where <em>append</em> is defined as:</p>

<p>

<math display="block" id="List_(abstract_data_type):2">
 <semantics>
  <mrow>
   <mtext>append</mtext>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mo>*</mo>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>A</mi>
     <mo>*</mo>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>A</mi>
     <mo>*</mo>
    </msup>
    <mo>=</mo>
    <msub>
     <mi>l</mi>
     <mn>1</mn>
    </msub>
    <mo>↦</mo>
    <msub>
     <mi>l</mi>
     <mn>2</mn>
    </msub>
    <mo>↦</mo>
    <mrow>
     <mo>{</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="left">
        <msub>
         <mi>l</mi>
         <mn>2</mn>
        </msub>
       </mtd>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mpadded width="+5pt">
           <mtext>if</mtext>
          </mpadded>
          <msub>
           <mi>l</mi>
           <mn>1</mn>
          </msub>
         </mrow>
         <mo>=</mo>
         <mtext>nil</mtext>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="left">
        <mrow>
         <mpadded width="+1.7pt">
          <mtext>cons</mtext>
         </mpadded>
         <mpadded width="+1.7pt">
          <mi>a</mi>
         </mpadded>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mpadded width="+1.7pt">
            <mtext>append</mtext>
           </mpadded>
           <mpadded width="+1.7pt">
            <msubsup>
             <mi>l</mi>
             <mn>1</mn>
             <mo>′</mo>
            </msubsup>
           </mpadded>
           <msub>
            <mi>l</mi>
            <mn>2</mn>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mtd>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mpadded width="+5pt">
           <mtext>if</mtext>
          </mpadded>
          <msub>
           <mi>l</mi>
           <mn>1</mn>
          </msub>
         </mrow>
         <mo>=</mo>
         <mrow>
          <mpadded width="+1.7pt">
           <mtext>cons</mtext>
          </mpadded>
          <mpadded width="+1.7pt">
           <mi>a</mi>
          </mpadded>
          <msubsup>
           <mi>l</mi>
           <mn>1</mn>
           <mo>′</mo>
          </msubsup>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <mtext>append</mtext>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <times></times>
      </apply>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <times></times>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="latexml">cases</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>l</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <mtext>if</mtext>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>l</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <mtext>nil</mtext>
       </apply>
       <apply>
        <times></times>
        <mtext>cons</mtext>
        <ci>a</ci>
        <apply>
         <times></times>
         <mtext>append</mtext>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>l</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>normal-′</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>l</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <mtext>if</mtext>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>l</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <mtext>cons</mtext>
         <ci>a</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>l</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>normal-′</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{append}\colon A^{*}\to A^{*}\to A^{*}=l_{1}\mapsto l_{2}\mapsto\begin{%
cases}l_{2}&\text{if}\ l_{1}=\text{nil}\\
\text{cons}\,a\,(\text{append}\,l_{1}^{\prime}\,l_{2})&\text{if}\ l_{1}=\text{%
cons}\,a\,l_{1}^{\prime}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>Alternatively, the monad may be defined in terms of operations <em>return</em>, <em>fmap</em> and <em>join</em>, with:</p>

<p>

<math display="block" id="List_(abstract_data_type):3">
 <semantics>
  <mrow>
   <mtext>fmap</mtext>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>A</mi>
     <mo>*</mo>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>B</mi>
     <mo>*</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>f</mi>
   <mo>↦</mo>
   <mi>l</mi>
   <mo>↦</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mtext>nil</mtext>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mpadded width="+5pt">
          <mtext>if</mtext>
         </mpadded>
         <mi>l</mi>
        </mrow>
        <mo>=</mo>
        <mtext>nil</mtext>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mpadded width="+1.7pt">
         <mtext>cons</mtext>
        </mpadded>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mpadded width="+1.7pt">
           <mi>f</mi>
          </mpadded>
          <mi>a</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mtext>fmap</mtext>
          <mpadded width="+1.7pt">
           <mi>f</mi>
          </mpadded>
          <msup>
           <mi>l</mi>
           <mo>′</mo>
          </msup>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mpadded width="+5pt">
          <mtext>if</mtext>
         </mpadded>
         <mi>l</mi>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mpadded width="+1.7pt">
          <mtext>cons</mtext>
         </mpadded>
         <mpadded width="+1.7pt">
          <mi>a</mi>
         </mpadded>
         <msup>
          <mi>l</mi>
          <mo>′</mo>
         </msup>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>fmap</mtext>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <times></times>
     </apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <times></times>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">l</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <mtext>nil</mtext>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>l</ci>
      </apply>
      <mtext>nil</mtext>
     </apply>
     <apply>
      <times></times>
      <mtext>cons</mtext>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <mtext>fmap</mtext>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>l</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>l</ci>
      </apply>
      <apply>
       <times></times>
       <mtext>cons</mtext>
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>l</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{fmap}\colon(A\to B)\to(A^{*}\to B^{*})=f\mapsto l\mapsto\begin{cases}%
\text{nil}&\text{if}\ l=\text{nil}\\
\text{cons}\,(f\,a)(\text{fmap}f\,l^{\prime})&\text{if}\ l=\text{cons}\,a\,l^{%
\prime}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="List_(abstract_data_type):4">
 <semantics>
  <mrow>
   <mtext>join</mtext>
   <mo>:</mo>
   <mrow>
    <mmultiscripts>
     <mi>A</mi>
     <none></none>
     <mo>*</mo>
     <none></none>
     <mo>*</mo>
    </mmultiscripts>
    <mo>→</mo>
    <msup>
     <mi>A</mi>
     <mo>*</mo>
    </msup>
    <mo>=</mo>
    <mi>l</mi>
    <mo>↦</mo>
    <mrow>
     <mo>{</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="left">
        <mtext>nil</mtext>
       </mtd>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mpadded width="+5pt">
           <mtext>if</mtext>
          </mpadded>
          <mi>l</mi>
         </mrow>
         <mo>=</mo>
         <mtext>nil</mtext>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="left">
        <mrow>
         <mpadded width="+1.7pt">
          <mtext>append</mtext>
         </mpadded>
         <mpadded width="+1.7pt">
          <mi>a</mi>
         </mpadded>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mpadded width="+1.7pt">
            <mtext>join</mtext>
           </mpadded>
           <msup>
            <mi>l</mi>
            <mo>′</mo>
           </msup>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mtd>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mpadded width="+5pt">
           <mtext>if</mtext>
          </mpadded>
          <mi>l</mi>
         </mrow>
         <mo>=</mo>
         <mrow>
          <mpadded width="+1.7pt">
           <mtext>cons</mtext>
          </mpadded>
          <mpadded width="+1.7pt">
           <mi>a</mi>
          </mpadded>
          <msup>
           <mi>l</mi>
           <mo>′</mo>
          </msup>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <mtext>join</mtext>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>A</ci>
        <times></times>
       </apply>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <times></times>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <ci>l</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="latexml">cases</csymbol>
       <mtext>nil</mtext>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <mtext>if</mtext>
         <ci>l</ci>
        </apply>
        <mtext>nil</mtext>
       </apply>
       <apply>
        <times></times>
        <mtext>append</mtext>
        <ci>a</ci>
        <apply>
         <times></times>
         <mtext>join</mtext>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>l</ci>
          <ci>normal-′</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <mtext>if</mtext>
         <ci>l</ci>
        </apply>
        <apply>
         <times></times>
         <mtext>cons</mtext>
         <ci>a</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>l</ci>
          <ci>normal-′</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{join}\colon{A^{*}}^{*}\to A^{*}=l\mapsto\begin{cases}\text{nil}&\text{if%
}\ l=\text{nil}\\
\text{append}\,a\,(\text{join}\,l^{\prime})&\text{if}\ l=\text{cons}\,a\,l^{%
\prime}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>Note that <em>fmap</em>, <em>join</em>, <em>append</em> and <em>bind</em> are well-defined, since they're applied to progressively deeper arguments at each recursive call.</p>

<p>The list type is an additive monad, with <em>nil</em> as the monadic zero and <em>append</em> as monadic sum.</p>

<p>Lists form a <a class="uri" href="monoid" title="wikilink">monoid</a> under the <em>append</em> operation. The identity element of the monoid is the empty list, <em>nil</em>. In fact, this is the <a href="free_monoid" title="wikilink">free monoid</a> over the set of list elements.</p>
<h2 id="references">References</h2>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Array_(data_type)" title="wikilink">Array</a></li>
<li><a href="Queue_(data_structure)" title="wikilink">Queue</a></li>
<li><a href="Set_(computer_science)" title="wikilink">Set</a></li>
<li><a href="Stream_(computing)" title="wikilink">Stream</a></li>
</ul>

<p><a href="de:Liste_(Datenstruktur)" title="wikilink">de:Liste (Datenstruktur)</a> <a class="uri" href="pl:Lista" title="wikilink">pl:Lista</a>"</p>

<p><a href="Category:Data_types" title="wikilink">Category:Data types</a> <a href="Category:Composite_data_types" title="wikilink">Category:Composite data types</a> <a href="Category:Abstract_data_types" title="wikilink">Category:Abstract data types</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
