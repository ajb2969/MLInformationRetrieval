<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="848">Multivariate adaptive regression splines</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Multivariate adaptive regression splines</h1>
<hr/>

<p>In <a class="uri" href="statistics" title="wikilink">statistics</a>, <strong>Multivariate adaptive regression splines (MARS)</strong> is a form of <a href="regression_analysis" title="wikilink">regression analysis</a> introduced by <a href="Jerome_H._Friedman" title="wikilink">Jerome H. Friedman</a> in 1991.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It is a <a href="non-parametric_regression" title="wikilink">non-parametric regression</a> technique and can be seen as an extension of <a href="linear_model" title="wikilink">linear models</a> that automatically models non-linearities and interactions between variables.</p>

<p>The term "MARS" is trademarked and licensed to Salford Systems. In order to avoid trademark infringements, many open source implementations of MARS are called "Earth".<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="the-basics">The basics</h2>

<p>This section introduces MARS using a few examples. We start with a set of data: a matrix of input variables <em>x</em>, and a vector of the observed responses <em>y</em>, with a response for each row in <em>x</em>. For example, the data could be:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p><em>x</em></p></th>
<th style="text-align: left;">
<p><em>y</em></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>10.5</p></td>
<td style="text-align: left;">
<p>16.4</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>10.7</p></td>
<td style="text-align: left;">
<p>18.8</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>10.8</p></td>
<td style="text-align: left;">
<p>19.7</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>...</p></td>
<td style="text-align: left;">
<p>...</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>20.6</p></td>
<td style="text-align: left;">
<p>77.0</p></td>
</tr>
</tbody>
</table>

<p>Here there is only one <a href="Dependent_and_independent_variables" title="wikilink">independent variable</a>, so the <em>x</em> matrix is just a single column. Given these measurements, we would like to build a model which predicts the expected <em>y</em> for a given <em>x</em>.</p>

<p> A <a href="linear_model" title="wikilink">linear model</a> for the above data is</p>

<p>

<math display="block" id="Multivariate_adaptive_regression_splines:0">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>y</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mn>37</mn>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>5.1</mn>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-^</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <cn type="integer">37</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="float">5.1</cn>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{y}=-37+5.1x
  </annotation>
 </semantics>
</math>

 The hat on the 

<math display="inline" id="Multivariate_adaptive_regression_splines:1">
 <semantics>
  <mover accent="true">
   <mi>y</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{y}
  </annotation>
 </semantics>
</math>

 indicates that 

<math display="inline" id="Multivariate_adaptive_regression_splines:2">
 <semantics>
  <mover accent="true">
   <mi>y</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{y}
  </annotation>
 </semantics>
</math>

 is estimated from the data. The figure on the right shows a plot of this function: a line giving the predicted 

<math display="inline" id="Multivariate_adaptive_regression_splines:3">
 <semantics>
  <mover accent="true">
   <mi>y</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{y}
  </annotation>
 </semantics>
</math>

 versus <em>x</em>, with the original values of <em>y</em> shown as red dots.</p>

<p>The data at the extremes of <em>x</em> indicates that the relationship between <em>y</em> and <em>x</em> may be non-linear (look at the red dots relative to the regression line at low and high values of <em>x</em>). We thus turn to MARS to automatically build a model taking into account non-linearities. MARS software constructs a model from the given <em>x</em> and <em>y</em> as follows</p>

<p>

<math display="inline" id="Multivariate_adaptive_regression_splines:4">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>y</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-^</ci>
     <ci>y</ci>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\hat{y}=
  </annotation>
 </semantics>
</math>


</p>
<figure><b>(Figure)</b>
<figcaption>A simple MARS model of the same data</figcaption>
</figure>

<p>The figure on the right shows a plot of this function: the predicted 

<math display="inline" id="Multivariate_adaptive_regression_splines:5">
 <semantics>
  <mover accent="true">
   <mi>y</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{y}
  </annotation>
 </semantics>
</math>

 versus <em>x</em>, with the original values of y once again shown as red dots. The predicted response is now a better fit to the original <em>y</em> values.</p>

<p>MARS has automatically produced a kink in the predicted <em>y</em> to take into account non-linearity. The kink is produced by <em>hinge functions</em>. The hinge functions are the expressions starting with 

<math display="inline" id="Multivariate_adaptive_regression_splines:6">
 <semantics>
  <mi>max</mi>
  <annotation-xml encoding="MathML-Content">
   <max></max>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max
  </annotation>
 </semantics>
</math>

 (where 

<math display="inline" id="Multivariate_adaptive_regression_splines:7">
 <semantics>
  <mrow>
   <mi>max</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <max></max>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max(a,b)
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Multivariate_adaptive_regression_splines:8">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Multivariate_adaptive_regression_splines:9">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>></mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a>b
  </annotation>
 </semantics>
</math>

, else 

<math display="inline" id="Multivariate_adaptive_regression_splines:10">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

). Hinge functions are described in more detail below.</p>

<p>In this simple example, we can easily see from the plot that <em>y</em> has a non-linear relationship with <em>x</em> (and might perhaps guess that y varies with the square of <em>x</em>). However, in general there will be multiple <a href="Dependent_and_independent_variables" title="wikilink">independent variables</a>, and the relationship between <em>y</em> and these variables will be unclear and not easily visible by plotting. We can use MARS to discover that non-linear relationship.</p>

<p>An example MARS expression with multiple variables is</p>

<p>

<math display="inline" id="Multivariate_adaptive_regression_splines:11">
 <semantics>
  <mrow>
   <mi>ozone</mi>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ozone</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\mathrm{ozone}=
  </annotation>
 </semantics>
</math>


 </p>

<p>This expression models air pollution (the ozone level) as a function of the temperature and a few other variables. Note that the last term in the formula (on the last line) incorporates an interaction between 

<math display="inline" id="Multivariate_adaptive_regression_splines:12">
 <semantics>
  <mi>wind</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>wind</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{wind}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Multivariate_adaptive_regression_splines:13">
 <semantics>
  <mi>vis</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>vis</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{vis}
  </annotation>
 </semantics>
</math>

.</p>

<p>The figure on the right plots the predicted 

<math display="inline" id="Multivariate_adaptive_regression_splines:14">
 <semantics>
  <mi>ozone</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ozone</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{ozone}
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Multivariate_adaptive_regression_splines:15">
 <semantics>
  <mi>wind</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>wind</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{wind}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Multivariate_adaptive_regression_splines:16">
 <semantics>
  <mi>vis</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>vis</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{vis}
  </annotation>
 </semantics>
</math>

 vary, with the other variables fixed at their median values. The figure shows that wind does not affect the ozone level unless visibility is low. We see that MARS can build quite flexible regression surfaces by combining hinge functions.</p>

<p>To obtain the above expression, the MARS model building procedure automatically selects which variables to use (some variables are important, others not), the positions of the kinks in the hinge functions, and how the hinge functions are combined.</p>
<h2 id="the-mars-model">The MARS model</h2>

<p>MARS builds models of the form</p>

<p>

<math display="block" id="Multivariate_adaptive_regression_splines:17">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>f</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>k</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>B</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>f</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>i</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{f}(x)=\sum_{i=1}^{k}c_{i}B_{i}(x)
  </annotation>
 </semantics>
</math>

.</p>

<p>The model is a weighted sum of basis functions 

<math display="inline" id="Multivariate_adaptive_regression_splines:18">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>i</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{i}(x)
  </annotation>
 </semantics>
</math>

. Each 

<math display="inline" id="Multivariate_adaptive_regression_splines:19">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{i}
  </annotation>
 </semantics>
</math>

 is a constant coefficient. For example, each line in the formula for ozone above is one basis function multiplied by its coefficient.</p>

<p>Each <a href="basis_function" title="wikilink">basis function</a> 

<math display="inline" id="Multivariate_adaptive_regression_splines:20">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>i</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{i}(x)
  </annotation>
 </semantics>
</math>

 takes one of the following three forms:</p>

<p>1) a constant 1. There is just one such term, the intercept. In the ozone formula above, the intercept term is 5.2.</p>

<p>2) a <em>hinge</em> function. A hinge function has the form 

<math display="inline" id="Multivariate_adaptive_regression_splines:21">
 <semantics>
  <mrow>
   <mi>max</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <mrow>
      <mi>c</mi>
      <mi>o</mi>
      <mi>n</mi>
      <mi>s</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <max></max>
    <cn type="integer">0</cn>
    <apply>
     <minus></minus>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>o</ci>
      <ci>n</ci>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max(0,x-const)
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Multivariate_adaptive_regression_splines:22">
 <semantics>
  <mrow>
   <mi>max</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mi>c</mi>
      <mi>o</mi>
      <mi>n</mi>
      <mi>s</mi>
      <mi>t</mi>
     </mrow>
     <mo>-</mo>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <max></max>
    <cn type="integer">0</cn>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>o</ci>
      <ci>n</ci>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max(0,const-x)
  </annotation>
 </semantics>
</math>

. MARS automatically selects variables and values of those variables for knots of the hinge functions. Examples of such basis functions can be seen in the middle three lines of the ozone formula.</p>

<p>3) a product of two or more hinge functions. These basis functions can model interaction between two or more variables. An example is the last line of the ozone formula.</p>
<h2 id="hinge-functions">Hinge functions</h2>
<figure><b>(Figure)</b>
<figcaption>A mirrored pair of hinge functions with a knot at x=3.1</figcaption>
</figure>

<p>Hinge functions are a key part of MARS models. A hinge function takes the form</p>

<p>

<math display="block" id="Multivariate_adaptive_regression_splines:23">
 <semantics>
  <mrow>
   <mi>max</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <mi>c</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <max></max>
    <cn type="integer">0</cn>
    <apply>
     <minus></minus>
     <ci>x</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max(0,x-c)
  </annotation>
 </semantics>
</math>

 or</p>

<p>

<math display="block" id="Multivariate_adaptive_regression_splines:24">
 <semantics>
  <mrow>
   <mi>max</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mrow>
     <mi>c</mi>
     <mo>-</mo>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <max></max>
    <cn type="integer">0</cn>
    <apply>
     <minus></minus>
     <ci>c</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max(0,c-x)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Multivariate_adaptive_regression_splines:25">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 is a constant, called the <em>knot</em>. The figure on the right shows a mirrored pair of hinge functions with a knot at 3.1.</p>

<p>A hinge function is zero for part of its range, so can be used to partition the data into disjoint regions, each of which can be treated independently. Thus for example a mirrored pair of hinge functions in the expression</p>

<p>

<math display="block" id="Multivariate_adaptive_regression_splines:26">
 <semantics>
  <mrow>
   <mrow>
    <mn>6.1</mn>
    <mrow>
     <mi>max</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mn>13</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mn>3.1</mn>
    <mrow>
     <mi>max</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mrow>
       <mn>13</mn>
       <mo>-</mo>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <cn type="float">6.1</cn>
     <apply>
      <max></max>
      <cn type="integer">0</cn>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <cn type="integer">13</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="float">3.1</cn>
     <apply>
      <max></max>
      <cn type="integer">0</cn>
      <apply>
       <minus></minus>
       <cn type="integer">13</cn>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   6.1\max(0,x-13)-3.1\max(0,13-x)
  </annotation>
 </semantics>
</math>

 creates the <a class="uri" href="piecewise" title="wikilink">piecewise</a> linear graph shown for the simple MARS model in the previous section.</p>

<p>One might assume that only piecewise linear functions can be formed from hinge functions, but hinge functions can be multiplied together to form non-linear functions.</p>

<p>Hinge functions are also called <a href="Ice_hockey_stick" title="wikilink">hockey stick</a> or <a href="Rectifier_(neural_networks)" title="wikilink">rectifier</a> functions. Instead of the 

<math display="inline" id="Multivariate_adaptive_regression_splines:27">
 <semantics>
  <mi>max</mi>
  <annotation-xml encoding="MathML-Content">
   <max></max>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max
  </annotation>
 </semantics>
</math>

 notation used in this article, hinge functions are often represented by 

<math display="inline" id="Multivariate_adaptive_regression_splines:28">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo>±</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo>-</mo>
       <mi>c</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>+</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <csymbol cd="latexml">plus-or-minus</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\pm(x_{i}-c)]_{+}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Multivariate_adaptive_regression_splines:29">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mo>⋅</mo>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>+</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>normal-⋅</ci>
    </apply>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\cdot]_{+}
  </annotation>
 </semantics>
</math>

 means take the positive part.</p>
<h2 id="the-model-building-process">The model building process</h2>

<p>MARS builds a model in two phases: the forward and the backward pass. This two-stage approach is the same as that used by <a href="recursive_partitioning" title="wikilink">recursive partitioning</a> trees.</p>
<h3 id="the-forward-pass">The forward pass</h3>

<p>MARS starts with a model which consists of just the intercept term (which is the mean of the response values).</p>

<p>MARS then repeatedly adds basis function in pairs to the model. At each step it finds the pair of basis functions that gives the maximum reduction in sum-of-squares <a href="Errors_and_residuals_in_statistics" title="wikilink">residual</a> error (it is a <a href="greedy_algorithm" title="wikilink">greedy algorithm</a>). The two basis functions in the pair are identical except that a different side of a mirrored hinge function is used for each function. Each new basis function consists of a term already in the model (which could perhaps be the intercept i.e. a constant 1) multiplied by a new hinge function. A hinge function is defined by a variable and a knot, so to add a new basis function, MARS must search over all combinations of the following:</p>

<p>1) existing terms (called <em>parent terms</em> in this context)</p>

<p>2) all variables (to select one for the new basis function)</p>

<p>3) all values of each variable (for the knot of the new hinge function).</p>

<p>This process of adding terms continues until the change in residual error is too small to continue or until the maximum number of terms is reached. The maximum number of terms is specified by the user before model building starts.</p>

<p>The search at each step is done in a <a href="Brute-force_search" title="wikilink">brute force</a> fashion, but a key aspect of MARS is that because of the nature of hinge functions the search can be done relatively quickly using a fast least-squares update technique. Actually, the search is not quite brute force. The search can be sped up with a <a href="Heuristics" title="wikilink">heuristic</a> that reduces the number of parent terms to consider at each step ("Fast MARS" <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a>).</p>
<h3 id="the-backward-pass">The backward pass</h3>

<p>The forward pass usually builds an <a class="uri" href="overfit" title="wikilink">overfit</a> model. (An overfit model has a good fit to the data used to build the model but will not generalize well to new data.) To build a model with better generalization ability, the backward pass prunes the model. It removes terms one by one, deleting the least effective term at each step until it finds the best submodel. Model subsets are compared using the GCV criterion described below.</p>

<p>The backward pass has an advantage over the forward pass: at any step it can choose any term to delete, whereas the forward pass at each step can only see the next pair of terms.</p>

<p>The forward pass adds terms in pairs, but the backward pass typically discards one side of the pair and so terms are often not seen in pairs in the final model. A paired hinge can be seen in the equation for 

<math display="inline" id="Multivariate_adaptive_regression_splines:30">
 <semantics>
  <mover accent="true">
   <mi>y</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{y}
  </annotation>
 </semantics>
</math>


 in the first MARS example above; there are no complete pairs retained in the ozone example.</p>
<h3 id="generalized-cross-validation-gcv">Generalized cross validation (GCV)</h3>

<p>The backward pass uses GCV to compare the performance of model subsets in order to choose the best subset: lower values of GCV are better. The GCV is a form of <a href="Regularization_(machine_learning)" title="wikilink">regularization</a>: it trades off goodness-of-fit against model complexity.</p>

<p>(We want to estimate how well a model performs on <em>new</em> data, not on the training data. Such new data is usually not available at the time of model building, so instead we use GCV to estimate what performance would be on new data. The raw <a href="Residual_sum_of_squares" title="wikilink">residual sum-of-squares</a> (RSS) on the training data is inadequate for comparing models, because the RSS always increases as MARS terms are dropped. In other words, if the RSS were used to compare models, the backward pass would always choose the largest model—but the largest model typically does not have the best generalization performance.)</p>

<p>The formula for the GCV is</p>

<p><strong>GCV = RSS / (N * (1 - EffectiveNumberOfParameters / N)^2)</strong></p>

<p>where <strong>RSS</strong> is the residual sum-of-squares measured on the training data and <strong>N</strong> is the number of observations (the number of rows in the <strong>x</strong> matrix).</p>

<p>The <strong>EffectiveNumberOfParameters</strong> is defined in the MARS context as</p>

<p><strong>EffectiveNumberOfParameters = NumberOfMarsTerms + Penalty * (NumberOfMarsTerms - 1 ) / 2</strong></p>

<p>where <strong>Penalty</strong> is about 2 or 3 (the MARS software allows the user to preset Penalty).</p>

<p>Note that <strong>(NumberOfMarsTerms - 1 ) / 2</strong> is the number of hinge-function knots, so the formula penalizes the addition of knots. Thus the GCV formula adjusts (i.e. increases) the training RSS to take into account the flexibility of the model. We penalize flexibility because models that are too flexible will model the specific realization of noise in the data instead of just the systematic structure of the data.</p>

<p>Generalized Cross Validation is so named because it uses a formula to approximate the error that would be determined by leave-one-out validation. It is just an approximation but works well in practice. GCVs were introduced by Craven and <a href="Grace_Wahba" title="wikilink">Wahba</a> and extended by Friedman for MARS.</p>
<h3 id="constraints">Constraints</h3>

<p>One constraint has already been mentioned: the user can specify the maximum number of terms in the forward pass.</p>

<p>A further constraint can be placed on the forward pass by specifying a maximum allowable degree of interaction. Typically only one or two degrees of interaction are allowed, but higher degrees can be used when the data warrants it. The maximum degree of interaction in the first MARS example above is one (i.e. no interactions or an <em>additive model</em>); in the ozone example it is two.</p>

<p>Other constraints on the forward pass are possible. For example, the user can specify that interactions are allowed only for certain input variables. Such constraints could make sense because of knowledge of the process that generated the data.</p>
<h2 id="pros-and-cons">Pros and cons</h2>

<p>No regression modeling technique is best for all situations. The guidelines below are intended to give an idea of the pros and cons of MARS, but there will be exceptions to the guidelines. It is useful to compare MARS to <a href="recursive_partitioning" title="wikilink">recursive partitioning</a> and this is done below. (Recursive partitioning is also commonly called <em>regression trees</em>, <em>decision trees</em>, or <a href="Predictive_analytics#Classification_and_regression_trees" title="wikilink">CART</a>; see the <a href="Decision_tree_learning" title="wikilink">recursive partitioning</a> article for details).</p>
<ul>
<li>MARS models are more flexible than <a href="linear_regression" title="wikilink">linear regression</a> models.</li>
</ul>
<ul>
<li>MARS models are simple to understand and interpret. Compare the equation for ozone concentration above to, say, the innards of a trained <a href="Artificial_neural_network" title="wikilink">neural network</a> or a <a href="random_forest" title="wikilink">random forest</a>.</li>
</ul>
<ul>
<li>MARS can handle both continuous and categorical data.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> MARS tends to be better than recursive partitioning for numeric data because hinges are more appropriate for numeric variables than the piecewise constant segmentation used by recursive partitioning.</li>
</ul>
<ul>
<li>Building MARS models often requires little or no data preparation. The hinge functions automatically partition the input data, so the effect of outliers is contained. In this respect MARS is similar to <a href="recursive_partitioning" title="wikilink">recursive partitioning</a> which also partitions the data into disjoint regions, although using a different method. (Nevertheless, as with most statistical modeling techniques, known outliers should be considered for removal before training a MARS model.)</li>
</ul>
<ul>
<li>MARS (like recursive partitioning) does <em>automatic variable selection</em> (meaning it includes important variables in the model and excludes unimportant ones). However, bear in mind that variable selection is not a clean problem and there is usually some arbitrariness in the selection, especially in the presence of <a href="Multicollinearity" title="wikilink">collinearity</a> and 'concurvity'.</li>
</ul>
<ul>
<li>MARS models tend to have a good bias-variance trade-off. The models are flexible enough to model non-linearity and variable interactions (thus MARS models have fairly low bias), yet the constrained form of MARS basis functions prevents too much flexibility (thus MARS models have fairly low variance).</li>
</ul>
<ul>
<li>MARS is suitable for handling fairly large datasets. It is a routine matter to build a MARS model from an input matrix with, say, 100 predictors and 10<sup>5</sup> observations. Such a model can be built in about a minute on a 1 GHz machine, assuming the maximum degree of interaction of MARS terms is limited to one (i.e. additive terms only). A degree two model with the same data on the same 1 GHz machine takes longer—about 12 minutes. Be aware that these times are highly data dependent. Recursive partitioning is much faster than MARS.</li>
</ul>
<ul>
<li>With MARS models, as with any non-parametric regression, parameter confidence intervals and other checks on the model cannot be calculated directly (unlike <a href="linear_regression" title="wikilink">linear regression</a> models). <a href="Cross-validation_(statistics)" title="wikilink">Cross-validation</a> and related techniques must be used for validating the model instead.</li>
</ul>
<ul>
<li>MARS models do not give as good fits as <a href="Boosting_(meta-algorithm)" title="wikilink">boosted</a> trees, but can be built much more quickly and are more interpretable. (An 'interpretable' model is in a form that makes it clear what the effect of each predictor is.)</li>
</ul>
<ul>
<li>The <code>earth</code>, <code>mda</code>, and <code>polspline</code> implementations do not allow missing values in predictors, but free implementations of regression trees (such as <code>rpart</code> and <code>party</code>) do allow missing values using a technique called surrogate splits.</li>
</ul>
<ul>
<li>MARS models can make predictions quickly. The prediction function simply has to evaluate the MARS model formula. Compare that to making a prediction with say a <a href="Support_Vector_Machine" title="wikilink">Support Vector Machine</a>, where every variable has to be multiplied by the corresponding element of every support vector. That can be a slow process if there are many variables and many support vectors.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Linear_regression" title="wikilink">Linear regression</a></li>
<li><a href="Segmented_regression" title="wikilink">Segmented regression</a></li>
<li><a href="Generalized_linear_model" title="wikilink">Generalized linear models</a> (GLMs) can be incorporated into MARS models by applying a link function after the MARS model is built. Thus, for example, MARS models can incorporate <a href="logistic_regression" title="wikilink">logistic regression</a> to predict probabilities.</li>
<li><a href="Nonlinear_regression" title="wikilink">Non-linear regression</a> is used when the underlying form of the function is known and regression is used only to estimate the parameters of that function. MARS, on the other hand, estimates the functions themselves, albeit with severe constraints on the nature of the functions. (These constraints are necessary because discovering a model from the data is an <a href="inverse_problem" title="wikilink">inverse problem</a> that is not <a href="Well-posed_problem" title="wikilink">well-posed</a> without constraints on the model.)</li>
<li><a href="Recursive_partitioning" title="wikilink">Recursive partitioning</a> (commonly called CART). MARS can be seen as a generalization of recursive partitioning that allows the model to better handle numerical (i.e. non-categorical) data.</li>
<li><a href="Generalized_additive_model" title="wikilink">Generalized additive models</a>. From the user's perspective GAMs are similar to MARS but (a) fit smooth <a href="Local_regression" title="wikilink">loess</a> or polynomial <a href="Spline_(mathematics)" title="wikilink">splines</a> instead of MARS basis functions, and (b) do not automatically model variable interactions. The fitting method used internally by GAMs is very different from that of MARS. For models that do not require automatic discovery of variable interactions GAMs often compete favorably with MARS.</li>
<li><a href="Rational_function_modeling" title="wikilink">Rational function modeling</a></li>
<li><a href="Spline_interpolation" title="wikilink">Spline interpolation</a></li>
<li><a class="uri" href="TSMARS" title="wikilink">TSMARS</a>. Time Series Mars is the term used when MARS models are applied in a time series context. Typically in this set up the predictors are the lagged time series values resulting in autoregressive spline models. These models and extensions to include moving average spline models are described in "Univariate Time Series Modelling and Forecasting using TSMARS: A study of threshold time series autoregressive, seasonal and moving average models using TSMARS".</li>
</ul>
<h2 id="software">Software</h2>
<h3 id="free">Free</h3>
<ul>
<li>Several <a href="R_(programming_language)" title="wikilink">R</a> packages fit MARS-type models:
<ul>
<li><code>earth</code> function in the <code>[http://cran.r-project.org/web/packages/earth/index.html earth]</code> package</li>
<li><code>mars</code> function in the <code>[http://cran.r-project.org/web/packages/mda/index.html mda]</code> package</li>
<li><code>polymars</code> function in the <code>[http://cran.r-project.org/web/packages/polspline/index.html polspline]</code> package. Not Friedman's MARS.</li>
</ul></li>
<li>Matlab code:
<ul>
<li><a href="http://www.cs.rtu.lv/jekabsons/regression.html">ARESLab: Adaptive Regression Splines toolbox for Matlab</a></li>
</ul></li>
<li>Python
<ul>
<li><a href="http://orange.biolab.si/blog/2011/12/20/earth-multivariate-adaptive-regression-splines/">Earth - Multivariate adaptive regression splines</a></li>
<li><a href="https://github.com/jcrudy/py-earth/">py-earth</a></li>
</ul></li>
</ul>
<h3 id="commercial">Commercial</h3>
<ul>
<li><a href="http://www.salfordsystems.com/mars.php">MARS</a> from Salford Systems. Based on Friedman's implementation.</li>
<li><a href="http://statsoft.com/products/data-mining-solutions/">STATISTICA Data Miner</a> from StatSoft</li>
<li><a href="http://support.sas.com/documentation/cdl/en/statug/65328/HTML/default/viewer.htm#statug_adaptivereg_overview.htm">ADAPTIVEREG</a> from SAS.</li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Hastie T., Tibshirani R., and Friedman J.H. (2009) <a href="http://www-stat.stanford.edu/~tibs/ElemStatLearn"><em>The Elements of Statistical Learning</em></a>, 2nd edition. Springer, ISBN 978-0-387-84857-0 (has a section on MARS)</li>
<li>Faraway J. (2005) <a href="http://www.maths.bath.ac.uk/~jjf23"><em>Extending the Linear Model with R</em></a>, CRC, ISBN 978-1-58488-424-8 (has an example using MARS with R)</li>
<li>Heping Zhang and Burton H. Singer (2010) <a href="http://www.amazon.com/Recursive-Partitioning-Applications-Springer-Statistics/dp/1441968237"><em>Recursive Partitioning and Applications</em></a>, 2nd edition. Springer, ISBN 978-1-4419-6823-4 (has a chapter on MARS and discusses some tweaks to the algorithm)</li>
<li>Denison D.G.T., Holmes C.C., Mallick B.K., and Smith A.F.M. (2004) <a href="http://www.stat.tamu.edu/~bmallick/wileybook/book_code.html"><em>Bayesian Methods for Nonlinear Classification and Regression</em></a>, Wiley, ISBN 978-0-471-49036-4</li>
<li>Berk R.A. (2008) <em>Statistical learning from a regression persepective</em>, Springer, ISBN 978-0-387-77500-5</li>
</ul>

<p>"</p>

<p><a href="Category:Regression_analysis" title="wikilink">Category:Regression analysis</a> <a href="Category:Machine_learning" title="wikilink">Category:Machine learning</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://cran.r-project.org/web/packages/earth/index.html">CRAN Package earth</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://orange.biolab.si/blog/2011/12/20/earth-multivariate-adaptive-regression-splines/">Earth - Multivariate adaptive regression splines in Orange (Python machine learning library)</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="Friedman,_J._H." title="wikilink">Friedman, J. H.</a> (1993) <em>Fast MARS</em>, Stanford University Department of Statistics, Technical Report 110<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="Friedman,_J._H." title="wikilink">Friedman, J. H.</a> (1993) <em>Estimating Functions of Mixed Ordinal and Categorical Variables Using Adaptive Splines</em>, New Directions in Statistical Data Analysis and Robustness (Morgenthaler, Ronchetti, Stahel, eds.), Birkhauser<a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
