<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1276">Memory cell (binary)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Memory cell (binary)</h1>
<hr/>

<p>The <strong>memory cell</strong> is the fundamental building block of <a href="computer_memory" title="wikilink">computer memory</a>. The memory cell is an <a href="electronic_circuit" title="wikilink">electronic circuit</a> that stores one <a class="uri" href="bit" title="wikilink">bit</a> of binary information and it must be set to store a logic 1 (high voltage level) and reset to store a logic 0 (low voltage level). Its value is maintained/stored until it is changed by the set/reset process. The value in the memory cell can be accessed by reading it.</p>
<h2 id="history">History</h2>

<p>On December 11, 1946 <a href="Frederic_Calland_Williams" title="wikilink">Freddie Williams</a> applied for a patent on his cathode-ray tube (CRT) storing device (<a href="Williams_tube" title="wikilink">Williams tube</a>) with 128 40-<a class="uri" href="bit" title="wikilink">bit</a> words, it was operational in 1947 and it is considered to be the first practical implementation of <a href="random-access_memory" title="wikilink">random-access memory</a>. In that year, the first patent applications for <a href="magnetic-core_memory" title="wikilink">magnetic-core memory</a> were filed by Frederick Viehe, <a href="An_Wang" title="wikilink">An Wang</a>, <a href="Ken_Olsen" title="wikilink">Ken Olsen</a> and <a href="Jay_Forrester" title="wikilink">Jay Forrester</a> also contributed to its development. The first modern memory cells were introduced in 1969, when John Schmidt designs the first 64-bit <a href="MOS_Technology" title="wikilink">MOS</a> p-channel <a href="Static_random-access_memory" title="wikilink">SRAM</a>. The first bipolar 64-bit <a href="Static_random-access_memory" title="wikilink">SRAM</a> were released by <a class="uri" href="Intel" title="wikilink">Intel</a> in 1969 with the 3101 <a href="Schottky_transistor" title="wikilink">Schottky</a> <a href="Transistor–transistor_logic" title="wikilink">TTL</a> and one year later it released the first <a class="uri" href="DRAM" title="wikilink">DRAM</a> chip, the <a href="Intel_1103" title="wikilink">Intel 1103</a>.</p>
<h2 id="description">Description</h2>

<p>The memory cell is the fundamental building block of memory. It can be implemented using different technologies, such as: <a href="Bipolar_junction_transistor" title="wikilink">bipolar</a>, <a href="MOSFET" title="wikilink">MOS</a>, and other <a href="semiconductor_devices" title="wikilink">semiconductor devices</a>, it can also be built from <a class="uri" href="magnetic" title="wikilink">magnetic</a> material such as <a href="Ferrite_(magnet)" title="wikilink">ferrite</a> cores or magnetic bubbles. Regardless of the implementation technology used, the purpose of the binary memory cell is always the same. It stores one bit of binary information and it must be set to store a 1 and reset to store a 0.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="implementation">Implementation</h2>

<p>In the following schematics detail the three most used implementations nowadays for memory cells :</p>
<ul>
<li>The Dynamic Random Access Memory cell (DRAM)</li>
<li>The Static Random Access Memory cell (SRAM)</li>
<li>Flip flops like the J/K shown below.</li>
</ul>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>DRAM Cell (1 Transistor and one capacitor)</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>SRAM Cell (6 Transistors)</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Clocked J/K flip flop</figcaption>
</figure></td>
</tr>
</tbody>
</table>
<h2 id="operation">Operation</h2>
<h3 id="dram-memory-cell">DRAM memory cell</h3>

<p><a href="Image:MT4C1024-HD.jpg" title="wikilink">thumb|right|upright=1.8|</a><a href="Die_(integrated_circuit)" title="wikilink">Die</a> of the MT4C1024 integrating one-<a class="uri" href="mebibit" title="wikilink">mebibit</a> of <a href="Dynamic_random-access_memory" title="wikilink">DRAM</a> memory cells.</p>
<ul>
<li><strong>Storage</strong></li>
</ul>
<dl>
<dd>The storage element of the <a href="Dynamic_random-access_memory" title="wikilink">DRAM</a> memory cell is the <a class="uri" href="capacitor" title="wikilink">capacitor</a> labeled (4) in the diagram above. The charge stored in the capacitor degrades over time, so its value must be refreshed (read and rewritten) periodically. The <a href="MOSFET" title="wikilink">nMOS</a> transistor (3) acts as a gate to allow reading or writing when open or storing when closed.
</dd>
</dl>
<ul>
<li><strong>Reading</strong></li>
</ul>
<dl>
<dd>For reading the Word line drives a logic 1 (voltage high) into the gate of the <a href="MOSFET" title="wikilink">nMOS</a> transistor (3) which makes it conductive and the charge stored at the capacitor (4) is then transferred to the bit line. The bit line will have a <a href="parasitic_capacitance" title="wikilink">parasitic capacitance</a> (5) that will drain part of the charge and slow the reading process. The capacitance of the bit line will determine the needed size of the storage capacitor (4). It is a trade-off. If the storage capacitor is too small, the voltage of the bit line would take too much time to raise or not even rise above the threshold needed by the amplifiers at the end of the bit line. Since the reading process degrades the charge in the storage capacitor (4) its value is rewritten after each read.
</dd>
</dl>
<ul>
<li><strong>Writing</strong></li>
</ul>
<dl>
<dd>The writing process is the easiest, the desired value logic 1 (high voltage) or logic 0 (low voltage) is driven into the bit line. The word line activates the <a href="MOSFET" title="wikilink">nMOS</a> transistor (3) connecting it to the storage capacitor (4). The only issue is to keep it open enough time to ensure that the capacitor is fully charged or discharged before turning off the nMOS transistor (3).
</dd>
</dl>
<h3 id="sram-memory-cell">SRAM memory cell</h3>
<figure><b>(Figure)</b>
<figcaption>SRAM memory cell depicting Inverter Loop as gates</figcaption>
</figure>
<ul>
<li><strong>Storage</strong></li>
</ul>
<dl>
<dd>The working principle of <a href="Static_random-access_memory" title="wikilink">SRAM</a> memory cell can be easier to understand if we draw transistors M1 through M4 as logic gates. That way we can clearly see that at its heart the cell storage is built using of two cross-coupled inverters This simple loop, creates a bi-stable circuit. a logic 1 at the input of the first <a class="uri" href="inverter" title="wikilink">inverter</a> turns into a 0 at its output, and it is fed into the second inverter which transforms that logic 0 back to a logic 1 feeding back the same value to the input of the first inverter. That creates a stable state that does not change over time. Similarly the other stable state of the circuit is to have a logic 0 at the input of the first inverter. After been inverted twice it will also feedback the same value.
</dd>
<dd>Therefore there are only two stable states that the circuit can be in:
<ul>
<li>

<math display="inline" id="Memory_cell_(binary):0">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle Q
  </annotation>
 </semantics>
</math>

 = 0 and   

<math display="inline" id="Memory_cell_(binary):1">
 <semantics>
  <mover accent="true">
   <mi>Q</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\overline{Q}
  </annotation>
 </semantics>
</math>

 = 1</li>
<li>

<math display="inline" id="Memory_cell_(binary):2">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle Q
  </annotation>
 </semantics>
</math>

 = 1 and   

<math display="inline" id="Memory_cell_(binary):3">
 <semantics>
  <mover accent="true">
   <mi>Q</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\overline{Q}
  </annotation>
 </semantics>
</math>

 = 0</li>
</ul>
</dd>
</dl>
<ul>
<li><strong>Reading</strong></li>
</ul>
<dl>
<dd>To read the contents of the memory cell stored in the loop, the transistors M5 and M6 must be turned on. when they receive voltage to their gates from the word line (

<math display="inline" id="Memory_cell_(binary):4">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle WL
  </annotation>
 </semantics>
</math>

), they become conductive and so the 

<math display="inline" id="Memory_cell_(binary):5">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle Q
  </annotation>
 </semantics>
</math>

 and  

<math display="inline" id="Memory_cell_(binary):6">
 <semantics>
  <mover accent="true">
   <mi>Q</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\overline{Q}
  </annotation>
 </semantics>
</math>

  values get transmitted to the bit line (

<math display="inline" id="Memory_cell_(binary):7">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle BL
  </annotation>
 </semantics>
</math>

) and to its complement (

<math display="inline" id="Memory_cell_(binary):8">
 <semantics>
  <mover accent="true">
   <mrow>
    <mi>B</mi>
    <mi>L</mi>
   </mrow>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <times></times>
     <ci>B</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\overline{BL}
  </annotation>
 </semantics>
</math>

). Finally this values get amplified at the end of the bit lines.
</dd>
</dl>
<ul>
<li><strong>Writing</strong></li>
</ul>
<dl>
<dd>The writing process is similar, the difference is that now the new value that we want to store in the memory cell is driven into the bit line (

<math display="inline" id="Memory_cell_(binary):9">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle BL
  </annotation>
 </semantics>
</math>

) and into its complement (

<math display="inline" id="Memory_cell_(binary):10">
 <semantics>
  <mover accent="true">
   <mrow>
    <mi>B</mi>
    <mi>L</mi>
   </mrow>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <times></times>
     <ci>B</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\overline{BL}
  </annotation>
 </semantics>
</math>

). Next transistors M5 and M6 are open by driving a logic one (voltage high) into the word line (

<math display="inline" id="Memory_cell_(binary):11">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle WL
  </annotation>
 </semantics>
</math>

) connecting the bit lines to the loop. There are two possible cases:
<ol>
<li>If the value of the loop is the same as the new value driven, there is no change.</li>
<li>If the value of the loop is different from the new value driven there are two conflicting values, in order for the voltage in the bit lines to overwrite the output of the inverters, the size of the M5 and M6 transistors must be larger than that of the M1-M4 transistors to allow more current to flow through them and tip the voltage in the new value direction, the loop will then amplify it to full rail.</li>
</ol>
</dd>
</dl>
<h3 id="flip-flop">Flip flop</h3>

<p>The <a href="Flip-flop_(electronics)" title="wikilink">flip-flop</a> has many different implementations, its storage element is usually a Latch consisting of a <a href="NAND_gate" title="wikilink">NAND gate</a> loop or a <a href="NOR_gate" title="wikilink">NOR gate</a> loop with additional gates used to implement clocking. Its value is always available for reading as an output. The value remains stored until it is changed through the set or reset process.</p>
<h2 id="applications">Applications</h2>

<p> Logic circuits without memory cells or feedback paths are called <a href="Combinational_logic" title="wikilink">combinational</a>, their outputs values depend only on the current value of their input values. They do not have memory. But memory is a key element of <a href="digital_systems" title="wikilink">digital systems</a>. In computers it allows to store both programs and data. and memory cells are also used for temporary storage of the output of combinational circuits to be used latter by digital systems. Logic circuits that use memory cells are called sequential circuits. Its output depends not only on the present value of its inputs, but also on the circuits previous state, as determined by the values stored on is memory cells. These circuits require a timing generator or clock for their operation.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Computer memory used in <a href="computer_systems" title="wikilink">computer systems</a> is built mainly out of DRAM cells, since the layout is much smaller than SRAM, it can be more densely packed yielding cheaper memory with greater capacity. Since the DRAM memory cell stores its value as the charge of a capacitor, and there are current leakage issues, its value must be constantly rewriten. this is one of the reasons that make DRAM cells slower than the larger SRAM (Static RAM) cells, which has its value always available. That is the reason why SRAM memory is used for on-<a href="Integrated_circuit" title="wikilink">chip</a> <a href="CPU_cache" title="wikilink">cache</a> included in modern <a class="uri" href="microprocessor" title="wikilink">microprocessor</a> chips.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="references">References</h2>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Dynamic_random-access_memory" title="wikilink">Dynamic random-access memory</a></li>
<li><a href="Flip-flop_(electronics)" title="wikilink">Flip-flop (electronics)</a></li>
<li><a href="Row_hammer" title="wikilink">Row hammer</a></li>
<li><a href="Static_random-access_memory" title="wikilink">Static random-access memory</a></li>
</ul>

<p>"</p>

<p><a href="Category:Computer_memory" title="wikilink">Category:Computer memory</a> <a href="Category:Digital_electronics" title="wikilink">Category:Digital electronics</a> <a href="Category:Digital_systems" title="wikilink">Circuit</a> <a href="Category:Electronic_engineering" title="wikilink">Category:Electronic engineering</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
