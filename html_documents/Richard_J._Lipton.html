<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1564">Richard J. Lipton</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Richard J. Lipton</h1>
<hr/>

<p><strong>Richard Jay "Dick" Lipton</strong> (born September 6, 1946) is an <a href="United_States" title="wikilink">American</a> <a href="computer_science" title="wikilink">computer scientist</a> who has worked in <a href="computer_science_theory" title="wikilink">computer science theory</a>, <a class="uri" href="cryptography" title="wikilink">cryptography</a>, and <a href="DNA_computing" title="wikilink">DNA computing</a>. Lipton is Associate Dean of Research, Professor, and the Frederick G. Storey Chair in Computing in the College of Computing at the <a href="Georgia_Institute_of_Technology" title="wikilink">Georgia Institute of Technology</a>.</p>
<h2 id="career">Career</h2>

<p>In 1968, Lipton received his undergraduate degree in <a class="uri" href="mathematics" title="wikilink">mathematics</a> from <a href="Case_Western_Reserve_University" title="wikilink">Case Western Reserve University</a>. In 1973, he received his <a class="uri" href="Ph.D." title="wikilink">Ph.D.</a> from <a href="Carnegie_Mellon_University" title="wikilink">Carnegie Mellon University</a>; his dissertation, supervised by <a href="David_Parnas" title="wikilink">David Parnas</a>, is entitled <em>On Synchronization Primitive Systems</em>. After graduating, Lipton taught at <a href="Yale_University" title="wikilink">Yale</a> 1973–1978, at <a href="University_of_California,_Berkeley" title="wikilink">Berkeley</a> 1978–1980, and then at <a href="Princeton_University" title="wikilink">Princeton</a> 1980–2000. Since 2000, Lipton has been at <a href="Georgia_Institute_of_Technology" title="wikilink">Georgia Tech</a>. While at Princeton, Lipton worked in the field of <a href="DNA_computing" title="wikilink">DNA computing</a>. Since 1996, Lipton has been the chief consulting scientist at <a class="uri" href="Telcordia" title="wikilink">Telcordia</a>.</p>
<h2 id="karplipton-theorem">Karp–Lipton theorem</h2>

<p>In 1980, along with <a href="Richard_M._Karp" title="wikilink">Richard M. Karp</a>, Lipton proved that if <a href="Boolean_satisfiability_problem" title="wikilink">SAT</a> can be solved by <a href="Boolean_circuit" title="wikilink">Boolean circuits</a> with a polynomial number of <a href="logic_gate" title="wikilink">logic gates</a>, then the <a href="polynomial_hierarchy" title="wikilink">polynomial hierarchy</a> collapses to its second level. __NOTOC__</p>
<h2 id="parallel-algorithms">Parallel algorithms</h2>

<p>Showing that a program P has some property is a simple process if the actions inside the program are uninterruptible. However, when the action is interruptible, Lipton showed that through a type of reduction and analysis, it can be shown that the reduced program has that property if and only if the original program has the property.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> If the reduction is done by treating interruptible operations as one large uninterruptible action, even with these relaxed conditions properties can be proven for a program P. Thus, correctness proofs of a parallel system can often be greatly simplified.</p>
<h2 id="database-security">Database security</h2>

<p>Lipton studied and created database security models on how and when to restrict the queries made by users of a database such that private or secret information will not be leaked.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Even when the user is restricted to only read operations on a database, secure information could be at risk. For example, querying a database of campaign donations could allow the user to discover the individual donations to political candidates or organizations. If given access to averages of data and unrestricted query access, a user could exploit the properties of those averages to gain illicit information. These queries are considered to have large "overlap" creating the insecurity. By bounding the "overlap" and number of queries, a secure database can be achieved.</p>
<h2 id="online-scheduling">Online scheduling</h2>

<p>Richard Lipton with Andrew Tomkins introduced a randomized <a href="Adversary_(online_algorithm)" title="wikilink">online interval scheduling algorithm</a>, the 2-size version being strongly competitive, and the <em>k</em>-size version achieving O(log

<math display="inline" id="Richard_J._Lipton:0">
 <semantics>
  <msup>
   <mi mathvariant="normal">△</mi>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mi>ϵ</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-△</ci>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>ϵ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vartriangle^{1+\epsilon}
  </annotation>
 </semantics>
</math>

), as well as demonstrating a theoretical lower-bound of O(log

<math display="inline" id="Richard_J._Lipton:1">
 <semantics>
  <mi mathvariant="normal">△</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-△</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vartriangle
  </annotation>
 </semantics>
</math>

).<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> This algorithm uses a private-coin for randomization and a "virtual" choice to fool a <a href="Adversary_(online_algorithm)" title="wikilink">medium adversary</a>.</p>

<p>Being presented with an event the user must decide whether or not to include the event in the schedule. The 2-size virtual algorithm is described by how it reacts to 1-interval or <em>k</em>-intervals being presented by the adversary:</p>
<ul>
<li>For a 1-interval, flip a fair coin

<p>*;Heads: Take the interval</p>

<p>*;Tails: "Virtually" take the interval, but do no work. Take no short interval for the next 1 unit of time.</p></li>
</ul>
<ul>
<li>For a <em>k</em>-interval, take whenever possible.</li>
</ul>

<p>Again, this 2-size algorithm is shown to be strongly-<a href="Competitive_analysis_(online_algorithm)" title="wikilink">competitive</a>. The generalized <em>k</em>-size algorithm which is similar to the 2-size algorithm is then shown to be O(log

<math display="inline" id="Richard_J._Lipton:2">
 <semantics>
  <msup>
   <mi mathvariant="normal">△</mi>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mi>ϵ</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-△</ci>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>ϵ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vartriangle^{1+\epsilon}
  </annotation>
 </semantics>
</math>

)-competitive.</p>
<h2 id="program-checking">Program checking</h2>

<p>Lipton showed that randomized testing can be provably useful, given the problem satisfied certain properties.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Proving <a href="program_correctness" title="wikilink">correctness of a program</a> is one of the most important problems presented in computer science. Typically in randomized testing, in order to attain a 1/1000 chance of an error, 1000 tests must be run. However Lipton shows that if a problem has "easy" sub-parts, repeated black-box testing can attain <em>c</em><sup><em>r</em></sup> error rate, with <em>c</em> a constant less than 1 and <em>r</em> being the number of tests. Therefore, the probability of error <a href="exponential_decay" title="wikilink">goes to zero exponentially</a> fast as <em>r</em> grows.</p>

<p>This technique is useful to check the correctness of many types of problems.</p>
<ul>
<li>Signal processing: <a href="Fast_Fourier_transform" title="wikilink">fast Fourier transform (FFT)</a> and other highly parallelizable functions are difficult to manually check results when written in code such as <a href="Fortran" title="wikilink">FORTRAN</a>, so a way to quickly check correctness is greatly desired.</li>
<li>Functions over finite fields and the permanent: Suppose that 

<math display="inline" id="Richard_J._Lipton:3">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{1},\dots,x_{n})
  </annotation>
 </semantics>
</math>

 is a polynomial over a finite field of size <em>q</em> with . Then <em>ƒ</em> is randomly testable of order  over the function basis that includes just addition. Perhaps the most important application from this is the ability to efficiently check the correctness of the <a class="uri" href="permanent" title="wikilink">permanent</a>. Cosmetically similar to the determinant, the permanent is very difficult to check correctness, but even this type of problem satisfies the constraints. This result even led to the breakthroughs of <a href="interactive_proof_system" title="wikilink">interactive proof systems</a> Karloff-Nisan and Shamir, including the result .</li>
</ul>
<h2 id="games-with-simple-strategies">Games with simple strategies</h2>

<p>In the area of <a href="game_theory" title="wikilink">game theory</a>, more specifically on <a href="non-cooperative_game" title="wikilink">non-cooperative game</a>, Lipton together with E.Markakis and A.Mehta proved <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> the existence of <a class="uri" href="epsilon-equilibrium" title="wikilink">epsilon-equilibrium</a> strategies with support logarithmic in the number of <a href="pure_strategy" title="wikilink">pure strategy</a>. Furthermore, the payoff of such strategies can epsilon-approximate the payoffs of exact <a href="Nash_equilibrium" title="wikilink">Nash equilibrium</a>. The limited size (logarithmic) of support provides a natural quasi-polynomial algorithm of computing an <a class="uri" href="epsilon-equilibrium" title="wikilink">epsilon-equilibrium</a>.</p>
<h2 id="query-size-estimation">Query size estimation</h2>

<p>Lipton and J.Naughton presented an adaptive random sampling algorithm for database querying<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> which is applicable to any query for which answer to the query can be partitioned into disjoint subsets. Compared with most sampling estimation algorithms that statically determines the number of samples needed, the algorithm they proposed decides the number of samples based on the size of samples and tends to keep the running time constant rather than the number of samples.</p>
<h2 id="formal-verification-of-programs">Formal verification of programs</h2>

<p><a href="Richard_DeMillo" title="wikilink">DeMillo</a>, Lipton and <a href="Alan_Perlis" title="wikilink">Perlis</a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> criticized the idea of formal verification of programs and argued that</p>
<ul>
<li>Formal verifications in computer science will not play the same key role as proofs do in mathematics.</li>
<li>Absence of continuity, the inevitability of change, and the complexity of specification of real programs will make formal verification of programs difficult to justify and manage.</li>
</ul>
<h2 id="multi-party-protocols">Multi-party protocols</h2>

<p>Chandra, Furst and Lipton<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> generalized the notion of two-party communication protocols to multi-party communication protocols. They proposed a model in which a collection of processes (

<math display="inline" id="Richard_J._Lipton:4">
 <semantics>
  <msub>
   <mi>P</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{0}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Richard_J._Lipton:5">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>P</mi>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1},\dots,P_{k-1}
  </annotation>
 </semantics>
</math>

) have access to a set of integers (

<math display="inline" id="Richard_J._Lipton:6">
 <semantics>
  <msub>
   <mi>a</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{0}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Richard_J._Lipton:7">
 <semantics>
  <msub>
   <mi>a</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1}
  </annotation>
 </semantics>
</math>

,…

<math display="inline" id="Richard_J._Lipton:8">
 <semantics>
  <msub>
   <mi>a</mi>
   <mrow>
    <mi>k</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <apply>
     <minus></minus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{k-1}
  </annotation>
 </semantics>
</math>

 ) except one of them, so that 

<math display="inline" id="Richard_J._Lipton:9">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}
  </annotation>
 </semantics>
</math>

 is denied access to 

<math display="inline" id="Richard_J._Lipton:10">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}
  </annotation>
 </semantics>
</math>

. These processes are allowed to communicate in order to arrive at a consensus on a predicate. They studied this model’s communication complexity, defined as the number of bits broadcast among all the processes. As an example, they studied the complexity of a <em>k</em>-party protocol for Exactly-N (do all 

<math display="inline" id="Richard_J._Lipton:11">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}
  </annotation>
 </semantics>
</math>

’s sum up to N?), and obtained a lower bound using the tiling method. They further applied this model to study general branching programs and obtained a time lower bound for constant-space branching programs that compute Exactly-N.</p>
<h2 id="timespace-sat-tradeoff">Time/space SAT tradeoff</h2>

<p>We have no way to prove that <a href="Boolean_satisfiability_problem" title="wikilink">Boolean satisfiability problem</a> (often abbreviated as SAT), which is <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>, requires exponential (or at least super-polynomial) time (this is the famous <a href="P_versus_NP_problem" title="wikilink">P versus NP problem</a>), or linear (or at least super-logarithmic) space to solve. However, in the context of <a href="space-time_tradeoff" title="wikilink">space-time tradeoff</a>, one can prove that SAT cannot be computed if we apply constraints to both time and space. L. Fortnow, Lipton, D. van Melkebeek, and A. Viglas<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> proved that SAT cannot be computed by a Turing machine that takes at most O(

<math display="inline" id="Richard_J._Lipton:12">
 <semantics>
  <msup>
   <mi>n</mi>
   <mn>1.1</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <cn type="float">1.1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{1.1}
  </annotation>
 </semantics>
</math>

) steps and at most O(

<math display="inline" id="Richard_J._Lipton:13">
 <semantics>
  <msup>
   <mi>n</mi>
   <mn>0.1</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <cn type="float">0.1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{0.1}
  </annotation>
 </semantics>
</math>

) cells of its read-write tapes.</p>
<h2 id="awards-and-honors">Awards and honors</h2>
<ul>
<li><a href="Guggenheim_Fellowship" title="wikilink">Guggenheim Fellow</a>, 1981</li>
<li><a class="uri" href="Fellow" title="wikilink">Fellow</a> of the <a href="Association_for_Computing_Machinery" title="wikilink">Association for Computing Machinery</a>, 1997</li>
<li>member of the <a href="National_Academy_of_Engineering" title="wikilink">National Academy of Engineering</a></li>
<li><a href="Knuth_Prize" title="wikilink">Knuth Prize</a> winner, 2014<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="SL_(complexity)" title="wikilink">SL (complexity)</a></li>
<li><a href="Take-grant_protection_model" title="wikilink">Take-grant protection model</a></li>
<li><a href="Planar_separator_theorem" title="wikilink">Planar separator theorem</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://rjlipton.wordpress.com/">His Personal Blog "Gödel`s Lost Letter and P=NP"</a></li>
</ul>

<p>"</p>

<p><a href="Category:American_computer_scientists" title="wikilink">Category:American computer scientists</a> <a href="Category:Fellows_of_the_Association_for_Computing_Machinery" title="wikilink">Category:Fellows of the Association for Computing Machinery</a> <a href="Category:Guggenheim_Fellows" title="wikilink">Category:Guggenheim Fellows</a> <a href="Category:Living_people" title="wikilink">Category:Living people</a> <a href="Category:Carnegie_Mellon_University_alumni" title="wikilink">Category:Carnegie Mellon University alumni</a> <a href="Category:Georgia_Institute_of_Technology_faculty" title="wikilink">Category:Georgia Institute of Technology faculty</a> <a href="Category:Theoretical_computer_scientists" title="wikilink">Category:Theoretical computer scientists</a> <a href="Category:1946_births" title="wikilink">Category:1946 births</a> <a href="Category:20th-century_mathematicians" title="wikilink">Category:20th-century mathematicians</a> <a href="Category:21st-century_mathematicians" title="wikilink">Category:21st-century mathematicians</a> <a href="Category:Members_of_the_United_States_National_Academy_of_Engineering" title="wikilink">Category:Members of the United States National Academy of Engineering</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Lipton, R (1975) <a href="http://www.cs.uoregon.edu/classes/06W/cis607atom/readings/lipton-reduction.pdf">"Reduction: a method of proving properties of parallel programs"</a>, <em>Communications of the ACM</em> 18(12)<a href="#fnref1">↩</a></li>
<li id="fn2">Lipton, R (1979) <a href="http://www.cs.virginia.edu/papers/p97-dobkin.pdf">"Secure databases: protection against user influence"</a>, "ACM Transactions on Database Systems" 4(1)<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">Lipton, R (1991) "New Directions in Testing", "DIMACS Distributed Computing and Cryptography" Vol. 2 page: 191<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="Richard_Lipton" title="wikilink">Richard Lipton</a>, Evangelos Markakis, Aranyak Mehta (2007) "Playing Games with Simple Strategies", "EC '03: Proceedings of the 4th ACM conference on Electronic commerce", "ACM"<a href="#fnref5">↩</a></li>
<li id="fn6">Richard J. Lipton, Jeffrey F. Naughton (1990) "Query Size Estimation By Adaptive Sampling", "PODS '90: Proceedings of the ninth ACM SIGACT-SIGMOD-SIGART symposium on Principles of database systems"<a href="#fnref6">↩</a></li>
<li id="fn7">Richard J. Lipton, Jeffrey F. Naughton, Donovan A. Schneider (1990) "SIGMOD '90: Proceedings of the 1990 ACM SIGMOD international conference on Management of data "<a href="#fnref7">↩</a></li>
<li id="fn8">Richard A. DeMillo, Richard J. Lipton, Alan J. Perlis (1979) “Social processes and proofs of theorems and programs”, "Communications of the ACM , Volume 22 Issue 5"<a href="#fnref8">↩</a></li>
<li id="fn9">A. K. Chandra, M. L. Furst, and R. J. Lipton (1983) "Multi-Party Protocols", "In STOC, pages 94–99. ACM, 25–2"<a href="#fnref9">↩</a></li>
<li id="fn10">L. Fortnow, R. Lipton, D. van Melkebeek, and A. Viglas (2005) "Time-space lower bounds for satisfiability", "J. ACM, 52:835–865, 2005. Prelim version CCC ’2000"<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
</ol>
</section>
</body>
</html>
