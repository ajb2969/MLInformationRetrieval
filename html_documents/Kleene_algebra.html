<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title offset="468">Kleene algebra</title>
   <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js">
    </script>
</head>
<body>
<h1>Kleene algebra</h1>
<hr/>
<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <strong>Kleene algebra</strong> ( ; named after <a href="Stephen_Cole_Kleene" title="wikilink">Stephen Cole Kleene</a>) is an idempotent (and thus partially ordered) <a class="uri" href="semiring" title="wikilink">semiring</a> endowed with a <a href="closure_operator" title="wikilink">closure operator</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It generalizes the operations known from <a href="regular_expression" title="wikilink">regular expressions</a>.</p>
<h2 id="definition">Definition</h2>
<p>Various inequivalent definitions of Kleene algebras and related structures have been given in the literature.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Here we will give the definition that seems to be the most common nowadays.</p>
<p>A Kleene algebra is a <a href="Set_(mathematics)" title="wikilink">set</a> <em>A</em> together with two <a href="binary_operation" title="wikilink">binary operations</a> + : <em>A</em> × <em>A</em> → <em>A</em> and · : <em>A</em> × <em>A</em> → <em>A</em> and one function <sup>*</sup> : <em>A</em> → <em>A</em>, written as <em>a</em> + <em>b</em>, <em>ab</em> and <em>a</em><sup>*</sup> respectively, so that the following axioms are satisfied.</p>
<ul>
<li><a class="uri" href="Associativity" title="wikilink">Associativity</a> of + and ·: <em>a</em> + (<em>b</em> + <em>c</em>) = (<em>a</em> + <em>b</em>) + <em>c</em> and <em>a</em>(<em>bc</em>) = (<em>ab</em>)<em>c</em> for all <em>a</em>, <em>b</em>, <em>c</em> in <em>A</em>.</li>
<li><a class="uri" href="Commutativity" title="wikilink">Commutativity</a> of +: <em>a</em> + <em>b</em> = <em>b</em> + <em>a</em> for all <em>a</em>, <em>b</em> in <em>A</em></li>
<li><a class="uri" href="Distributivity" title="wikilink">Distributivity</a>: <em>a</em>(<em>b</em> + <em>c</em>) = (<em>ab</em>) + (<em>ac</em>) and (<em>b</em> + <em>c</em>)<em>a</em> = (<em>ba</em>) + (<em>ca</em>) for all <em>a</em>, <em>b</em>, <em>c</em> in <em>A</em></li>
<li><a href="Identity_element" title="wikilink">Identity elements</a> for + and ·: There exists an element 0 in <em>A</em> such that for all <em>a</em> in <em>A</em>: <em>a</em> + 0 = 0 + <em>a</em> = <em>a</em>. There exists an element 1 in <em>A</em> such that for all <em>a</em> in <em>A</em>: <em>a</em>1 = 1<em>a</em> = <em>a</em>.</li>
<li><em>a</em>0 = 0<em>a</em> = 0 for all <em>a</em> in <em>A</em>.</li>
</ul>
<p>The above axioms define a <a class="uri" href="semiring" title="wikilink">semiring</a>. We further require:</p>
<ul>
<li>+ is <a class="uri" href="idempotent" title="wikilink">idempotent</a>: <em>a</em> + <em>a</em> = <em>a</em> for all <em>a</em> in <em>A</em>.</li>
</ul>
<p>It is now possible to define a <a href="partial_order" title="wikilink">partial order</a> ≤ on <em>A</em> by setting <em>a</em> ≤ <em>b</em> <a href="if_and_only_if" title="wikilink">if and only if</a> <em>a</em> + <em>b</em> = <em>b</em> (or equivalently: <em>a</em> ≤ <em>b</em> if and only if there exists an <em>x</em> in <em>A</em> such that <em>a</em> + <em>x</em> = <em>b</em>; with any definition, <em>a</em> ≤ <em>b</em> ≤ <em>a</em> implies <em>a</em> = <em>b</em>). With this order we can formulate the last two axioms about the operation <sup>*</sup>:</p>
<ul>
<li>1 + <em>a</em>(<em>a</em><sup>*</sup>) ≤ <em>a</em><sup>*</sup> for all <em>a</em> in <em>A</em>.</li>
<li>1 + (<em>a</em><sup>*</sup>)<em>a</em> ≤ <em>a</em><sup>*</sup> for all <em>a</em> in <em>A</em>.</li>
<li>if <em>a</em> and <em>x</em> are in <em>A</em> such that <em>ax</em> ≤ <em>x</em>, then <em>a</em><sup>*</sup><em>x</em> ≤ <em>x</em></li>
<li>if <em>a</em> and <em>x</em> are in <em>A</em> such that <em>xa</em> ≤ <em>x</em>, then <em>x</em>(<em>a</em><sup>*</sup>) ≤ <em>x</em> <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
</ul>
<p>Intuitively, one should think of <em>a</em> + <em>b</em> as the "union" or the "least upper bound" of <em>a</em> and <em>b</em> and of <em>ab</em> as some multiplication which is monotonic, in the sense that <em>a</em> ≤ <em>b</em> implies <em>ax</em> ≤ <em>bx</em>. The idea behind the star operator is <em>a</em><sup>*</sup> = 1 + <em>a</em> + <em>aa</em> + <em>aaa</em> + ... From the standpoint of <a href="programming_language_theory" title="wikilink">programming language theory</a>, one may also interpret + as "choice", · as "sequencing" and <sup>*</sup> as "iteration".</p>
<h2 id="examples">Examples</h2>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Notational correspondence between</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><a href="#Definition" title="wikilink">Kleene algebras</a> and</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><a href="Regular_expression#Formal_language_theory" title="wikilink">Regular expressions</a></p></td>
</tr>
</tbody>
</table>
<p>Let Σ be a finite set (an "alphabet") and let <em>A</em> be the set of all <a href="Regular_expression#Formal_language_theory" title="wikilink">regular expressions</a> over Σ. We consider two such regular expressions equal if they describe the same <a href="formal_language" title="wikilink">language</a>. Then <em>A</em> forms a Kleene algebra. In fact, this is a <a href="free_object" title="wikilink">free</a> Kleene algebra in the sense that any equation among regular expressions follows from the Kleene algebra axioms and is therefore valid in every Kleene algebra.</p>
<p>Again let Σ be an alphabet. Let <em>A</em> be the set of all <a href="regular_language" title="wikilink">regular languages</a> over Σ (or the set of all <a href="context-free_language" title="wikilink">context-free languages</a> over Σ; or the set of all <a href="recursive_language" title="wikilink">recursive languages</a> over Σ; or the set of <em>all</em> languages over Σ). Then the <a href="union_(set_theory)" title="wikilink">union</a> (written as +) and the <a href="concatenation#Concatenation_of_sets_of_strings" title="wikilink">concatenation</a> (written as ·) of two elements of <em>A</em> again belong to <em>A</em>, and so does the <a href="Kleene_star" title="wikilink">Kleene star</a> operation applied to any element of <em>A</em>. We obtain a Kleene algebra <em>A</em> with 0 being the <a href="empty_set" title="wikilink">empty set</a> and 1 being the set that only contains the <a href="empty_string" title="wikilink">empty string</a>.</p>
<p>Let <em>M</em> be a <a class="uri" href="monoid" title="wikilink">monoid</a> with identity element <em>e</em> and let <em>A</em> be the set of all <a href="subset" title="wikilink">subsets</a> of <em>M</em>. For two such subsets <em>S</em> and <em>T</em>, let <em>S</em> + <em>T</em> be the union of <em>S</em> and <em>T</em> and set <em>ST</em> = {<em>st</em> : <em>s</em> in <em>S</em> and <em>t</em> in <em>T</em>}. <em>S</em><sup>*</sup> is defined as the submonoid of <em>M</em> generated by <em>S</em>, which can be described as {<em>e</em>} ∪ <em>S</em> ∪ <em>SS</em> ∪ <em>SSS</em> ∪ ... Then <em>A</em> forms a Kleene algebra with 0 being the empty set and 1 being {<em>e</em>}. An analogous construction can be performed for any small <a href="category_theory" title="wikilink">category</a>.</p>
<p>The <a href="linear_subspace" title="wikilink">linear subspaces</a> of a unital <a href="algebra_over_a_field" title="wikilink">algebra over a field</a> form a Kleene algebra. Given linear subspaces <em>V</em> and <em>W</em>, define <em>V</em> + <em>W</em> to be the sum of the two subspaces, and 0 to be the trivial subspace {0}. Define <em>V</em> · <em>W</em> = span {v · w | v ∈ V, w ∈ V}, the <a href="linear_span" title="wikilink">linear span</a> of the product of vectors from <em>V</em> and <em>W</em> respectively. Define 1 = span {I}, the span of the unit of the algebra. The closure of <em>V</em> is the <a href="direct_sum_of_modules" title="wikilink">direct sum</a> of all powers of <em>V</em>.</p>
<p><span class="LaTeX">$$V^{*} = \bigoplus_{i = 0}^{\infty} V^{n}$$</span></p>
<p>Suppose <em>M</em> is a set and <em>A</em> is the set of all <a href="binary_relation" title="wikilink">binary relations</a> on <em>M</em>. Taking + to be the union, · to be the composition and <sup>*</sup> to be the <a href="reflexive_transitive_closure" title="wikilink">reflexive transitive closure</a>, we obtain a Kleene algebra.</p>
<p>Every <a href="Boolean_algebra_(structure)" title="wikilink">Boolean algebra</a> with operations <span class="LaTeX">$\lor$</span> and <span class="LaTeX">$\land$</span> turns into a Kleene algebra if we use <span class="LaTeX">$\lor$</span> for +, <span class="LaTeX">$\land$</span> for · and set <em>a</em><sup>*</sup> = 1 for all <em>a</em>.</p>
<p>A quite different Kleene algebra can be used to implement the <a href="Floyd–Warshall_algorithm" title="wikilink">Floyd–Warshall algorithm</a>, computing the <a href="shortest_path_problem" title="wikilink">shortest path's length</a> for every two vertices of a <a href="graph_theory" title="wikilink">weighted directed graph</a>, by <a href="Kleene's_algorithm" title="wikilink">Kleene's algorithm</a>, computing a regular expression for every two states of a <a href="deterministic_finite_automaton" title="wikilink">deterministic finite automaton</a>. Using the <a href="extended_real_number_line" title="wikilink">extended real number line</a>, take <em>a</em> + <em>b</em> to be the minimum of <em>a</em> and <em>b</em> and <em>ab</em> to be the ordinary sum of <em>a</em> and <em>b</em> (with the sum of +∞ and −∞ being defined as +∞). <em>a</em><sup>*</sup> is defined to be the real number zero for nonnegative <em>a</em> and −∞ for negative <em>a</em>. This is a Kleene algebra with zero element +∞ and one element the real number zero. A weighted directed graph can then be considered as a deterministic finite automaton, with each transition labelled by its weight. For any two graph nodes (automaton states), the regular expressions computed from Kleene's algorithm evaluates, in this particular Kleene algebra, to the shortest path length between the nodes.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="properties">Properties</h2>
<p>Zero is the smallest element: 0 ≤ <em>a</em> for all <em>a</em> in <em>A</em>.</p>
<p>The sum <em>a</em> + <em>b</em> is the <a href="least_upper_bound" title="wikilink">least upper bound</a> of <em>a</em> and <em>b</em>: we have <em>a</em> ≤ <em>a</em> + <em>b</em> and <em>b</em> ≤ <em>a</em> + <em>b</em> and if <em>x</em> is an element of <em>A</em> with <em>a</em> ≤ <em>x</em> and <em>b</em> ≤ <em>x</em>, then <em>a</em> + <em>b</em> ≤ <em>x</em>. Similarly, <em>a</em><sub>1</sub> + ... + <em>a</em><sub><em>n</em></sub> is the least upper bound of the elements <em>a</em><sub>1</sub>, ..., <em>a</em><sub><em>n</em></sub>.</p>
<p>Multiplication and addition are monotonic: if <em>a</em> ≤ <em>b</em>, then</p>
<ul>
<li><em>a</em> + <em>x</em> ≤ <em>b</em> + <em>x</em>,</li>
<li><em>ax</em> ≤ <em>bx</em>, and</li>
<li><em>xa</em> ≤ <em>xb</em></li>
</ul>
<p>for all <em>x</em> in <em>A</em>.</p>
<p>Regarding the star operation, we have</p>
<ul>
<li>0<sup>*</sup> = 1 and 1<sup>*</sup> = 1,</li>
<li><em>a</em> ≤ <em>b</em> implies <em>a</em><sup>*</sup> ≤ <em>b</em><sup>*</sup> (monotonicity),</li>
<li><em>a</em><sup><em>n</em></sup> ≤ <em>a</em><sup>*</sup> for every natural number <em>n</em>, where <em>a</em><sup><em>n</em></sup> is defined as <em>n</em>-fold multiplication of <em>a</em>,</li>
<li>(<em>a</em><sup>*</sup>)(<em>a</em><sup>*</sup>) = <em>a</em><sup>*</sup>,</li>
<li>(<em>a</em><sup>*</sup>)<sup>*</sup> = <em>a</em><sup>*</sup>,</li>
<li>1 + <em>a</em>(<em>a</em><sup>*</sup>) = <em>a</em><sup>*</sup> = 1 + (<em>a</em><sup>*</sup>)<em>a</em>,</li>
<li><em>a</em> ≤ <em>b</em><sup>*</sup> if and only if <em>a</em><sup>*</sup> ≤ <em>b</em><sup>*</sup>,</li>
<li><em>ax</em> = <em>xb</em> implies (<em>a</em><sup>*</sup>)<em>x</em> = <em>x</em>(<em>b</em><sup>*</sup>),</li>
<li>((<em>ab</em>)<sup>*</sup>)<em>a</em> = <em>a</em>((<em>ba</em>)<sup>*</sup>),</li>
<li>(<em>a</em>+<em>b</em>)<sup>*</sup> = <em>a</em><sup>*</sup>(<em>b</em>(<em>a</em><sup>*</sup>))<sup>*</sup>, and</li>
<li><em>pq</em> = 1 = <em>qp</em> implies <em>q</em>(<em>a</em><sup>*</sup>)<em>p</em> = (<em>qap</em>)<sup>*</sup>. <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
</ul>
<p>If <em>A</em> is a Kleene algebra and <em>n</em> is a natural number, then one can consider the set M<sub><em>n</em></sub>(<em>A</em>) consisting of all <em>n</em>-by-<em>n</em> <a href="matrix_(mathematics)" title="wikilink">matrices</a> with entries in <em>A</em>. Using the ordinary notions of matrix addition and multiplication, one can define a unique <sup>*</sup>-operation so that M<sub><em>n</em></sub>(<em>A</em>) becomes a Kleene algebra.</p>
<h2 id="history">History</h2>
<p>Kleene introduced regular expressions and gave some of their algebraical laws.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Although he didn't define Kleene algebras, he asked for a decision procedure for equivalence of regular expressions.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Redko proved that no finite set of axioms can characterize the algebra of regular languages.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Salomaa gave complete axiomatizations of this algebra, however depending on problematic inference rules.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> The problem of providing a complete set of axioms, which would allow derivation of all equations among regular expressions, was intensively studied by <a href="John_Horton_Conway" title="wikilink">John Horton Conway</a> under the name of <em>regular algebras</em>,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> however, the bulk of his treatment was infinitary. In 1981, <a href="Dexter_Kozen" title="wikilink">Kozen</a> gave a complete infinitary equational deductive system for the algebra of regular languages.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> In 1994, he gave the <a href="#Definition" title="wikilink">above</a> finite axiom system, which uses unconditional and conditional equalities,<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> and is complete for the algebra of regular languages. Two regular expressions <em>a</em> and <em>b</em> denote the same language if <em>a</em>=<em>b</em> follows from the <a href="#Definition" title="wikilink">above</a> axioms.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="generalization-or-relation-to-other-structures">Generalization (or relation to other structures)</h2>
<p>Kleene algebras are a particular case of <a href="closed_semiring" title="wikilink">closed semirings</a>, also called <a href="quasi-regular_semiring" title="wikilink">quasi-regular semirings</a> or <a href="Lehmann_semiring" title="wikilink">Lehmann semirings</a>, which are semirings in which every element has at least one quasi-inverse satisfying the equation: a* = aa* + 1 = a*a + 1. This quasi-inverse is not necessarily unique.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> In a Kleene algebra, a* is the least solution to the <a class="uri" href="fixpoint" title="wikilink">fixpoint</a> equations: X = aX + 1 and X = Xa + 1.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<p>Closed semirings and Kleene algebras appear in <a href="algebraic_path_problem" title="wikilink">algebraic path problems</a>, a generalization of the <a href="shortest_path" title="wikilink">shortest path</a> problem.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Action_algebra" title="wikilink">Action algebra</a></li>
<li><a href="Algebraic_structure" title="wikilink">Algebraic structure</a></li>
<li><a href="Kleene_star" title="wikilink">Kleene star</a></li>
<li><a href="Regular_expression" title="wikilink">Regular expression</a></li>
<li><a href="Star_semiring" title="wikilink">Star semiring</a></li>
<li><a href="Valuation_algebra" title="wikilink">Valuation algebra</a></li>
</ul>
<h2 id="notes-and-references">Notes and references</h2>
<ul>
<li></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>
<p>The introduction of this book reviews advances in the field of Kleene algebra made in the last 20 years, which are not discussed in the article above.</p></li>
</ul>
<p>"</p>
<p><a href="Category:Algebraic_structures" title="wikilink">Category:Algebraic structures</a> <a href="Category:Algebraic_logic" title="wikilink">Category:Algebraic logic</a> <a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a> <a href="Category:Many-valued_logic" title="wikilink">Category:Many-valued logic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">For a survey, see: <a href="#fnref2">↩</a></li>
<li id="fn3">Kozen (1990), sect.2.1, p.3<a href="#fnref3">↩</a></li>
<li id="fn4">.<a href="#fnref4">↩</a></li>
<li id="fn5">Kozen (1990), sect.2.1.2, p.5<a href="#fnref5">↩</a></li>
<li id="fn6"> Here: sect.7.2, p.52<a href="#fnref6">↩</a></li>
<li id="fn7"> Here: sect.7.2, p.26-27<a href="#fnref7">↩</a></li>
<li id="fn8">Kleene (1956), p.35<a href="#fnref8">↩</a></li>
<li id="fn9"> (In Russian)<a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"> Chap.IV.<a href="#fnref11">↩</a></li>
<li id="fn12"><mtpl></mtpl><a href="#fnref12">↩</a></li>
<li id="fn13">considering <em>a</em>≤<em>b</em> as an abbreviation for <em>a</em>+<em>b</em>=<em>b</em><a href="#fnref13">↩</a></li>
<li id="fn14"> — An earlier version appeared as: <a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
</ol>
</section>
</body>
</html>
