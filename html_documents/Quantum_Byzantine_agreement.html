<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="70">Quantum Byzantine agreement</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Quantum Byzantine agreement</h1>
<hr/>

<p><a href="Byzantine_fault_tolerance" title="wikilink">Byzantine fault tolerant</a> <a href="Protocol_(computing)" title="wikilink">protocols</a> are algorithms that are robust to arbitrary types of failures in <a href="distributed_algorithms" title="wikilink">distributed algorithms</a>. With the advent and popularity of the <a class="uri" href="Internet" title="wikilink">Internet</a>, there is a need to develop algorithms that do not require any centralized control that have some guarantee of always working correctly. The Byzantine agreement protocol is an essential part of this task. In this article the quantum version of the Byzantine protocol,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> which works in constant time is described.</p>
<h2 id="introduction">Introduction</h2>

<p>The <a href="Byzantine_fault_tolerance" title="wikilink">Byzantine Agreement</a> <a href="Communications_protocol" title="wikilink">protocol</a> is a protocol in <a href="distributed_computing" title="wikilink">distributed computing</a>. It takes its name from a problem formulated by Lamport, Shostak and Pease in 1982,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> which itself is a reference to a historical problem. The Byzantine army was divided into divisions with each division being led by a General with the following properties:</p>
<ul>
<li>Each General is either loyal or a traitor to the <a href="Byzantine" title="wikilink">Byzantine state</a>.</li>
<li>All Generals communicate by sending and receiving messages.</li>
<li>There are only two commands: attack and retreat.</li>
<li>All loyal Generals should agree on the same plan of action: attack or retreat.</li>
<li>A small linear fraction of bad Generals should not cause the protocol to fail (less than a 

<math display="inline" id="Quantum_Byzantine_agreement:0">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mn>3</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{3}
  </annotation>
 </semantics>
</math>

 fraction).</li>
</ul>

<p>(See <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> for the proof of the impossibility result). The problem usually is equivalently restated in the form of a commanding General and loyal Lieutenants with the General being either loyal or a traitor and the same for the Lieutenants with the following properties.</p>
<ul>
<li>All loyal Lieutenants carry out the same order.</li>
<li>If the commanding General is loyal, all loyal Lieutenants obey the order that he sends.</li>
<li>A strictly less than 

<math display="inline" id="Quantum_Byzantine_agreement:1">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mn>3</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{3}
  </annotation>
 </semantics>
</math>

 fraction including the commanding General are traitors.</li>
</ul>
<h2 id="byzantine-failure-and-resilience">Byzantine Failure and Resilience</h2>

<p>Failures in an <a class="uri" href="algorithm" title="wikilink">algorithm</a> or <a href="Communications_protocol" title="wikilink">protocol</a> can be categorized into three main types:</p>
<ol>
<li>A failure to take another execution step in the algorithm: This is usually referred to as a "fail stop" fault.</li>
<li>A random failure to execute correctly: This is called a "random fault" or "random Byzantine" fault.</li>
<li>An arbitrary failure where the algorithm fails to execute the steps correctly (usually in a clever way by some adversary to make the whole algorithm fail) which also encompasses the previous two types of faults; this is called a "Byzantine fault".</li>
</ol>

<p>A Byzantine resilient or <a href="Byzantine_fault_tolerance" title="wikilink">Byzantine fault tolerant</a> protocol or algorithm is an algorithm that is robust to all the kinds of failures mentioned above. For example, given a space shuttle with multiple redundant processors and some of the processors give incorrect data, which processors or sets of processors should be believed? The solution can be formulated as a <a href="Byzantine_fault_tolerance" title="wikilink">Byzantine fault tolerant</a> protocol.</p>
<h2 id="sketch-of-the-algorithm">Sketch of the Algorithm</h2>

<p>We will sketch here the asynchronous algorithm <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The algorithm works in two phases:</p>
<ul>
<li>Phase 1 (Communication phase):</li>
</ul>
<dl>
<dd>All messages are sent and received in this round.
</dd>
<dd>A coin flipping protocol is a procedure that allows two parties A and B that do not trust each other to toss a coin to win a particular object.
</dd>
</dl>

<p>There are two types of coin flipping protocols</p>
<ul>
<li><ul>
<li><a href="Quantum_Coin_Flipping" title="wikilink">weak coin flipping</a> protocols:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The two players A and B initially start with no inputs and they are to compute some value 

<math display="inline" id="Quantum_Byzantine_agreement:2">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mi>A</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>c</mi>
     <mi>B</mi>
    </msub>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>B</ci>
     </apply>
    </list>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{A},c_{B}\in[0,1]
  </annotation>
 </semantics>
</math>

 and be able to accuse anyone of cheating. The protocol is successful if A and B agree on the outcome. The outcome 0 is defined as A winning and 1 as B winning. The protocol has the following properties:
<ul>
<li>If both players are honest (they follow the protocol), then they agree on the outcome of the protocol 

<math display="inline" id="Quantum_Byzantine_agreement:3">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>A</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>c</mi>
    <mi>B</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{A}=c_{B}
  </annotation>
 </semantics>
</math>


 with 

<math display="inline" id="Quantum_Byzantine_agreement:4">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mi>A</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>c</mi>
     <mi>B</mi>
    </msub>
    <mo>=</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>A</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>B</ci>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Pr(c_{A}=c_{B}=b)=\frac{1}{2}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Quantum_Byzantine_agreement:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>a</ci>
     <ci>b</ci>
    </list>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a,b\in\{0,1\}
  </annotation>
 </semantics>
</math>

.</li>
<li>If one of the players is honest (i.e., the other player may deviate arbitrarily from the protocol in his or her local computation), then the other party wins with probability at most 

<math display="inline" id="Quantum_Byzantine_agreement:6">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
   <mo>+</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}+\epsilon
  </annotation>
 </semantics>
</math>

. In other words, if B is dishonest, then 

<math display="inline" id="Quantum_Byzantine_agreement:7">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mi>A</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>c</mi>
     <mi>B</mi>
    </msub>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≤</mo>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
   <mo>+</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>A</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>B</ci>
     </apply>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <leq></leq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <plus></plus>
    <csymbol cd="unknown">ϵ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Pr(c_{A}=c_{B}=1)\leq\frac{1}{2}+\epsilon
  </annotation>
 </semantics>
</math>

, and if A is dishonest, then 

<math display="inline" id="Quantum_Byzantine_agreement:8">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mi>A</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>c</mi>
     <mi>B</mi>
    </msub>
    <mo>=</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≤</mo>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
   <mo>+</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>A</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>B</ci>
     </apply>
     <eq></eq>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
    <leq></leq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <plus></plus>
    <csymbol cd="unknown">ϵ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Pr(c_{A}=c_{B}=0)\leq\frac{1}{2}+\epsilon
  </annotation>
 </semantics>
</math>


.</li>
</ul></li>
<li>A <a href="Quantum_Coin_Flipping" title="wikilink">strong coin flipping protocol</a>: In a strong coin flipping protocol, the goal is instead to produce a random bit which is biased away from any particular value 0 or 1. Clearly, any strong coin flipping protocol with bias 

<math display="inline" id="Quantum_Byzantine_agreement:9">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 leads to weak coin flipping with the same bias.</li>
</ul></li>
</ul>
<h3 id="verifiable-secret-sharing.">Verifiable secret sharing.</h3>
<ul>
<li>A <a href="verifiable_secret_sharing" title="wikilink">verifiable secret sharing</a> (VSS) protocol:<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> A (n,k) <a href="secret_sharing" title="wikilink">secret sharing</a> protocol allows a set of n players to share a secret, <em>s</em> such that only a quorum of k or more players can discover the secret. The player sharing (distributing the secret pieces) the secret is usually referred to as the dealer. A verifiable secret sharing protocol differs from a basic secret sharing protocol in that players can verify that their shares are consistent even in the presence of a malicious dealer.</li>
</ul>
<h3 id="the-fail-stop-protocol.">The Fail-stop protocol.</h3>
<h4 id="protocol-quantumcoinflip-for-player-p_i">Protocol QuantumCoinFlip for player 

<math display="inline" id="Quantum_Byzantine_agreement:10">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}
  </annotation>
 </semantics>
</math>

</h4>
<ol>
<li>Round 1 generate the state 

<math display="inline" id="Quantum_Byzantine_agreement:11">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mrow>
     <mi>C</mi>
     <mi>o</mi>
     <mi>i</mi>
     <msub>
      <mi>n</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msqrt>
       <mn>2</mn>
      </msqrt>
     </mfrac>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mrow>
       <mn>0</mn>
       <mo>,</mo>
       <mn>0</mn>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <mn>0</mn>
      </mrow>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msqrt>
       <mn>2</mn>
      </msqrt>
     </mfrac>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mrow>
       <mn>1</mn>
       <mo>,</mo>
       <mn>1</mn>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>o</ci>
      <ci>i</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <root></root>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <list>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
        <ci>normal-…</ci>
        <cn type="integer">0</cn>
       </list>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <root></root>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <list>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
        <ci>normal-…</ci>
        <cn type="integer">1</cn>
       </list>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |Coin_{i}\rangle=\frac{1}{\sqrt{2}}|0,0,\ldots,0\rangle+\frac{1}{\sqrt{2}}|1,1%
,\ldots,1\rangle
  </annotation>
 </semantics>
</math>

 on n <a class="uri" href="qubits" title="wikilink">qubits</a> and send the kth <a class="uri" href="qubit" title="wikilink">qubit</a> to the kth player keeping one part</li>
<li>Generate the state 

<math display="inline" id="Quantum_Byzantine_agreement:12">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mrow>
     <mi>L</mi>
     <mi>e</mi>
     <mi>a</mi>
     <mi>d</mi>
     <mi>e</mi>
     <msub>
      <mi>r</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msup>
      <mi>n</mi>
      <mrow>
       <mn>3</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>a</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <msup>
       <mi>n</mi>
       <mn>3</mn>
      </msup>
     </msubsup>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mrow>
       <mi>a</mi>
       <mo>,</mo>
       <mi>a</mi>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <mi>a</mi>
      </mrow>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>e</ci>
      <ci>a</ci>
      <ci>d</ci>
      <ci>e</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <apply>
        <divide></divide>
        <cn type="integer">3</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>a</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <list>
        <ci>a</ci>
        <ci>a</ci>
        <ci>normal-…</ci>
        <ci>a</ci>
       </list>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |Leader_{i}\rangle=\frac{1}{n^{3/2}}\sum_{a=1}^{n^{3}}|a,a,\ldots,a\rangle
  </annotation>
 </semantics>
</math>

 on <em>n</em> qubits, an equal superposition of the numbers between 1 and 

<math display="inline" id="Quantum_Byzantine_agreement:13">
 <semantics>
  <msup>
   <mi>n</mi>
   <mn>3</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{3}
  </annotation>
 </semantics>
</math>


.Distribute the <em>n</em> <a class="uri" href="qubits" title="wikilink">qubits</a> between all the players</li>
<li>Receive the quantum messages from all players and wait for the next communication round, thus forcing the adversary to choose which messages were passed.</li>
<li>Round 2: Measure (in the standard base) all 

<math display="inline" id="Quantum_Byzantine_agreement:14">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mi>e</mi>
   <mi>a</mi>
   <mi>d</mi>
   <mi>e</mi>
   <msub>
    <mi>r</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>e</ci>
    <ci>a</ci>
    <ci>d</ci>
    <ci>e</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Leader_{j}
  </annotation>
 </semantics>
</math>

 <a class="uri" href="qubits" title="wikilink">qubits</a> received in round I. Select the player with the highest leader value (ties broken arbitrarily) as the "leader" of the round. Measure the leader’s coin in the standard base.</li>
<li>Set the output of the QuantumCoinFlip protocol

<math display="block" id="Quantum_Byzantine_agreement:15">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

 = measurement outcome of the leader’s coin.</li>
</ol>
<h3 id="the-byzantine-protocol.">The Byzantine protocol.</h3>

<p>To generate a random coin assign an integer in the range [0,n-1] to each player and each player is not allowed to choose its own random ID as each player 

<math display="inline" id="Quantum_Byzantine_agreement:16">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{k}
  </annotation>
 </semantics>
</math>

 selects a random number 

<math display="inline" id="Quantum_Byzantine_agreement:17">
 <semantics>
  <mrow>
   <mi>s</mi>
   <msubsup>
    <mi></mi>
    <mi>k</mi>
    <mi>i</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <ci>i</ci>
     </apply>
     <ci>k</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s{{}_{k}^{i}}
  </annotation>
 </semantics>
</math>

 for every other player 

<math display="inline" id="Quantum_Byzantine_agreement:18">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}
  </annotation>
 </semantics>
</math>


 and distributes this using a verifiable secret sharing scheme.</p>

<p>At the end of this phase players agree on which secrets were properly shared, the secrets are then opened and each player 

<math display="inline" id="Quantum_Byzantine_agreement:19">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}
  </annotation>
 </semantics>
</math>

 is assigned the value 

<math display="inline" id="Quantum_Byzantine_agreement:20">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo largeop="true" rspace="4.2pt" symmetric="true">∑</mo>
     <mrow>
      <msubsup>
       <mi>s</mi>
       <mi>k</mi>
       <mi>i</mi>
      </msubsup>
      <mtext>for all secrets properly shared</mtext>
     </mrow>
    </mrow>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <sum></sum>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <ci>k</ci>
        </apply>
        <ci>i</ci>
       </apply>
       <mtext>for all secrets properly shared</mtext>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{i}=\sum\,{s_{k}^{i}}{\text{for all secrets properly shared}}\mod n
  </annotation>
 </semantics>
</math>

 This requires private information channels so we replace the random secrets by the superposition 

<math display="inline" id="Quantum_Byzantine_agreement:21">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mi>n</mi>
     </msqrt>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>a</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>a</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>ϕ</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>a</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <ci>a</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi\rangle=\frac{1}{\sqrt{n}}\sum_{a=0}^{n-1}|a\rangle
  </annotation>
 </semantics>
</math>

. In which the state is encoded using a quantum verifiable secret sharing protocol (QVSS).<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> We cannot distribute the state 

<math display="inline" id="Quantum_Byzantine_agreement:22">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mrow>
    <mi>ϕ</mi>
    <mo>,</mo>
    <mi>ϕ</mi>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">…</mi>
     <mi>ϕ</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <list>
     <ci>ϕ</ci>
     <ci>ϕ</ci>
     <apply>
      <times></times>
      <ci>normal-…</ci>
      <ci>ϕ</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi,\phi,\ldots\phi\rangle
  </annotation>
 </semantics>
</math>

 since the bad players can collapse the state. To prevent bad players from doing so we encode the state using the Quantum verifiable secret sharing (QVSS) and send each player their share of the secret. Here again the verification requires Byzantine Agreement, but replacing the agreement by the grade-cast protocol is enough.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h4 id="grade-cast-protocol">Grade-cast protocol</h4>

<p>A grade-cast protocol has the following properties using the definitions in <a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Informally, a graded <a href="Broadcasting_(computing)" title="wikilink">broadcast</a> protocol is a protocol with a designated player called “dealer” (the one who broadcasts) such that:</p>
<ol>
<li>If the dealer is good, all the players get the same message.</li>
<li>Even if the dealer is bad, if some good player accepts the message, all the good players get the same message (but they may or may not accept it).</li>
</ol>

<p>A protocol P is said to be achieve graded <a href="Broadcasting_(computing)" title="wikilink">broadcast</a> if, at the beginning of the protocol, a designated player D (called the dealer) holds a value v, and at the end of the protocol, every player 

<math display="inline" id="Quantum_Byzantine_agreement:23">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}
  </annotation>
 </semantics>
</math>


 outputs a pair 

<math display="inline" id="Quantum_Byzantine_agreement:24">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>v</mi>
    <mi>a</mi>
    <mi>l</mi>
    <mi>u</mi>
    <msub>
     <mi>e</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>c</mi>
    <mi>o</mi>
    <mi>n</mi>
    <mi>f</mi>
    <mi>i</mi>
    <mi>d</mi>
    <mi>e</mi>
    <mi>n</mi>
    <mi>c</mi>
    <msub>
     <mi>e</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>a</ci>
     <ci>l</ci>
     <ci>u</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>o</ci>
     <ci>n</ci>
     <ci>f</ci>
     <ci>i</ci>
     <ci>d</ci>
     <ci>e</ci>
     <ci>n</ci>
     <ci>c</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (value_{i},confidence_{i})
  </annotation>
 </semantics>
</math>

 such that the following properties hold: 

<math display="inline" id="Quantum_Byzantine_agreement:25">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>i</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>c</mi>
      <mi>o</mi>
      <mi>n</mi>
      <mi>f</mi>
      <mi>i</mi>
      <mi>d</mi>
      <mi>e</mi>
      <mi>n</mi>
      <mi>c</mi>
      <msub>
       <mi>e</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>o</ci>
      <ci>n</ci>
      <ci>f</ci>
      <ci>i</ci>
      <ci>d</ci>
      <ci>e</ci>
      <ci>n</ci>
      <ci>c</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </list>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall i,confidence_{i}\in\{0,1,2\})
  </annotation>
 </semantics>
</math>

</p>
<ol>
<li>If D is honest, then 

<math display="inline" id="Quantum_Byzantine_agreement:26">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mi>a</mi>
   <mi>l</mi>
   <mi>u</mi>
   <msub>
    <mi>e</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>v</ci>
    <ci>a</ci>
    <ci>l</ci>
    <ci>u</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   value_{i}
  </annotation>
 </semantics>
</math>

 = v and 

<math display="inline" id="Quantum_Byzantine_agreement:27">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mi>o</mi>
   <mi>n</mi>
   <mi>f</mi>
   <mi>i</mi>
   <mi>d</mi>
   <mi>e</mi>
   <mi>n</mi>
   <mi>c</mi>
   <msub>
    <mi>e</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <ci>o</ci>
    <ci>n</ci>
    <ci>f</ci>
    <ci>i</ci>
    <ci>d</ci>
    <ci>e</ci>
    <ci>n</ci>
    <ci>c</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   confidence_{i}
  </annotation>
 </semantics>
</math>

 = 2 for every honest player 

<math display="inline" id="Quantum_Byzantine_agreement:28">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}
  </annotation>
 </semantics>
</math>


.</li>
<li>For any two honest players 

<math display="inline" id="Quantum_Byzantine_agreement:29">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_Byzantine_agreement:30">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>j</mi>
   </msub>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{j},
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Quantum_Byzantine_agreement:31">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>c</mi>
      <mi>o</mi>
      <mi>n</mi>
      <mi>f</mi>
      <mi>i</mi>
      <mi>d</mi>
      <mi>e</mi>
      <mi>n</mi>
      <mi>c</mi>
      <msub>
       <mi>e</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>c</mi>
      <mi>o</mi>
      <mi>n</mi>
      <mi>f</mi>
      <mi>i</mi>
      <mi>d</mi>
      <mi>e</mi>
      <mi>n</mi>
      <mi>c</mi>
      <msub>
       <mi>e</mi>
       <mi>j</mi>
      </msub>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>≤</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>o</ci>
       <ci>n</ci>
       <ci>f</ci>
       <ci>i</ci>
       <ci>d</ci>
       <ci>e</ci>
       <ci>n</ci>
       <ci>c</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>o</ci>
       <ci>n</ci>
       <ci>f</ci>
       <ci>i</ci>
       <ci>d</ci>
       <ci>e</ci>
       <ci>n</ci>
       <ci>c</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |confidence_{i}-confidence_{j}|\leq 1
  </annotation>
 </semantics>
</math>

.</li>
<li>(Consistency) For any two honest players 

<math display="inline" id="Quantum_Byzantine_agreement:32">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_Byzantine_agreement:33">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{j}
  </annotation>
 </semantics>
</math>


, if 

<math display="inline" id="Quantum_Byzantine_agreement:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mi>o</mi>
    <mi>n</mi>
    <mi>f</mi>
    <mi>i</mi>
    <mi>d</mi>
    <mi>e</mi>
    <mi>n</mi>
    <mi>c</mi>
    <msub>
     <mi>e</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>o</ci>
     <ci>n</ci>
     <ci>f</ci>
     <ci>i</ci>
     <ci>d</ci>
     <ci>e</ci>
     <ci>n</ci>
     <ci>c</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   confidence_{i}>0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_Byzantine_agreement:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mi>o</mi>
    <mi>n</mi>
    <mi>f</mi>
    <mi>i</mi>
    <mi>d</mi>
    <mi>e</mi>
    <mi>n</mi>
    <mi>c</mi>
    <msub>
     <mi>e</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>o</ci>
     <ci>n</ci>
     <ci>f</ci>
     <ci>i</ci>
     <ci>d</ci>
     <ci>e</ci>
     <ci>n</ci>
     <ci>c</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   confidence_{j}>0
  </annotation>
 </semantics>
</math>

,then 

<math display="inline" id="Quantum_Byzantine_agreement:36">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mi>a</mi>
    <mi>l</mi>
    <mi>u</mi>
    <msub>
     <mi>e</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>v</mi>
    <mi>a</mi>
    <mi>l</mi>
    <mi>u</mi>
    <msub>
     <mi>e</mi>
     <mi>j</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>a</ci>
     <ci>l</ci>
     <ci>u</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>a</ci>
     <ci>l</ci>
     <ci>u</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   value_{i}=value_{j}
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>For 

<math display="inline" id="Quantum_Byzantine_agreement:37">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo><</mo>
   <mfrac>
    <mi>n</mi>
    <mn>4</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>t</ci>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t<\frac{n}{4}
  </annotation>
 </semantics>
</math>

 the verification stage of the QVSS protocol guarantees that for a good dealer the correct state will be encoded, and that for any, possibly faulty dealer, some particular state will be recovered during the recovery stage. We note that for the purpose of our Byzantine quantum coin flip protocol the recovery stage is much simpler. Each player measures his share of the QVSS and sends the classical value to all other players. The verification stage guarantees, with high probability, that in the presence of up to 

<math display="inline" id="Quantum_Byzantine_agreement:38">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo><</mo>
   <mfrac>
    <mi>n</mi>
    <mn>4</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>t</ci>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t<\frac{n}{4}
  </annotation>
 </semantics>
</math>


 faulty players all the good players will recover the same classical value (which is the same value that would result from a direct measurement of the encoded state).</p>
<h2 id="remarks">Remarks</h2>

<p>In 2007, a quantum protocol for Byzantine Agreement was demonstrated experimentally <a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> using a four-photon polarization-entangled state. This shows that the quantum implementation of classical Byzantine Agreement protocols is indeed feasible.</p>
<h2 id="references">References</h2>

<p><a href="ru:Задача_византийских_генералов" title="wikilink">ru:Задача византийских генералов</a> <a href="uk:Задача_візантійських_генералів" title="wikilink">uk:Задача візантійських генералів</a>"</p>

<p><a href="Category:Quantum_mechanics" title="wikilink">Category:Quantum mechanics</a> <a class="uri" href="Category:Cryptography" title="wikilink">Category:Cryptography</a> <a href="Category:Distributed_computing_problems" title="wikilink">Category:Distributed computing problems</a> <a href="Category:Fault_tolerance" title="wikilink">Category:Fault tolerance</a> <a class="uri" href="Category:Failure" title="wikilink">Category:Failure</a> <a href="Category:Theory_of_computation" title="wikilink">Category:Theory of computation</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Michael Ben-Or and Avinatan Hassidim, Fast quantum byzantine agreement,STOC '05: Proceedings of the thirty-seventh annual ACM symposium on Theory of computing, pg 481-485 [2005]<a href="#fnref1">↩</a></li>
<li id="fn2">L. Lamport and R. Shostak and M. Pease, The <a class="uri" href="Byzantine" title="wikilink">Byzantine</a> Generals Problem, ACM Trans. Program. Lang. Syst., volume 4, number 3, pg 382-401 [1982]<a href="#fnref2">↩</a></li>
<li id="fn3">Michael J. Fisher, Nancy A. Lynch,Michael S. Paterson,Impossibility of Distributed Consensus with One Faulty Process, Journal of the ACM volume 32, issue=2, pg 374-382 <a href="http://portal.acm.org/citation.cfm?doid=3149.214121">Impossibility of Distributed Consensus with One Faulty Process</a>[1985]<a href="#fnref3">↩</a></li>
<li id="fn4">Michael Ben-Or and Avinatan Hassidim, Fast quantum byzantine agreement, STOC '05: Proceedings of the thirty-seventh annual ACM symposium on Theory of computing, pg 481-485 [2005]<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="http://arxiv.org/abs/quant-ph/0206121v2">I. Kerenidis, A. Nayak, coin flipping with small bias, arxiv</a><a href="#fnref5">↩</a></li>
<li id="fn6">Verifiable secret sharing <a href="verifiable_secret_sharing" title="wikilink">verifiable secret sharing</a><a href="#fnref6">↩</a></li>
<li id="fn7">Claude Cr´epeau, Daniel Gottesman and Adam Smith, Secure Multi-party Quantum Computation, In 34th ACM Symposium on the Theory of Computing, STOC, pg. 643–652, [2002]<a href="#fnref7">↩</a></li>
<li id="fn8">Michael Ben-Or, Elan Pavlov, Vinod Vaikuntanathan, Byzantine Agreement in the Full-Information Model in O(log n) Rounds, STOC '06: Proceedings of the thirty-eighth annual ACM symposium on Theory of computing, pg 179-186 [2006]<a href="#fnref8">↩</a></li>
<li id="fn9">Pesech Feldman and Silvio Micali. An optimal probabilistic protocol for synchronous byzantine agreement. SIAM J. Comput., pg 873–933, [1997]<a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11">Sascha Gaertner, Mohamed Bourennane, Christian Kurtsiefer, Adán Cabello, Harald Weinfurter, Experimental Demonstration of a Quantum Protocol for Byzantine Agreement and Liar Detection, <a href="http://arxiv.org/abs/0710.0290v2">arXiv:0710.0290v2</a>, [2007], <a href="http://link.aps.org/doi/10.1103/PhysRevLett.100.070504">Phys. Rev. Lett. 100 (2008) 070504</a>.<a href="#fnref11">↩</a></li>
</ol>
</section>
</body>
</html>
