<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1522">Las Vegas algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Las Vegas algorithm</h1>
<hr>In [[computing]], a '''Las Vegas algorithm''' is a [[randomized algorithm]] that always gives [[correctness (computer science)|correct]] result
<p>s; that is, it always produces the correct result or it informs about the failure. In other words, a Las Vegas algorithm does not gamble with the correctness of the result; it gambles only with the resources used for the computation. A simple example is randomized <a class="uri" href="quicksort" title="wikilink">quicksort</a>, where the pivot is chosen randomly, but the result is always sorted. The usual definition of a Las Vegas algorithm includes the restriction that the <em>expected</em> run time always be finite, when the expectation is carried out over the space of random information, or entropy, used in the algorithm. An alternative definition requires that a Las Vegas algorithm always terminate (be <a href="Effective_method" title="wikilink">effective</a>), but it may output a <a href="Partial_function#Bottom_type" title="wikilink">symbol not part of the solution space</a> to indicate failure in finding a solution.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Las Vegas algorithms were introduced by <a href="László_Babai" title="wikilink">László Babai</a> in 1979, in the context of the <a href="graph_isomorphism_problem" title="wikilink">graph isomorphism problem</a>, as a stronger version of <a href="Monte_Carlo_algorithm" title="wikilink">Monte Carlo algorithms</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Las Vegas algorithms can be used in situations where the number of possible solutions is relatively limited, and where verifying the correctness of a candidate solution is relatively easy while actually calculating the solution is complex.</p>

<p>The name refers to the city of <a href="Las_Vegas,_Nevada" title="wikilink">Las Vegas, Nevada</a>, which is well known within the United States as an icon of gambling.</p>
<h2 id="complexity-class">Complexity class</h2>

<p>The <a href="complexity_class" title="wikilink">complexity class</a> of <a href="decision_problem" title="wikilink">decision problems</a> that have Las Vegas algorithms with <a href="expected_value" title="wikilink">expected</a> polynomial runtime is <strong><a href="Zero-error_Probabilistic_Polynomial_time" title="wikilink"> ZPP</a></strong>.</p>

<p>It turns out that</p>

<p>

<math display="block" id="Las_Vegas_algorithm:0">
 <semantics>
  <mrow>
   <mrow>
    <mtext>ZPP</mtext>
    <mo>=</mo>
    <mrow>
     <mtext>RP</mtext>
     <mo rspace="4.2pt">∩</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mtext>co</mtext>
      </mpadded>
      <mtext>-RP</mtext>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>ZPP</mtext>
    <apply>
     <intersect></intersect>
     <mtext>RP</mtext>
     <apply>
      <times></times>
      <mtext>co</mtext>
      <mtext>-RP</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textrm{ZPP}=\textrm{RP}\cap\,\text{co}\,\textrm{-RP},\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>which is intimately connected with the way Las Vegas algorithms are sometimes constructed. Namely the class <strong><a href="RP_(complexity)" title="wikilink">RP</a></strong> consists of all decision problems for which a randomized polynomial-time algorithm exists that always answers correctly when the correct answer is "no", but is allowed to be wrong with a certain probability bounded away from one when the answer is "yes". When such an algorithm exists for both a problem and its complement (with the answers "yes" and "no" swapped), the two algorithms can be run simultaneously and repeatedly: run each for a constant number of steps, taking turns, until one of them returns a definitive answer. This is the standard way to construct a Las Vegas algorithm that runs in expected polynomial time. Note that in general there is no worst case upper bound on the run time of a Las Vegas algorithm.</p>
<h2 id="relation-to-monte-carlo-algorithms">Relation to Monte Carlo algorithms</h2>

<p>Las Vegas algorithms can be contrasted with <a href="Monte_Carlo_algorithm" title="wikilink">Monte Carlo algorithms</a>, in which the resources used are bounded but the answer is not guaranteed to always be correct. By an application of <a href="Markov's_inequality" title="wikilink">Markov's inequality</a>, a Las Vegas algorithm can be converted into a Monte Carlo algorithm via early termination.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Randomness" title="wikilink">Randomness</a></li>
<li><a href="Atlantic_City_algorithm" title="wikilink">Atlantic City algorithm</a></li>
<li><a href="Monte_Carlo_algorithm" title="wikilink">Monte Carlo algorithm</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li><em>Algorithms and Theory of Computation Handbook</em>, CRC Press LLC, 1999, "Las Vegas algorithm", in <em>Dictionary of Algorithms and Data Structures</em> [online], Paul E. Black, ed., U.S. <a href="National_Institute_of_Standards_and_Technology" title="wikilink">National Institute of Standards and Technology</a>. 17 July 2006. (accessed May 09, 2009) Available from: <a href="http://www.nist.gov/dads/HTML/lasVegas.html">1</a></li>
</ul>

<p>"</p>

<p><a href="Category:Randomized_algorithms" title="wikilink">Category:Randomized algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="László_Babai" title="wikilink">László Babai</a>, <a href="http://people.cs.uchicago.edu/~laci/lasvegas79.pdf">Monte-Carlo algorithms in graph isomorphism testing</a>, Université de Montréal, D.M.S. No. 79-10.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="Leonid_Levin" title="wikilink">Leonid Levin</a>, <a href="http://arxiv.org/abs/cs.CR/0012023">The Tale of One-way Functions</a>, <em>Problems of Information Transmission</em>, vol. 39 (2003), 92-103.<a href="#fnref3">↩</a></li>
<li id="fn4">Dan Grundy, <a href="http://www.cs.kent.ac.uk/people/staff/eab2/crypto/thesis.web.pdf">Concepts and Calculation in Cryptography</a>, University of Kent, Ph.D. thesis, 2008<a href="#fnref4">↩</a></li>
</ol>
</section>
</hr></body>
</html>
