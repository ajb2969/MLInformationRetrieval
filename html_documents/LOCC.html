<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="327">LOCC</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>LOCC</h1>
<hr/>

<p><strong>LOCC</strong>, or <strong>Local Operations and Classical Communication</strong>, is a method in <a href="quantum_information_theory" title="wikilink">quantum information theory</a> where a local (product) operation is performed on part of the system, and where the result of that operation is "communicated" classically to another part where usually another local operation is performed. An example of this is distinguishing two <a href="Bell_state" title="wikilink">Bell pairs</a>, such as the following:</p>
<figure><b>(Figure)</b>
<figcaption>LOCC paradigm: the parties are not allowed to exchange particles coherently. Only Local operations and classical communication is allowed</figcaption>
</figure>

<p>

<math display="block" id="LOCC:0">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>ψ</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mn>2</mn>
     </msqrt>
    </mfrac>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <msub>
        <mrow>
         <mo fence="true" stretchy="false">|</mo>
         <mn>0</mn>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <mi>A</mi>
       </msub>
       <mo>⊗</mo>
       <msub>
        <mrow>
         <mo fence="true" stretchy="false">|</mo>
         <mn>0</mn>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <mi>B</mi>
       </msub>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mrow>
         <mo fence="true" stretchy="false">|</mo>
         <mn>1</mn>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <mi>A</mi>
       </msub>
       <mo>⊗</mo>
       <msub>
        <mrow>
         <mo fence="true" stretchy="false">|</mo>
         <mn>1</mn>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <mi>B</mi>
       </msub>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ψ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">0</cn>
        </apply>
        <ci>A</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">0</cn>
        </apply>
        <ci>B</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">1</cn>
        </apply>
        <ci>A</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">1</cn>
        </apply>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi_{1}\rangle=\frac{1}{\sqrt{2}}\left(|0\rangle_{A}\otimes|0\rangle_{B}+|1%
\rangle_{A}\otimes|1\rangle_{B}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="LOCC:1">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>ψ</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mn>2</mn>
     </msqrt>
    </mfrac>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <msub>
        <mrow>
         <mo fence="true" stretchy="false">|</mo>
         <mn>0</mn>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <mi>A</mi>
       </msub>
       <mo>⊗</mo>
       <msub>
        <mrow>
         <mo fence="true" stretchy="false">|</mo>
         <mn>1</mn>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <mi>B</mi>
       </msub>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mrow>
         <mo fence="true" stretchy="false">|</mo>
         <mn>1</mn>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <mi>A</mi>
       </msub>
       <mo>⊗</mo>
       <msub>
        <mrow>
         <mo fence="true" stretchy="false">|</mo>
         <mn>0</mn>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <mi>B</mi>
       </msub>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ψ</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">0</cn>
        </apply>
        <ci>A</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">1</cn>
        </apply>
        <ci>B</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">1</cn>
        </apply>
        <ci>A</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">0</cn>
        </apply>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi_{2}\rangle=\frac{1}{\sqrt{2}}\left(|0\rangle_{A}\otimes|1\rangle_{B}+|1%
\rangle_{A}\otimes|0\rangle_{B}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>Let's say the two-<a class="uri" href="qubit" title="wikilink">qubit</a> system is separated, where the first qubit is given to Alice and the second is given to Bob. Assume that Alice measures the first qubit, and obtains the result 0. We still don't know which Bell pair we were given. Alice sends the result to Bob over a classical channel, where Bob measures the second qubit, also obtaining 0. Bob now knows that since the joint measurement outcome is 

<math display="inline" id="LOCC:2">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mn>0</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>A</mi>
   </msub>
   <mo>⊗</mo>
   <msub>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mn>0</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>B</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">0</cn>
     </apply>
     <ci>A</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">0</cn>
     </apply>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |0\rangle_{A}\otimes|0\rangle_{B}
  </annotation>
 </semantics>
</math>

, then the pair given was 

<math display="inline" id="LOCC:3">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>ψ</mi>
    <mn>1</mn>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ψ</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi_{1}\rangle
  </annotation>
 </semantics>
</math>

.</p>

<p>These measurements contrasts with <a href="Quantum_nonlocality" title="wikilink">nonlocal</a> or <a href="Quantum_entanglement" title="wikilink">entangled</a> measurements, where a single measurement is performed in 

<math display="inline" id="LOCC:4">
 <semantics>
  <msup>
   <mi>ℂ</mi>
   <mrow>
    <mn>2</mn>
    <mi>n</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℂ</ci>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}^{2n}
  </annotation>
 </semantics>
</math>

 instead of the product space 

<math display="inline" id="LOCC:5">
 <semantics>
  <mrow>
   <msup>
    <mi>ℂ</mi>
    <mn>2</mn>
   </msup>
   <mo>⊗</mo>
   <msup>
    <mi>ℂ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℂ</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℂ</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{C}^{2}\otimes\mathbb{C}^{n}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="entanglement-manipulation">Entanglement manipulation</h2>

<p>Nielsen <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> has derived a general condition to determine whether one pure state of a bipartite quantum system may be transformed into another using only LOCC. Full details may be found in the paper referenced earlier, the results are sketched out here.</p>

<p>Consider two particles in a <a href="Hilbert_spaces" title="wikilink">Hilbert space</a> of dimension 

<math display="inline" id="LOCC:6">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 with particle states 

<math display="inline" id="LOCC:7">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ψ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="LOCC:8">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ϕ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi\rangle
  </annotation>
 </semantics>
</math>

 with <a href="Schmidt_decomposition" title="wikilink">Schmidt decompositions</a></p>

<p>

<math display="block" id="LOCC:9">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>ψ</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <mrow>
      <msqrt>
       <msub>
        <mi>λ</mi>
        <mi>i</mi>
       </msub>
      </msqrt>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <msub>
        <mi>i</mi>
        <mi>A</mi>
       </msub>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo>⊗</mo>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <msub>
       <mi>i</mi>
       <mi>B</mi>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>ψ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <times></times>
       <apply>
        <root></root>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>i</ci>
         <ci>A</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle=\sum_{i}\sqrt{\lambda_{i}}|i_{A}\rangle\otimes|i_{B}\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="LOCC:10">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <mrow>
      <msqrt>
       <msubsup>
        <mi>λ</mi>
        <mi>i</mi>
        <mo>′</mo>
       </msubsup>
      </msqrt>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <msubsup>
        <mi>i</mi>
        <mi>A</mi>
        <mo>′</mo>
       </msubsup>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo>⊗</mo>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <msubsup>
       <mi>i</mi>
       <mi>B</mi>
       <mo>′</mo>
      </msubsup>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>ϕ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <times></times>
       <apply>
        <root></root>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>λ</ci>
          <ci>i</ci>
         </apply>
         <ci>normal-′</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>i</ci>
          <ci>A</ci>
         </apply>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>i</ci>
         <ci>B</ci>
        </apply>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi\rangle=\sum_{i}\sqrt{\lambda_{i}^{\prime}}|i_{A}^{\prime}\rangle\otimes|%
i_{B}^{\prime}\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>The 

<math display="inline" id="LOCC:11">
 <semantics>
  <msqrt>
   <msub>
    <mi>λ</mi>
    <mi>i</mi>
   </msub>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{\lambda_{i}}
  </annotation>
 </semantics>
</math>

's are known as <a href="Schmidt_decomposition" title="wikilink">Schmidt coefficients</a>. If they are ordered largest to smallest (i.e. with 

<math display="inline" id="LOCC:12">
 <semantics>
  <mrow>
   <msub>
    <mi>λ</mi>
    <mn>1</mn>
   </msub>
   <mo>></mo>
   <msub>
    <mi>λ</mi>
    <mi>d</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{1}>\lambda_{d}
  </annotation>
 </semantics>
</math>

) then 

<math display="inline" id="LOCC:13">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ψ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle
  </annotation>
 </semantics>
</math>

 can only be transformed into 

<math display="inline" id="LOCC:14">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ϕ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi\rangle
  </annotation>
 </semantics>
</math>

 using only local operations if and only if for all 

<math display="inline" id="LOCC:15">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 in the range 

<math display="inline" id="LOCC:16">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>k</mi>
   <mo>≤</mo>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>k</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq k\leq d
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="LOCC:17">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>k</mi>
    </munderover>
    <msub>
     <mi>λ</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>k</mi>
    </munderover>
    <msubsup>
     <mi>λ</mi>
     <mi>i</mi>
     <mo>′</mo>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{k}\lambda_{i}\leq\sum_{i=1}^{k}\lambda_{i}^{\prime}
  </annotation>
 </semantics>
</math>

</p>

<p>In more concise notation:</p>

<p>

<math display="block" id="LOCC:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mi>ψ</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>ϕ</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mtext>iff</mtext>
    </mrow>
   </mrow>
   <mrow>
    <mi>λ</mi>
    <mo>≺</mo>
    <msup>
     <mi>λ</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>ψ</ci>
     </apply>
     <list>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <ci>ϕ</ci>
      </apply>
      <mtext>iff</mtext>
     </list>
    </apply>
    <apply>
     <csymbol cd="latexml">precedes</csymbol>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>λ</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle\rightarrow|\phi\rangle\quad\text{iff}\quad\lambda\prec\lambda^{\prime}
  </annotation>
 </semantics>
</math>

</p>

<p>This is a more restrictive condition that local operations cannot increase the degree of entanglement. It is quite possible that converting between 

<math display="inline" id="LOCC:19">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ψ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="LOCC:20">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ϕ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi\rangle
  </annotation>
 </semantics>
</math>

 in either direction is impossible because neither set of Schmidt coefficients <a href="Majorization" title="wikilink">majorises</a> the other. For large 

<math display="inline" id="LOCC:21">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 if all <a href="Schmidt_decomposition" title="wikilink">Schmidt coefficients</a> are non-zero then the probability of one set of coefficients <a href="Majorization" title="wikilink">majorising</a> the other becomes negligible. Therefore for large 

<math display="inline" id="LOCC:22">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 the probability of any arbitrary state being converted into another becomes negligible.</p>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="further-reading">Further reading</h2>
<ul>
<li><em><a class="uri" href="http://www.quantiki.org/wiki/index.php/LOCC_operations">http://www.quantiki.org/wiki/index.php/LOCC_operations</a></em></li>
<li>M. A. Nielsen, “Conditions for a class of entanglement transformations”, Phys. Rev. Lett. 83 (2) 436-439 (1999) (<em><a class="uri" href="http://arxiv.org/abs/quant-ph/9811053">http://arxiv.org/abs/quant-ph/9811053</a></em>)</li>
</ul>

<p>"</p>

<p><a href="Category:Quantum_information_science" title="wikilink">Category:Quantum information science</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Phys. Rev. Lett. 83, 436 - 439 (1999)<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
