<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1800">Double counting (proof technique)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Double counting (proof technique)</h1>
<hr/>

<p>In <a class="uri" href="combinatorics" title="wikilink">combinatorics</a>, <strong>double counting</strong>, also called <strong>counting in two ways</strong>, is a <a href="combinatorial_proof" title="wikilink">combinatorial proof</a> technique for showing that two expressions are equal by demonstrating that they are two ways of counting the size of one <a href="Set_(mathematics)" title="wikilink">set</a>. In this technique, which  call “one of the most important tools in combinatorics,” one describes a finite set <em>X</em> from two perspectives leading to two distinct expressions for the size of the set. Since both expressions equal the size of the same set, they equal each other.</p>
<h2 id="examples">Examples</h2>
<h3 id="forming-committees">Forming committees</h3>

<p>One example of the double counting method counts the number of ways in which a committee can be formed from <em>n</em> people, allowing any number of the people (even zero of them) to be part of the committee. That is, one counts the number of subsets that an <em>n</em>-element set may have. One method for forming a committee is to ask each person to choose whether or not to join it. Each person has two choices – yes or no – and these choices are independent of those of the other people. Therefore there are 2 × 2 × ... × 2 = 2<sup><em>n</em></sup> possibilities. Alternatively, one may observe that the size of the committee must be some number between 0 and <em>n</em>. For each possible size <em>k</em>, the number of ways in which a committee of <em>k</em> people can be formed from <em>n</em> people is the <a href="binomial_coefficient" title="wikilink">binomial coefficient</a></p>

<p>

<math display="block" id="Double_counting_(proof_technique):0">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mi>n</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mi>k</mi>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">binomial</csymbol>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {n\choose k}.
  </annotation>
 </semantics>
</math>

 Therefore the total number of possible committees is the sum of binomial coefficients over <em>k</em> = 0, 1, 2, ... <em>n</em>. Equating the two expressions gives the <a href="Identity_(mathematics)" title="wikilink">identity</a></p>

<p>

<math display="block" id="Double_counting_(proof_technique):1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <mo>(</mo>
      <mtable columnspacing="0.4em" rowspacing="0.2ex">
       <mtr>
        <mtd>
         <mi>n</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd>
         <mi>k</mi>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mn>2</mn>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">binomial</csymbol>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{k=0}^{n}{n\choose k}=2^{n},
  </annotation>
 </semantics>
</math>

 a special case of the <a href="binomial_theorem" title="wikilink">binomial theorem</a>. A similar double counting method can be used to prove the more general identity</p>

<p>

<math display="block" id="Double_counting_(proof_technique):2">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mi>d</mi>
     </mrow>
     <mi>n</mi>
    </munderover>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mtable columnspacing="0.4em" rowspacing="0.2ex">
       <mtr>
        <mtd>
         <mi>n</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd>
         <mi>k</mi>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mtable columnspacing="0.4em" rowspacing="0.2ex">
       <mtr>
        <mtd>
         <mi>k</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd>
         <mi>d</mi>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mi>d</mi>
     </mrow>
    </msup>
    <mrow>
     <mo>(</mo>
     <mtable columnspacing="0.4em" rowspacing="0.2ex">
      <mtr>
       <mtd>
        <mi>n</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mi>d</mi>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <ci>d</ci>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">binomial</csymbol>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">binomial</csymbol>
       <ci>k</ci>
       <ci>d</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <ci>d</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">binomial</csymbol>
      <ci>n</ci>
      <ci>d</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{k=d}^{n}{n\choose k}{k\choose d}=2^{n-d}{n\choose d}
  </annotation>
 </semantics>
</math>

 (; ).</p>
<h3 id="handshaking-lemma">Handshaking lemma</h3>

<p>Another theorem that is commonly proven with a double counting argument states that every <a href="undirected_graph" title="wikilink">undirected graph</a> contains an even number of vertices of odd <a href="Degree_(graph_theory)" title="wikilink">degree</a>. That is, the number of vertices that have an odd number of incident edges must be even. In more colloquial terms, in a party of people some of whom shake hands, an even number of people must have shaken an odd number of other people's hands; for this reason, the result is known as the <a href="handshaking_lemma" title="wikilink">handshaking lemma</a>.</p>

<p>To prove this by double counting, let <em>d(v)</em> be the degree of vertex <em>v</em>. The number of vertex-edge incidences in the graph may be counted in two different ways: by summing the degrees of the vertices, or by counting two incidences for every edge. Therefore</p>

<p>

<math display="block" id="Double_counting_(proof_technique):3">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>v</mi>
    </munder>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mpadded width="+1.7pt">
     <mi>e</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>v</ci>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{v}d(v)=2e\,
  </annotation>
 </semantics>
</math>

 where <em>e</em> is the number of edges. The sum of the degrees of the vertices is therefore an <a href="even_number" title="wikilink">even number</a>, which could not happen if an odd number of the vertices had odd degree. This fact, with this proof, appears in the 1736 paper of <a href="Leonhard_Euler" title="wikilink">Leonhard Euler</a> on the <a href="Seven_Bridges_of_Königsberg" title="wikilink">Seven Bridges of Königsberg</a> that first began the study of <a href="graph_theory" title="wikilink">graph theory</a>.</p>
<h3 id="counting-trees">Counting trees</h3>

<p>  What is the number <em>T<sub>n</sub></em> of different <a href="tree_(graph_theory)" title="wikilink">trees</a> that can be formed from a set of <em>n</em> distinct vertices? <a href="Cayley's_formula" title="wikilink">Cayley's formula</a> gives the answer <mtpl> <em>n</em><sup><em>n</em> − 2</sup>}}</mtpl>.  list four proofs of this fact; they write of the fourth, a double counting proof due to Jim Pitman, that it is “the most beautiful of them all.”</p>

<p>Pitman's proof counts in two different ways the number of different sequences of directed edges that can be added to an <a href="empty_graph" title="wikilink">empty graph</a> on <em>n</em> vertices to form from it a rooted tree. One way to form such a sequence is to start with one of the <em>T<sub>n</sub></em> possible unrooted trees, choose one of its <em>n</em> vertices as root, and choose one of the  possible sequences in which to add its  (directed) edges. Therefore, the total number of sequences that can be formed in this way is <mtpl> <em>T<sub>n</sub>n</em>!}}</mtpl>.</p>

<p>Another way to count these edge sequences is to consider adding the edges one by one to an empty graph, and to count the number of choices available at each step. If one has added a collection of  edges already, so that the graph formed by these edges is a rooted forest with <em>k</em> trees, there are  choices for the next edge to add: its starting vertex can be any one of the <em>n</em> vertices of the graph, and its ending vertex can be any one of the  roots other than the root of the tree containing the starting vertex. Therefore, if one multiplies together the number of choices from the first step, the second step, etc., the total number of choices is</p>

<p>

<math display="block" id="Double_counting_(proof_technique):4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>2</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <mrow>
      <mi>n</mi>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <factorial></factorial>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <factorial></factorial>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \prod_{k=2}^{n}n(k-1)=n^{n-1}(n-1)!=n^{n-2}n!.
  </annotation>
 </semantics>
</math>

 Equating these two formulas for the number of edge sequences results in Cayley's formula:</p>

<p>

<math display="block" id="Double_counting_(proof_technique):5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>T</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mi>n</mi>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>n</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
    </msup>
    <mrow>
     <mi>n</mi>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <factorial></factorial>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <factorial></factorial>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle T_{n}n!=n^{n-2}n!
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Double_counting_(proof_technique):6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>T</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <msup>
     <mi>n</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle T_{n}=n^{n-2}.
  </annotation>
 </semantics>
</math>

 As Aigner and Ziegler describe, the formula and the proof can be generalized to count the number of rooted forests with <em>k</em> trees, for any <em>k</em>.</p>
<h2 id="see-also">See also</h2>
<h3 id="additional-examples">Additional examples</h3>
<ul>
<li><a href="Vandermonde's_identity" title="wikilink">Vandermonde's identity</a>, another identity on sums of binomial coefficients that can be proven by double counting.</li>
<li><a href="Square_pyramidal_number" title="wikilink">Square pyramidal number</a>. The equality between the sum of the first <em>n</em> square numbers and a cubic polynomial can be shown by double counting the triples of numbers <em>x</em>, <em>y</em>, and <em>z</em> where <em>z</em> is larger than either of the other two numbers.</li>
<li><a href="Lubell–Yamamoto–Meshalkin_inequality" title="wikilink">Lubell–Yamamoto–Meshalkin inequality</a>. Lubell's proof of this result on set families is a double counting argument on permutations, used to prove an inequality rather than an equality.</li>
<li><a href="Proofs_of_Fermat's_little_theorem" title="wikilink">Proofs of Fermat's little theorem</a>. A <a class="uri" href="divisibility" title="wikilink">divisibility</a> proof by double counting: for any prime <em>p</em> and natural number <em>A</em>, there are <mtpl></mtpl> length-<em>p</em> words over an <em>A</em>-symbol alphabet having two or more distinct symbols. These may be grouped into sets of <em>p</em> words that can be transformed into each other by <a href="circular_shift" title="wikilink">circular shifts</a>; these sets are called <a href="necklace_(combinatorics)" title="wikilink">necklaces</a>. Therefore, <mtpl> <em>p</em> × (number}}</mtpl> of necklaces) and is divisible by <em>p</em>.</li>
<li><a href="Proofs_of_quadratic_reciprocity" title="wikilink">Proofs of quadratic reciprocity</a>. A proof by <a href="Gotthold_Eisenstein" title="wikilink">Eisenstein</a> derives another important <a href="number_theory" title="wikilink">number-theoretic</a> fact by double counting lattice points in a triangle.</li>
</ul>
<h3 id="related-topics">Related topics</h3>
<ul>
<li><a href="Bijective_proof" title="wikilink">Bijective proof</a>. Where double counting involves counting one set in two ways, bijective proofs involve counting two sets in one way, by showing that their elements correspond one-for-one.</li>
<li>The <a href="inclusion-exclusion_principle" title="wikilink">inclusion-exclusion principle</a>, a formula for the size of a union of sets that may, together with another formula for the same union, be used as part of a double counting argument.</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>

<p>. Double counting is described as a general principle on page 126; Pitman's double counting proof of Cayley's formula is on pp. 145–146.</p></li>
<li>

<p>. Reprinted and translated in .</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Enumerative_combinatorics" title="wikilink">Category:Enumerative combinatorics</a> <a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a> <a href="Category:Mathematical_proofs" title="wikilink">Category:Mathematical proofs</a></p>
</body>
</html>
