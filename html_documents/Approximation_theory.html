<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1649">Approximation theory</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Approximation theory</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <strong>approximation theory</strong> is concerned with how <a href="function_(mathematics)" title="wikilink">functions</a> can best be <a href="approximation" title="wikilink">approximated</a> with simpler <a href="function_(mathematics)" title="wikilink">functions</a>, and with <a href="Quantitative_property" title="wikilink">quantitatively</a> <a href="characterization_(mathematics)" title="wikilink">characterizing</a> the <a href="approximation_error" title="wikilink">errors</a> introduced thereby. Note that what is meant by <em>best</em> and <em>simpler</em> will depend on the application.</p>

<p>A closely related topic is the approximation of functions by <a href="generalized_Fourier_series" title="wikilink">generalized Fourier series</a>, that is, approximations based upon summation of a series of terms based upon <a href="orthogonal_polynomials" title="wikilink">orthogonal polynomials</a>.</p>

<p>One problem of particular interest is that of approximating a function in a <a class="uri" href="computer" title="wikilink">computer</a> mathematical library, using operations that can be performed on the computer or calculator (e.g. addition and multiplication), such that the result is as close to the actual function as possible. This is typically done with <a class="uri" href="polynomial" title="wikilink">polynomial</a> or <a href="Rational_function" title="wikilink">rational</a> (ratio of polynomials) approximations.</p>

<p>The objective is to make the approximation as close as possible to the actual function, typically with an accuracy close to that of the underlying computer's <a href="floating_point" title="wikilink">floating point</a> arithmetic. This is accomplished by using a polynomial of high <a href="Degree_of_a_polynomial" title="wikilink">degree</a>, and/or narrowing the domain over which the polynomial has to approximate the function. Narrowing the domain can often be done through the use of various addition or scaling formulas for the function being approximated. Modern mathematical libraries often reduce the domain into many tiny segments and use a low-degree polynomial for each segment.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Error between optimal polynomial and log(x) (red), and Chebyshev approximation and log(x) (blue) over the interval [2, 4]. Vertical divisions are 10<sup>−5</sup>. Maximum error for the optimal polynomial is 6.07 x 10<sup>−5</sup>.</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Error between optimal polynomial and exp(x) (red), and Chebyshev approximation and exp(x) (blue) over the interval [−1, 1]. Vertical divisions are 10<sup>−4</sup>. Maximum error for the optimal polynomial is 5.47 x 10<sup>−4</sup>.</figcaption>
</figure></td>
</tr>
</tbody>
</table>
<h2 id="optimal-polynomials">Optimal polynomials</h2>

<p>Once the domain (typically an interval) and degree of the polynomial are chosen, the polynomial itself is chosen in such a way as to minimize the worst-case error. That is, the goal is to minimize the maximum value of 

<math display="inline" id="Approximation_theory:0">
 <semantics>
  <mrow>
   <mo>∣</mo>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>∣</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-∣∣</csymbol>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mid P(x)-f(x)\mid
  </annotation>
 </semantics>
</math>

, where <em>P</em>(<em>x</em>) is the approximating polynomial, <em>f</em>(<em>x</em>) is the actual function, and <em>x</em> varies over the chosen interval. For well-behaved functions, there exists an <em>N</em><span style="padding-left:0.1em;">th</span>-degree polynomial that will lead to an error curve that oscillates back and forth between 

<math display="inline" id="Approximation_theory:1">
 <semantics>
  <mrow>
   <mo>+</mo>
   <mi>ε</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>ε</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   +\varepsilon
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Approximation_theory:2">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mi>ε</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>ε</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\varepsilon
  </annotation>
 </semantics>
</math>

 a total of <em>N</em>+2 times, giving a worst-case error of 

<math display="inline" id="Approximation_theory:3">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

. It is seen that an <em>N</em><span style="padding-left:0.1em;">th</span>-degree polynomial can interpolate <em>N</em>+1 points in a curve. Such a polynomial is always optimal. It is possible to make contrived functions <em>f</em>(<em>x</em>) for which no such polynomial exists, but these occur rarely in practice.</p>

<p>For example, the graphs shown to the right show the error in approximating log(x) and exp(x) for <em>N</em> = 4. The red curves, for the optimal polynomial, are <strong>level</strong>, that is, they oscillate between 

<math display="inline" id="Approximation_theory:4">
 <semantics>
  <mrow>
   <mo>+</mo>
   <mi>ε</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>ε</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   +\varepsilon
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Approximation_theory:5">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mi>ε</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>ε</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\varepsilon
  </annotation>
 </semantics>
</math>

 exactly. Note that, in each case, the number of extrema is <em>N</em>+2, that is, 6. Two of the extrema are at the end points of the interval, at the left and right edges of the graphs.</p>

<p> To prove this is true in general, suppose <em>P</em> is a polynomial of degree <em>N</em> having the property described, that is, it gives rise to an error function that has <em>N</em> + 2 extrema, of alternating signs and equal magnitudes. The red graph to the right shows what this error function might look like for <em>N</em> = 4. Suppose <em>Q</em>(<em>x</em>) (whose error function is shown in blue to the right) is another <em>N</em>-degree polynomial that is a better approximation to <em>f</em> than <em>P</em>. In particular, <em>Q</em> is closer to <em>f</em> than <em>P</em> for each value <em>x<sub>i</sub></em> where an extreme of <em>P</em>−<em>f</em> occurs, so</p>

<p>

<math display="block" id="Approximation_theory:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mrow>
       <mi>Q</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo><</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>Q</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |Q(x_{i})-f(x_{i})|<|P(x_{i})-f(x_{i})|.
  </annotation>
 </semantics>
</math>

 When a maximum of <em>P</em>−<em>f</em> occurs at <em>x<sub>i</sub></em>, then</p>

<p>

<math display="block" id="Approximation_theory:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>Q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mrow>
       <mi>Q</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo><</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>Q</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>Q</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <abs></abs>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>P</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x_{i})-f(x_{i})\leq|Q(x_{i})-f(x_{i})|<|P(x_{i})-f(x_{i})|=P(x_{i})-f(x_{i}),
  </annotation>
 </semantics>
</math>

 And when a minimum of <em>P</em>−<em>f</em> occurs at <em>x<sub>i</sub></em>, then</p>

<p>

<math display="block" id="Approximation_theory:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>Q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mrow>
       <mi>Q</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo><</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mrow>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>Q</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>Q</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <abs></abs>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>P</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{i})-Q(x_{i})\leq|Q(x_{i})-f(x_{i})|<|P(x_{i})-f(x_{i})|=f(x_{i})-P(x_{i}).
  </annotation>
 </semantics>
</math>

 So, as can be seen in the graph, [<em>P</em>(<em>x</em>) − <em>f</em>(<em>x</em>)] − [<em>Q</em>(<em>x</em>) − <em>f</em>(<em>x</em>)] must alternate in sign for the <em>N</em> + 2 values of <em>x<sub>i</sub></em>. But [<em>P</em>(<em>x</em>) − <em>f</em>(<em>x</em>)] − [<em>Q</em>(<em>x</em>) − <em>f</em>(<em>x</em>)] reduces to <em>P</em>(<em>x</em>) − <em>Q</em>(<em>x</em>) which is a polynomial of degree <em>N</em>. This function changes sign at least <em>N</em>+1 times so, by the <a href="Intermediate_value_theorem" title="wikilink">Intermediate value theorem</a>, it has <em>N</em>+1 zeroes, which is impossible for a polynomial of degree <em>N</em>.</p>
<h2 id="chebyshev-approximation">Chebyshev approximation</h2>

<p>One can obtain polynomials very close to the optimal one by expanding the given function in terms of <a href="Chebyshev_polynomials" title="wikilink">Chebyshev polynomials</a> and then cutting off the expansion at the desired degree. This is similar to the <a href="Harmonic_analysis" title="wikilink">Fourier analysis</a> of the function, using the Chebyshev polynomials instead of the usual trigonometric functions.</p>

<p>If one calculates the coefficients in the Chebyshev expansion for a function:</p>

<p>

<math display="block" id="Approximation_theory:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∼</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>T</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <ci>i</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)\sim\sum_{i=0}^{\infty}c_{i}T_{i}(x)
  </annotation>
 </semantics>
</math>

</p>

<p>and then cuts off the series after the 

<math display="inline" id="Approximation_theory:10">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>N</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{N}
  </annotation>
 </semantics>
</math>

 term, one gets an <em>N</em><span style="padding-left:0.1em;">th</span>-degree polynomial approximating <em>f</em>(<em>x</em>).</p>

<p>The reason this polynomial is nearly optimal is that, for functions with rapidly converging power series, if the series is cut off after some term, the total error arising from the cutoff is close to the first term after the cutoff. That is, the first term after the cutoff dominates all later terms. The same is true if the expansion is in terms of Chebyshev polynomials. If a Chebyshev expansion is cut off after 

<math display="inline" id="Approximation_theory:11">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>N</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{N}
  </annotation>
 </semantics>
</math>

, the error will take a form close to a multiple of 

<math display="inline" id="Approximation_theory:12">
 <semantics>
  <msub>
   <mi>T</mi>
   <mrow>
    <mi>N</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <apply>
     <plus></plus>
     <ci>N</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{N+1}
  </annotation>
 </semantics>
</math>

. The Chebyshev polynomials have the property that they are level – they oscillate between +1 and −1 in the interval [−1, 1]. 

<math display="inline" id="Approximation_theory:13">
 <semantics>
  <msub>
   <mi>T</mi>
   <mrow>
    <mi>N</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <apply>
     <plus></plus>
     <ci>N</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{N+1}
  </annotation>
 </semantics>
</math>

 has <em>N</em>+2 level extrema. This means that the error between <em>f</em>(<em>x</em>) and its Chebyshev expansion out to 

<math display="inline" id="Approximation_theory:14">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>N</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{N}
  </annotation>
 </semantics>
</math>

 is close to a level function with <em>N</em>+2 extrema, so it is close to the optimal <em>N</em><span style="padding-left:0.1em;">th</span>-degree polynomial.</p>

<p>In the graphs above, note that the blue error function is sometimes better than (inside of) the red function, but sometimes worse, meaning that it is not quite the optimal polynomial. Note also that the discrepancy is less serious for the exp function, which has an extremely rapidly converging power series, than for the log function.</p>

<p>Chebyshev approximation is the basis for <a href="Clenshaw–Curtis_quadrature" title="wikilink">Clenshaw–Curtis quadrature</a>, a <a href="numerical_integration" title="wikilink">numerical integration</a> technique.</p>
<h2 id="remez-algorithm">Remez' algorithm</h2>

<p>The <a href="Remez_algorithm" title="wikilink">Remez algorithm</a> (sometimes spelled Remes) is used to produce an optimal polynomial <em>P</em>(<em>x</em>) approximating a given function <em>f</em>(<em>x</em>) over a given interval. It is an iterative algorithm that converges to a polynomial that has an error function with <em>N</em>+2 level extrema. By the theorem above, that polynomial is optimal.</p>

<p>Remez' algorithm uses the fact that one can construct an <em>N</em><span style="padding-left:0.1em;">th</span>-degree polynomial that leads to level and alternating error values, given <em>N</em>+2 test points.</p>

<p>Given <em>N</em>+2 test points 

<math display="inline" id="Approximation_theory:15">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Approximation_theory:16">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}
  </annotation>
 </semantics>
</math>

, ... 

<math display="inline" id="Approximation_theory:17">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>N</mi>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>N</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{N+2}
  </annotation>
 </semantics>
</math>

 (where 

<math display="inline" id="Approximation_theory:18">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Approximation_theory:19">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>N</mi>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>N</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{N+2}
  </annotation>
 </semantics>
</math>

 are presumably the end points of the interval of approximation), these equations need to be solved:</p>

<p>

<math display="block" id="Approximation_theory:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>+</mo>
    <mpadded width="+1.7pt">
     <mi>ε</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>ε</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x_{1})-f(x_{1})=+\varepsilon\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Approximation_theory:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mpadded width="+1.7pt">
     <mi>ε</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <ci>ε</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x_{2})-f(x_{2})=-\varepsilon\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Approximation_theory:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>3</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>3</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>+</mo>
    <mpadded width="+1.7pt">
     <mi>ε</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>ε</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x_{3})-f(x_{3})=+\varepsilon\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Approximation_theory:23">
 <semantics>
  <mi mathvariant="normal">⋮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⋮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdots
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Approximation_theory:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mrow>
         <mi>N</mi>
         <mo>+</mo>
         <mn>2</mn>
        </mrow>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mrow>
         <mi>N</mi>
         <mo>+</mo>
         <mn>2</mn>
        </mrow>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>±</mo>
     <mi>ε</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <ci>N</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <ci>N</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">plus-or-minus</csymbol>
     <ci>ε</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x_{N+2})-f(x_{N+2})=\pm\varepsilon.\,
  </annotation>
 </semantics>
</math>

</p>

<p>The right-hand sides alternate in sign.</p>

<p>That is,</p>

<p>

<math display="block" id="Approximation_theory:25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>P</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>P</mi>
       <mn>2</mn>
      </msub>
      <msubsup>
       <mi>x</mi>
       <mn>1</mn>
       <mn>2</mn>
      </msubsup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>P</mi>
       <mn>3</mn>
      </msub>
      <msubsup>
       <mi>x</mi>
       <mn>1</mn>
       <mn>3</mn>
      </msubsup>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">…</mi>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>P</mi>
       <mi>N</mi>
      </msub>
      <msubsup>
       <mi>x</mi>
       <mn>1</mn>
       <mi>N</mi>
      </msubsup>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>+</mo>
    <mpadded width="+1.7pt">
     <mi>ε</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>N</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>ε</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{0}+P_{1}x_{1}+P_{2}x_{1}^{2}+P_{3}x_{1}^{3}+\dots+P_{N}x_{1}^{N}-f(x_{1})=+\varepsilon\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Approximation_theory:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>P</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>P</mi>
       <mn>2</mn>
      </msub>
      <msubsup>
       <mi>x</mi>
       <mn>2</mn>
       <mn>2</mn>
      </msubsup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>P</mi>
       <mn>3</mn>
      </msub>
      <msubsup>
       <mi>x</mi>
       <mn>2</mn>
       <mn>3</mn>
      </msubsup>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">…</mi>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>P</mi>
       <mi>N</mi>
      </msub>
      <msubsup>
       <mi>x</mi>
       <mn>2</mn>
       <mi>N</mi>
      </msubsup>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mpadded width="+1.7pt">
     <mi>ε</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>N</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <ci>ε</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{0}+P_{1}x_{2}+P_{2}x_{2}^{2}+P_{3}x_{2}^{3}+\dots+P_{N}x_{2}^{N}-f(x_{2})=-\varepsilon\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Approximation_theory:27">
 <semantics>
  <mi mathvariant="normal">⋮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⋮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdots
  </annotation>
 </semantics>
</math>

</p>

<p>Since 

<math display="inline" id="Approximation_theory:28">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

, ..., 

<math display="inline" id="Approximation_theory:29">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>N</mi>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>N</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{N+2}
  </annotation>
 </semantics>
</math>

 were given, all of their powers are known, and 

<math display="inline" id="Approximation_theory:30">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{1})
  </annotation>
 </semantics>
</math>

, ..., 

<math display="inline" id="Approximation_theory:31">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>N</mi>
      <mo>+</mo>
      <mn>2</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>N</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{N+2})
  </annotation>
 </semantics>
</math>

 are also known. That means that the above equations are just <em>N</em>+2 linear equations in the <em>N</em>+2 variables 

<math display="inline" id="Approximation_theory:32">
 <semantics>
  <msub>
   <mi>P</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{0}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Approximation_theory:33">
 <semantics>
  <msub>
   <mi>P</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1}
  </annotation>
 </semantics>
</math>

, ..., 

<math display="inline" id="Approximation_theory:34">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>N</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{N}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Approximation_theory:35">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

. Given the test points 

<math display="inline" id="Approximation_theory:36">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

, ..., 

<math display="inline" id="Approximation_theory:37">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>N</mi>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>N</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{N+2}
  </annotation>
 </semantics>
</math>

, one can solve this system to get the polynomial <em>P</em> and the number 

<math display="inline" id="Approximation_theory:38">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

.</p>

<p>The graph below shows an example of this, producing a fourth-degree polynomial approximating 

<math display="inline" id="Approximation_theory:39">
 <semantics>
  <msup>
   <mi>e</mi>
   <mi>x</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>e</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{x}
  </annotation>
 </semantics>
</math>

 over [−1, 1]. The test points were set at −1, −0.7, −0.1, +0.4, +0.9, and 1. Those values are shown in green. The resultant value of 

<math display="inline" id="Approximation_theory:40">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

 is 4.43 x 10<sup>−4</sup></p>
<figure><b>(Figure)</b>
<figcaption>Error of the polynomial produced by the first step of Remez' algorithm, approximating e<sup>x</sup> over the interval [−1, 1]. Vertical divisions are 10<sup>−4</sup>.</figcaption>
</figure>

<p>Note that the error graph does indeed take on the values 

<math display="inline" id="Approximation_theory:41">
 <semantics>
  <mrow>
   <mo>±</mo>
   <mi>ε</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">plus-or-minus</csymbol>
    <ci>ε</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pm\varepsilon
  </annotation>
 </semantics>
</math>

 at the six test points, including the end points, but that those points are not extrema. If the four interior test points had been extrema (that is, the function <em>P</em>(<em>x</em>)<em>f</em>(<em>x</em>) had maxima or minima there), the polynomial would be optimal.</p>

<p>The second step of Remez' algorithm consists of moving the test points to the approximate locations where the error function had its actual local maxima or minima. For example, one can tell from looking at the graph that the point at −0.1 should have been at about −0.28. The way to do this in the algorithm is to use a single round of <a href="Newton's_method" title="wikilink">Newton's method</a>. Since one knows the first and second derivatives of <em>P</em>(<em>x</em>)−<em>f</em>(<em>x</em>), one can calculate approximately how far a test point has to be moved so that the derivative will be zero.</p>

<p>Calculating the derivatives of a polynomial is straightforward. One must also be able to calculate the first and second derivatives of <em>f</em>(<em>x</em>). Remez' algorithm requires an ability to calculate 

<math display="inline" id="Approximation_theory:42">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)\,
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Approximation_theory:43">
 <semantics>
  <mrow>
   <msup>
    <mi>f</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(x)\,
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Approximation_theory:44">
 <semantics>
  <mrow>
   <msup>
    <mi>f</mi>
    <mi>′′</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <ci>′′</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime\prime}(x)\,
  </annotation>
 </semantics>
</math>

 to extremely high precision. The entire algorithm must be carried out to higher precision than the desired precision of the result.</p>

<p>After moving the test points, the linear equation part is repeated, getting a new polynomial, and Newton's method is used again to move the test points again. This sequence is continued until the result converges to the desired accuracy. The algorithm converges very rapidly. Convergence is quadratic for well-behaved functions—if the test points are within 

<math display="inline" id="Approximation_theory:45">
 <semantics>
  <msup>
   <mn>10</mn>
   <mrow>
    <mo>-</mo>
    <mn>15</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">10</cn>
    <apply>
     <minus></minus>
     <cn type="integer">15</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   10^{-15}
  </annotation>
 </semantics>
</math>

 of the correct result, they will be approximately within 

<math display="inline" id="Approximation_theory:46">
 <semantics>
  <msup>
   <mn>10</mn>
   <mrow>
    <mo>-</mo>
    <mn>30</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">10</cn>
    <apply>
     <minus></minus>
     <cn type="integer">30</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   10^{-30}
  </annotation>
 </semantics>
</math>

 of the correct result after the next round.</p>

<p>Remez' algorithm is typically started by choosing the extrema of the Chebyshev polynomial 

<math display="inline" id="Approximation_theory:47">
 <semantics>
  <msub>
   <mi>T</mi>
   <mrow>
    <mi>N</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <apply>
     <plus></plus>
     <ci>N</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{N+1}
  </annotation>
 </semantics>
</math>

 as the initial points, since the final error function will be similar to that polynomial.</p>
<h2 id="main-journals">Main journals</h2>
<ul>
<li><a href="Journal_of_Approximation_Theory" title="wikilink">Journal of Approximation Theory</a></li>
<li><a href="Constructive_Approximation" title="wikilink">Constructive Approximation</a></li>
<li><a href="East_Journal_on_Approximations" title="wikilink">East Journal on Approximations</a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Chebyshev_polynomials" title="wikilink">Chebyshev polynomials</a></li>
<li><a href="Estimation_theory" title="wikilink">Estimation theory</a></li>
<li><a href="Generalized_Fourier_series" title="wikilink">Generalized Fourier series</a></li>
<li><a href="Orthogonal_polynomials" title="wikilink">Orthogonal polynomials</a></li>
<li><a href="Orthonormal_basis" title="wikilink">Orthonormal basis</a></li>
<li><a href="Fourier_series" title="wikilink">Fourier series</a></li>
<li><a href="Schauder_basis" title="wikilink">Schauder basis</a></li>
<li><a href="Padé_approximant" title="wikilink">Padé approximant</a></li>
<li><a href="Function_approximation" title="wikilink">Function approximation</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>N. I. Achiezer (Akhiezer), Theory of approximation, Translated by Charles J. Hyman Frederick Ungar Publishing Co., New York 1956 x+307 pp.</li>
<li>A. F. Timan, <em>Theory of approximation of functions of a real variable</em>, 1963 ISBN 0-486-67830-X</li>
<li>C. Hastings, Jr. <em>Approximations for Digital Computers</em>. Princeton University Press, 1955.</li>
<li>J. F. Hart, E. W. Cheney, C. L. Lawson, H. J. Maehly, C. K. Mesztenyi, <a href="John_R._Rice_(professor)" title="wikilink">J. R. Rice</a>, H. C. Thacher Jr., C. Witzgall, <em>Computer Approximations</em>. Wiley, 1968, Lib. Cong. 67-23326.</li>
<li>L. Fox and I. B. Parker. "Chebyshev Polynomials in Numerical Analysis." Oxford University Press London, 1968.</li>
<li></li>
<li>W. J. Cody Jr., W. Waite, <em>Software Manual for the Elementary Functions</em>. Prentice-Hall, 1980, ISBN 0-13-822064-6.</li>
<li>E. Remes [Remez], "Sur le calcul effectif des polynomes d'approximation de Tschebyscheff". 1934 <em>C. R. Acad. Sci.</em>, Paris, <strong>199</strong>, 337-340.</li>
<li>K.-G. Steffens, "The History of Approximation Theory: From Euler to Bernstein," Birkhauser, Boston 2006 ISBN 0-8176-4353-2.</li>
<li><a href="Tamas_Erdelyi_(mathematician)" title="wikilink">T. Erdélyi</a>, "Extensions of the Bloch-Pólya theorem on the number of distinct real zeros of polynomials", <em>Journal de théorie des nombres de Bordeaux</em> <strong>20</strong> (2008), 281–287.</li>
<li>T. Erdélyi, "The Remez inequality for linear combinations of shifted Gaussians", <em>Math. Proc. Cambridge Phil. Soc.</em> <strong>146</strong> (2009), 523–530.</li>
<li>L. N. Trefethen, "Approximation theory and approximation practice", SIAM 2013. <a href="http://www2.maths.ox.ac.uk/chebfun/ATAP/">1</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.math.technion.ac.il/hat/">History of Approximation Theory (HAT)</a></li>
<li><a href="http://www.emis.de/journals/SAT/">Surveys in Approximation Theory (SAT)</a></li>
</ul>

<p>"</p>

<p><a href="Category:Approximation_theory" title="wikilink">*</a> <a href="Category:Numerical_analysis" title="wikilink">Category:Numerical analysis</a></p>
</body>
</html>
