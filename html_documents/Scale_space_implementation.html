<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="326">Scale space implementation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Scale space implementation</h1>
<hr/>

<p>The <strong>linear <a href="scale_space" title="wikilink">scale-space representation</a></strong> of an <em>N</em>-dimensional continuous signal,</p>

<p>

<math display="block" id="Scale_space_implementation:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi>C</mi>
    </msub>
    <mrow>
     <mo>(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>N</mi>
     </msub>
     <mo>,</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>C</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>N</ci>
     </apply>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{C}\left(x_{1},\cdots,x_{N},t\right),
  </annotation>
 </semantics>
</math>

</p>

<p>is obtained by <a href="convolution" title="wikilink">convolving</a> <em>f<sub>C</sub></em> with an <em>N</em>-dimensional Gaussian kernel:</p>

<p>

<math display="block" id="Scale_space_implementation:1">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>g</mi>
     <mi>N</mi>
    </msub>
    <mrow>
     <mo>(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>N</mi>
     </msub>
     <mo>,</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <ci>N</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>N</ci>
     </apply>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{N}\left(x_{1},\cdots,x_{N},t\right).
  </annotation>
 </semantics>
</math>

</p>

<p>In other words:</p>

<p>

<math display="block" id="Scale_space_implementation:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo>(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>N</mi>
      </msub>
      <mo>,</mo>
      <mi>t</mi>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <msub>
        <mi>u</mi>
        <mn>1</mn>
       </msub>
       <mo>=</mo>
       <mrow>
        <mo>-</mo>
        <mi mathvariant="normal">∞</mi>
       </mrow>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mi mathvariant="normal">⋯</mi>
      <mrow>
       <msubsup>
        <mo largeop="true" symmetric="true">∫</mo>
        <mrow>
         <msub>
          <mi>u</mi>
          <mi>N</mi>
         </msub>
         <mo>=</mo>
         <mrow>
          <mo>-</mo>
          <mi mathvariant="normal">∞</mi>
         </mrow>
        </mrow>
        <mi mathvariant="normal">∞</mi>
       </msubsup>
       <mrow>
        <mrow>
         <mrow>
          <msub>
           <mi>f</mi>
           <mi>C</mi>
          </msub>
          <mrow>
           <mo>(</mo>
           <mrow>
            <msub>
             <mi>x</mi>
             <mn>1</mn>
            </msub>
            <mo>-</mo>
            <msub>
             <mi>u</mi>
             <mn>1</mn>
            </msub>
           </mrow>
           <mo>,</mo>
           <mi mathvariant="normal">⋯</mi>
           <mo>,</mo>
           <mrow>
            <msub>
             <mi>x</mi>
             <mi>N</mi>
            </msub>
            <mo>-</mo>
            <msub>
             <mi>u</mi>
             <mi>N</mi>
            </msub>
           </mrow>
           <mo>,</mo>
           <mi>t</mi>
           <mo>)</mo>
          </mrow>
         </mrow>
         <mo>⋅</mo>
         <msub>
          <mi>g</mi>
          <mi>N</mi>
         </msub>
        </mrow>
        <mrow>
         <mo>(</mo>
         <msub>
          <mi>u</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <mi mathvariant="normal">⋯</mi>
         <mo>,</mo>
         <msub>
          <mi>u</mi>
          <mi>N</mi>
         </msub>
         <mo>,</mo>
         <mi>t</mi>
         <mo rspace="4.2pt">)</mo>
        </mrow>
        <mi>d</mi>
        <msub>
         <mi>u</mi>
         <mn>1</mn>
        </msub>
        <mi mathvariant="normal">⋯</mi>
        <mi>d</mi>
        <msub>
         <mi>u</mi>
         <mi>N</mi>
        </msub>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>N</ci>
      </apply>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>normal-⋯</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <apply>
          <eq></eq>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>u</ci>
           <ci>N</ci>
          </apply>
          <apply>
           <minus></minus>
           <infinity></infinity>
          </apply>
         </apply>
        </apply>
        <infinity></infinity>
       </apply>
       <apply>
        <times></times>
        <apply>
         <ci>normal-⋅</ci>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <ci>C</ci>
          </apply>
          <vector>
           <apply>
            <minus></minus>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <cn type="integer">1</cn>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>u</ci>
             <cn type="integer">1</cn>
            </apply>
           </apply>
           <ci>normal-⋯</ci>
           <apply>
            <minus></minus>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>N</ci>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>u</ci>
             <ci>N</ci>
            </apply>
           </apply>
           <ci>t</ci>
          </vector>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>g</ci>
          <ci>N</ci>
         </apply>
        </apply>
        <vector>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>u</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-⋯</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>u</ci>
          <ci>N</ci>
         </apply>
         <ci>t</ci>
        </vector>
        <ci>d</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-⋯</ci>
        <ci>d</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>N</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\left(x_{1},\cdots,x_{N},t\right)=\int_{u_{1}=-\infty}^{\infty}\cdots\int_{u_%
{N}=-\infty}^{\infty}f_{C}\left(x_{1}-u_{1},\cdots,x_{N}-u_{N},t\right)\cdot g%
_{N}\left(u_{1},\cdots,u_{N},t\right)\,du_{1}\cdots du_{N}.
  </annotation>
 </semantics>
</math>

</p>

<p>However, for <strong>implementation</strong>, this definition is impractical, since it is continuous. When applying the scale space concept to a discrete signal <em>f<sub>D</sub></em>, different approaches can be taken. This article is a brief summary of some of the most frequently used methods.</p>
<h2 id="separability">Separability</h2>

<p>Using the <em>separability property</em> of the Gaussian kernel</p>

<p>

<math display="block" id="Scale_space_implementation:3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>g</mi>
     <mi>N</mi>
    </msub>
    <mrow>
     <mo>(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>N</mi>
     </msub>
     <mo>,</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo>(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
    <mi mathvariant="normal">⋯</mi>
    <mi>G</mi>
    <mrow>
     <mo>(</mo>
     <msub>
      <mi>x</mi>
      <mi>N</mi>
     </msub>
     <mo>,</mo>
     <mi>t</mi>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>N</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>N</ci>
      </apply>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>G</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>t</ci>
     </interval>
     <ci>normal-⋯</ci>
     <ci>G</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>N</ci>
      </apply>
      <ci>t</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{N}\left(x_{1},\dots,x_{N},t\right)=G\left(x_{1},t\right)\cdots G\left(x_{N}%
,t\right)
  </annotation>
 </semantics>
</math>

</p>

<p>the <em>N</em>-dimensional <a class="uri" href="convolution" title="wikilink">convolution</a> operation can be decomposed into a set of separable smoothing steps with a one-dimensional Gaussian kernel <em>G</em> along each dimension</p>

<p>

<math display="block" id="Scale_space_implementation:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>N</mi>
      </msub>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <msub>
        <mi>u</mi>
        <mn>1</mn>
       </msub>
       <mo>=</mo>
       <mrow>
        <mo>-</mo>
        <mi mathvariant="normal">∞</mi>
       </mrow>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mi mathvariant="normal">⋯</mi>
      <mrow>
       <msubsup>
        <mo largeop="true" symmetric="true">∫</mo>
        <mrow>
         <msub>
          <mi>u</mi>
          <mi>N</mi>
         </msub>
         <mo>=</mo>
         <mrow>
          <mo>-</mo>
          <mi mathvariant="normal">∞</mi>
         </mrow>
        </mrow>
        <mi mathvariant="normal">∞</mi>
       </msubsup>
       <mrow>
        <msub>
         <mi>f</mi>
         <mi>C</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mi>x</mi>
           <mn>1</mn>
          </msub>
          <mo>-</mo>
          <msub>
           <mi>u</mi>
           <mn>1</mn>
          </msub>
         </mrow>
         <mo>,</mo>
         <mi mathvariant="normal">⋯</mi>
         <mo>,</mo>
         <mrow>
          <msub>
           <mi>x</mi>
           <mi>N</mi>
          </msub>
          <mo>-</mo>
          <msub>
           <mi>u</mi>
           <mi>N</mi>
          </msub>
         </mrow>
         <mo>,</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>G</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>u</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <mi>t</mi>
         <mo rspace="4.2pt" stretchy="false">)</mo>
        </mrow>
        <mi>d</mi>
        <msub>
         <mi>u</mi>
         <mn>1</mn>
        </msub>
        <mi mathvariant="normal">⋯</mi>
        <mi>G</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>u</mi>
          <mi>N</mi>
         </msub>
         <mo>,</mo>
         <mi>t</mi>
         <mo rspace="4.2pt" stretchy="false">)</mo>
        </mrow>
        <mi>d</mi>
        <msub>
         <mi>u</mi>
         <mi>N</mi>
        </msub>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>N</ci>
      </apply>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>normal-⋯</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <apply>
          <eq></eq>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>u</ci>
           <ci>N</ci>
          </apply>
          <apply>
           <minus></minus>
           <infinity></infinity>
          </apply>
         </apply>
        </apply>
        <infinity></infinity>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>C</ci>
        </apply>
        <vector>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>u</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>normal-⋯</ci>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>N</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>u</ci>
           <ci>N</ci>
          </apply>
         </apply>
         <ci>t</ci>
        </vector>
        <ci>G</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>u</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>t</ci>
        </interval>
        <ci>d</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-⋯</ci>
        <ci>G</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>u</ci>
          <ci>N</ci>
         </apply>
         <ci>t</ci>
        </interval>
        <ci>d</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>N</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(x_{1},\cdots,x_{N},t)=\int_{u_{1}=-\infty}^{\infty}\cdots\int_{u_{N}=-\infty%
}^{\infty}f_{C}(x_{1}-u_{1},\cdots,x_{N}-u_{N},t)G(u_{1},t)\,du_{1}\cdots G(u_%
{N},t)\,du_{N},
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Scale_space_implementation:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
       <mi>t</mi>
      </mrow>
     </msqrt>
    </mfrac>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mfrac>
       <msup>
        <mi>x</mi>
        <mn>2</mn>
       </msup>
       <mrow>
        <mn>2</mn>
        <mi>t</mi>
       </mrow>
      </mfrac>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>t</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(x,t)=\frac{1}{\sqrt{2\pi t}}e^{-\frac{x^{2}}{2t}}
  </annotation>
 </semantics>
</math>

</p>

<p>and the standard deviation of the Gaussian σ is related to the scale parameter <em>t</em> according to <em>t</em> = σ<sup>2</sup>.</p>

<p>Separability will be assumed in all that follows, even when the kernel is not exactly Gaussian, since separation of the dimensions is the most practical way to implement multidimensional smoothing, especially at larger scales. Therefore, <strong>the rest of the article focuses on the one-dimensional case.</strong></p>
<h2 id="the-sampled-gaussian-kernel">The sampled Gaussian kernel</h2>

<p>When implementing the one-dimensional smoothing step in practice, the presumably simplest approach is to convolve the discrete signal <em>f<sub>D</sub></em> with a <em>sampled Gaussian kernel</em>:</p>

<p>

<math display="block" id="Scale_space_implementation:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mi>n</mi>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>t</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <ci>G</ci>
      <interval closure="open">
       <ci>n</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(x,t)=\sum_{n=-\infty}^{\infty}f(x-n)\,G(n,t)
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Scale_space_implementation:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
       <mi>t</mi>
      </mrow>
     </msqrt>
    </mfrac>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mfrac>
       <msup>
        <mi>n</mi>
        <mn>2</mn>
       </msup>
       <mrow>
        <mn>2</mn>
        <mi>t</mi>
       </mrow>
      </mfrac>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <interval closure="open">
      <ci>n</ci>
      <ci>t</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(n,t)=\frac{1}{\sqrt{2\pi t}}e^{-\frac{n^{2}}{2t}}
  </annotation>
 </semantics>
</math>

</p>

<p>(with <em>t</em> = σ<sup>2</sup>) which in turn is truncated at the ends to give a filter with finite impulse response</p>

<p>

<math display="block" id="Scale_space_implementation:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mrow>
       <mo>-</mo>
       <mi>M</mi>
      </mrow>
     </mrow>
     <mi>M</mi>
    </munderover>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mi>n</mi>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>t</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <apply>
         <minus></minus>
         <ci>M</ci>
        </apply>
       </apply>
      </apply>
      <ci>M</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <ci>G</ci>
      <interval closure="open">
       <ci>n</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(x,t)=\sum_{n=-M}^{M}f(x-n)\,G(n,t)
  </annotation>
 </semantics>
</math>

</p>

<p>for <em>M</em> chosen sufficiently large (see <a href="error_function" title="wikilink">error function</a>) such that</p>

<p>

<math display="block" id="Scale_space_implementation:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mi>M</mi>
       <mi mathvariant="normal">∞</mi>
      </msubsup>
      <mrow>
       <mi>G</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>u</mi>
        <mo>,</mo>
        <mi>t</mi>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <mi>d</mi>
       <mi>u</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>2</mn>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mfrac>
        <mi>M</mi>
        <msqrt>
         <mi>t</mi>
        </msqrt>
       </mfrac>
       <mi mathvariant="normal">∞</mi>
      </msubsup>
      <mrow>
       <mi>G</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>v</mi>
        <mo>,</mo>
        <mn>1</mn>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <mi>d</mi>
       <mi>v</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo><</mo>
    <mi>ε</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <ci>M</ci>
        </apply>
        <infinity></infinity>
       </apply>
       <apply>
        <times></times>
        <ci>G</ci>
        <interval closure="open">
         <ci>u</ci>
         <ci>t</ci>
        </interval>
        <ci>d</ci>
        <ci>u</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <apply>
          <divide></divide>
          <ci>M</ci>
          <apply>
           <root></root>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
        <infinity></infinity>
       </apply>
       <apply>
        <times></times>
        <ci>G</ci>
        <interval closure="open">
         <ci>v</ci>
         <cn type="integer">1</cn>
        </interval>
        <ci>d</ci>
        <ci>v</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <ci>ε</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\int_{M}^{\infty}G(u,t)\,du=2\int_{\frac{M}{\sqrt{t}}}^{\infty}G(v,1)\,dv<\varepsilon.
  </annotation>
 </semantics>
</math>

</p>

<p>A common choice is to set M to a constant C times the standard deviation of the Gaussian kernel</p>

<p>

<math display="block" id="Scale_space_implementation:10">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>C</mi>
     <mi>σ</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>C</mi>
     <msqrt>
      <mi>t</mi>
     </msqrt>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>M</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>C</ci>
       <ci>σ</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>C</ci>
       <apply>
        <root></root>
        <ci>t</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=C\sigma+1=C\sqrt{t}+1
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>C</em> is often chosen somewhere between 3 and 6.</p>

<p>Using the sampled Gaussian kernel can, however, lead to implementation problems, in particular when computing higher-order derivatives at finer scales by applying sampled derivatives of Gaussian kernels. When accuracy and robustness are primary design criteria, alternative implementation approaches should therefore be considered.</p>

<p>For small values of ε (10<sup>−6</sup> to 10<sup>−8</sup>) the errors introduced by truncating the Gaussian are usually negligible. For larger values of ε, however, there are many better alternatives to a rectangular <a href="window_function" title="wikilink">window function</a>. For example, for a given number of points, a <a href="Hamming_window" title="wikilink">Hamming window</a>, <a href="Blackman_window" title="wikilink">Blackman window</a>, or <a href="Kaiser_window" title="wikilink">Kaiser window</a> will do less damage to the spectral and other properties of the Gaussian than a simple truncation will. Nonwithstanding this, since the Gaussian kernel decreases rapidly at the tails, the main recommendation is still to use a sufficiently small value of ε such that the truncation effects are no longer important.</p>
<h2 id="the-discrete-gaussian-kernel">The discrete Gaussian kernel</h2>

<p>]</p>

<p>A more refined approach is to convolve the original signal by the <em>discrete Gaussian kernel</em> <em>T</em>(<em>n</em>, <em>t</em>)<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>

<math display="block" id="Scale_space_implementation:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mi>n</mi>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>t</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <ci>T</ci>
      <interval closure="open">
       <ci>n</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(x,t)=\sum_{n=-\infty}^{\infty}f(x-n)\,T(n,t)
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Scale_space_implementation:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mi>t</mi>
     </mrow>
    </msup>
    <msub>
     <mi>I</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <interval closure="open">
      <ci>n</ci>
      <ci>t</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>n</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(n,t)=e^{-t}I_{n}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>and 

<math display="inline" id="Scale_space_implementation:13">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>n</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{n}(t)
  </annotation>
 </semantics>
</math>

 denotes the <a href="modified_Bessel_function" title="wikilink">modified Bessel functions</a> of integer order, <em>n</em>. This is the discrete counterpart of the continuous Gaussian in that it is the solution to the discrete <a href="diffusion_equation" title="wikilink">diffusion equation</a> (discrete space, continuous time), just as the continuous Gaussian is the solution to the continuous diffusion equation.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>This filter can be truncated in the spatial domain as for the sampled Gaussian</p>

<p>

<math display="block" id="Scale_space_implementation:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mrow>
       <mo>-</mo>
       <mi>M</mi>
      </mrow>
     </mrow>
     <mi>M</mi>
    </munderover>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mi>n</mi>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>t</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <apply>
         <minus></minus>
         <ci>M</ci>
        </apply>
       </apply>
      </apply>
      <ci>M</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <ci>T</ci>
      <interval closure="open">
       <ci>n</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(x,t)=\sum_{n=-M}^{M}f(x-n)\,T(n,t)
  </annotation>
 </semantics>
</math>

</p>

<p>or can be implemented in the Fourier domain using a closed-form expression for its <a href="discrete-time_Fourier_transform" title="wikilink">discrete-time Fourier transform</a>:</p>

<p>

<math display="block" id="Scale_space_implementation:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>T</mi>
      <mo>^</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>θ</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mrow>
        <mo>-</mo>
        <mi mathvariant="normal">∞</mi>
       </mrow>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo>,</mo>
       <mi>t</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>e</mi>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>i</mi>
         <mi>θ</mi>
         <mi>n</mi>
        </mrow>
       </mrow>
      </msup>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>e</mi>
     <mrow>
      <mi>t</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>cos</mi>
         <mi>θ</mi>
        </mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-^</ci>
       <ci>T</ci>
      </apply>
      <interval closure="open">
       <ci>θ</ci>
       <ci>t</ci>
      </interval>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <apply>
          <minus></minus>
          <infinity></infinity>
         </apply>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <interval closure="open">
        <ci>n</ci>
        <ci>t</ci>
       </interval>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>θ</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>t</ci>
       <apply>
        <minus></minus>
        <apply>
         <cos></cos>
         <ci>θ</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{T}(\theta,t)=\sum_{n=-\infty}^{\infty}T(n,t)\,e^{-i\theta n}=e^{t(%
\cos\theta-1)}.
  </annotation>
 </semantics>
</math>

</p>

<p>With this frequency-domain approach, the scale-space properties transfer <em>exactly</em> to the discrete domain, or with excellent approximation using periodic extension and a suitably long <a href="discrete_Fourier_transform" title="wikilink">discrete Fourier transform</a> to approximate the <a href="discrete-time_Fourier_transform" title="wikilink">discrete-time Fourier transform</a> of the signal being smoothed. Moreover, higher-order derivative approximations can be computed in a straightforward manner (and preserving scale-space properties) by applying small support central difference operators to the discrete <a href="scale_space_representation" title="wikilink">scale space representation</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>As with the sampled Gaussian, a plain truncation of the infinite impulse response will in most cases be a sufficient approximation for small values of ε, while for larger values of ε it is better to use either a decomposition of the discrete Gaussian into a cascade of generalized binomial filters or alternatively to construct a finite approximate kernel by multiplying by a <a href="window_function" title="wikilink">window function</a>. If ε has been chosen too large such that effects of the truncation error begin to appear (for example as spurious extrema or spurious responses to higher-order derivative operators), then the options are to decrease the value of ε such that a larger finite kernel is used, with cutoff where the support is very small, or to use a tapered window.</p>
<h2 id="recursive-filters">Recursive filters</h2>
<figure><b>(Figure)</b>
<figcaption>Scale-space kernels. Ideal discrete gaussian based on bessel functions (red), and two-pole-pair forward/backward recursive smoothing filters (blue) with poles as described in the text. Top shows individual kernels, and bottom is their cumulative convolution with each other; <em>t</em> = [0.5, 1, 2, 4].</figcaption>
</figure>

<p>Since computational efficiency is often important, low-order <em><a href="recursive_filter" title="wikilink">recursive filters</a></em> are often used for scale-space smoothing. For example, Young and van Vliet<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> use a third-order recursive filter with one real pole and a pair of complex poles, applied forward and backward to make a sixth-order symmetric approximation to the Gaussian with low computational complexity for any smoothing scale.</p>

<p>By relaxing a few of the axioms, Lindeberg<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> concluded that good smoothing filters would be "normalized <a class="uri" href="Pólya" title="wikilink">Pólya</a> frequency sequences", a family of discrete kernels that includes all filters with real poles at 0  1, as well as with real zeros at <em>Z</em> Z = 1 + \frac{2}{t} - \sqrt{\left (1 + \frac{2}{t} \right)^2 - 1}</p>

<p>can be applied forward and backwards, for symmetry and stability. This filter is the simplest implementation of a normalized Pólya frequency sequence kernel that works for any smoothing scale, but it is not as excellent an approximation to the Gaussian as Young and van Vliet's filter, which is <em>not</em> normalized Pólya frequency sequence, due to its complex poles.</p>

<p>The transfer function, <em>H</em><sub>1</sub>, of a symmetric pole-pair recursive filter is closely related to the <a href="discrete-time_Fourier_transform" title="wikilink">discrete-time Fourier transform</a> of the discrete Gaussian kernel via first-order approximation of the exponential:</p>

<p>

<math display="block" id="Scale_space_implementation:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>T</mi>
      <mo>^</mo>
     </mover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>θ</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <msup>
      <mi>e</mi>
      <mrow>
       <mi>t</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mrow>
          <mi>cos</mi>
          <mi>θ</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
    </mfrac>
    <mo>≈</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mrow>
       <mi>t</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mrow>
          <mi>cos</mi>
          <mi>θ</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>H</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>θ</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-^</ci>
       <ci>T</ci>
      </apply>
      <interval closure="open">
       <ci>θ</ci>
       <ci>t</ci>
      </interval>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <times></times>
        <ci>t</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <apply>
          <cos></cos>
          <ci>θ</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>t</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <apply>
          <cos></cos>
          <ci>θ</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <cn type="integer">1</cn>
      </apply>
      <interval closure="open">
       <ci>θ</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{T}(\theta,t)=\frac{1}{e^{t(1-\cos\theta)}}\approx\frac{1}{{1+t(1-\cos%
\theta)}}=H_{1}(\theta,t),
  </annotation>
 </semantics>
</math>

</p>

<p>where the <em>t</em> parameter here is related to the stable pole position <em>Z</em> = <em>p</em> via:</p>

<p>

<math display="block" id="Scale_space_implementation:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mn>2</mn>
      <mi>p</mi>
     </mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>p</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>p</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>p</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=\frac{2p}{(1-p)^{2}}.
  </annotation>
 </semantics>
</math>

</p>

<p>Furthermore, such filters with <em>N</em> pairs of poles, such as the two pole pairs illustrated in this section, are an even better approximation to the exponential:</p>

<p>

<math display="block" id="Scale_space_implementation:18">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msup>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mrow>
         <mfrac>
          <mi>t</mi>
          <mi>N</mi>
         </mfrac>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mn>1</mn>
           <mo>-</mo>
           <mrow>
            <mi>cos</mi>
            <mi>θ</mi>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mi>N</mi>
     </msup>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>H</mi>
      <mi>N</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>θ</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <ci>t</ci>
         <ci>N</ci>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <apply>
          <cos></cos>
          <ci>θ</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>N</ci>
     </apply>
     <interval closure="open">
      <ci>θ</ci>
      <ci>t</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{\left(1+\frac{t}{N}(1-\cos\theta)\right)^{N}}=H_{N}(\theta,t),
  </annotation>
 </semantics>
</math>

</p>

<p>where the stable pole positions are adjusted by solving:</p>

<p>

<math display="block" id="Scale_space_implementation:19">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mi>t</mi>
     <mi>N</mi>
    </mfrac>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mn>2</mn>
      <mi>p</mi>
     </mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>p</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>t</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>p</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>p</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{t}{N}=\frac{2p}{(1-p)^{2}}.
  </annotation>
 </semantics>
</math>

</p>

<p>The impulse responses of these filters are not very close to gaussian unless more than two pole pairs are used. However, even with only one or two pole pairs per scale, a signal successively smoothed at increasing scales will be very close to a gaussian-smoothed signal. The semi-group property is poorly approximated when too few pole pairs are used.</p>

<p><a href="Scale-space_axioms" title="wikilink">Scale-space axioms</a> that are still satisfied by these filters are:</p>
<ul>
<li><em>linearity</em></li>
<li><em>shift invariance</em> (integer shifts)</li>
<li><em>non-creation of local extrema</em> (zero-crossings) in one dimension</li>
<li><em>non-enhancement of local extrema</em> in any number of dimensions</li>
<li><em>positivity</em></li>
<li><em>normalization</em></li>
</ul>

<p>The following are only approximately satisfied, the approximation being better for larger numbers of pole pairs:</p>
<ul>
<li>existence of an <em>infinitesimal generator</em> <em>A</em> (the infinitesimal generator of the discrete Gaussian, or a filter approximating it, approximately maps a recursive filter response to one of infinitesimally larger <em>t</em>)</li>
<li>the <em>semi-group structure</em> with the associated <em>cascade smoothing property</em> (this property is approximated by considering kernels to be equivalent when they have the same <em>t</em> value, even if they are not quite equal)</li>
<li><em>rotational symmetry</em></li>
<li><em>scale invariance</em></li>
</ul>

<p>This recursive filter method and variations to compute both the Gaussian smoothing as well as Gaussian derivatives has been described by several authors.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> Tan <em>et al.</em> have analyzed and compared some of these approaches, and have pointed out that the Young and van Vliet filters are a cascade (multiplication) of forward and backward filters, while the Deriche and the Jin <em>et al.</em> filters are sums of forward and backward filters.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>At fine scales, the recursive filtering approach as well as other separable approaches are not guaranteed to give the best possible approximation to rotational symmetry, so non-separable implementations for 2D images may be considered as an alternative.</p>

<p>When computing several derivatives in the <a class="uri" href="N-jet" title="wikilink">N-jet</a> simultaneously, discrete scale-space smoothing with the discrete analogue of the Gaussian kernel, or with a recursive filter approximation, followed by small support difference operators, may be both faster and more accurate than computing recursive approximations of each derivative operator.</p>
<h2 id="finite-impulse-response-fir-smoothers">Finite-impulse-response (FIR) smoothers</h2>

<p>For small scales, a low-order FIR filter may be a better smoothing filter than a recursive filter. The symmetric 3-kernel 

<math display="inline" id="Scale_space_implementation:20">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mi>t</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mi>t</mi>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <mi>t</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <divide></divide>
     <ci>t</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <minus></minus>
     <cn type="float">1</cn>
     <ci>t</ci>
    </apply>
    <apply>
     <divide></divide>
     <ci>t</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [t/2,\ 1-t,\ t/2]
  </annotation>
 </semantics>
</math>

, for 

<math display="inline" id="Scale_space_implementation:21">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>≤</mo>
   <mn>0.5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>t</ci>
    <cn type="float">0.5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\leq 0.5
  </annotation>
 </semantics>
</math>

 smooths to a scale of <em>t</em> using a pair of real zeros at <em>Z</em> \widehat{T}(\theta, t) = e^{-t(1 - \cos \theta)} \approx {1 -t(1 - \cos \theta)} = F_1(\theta, t),</p>

<p>where the <em>t</em> parameter here is related to the zero positions <em>Z</em> = <em>z</em> via:</p>

<p>

<math display="block" id="Scale_space_implementation:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mn>2</mn>
       <mi>z</mi>
      </mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mi>z</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mfrac>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>z</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>z</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=-\frac{2z}{(1-z)^{2}},
  </annotation>
 </semantics>
</math>

</p>

<p>and we require 

<math display="inline" id="Scale_space_implementation:23">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>≤</mo>
   <mn>0.5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>t</ci>
    <cn type="float">0.5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\leq 0.5
  </annotation>
 </semantics>
</math>

 to keep the transfer function non-negative.</p>

<p>Furthermore, such filters with <em>N</em> pairs of zeros, are an even better approximation to the exponential and extend to higher values of <em>t</em> :</p>

<p>

<math display="block" id="Scale_space_implementation:24">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <mfrac>
         <mi>t</mi>
         <mi>N</mi>
        </mfrac>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mrow>
           <mi>cos</mi>
           <mi>θ</mi>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mi>N</mi>
    </msup>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>F</mi>
      <mi>N</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>θ</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>t</ci>
        <ci>N</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <cos></cos>
         <ci>θ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>N</ci>
     </apply>
     <interval closure="open">
      <ci>θ</ci>
      <ci>t</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(1-\frac{t}{N}(1-\cos\theta)\right)^{N}=F_{N}(\theta,t),
  </annotation>
 </semantics>
</math>

</p>

<p>where the stable zero positions are adjusted by solving:</p>

<p>

<math display="block" id="Scale_space_implementation:25">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mi>t</mi>
     <mi>N</mi>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mn>2</mn>
       <mi>z</mi>
      </mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mi>z</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>t</ci>
     <ci>N</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>z</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>z</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{t}{N}=-\frac{2z}{(1-z)^{2}}.
  </annotation>
 </semantics>
</math>

</p>

<p>These FIR and pole-zero filters are valid scale-space kernels, satisfying the same axioms as the all-pole recursive filters.</p>
<h2 id="real-time-implementation-within-pyramids-and-discrete-approximation-of-scale-normalized-derivatives">Real-time implementation within pyramids and discrete approximation of scale-normalized derivatives</h2>

<p>Regarding the topic of automatic scale selection based on normalized derivatives, <a href="pyramid_(image_processing)" title="wikilink">pyramid approximations</a> are frequently used to obtain real-time performance.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> The appropriateness of approximating scale-space operations within a pyramid originates from the fact that repeated cascade smoothing with generalized binomial kernels leads to equivalent smoothing kernels that under reasonable conditions approach the Gaussian. Furthermore, the binomial kernels (or more generally the class of generalized binomial kernels) can be shown to constitute the unique class of finite-support kernels that guarantee non-creation of local extrema or zero-crossings with increasing scale (see the article on <a href="multi-scale_approaches" title="wikilink">multi-scale approaches</a> for details). Special care may, however, need to be taken to avoid discretization artifacts.</p>
<h2 id="other-multi-scale-approaches">Other multi-scale approaches</h2>

<p>For one-dimensional kernels, there is a well-developed theory of <a href="multi-scale_approaches" title="wikilink">multi-scale approaches</a>, concerning filters that do not create new local extrema or new zero-crossings with increasing scales. For continuous signals, filters with real poles in the <em>s</em>-plane are within this class, while for discrete signals the above-described recursive and FIR filters satisfy these criteria. Combined with the strict requirement of a continuous semi-group structure, the continuous Gaussian and the discrete Gaussian constitute the unique choice for continuous and discrete signals.</p>

<p>There are many other multi-scale signal processing, image processing and data compression techniques, using <a class="uri" href="wavelets" title="wikilink">wavelets</a> and a variety of other kernels, that do not exploit or require the <a href="scale-space_axioms" title="wikilink">same requirements</a> as <a href="scale_space" title="wikilink">scale space</a> descriptions do; that is, they do not depend on a coarser scale not generating a new extremum that was not present at a finer scale (in 1D) or non-enhancement of local extrema between adjacent scale levels (in any number of dimensions).</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="scale_space" title="wikilink">scale space</a></li>
<li><a href="pyramid_(image_processing)" title="wikilink">pyramid (image processing)</a></li>
<li><a href="multi-scale_approaches" title="wikilink">multi-scale approaches</a></li>
<li><a href="Gaussian_filter" title="wikilink">Gaussian filter</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Image_processing" title="wikilink">Category:Image processing</a> <a href="Category:Computer_vision" title="wikilink">Category:Computer vision</a> <a href="Category:Gaussian_function" title="wikilink">Category:Gaussian function</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.nada.kth.se/~tony/abstracts/Lin90-PAMI.html">Lindeberg, T., "Scale-space for discrete signals," PAMI(12), No. 3, March 1990, pp. 234-254.</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://www.csc.kth.se/~tony/book.html">Lindeberg, T., Scale-Space Theory in Computer Vision, Kluwer Academic Publishers, 1994</a>, ISBN 0-7923-9418-6<a href="#fnref2">↩</a></li>
<li id="fn3">R.A. Haddad and A.N. Akansu, "A Class of Fast Gaussian Binomial Filters for Speech and Image Processing," IEEE Transactions on Acoustics, Speech and Signal Processing, vol. 39, pp 723-727, March 1991.<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6">Campbell, J, 2007, <em><a href="http://dx.doi.org/10.1016/j.tpb.2007.08.001">The SMM model as a boundary value problem using the discrete diffusion equation</a></em>, Theor Popul Biol. 2007 Dec;72(4):539-46.<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="http://www.nada.kth.se/~tony/abstracts/Lin93-JMIV.html">Lindeberg, T. Discrete derivative approximations with scale-space properties: A basis for low-level feature extraction, J. of Mathematical Imaging and Vision, 3(4), pp. 349--376, 1993.</a><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"><a href="http://citeseer.ist.psu.edu/deriche93recursively.html">Deriche, R: Recursively implementing the Gaussian and its derivatives, INRIA Research Report 1893, 1993.</a><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="http://www.dicklyon.com/tech/Scans/ICASSP87_ScaleSpace-Lyon.pdf">Richard F. Lyon. "Speech recognition in scale space," Proc. of 1987 ICASSP. San Diego, March, pp. 29.3.14, 1987.</a><a href="#fnref12">↩</a></li>
<li id="fn13">Jin, JS, Gao Y. "Recursive implementation of LoG Filtering". <em>Real-Time Imaging</em> 1997;3:59–65.<a href="#fnref13">↩</a></li>
<li id="fn14"><a href="http://www.pspc.dibe.unige.it/ecovision/pubs/papers/tan-dale-johnston.pdf">.</a> <a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="http://www-prima.inrialpes.fr/Prima/Homepages/jlc/papers/Crowley-ScaleSpace03.pdf">Crowley, J, Riff O: Fast computation of scale normalised Gaussian receptive fields, Proc. Scale-Space'03, Isle of Skye, Scotland, Springer Lecture Notes in Computer Science, volume 2695, 2003.</a><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="http://citeseer.ist.psu.edu/lowe04distinctive.html">Lowe, D. G., “Distinctive image features from scale-invariant keypoints”, International Journal of Computer Vision, 60, 2, pp. 91-110, 2004.</a><a href="#fnref17">↩</a></li>
</ol>
</section>
</body>
</html>
