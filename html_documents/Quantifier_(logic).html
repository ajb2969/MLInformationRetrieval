<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1186">Quantifier (logic)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Quantifier (logic)</h1>
<hr/>

<p>In <a class="uri" href="logic" title="wikilink">logic</a>, <strong>quantification</strong> is a construct that specifies the quantity of specimens in the <a href="domain_of_discourse" title="wikilink">domain of discourse</a> that satisfy an open formula. For example, in arithmetic, it allows the expression of the statement that every natural number has a successor. A language element which generates a quantification (such as "every") is called a <strong>quantifier</strong>. The resulting expression is a quantified expression, it is said to be <strong>quantified</strong> over the predicate (such as "the natural number <em>x</em> has a successor") whose <a href="Free_variables_and_bound_variables" title="wikilink">free variable</a> is bound by the quantifier. In formal languages, quantification is a formula constructor that produces new formulas from old ones. The <a class="uri" href="semantics" title="wikilink">semantics</a> of the language specifies how the constructor is interpreted. Two fundamental kinds of quantification in <a href="predicate_(logic)" title="wikilink">predicate logic</a> are <a href="universal_quantification" title="wikilink">universal quantification</a> and <a href="existential_quantification" title="wikilink">existential quantification</a>. The traditional symbol for the universal quantifier "all" is "‚àÄ", a rotated letter "<a class="uri" href="A" title="wikilink">A</a>", and for the <a href="existential_quantification" title="wikilink">existential quantifier</a> "exists" is "‚àÉ", a rotated letter "<a class="uri" href="E" title="wikilink">E</a>". These quantifiers have been generalized beginning with the work of <a href="Andrzej_Mostowski" title="wikilink">Mostowski</a> and <a href="Per_Lindstr√∂m" title="wikilink">Lindstr√∂m</a>.</p>

<p>Quantification is used as well in <a href="natural_language" title="wikilink">natural languages</a>; examples of quantifiers in English are <em>for all</em>, <em>for some</em>, <em>many</em>, <em>few</em>, <em>a lot</em>, and <em>no</em>; see <a href="Quantifier_(linguistics)" title="wikilink">Quantifier (linguistics)</a> for details.</p>
<h2 id="mathematics">Mathematics</h2>

<p>Consider the following statement:</p>
<dl>
<dd>1 ¬∑ 2 = 1 + 1, and 2 ¬∑ 2 = 2 + 2, and 3 ¬∑ 2 = 3 + 3, ..., and 100 ¬∑ 2 = 100 + 100, and ..., etc.
</dd>
</dl>

<p>This has the appearance of an <em>infinite <a href="logical_conjunction" title="wikilink">conjunction</a></em> of propositions. From the point of view of <a href="formal_language" title="wikilink">formal languages</a> this is immediately a problem, since <a class="uri" href="syntax" title="wikilink">syntax</a> rules are expected to generate <a href="finite_set" title="wikilink">finite</a> objects. The example above is fortunate in that there is a <a href="Algorithm" title="wikilink">procedure</a> to generate all the conjuncts. However, if an assertion were to be made about every <a href="irrational_number" title="wikilink">irrational number</a>, there would be no way to enumerate all the conjuncts, since irrationals cannot be enumerated. A succinct formulation which avoids these problems uses <em>universal quantification</em>:</p>
<dl>
<dd>For each <a href="natural_number" title="wikilink">natural number</a> <em>n</em>, <em>n</em> ¬∑ 2 = <em>n</em> + <em>n</em>.
</dd>
</dl>

<p>A similar analysis applies to the <a href="disjunction_(logic)" title="wikilink">disjunction</a>,</p>
<dl>
<dd>1 is equal to 5 + 5, or 2 is equal to 5 + 5, or 3 is equal to 5 + 5, ... , or 100 is equal to 5 + 5, or ..., etc.
</dd>
</dl>

<p>which can be rephrased using <em>existential quantification</em>:</p>
<dl>
<dd>For some <a href="natural_number" title="wikilink">natural number</a> <em>n</em>, <em>n</em> is equal to 5+5.
</dd>
</dl>
<h2 id="algebraic-approaches-to-quantification">Algebraic approaches to quantification</h2>

<p>It is possible to devise <a href="abstract_algebra" title="wikilink">abstract algebras</a> whose <a href="model_theory" title="wikilink">models</a> include <a href="formal_language" title="wikilink">formal languages</a> with quantification, but progress has been slow and interest in such algebra has been limited. Three approaches have been devised to date:</p>
<ul>
<li><a href="Relation_algebra" title="wikilink">Relation algebra</a>, invented by <a href="Augustus_De_Morgan" title="wikilink">Augustus De Morgan</a>, and developed by <a href="Charles_Sanders_Peirce" title="wikilink">Charles Sanders Peirce</a>, <a href="Ernst_Schr√∂der" title="wikilink">Ernst Schr√∂der</a>, <a href="Alfred_Tarski" title="wikilink">Alfred Tarski</a>, and Tarski's students. Relation algebra cannot represent any formula with quantifiers nested more than three deep. Surprisingly, the models of relation algebra include the <a href="axiomatic_set_theory" title="wikilink">axiomatic set theory</a> <a class="uri" href="ZFC" title="wikilink">ZFC</a> and <a href="Peano_arithmetic" title="wikilink">Peano arithmetic</a>;</li>
<li><a href="Cylindric_algebra" title="wikilink">Cylindric algebra</a>, devised by <a href="Alfred_Tarski" title="wikilink">Alfred Tarski</a>, <a href="Leon_Henkin" title="wikilink">Leon Henkin</a>, and others;</li>
<li>The <a href="polyadic_algebra" title="wikilink">polyadic algebra</a> of <a href="Paul_Halmos" title="wikilink">Paul Halmos</a>.</li>
</ul>
<h2 id="notation">Notation</h2>

<p>The two most common quantifiers are the universal quantifier and the existential quantifier. The traditional symbol for the universal quantifier is "<a class="uri" href="‚àÄ" title="wikilink">‚àÄ</a>", an inverted letter "<a class="uri" href="A" title="wikilink">A</a>", which stands for "for all" or "all". The corresponding symbol for the existential quantifier is "<a class="uri" href="‚àÉ" title="wikilink">‚àÉ</a>", a rotated letter "<a class="uri" href="E" title="wikilink">E</a>", which stands for "there exists" or "exists".</p>

<p>An example of translating a quantified English statement would be as follows. Given the statement, "Each of Peter's friends either likes to dance or likes to go to the beach", we can identify key aspects and rewrite using symbols including quantifiers. So, let <em>X</em> the set of all Peter's friends, <em>P</em>(<em>x</em>) be the <a href="predicate_(mathematical_logic)" title="wikilink">predicate</a> "<em>x</em> likes to dance", and lastly <em>Q</em>(<em>x</em>) the predicate "<em>x</em> likes to go to the beach". Then the above sentence can be written in formal notation as 

<math display="inline" id="Quantifier_(logic):0">
 <semantics>
  <mrow>
   <mrow>
    <mo>‚àÄ</mo>
    <mi>x</mi>
   </mrow>
   <mo>‚àà</mo>
   <mrow>
    <mi>X</mi>
    <mo>,</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>x</ci>
    </apply>
    <list>
     <ci>X</ci>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>x</ci>
      <ci>Q</ci>
      <ci>x</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall{x}{\in}X,P(x)Q(x)
  </annotation>
 </semantics>
</math>

, which is read, "for every <em>x</em> that is a member of <em>X</em>, <em>P</em> applies to <em>x</em> or <em>Q</em> applies to <em>x</em>."</p>

<p>Some other quantified expressions are constructed as follows,</p>

<p>

<math display="block" id="Quantifier_(logic):1">
 <semantics>
  <mrow>
   <mrow>
    <mo>‚àÉ</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>x</mi>
     </mpadded>
     <mi>P</mi>
    </mrow>
   </mrow>
   <mrow>
    <mo>‚àÄ</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>x</mi>
     </mpadded>
     <mi>P</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>P</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>P</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists{x}\,P\qquad\forall{x}\,P
  </annotation>
 </semantics>
</math>

 for a formula <em>P</em>. These two expressions (using the definitions above) are read as "there exists a friend of Peter who likes to dance" and "all friends of Peter like to dance" respectively. Variant notations include, for set <em>X</em> and set members <em>x</em>:</p>

<p>

<math display="block" id="Quantifier_(logic):2">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>‚àÉ</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>‚àÉ</mo>
    <mpadded width="+5pt">
     <mi>x</mi>
    </mpadded>
    <mo rspace="7.5pt">.</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>‚àÉ</mo>
   <mpadded width="+5pt">
    <mi>x</mi>
   </mpadded>
   <mo rspace="7.5pt">‚ãÖ</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>‚àÉ</mo>
    <mi>x</mi>
    <mo>:</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>‚àÉ</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mpadded width="+1.7pt">
    <msub>
     <mo>‚àÉ</mo>
     <mi>x</mi>
    </msub>
   </mpadded>
   <mi>P</mi>
   <mo>‚àÉ</mo>
   <mi>x</mi>
   <mo rspace="4.2pt">,</mo>
   <mi>P</mi>
   <mo>‚àÉ</mo>
   <mi>x</mi>
   <mo>‚àà</mo>
   <mpadded width="+1.7pt">
    <mi>X</mi>
   </mpadded>
   <mi>P</mi>
   <mo rspace="4.2pt">‚àÉ</mo>
   <mi>x</mi>
   <mo>:</mo>
   <mpadded width="+1.7pt">
    <mi>X</mi>
   </mpadded>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <ci>italic-</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>italic-</ci>
    <exists></exists>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-‚ãÖ</ci>
    <csymbol cd="unknown">P</csymbol>
    <ci>italic-</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>italic-</ci>
    <exists></exists>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>italic-</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <exists></exists>
     <ci>x</ci>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <ci>italic-</ci>
    <exists></exists>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">P</csymbol>
    <ci>italic-</ci>
    <exists></exists>
    <csymbol cd="unknown">x</csymbol>
    <in></in>
    <csymbol cd="unknown">X</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <ci>italic-</ci>
    <exists></exists>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">X</csymbol>
    <csymbol cd="unknown">P</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\exists{x})P\qquad(\exists x\ .\ P)\qquad\exists x\ \cdot\ P\qquad(\exists x:%
P)\qquad\exists{x}(P)\qquad\exists_{x}\,P\qquad\exists{x}{,}\,P\qquad\exists{x%
}{\in}X\,P\qquad\exists\,x{:}X\,P
  </annotation>
 </semantics>
</math>

 All of these variations also apply to universal quantification. Other variations for the universal quantifier are</p>

<p>

<math display="block" id="Quantifier_(logic):3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
    <mi>P</mi>
   </mrow>
   <mrow>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">‚ãÄ</mo>
     <mi>x</mi>
    </munder>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>P</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <and></and>
      <ci>x</ci>
     </apply>
     <ci>P</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x)\,P\qquad\bigwedge_{x}P
  </annotation>
 </semantics>
</math>

</p>

<p>Some versions of the notation explicitly mention the range of quantification. The range of quantification must always be specified; for a given mathematical theory, this can be done in several ways:</p>
<ul>
<li>Assume a fixed domain of discourse for every quantification, as is done in <a href="Zermelo‚ÄìFraenkel_set_theory" title="wikilink">Zermelo‚ÄìFraenkel set theory</a>,</li>
<li>Fix several domains of discourse in advance and require that each variable have a declared domain, which is the <em>type</em> of that variable. This is analogous to the situation in <a href="Type_system" title="wikilink">statically typed</a> <a href="computer_programming" title="wikilink">computer programming</a> languages, where variables have declared types.</li>
<li>Mention explicitly the range of quantification, perhaps using a symbol for the set of all objects in that domain or the <a href="type_(logic)" title="wikilink">type</a> of the objects in that domain.</li>
</ul>

<p>One can use any variable as a quantified variable in place of any other, under certain restrictions in which <em>variable capture</em> does not occur. Even if the notation uses typed variables, variables of that type may be used.</p>

<p>Informally or in natural language, the "‚àÄ<em>x</em>" or "‚àÉ<em>x</em>" might appear after or in the middle of <em>P</em>(<em>x</em>). Formally, however, the phrase that introduces the dummy variable is placed in front.</p>

<p>Mathematical formulas mix symbolic expressions for quantifiers, with natural language quantifiers such as</p>
<dl>
<dd>For every natural number <em>x</em>, ....
</dd>
<dd>There exists an <em>x</em> such that ....
</dd>
<dd>For at least one <em>x</em>.
</dd>
</dl>

<p>Keywords for <a href="uniqueness_quantification" title="wikilink">uniqueness quantification</a> include:</p>
<dl>
<dd>For exactly one natural number <em>x</em>, ....
</dd>
<dd>There is one and only one <em>x</em> such that ....
</dd>
</dl>

<p>Further, <em>x</em> may be replaced by a <a class="uri" href="pronoun" title="wikilink">pronoun</a>. For example,</p>
<dl>
<dd>For every natural number, its product with 2 equals to its sum with itself
</dd>
<dd>Some natural number is prime.
</dd>
</dl>
<h2 id="nesting">Nesting</h2>

<p>The order of quantifiers is critical to meaning, as is illustrated by the following two propositions:</p>
<dl>
<dd>For every natural number <em>n</em>, there exists a natural number <em>s</em> such that <em>s</em> = <em>n</em><sup>2</sup>.
</dd>
</dl>

<p>This is clearly true; it just asserts that every natural number has a square. The meaning of the assertion in which the quantifiers are turned around is different:</p>
<dl>
<dd>There exists a natural number <em>s</em> such that for every natural number <em>n</em>, <em>s</em> = <em>n</em><sup>2</sup>.
</dd>
</dl>

<p>This is clearly false; it asserts that there is a single natural number <em>s</em> that is at the same time the square of <em>every</em> natural number. This is because the syntax directs that any variable cannot be a function of subsequently introduced variables.</p>

<p>A less trivial example from <a href="mathematical_analysis" title="wikilink">mathematical analysis</a> are the concepts of <a href="uniform_continuity" title="wikilink">uniform</a> and <a href="continuous_function" title="wikilink">pointwise</a> continuity, whose definitions differ only by an exchange in the positions of two quantifiers. A function <em>f</em> from <a href="real_numbers" title="wikilink"><strong>R</strong></a> to <strong>R</strong> is called</p>
<ul>
<li>pointwise continuous if ‚àÄŒµ&gt;0 ‚àÄ<em>x</em>‚àà<strong>R</strong> ‚àÉŒ¥&gt;0 ‚àÄ<em>h</em>‚àà<strong>R</strong> (|<em>h</em>| &lt; Œ¥ ‚Üí |<em>f</em>(<em>x</em>) ‚Äì f(<em>x</em> + <em>h</em>)| &lt; Œµ)</li>
<li>uniformly continuous if ‚àÄŒµ&gt;0 ‚àÉŒ¥&gt;0 ‚àÄ<em>x</em>‚àà<strong>R</strong> ‚àÄ<em>h</em>‚àà<strong>R</strong> (|<em>h</em>| &lt; Œ¥ ‚Üí |<em>f</em>(<em>x</em>) ‚Äì f(<em>x</em> + <em>h</em>)| &lt; Œµ)</li>
</ul>

<p>In the former case, the particular value chosen for <em>Œ¥</em> can be a function of both <em>Œµ</em> and <em>x</em>, the variables that precede it. In the latter case, <em>Œ¥</em> can be a function only of <em>Œµ</em>, i.e. it has to be chosen independent of <em>x</em>. For example, <em>f</em>(<em>x</em>) = <em>x</em><sup>2</sup> satisfies pointwise, but not uniform continuity. In contrast, interchanging the two initial universal quantifiers in the definition of pointwise continuity does not change the meaning.</p>

<p>The maximum depth of nesting of quantifiers inside a formula is called its <strong><a href="quantifier_rank" title="wikilink">quantifier rank</a></strong>.</p>
<h2 id="equivalent-expressions">Equivalent expressions</h2>

<p>If <em>D</em> is a domain of <em>x</em> and <em>P</em>(<em>x</em>) is a predicate dependent on <em>x</em>, then the universal proposition can be expressed as</p>

<p>

<math display="block" id="Quantifier_(logic):4">
 <semantics>
  <mrow>
   <mrow>
    <mo>‚àÄ</mo>
    <mpadded width="-1.7pt">
     <mi>x</mi>
    </mpadded>
   </mrow>
   <mo rspace="0.8pt">‚àà</mo>
   <mrow>
    <mpadded width="+2.8pt">
     <mi>D</mi>
    </mpadded>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\!\in\!D\;P(x)
  </annotation>
 </semantics>
</math>

</p>

<p>This notation is known as restricted or relativized or <a href="Bounded_quantifier" title="wikilink">bounded quantification</a>. Equivalently,</p>

<p>

<math display="block" id="Quantifier_(logic):5">
 <semantics>
  <mrow>
   <mo>‚àÄ</mo>
   <mpadded width="+2.8pt">
    <mi>x</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="-1.7pt">
     <mi>x</mi>
    </mpadded>
    <mo rspace="0.8pt">‚àà</mo>
    <mi>D</mi>
    <mo>‚Üí</mo>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-‚Üí</ci>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\;(x\!\in\!D\to P(x))
  </annotation>
 </semantics>
</math>

</p>

<p>The existential proposition can be expressed with bounded quantification as</p>

<p>

<math display="block" id="Quantifier_(logic):6">
 <semantics>
  <mrow>
   <mrow>
    <mo>‚àÉ</mo>
    <mpadded width="-1.7pt">
     <mi>x</mi>
    </mpadded>
   </mrow>
   <mo rspace="0.8pt">‚àà</mo>
   <mrow>
    <mpadded width="+2.8pt">
     <mi>D</mi>
    </mpadded>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <exists></exists>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x\!\in\!D\;P(x)
  </annotation>
 </semantics>
</math>

</p>

<p>or equivalently</p>

<p>

<math display="block" id="Quantifier_(logic):7">
 <semantics>
  <mrow>
   <mo>‚àÉ</mo>
   <mpadded width="+2.8pt">
    <mi>x</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="-1.7pt">
     <mi>x</mi>
    </mpadded>
    <mo rspace="0pt">‚àà</mo>
    <mi>D</mi>
    <mi mathvariant="italic">and</mi>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <exists></exists>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">D</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">P</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x\;(x\!\in\!\!D\and P(x))
  </annotation>
 </semantics>
</math>

</p>

<p>Together with negation, only one of either the universal or existential quantifier is needed to perform both tasks:</p>

<p>

<math display="block" id="Quantifier_(logic):8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬¨</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo>‚àÄ</mo>
        <mpadded width="-1.7pt">
         <mi>x</mi>
        </mpadded>
       </mrow>
       <mo rspace="0.8pt">‚àà</mo>
       <mrow>
        <mpadded width="+2.8pt">
         <mi>D</mi>
        </mpadded>
        <mi>P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>‚â°</mo>
    <mrow>
     <mo>‚àÉ</mo>
     <mpadded width="-1.7pt">
      <mi>x</mi>
     </mpadded>
    </mrow>
    <mo rspace="0.8pt">‚àà</mo>
    <mrow>
     <mpadded width="+2.8pt">
      <mi>D</mi>
     </mpadded>
     <mi mathvariant="normal">¬¨</mi>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <not></not>
      <apply>
       <in></in>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <ci>x</ci>
       </apply>
       <apply>
        <times></times>
        <ci>D</ci>
        <ci>P</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <exists></exists>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>D</ci>
      <not></not>
      <ci>P</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg(\forall x\!\in\!D\;P(x))\equiv\exists x\!\in\!D\;\neg P(x),
  </annotation>
 </semantics>
</math>

</p>

<p>which shows that to disprove a "for all <em>x</em>" proposition, one needs no more than to find an <em>x</em> for which the predicate is false. Similarly,</p>

<p>

<math display="block" id="Quantifier_(logic):9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬¨</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo>‚àÉ</mo>
        <mpadded width="-1.7pt">
         <mi>x</mi>
        </mpadded>
       </mrow>
       <mo rspace="0.8pt">‚àà</mo>
       <mrow>
        <mpadded width="+2.8pt">
         <mi>D</mi>
        </mpadded>
        <mi>P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>‚â°</mo>
    <mrow>
     <mo>‚àÄ</mo>
     <mpadded width="-1.7pt">
      <mi>x</mi>
     </mpadded>
    </mrow>
    <mo rspace="0.8pt">‚àà</mo>
    <mrow>
     <mpadded width="+2.8pt">
      <mi>D</mi>
     </mpadded>
     <mi mathvariant="normal">¬¨</mi>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <not></not>
      <apply>
       <in></in>
       <apply>
        <exists></exists>
        <ci>x</ci>
       </apply>
       <apply>
        <times></times>
        <ci>D</ci>
        <ci>P</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>D</ci>
      <not></not>
      <ci>P</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg(\exists x\!\in\!D\;P(x))\equiv\forall x\!\in\!D\;\neg P(x),
  </annotation>
 </semantics>
</math>

</p>

<p>to disprove a "there exists an <em>x</em>" proposition, one needs to show that the predicate is false for all <em>x</em>.</p>
<h2 id="range-of-quantification">Range of quantification</h2>

<p>Every quantification involves one specific variable and a <em>domain of discourse</em> or <em>range of quantification</em> of that variable. The range of quantification specifies the set of values that the variable takes. In the examples above, the range of quantification is the set of natural numbers. Specification of the range of quantification allows us to express the difference between, asserting that a predicate holds for some natural number or for some <a href="real_number" title="wikilink">real number</a>. Expository conventions often reserve some variable names such as "<em>n</em>" for natural numbers and "<em>x</em>" for real numbers, although relying exclusively on naming conventions cannot work in general since ranges of variables can change in the course of a mathematical argument.</p>

<p>A more natural way to restrict the domain of discourse uses <em>guarded quantification</em>. For example, the guarded quantification</p>
<dl>
<dd>For some natural number <em>n</em>, <em>n</em> is even and <em>n</em> is prime
</dd>
</dl>

<p>means</p>
<dl>
<dd>For some <a href="even_number" title="wikilink">even number</a> <em>n</em>, <em>n</em> is prime.
</dd>
</dl>

<p>In some mathematical theories a single domain of discourse fixed in advance is assumed. For example, in <a href="Zermelo‚ÄìFraenkel_set_theory" title="wikilink">Zermelo‚ÄìFraenkel set theory</a>, variables range over all sets. In this case, guarded quantifiers can be used to mimic a smaller range of quantification. Thus in the example above to express</p>
<dl>
<dd>For every natural number <em>n</em>, <em>n</em>¬∑2 = <em>n</em> + <em>n</em>
</dd>
</dl>

<p>in Zermelo‚ÄìFraenkel set theory, it can be said</p>
<dl>
<dd>For every <em>n</em>, if <em>n</em> belongs to <strong>N</strong>, then <em>n</em>¬∑2 = <em>n</em> + <em>n</em>,
</dd>
</dl>

<p>where <strong>N</strong> is the set of all natural numbers.</p>
<h2 id="formal-semantics">Formal semantics</h2>

<p>Mathematical Semantics is the application of <a class="uri" href="mathematics" title="wikilink">mathematics</a> to study the meaning of expressions in a formal language. It has three elements: A mathematical specification of a class of objects via <a class="uri" href="syntax" title="wikilink">syntax</a>, a mathematical specification of various semantic domains and the relation between the two, which is usually expressed as a function from syntactic objects to semantic ones. This article only addresses the issue of how quantifier elements are interpreted.</p>

<p>Given a <a href="model_theory" title="wikilink">model theoretical</a> logical framework, the syntax of a formula can be given by a syntax tree. Quantifiers have scope and a variable <em>x</em> is <a href="free_variable" title="wikilink">free</a> if it is not within the scope of a quantification for that variable. Thus in</p>

<p>

<math display="block" id="Quantifier_(logic):10">
 <semantics>
  <mrow>
   <mrow>
    <mo>‚àÄ</mo>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>‚àÉ</mo>
       <mrow>
        <mi>y</mi>
        <mi>B</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>‚à®</mo>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <exists></exists>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>B</ci>
        <interval closure="open">
         <ci>x</ci>
         <ci>y</ci>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>C</ci>
     <interval closure="open">
      <ci>y</ci>
      <ci>x</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x(\exists yB(x,y))\vee C(y,x)
  </annotation>
 </semantics>
</math>

 the occurrence of both <em>x</em> and <em>y</em> in <em>C</em>(<em>y</em>,<em>x</em>) is free.</p>

<p> An interpretation for first-order predicate calculus assumes as given a domain of individuals <em>X</em>. A formula <em>A</em> whose free variables are <em>x</em><sub>1</sub>, ..., <em>x</em><sub>n</sub> is interpreted as a <a href="Boolean_function" title="wikilink">boolean</a>-valued function <em>F</em>(<em>v</em><sub>1</sub>, ..., <em>v</em><sub><em>n</em></sub>) of <em>n</em> arguments, where each argument ranges over the domain <em>X</em>. Boolean-valued means that the function assumes one of the values <strong>T</strong> (interpreted as truth) or <strong>F</strong> (interpreted as falsehood). The interpretation of the formula</p>

<p>

<math display="block" id="Quantifier_(logic):11">
 <semantics>
  <mrow>
   <mo>‚àÄ</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <ci>A</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x_{n}A(x_{1},\ldots,x_{n})
  </annotation>
 </semantics>
</math>

 is the function <em>G</em> of <em>n</em>-1 arguments such that <em>G</em>(<em>v</em><sub>1</sub>, ...,<em>v</em><sub><em>n</em>-1</sub>) = <strong>T</strong> if and only if <em>F</em>(<em>v</em><sub>1</sub>, ..., <em>v</em><sub><em>n</em>-1</sub>, <em>w</em>) = <strong>T</strong> for every <em>w</em> in <em>X</em>. If <em>F</em>(<em>v</em><sub>1</sub>, ..., <em>v</em><sub><em>n</em>-1</sub>, <em>w</em>) = <strong>F</strong> for at least one value of <em>w</em>, then <em>G</em>(<em>v</em><sub>1</sub>, ...,<em>v</em><sub><em>n</em>-1</sub>) = <strong>F</strong>. Similarly the interpretation of the formula</p>

<p>

<math display="block" id="Quantifier_(logic):12">
 <semantics>
  <mrow>
   <mo>‚àÉ</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <ci>A</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x_{n}A(x_{1},\ldots,x_{n})
  </annotation>
 </semantics>
</math>

 is the function <em>H</em> of <em>n</em>-1 arguments such that <em>H</em>(<em>v</em><sub>1</sub>, ...,<em>v</em><sub><em>n</em>-1</sub>) = <strong>T</strong> if and only if <em>F</em>(<em>v</em><sub>1</sub>, ...,<em>v</em><sub><em>n</em>-1</sub>, <em>w</em>) = <strong>T</strong> for at least one <em>w</em> and <em>H</em>(<em>v</em><sub>1</sub>, ..., <em>v</em><sub><em>n</em>-1</sub>) = <strong>F</strong> otherwise.</p>

<p>The semantics for <a href="uniqueness_quantification" title="wikilink">uniqueness quantification</a> requires first-order predicate calculus with equality. This means there is given a distinguished two-placed predicate "="; the semantics is also modified accordingly so that "=" is always interpreted as the two-place equality relation on <em>X</em>. The interpretation of</p>

<p>

<math display="block" id="Quantifier_(logic):13">
 <semantics>
  <mrow>
   <mrow>
    <mo>‚àÉ</mo>
    <mo lspace="0pt" rspace="3.5pt">!</mo>
   </mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <factorial></factorial>
     <exists></exists>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <ci>A</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists!x_{n}A(x_{1},\ldots,x_{n})
  </annotation>
 </semantics>
</math>

 then is the function of <em>n</em>-1 arguments, which is the logical <em>and</em> of the interpretations of</p>

<p>

<math display="block" id="Quantifier_(logic):14">
 <semantics>
  <mrow>
   <mo>‚àÉ</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <ci>A</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x_{n}A(x_{1},\ldots,x_{n})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Quantifier_(logic):15">
 <semantics>
  <mrow>
   <mo>‚àÄ</mo>
   <mi>y</mi>
   <mo>,</mo>
   <mi>z</mi>
   <mrow>
    <mo>{</mo>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>‚àß</mo>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>‚üπ</mo>
    <mi>y</mi>
    <mo>=</mo>
    <mi>z</mi>
    <mo>}</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">z</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">A</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <ci>normal-‚Ä¶</ci>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="unknown">A</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <ci>normal-‚Ä¶</ci>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-,</ci>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <implies></implies>
     <csymbol cd="unknown">y</csymbol>
     <eq></eq>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall y,z\left\{A(x_{1},\ldots,x_{n-1},y)\wedge A(x_{1},\ldots,x_{n-1},z)%
\implies y=z\right\}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="paucal-multal-and-other-degree-quantifiers">Paucal, multal and other degree quantifiers</h2>

<p>None of the quantifiers previously discussed apply to a quantification such as</p>
<dl>
<dd>There are many integers <em>n</em> &lt; 100, such that <em>n</em> is divisible by 2 or 3 or 5.
</dd>
</dl>

<p>One possible interpretation mechanism can be obtained as follows: Suppose that in addition to a semantic domain <em>X</em>, we have given a <a href="probability_measure" title="wikilink">probability measure</a> P defined on <em>X</em> and cutoff numbers 0 1,...,<em>x</em><sub><em>n</em></sub> whose interpretation is the function <em>F</em> of variables <em>v</em><sub>1</sub>,...,<em>v</em><sub><em>n</em></sub> then the interpretation of</p>

<p>

<math display="block" id="Quantifier_(logic):16">
 <semantics>
  <mrow>
   <msup>
    <mo>‚àÉ</mo>
    <mi>many</mi>
   </msup>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <exists></exists>
     <ci>many</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <ci>A</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists^{\mathrm{many}}x_{n}A(x_{1},\ldots,x_{n-1},x_{n})
  </annotation>
 </semantics>
</math>

 is the function of <em>v</em><sub>1</sub>,...,<em>v</em><sub><em>n</em>-1</sub> which is <strong>T</strong> if and only if</p>

<p>

<math display="block" id="Quantifier_(logic):17">
 <semantics>
  <mrow>
   <mrow>
    <mo>P</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>w</mi>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mi>F</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>v</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <mi mathvariant="normal">‚Ä¶</mi>
         <mo>,</mo>
         <msub>
          <mi>v</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo>,</mo>
         <mi>w</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mi>ùêì</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>‚â•</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <ci>normal-P</ci>
     <apply>
      <ci>normal-:</ci>
      <ci>w</ci>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <ci>F</ci>
        <vector>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>v</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-‚Ä¶</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>v</ci>
          <apply>
           <minus></minus>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>w</ci>
        </vector>
       </apply>
       <ci>ùêì</ci>
      </apply>
     </apply>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{P}\{w:F(v_{1},\ldots,v_{n-1},w)=\mathbf{T}\}\geq b
  </annotation>
 </semantics>
</math>

 and <strong>F</strong> otherwise. Similarly, the interpretation of</p>

<p>

<math display="block" id="Quantifier_(logic):18">
 <semantics>
  <mrow>
   <msup>
    <mo>‚àÉ</mo>
    <mi>few</mi>
   </msup>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <exists></exists>
     <ci>few</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <ci>A</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists^{\mathrm{few}}x_{n}A(x_{1},\ldots,x_{n-1},x_{n})
  </annotation>
 </semantics>
</math>

 is the function of <em>v</em><sub>1</sub>,...,<em>v</em><sub><em>n</em>-1</sub> which is <strong>F</strong> if and only if</p>

<p>

<math display="block" id="Quantifier_(logic):19">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo><</mo>
   <mrow>
    <mo>P</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>w</mi>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mi>F</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>v</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <mi mathvariant="normal">‚Ä¶</mi>
         <mo>,</mo>
         <msub>
          <mi>v</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo>,</mo>
         <mi>w</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mi>ùêì</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>‚â§</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <apply>
      <ci>normal-P</ci>
      <apply>
       <ci>normal-:</ci>
       <ci>w</ci>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <ci>F</ci>
         <vector>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>v</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>normal-‚Ä¶</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>v</ci>
           <apply>
            <minus></minus>
            <ci>n</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <ci>w</ci>
         </vector>
        </apply>
        <ci>ùêì</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<\operatorname{P}\{w:F(v_{1},\ldots,v_{n-1},w)=\mathbf{T}\}\leq a
  </annotation>
 </semantics>
</math>

 and <strong>T</strong> otherwise. </p>
<h2 id="other-quantifiers">Other quantifiers</h2>

<p>A few other quantifiers have been proposed over time. In particular, the solution quantifier,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> noted ¬ß (<a href="section_sign" title="wikilink">section sign</a>) and read "those". For example:</p>

<p>

<math display="block" id="Quantifier_(logic):20">
 <semantics>
  <mrow>
   <mrow>
    <mo>[</mo>
    <mi mathvariant="normal">¬ß</mi>
    <mi>n</mi>
    <mo>‚àà</mo>
    <mi>‚Ñï</mi>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo>‚â§</mo>
    <mn>4</mn>
    <mo>]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">¬ß</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <in></in>
     <csymbol cd="unknown">N</csymbol>
     <ci></ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
     <leq></leq>
     <cn type="integer">4</cn>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <cn type="integer">0</cn>
     <ci>normal-,</ci>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <cn type="integer">2</cn>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left[\S n\in\mathbb{N}\quad n^{2}\leq 4\right]=\left\{0,1,2\right\}
  </annotation>
 </semantics>
</math>

 is read "those <em>n</em> in <strong>N</strong> such that <em>n</em><sup>2</sup> ‚â§ 4 are in {0,1,2}." The same construct is expressible in <a href="set-builder_notation" title="wikilink">set-builder notation</a>:</p>

<p>

<math display="block" id="Quantifier_(logic):21">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>n</mi>
     <mo>‚àà</mo>
     <mi>ùêç</mi>
    </mrow>
    <mo>:</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
     <mo>‚â§</mo>
     <mn>4</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>n</ci>
      <ci>ùêç</ci>
     </apply>
     <apply>
      <leq></leq>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{n\in\mathbf{N}:n^{2}\leq 4\}=\left\{0,1,2\right\}\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Some other quantifiers sometimes used in mathematics include:</p>
<ul>
<li>There are infinitely many elements such that...</li>
<li>For all but finitely many elements... (sometimes expressed as "for almost all elements...").</li>
<li>There are uncountable many elements such that...</li>
<li>For all but countably many elements...</li>
<li>For all elements in a set of positive measure...</li>
<li>For all elements except those in a set of measure zero...</li>
</ul>
<h2 id="history">History</h2>

<p><a href="Term_logic" title="wikilink">Term logic</a>, also called Aristotelian logic, treats quantification in a manner that is closer to natural language, and also less suited to formal analysis. Term logic treated <em>All</em>, <em>Some</em> and <em>No</em> in the 4th century BC, in an account also touching on the <a href="alethic_modalities" title="wikilink">alethic modalities</a>.</p>

<p><a href="Gottlob_Frege" title="wikilink">Gottlob Frege</a>, in his 1879 <em><a class="uri" href="Begriffsschrift" title="wikilink">Begriffsschrift</a></em>, was the first to employ a quantifier to bind a variable ranging over a <a href="domain_of_discourse" title="wikilink">domain of discourse</a> and appearing in <a href="Predicate_(mathematical_logic)" title="wikilink">predicates</a>. He would universally quantify a variable (or relation) by writing the variable over a dimple in an otherwise straight line appearing in his diagrammatic formulas. Frege did not devise an explicit notation for existential quantification, instead employing his equivalent of ~‚àÄ<em>x</em>~, or <a class="uri" href="contraposition" title="wikilink">contraposition</a>. Frege's treatment of quantification went largely unremarked until <a href="Bertrand_Russell" title="wikilink">Bertrand Russell</a>'s 1903 <em>Principles of Mathematics</em>.</p>

<p>In work that culminated in Peirce (1885), <a href="Charles_Sanders_Peirce" title="wikilink">Charles Sanders Peirce</a> and his student <a href="Oscar_Howard_Mitchell" title="wikilink">Oscar Howard Mitchell</a> independently invented universal and existential quantifiers, and <a href="bound_variable" title="wikilink">bound variables</a>. Peirce and Mitchell wrote Œ†<sub>x</sub> and Œ£<sub>x</sub> where we now write ‚àÄ<em>x</em> and ‚àÉ<em>x</em>. Peirce's notation can be found in the writings of <a href="Ernst_Schr√∂der" title="wikilink">Ernst Schr√∂der</a>, <a href="Leopold_Loewenheim" title="wikilink">Leopold Loewenheim</a>, <a href="Thoralf_Skolem" title="wikilink">Thoralf Skolem</a>, and Polish logicians into the 1950s. Most notably, it is the notation of <a href="Kurt_G√∂del" title="wikilink">Kurt G√∂del</a>'s landmark 1930 paper on the <a href="G√∂del's_completeness_theorem" title="wikilink">completeness</a> of <a href="first-order_logic" title="wikilink">first-order logic</a>, and 1931 paper on the <a href="G√∂del's_incompleteness_theorem" title="wikilink">incompleteness</a> of <a href="Peano_arithmetic" title="wikilink">Peano arithmetic</a>.</p>

<p>Peirce's approach to quantification also influenced <a href="William_Ernest_Johnson" title="wikilink">William Ernest Johnson</a> and <a href="Giuseppe_Peano" title="wikilink">Giuseppe Peano</a>, who invented yet another notation, namely (<em>x</em>) for the universal quantification of <em>x</em> and (in 1897) ‚àÉ<em>x</em> for the existential quantification of <em>x</em>. Hence for decades, the canonical notation in philosophy and mathematical logic was (<em>x</em>)<em>P</em> to express "all individuals in the domain of discourse have the property <em>P</em>," and "(‚àÉ<em>x</em>)<em>P</em>" for "there exists at least one individual in the domain of discourse having the property <em>P</em>." Peano, who was much better known than Peirce, in effect diffused the latter's thinking throughout Europe. Peano's notation was adopted by the <em><a href="Principia_Mathematica" title="wikilink">Principia Mathematica</a></em> of <a href="Alfred_North_Whitehead" title="wikilink">Whitehead</a> and <a href="Bertrand_Russell" title="wikilink">Russell</a>, <a href="Willard_Van_Orman_Quine" title="wikilink">Quine</a>, and <a href="Alonzo_Church" title="wikilink">Alonzo Church</a>. In 1935, <a class="uri" href="Gentzen" title="wikilink">Gentzen</a> introduced the ‚àÄ symbol, by analogy with Peano's ‚àÉ symbol. ‚àÄ did not become canonical until the 1960s.</p>

<p>Around 1895, Peirce began developing his <a href="existential_graph" title="wikilink">existential graphs</a>, whose variables can be seen as tacitly quantified. Whether the shallowest instance of a variable is even or odd determines whether that variable's quantification is universal or existential. (Shallowness is the contrary of depth, which is determined by the nesting of negations.) Peirce's graphical logic has attracted some attention in recent years by those researching <a href="heterogeneous_reasoning" title="wikilink">heterogeneous reasoning</a> and <a href="logical_graph" title="wikilink">diagrammatic inference</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Generalized_quantifier" title="wikilink">Generalized quantifier</a> ‚Äî a higher-order property used as standard semantics of quantified <a href="noun_phrases" title="wikilink">noun phrases</a></li>
<li><a href="Lindstr√∂m_quantifier" title="wikilink">Lindstr√∂m quantifier</a> ‚Äî a generalized polyadic quantifier</li>
<li><a href="Quantifier_elimination" title="wikilink">Quantifier elimination</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<ul>
<li><a href="Jon_Barwise" title="wikilink">Barwise, Jon</a>; and <a href="John_Etchemendy" title="wikilink">Etchemendy, John</a>, 2000. <em>Language Proof and Logic</em>. CSLI (University of Chicago Press) and New York: Seven Bridges Press. A gentle introduction to <a href="first-order_logic" title="wikilink">first-order logic</a> by two first-rate logicians.</li>
<li><a href="Gottlob_Frege" title="wikilink">Frege, Gottlob</a>, 1879. <em><a class="uri" href="Begriffsschrift" title="wikilink">Begriffsschrift</a></em>. Translated in <a href="Jean_van_Heijenoort" title="wikilink">Jean van Heijenoort</a>, 1967. <em>From Frege to G√∂del: A Source Book on Mathematical Logic, 1879-1931</em>. Harvard University Press. The first appearance of quantification.</li>
<li><a href="David_Hilbert" title="wikilink">Hilbert, David</a>; and <a href="Wilhelm_Ackermann" title="wikilink">Ackermann, Wilhelm</a>, 1950 (1928). <em><a href="Principles_of_Mathematical_Logic" title="wikilink">Principles of Mathematical Logic</a></em>. Chelsea. Translation of <em>Grundz√ºge der theoretischen Logik</em>. Springer-Verlag. The 1928 first edition is the first time quantification was consciously employed in the now-standard manner, namely as binding variables ranging over some fixed domain of discourse. This is the defining aspect of <a href="first-order_logic" title="wikilink">first-order logic</a>.</li>
<li><a href="Charles_Sanders_Peirce" title="wikilink">Peirce, C. S.</a>, 1885, "On the Algebra of Logic: A Contribution to the Philosophy of Notation, <em>American Journal of Mathematics</em>, Vol. 7, pp. 180‚Äì202. Reprinted in Kloesel, N. <em>et al.</em>, eds., 1993. <em>Writings of C. S. Peirce, Vol. 5</em>. Indiana University Press. The first appearance of quantification in anything like its present form.</li>
<li><a href="Hans_Reichenbach" title="wikilink">Reichenbach, Hans</a>, 1975 (1947). <em>Elements of Symbolic Logic</em>, Dover Publications. The quantifiers are discussed in chapters ¬ß18 "Binding of variables" through ¬ß30 "Derivations from Synthetic Premises".</li>
<li>Westerst√•hl, Dag, 2001, "Quantifiers," in Goble, Lou, ed., <em>The Blackwell Guide to Philosophical Logic</em>. Blackwell.</li>
<li>Wiese, Heike, 2003. <em>Numbers, language, and the human mind</em>. Cambridge University Press. ISBN 0-521-83182-2.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="Stanford_Encyclopedia_of_Philosophy" title="wikilink">Stanford Encyclopedia of Philosophy</a>:
<ul>
<li>"<a href="http://plato.stanford.edu/entries/logic-classical/">Classical Logic</a> ‚Äî by Stewart Shapiro. Covers syntax, model theory, and metatheory for first order logic in the natural deduction style.</li>
<li>"<a href="http://plato.stanford.edu/entries/generalized-quantifiers/">Generalized quantifiers</a>" ‚Äî by Dag Westerst√•hl.</li>
</ul></li>
<li>Peters, Stanley; Westerst√•hl, Dag (2002). "<a href="http://www.stanford.edu/group/nasslli/courses/peters-wes/PWbookdraft2-3.pdf">Quantifiers.</a>"</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Logic" title="wikilink">Category:Logic</a> <a href="Category:Predicate_logic" title="wikilink">Category:Predicate logic</a> <a class="uri" href="Category:Quantification" title="wikilink">Category:Quantification</a> <a href="Category:Philosophical_logic" title="wikilink">Category:Philosophical logic</a> <a class="uri" href="Category:Semantics" title="wikilink">Category:Semantics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="E._C._R._Hehner" title="wikilink">Hehner, Eric C. R.</a>, 2004, <a href="http://www.cs.utoronto.ca/~hehner/aPToP"><em>Practical Theory of Programming</em></a>, 2nd edition, p. 28<a href="#fnref1">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
