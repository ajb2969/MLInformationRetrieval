<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="699">CC (complexity)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>CC (complexity)</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, <strong>CC (Comparator Circuits)</strong> is the <a href="complexity_class" title="wikilink">complexity class</a> containing <a href="decision_problem" title="wikilink">decision problems</a> which can be solved by comparator circuits of <a class="uri" href="polynomial" title="wikilink">polynomial</a> size.</p>

<p>Comparator circuits are <a href="sorting_network" title="wikilink">sorting networks</a> in which each comparator gate is directed, each wire is initialized with an input variable, its negation, or a constant, and one of the wires is distinguished as the output wire.</p>

<p>The most important problem which is complete for <strong>CC</strong> is a decision variant of the <a href="stable_marriage_problem" title="wikilink">stable marriage problem</a>.</p>
<h2 id="definition">Definition</h2>

<p> A comparator circuit is a network of wires and gates. Each comparator gate, which is a directed edge connecting two wires, takes its two inputs and outputs them in sorted order (the larger value ending up in the wire the edge is pointing to). The input to any wire can be either a variable, its negation, or a constant. One of the wires is designated as the output wire. The function computed by the circuit is evaluated by initializing the wires according to the input variables, executing the comparator gates in order, and outputting the value carried by the output wire.</p>

<p>The comparator circuit value problem (CCVP) is the problem of evaluating a comparator circuit given an encoding of the circuit and the input to the circuit. The complexity class <strong>CC</strong> is defined as the class of problems <a href="L_(complexity)" title="wikilink">logspace</a> reducible to CCVP.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> An equivalent definition<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> is the class of problems <strong><a href="AC0" title="wikilink">AC<sup>0</sup></a></strong> reducible to CCVP.</p>

<p>As an example, a sorting network can be used to compute majority by designating the middle wire as an output wire:</p>
<figure><b>(Figure)</b>
</figure>

<p>If the middle wire is designated as output, and the wires are annotated with 16 different input variables, then the resulting comparator circuit computes majority. Since there are sorting networks which can be constructed in <strong>AC<sup>0</sup></strong>, this shows that the majority function is in <strong>CC</strong>.</p>
<h2 id="cc-complete-problems">CC-complete problems</h2>

<p>A problem in <strong>CC</strong> is <strong>CC</strong>-complete if every problem in <strong>CC</strong> can be reduced to it using a <a href="L_(complexity)" title="wikilink">logspace</a> reduction. The comparator circuit value problem (CCVP) is <strong>CC</strong>-complete.</p>

<p>In the <a href="stable_marriage_problem" title="wikilink">stable marriage problem</a>, there is an equal number of men and women. Each person ranks all members of the opposite sex. A matching between men and women is <em>stable</em> if there are no unpaired man and woman who prefer each other over their current partners. A stable matching always exists. Among the stable matchings, there is one in which each woman gets the best man that she ever gets in any stable matching; this is known as the <em>woman-optimal</em> stable matching. The decision version of the stable matching problem is, given the rankings of all men and women, whether a given man and a given woman are matched in the woman-optimal stable matching. Although the classical Gale–Shapley algorithm cannot be implemented as a comparator circuit, Subramanian<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> came up with a different algorithm showing that the problem is in <strong>CC</strong>. The problem is also <strong>CC</strong>-complete.</p>

<p>Another problem which is <strong>CC</strong>-complete is lexicographically-first maximal matching.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> In this problem, we are given a bipartite graph with an order on the vertices, and an edge. The lexicographically-first maximal matching is obtained by successively matching vertices from the first bipartition to the minimal available vertices from the second bipartition. The problem asks whether the given edge belongs to this matching.</p>

<p><a href="Scott_Aaronson" title="wikilink">Scott Aaronson</a> showed that the <em>pebbles model</em> is <strong>CC</strong>-complete.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> In this problem, we are given a starting number of pebbles (encoded in <a href="Unary_numeral_system" title="wikilink">unary</a>) and a description of a program which may contain only two types of instructions: combine two piles of sizes 

<math display="inline" id="CC_(complexity):0">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="CC_(complexity):1">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 to get a new pile of size 

<math display="inline" id="CC_(complexity):2">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>+</mo>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>y</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y+z
  </annotation>
 </semantics>
</math>

, or split a pile of size 

<math display="inline" id="CC_(complexity):3">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 into piles of size 

<math display="inline" id="CC_(complexity):4">
 <semantics>
  <mrow>
   <mo stretchy="false">⌈</mo>
   <mrow>
    <mi>y</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mo stretchy="false">⌉</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ceiling></ceiling>
    <apply>
     <divide></divide>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lceil y/2\rceil
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="CC_(complexity):5">
 <semantics>
  <mrow>
   <mo stretchy="false">⌊</mo>
   <mrow>
    <mi>y</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mo stretchy="false">⌋</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <floor></floor>
    <apply>
     <divide></divide>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lfloor y/2\rfloor
  </annotation>
 </semantics>
</math>

. The problem is to decide whether any pebbles are present in a particular pile after executing the program. He used this to show that the problem of deciding whether any balls reach a designated sink vertex in a <a href="Digi-Comp_II" title="wikilink">Digi-Comp II</a>-like device is also <strong>CC</strong>-complete.</p>
<h2 id="containments">Containments</h2>

<p>The comparator circuit evaluation problem can be solved in polynomial time, and so <strong>CC</strong> is contained in <strong><a href="P_(complexity)" title="wikilink">P</a></strong>. On the other hand, comparator circuits can solve directed reachability,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> and so <strong>CC</strong> contains <strong><a href="NL_(complexity)" title="wikilink">NL</a></strong>. There is a relativized world in which <strong>CC</strong> and <strong><a href="NC_(complexity)" title="wikilink">NC</a></strong> are incomparable,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> and so both containments are strict.</p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Circuit_complexity" title="wikilink">Category:Circuit complexity</a> <a href="Category:Complexity_classes" title="wikilink">Category:Complexity classes</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
</ol>
</section>
</body>
</html>
