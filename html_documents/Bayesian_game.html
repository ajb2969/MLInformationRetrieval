<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1625">Bayesian game</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Bayesian game</h1>
<hr/>

<p>In <a href="game_theory" title="wikilink">game theory</a>, a <strong>Bayesian game</strong> is one in which information about characteristics of the other players (i.e. payoffs) is <a href="complete_information" title="wikilink">incomplete</a>. Following <a href="John_C._Harsanyi" title="wikilink">John C. Harsanyi</a>'s framework,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> a Bayesian game can be modelled by introducing Nature as a player in a game. Nature assigns a random variable to each player which could take values of <em>types</em> for each player and associating probabilities or a probability density function with those types (in <a href="extensive_form_game" title="wikilink">the course of the game</a>, <em>nature</em> randomly <em>chooses</em> a type for each player according to the probability distribution across each player's type space). Harsanyi's approach to modelling a Bayesian game in such a way allows games of incomplete information to become games of imperfect information (in which the history of the game is not available to all players). The type of a player determines that player's payoff function. The probability associated with a type is the probability that the player, for whom the type is specified, is that type. In a Bayesian game, the incompleteness of information means that at least one player is unsure of the type (and so the payoff function) of another player.</p>

<p>Such games are called <em>Bayesian</em> because of the probabilistic analysis inherent in the game. Players have initial beliefs about the type of each player (where a belief is a probability distribution over the possible types for a player) and can update their beliefs according to <a href="Bayes'_Rule" title="wikilink">Bayes' Rule</a> as play takes place in the game, i.e. the belief a player holds about another player's type might change on the basis of the actions they have played. The lack of information held by players and modelling of beliefs mean that such games are also used to analyse <a href="perfect_information" title="wikilink">imperfect information</a> scenarios.</p>
<h2 id="specification-of-games">Specification of games</h2>

<p>The <a href="Normal_form_game" title="wikilink">normal form representation</a> of a non-Bayesian game with <a href="perfect_information" title="wikilink">perfect information</a> is a specification of the strategy spaces and payoff functions of players. A strategy for a player is a complete plan of action that covers <em>every contingency of the game</em>, even if that contingency can never arise. The strategy space of a player is thus the set of all strategies available to a player. A payoff function is a function from the set of strategy profiles to the set of payoffs (normally the set of real numbers), where a strategy profile is a vector specifying a strategy for every player.</p>

<p>In a Bayesian game, one has to specify strategy spaces, type spaces, payoff functions and beliefs for every player. A strategy for a player is a complete plan of action that covers every contingency that might arise for every type that player might be. A strategy must not only specify the actions of the player given the type that he is, but must specify the actions that he would take if he were of another type. Strategy spaces are defined as above. A type space for a player is just the set of all possible <em>types</em> of that player. The beliefs of a player describe the uncertainty of that player about the types of the other players. Each belief is the probability of the other players having particular types, given the type of the player with that belief (i.e. the belief is 

<math display="inline" id="Bayesian_game:0">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mtext>types of other players</mtext>
    <mo stretchy="false">|</mo>
    <mtext>type of this player</mtext>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>types of other players</mtext>
     <ci>normal-|</ci>
     <mtext>type of this player</mtext>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\mbox{types of other players}|\mbox{type of this player})
  </annotation>
 </semantics>
</math>


). A payoff function is a 2-place function of strategy profiles and types. If a player has payoff function 

<math display="inline" id="Bayesian_game:1">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(x,y)
  </annotation>
 </semantics>
</math>

 and he has type t, the payoff he receives is 

<math display="inline" id="Bayesian_game:2">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>x</mi>
     <mo>*</mo>
    </msup>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <times></times>
     </apply>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(x^{*},t)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Bayesian_game:3">
 <semantics>
  <msup>
   <mi>x</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{*}
  </annotation>
 </semantics>
</math>

 is the strategy profile played in the game (i.e. the vector of strategies played).</p>

<p>One of the formal definitions of such a game looks like the following:</p>

<p>The game is defined as: 

<math display="inline" id="Bayesian_game:4">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>N</mi>
    <mo>,</mo>
    <mi mathvariant="normal">Ω</mi>
    <mo>,</mo>
    <msub>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msub>
       <mi>A</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>u</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>T</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>τ</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>p</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>C</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mrow>
      <mi>i</mi>
      <mo>∈</mo>
      <mi>N</mi>
     </mrow>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <list>
     <ci>N</ci>
     <ci>normal-Ω</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>τ</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>i</ci>
       </apply>
      </list>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=\langle N,\Omega,\langle A_{i},u_{i},T_{i},\tau_{i},p_{i},C_{i}\rangle_{i\in
N}\rangle
  </annotation>
 </semantics>
</math>

, where</p>
<ol>
<li>

<math display="inline" id="Bayesian_game:5">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>


 is the set of players.</li>
<li>

<math display="inline" id="Bayesian_game:6">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 is the set of states of nature. For instance, in a card game, it can be any order of the cards.</li>
<li>

<math display="inline" id="Bayesian_game:7">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>

 is the set of actions for player 

<math display="inline" id="Bayesian_game:8">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Bayesian_game:9">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
    <mo>×</mo>
    <msub>
     <mi>A</mi>
     <mn>2</mn>
    </msub>
    <mo>×</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>×</mo>
    <msub>
     <mi>A</mi>
     <mi>N</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=A_{1}\times A_{2}\times\cdots\times A_{N}
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Bayesian_game:10">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{i}
  </annotation>
 </semantics>
</math>


 is the type of player 

<math display="inline" id="Bayesian_game:11">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, decided by the function 

<math display="inline" id="Bayesian_game:12">
 <semantics>
  <mrow>
   <msub>
    <mi>τ</mi>
    <mi>i</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mo>→</mo>
    <msub>
     <mi>T</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>τ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>normal-Ω</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{i}\colon\Omega\rightarrow T_{i}
  </annotation>
 </semantics>
</math>

. So for each state of the nature, the game will have different types of players. The outcome of the players is what determines its type. Players with the same outcome belong to the same type.</li>
<li>

<math display="inline" id="Bayesian_game:13">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>i</mi>
   </msub>
   <mo>⊆</mo>
   <mrow>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
    <mo>×</mo>
    <msub>
     <mi>T</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}\subseteq A_{i}\times T_{i}
  </annotation>
 </semantics>
</math>

 defines the available actions for player 

<math display="inline" id="Bayesian_game:14">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 of some type in 

<math display="inline" id="Bayesian_game:15">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{i}
  </annotation>
 </semantics>
</math>


.</li>
<li>

<math display="inline" id="Bayesian_game:16">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mi>i</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Ω</mi>
     <mo>×</mo>
     <mi>A</mi>
    </mrow>
    <mo>→</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>normal-Ω</ci>
      <ci>A</ci>
     </apply>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}\colon\Omega\times A\rightarrow R
  </annotation>
 </semantics>
</math>

 is the payoff function for player 

<math display="inline" id="Bayesian_game:17">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

. More formally, let 

<math display="inline" id="Bayesian_game:18">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mi>N</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mrow>
      <mi>ω</mi>
      <mo>∈</mo>
      <mrow>
       <mi mathvariant="normal">Ω</mi>
       <mo>,</mo>
       <mrow>
        <mo>∀</mo>
        <mi>i</mi>
       </mrow>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>a</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>τ</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>ω</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <msub>
       <mi>C</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <vector>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>N</ci>
      </apply>
     </vector>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <in></in>
       <ci>ω</ci>
       <list>
        <ci>normal-Ω</ci>
        <apply>
         <csymbol cd="latexml">for-all</csymbol>
         <ci>i</ci>
        </apply>
       </list>
      </apply>
      <apply>
       <in></in>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>τ</ci>
          <ci>i</ci>
         </apply>
         <ci>ω</ci>
        </apply>
       </interval>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=\{(\omega,a_{1},\ldots,a_{N})\mid\omega\in\Omega,\forall i,(a_{i},\tau_{i}(%
\omega))\in C_{i}\}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Bayesian_game:19">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mi>i</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi>L</mi>
    <mo>→</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>L</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}\colon L\rightarrow R
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Bayesian_game:20">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>


 is the probability distribution over 

<math display="inline" id="Bayesian_game:21">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 for each player 

<math display="inline" id="Bayesian_game:22">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, that is to say, each player has different views of the probability distribution over the states of the nature. In the game, they never know the exact state of the nature.</li>
</ol>

<p>The pure strategy 

<math display="inline" id="Bayesian_game:23">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>i</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>T</mi>
     <mi>i</mi>
    </msub>
    <mo>→</mo>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{i}\colon T_{i}\rightarrow A_{i}
  </annotation>
 </semantics>
</math>

 should satisfy 

<math display="inline" id="Bayesian_game:24">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>s</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>t</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>t</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi>C</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>i</ci>
     </apply>
    </interval>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s_{i}(t_{i}),t_{i})\in C_{i}
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Bayesian_game:25">
 <semantics>
  <msub>
   <mi>t</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{i}
  </annotation>
 </semantics>
</math>


. So the strategy for each player only depends on his type, since he may not have any knowledge about other players' types. And the expected payoff to player 

<math display="inline" id="Bayesian_game:26">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 for such a strategy profile is 

<math display="inline" id="Bayesian_game:27">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>u</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>E</mi>
     <mrow>
      <mi>ω</mi>
      <mo>∼</mo>
      <msub>
       <mi>p</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <msub>
       <mi>u</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ω</mi>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>s</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mi>τ</mi>
           <mn>1</mn>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>ω</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>s</mi>
         <mi>N</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mi>τ</mi>
           <mi>N</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>ω</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>i</ci>
     </apply>
     <ci>S</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">similar-to</csymbol>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>i</ci>
       </apply>
       <vector>
        <ci>ω</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>τ</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>ω</ci>
         </apply>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <ci>N</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>τ</ci>
           <ci>N</ci>
          </apply>
          <ci>ω</ci>
         </apply>
        </apply>
       </vector>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}(S)=E_{\omega\sim p_{i}}[u_{i}(\omega,s_{1}(\tau_{1}(\omega)),\ldots,s_{N%
}(\tau_{N}(\omega)))]
  </annotation>
 </semantics>
</math>

.</p>

<p>Let 

<math display="inline" id="Bayesian_game:28">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{i}
  </annotation>
 </semantics>
</math>

 be the set of pure strategies, 

<math display="inline" id="Bayesian_game:29">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>s</mi>
     <mi>i</mi>
    </msub>
    <mo>:</mo>
    <msub>
     <mi>T</mi>
     <mi>i</mi>
    </msub>
    <mo>→</mo>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
    <mo>∣</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>s</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>t</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi>t</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <msub>
     <mi>C</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <mo>∀</mo>
    <msub>
     <mi>t</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-∣</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>i</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>i</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{i}=\{s_{i}\colon T_{i}\rightarrow A_{i}\mid(s_{i}(t_{i}),t_{i})\in C_{i},%
\forall t_{i}\}.
  </annotation>
 </semantics>
</math>

</p>

<p>A Bayesian Equilibrium of the game 

<math display="inline" id="Bayesian_game:30">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>


 is defined to be a (possibly mixed strategy) Nash equilibrium of the game 

<math display="inline" id="Bayesian_game:31">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>G</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>N</mi>
    <mo>,</mo>
    <mover accent="true">
     <mi>A</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>=</mo>
    <msub>
     <mi>S</mi>
     <mn>1</mn>
    </msub>
    <mo>×</mo>
    <msub>
     <mi>S</mi>
     <mn>2</mn>
    </msub>
    <mo>×</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>×</mo>
    <msub>
     <mi>S</mi>
     <mi>N</mi>
    </msub>
    <mo>,</mo>
    <mover accent="true">
     <mi>u</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>=</mo>
    <mi>u</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>G</ci>
    </apply>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-,</ci>
     <apply>
      <ci>normal-^</ci>
      <ci>A</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">2</cn>
     </apply>
     <times></times>
     <ci>normal-⋯</ci>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>N</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <ci>normal-^</ci>
      <ci>u</ci>
     </apply>
     <eq></eq>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{G}=\langle N,\hat{A}=S_{1}\times S_{2}\times\cdots\times S_{N},\hat{u}=u\rangle
  </annotation>
 </semantics>
</math>

. So for any finite game 

<math display="inline" id="Bayesian_game:32">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, Bayesian Equilibria always exist.</p>
<h2 id="signaling">Signaling</h2>

<p><a href="Signaling_games" title="wikilink">Signaling games</a> constitute an example of Bayesian games. In such a game, the informed party (the “agent”) knows their type, whereas the uninformed party (the “principal”) does not know the (agent’s) type. In some such games, it is possible for the principal to deduce the agent's type based on the actions the agent takes (in the form of a signal sent to the principal) in what is known as a “separating equilibrium”.</p>

<p>A specific example of a signaling game is a model of the job market. The players are the applicant (agent) and the employer (principal). There are two types of applicant, skilled and unskilled. The employer does not know which the applicant is, but he does know that 90% of applicants are unskilled and 10% are skilled (type 'skilled' has a probability of 0.1 and type 'unskilled' has a 0.9 probability).</p>

<p>The employer's <a href="action_space" title="wikilink">action space</a> is the set of natural numbers, representing wages—these are used to form a contract based on how productive the applicant is expected to be. Paying larger wages to skilled workers will generate larger payoffs for employers, while wages given to unskilled workers will have a less pronounced effect. The payoff of the employer is determined thus by the skill of the applicant (if the applicant accepts a contract) and the wage paid. Crucially, the employer chooses his or her action (the wage offered) according to his or her belief as to how skilled the applicant is and this belief is largely determined through signals sent by the applicant.</p>

<p>The applicant's action space consists of two actions: either obtain a university education or abstain from university. It is less costly for a skilled worker to obtain an education, as he or she may receive scholarships, find classes less taxing, and so on. University education therefore serves as a <em>signal</em>, a means with which the applicant may communicate to the employer that he or she is, in fact, skilled.</p>

<p>One strategy the employer may use is to give all applicants a wage such that skilled applicants may attend university (due to its lower cost) but which is insufficient to provide university education for unskilled applicants. This creates a <em>separating equilibrium</em>: skilled applicants can now signify their skill by going to university, and unskilled applicants cannot. The employer can observe which workers are able to go to university, and can then maximize his or her payoff by providing high wages to skilled workers and low wages to unskilled.</p>
<h2 id="bayesian-nash-equilibrium">Bayesian Nash equilibrium</h2>

<p>In a non-Bayesian game, a strategy profile is a <a href="Nash_equilibrium" title="wikilink">Nash equilibrium</a> if every strategy in that profile is a <a href="best_response" title="wikilink">best response</a> to every other strategy in the profile; i.e., there is no strategy that a player could play that would yield a higher payoff, given all the strategies played by the other players. In a Bayesian game (where players are modeled as risk-neutral), rational players are seeking to maximize their expected payoff, given their beliefs about the other players (in the general case, where players may be risk-averse or risk-loving, the assumption is that players are <a href="Expected_utility" title="wikilink">expected utility-maximizing</a>).</p>

<p>A <em>Bayesian Nash equilibrium</em> is defined as a strategy profile and <em>beliefs specified for each player about the types of the other players</em> that maximizes the expected payoff for each player given their beliefs about the other players' types and given the strategies played by the other players.</p>

<p>This solution concept yields an abundance of equilibria in dynamic games, when no further restrictions are placed on players' beliefs. This makes Bayesian Nash equilibrium an incomplete tool with which to analyze dynamic games of incomplete information.</p>
<h2 id="perfect-bayesian-equilibrium">Perfect Bayesian equilibrium</h2>

<p>Bayesian Nash equilibrium results in some implausible equilibria in dynamic games, where players take turns sequentially rather than simultaneously. Similarly, implausible equilibria might arise in the same way that implausible Nash equilibria arise in games of perfect and complete information, such as <a href="dynamic_inconsistency" title="wikilink">incredible threats and promises</a>. Such equilibria might be eliminated in perfect and complete information games by applying <a href="subgame_perfect_Nash_equilibrium" title="wikilink">subgame perfect Nash equilibrium</a>. However, it is not always possible to avail oneself of this <a href="solution_concept" title="wikilink">solution concept</a> in incomplete information games because such games contain non-singleton information sets and since <a href="subgame" title="wikilink">subgames</a> must contain complete information sets, sometimes there is only one subgame—the entire game—and so every Nash equilibrium is trivially subgame perfect. Even if a game does have more than one subgame, the inability of subgame perfection to cut through information sets can result in implausible equilibria not being eliminated.</p>

<p>To refine the equilibria generated by the Bayesian Nash solution concept or subgame perfection, one can apply the <em>Perfect Bayesian equilibrium</em> solution concept. PBE is in the spirit of subgame perfection in that it demands that subsequent play be optimal. However, it places player beliefs on decision nodes that enables moves in non-singleton information sets to be dealt more satisfactorily.</p>

<p>So far in discussing Bayesian games, it has been assumed that information is perfect (or if imperfect, play is simultaneous). In examining dynamic games, however, it might be necessary to have the means to model imperfect information. PBE affords this means: players place beliefs on nodes occurring in their information sets, which means that the information set can be generated by nature (in the case of incomplete information) or by other players (in the case of imperfect information).</p>
<h3 id="belief-systems">Belief systems</h3>

<p>The beliefs held by players in Bayesian games can be approached more rigorously in PBE. A belief system is an assignment of probabilities to every node in the game such that the sum of probabilities in any information set is 1. The beliefs of a player are exactly those probabilities of the nodes in all the information sets at which that player has the move (a player belief might be specified as a function from the union of his information sets to [0,1]). A belief system is <em>consistent</em> for a given strategy profile if and only if the probability assigned by the system to every node is computed as the probability of that node being reached given the strategy profile, i.e. by <a href="Bayes'_rule" title="wikilink">Bayes' rule</a>.</p>
<h3 id="sequential-rationality">Sequential rationality</h3>

<p>The notion of sequential rationality is what determines the optimality of subsequent play in PBE. A strategy profile is sequentially rational at a particular information set for a particular <em>belief system</em> <a href="if_and_only_if" title="wikilink">if and only if</a> the expected payoff of the player whose information set it is (i.e. who has the move at that information set) is maximal given the strategies played by all the other players. A strategy profile is sequentially rational for a particular belief system if it satisfies the above for every information set.</p>
<h3 id="definition">Definition</h3>

<p>A perfect Bayesian equilibrium is a strategy profile and a belief system such that the strategies are sequentially rational given the belief system and the belief system is <em>consistent</em>, wherever possible, given the strategy profile.</p>

<p>It is necessary to stipulate the 'wherever possible' clause because some information sets might not be reached with the given strategy profile and hence Bayes' rule cannot be employed to calculate the probability at the nodes in those sets. Such information sets are said to be <em>off the equilibrium path</em> and any beliefs can be assigned to them. Stronger notions of consistency further restricts the beliefs that can be assigned to off-equilibrium information sets to "reasonable" ones.</p>
<h3 id="example">Example</h3>
<figure><b>(Figure)</b>
<figcaption>A Bayesian game with imperfect information represented in extensive form</figcaption>
</figure>

<p>Information in the game on the left is imperfect since player 2 does not know what player 1 does when he comes to play. If both players are rational and both know that both players are rational and everything that is known by any player is known to be known by every player (i.e. player 1 knows player 2 knows that player 1 is rational and player 2 knows this, etc. <em>ad infinitum</em> – <a href="common_knowledge_(logic)" title="wikilink">common knowledge</a>), play in the game will be as follows according to perfect Bayesian equilibrium:</p>

<p>Player 2 cannot observe player 1's move. Player 1 would like to fool player 2 into thinking he has played <em>U</em> when he has actually played <em>D</em> so that player 2 will play ''D' '' and player 1 will receive 3. In fact, there is a perfect Bayesian equilibrium where player 1 plays <em>D</em> and player 2 plays ''U' '' and player 2 holds the belief that player 1 will definitely play <em>D</em> (i.e. player 2 places a probability of 1 on the node reached if player 1 plays <em>D</em>). In this equilibrium, every strategy is rational given the beliefs held and every belief is consistent with the strategies played. In this case, the perfect Bayesian equilibrium is the only Nash equilibrium.</p>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Bayesian_statistics" title="wikilink">Game</a> <a href="Category:Game_theory" title="wikilink">Category:Game theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Harsanyi, John C., 1967/1968. "Games with Incomplete Information Played by Bayesian Players, I-III." Management Science 14 (3): 159-183 (Part I), 14 (5): 320-334 (Part II), 14 (7): 486-502 (Part III).<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
