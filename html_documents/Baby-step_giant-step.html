<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1659">Baby-step giant-step</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Baby-step giant-step</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a href="group_theory" title="wikilink">group theory</a>, a branch of mathematics, the <strong>baby-step giant-step</strong> is a <a href="Meet-in-the-middle_attack" title="wikilink">meet-in-the-middle</a> <a class="uri" href="algorithm" title="wikilink">algorithm</a> computing the <a href="discrete_logarithm" title="wikilink">discrete logarithm</a>. The discrete log problem is of fundamental importance to the area of <a href="public_key_cryptography" title="wikilink">public key cryptography</a>. Many of the most commonly used cryptography systems are based on the assumption that the discrete log is extremely difficult to compute; the more difficult it is, the more security it provides a data transfer. One way to increase the difficulty of the discrete log problem is to base the cryptosystem on a larger group.</p>
<h2 id="theory">Theory</h2>

<p>The algorithm is based on a <a href="space-time_tradeoff" title="wikilink">space-time tradeoff</a>. It is a fairly simple modification of trial multiplication, the naive method of finding discrete logarithms.</p>

<p>Given a <a href="cyclic_group" title="wikilink">cyclic group</a> 

<math display="inline" id="Baby-step_giant-step:0">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 of order 

<math display="inline" id="Baby-step_giant-step:1">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, a <a href="Generating_set_of_a_group" title="wikilink">generator</a> 

<math display="inline" id="Baby-step_giant-step:2">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 of the group and a group element 

<math display="inline" id="Baby-step_giant-step:3">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

, the problem is to find an integer 

<math display="inline" id="Baby-step_giant-step:4">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 such that</p>

<p>

<math display="block" id="Baby-step_giant-step:5">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>α</mi>
     <mi>x</mi>
    </msup>
    <mo>=</mo>
    <mpadded width="+1.7pt">
     <mi>β</mi>
    </mpadded>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <ci>x</ci>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha^{x}=\beta\,.
  </annotation>
 </semantics>
</math>

 The baby-step giant-step algorithm is based on rewriting 

<math display="inline" id="Baby-step_giant-step:6">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Baby-step_giant-step:7">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>i</mi>
     <mi>m</mi>
    </mrow>
    <mo>+</mo>
    <mi>j</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>m</ci>
     </apply>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=im+j
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Baby-step_giant-step:8">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mrow>
    <mo>⌈</mo>
    <msqrt>
     <mi>n</mi>
    </msqrt>
    <mo>⌉</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <apply>
     <ceiling></ceiling>
     <apply>
      <root></root>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=\left\lceil\sqrt{n}\right\rceil
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Baby-step_giant-step:9">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <mi>i</mi>
   <mo><</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq i<m
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Baby-step_giant-step:10">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <mi>j</mi>
   <mo><</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>j</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq j<m
  </annotation>
 </semantics>
</math>

. Therefore, we have:</p>

<p>

<math display="block" id="Baby-step_giant-step:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>β</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>α</mi>
        <mrow>
         <mo>-</mo>
         <mi>m</mi>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>i</mi>
     </msup>
    </mrow>
    <mo>=</mo>
    <mpadded width="+1.7pt">
     <msup>
      <mi>α</mi>
      <mi>j</mi>
     </msup>
    </mpadded>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>β</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>α</ci>
       <apply>
        <minus></minus>
        <ci>m</ci>
       </apply>
      </apply>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta(\alpha^{-m})^{i}=\alpha^{j}\,.
  </annotation>
 </semantics>
</math>

</p>

<p>The algorithm precomputes 

<math display="inline" id="Baby-step_giant-step:12">
 <semantics>
  <msup>
   <mi>α</mi>
   <mi>j</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>α</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha^{j}
  </annotation>
 </semantics>
</math>

 for several values of 

<math display="inline" id="Baby-step_giant-step:13">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

. Then it fixes an 

<math display="inline" id="Baby-step_giant-step:14">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 and tries values of 

<math display="inline" id="Baby-step_giant-step:15">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 in the left-hand side of the congruence above, in the manner of trial multiplication. It tests to see if the congruence is satisfied for any value of 

<math display="inline" id="Baby-step_giant-step:16">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

, using the precomputed values of 

<math display="inline" id="Baby-step_giant-step:17">
 <semantics>
  <msup>
   <mi>α</mi>
   <mi>j</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>α</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha^{j}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="the-algorithm">The algorithm</h2>

<p><strong>Input</strong>: A cyclic group <em>G</em> of order <em>n</em>, having a generator α and an element β.</p>

<p><strong>Output</strong>: A value <em>x</em> satisfying 

<math display="inline" id="Baby-step_giant-step:18">
 <semantics>
  <mrow>
   <msup>
    <mi>α</mi>
    <mi>x</mi>
   </msup>
   <mo>=</mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <ci>x</ci>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha^{x}=\beta
  </annotation>
 </semantics>
</math>

.</p>
<ol>
<li><em>m</em> ← Ceiling(√<em>n</em>)</li>
<li>For all <em>j</em> where 0 ≤ <em>j</em> <em>j</em> and store the pair (<em>j</em>, α<sup><em>j</em></sup>) in a table. (See section "In practice")</li>
<li>Compute α<sup>−<em>m</em></sup>.</li>
<li>γ ← β. (set γ = β)</li>
<li>For <em>i</em> = 0 to (<em>m</em> − 1):
<ol>
<li>Check to see if γ is the second component (α<sup><em>j</em></sup>) of any pair in the table.</li>
<li>If so, return <em>im</em> + <em>j</em>.</li>
<li>If not, γ ← γ • α<sup>−<em>m</em></sup>.</li>
</ol></li>
</ol>
<h3 id="c-algorithm-with-the-gnu-mp-lib">C algorithm with the <a href="GNU_MP" title="wikilink">GNU MP</a> lib</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> baby_step_giant_step (mpz_t g, mpz_t h, mpz_t p, mpz_t n, mpz_t x ){
   <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span> i;
   <span class="dt">long</span> <span class="dt">int</span> j = <span class="dv">0</span>;
   mpz_t N;
   mpz_t* gr ; <span class="co">/* list g^r */</span>
   <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span>* indices; <span class="co">/* indice[ i ] = k &lt;=&gt; gr[ i ] = g^k */</span>
   mpz_t hgNq ; <span class="co">/* hg^(Nq) */</span>
   mpz_t inv ; <span class="co">/* inverse of g^(N) */</span>
   mpz_init (N) ;
   mpz_sqrt (N, n ) ;
   mpz_add ui (N, N, <span class="dv">1</span> ) ;

   gr = malloc (mpz_get_ui (N) * <span class="kw">sizeof</span> (mpz_t) ) ;
   indices = malloc ( mpz_get_ui (N) * <span class="kw">sizeof</span> (<span class="dt">long</span> <span class="dt">int</span> ) ) ;
   mpz_init_set_ui (gr[ <span class="dv">0</span> ], <span class="dv">1</span>);

   <span class="co">/* find the sequence {g^r} r = 1 ,.. ,N (Baby step ) */</span>
   <span class="kw">for</span> ( i = <span class="dv">1</span> ; i &lt;= mpz_get_ui (N) ; i++) {
      indices[i - <span class="dv">1</span>] = i - <span class="dv">1</span> ;
      mpz_init (gr[ i ]) ;
      mpz_mul (gr[ i ], gr[ i - <span class="dv">1</span> ], g ); <span class="co">/* multiply gr[i - 1] for g */</span>
      mpz_mod (gr[ i ], gr[ i ], p );
   }
   <span class="co">/* sort the values (k , g^k) with respect to g^k */</span>
   qsort ( gr, indices, mpz_get_ui (N), mpz_cmp ) ;
   <span class="co">/* compute g^(-Nq)   (Giant step) */</span>
   mpz_init_set (inv, g);
   mpz_powm (inv, inv, N, p);  <span class="co">/* inv &lt;- inv ^ N (mod p)  */</span>
   mpz_invert (inv, p, inv) ;

   mpz_init_set (hgNq, h);

   <span class="co">/* find the elements in the two sequences */</span>
   <span class="kw">for</span> ( i = <span class="dv">0</span> ; i &lt;= mpz_get_ui (N) ; i++){
      <span class="co">/* find hgNq in the sequence gr ) */</span>
      j = bsearch (gr, hgNq, <span class="dv">0</span>, mpz_get_ui (N), mpz_cmp ) ;
      <span class="kw">if</span> ( j &gt;= <span class="dv">0</span> ){
         mpz_mul_ui (N, N, i);
         mpz_add_ui (N, N, indices [j]);
         mpz_set (x, N) ;
         <span class="kw">break</span>;
      }
      <span class="co">/* if j &lt; 0, find the next value of g^(Nq) */</span>
      mpz_mul (hgNq, hgNq, inv);
      mpz_mod (hgNq, hgNq, p);
   }
}</code></pre></div>
<h2 id="in-practice">In practice</h2>

<p>The best way to speed up the baby-step giant-step algorithm is to use an efficient table lookup scheme. The best in this case is a <a href="hash_table" title="wikilink">hash table</a>. The hashing is done on the second component, and to perform the check in step 1 of the main loop, γ is hashed and the resulting memory address checked. Since hash tables can retrieve and add elements in <a href="Big_O_notation" title="wikilink">O</a>(1) time (constant time), this does not slow down the overall baby-step giant-step algorithm.</p>

<p>The running time of the algorithm and the space complexity is <a href="Big_O_notation" title="wikilink">O</a>(

<math display="inline" id="Baby-step_giant-step:19">
 <semantics>
  <msqrt>
   <mi>n</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{n}
  </annotation>
 </semantics>
</math>

), much better than the <a href="Big_O_notation" title="wikilink">O</a>(n) running time of the naive brute force calculation.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>The baby-step giant-step algorithm is a generic algorithm. It works for every finite cyclic group.</li>
<li>It is not necessary to know the order of the group <em>G</em> in advance. The algorithm still works if <em>n</em> is merely an upper bound on the group order.</li>
<li>Usually the baby-step giant-step algorithm is used for groups whose order is prime. If the order of the group is composite then the <a href="Pohlig–Hellman_algorithm" title="wikilink">Pohlig–Hellman algorithm</a> is more efficient.</li>
<li>The algorithm requires <a href="Big_O_notation" title="wikilink">O</a>(<em>m</em>) memory. It is possible to use less memory by choosing a smaller <em>m</em> in the first step of the algorithm. Doing so increases the running time, which then is <a href="Big_O_notation" title="wikilink">O</a>(<em>n</em>/<em>m</em>). Alternatively one can use <a href="Pollard's_rho_algorithm_for_logarithms" title="wikilink">Pollard's rho algorithm for logarithms</a>, which has about the same running time as the baby-step giant-step algorithm, but only a small memory requirement.</li>
<li>The algorithm was originally developed by <a href="Daniel_Shanks" title="wikilink">Daniel Shanks</a>.</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>H. Cohen, A course in computational algebraic number theory, Springer, 1996.</li>
<li>D. Shanks. Class number, a theory of factorization and genera. In Proc. Symp. Pure Math. 20, pages 415—440. AMS, Providence, R.I., 1971.</li>
<li>A. Stein and E. Teske, Optimized baby step-giant step methods, Journal of the Ramanujan Mathematical Society 20 (2005), no. 1, 1–32.</li>
<li>A. V. Sutherland, <a href="http://groups.csail.mit.edu/cis/theses/sutherland-phd.pdf">Order computations in generic groups</a>, PhD thesis, M.I.T., 2007.</li>
<li>D. C. Terr, A modification of Shanks’ baby-step giant-step algorithm, Mathematics of Computation 69 (2000), 767–773.</li>
</ul>

<p>"</p>

<p><a href="Category:Group_theory" title="wikilink">Category:Group theory</a> <a href="Category:Number_theoretic_algorithms" title="wikilink">Category:Number theoretic algorithms</a> <a href="Category:Articles_with_example_C_code" title="wikilink">Category:Articles with example C code</a></p>
</body>

