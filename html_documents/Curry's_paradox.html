<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="452">Curry's paradox</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Curry's paradox</h1>
<hr/>

<p><strong>Curry's paradox</strong> is a <a class="uri" href="paradox" title="wikilink">paradox</a> that occurs in <a href="naive_set_theory" title="wikilink">naive set theory</a> or naive <a href="logic" title="wikilink">logics</a>, and allows the derivation of an arbitrary sentence from a self-referring sentence and some apparently innocuous logical deduction rules. It is named after the logician <a href="Haskell_Curry" title="wikilink">Haskell Curry</a>. While naive set theory fails to identify it, a more rigorous examination reveals that the sentence is self-contradictory.</p>

<p>It has also been called <strong>Löb's paradox</strong> after <a href="Martin_Hugo_Löb" title="wikilink">Martin Hugo Löb</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="statement-of-currys-paradox">Statement of Curry's paradox</h2>

<p>The Paradox may be expressed in natural language and in various mathematical languages;</p>
<ul>
<li>Natural language</li>
<li>Formal logic</li>
<li>Set theory</li>
<li>Logic with a string Eval function</li>
<li>Lambda calculus</li>
<li>Combinatory logic</li>
</ul>
<h3 id="natural-language">Natural language</h3>

<p>Claims of the form "if A, then B" are called <a href="indicative_conditional" title="wikilink">conditional</a> claims. Curry's paradox uses a particular kind of self-referential conditional sentence, as demonstrated in this example:</p>
<dl>
<dd>If this sentence is true, then Germany borders China.
</dd>
</dl>

<p>Even though <a class="uri" href="Germany" title="wikilink">Germany</a> does not border <a class="uri" href="China" title="wikilink">China</a>, the example sentence certainly is a natural-language sentence, and so the truth of that sentence can be analyzed. The paradox follows from this analysis. First, common natural-language proof techniques can be used to prove that the example sentence is true. (Such proofs will be shown below.) Second, the truth of the example sentence can be used to prove that Germany borders China. Because Germany does not border China, this suggests that there has been an error in one of the proofs.</p>

<p>The claim "Germany borders China" could be replaced by any other claim, and the sentence would still be provable; thus every sentence appears to be provable. Because the proof uses only well-accepted methods of deduction, and because none of these methods appears to be incorrect, this situation is paradoxical.</p>
<h4 id="proof-that-the-sentence-is-true">Proof that the sentence is true</h4>

<p>The following analysis is used to show that the sentence "If this sentence is true, then Germany borders China" is itself true. The quoted sentence is of the form "If A then B" where A refers to the sentence itself and B refers to "Germany borders China".</p>

<p>The usual method for proving a conditional sentence is to show that by assuming that hypothesis (A) is true, then the conclusion (B) can be proven from that assumption. Therefore, for the purpose of the proof, assume A.</p>

<p>Because A refers to the overall sentence, this means that assuming A is the same as assuming "If A then B". Therefore, in assuming A, we have assumed both A and "If A then B". From these, we can obtain B by <a href="modus_ponens" title="wikilink">modus ponens</a>. Therefore, A implies B and we have proved "If this sentence is true then Germany borders China" is true. Therefore "Germany borders China", but we know that is false, which is a paradox.</p>
<h3 id="formal-logic">Formal logic</h3>

<p>The example in the previous section used unformalized, natural-language reasoning. Curry's paradox also occurs in <a href="formal_logic" title="wikilink">formal logic</a>. In this context, it shows that if we assume there is a formal sentence (X → Y), where X itself is equivalent to (X → Y), then we can prove <em>Y</em> with a formal proof. One example of such a formal proof is as follows. For explanation of the logic notation used in this section, refer to the <a href="Logic_notation" title="wikilink">list of logic symbols</a>.</p>

<p>0. X := (X → Y)</p>
<dl>
<dd><em>assumption</em>, the starting point, equivalent to "If this sentence is true, then Y"
</dd>
</dl>

<p>1. X → X</p>
<dl>
<dd><em><a href="natural_deduction" title="wikilink">rule of assumption</a>, also called restatement of premise or of hypothesis</em>
</dd>
</dl>

<p>2. X → (X → Y)</p>
<dl>
<dd><em>substitute right side of 1</em>, since X is equivalent to X → Y by 0
</dd>
</dl>

<p>3. X → Y</p>
<dl>
<dd>from 2 by <em><a href="rule_of_contraction" title="wikilink">contraction</a></em>
</dd>
</dl>

<p>4. X</p>
<dl>
<dd><em>substitute 3</em>, by 0
</dd>
</dl>

<p>5. Y</p>
<dl>
<dd>from 4 and 3 by <em><a href="modus_ponens" title="wikilink">modus ponens</a></em>
</dd>
</dl>

<p>An alternative proof is via <em><a href="Peirce's_law" title="wikilink">Peirce's law</a></em>. If X = X → Y then (X → Y) → X. This together with Peirce's law ((X → Y) → X) → X and <em><a href="modus_ponens" title="wikilink">modus ponens</a></em> implies X and subsequently Y (as in above proof).</p>

<p>Therefore, if Y is an unprovable statement in a formal system, there is no statement X in that system such that X is equivalent to the implication (X → Y). By contrast, the previous section shows that in natural (unformalized) language, for every natural language statement Y there is a natural language statement Z such that Z is equivalent to (Z → Y) in natural language. Namely, Z is "If this sentence is true then Y".</p>

<p>In specific cases where the classification of Y is already known, few steps are needed to reveal the contradiction. For example, when Y is "Germany borders China," it is known that Y is false.</p>

<p>1. X = (X → Y)</p>
<dl>
<dd>assumption
</dd>
</dl>

<p>2. X = (X → false)</p>
<dl>
<dd>substitute known value of Y
</dd>
</dl>

<p>3. X = (¬X ∨ false)</p>
<dl>
<dd><em><a href="logical_implication" title="wikilink">implication</a></em>
</dd>
</dl>

<p>4. X = ¬X</p>
<dl>
<dd>identity
</dd>
</dl>
<h3 id="naive-set-theory">Naive set theory</h3>

<p>Even if the underlying mathematical logic does not admit any self-referential sentence, in set theories which allow <a href="Axiom_schema_of_specification" title="wikilink">unrestricted comprehension</a>, we can nevertheless prove any logical statement <em>Y</em> by examining the set</p>

<p>

<math display="block" id="Curry's_paradox:0">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>X</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mover>
     <mo movablelimits="false">=</mo>
     <mi>def</mi>
    </mover>
   </mpadded>
   <mrow>
    <mo>{</mo>
    <mi>x</mi>
    <mo>∣</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>∈</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>Y</mi>
    <mo>}</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">X</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <ci>def</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-∣</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <in></in>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\ \stackrel{\mathrm{def}}{=}\ \left\{x\mid(x\in x)\to Y\right\}.
  </annotation>
 </semantics>
</math>

</p>

<p>The proof proceeds as follows:</p>
<ol>
<li>

<math display="inline" id="Curry's_paradox:1">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>∈</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>∈</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <in></in>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">iff</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">X</csymbol>
      <in></in>
      <csymbol cd="unknown">X</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (X\in X)\iff((X\in X)\to Y)
  </annotation>
 </semantics>
</math>


<dl>
<dd>Definition of X
</dd>
</dl></li>
<li>

<math display="inline" id="Curry's_paradox:2">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>∈</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>∈</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <in></in>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">X</csymbol>
      <in></in>
      <csymbol cd="unknown">X</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (X\in X)\to((X\in X)\to Y)
  </annotation>
 </semantics>
</math>


<dl>
<dd>from 1
</dd>
</dl></li>
<li>

<math display="inline" id="Curry's_paradox:3">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>∈</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <in></in>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">Y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (X\in X)\to Y
  </annotation>
 </semantics>
</math>


<dl>
<dd>from 2, contraction
</dd>
</dl></li>
<li>

<math display="inline" id="Curry's_paradox:4">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>∈</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>∈</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">X</csymbol>
      <in></in>
      <csymbol cd="unknown">X</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <in></in>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((X\in X)\to Y)\to(X\in X)
  </annotation>
 </semantics>
</math>


<dl>
<dd>from 1
</dd>
</dl></li>
<li>

<math display="inline" id="Curry's_paradox:5">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>X</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\in X
  </annotation>
 </semantics>
</math>


<dl>
<dd>from 3 and 4, modus ponens
</dd>
</dl></li>
<li>

<math display="inline" id="Curry's_paradox:6">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>


<dl>
<dd>from 3 and 5, modus ponens
</dd>
</dl></li>
</ol>

<p>Therefore, in a consistent set theory, the set 

<math display="inline" id="Curry's_paradox:7">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mi>x</mi>
   <mo>∣</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>Y</mi>
   <mo>}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-{</ci>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-∣</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">Y</csymbol>
    <ci>normal-}</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\{x\mid(x\in x)\to Y\right\}
  </annotation>
 </semantics>
</math>

 does not exist for false <em>Y</em>. This can be seen as a variant on <a href="Russell's_paradox" title="wikilink">Russell's paradox</a>, but is not identical. Some proposals for set theory have attempted to deal with <a href="Russell's_paradox" title="wikilink">Russell's paradox</a> not by restricting the rule of comprehension, but by restricting the rules of logic so that it tolerates the contradictory nature of the set of all sets that are not members of themselves. The existence of proofs like the one above shows that such a task is not so simple, because at least one of the deduction rules used in the proof above must be omitted or restricted.</p>
<h3 id="logic-with-a-string-eval-function">Logic with a string Eval function</h3>

<p>Suppose there is a function called <a class="uri" href="eval" title="wikilink">eval</a>, that takes a string and converts it into a logical expression. Then consider the string,</p>
<dl>
<dd>s = "eval(s) → y"
</dd>
</dl>

<p>then the expression,</p>
<dl>
<dd>eval(s) = eval(s) → y
</dd>
</dl>

<p>again gives Curry's paradox.</p>
<h3 id="lambda-calculus">Lambda calculus</h3>

<p>Curry's paradox may be expressed in <a href="Lambda_calculus" title="wikilink">Lambda calculus</a>. Consider a function <em>r</em> defined as</p>
<dl>
<dd><em>r</em> = ( λ<em>x</em>. ((<em>x</em> <em>x</em>) → <em>y</em>) )
</dd>
</dl>

<p>Then (<em>r</em> <em>r</em>) <a href="Lambda_calculus#β-reduction" title="wikilink">β-reduces</a> to</p>
<dl>
<dd>(<em>r</em> <em>r</em>) → <em>y</em>
</dd>
</dl>

<p>If (<em>r</em> <em>r</em>) is true then its reduct (<em>r</em> <em>r</em>) → <em>y</em> is also true, and, by <a href="modus_ponens" title="wikilink">modus ponens</a>, so is <em>y</em>. If (<em>r</em> <em>r</em>) is false then (<em>r</em> <em>r</em>) → <em>y</em> is true by the <a href="principle_of_explosion" title="wikilink">principle of explosion</a>, which is a contradiction. So <em>y</em> is true and as <em>y</em> can be any statement, any statement may be proved true.</p>

<p>(<em>r</em> <em>r</em>) is a non-terminating computation. Considered as logic, (<em>r</em> <em>r</em>) is an expression for a value that does not exist.</p>

<p>In <a href="simply_typed_lambda_calculus" title="wikilink">simply typed lambda calculus</a>, such terms, like any <a href="Lambda_calculus#Recursion_and_fixed_points" title="wikilink">fixed point combinators</a>, cannot be <a href="simply_typed_lambda_calculus#Typing_rules" title="wikilink">typed</a> and hence aren't admitted; this is sufficient to avoid consistency problems in combination with logical junctors. The programming language <a class="uri" href="λProlog" title="wikilink">λProlog</a> is based on such a combination. </p>
<h3 id="combinatory-logic">Combinatory logic</h3>

<p>Curry's paradox may also be expressed in <a href="combinatory_logic" title="wikilink">combinatory logic</a>, which has equivalent expressive power to <a href="lambda_calculus" title="wikilink">lambda calculus</a>. Any lambda expression may be translated into combinatory logic, so a translation of the implementation of Curry's paradox in lambda calculus would suffice.</p>

<p>If m is the implication function taking two parameters (that is m A B is equivalent to A → B), then r in combinatory logic is,</p>
<dl>
<dd>r = S (S (K m) (S I I)) (K y)
</dd>
</dl>

<p>then</p>
<dl>
<dd>r r = m (r r) y
</dd>
</dl>

<p>The paradox may also be produced using the <a href="Fixed-point_combinator" title="wikilink">Curry's paradoxical combinator</a>, where,</p>

<p>

<math display="block" id="Curry's_paradox:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>=</mo>
    <mrow>
     <mi>λ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>x</mi>
    <mo>→</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>λ</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=\lambda x.x\to y
  </annotation>
 </semantics>
</math>

 = S m (K y)</p>

<p>Then,</p>
<dl>
<dd>Y f
</dd>
</dl>

<p>is the solution of,</p>

<p>

<math display="block" id="Curry's_paradox:9">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mi>x</mi>
   <mo>→</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>x</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=x\to y
  </annotation>
 </semantics>
</math>

</p>

<p>so</p>
<dl>
<dd>Y f = m (Y f) y
</dd>
</dl>
<h2 id="discussion">Discussion</h2>
<h3 id="terminology">Terminology</h3>

<p>Natural language and mathematical logic are both based on asserting some statements to be true. A statement may be represented as a logical (or boolean) expression (or <a href="Well-formed_formula" title="wikilink">formula</a>) which may be evaluated to give a value of true or false. An assertion is a statement or logical expression that, it is asserted, when evaluated, will give the value true.</p>

<p>Statements may also be considered in more complex ways. Statements may be qualified by who states, or believe them, and by level of certainty. However, for logic, the simple definition given above is sufficient.</p>
<h3 id="existence-problem">Existence problem</h3>

<p>This paradox is similar to,</p>
<ul>
<li><a href="Liar_paradox" title="wikilink">Liar paradox</a></li>
<li><a href="Russell's_paradox" title="wikilink">Russell's paradox</a></li>
</ul>

<p>in that each paradox attempts to give a name for something that does not exist. These paradoxes all attempt to give a name or representation to a solution to the equation,</p>
<dl>
<dd>X = ¬X
</dd>
</dl>

<p>Note that the paradox does not arise from asserting the statement of ¬X, as such a statement would be a lie. It arises from the consideration and naming of the statement. The paradox arises by naming or representing an expression of the form ¬X to be X. In the case of Curry's Paradox, the negation is constructed from implication,</p>
<dl>
<dd>X = X → false = ¬X ∨ false = ¬X
</dd>
</dl>

<p>The domain of a boolean variable X is the set {true, false}. However neither <em>true</em> or <em>false</em> is a solution to the above equation. So it must be wrong to assert the existence of X, and it is falsehood to name the expression ¬X as X.</p>

<p>The paradox exists whenever an expression can be constructed whose value does not exist. This may be achieved using "this statement", but there are many other language features that allow the construction of an expression that does not exist.</p>
<h3 id="language-capabilities-for-expressing-the-paradox">Language capabilities for expressing the paradox</h3>

<p>Curry's paradox can be formulated in any language supporting basic logic operations that also allows a self-recursive function to be constructed as an expression. The following list gives some mechanisms that support the construction of the paradox but the list is not exhaustive.</p>
<ol>
<li>Self-reference; "this sentence".</li>
<li>Through naming of an expression which includes the name.</li>
<li>Apply naive set theory (<a href="Unrestricted_comprehension#Unrestricted_comprehension" title="wikilink">Unrestricted comprehension</a>).</li>
<li>Lambda expressions.</li>
<li>An <em>Eval</em> function on a string.</li>
</ol>

<p>The logic rules used in the construction of the proof are,</p>
<ol>
<li><a href="natural_deduction" title="wikilink">rule of assumption</a></li>
<li><a href="rule_of_contraction" title="wikilink">contraction</a></li>
<li><a href="modus_ponens" title="wikilink">modus ponens</a></li>
</ol>

<p>The self-recursive function can then be used to define a non terminating computation whose value is solution to an equation. In Curry's Paradox we use implication to construct a negation, that constructs an equation with no solution.</p>

<p>The recursive expression then represents a value that does not exist. The <a href="Propositional_calculus" title="wikilink">laws of logic</a> are only valid for Boolean values in {true, false}, so any deduction made from the expression may be in error.</p>

<p>Natural languages nearly always contain many of features that could be used to construct the paradox, as do many other languages. Usually the addition of meta programming capabilities to a language will add the features needed.</p>

<p>Mathematical logic generally does not countenance explicit reference to its own sentences. However the heart of <a href="Gödel's_incompleteness_theorems" title="wikilink">Gödel's incompleteness theorems</a> is the observation that a self-reference can be added; see <a href="Gödel_number" title="wikilink">Gödel number</a>.</p>

<p>The axiom of <a href="Unrestricted_comprehension#Unrestricted_comprehension" title="wikilink">Unrestricted comprehension</a> adds the ability to construct a recursive definition in set theory. This axiom is not supported by <a href="Zermelo–Fraenkel_set_theory" title="wikilink">modern set theory</a>.</p>
<h3 id="consequences-for-some-formal-logic">Consequences for some formal logic</h3>

<p>In the 1930s, Curry's Paradox and the related <a href="Kleene–Rosser_paradox" title="wikilink">Kleene–Rosser paradox</a> played a major role in showing that formal logic systems based on self-recursive expressions are <a href="Consistency" title="wikilink">inconsistent</a>.</p>
<ul>
<li><a href="Lambda_calculus" title="wikilink">Lambda calculus</a></li>
<li><a href="Combinatory_logic" title="wikilink">Combinatory logic</a></li>
</ul>

<p>Curry started with the <a href="Kleene–Rosser_paradox" title="wikilink">Kleene–Rosser paradox</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and deduced that the core problem could be expressed in this simpler Curry's paradox.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> His conclusion may be stated as saying that the Combinatory logic and Lambda calculus could not be made consistent as a deductive language, while allowing recursion.</p>

<p>In the study of illative (deductive) <a href="combinatory_logic" title="wikilink">combinatory logic</a>, Curry in 1941<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> recognized the implication of the paradox as implying that, without restrictions, the following properties of a combinatory logic are incompatible:</p>
<ol>
<li><em>Combinatorial completeness</em>. This means that an abstraction operator is definable (or primitive) in the system, which is a requirement on the expressive power of the system.</li>
<li><em>Deductive completeness</em>. This is a requirement on derivability, namely, the principle that in a formal system with material implication and modus ponens, if Y is provable from the hypothesis X, then there is also a proof of X → Y.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
</ol>
<h2 id="resolution">Resolution</h2>

<p>Note that unlike the liar paradox or Russell's paradox, this paradox does not depend on what <a href="law_of_non-contradiction" title="wikilink">model of negation</a> is used, as it is completely negation-free. Thus <a href="paraconsistent_logics" title="wikilink">paraconsistent logics</a> can still be vulnerable to this, even if they are immune to the liar paradox.</p>
<h3 id="no-resolution-in-lambda-calculus">No resolution in lambda calculus</h3>

<p>The origin of <a href="Alonzo_Church" title="wikilink">Alonzo Church's</a> <a href="lambda_calculus" title="wikilink">lambda calculus</a> may have been, "How can you solve an equation, to provide a definition of a function?". This is expressed in this equivalence,</p>

<p>

<math display="block" id="Curry's_paradox:10">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mi>x</mi>
   <mo>=</mo>
   <mi>y</mi>
   <mo>⇔</mo>
   <mi>f</mi>
   <mo>=</mo>
   <mi>λ</mi>
   <mi>x</mi>
   <mo>.</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <csymbol cd="unknown">y</csymbol>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <eq></eq>
    <csymbol cd="unknown">λ</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ x=y\iff f=\lambda x.y
  </annotation>
 </semantics>
</math>

</p>

<p>This definition is valid if there is one and only one function 

<math display="inline" id="Curry's_paradox:11">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 that satisfies the equation 

<math display="inline" id="Curry's_paradox:12">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ x=y
  </annotation>
 </semantics>
</math>

 but invalid otherwise. This is the core of the problem that <a href="Stephen_Cole_Kleene" title="wikilink">Stephen Cole Kleene</a> and then <a href="Haskell_Curry" title="wikilink">Haskell Curry</a> discovered with Combinatory logic and Lambda calculus.</p>

<p>The situation may be compared to defining,</p>

<p>

<math display="block" id="Curry's_paradox:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mo>=</mo>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <msqrt>
     <mi>y</mi>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <apply>
     <eq></eq>
     <ci>y</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>x</ci>
     <apply>
      <root></root>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=x^{2}\iff x=\sqrt{y}
  </annotation>
 </semantics>
</math>

</p>

<p>This definition is fine as long as only positive values are allowed for the square root. In mathematics an <a href="Existential_quantification" title="wikilink">existentially quantified</a> variable may represent multiple values, but only one at a time. Existential quantification is the <a href="Logical_disjunction" title="wikilink">disjunction</a> of many instances of an equation. In each equation there is one value for the variable.</p>

<p>However, in mathematics, an expression with no <a href="Free_variables_and_bound_variables" title="wikilink">free variables</a> must have one and only one value. So 

<math display="inline" id="Curry's_paradox:14">
 <semantics>
  <msqrt>
   <mn>4</mn>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{4}
  </annotation>
 </semantics>
</math>

 can only represent 

<math display="inline" id="Curry's_paradox:15">
 <semantics>
  <mrow>
   <mo>+</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   +2
  </annotation>
 </semantics>
</math>

. However there is no convenient way to restrict the lambda abstraction to one value, or to assure that there is a value.</p>

<p>Lambda calculus allows recursion by passing the same function as called, as a parameter. This allows situations where 

<math display="inline" id="Curry's_paradox:16">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\ x=y
  </annotation>
 </semantics>
</math>

 has multiple, or no solutions for 

<math display="inline" id="Curry's_paradox:17">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

.</p>

<p>Lambda calculus may be considered as part of mathematics if only lambda abstractions that represent a single solution to an equation are allowed. Other lambda abstractions are incorrect in mathematics.</p>

<p>Curry's paradox, and other paradoxes arise in Lambda Calculus because of the inconsistency of Lambda calculus considered as a <a href="deductive_system" title="wikilink">deductive system</a>. See also <a href="deductive_lambda_calculus" title="wikilink">deductive lambda calculus</a>.</p>
<h4 id="domain-of-lambda-calculus-terms">Domain of lambda calculus terms</h4>

<p>Lambda calculus is a consistent theory in its <a href="Deductive_lambda_calculus#Domain_of_lambda_calculus" title="wikilink">own domain</a>. However it is not consistent to add the lambda abstraction definition to <a href="mathematics" title="wikilink">general mathematics</a>. Lambda terms describe values from the lambda calculus domain. Each lambda term has a value in that domain.</p>

<p>When translating expressions from mathematics to lambda calculus the domain of lambda calculus terms is not always <a href="isomorphism" title="wikilink">isomorphic</a> to the domain of the mathematical expressions. This lack of isomorphism is the source of the apparent contradictions.</p>
<h3 id="resolution-in-unrestricted-languages">Resolution in unrestricted languages</h3>

<p>There are many language constructs that implicitly invoke an equation that may have none or many solutions. The sound resolution to this problem is to syntactically link these expressions to an existentially quantified variable. The variable represents the multiple values in a way that is meaningful in common human reasoning, but is also valid in mathematics.</p>

<p>For example a natural language that allows the <em>Eval</em> function is not mathematically consistent. But each call to <em>Eval</em> in that natural language may be translated into mathematics in a way that is consistent. The translation of <em>Eval(s)</em> into mathematics is,</p>
<dl>
<dd>let x = Eval(s) in x
</dd>
</dl>

<p>So where s = "Eval(s) → y"</p>
<dl>
<dd>let x = x → y in x
</dd>
</dl>

<p>If y is false then the x = x → y is false, but this is a falsehood, not a paradox.</p>

<p>The existence of the variable x was implicit in the natural language. The variable x is created when the natural language is translated into mathematics. This allows us to use natural language, with natural semantics, while maintaining mathematical integrity.</p>
<h3 id="resolution-in-formal-logic">Resolution in formal logic</h3>

<p>The argument in formal logic starts with assuming the validity of naming (X → Y) as X. However this is not a valid starting point. First we must deduce the validity of the naming. The following theorem is easily proved and represents such a naming.</p>

<p>

<math display="block" id="Curry's_paradox:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>A</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo>∃</mo>
     <mi>X</mi>
    </mrow>
    <mo>,</mo>
    <mi>X</mi>
   </mrow>
   <mo>=</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>A</ci>
     </apply>
     <apply>
      <exists></exists>
      <ci>X</ci>
     </apply>
     <ci>X</ci>
    </list>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall A,\exists X,X=A
  </annotation>
 </semantics>
</math>

</p>

<p>In the above statement the formula A is named as X. Now attempt to <a href="Universal_instantiation" title="wikilink">instantiate</a> the formula with (X → Y) for A. However this is not possible as the scope of 

<math display="inline" id="Curry's_paradox:19">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists X
  </annotation>
 </semantics>
</math>

 is inside the scope of 

<math display="inline" id="Curry's_paradox:20">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall A
  </annotation>
 </semantics>
</math>

. The order of the quantifiers may be reversed using <a href="Skolem_normal_form" title="wikilink">Skolemization</a>.</p>

<p>

<math display="block" id="Curry's_paradox:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∃</mo>
     <mi>f</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo>∀</mo>
     <mi>A</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <exists></exists>
      <ci>f</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>A</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>A</ci>
     </apply>
    </list>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists f,\forall A,f(A)=A
  </annotation>
 </semantics>
</math>

</p>

<p>However now instantiation gives,</p>

<p>

<math display="block" id="Curry's_paradox:22">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>→</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>X</mi>
   <mo>→</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">X</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">Y</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(X\to Y)=X\to Y
  </annotation>
 </semantics>
</math>

</p>

<p>which is not the starting point for the proof and does not lead to a contradiction. There are no other instantiations for A that lead to the starting point of the paradox.</p>
<h3 id="resolution-in-set-theory">Resolution in set theory</h3>

<p>In <a href="ZFC" title="wikilink">Zermelo–Fraenkel set theory</a> the <a href="Axiom_schema_of_specification" title="wikilink">axiom of unrestricted comprehension</a> is replaced with a group of axioms that allow construction of sets. So Curry's paradox cannot be stated in ZFC. ZFC evolved in response to Russell's paradox.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Russell's_paradox" title="wikilink">Russell's paradox</a></li>
<li><a href="Girard's_paradox" title="wikilink">Girard's paradox</a></li>
<li><a href="Kleene–Rosser_paradox" title="wikilink">Kleene–Rosser paradox</a></li>
<li><a href="List_of_paradoxes" title="wikilink">List of paradoxes</a></li>
<li><a href="Richard's_paradox" title="wikilink">Richard's paradox</a></li>
<li><a href="Zermelo–Fraenkel_set_theory" title="wikilink">Zermelo–Fraenkel set theory</a></li>
<li><a href="Fixed-point_combinator" title="wikilink">Fixed-point combinator</a></li>
<li><a href="Deductive_lambda_calculus" title="wikilink">Deductive lambda calculus</a></li>
<li><a href="Let_expression" title="wikilink">Let expression</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
<li><a href="http://xeny.net/PenguinsRuleTheUniverse">Penguins Rule the Universe: A Proof that Penguins Rule the Universe</a>, a brief and entertaining discussion of Curry's paradox.</li>
<li><a href="http://arxiv.org/abs/0804.4818">Relevant First-Order Logic LP# and Curry's Paradox</a> by Jaykov Foukzon</li>
<li><a href="http://ru.scribd.com/doc/115667544?secret_password=2gzzmxsoylip718oxbvd">Inconsistent countable set</a> by Jaykov Foukzon</li>
</ul>

<p>"</p>

<p><a href="Category:Mathematics_paradoxes" title="wikilink">Category:Mathematics paradoxes</a> <a href="Category:Mathematical_logic" title="wikilink">Category:Mathematical logic</a> <a href="Category:Paradoxes_of_naive_set_theory" title="wikilink">Category:Paradoxes of naive set theory</a> <a href="Category:Self-referential_paradoxes" title="wikilink">Category:Self-referential paradoxes</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">The Inconsistency of Certain Formal Logic Haskell B. Curry The Journal of Symbolic Logic Vol. 7, No. 3 (Sep., 1942), pp. 115-117 Published by: Association for Symbolic Logic Article Stable URL: <a class="uri" href="http://www.jstor.org/stable/2269292">http://www.jstor.org/stable/2269292</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
