<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="882">Recursion</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Recursion</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p> <strong>Recursion</strong> is the process of repeating items in a <a href="Self-similarity" title="wikilink">self-similar</a> way. For instance, when the surfaces of two mirrors are exactly parallel with each other, the nested images that occur are a form of infinite recursion. The term has a variety of meanings specific to a variety of disciplines ranging from <a class="uri" href="linguistics" title="wikilink">linguistics</a> to <a class="uri" href="logic" title="wikilink">logic</a>. The most common application of recursion is in <a class="uri" href="mathematics" title="wikilink">mathematics</a> and <a href="computer_science" title="wikilink">computer science</a>, in which it refers to a method of defining <a href="function_(mathematics)" title="wikilink">functions</a> in which the function being defined is applied within its own definition. Specifically, this defines an infinite number of instances (function values), using a finite expression that for some instances may refer to other instances, but in such a way that no loop or infinite chain of references can occur. The term is also used more generally to describe a process of repeating objects in a self-similar way.</p>
<h2 id="formal-definitions">Formal definitions</h2>
<figure><b>(Figure)</b>
<figcaption>Recursion in a screen recording program, where the smaller window contains a snapshot of the entire screen.</figcaption>
</figure>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a> and <a href="computer_science" title="wikilink">computer science</a>, a class of objects or methods exhibit recursive behavior when they can be defined by two properties:</p>
<ol>
<li>

<p>A simple <strong>base case</strong> (or cases)â€”a terminating scenario that does not use recursion to produce an answer</p></li>
<li>A set of rules that reduce all other cases toward the base case</li>
</ol>

<p>For example, the following is a recursive definition of a person's ancestors:</p>
<ul>
<li>One's <a href="parent" title="wikilink">parents</a> are one's <a href="ancestor" title="wikilink">ancestors</a> (<em>base case</em>).</li>
<li>The ancestors of one's ancestors are also one's ancestors (<em>recursion step</em>).</li>
</ul>

<p>The <a href="Fibonacci_sequence" title="wikilink">Fibonacci sequence</a> is a classic example of recursion:</p>

<p>

<math display="inline" id="Recursion:0">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Fib</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mtext>as base case 1,</mtext>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>Fib</mtext>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">0</cn>
     <mtext>as base case 1,</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Fib}(0)=0\text{ as base case 1,}
  </annotation>
 </semantics>
</math>


 

<math display="inline" id="Recursion:1">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Fib</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mtext>as base case 2,</mtext>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>Fib</mtext>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <mtext>as base case 2,</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Fib}(1)=1\text{ as base case 2,}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Recursion:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mtext>For all integers</mtext>
      <mi>n</mi>
     </mrow>
     <mo>></mo>
     <mn>1</mn>
    </mrow>
    <mo rspace="5.8pt">,</mo>
    <mrow>
     <mrow>
      <mtext>Fib</mtext>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>:=</mo>
     <mrow>
      <mrow>
       <mtext>Fib</mtext>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mtext>Fib</mtext>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>2</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <gt></gt>
     <apply>
      <times></times>
      <mtext>For all integers</mtext>
      <ci>n</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <times></times>
      <mtext>Fib</mtext>
      <ci>n</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <mtext>Fib</mtext>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <mtext>Fib</mtext>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{For all integers }n>1,~{}\text{ Fib}(n):=\text{Fib}(n-1)+\text{Fib}(n-2).
  </annotation>
 </semantics>
</math>

</p>

<p>Many mathematical axioms are based upon recursive rules. For example, the formal definition of the <a href="natural_number" title="wikilink">natural numbers</a> by the <a href="Peano_axioms" title="wikilink">Peano axioms</a> can be described as: <em>0 is a natural number, and each natural number has a successor, which is also a natural number.</em> By this base case and recursive rule, one can generate the set of all natural numbers.</p>

<p>Recursively defined mathematical objects include <a href="function_(mathematics)" title="wikilink">functions</a>, <a href="set_(mathematics)" title="wikilink">sets</a>, and especially <a href="fractal" title="wikilink">fractals</a>.</p>

<p>There are various more tongue-in-cheek "definitions" of recursion; see <a href="#Recursive_humor" title="wikilink">recursive humor</a>.</p>
<h2 id="informal-definition">Informal definition</h2>
<figure><b>(Figure)</b>
<figcaption>Recently refreshed <a class="uri" href="sourdough" title="wikilink">sourdough</a>, bubbling through <a class="uri" href="fermentation" title="wikilink">fermentation</a>: the <a class="uri" href="recipe" title="wikilink">recipe</a> calls for some sourdough left over from the last time the same recipe was made.</figcaption>
</figure>

<p>Recursion is the process a procedure goes through when one of the steps of the procedure involves invoking the procedure itself. A procedure that goes through recursion is said to be 'recursive'.</p>

<p>To understand recursion, one must recognize the distinction between a procedure and the running of a procedure. A procedure is a set of steps based on a set of rules. The running of a procedure involves actually following the rules and performing the steps. An analogy: a procedure is like a written recipe; running a procedure is like actually preparing the meal.</p>

<p>Recursion is related to, but not the same as, a reference within the specification of a procedure to the execution of some other procedure. For instance, a recipe might refer to cooking vegetables, which is another procedure that in turn requires heating water, and so forth. However, a recursive procedure is where (at least) one of its steps calls for a new instance of the very same procedure, like a <a class="uri" href="sourdough" title="wikilink">sourdough</a> recipe calling for some dough left over from the last time the same recipe was made. This of course immediately creates the possibility of an endless loop; recursion can only be properly used in a definition if the step in question is skipped in certain cases so that the procedure can complete, like a sourdough recipe that also tells you how to get some starter dough in case you've never made it before. Even if properly defined, a recursive procedure is not easy for humans to perform, as it requires distinguishing the new from the old (partially executed) invocation of the procedure; this requires some administration of how far various simultaneous instances of the procedures have progressed. For this reason recursive definitions are very rare in everyday situations. An example could be the following procedure to find a way through a <a class="uri" href="maze" title="wikilink">maze</a>. Proceed forward until reaching either an exit or a branching point (a dead end is considered a branching point with 0 branches). If the point reached is an exit, terminate. Otherwise try each branch in turn, using the procedure recursively; if every trial fails by reaching only dead ends, return on the path that led to this branching point and report failure. Whether this actually defines a terminating procedure depends on the nature of the maze: it must not allow loops. In any case, executing the procedure requires carefully recording all currently explored branching points, and which of their branches have already been exhaustively tried.</p>
<h2 id="in-language">In language</h2>

<p>Linguist <a href="Noam_Chomsky" title="wikilink">Noam Chomsky</a> among many others has argued that the lack of an upper bound on the number of grammatical sentences in a language, and the lack of an upper bound on grammatical sentence length (beyond practical constraints such as the time available to utter one), can be explained as the consequence of recursion in natural language.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> This can be understood in terms of a recursive definition of a syntactic category, such as a sentence. A sentence can have a structure in which what follows the verb is another sentence: <em>Dorothy thinks witches are dangerous</em>, in which the sentence <em>witches are dangerous</em> occurs in the larger one. So a sentence can be defined recursively (very roughly) as something with a structure that includes a noun phrase, a verb, and optionally another sentence. This is really just a special case of the mathematical definition of recursion.</p>

<p>This provides a way of understanding the creativity of languageâ€”the unbounded number of grammatical sentencesâ€”because it immediately predicts that sentences can be of arbitrary length: <em>Dorothy thinks that Toto suspects that Tin Man said that...</em>. Of course, there are many structures apart from sentences that can be defined recursively, and therefore many ways in which a sentence can embed instances of one category inside another. Over the years, languages in general have proved amenable to this kind of analysis.</p>

<p>Recently, however, the generally-accepted idea that recursion is an essential property of human language has been challenged by <a href="Daniel_Everett" title="wikilink">Daniel Everett</a> on the basis of his claims about the <a href="PirahÃ£_language" title="wikilink">PirahÃ£ language</a>. Andrew Nevins, David Pesetsky and Cilene Rodrigues are among many who that have argued against this.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Literary <a class="uri" href="self-reference" title="wikilink">self-reference</a> can in any case be argued to be different in kind from mathematical or logical recursion.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Recursion plays a crucial role not only in syntax, but also in natural language semantics. The word <em>and</em>, for example, can be construed as a function that can apply to sentence meanings to create new sentences, and likewise for noun phrase meanings, verb phrase meanings, and others. It can also apply to intransitive verbs, transitive verbs, or ditransitive verbs. In order to provide a single denotation for it that is suitably flexible, <em>and</em> is typically defined so that it can take any of these different types of meanings as arguments. This can be done by defining it for a simple case in which it combines sentences, and then defining the other cases recursively in terms of the simple one.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="recursive-humor">Recursive humor</h3>

<p>Recursion is sometimes used humorously in computer science, programming, philosophy, or mathematics textbooks, generally by giving a <a href="circular_definition" title="wikilink">circular definition</a> or <a class="uri" href="self-reference" title="wikilink">self-reference</a>, in which the putative recursive step does not get closer to a base case, but instead leads to an <a href="infinite_regress" title="wikilink">infinite regress</a>. It is not unusual for such books to include a joke entry in their <a class="uri" href="glossary" title="wikilink">glossary</a> along the lines of:</p>
<dl>
<dd>Recursion, <em>see Recursion</em>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a>
</dd>
</dl>

<p>A variation is found on page 269 in the <a href="Back-of-the-book_index" title="wikilink">index</a> of some editions of <a href="Brian_Kernighan" title="wikilink">Brian Kernighan</a> and <a href="Dennis_Ritchie" title="wikilink">Dennis Ritchie</a>'s book <em><a href="The_C_Programming_Language_(book)" title="wikilink">The C Programming Language</a></em>; the index entry recursively references itself ("recursion 86, 139, 141, 182, 202, 269"). The earliest version of this joke was in "Software Tools" by Kernighan and Plauger, and also appears in "The UNIX Programming Environment" by Kernighan and Pike. It did not appear in the first edition of <em>The C Programming Language</em>.</p>

<p>Another joke is that "To understand recursion, you must understand recursion."<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> In the English-language version of the <a class="uri" href="Google" title="wikilink">Google</a> web search engine, when a search for "recursion" is made, the site suggests "Did you mean: <em>recursion</em>." An alternative form is the following, from <a href="Andrew_Plotkin" title="wikilink">Andrew Plotkin</a>: <em>"If you already know what recursion is, just remember the answer. Otherwise, find someone who is standing closer to <a href="Douglas_Hofstadter" title="wikilink">Douglas Hofstadter</a> than you are; then ask him or her what recursion is."</em></p>

<p><a href="Recursive_acronym" title="wikilink">Recursive acronyms</a> can also be examples of recursive humor. <a class="uri" href="PHP" title="wikilink">PHP</a>, for example, stands for "PHP Hypertext Preprocessor", <a href="Wine_(software)" title="wikilink">WINE</a> stands for "Wine Is Not an Emulator." and <a href="GNU_Project" title="wikilink">GNU</a> stands for "GNU's not Unix".</p>
<h2 id="in-mathematics">In mathematics</h2>
<figure><b>(Figure)</b>
<figcaption>The <a href="Sierpinski_triangle" title="wikilink">Sierpinski triangle</a>â€”a confined recursion of triangles that form a <a class="uri" href="fractal" title="wikilink">fractal</a></figcaption>
</figure>
<h3 id="recursively-defined-sets">Recursively defined sets</h3>
<h4 id="example-the-natural-numbers">Example: the natural numbers</h4>

<p>The canonical example of a recursively defined set is given by the <a href="natural_numbers" title="wikilink">natural numbers</a>:</p>
<dl>
<dd>0 is in 

<math display="inline" id="Recursion:3">
 <semantics>
  <mi>â„•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>â„•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{N}
  </annotation>
 </semantics>
</math>


</dd>
<dd>if <em>n</em> is in 

<math display="inline" id="Recursion:4">
 <semantics>
  <mi>â„•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>â„•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{N}
  </annotation>
 </semantics>
</math>

, then <em>n</em> + 1 is in 

<math display="inline" id="Recursion:5">
 <semantics>
  <mi>â„•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>â„•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{N}
  </annotation>
 </semantics>
</math>



</dd>
<dd>The set of natural numbers is the smallest set satisfying the previous two properties.
</dd>
</dl>
<h4 id="example-the-set-of-true-reachable-propositions">Example: The set of true reachable propositions</h4>

<p>Another interesting example is the set of all "true reachable" propositions in an <a href="axiomatic_system" title="wikilink">axiomatic system</a>.</p>
<ul>
<li>If a proposition is an axiom, it is a true reachable proposition.</li>
<li>If a proposition can be obtained from true reachable propositions by means of inference rules, it is a true reachable proposition.</li>
<li>The set of true reachable propositions is the smallest set of propositions satisfying these conditions.</li>
</ul>

<p>This set is called 'true reachable propositions' because in non-constructive approaches to the foundations of mathematics, the set of true propositions may be larger than the set recursively constructed from the axioms and rules of inference. See also <a href="GÃ¶del's_incompleteness_theorems" title="wikilink">GÃ¶del's incompleteness theorems</a>.</p>
<h3 id="finite-subdivision-rules">Finite subdivision rules</h3>

<p>Finite subdivision rules are a geometric form of recursion, which can be used to create <a class="uri" href="fractal" title="wikilink">fractal</a>-like images. A subdivision rule starts with a collection of polygons labelled by finitely many labels, and then each polygon is subdivided into smaller labelled polygons in a way that depends only on the labels of the original polygon. This process can be iterated. The standard `middle thirds' technique for creating the <a href="Cantor_set" title="wikilink">Cantor set</a> is a subdivision rule, as is <a href="barycentric_subdivision" title="wikilink">barycentric subdivision</a>.</p>
<h3 id="functional-recursion">Functional recursion</h3>

<p>A <a href="function_(mathematics)" title="wikilink">function</a> may be partly defined in terms of itself. A familiar example is the <a href="Fibonacci_number" title="wikilink">Fibonacci number</a> sequence: <em>F</em>(<em>n</em>) = <em>F</em>(<em>n</em> âˆ’ 1) + <em>F</em>(<em>n</em> âˆ’ 2). For such a definition to be useful, it must lead to non-recursively defined values, in this case <em>F</em>(0) = 0 and <em>F</em>(1) = 1.</p>

<p>A famous recursive function is the <a href="Ackermann_function" title="wikilink">Ackermann function</a>, whichâ€”unlike the Fibonacci sequenceâ€”cannot easily be expressed without recursion.</p>
<h3 id="proofs-involving-recursive-definitions">Proofs involving recursive definitions</h3>

<p>Applying the standard technique of <a href="proof_by_cases" title="wikilink">proof by cases</a> to recursively defined sets or functions, as in the preceding sections, yields <a href="structural_induction" title="wikilink">structural induction</a>, a powerful generalization of <a href="mathematical_induction" title="wikilink">mathematical induction</a> widely used to derive proofs in <a href="mathematical_logic" title="wikilink">mathematical logic</a> and <a href="computer_science" title="wikilink">computer science</a>.</p>
<h3 id="recursive-optimization">Recursive optimization</h3>

<p><a href="Dynamic_programming" title="wikilink">Dynamic programming</a> is an approach to <a href="optimization_(mathematics)" title="wikilink">optimization</a> that restates a multiperiod or multistep optimization problem in recursive form. The key result in dynamic programming is the <a href="Bellman_equation" title="wikilink">Bellman equation</a>, which writes the value of the optimization problem at an earlier time (or earlier step) in terms of its value at a later time (or later step).</p>
<h2 id="in-computer-science">In computer science</h2>

<p>A common method of simplification is to divide a problem into subproblems of the same type. As a <a href="computer_programming" title="wikilink">computer programming</a> technique, this is called <a href="divide_and_conquer_algorithm" title="wikilink">divide and conquer</a> and is key to the design of many important algorithms. Divide and conquer serves as a top-down approach to problem solving, where problems are solved by solving smaller and smaller instances. A contrary approach is <a href="dynamic_programming" title="wikilink">dynamic programming</a>. This approach serves as a bottom-up approach, where problems are solved by solving larger and larger instances, until the desired size is reached.</p>

<p>A classic example of recursion is the definition of the <a class="uri" href="factorial" title="wikilink">factorial</a> function, given here in C code:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">unsigned</span> <span class="dt">int</span> factorial(<span class="dt">unsigned</span> <span class="dt">int</span> n) {
    <span class="kw">if</span> (n == <span class="dv">0</span>) {
        <span class="kw">return</span> <span class="dv">1</span>;
    } <span class="kw">else</span> {
        <span class="kw">return</span> n * factorial(n - <span class="dv">1</span>);
    }
}</code></pre></div>

<p>The function calls itself recursively on a smaller version of the input (n - 1) and multiplies the result of the recursive call by n, until reaching the <a href="base_case" title="wikilink">base case</a>, analogously to the mathematical definition of factorial.</p>

<p>Recursion in computer programming is exemplified when a function is defined in terms of simpler, often smaller versions of itself. The solution to the problem is then devised by combining the solutions obtained from the simpler versions of the problem. One example application of recursion is in <a href="parser" title="wikilink">parsers</a> for programming languages. The great advantage of recursion is that an infinite set of possible sentences, designs or other data can be defined, parsed or produced by a finite computer program.</p>

<p><a href="Recurrence_relation" title="wikilink">Recurrence relations</a> are equations to define one or more sequences recursively. Some specific kinds of recurrence relation can be "solved" to obtain a non-recursive definition.</p>

<p>Use of recursion in an algorithm has both advantages and disadvantages. The main advantage is usually simplicity. The main disadvantage is often that the algorithm may require large amounts of memory if the depth of the recursion is very large.</p>
<h2 id="in-art">In art</h2>

<p>The Russian Doll or <a href="Matryoshka_doll" title="wikilink">Matryoshka Doll</a> is a physical artistic example of the recursive concept.</p>
<h2 id="the-recursion-theorem">The recursion theorem</h2>

<p>In <a href="set_theory" title="wikilink">set theory</a>, this is a theorem guaranteeing that recursively defined functions exist. Given a set <em>X</em>, an element <em>a</em> of <em>X</em> and a function 

<math display="inline" id="Recursion:6">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>â†’</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-â†’</ci>
     <ci>X</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:X\rightarrow X
  </annotation>
 </semantics>
</math>

, the theorem states that there is a unique function 

<math display="inline" id="Recursion:7">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>:</mo>
   <mrow>
    <mi>â„•</mi>
    <mo>â†’</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>F</ci>
    <apply>
     <ci>normal-â†’</ci>
     <ci>â„•</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F:\mathbb{N}\rightarrow X
  </annotation>
 </semantics>
</math>

 (where 

<math display="inline" id="Recursion:8">
 <semantics>
  <mi>â„•</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>â„•</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{N}
  </annotation>
 </semantics>
</math>

 denotes the set of natural numbers including zero) such that</p>

<p>

<math display="block" id="Recursion:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(0)=a
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Recursion:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>F</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(n+1)=f(F(n))
  </annotation>
 </semantics>
</math>

 for any natural number <em>n</em>.</p>
<h3 id="proof-of-uniqueness">Proof of uniqueness</h3>

<p>Take two functions 

<math display="inline" id="Recursion:11">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>:</mo>
   <mrow>
    <mi>â„•</mi>
    <mo>â†’</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>F</ci>
    <apply>
     <ci>normal-â†’</ci>
     <ci>â„•</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F:\mathbb{N}\rightarrow X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Recursion:12">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>:</mo>
   <mrow>
    <mi>â„•</mi>
    <mo>â†’</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>G</ci>
    <apply>
     <ci>normal-â†’</ci>
     <ci>â„•</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G:\mathbb{N}\rightarrow X
  </annotation>
 </semantics>
</math>

 such that:</p>

<p>

<math display="block" id="Recursion:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(0)=a
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Recursion:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(0)=a
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Recursion:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>F</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(n+1)=f(F(n))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Recursion:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>G</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(n+1)=f(G(n))
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>a</em> is an element of <em>X</em>.</p>

<p>It can be proved by <a href="mathematical_induction" title="wikilink">mathematical induction</a> that 

<math display="inline" id="Recursion:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(n)=G(n)
  </annotation>
 </semantics>
</math>

 for all natural numbers <em>n</em>:</p>
<dl>
<dd><strong>Base Case</strong>

<math display="block" id="Recursion:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
   <mo>=</mo>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>F</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>a</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>G</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(0)=a=G(0)
  </annotation>
 </semantics>
</math>

 so the equality holds for 

<math display="inline" id="Recursion:19">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=0
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
<dl>
<dd><strong>Inductive Step</strong>: Suppose 

<math display="inline" id="Recursion:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(k)=G(k)
  </annotation>
 </semantics>
</math>


 for some 

<math display="inline" id="Recursion:21">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>âˆˆ</mo>
   <mi>â„•</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>k</ci>
    <ci>â„•</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\in\mathbb{N}
  </annotation>
 </semantics>
</math>

. Then 

<math display="inline" id="Recursion:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>F</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>k</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>G</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>k</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>F</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>G</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>G</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(k+1)=f(F(k))=f(G(k))=G(k+1).
  </annotation>
 </semantics>
</math>


<dl>
<dd>Hence F(k) = G(k) implies F(k+1) = G(k+1).
</dd>
</dl>
</dd>
</dl>

<p>By induction, 

<math display="inline" id="Recursion:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(n)=G(n)
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Recursion:24">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>âˆˆ</mo>
   <mi>â„•</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>n</ci>
    <ci>â„•</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\in\mathbb{N}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="examples">Examples</h3>

<p>Some common recurrence relations are:</p>
<ul>
<li><a href="Golden_Ratio" title="wikilink">Golden Ratio</a>

<math display="block" id="Recursion:25">
 <semantics>
  <mrow>
   <mi>Ï•</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mi>Ï•</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>/</mo>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mn>1</mn>
            <mo>+</mo>
            <mrow>
             <mn>1</mn>
             <mo>/</mo>
             <mi mathvariant="normal">â€¦</mi>
            </mrow>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>Ï•</ci>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>Ï•</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <apply>
          <plus></plus>
          <cn type="integer">1</cn>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <ci>normal-â€¦</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi=1+(1/\phi)=1+(1/(1+(1/(1+1/...))))
  </annotation>
 </semantics>
</math>

</li>
<li><a class="uri" href="Factorial" title="wikilink">Factorial</a>

<math display="block" id="Recursion:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mo lspace="0pt" rspace="3.5pt">!</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>n</mi>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">â‹¯</mi>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <factorial></factorial>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <factorial></factorial>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-â‹¯</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n!=n(n-1)!=n(n-1)\cdots 1
  </annotation>
 </semantics>
</math>

</li>
<li><a href="Fibonacci_numbers" title="wikilink">Fibonacci numbers</a>

<math display="block" id="Recursion:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)=f(n-1)+f(n-2)
  </annotation>
 </semantics>
</math>

</li>
<li><a href="Catalan_number" title="wikilink">Catalan numbers</a>

<math display="block" id="Recursion:28">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{0}=1
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Recursion:29">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mn>4</mn>
        <mi>n</mi>
       </mrow>
       <mo>+</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>C</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <cn type="integer">4</cn>
        <ci>n</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n+1}=(4n+2)C_{n}/(n+2)
  </annotation>
 </semantics>
</math>

</li>
<li>Computing compound <a class="uri" href="interest" title="wikilink">interest</a></li>
<li>The <a href="Tower_of_Hanoi" title="wikilink">Tower of Hanoi</a></li>
<li><a href="Ackermann_function" title="wikilink">Ackermann function</a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Corecursion" title="wikilink">Corecursion</a></li>
<li><a href="Course-of-values_recursion" title="wikilink">Course-of-values recursion</a></li>
<li><a href="Digital_infinity" title="wikilink">Digital infinity</a></li>
<li><a href="Fixed_point_combinator" title="wikilink">Fixed point combinator</a></li>
<li><a href="Infinite_loop" title="wikilink">Infinite loop</a></li>
<li><a class="uri" href="Infinitism" title="wikilink">Infinitism</a></li>
<li><a href="Iterated_function" title="wikilink">Iterated function</a></li>
<li><a href="Mise_en_abyme" title="wikilink">Mise en abyme</a></li>
<li></li>
<li><a href="Reentrant_(subroutine)" title="wikilink">Reentrant (subroutine)</a></li>
<li><a class="uri" href="Self-reference" title="wikilink">Self-reference</a></li>
<li><a href="Strange_loop" title="wikilink">Strange loop</a></li>
<li><a href="Tail_recursion" title="wikilink">Tail recursion</a></li>
<li><a href="Tupper's_self-referential_formula" title="wikilink">Tupper's self-referential formula</a></li>
<li><a href="Turtles_all_the_way_down" title="wikilink">Turtles all the way down</a></li>
</ul>
<h2 id="bibliography">Bibliography</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>- offers a treatment of <a class="uri" href="corecursion" title="wikilink">corecursion</a>.</p></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>, first chapter on set theory.</p></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.freenetpages.co.uk/hp/alan.gauld/tutrecur.htm">Recursion</a> - tutorial by Alan Gauld</li>
<li><a href="http://amitksaha.files.wordpress.com/2009/05/recursion-primer.pdf">A Primer on Recursion</a>- contains pointers to recursion in Formal Languages, Linguistics, Math and Computer Science</li>
<li><a href="http://research.swtch.com/2010/03/zip-files-all-way-down.html">Zip Files All The Way Down</a></li>
<li><a href="http://www.ucl.ac.uk/psychlangsci/staff/linguistics-staff/nevins-publications/npr09b">Nevins, Andrew and David Pesetsky and Cilene Rodrigues. Evidence and Argumentation: A Reply to Everett (2009). Language 85.3: 671--681 (2009)</a></li>
</ul>

<p>"</p>

<p><a href="Category:Mathematical_logic" title="wikilink">Category:Mathematical logic</a> <a href="Category:Theory_of_computation" title="wikilink">Category:Theory of computation</a> <a href="Category:Programming_idioms" title="wikilink">Category:Programming idioms</a> <a href="Category:Recursion" title="wikilink"> </a> <a class="uri" href="Category:Self-reference" title="wikilink">Category:Self-reference</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">â†©</a></li>
<li id="fn2"><a href="#fnref2">â†©</a></li>
<li id="fn3"><a href="#fnref3">â†©</a></li>
<li id="fn4"><a href="#fnref4">â†©</a></li>
<li id="fn5">Barbara Partee and Mats Rooth. 1983. In Rainer BÃ¤uerle et al., <em>Meaning, Use, and Interpretation of Language</em>. Reprinted in Paul Portner and Barbara Partee, eds. 2002. <em>Formal Semantics: The Essential Readings</em>. Blackwell.<a href="#fnref5">â†©</a></li>
<li id="fn6"><a href="#fnref6">â†©</a></li>
<li id="fn7"></li>
</ol>
</section>
</body>

