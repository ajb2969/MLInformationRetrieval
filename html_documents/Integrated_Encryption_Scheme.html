<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="470">Integrated Encryption Scheme</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Integrated Encryption Scheme</h1>
<hr/>

<p><strong>Integrated Encryption Scheme</strong> (<strong>IES</strong>) is a <a href="hybrid_encryption" title="wikilink">hybrid encryption</a> scheme which provides <a href="semantic_security" title="wikilink">semantic security</a> against an <a href="Adversary_(cryptography)" title="wikilink">adversary</a> who is allowed to use chosen-plaintext and chosen-ciphertext attacks. The security of the scheme is based on the <a href="Diffie–Hellman_problem" title="wikilink">Diffie–Hellman problem</a>. Two incarnations of the IES are standardized: <a href="Discrete_logarithm" title="wikilink">Discrete Logarithm</a> Integrated Encryption Scheme (DLIES) and <a href="Elliptic_curve" title="wikilink">Elliptic Curve</a> Integrated Encryption Scheme (ECIES), which is also known as the Elliptic Curve Augmented Encryption Scheme or simply the Elliptic Curve Encryption Scheme. These two incarnations are identical up to the change of an underlying group and so to be concrete we concentrate on the latter.</p>
<h2 id="information-required">Information required</h2>

<p>To send an encrypted message to <a href="Alice_and_Bob" title="wikilink">Bob</a> using ECIES, Alice needs the following information:</p>
<ul>
<li>cryptographic suite to be used, including a <a href="key_derivation_function" title="wikilink">key derivation function</a> (e.g., <em>ANSI-X9.63-KDF with SHA-1 option</em>), a <a href="message_authentication_code" title="wikilink">message authentication code</a> (e.g., <em>HMAC-SHA-1-160 with 160-bit keys</em> or <em>HMAC-SHA-1-80 with 80-bit keys</em>) and a <a href="symmetric-key_algorithm" title="wikilink">symmetric encryption scheme</a> (e.g., <em><a class="uri" href="TDEA" title="wikilink">TDEA</a> in <a href="cipher_block_chaining" title="wikilink">CBC</a> mode</em> or <em>XOR encryption scheme</em>)—noted 

<math display="inline" id="Integrated_Encryption_Scheme:0">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

;</li>
<li>elliptic curve domain parameters

<math display="block" id="Integrated_Encryption_Scheme:1">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo>,</mo>
   <mi>G</mi>
   <mo>,</mo>
   <mi>n</mi>
   <mo>,</mo>
   <mi>h</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>p</ci>
    <ci>a</ci>
    <ci>b</ci>
    <ci>G</ci>
    <ci>n</ci>
    <ci>h</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,a,b,G,n,h)
  </annotation>
 </semantics>
</math>

 for a curve over a prime field or 

<math display="inline" id="Integrated_Encryption_Scheme:2">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>m</mi>
   <mo>,</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo>,</mo>
   <mi>G</mi>
   <mo>,</mo>
   <mi>n</mi>
   <mo>,</mo>
   <mi>h</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>m</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <ci>a</ci>
    <ci>b</ci>
    <ci>G</ci>
    <ci>n</ci>
    <ci>h</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (m,f(x),a,b,G,n,h)
  </annotation>
 </semantics>
</math>

 for a curve over a binary field;</li>
<li>Bob's public key

<math display="block" id="Integrated_Encryption_Scheme:3">
 <semantics>
  <msub>
   <mi>K</mi>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{B}
  </annotation>
 </semantics>
</math>

 (Bob generates it as follows

<math display="block" id="Integrated_Encryption_Scheme:4">
 <semantics>
  <mrow>
   <msub>
    <mi>K</mi>
    <mi>B</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>k</mi>
     <mi>B</mi>
    </msub>
    <mi>G</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <ci>B</ci>
     </apply>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{B}=k_{B}G
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Integrated_Encryption_Scheme:5">
 <semantics>
  <msub>
   <mi>k</mi>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{B}
  </annotation>
 </semantics>
</math>

 is the private key he chooses at random

<math display="block" id="Integrated_Encryption_Scheme:6">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mi>B</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <ci>B</ci>
    </apply>
    <interval closure="closed">
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{B}\in[1,n-1]
  </annotation>
 </semantics>
</math>

);</li>
<li>optional shared information

<math display="block" id="Integrated_Encryption_Scheme:7">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Integrated_Encryption_Scheme:8">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{2}
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<h2 id="encryption">Encryption</h2>

<p>To encrypt a message 

<math display="inline" id="Integrated_Encryption_Scheme:9">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 Alice does the following:</p>
<ol>
<li>generates a random number 

<math display="inline" id="Integrated_Encryption_Scheme:10">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>r</ci>
    <interval closure="closed">
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\in[1,n-1]
  </annotation>
 </semantics>
</math>

 and calculates 

<math display="inline" id="Integrated_Encryption_Scheme:11">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mrow>
    <mi>r</mi>
    <mi>G</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=rG
  </annotation>
 </semantics>
</math>

;</li>
<li>derives a shared secret

<math display="block" id="Integrated_Encryption_Scheme:12">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <msub>
    <mi>P</mi>
    <mi>x</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=P_{x}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Integrated_Encryption_Scheme:13">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>P</mi>
     <mi>x</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>P</mi>
     <mi>y</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>r</mi>
    <msub>
     <mi>K</mi>
     <mi>B</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>P</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>y</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>r</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=(P_{x},P_{y})=rK_{B}
  </annotation>
 </semantics>
</math>

 (and 

<math display="inline" id="Integrated_Encryption_Scheme:14">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>≠</mo>
   <mi>O</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>P</ci>
    <ci>O</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\neq O
  </annotation>
 </semantics>
</math>

);</li>
<li>uses KDF to derive a symmetric encryption and a MAC keys

<math display="block" id="Integrated_Encryption_Scheme:15">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mi>E</mi>
   </msub>
   <mo>∥</mo>
   <msub>
    <mi>k</mi>
    <mi>M</mi>
   </msub>
   <mo>=</mo>
   <mtext>KDF</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>∥</mo>
    <msub>
     <mi>S</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <ci>E</ci>
    </apply>
    <csymbol cd="latexml">parallel-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <ci>M</ci>
    </apply>
    <eq></eq>
    <mtext>KDF</mtext>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <csymbol cd="latexml">parallel-to</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{E}\|k_{M}=\textrm{KDF}(S\|S_{1})
  </annotation>
 </semantics>
</math>

;</li>
<li>encrypts the message

<math display="block" id="Integrated_Encryption_Scheme:16">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>k</mi>
      <mi>E</mi>
     </msub>
     <mo>;</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <apply>
     <times></times>
     <ci>E</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <ci>E</ci>
      </apply>
      <ci>m</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=E(k_{E};m)
  </annotation>
 </semantics>
</math>

;</li>
<li>computes the tag of encrypted message and 

<math display="inline" id="Integrated_Encryption_Scheme:17">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{2}
  </annotation>
 </semantics>
</math>



<math display="block" id="Integrated_Encryption_Scheme:18">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mtext>MAC</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>k</mi>
     <mi>M</mi>
    </msub>
    <mo>;</mo>
    <mi>c</mi>
    <mo>∥</mo>
    <msub>
     <mi>S</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <eq></eq>
    <mtext>MAC</mtext>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <ci>M</ci>
     </apply>
     <ci>normal-;</ci>
     <csymbol cd="unknown">c</csymbol>
     <csymbol cd="latexml">parallel-to</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=\textrm{MAC}(k_{M};c\|S_{2})
  </annotation>
 </semantics>
</math>

;</li>
<li>outputs 

<math display="inline" id="Integrated_Encryption_Scheme:19">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo>∥</mo>
    <mi>c</mi>
    <mo>∥</mo>
   </mrow>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <ci>c</ci>
    </apply>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\|c\|d
  </annotation>
 </semantics>
</math>

.</li>
</ol>
<h2 id="decryption">Decryption</h2>

<p>To decrypt the ciphertext 

<math display="inline" id="Integrated_Encryption_Scheme:20">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo>∥</mo>
    <mi>c</mi>
    <mo>∥</mo>
   </mrow>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <ci>c</ci>
    </apply>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\|c\|d
  </annotation>
 </semantics>
</math>

 Bob does the following:</p>
<ol>
<li>derives the shared secret

<math display="block" id="Integrated_Encryption_Scheme:21">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <msub>
    <mi>P</mi>
    <mi>x</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=P_{x}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Integrated_Encryption_Scheme:22">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>P</mi>
     <mi>x</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>P</mi>
     <mi>y</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>k</mi>
     <mi>B</mi>
    </msub>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>P</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>y</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <ci>B</ci>
      </apply>
      <ci>R</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=(P_{x},P_{y})=k_{B}R
  </annotation>
 </semantics>
</math>

 (it is the same as the one Alice derived because 

<math display="inline" id="Integrated_Encryption_Scheme:23">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>k</mi>
     <mi>B</mi>
    </msub>
    <mi>R</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>k</mi>
     <mi>B</mi>
    </msub>
    <mi>r</mi>
    <mi>G</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>r</mi>
    <msub>
     <mi>k</mi>
     <mi>B</mi>
    </msub>
    <mi>G</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>r</mi>
    <msub>
     <mi>K</mi>
     <mi>B</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>P</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <ci>B</ci>
      </apply>
      <ci>R</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <ci>B</ci>
      </apply>
      <ci>r</ci>
      <ci>G</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>r</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <ci>B</ci>
      </apply>
      <ci>G</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>r</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=k_{B}R=k_{B}rG=rk_{B}G=rK_{B}
  </annotation>
 </semantics>
</math>

), or outputs <em>failed</em> if 

<math display="inline" id="Integrated_Encryption_Scheme:24">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mi>O</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <ci>O</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=O
  </annotation>
 </semantics>
</math>

;</li>
<li>derives keys the same way as Alice did

<math display="block" id="Integrated_Encryption_Scheme:25">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mi>E</mi>
   </msub>
   <mo>∥</mo>
   <msub>
    <mi>k</mi>
    <mi>M</mi>
   </msub>
   <mo>=</mo>
   <mtext>KDF</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>∥</mo>
    <msub>
     <mi>S</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <ci>E</ci>
    </apply>
    <csymbol cd="latexml">parallel-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <ci>M</ci>
    </apply>
    <eq></eq>
    <mtext>KDF</mtext>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <csymbol cd="latexml">parallel-to</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{E}\|k_{M}=\textrm{KDF}(S\|S_{1})
  </annotation>
 </semantics>
</math>

;</li>
<li>uses MAC to check the tag and outputs <em>failed</em> if 

<math display="inline" id="Integrated_Encryption_Scheme:26">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>≠</mo>
   <mtext>MAC</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>k</mi>
     <mi>M</mi>
    </msub>
    <mo>;</mo>
    <mi>c</mi>
    <mo>∥</mo>
    <msub>
     <mi>S</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <neq></neq>
    <mtext>MAC</mtext>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <ci>M</ci>
     </apply>
     <ci>normal-;</ci>
     <csymbol cd="unknown">c</csymbol>
     <csymbol cd="latexml">parallel-to</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\neq\textrm{MAC}(k_{M};c\|S_{2})
  </annotation>
 </semantics>
</math>

;</li>
<li>uses symmetric encryption scheme to decrypt the message 

<math display="inline" id="Integrated_Encryption_Scheme:27">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>E</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>k</mi>
      <mi>E</mi>
     </msub>
     <mo>;</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>E</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <ci>E</ci>
      </apply>
      <ci>c</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=E^{-1}(k_{E};c)
  </annotation>
 </semantics>
</math>

.</li>
</ol>
<h2 id="references">References</h2>
<ul>
<li>Victor Shoup, <a href="http://www.shoup.net/papers/iso-2_1.pdf">A proposal for an ISO standard for public key encryption</a>, Version 2.1, December 20, 2001.</li>
<li>Certicom Research, <a href="http://www.secg.org/download/aid-780/sec1-v2.pdf">Standards for efficient cryptography, SEC 1: Elliptic Curve Cryptography</a>, Version 2.0, May 21, 2009.</li>
<li>Gayoso Martínez, Hernández Encinas, Sánchez Ávila: <a href="http://www.researchgate.net/publication/255970113_A_Survey_of_the_Elliptic_Curve_Integrated_Encryption_Scheme/links/02e7e5212654222f0a000000"><em>A Survey of the Elliptic Curve Integrated Encryption Scheme</em></a>, Journal of Computer Science and Engineering, 2, 2 (2010), 7-13.</li>
</ul>

<p>"</p>

<p><a href="Category:Cryptographic_protocols" title="wikilink">Category:Cryptographic protocols</a></p>
</body>
</html>
