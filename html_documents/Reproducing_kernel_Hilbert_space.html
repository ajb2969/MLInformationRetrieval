<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="99">Reproducing kernel Hilbert space</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Reproducing kernel Hilbert space</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Figure illustrates related but varying approaches to viewing RKHS</figcaption>
</figure>

<p>In <a href="functional_analysis" title="wikilink">functional analysis</a> (a branch of <a class="uri" href="mathematics" title="wikilink">mathematics</a>), a '''reproducing kernel Hilbert space '''(RKHS) is a <a href="Hilbert_space" title="wikilink">Hilbert space</a> associated with a kernel that reproduces every function in the space or, equivalently, where every evaluation functional is bounded. The reproducing kernel was first introduced in the 1907 work of <a href="Stanisław_Zaremba_(mathematician)" title="wikilink"> Stanisław Zaremba</a> concerning boundary value problems for harmonic and biharmonic functions. <a href="James_Mercer_(mathematician)" title="wikilink">James Mercer</a> simultaneously examined functions which satisfy the reproducing property in the theory of integral equations. The idea of the reproducing kernel remained untouched for nearly twenty years until it appeared in the dissertations of <a href="Gábor_Szegő" title="wikilink">Gábor Szegő</a>, <a href="Stefan_Bergman" title="wikilink">Stefan Bergman</a>, and <a href="Salomon_Bochner" title="wikilink">Salomon Bochner</a>. The subject was eventually systematically developed in the early 1950s by <a href="Nachman_Aronszajn" title="wikilink">Nachman Aronszajn</a> and Stefan Bergman. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>These spaces have wide applications, including <a href="complex_analysis" title="wikilink">complex analysis</a>, <a href="harmonic_analysis" title="wikilink">harmonic analysis</a>, and <a href="quantum_mechanics" title="wikilink">quantum mechanics</a>. Reproducing kernel Hilbert spaces are particularly important in the field of <a href="statistical_learning_theory" title="wikilink">statistical learning theory</a> because of the celebrated <a href="Representer_theorem" title="wikilink">Representer theorem</a> which states that every function in an RKHS can be written as a linear combination of the kernel function evaluated at the training points. This is a practically useful result as it effectively simplifies the <a href="empirical_risk_minimization" title="wikilink">empirical risk minimization</a> problem from an infinite dimensional to a finite dimensional optimization problem.</p>

<p>For ease of understanding, we provide the framework for real-valued Hilbert spaces. The theory can be easily extended to spaces of complex-valued functions and hence include the many important examples of reproducing kernel Hilbert spaces that are spaces of <a href="analytic_functions" title="wikilink">analytic functions</a>. <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="definition">Definition</h2>

<p>Let <em>X</em> be an arbitrary <a href="Set_(mathematics)" title="wikilink">set</a> and <em>H</em> a <a href="Hilbert_space" title="wikilink">Hilbert space</a> of <a href="real-valued_function" title="wikilink">real-valued functions</a> on <em>X</em>. The evaluation functional over the Hilbert space of functions <em>H</em> is a linear functional that evaluates each function at a point <em>x</em>,</p>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>L</mi>
     <mi>x</mi>
    </msub>
    <mo>:</mo>
    <mrow>
     <mi>f</mi>
     <mo>↦</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow></mrow>
      <mrow>
       <mo>∀</mo>
       <mi>f</mi>
      </mrow>
     </mrow>
     <mo>∈</mo>
     <mi>H</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
       <mtext></mtext>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <ci>f</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <ci>H</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{x}:f\mapsto f(x)\text{ }\forall f\in H.
  </annotation>
 </semantics>
</math>

</p>

<p>We say that <em>H</em> is a <strong>reproducing kernel Hilbert space</strong> if 

<math display="inline" id="Reproducing_kernel_Hilbert_space:1">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{x}
  </annotation>
 </semantics>
</math>

 is a <a href="continuous_function_(topology)" title="wikilink">continuous</a> function for any 

<math display="inline" id="Reproducing_kernel_Hilbert_space:2">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Reproducing_kernel_Hilbert_space:3">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 or, equivalently, if 

<math display="inline" id="Reproducing_kernel_Hilbert_space:4">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{x}
  </annotation>
 </semantics>
</math>

 is a <a href="bounded_operator" title="wikilink">bounded operator</a> so that for any 

<math display="inline" id="Reproducing_kernel_Hilbert_space:5">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Reproducing_kernel_Hilbert_space:6">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 there exists some <em>M &gt; 0</em> such that</p>

<p>While property () is the weakest condition that ensures both the existence of an inner product and the evaluation of every function in <em>H</em> at every point in the domain, it does not lend itself to easy application in practice. A more intuitive definition of the RKHS can be obtained by observing that this property guarantees that the evaluation functional can be represented by taking the inner product of 

<math display="inline" id="Reproducing_kernel_Hilbert_space:7">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 with a function 

<math display="inline" id="Reproducing_kernel_Hilbert_space:8">
 <semantics>
  <msub>
   <mi>K</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{x}
  </annotation>
 </semantics>
</math>

 in <em>H</em> . This function is the so-called <strong>reproducing kernel</strong> for the Hilbert space <em>H</em> from which the RKHS takes its name. More formally, the <a href="Riesz_representation_theorem" title="wikilink">Riesz representation theorem</a> implies that for all <em>x</em> in <em>X</em> there exists a unique element 

<math display="inline" id="Reproducing_kernel_Hilbert_space:9">
 <semantics>
  <msub>
   <mi>K</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{x}
  </annotation>
 </semantics>
</math>

 of <em>H</em> with the reproducing property,</p>

<p>Since 

<math display="inline" id="Reproducing_kernel_Hilbert_space:10">
 <semantics>
  <msub>
   <mi>K</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{x}
  </annotation>
 </semantics>
</math>

 is itself a function in <em>H</em> we have that for each <em>x</em> in <em>X</em></p>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>K</mi>
      <mi>x</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msub>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msub>
       <mi>K</mi>
       <mi>y</mi>
      </msub>
      <mo rspace="7.5pt">,</mo>
      <msub>
       <mi>K</mi>
       <mi>x</mi>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>H</mi>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <ci>x</ci>
     </apply>
     <ci>y</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>x</ci>
      </apply>
     </list>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{x}(y)=\langle K_{y},\ K_{x}\rangle_{H}.
  </annotation>
 </semantics>
</math>

</p>

<p>This allows us to define the reproducing kernel of <em>H</em> as a function 

<math display="inline" id="Reproducing_kernel_Hilbert_space:12">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mo>×</mo>
     <mi>X</mi>
    </mrow>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>K</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>X</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K:X\times X\to\mathbb{R}
  </annotation>
 </semantics>
</math>

 by</p>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>K</mi>
      <mi>x</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <ci>x</ci>
     </apply>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x,y)=K_{x}(y).
  </annotation>
 </semantics>
</math>

</p>

<p>From this definition it is easy to see that a function 

<math display="inline" id="Reproducing_kernel_Hilbert_space:14">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mo>×</mo>
     <mi>X</mi>
    </mrow>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>K</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>X</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K:X\times X\to\mathbb{R}
  </annotation>
 </semantics>
</math>

 is a reproducing kernel if it is both symmetric and <a href="positive_definite" title="wikilink">positive definite</a>, i.e.</p>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:15">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mi>j</mi>
      </mrow>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>c</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>c</mi>
      <mi>j</mi>
     </msub>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>j</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <list>
         <ci>i</ci>
         <ci>j</ci>
        </list>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>j</ci>
      </apply>
      <ci>K</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>j</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i,j=1}^{n}c_{i}c_{j}K(x_{i},x_{j})\geq 0
  </annotation>
 </semantics>
</math>

</p>

<p>for any 

<math display="inline" id="Reproducing_kernel_Hilbert_space:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>n</mi>
     <mo>∈</mo>
     <mrow>
      <mi>ℕ</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo>∈</mo>
      <mrow>
       <mi>X</mi>
       <mo>,</mo>
       <mrow>
        <mtext>and</mtext>
        <msub>
         <mi>c</mi>
         <mn>1</mn>
        </msub>
       </mrow>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>c</mi>
       <mi>n</mi>
      </msub>
      <mo>∈</mo>
      <mi>ℝ</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <ci>n</ci>
     <list>
      <ci>ℕ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
     </list>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <list>
       <ci>X</ci>
       <apply>
        <times></times>
        <mtext>and</mtext>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>c</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-…</ci>
      </list>
     </apply>
     <apply>
      <in></in>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>n</ci>
      </apply>
      <ci>ℝ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\in\mathbb{N},x_{1},\dots,x_{n}\in X,\text{ and }c_{1},\dots,c_{n}\in\mathbb{%
R}.
  </annotation>
 </semantics>
</math>

 <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="example">Example</h2>

<p>The space of <a href="Bandlimiting" title="wikilink">bandlimited functions</a> 

<math display="inline" id="Reproducing_kernel_Hilbert_space:17">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 is a RKHS. Let</p>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:18">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>f</mi>
     <mo>∈</mo>
     <mrow>
      <msub>
       <mi>L</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ℝ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo>supp</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>F</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⊂</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mo>-</mo>
        <mi>a</mi>
       </mrow>
       <mo>,</mo>
       <mi>a</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>a</mi>
      <mo><</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>f</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>ℝ</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <subset></subset>
       <apply>
        <ci>supp</ci>
        <ci>F</ci>
       </apply>
       <interval closure="closed">
        <apply>
         <minus></minus>
         <ci>a</ci>
        </apply>
        <ci>a</ci>
       </interval>
      </apply>
      <apply>
       <lt></lt>
       <ci>a</ci>
       <infinity></infinity>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=\{f\in L_{2}(\mathbb{R})|\operatorname{supp}(F)\subset[-a,a],a<\infty\}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Reproducing_kernel_Hilbert_space:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>i</mi>
        <mi>ω</mi>
        <mi>x</mi>
       </mrow>
      </mrow>
     </msup>
     <mi>d</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>ω</ci>
    </apply>
    <apply>
     <int></int>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>ω</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\omega)=\int f(x)e^{-i\omega x}dx
  </annotation>
 </semantics>
</math>

 is the <a href="Fourier_transform" title="wikilink">Fourier transform</a> of 

<math display="inline" id="Reproducing_kernel_Hilbert_space:20">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

. One can show that if 

<math display="inline" id="Reproducing_kernel_Hilbert_space:21">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>∈</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>f</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\in H
  </annotation>
 </semantics>
</math>

 then</p>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
     </mrow>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi>a</mi>
      </mrow>
      <mi>a</mi>
     </msubsup>
     <mrow>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ω</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>e</mi>
       <mrow>
        <mi>i</mi>
        <mi>x</mi>
        <mi>ω</mi>
       </mrow>
      </msup>
      <mi>d</mi>
      <mi>ω</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <ci>a</ci>
        </apply>
       </apply>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>x</ci>
         <ci>ω</ci>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>ω</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=\frac{1}{2\pi}\int_{-a}^{a}\phi(\omega)e^{ix\omega}d\omega
  </annotation>
 </semantics>
</math>

</p>

<p>for some 

<math display="inline" id="Reproducing_kernel_Hilbert_space:23">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>∈</mo>
   <mrow>
    <msub>
     <mi>L</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mo>-</mo>
      <mi>a</mi>
     </mrow>
     <mo>,</mo>
     <mi>a</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ϕ</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <cn type="integer">2</cn>
     </apply>
     <interval closure="closed">
      <apply>
       <minus></minus>
       <ci>a</ci>
      </apply>
      <ci>a</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\in L_{2}[-a,a]
  </annotation>
 </semantics>
</math>

. It then follows by the <a href="Cauchy-Schwarz_inequality" title="wikilink">Cauchy-Schwarz inequality</a> and <a href="Plancherel's_Theorem" title="wikilink">Plancherel's Theorem</a> that</p>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <msqrt>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mrow>
         <mn>2</mn>
         <mi>π</mi>
        </mrow>
       </mfrac>
       <mrow>
        <msubsup>
         <mo largeop="true" symmetric="true">∫</mo>
         <mrow>
          <mo>-</mo>
          <mi>a</mi>
         </mrow>
         <mi>a</mi>
        </msubsup>
        <mrow>
         <mn>1</mn>
         <mi>d</mi>
         <mi>ω</mi>
        </mrow>
       </mrow>
      </mrow>
     </msqrt>
     <msqrt>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mrow>
         <mn>2</mn>
         <mi>π</mi>
        </mrow>
       </mfrac>
       <mrow>
        <msubsup>
         <mo largeop="true" symmetric="true">∫</mo>
         <mrow>
          <mo>-</mo>
          <mi>a</mi>
         </mrow>
         <mi>a</mi>
        </msubsup>
        <mrow>
         <msup>
          <mrow>
           <mo stretchy="false">|</mo>
           <mrow>
            <mi>ϕ</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>ω</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo stretchy="false">|</mo>
          </mrow>
          <mn>2</mn>
         </msup>
         <mi>d</mi>
         <mi>ω</mi>
        </mrow>
       </mrow>
      </mrow>
     </msqrt>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msqrt>
      <mfrac>
       <mi>a</mi>
       <mi>π</mi>
      </mfrac>
     </msqrt>
     <mrow>
      <mo>∥</mo>
      <mi>f</mi>
      <mo>∥</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <root></root>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>π</ci>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <int></int>
           <apply>
            <minus></minus>
            <ci>a</ci>
           </apply>
          </apply>
          <ci>a</ci>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">1</cn>
          <ci>d</ci>
          <ci>ω</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <root></root>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>π</ci>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <int></int>
           <apply>
            <minus></minus>
            <ci>a</ci>
           </apply>
          </apply>
          <ci>a</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <abs></abs>
            <apply>
             <times></times>
             <ci>ϕ</ci>
             <ci>ω</ci>
            </apply>
           </apply>
           <cn type="integer">2</cn>
          </apply>
          <ci>d</ci>
          <ci>ω</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <root></root>
       <apply>
        <divide></divide>
        <ci>a</ci>
        <ci>π</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |f(x)|\leq\sqrt{\frac{1}{2\pi}\int_{-a}^{a}1d\omega}\sqrt{\frac{1}{2\pi}\int_{%
-a}^{a}|\phi(\omega)|^{2}d\omega}=\sqrt{\frac{a}{\pi}}\|f\|.
  </annotation>
 </semantics>
</math>

</p>

<p>As this inequality shows that the evaluation functional is bounded and 

<math display="inline" id="Reproducing_kernel_Hilbert_space:25">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 is also a Hilbert space, 

<math display="inline" id="Reproducing_kernel_Hilbert_space:26">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 is indeed a RKHS.</p>

<p>The kernel function 

<math display="inline" id="Reproducing_kernel_Hilbert_space:27">
 <semantics>
  <msub>
   <mi>K</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{x}
  </annotation>
 </semantics>
</math>

 in this case is given by</p>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:28">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>K</mi>
     <mi>x</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mi>a</mi>
     <mi>π</mi>
    </mfrac>
    <mrow>
     <mo>sinc</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>y</mi>
         <mo>-</mo>
         <mi>x</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>sin</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>y</mi>
         <mo>-</mo>
         <mi>x</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>π</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>y</mi>
       <mo>-</mo>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>x</ci>
      </apply>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>a</ci>
       <ci>π</ci>
      </apply>
      <apply>
       <ci>sinc</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <ci>y</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <sin></sin>
       <apply>
        <times></times>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <ci>y</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>π</ci>
       <apply>
        <minus></minus>
        <ci>y</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{x}(y)=\frac{a}{\pi}\operatorname{sinc}(a(y-x))=\frac{\sin(a(y-x))}{\pi(y-x)}
  </annotation>
 </semantics>
</math>

.</p>

<p>Note, that 

<math display="inline" id="Reproducing_kernel_Hilbert_space:29">
 <semantics>
  <msub>
   <mi>K</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{x}
  </annotation>
 </semantics>
</math>

 in this case is the "bandlimited version" of the Dirac delta distribution and that 

<math display="inline" id="Reproducing_kernel_Hilbert_space:30">
 <semantics>
  <msub>
   <mi>K</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{x}
  </annotation>
 </semantics>
</math>

 converges to 

<math display="inline" id="Reproducing_kernel_Hilbert_space:31">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>⋅</mo>
    <mo>-</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">δ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>normal-⋅</ci>
     <minus></minus>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(\cdot-x)
  </annotation>
 </semantics>
</math>

 in the weak sense, as explained in the entry for the <a href="Sinc#Relationship_to_the_Dirac_delta_distribution" title="wikilink">sinc function</a>.</p>
<h2 id="moore-aronszajn-theorem">Moore-Aronszajn Theorem</h2>

<p>We have seen how a reproducing kernel Hilbert space defines a reproducing kernel function that is both symmetric and <a href="positive_definite_kernel" title="wikilink">positive definite</a>. The Moore-Aronszajn theorem goes in the other direction; it states that every symmetric, positive definite kernel defines a unique reproducing kernel Hilbert space. The theorem first appeared in Aronszajn's <em>Theory of Reproducing Kernels</em>, although he attributes it to <a href="E._H._Moore" title="wikilink">E. H. Moore</a>.</p>
<blockquote>

<p><strong>Theorem</strong>. Suppose <em>K</em> is a symmetric, <a href="positive_definite_kernel" title="wikilink">positive definite kernel</a> on a set <em>X</em>. Then there is a unique Hilbert space of functions on <em>X</em> for which <em>K</em> is a reproducing kernel.</p>
</blockquote>

<p><strong>Proof</strong>. For all <em>x</em> in <em>X</em>, define <em>K<sub>x</sub></em> = <em>K</em>(<em>x</em>, ⋅ ). Let <em>H</em><sub>0</sub> be the linear span of {<em>K<sub>x</sub></em> : <em>x</em> ∈ <em>X</em>}. Define an inner product on <em>H</em><sub>0</sub> by</p>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:32">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>⟨</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>b</mi>
        <mi>j</mi>
       </msub>
       <msub>
        <mi>K</mi>
        <msub>
         <mi>y</mi>
         <mi>j</mi>
        </msub>
       </msub>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>m</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>a</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>K</mi>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
       </msub>
      </mrow>
     </mrow>
     <mo>⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>m</mi>
     </munderover>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>a</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>b</mi>
        <mi>j</mi>
       </msub>
       <mi>K</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>y</mi>
         <mi>j</mi>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </list>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>j</ci>
       </apply>
       <ci>K</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\langle\sum_{j=1}^{n}b_{j}K_{y_{j}},\sum_{i=1}^{m}a_{i}K_{x_{i}}\right%
\rangle=\sum_{i=1}^{m}\sum_{j=1}^{n}{a_{i}}b_{j}K(y_{j},x_{i}).
  </annotation>
 </semantics>
</math>

</p>

<p>The symmetry of this inner product follows from the symmetry of <em>K</em> and the non-degeneracy follows from the fact that <em>K</em> is positive definite.</p>

<p>Let <em>H</em> be the <a href="Completion_(metric_space)" title="wikilink">completion</a> of <em>H</em><sub>0</sub> with respect to this inner product. Then <em>H</em> consists of functions of the form</p>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>K</mi>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=\sum_{i=1}^{\infty}a_{i}K_{x_{i}}(x)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Reproducing_kernel_Hilbert_space:34">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <msubsup>
      <mi>a</mi>
      <mi>i</mi>
      <mn>2</mn>
     </msubsup>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo><</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>K</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{\infty}a_{i}^{2}K(x_{i},x_{i})<\infty
  </annotation>
 </semantics>
</math>

. The fact that the above sum converges for every <em>x</em> follows from the <a href="Cauchy-Schwarz_inequality" title="wikilink">Cauchy-Schwarz inequality</a>.</p>

<p>Now we can check the reproducing property ():</p>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>f</mi>
     <mo>,</mo>
     <msub>
      <mi>K</mi>
      <mi>x</mi>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>⟨</mo>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi mathvariant="normal">∞</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>a</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>K</mi>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
       </msub>
      </mrow>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi>K</mi>
      <mi>x</mi>
     </msub>
     <mo>⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>i</mi>
      </msub>
      <mi>K</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <list>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>x</ci>
      </apply>
     </list>
     <list>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <infinity></infinity>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>K</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>x</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <ci>K</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <ci>x</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle f,K_{x}\rangle=\left\langle\sum_{i=1}^{\infty}a_{i}K_{x_{i}},K_{x}%
\right\rangle=\sum_{i=1}^{\infty}a_{i}K(x_{i},x)=f(x).
  </annotation>
 </semantics>
</math>

</p>

<p>To prove uniqueness, let <em>G</em> be another Hilbert space of functions for which <em>K</em> is a reproducing kernel. For any <em>x</em> and <em>y</em> in <em>X</em>, () implies that</p>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:36">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msub>
       <mi>K</mi>
       <mi>x</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>K</mi>
       <mi>y</mi>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>H</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msub>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msub>
       <mi>K</mi>
       <mi>x</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>K</mi>
       <mi>y</mi>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>G</mi>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>y</ci>
       </apply>
      </list>
      <ci>H</ci>
     </apply>
     <apply>
      <times></times>
      <ci>K</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>y</ci>
       </apply>
      </list>
      <ci>G</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle K_{x},K_{y}\rangle_{H}=K(x,y)=\langle K_{x},K_{y}\rangle_{G}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>By linearity, 

<math display="inline" id="Reproducing_kernel_Hilbert_space:37">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mo>⋅</mo>
     <mo>,</mo>
     <mo>⋅</mo>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>H</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mo>⋅</mo>
     <mo>,</mo>
     <mo>⋅</mo>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>G</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <list>
      <ci>normal-⋅</ci>
      <ci>normal-⋅</ci>
     </list>
     <ci>H</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <list>
      <ci>normal-⋅</ci>
      <ci>normal-⋅</ci>
     </list>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\cdot,\cdot\rangle_{H}=\langle\cdot,\cdot\rangle_{G}
  </annotation>
 </semantics>
</math>

 on the span of {<em>K<sub>x</sub></em> : <em>x</em> ∈ <em>X</em>}. Then <em>G</em> = <em>H</em> by the uniqueness of the completion.</p>
<h2 id="integral-operators-and-mercers-theorem">Integral Operators and Mercer's Theorem</h2>

<p>We may characterize a symmetric positive definite kernel 

<math display="inline" id="Reproducing_kernel_Hilbert_space:38">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 via the integral operator using <a href="Mercer's_theorem" title="wikilink">Mercer's theorem</a> and obtain an additional view of the RKHS. Let 

<math display="inline" id="Reproducing_kernel_Hilbert_space:39">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 be a compact space equipped with a strictly positive finite <a href="Borel_measure" title="wikilink">Borel measure</a> 

<math display="inline" id="Reproducing_kernel_Hilbert_space:40">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Reproducing_kernel_Hilbert_space:41">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mo>×</mo>
     <mi>X</mi>
    </mrow>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>K</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>X</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K:X\times X\to\mathbb{R}
  </annotation>
 </semantics>
</math>

 a continuous, symmetric, and positive definite function. Define the integral operator 

<math display="inline" id="Reproducing_kernel_Hilbert_space:42">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mi>K</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>L</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <msub>
      <mi>L</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>K</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{K}:L_{2}(X)\rightarrow L_{2}(X)
  </annotation>
 </semantics>
</math>

 as</p>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:43">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <msub>
       <mi>T</mi>
       <mi>K</mi>
      </msub>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>⋅</mo>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi>X</mi>
    </msub>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>⋅</mo>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>μ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>K</ci>
       </apply>
       <ci>f</ci>
      </apply>
     </apply>
     <ci>normal-⋅</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>X</ci>
     </apply>
     <apply>
      <times></times>
      <ci>K</ci>
      <interval closure="open">
       <ci>normal-⋅</ci>
       <ci>t</ci>
      </interval>
      <ci>f</ci>
      <ci>t</ci>
      <ci>d</ci>
      <ci>μ</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [T_{K}f](\cdot)=\int_{X}K(\cdot,t)f(t)\,d\mu(t)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Reproducing_kernel_Hilbert_space:44">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{2}(X)
  </annotation>
 </semantics>
</math>

 is the space of square integrable functions with respect to 

<math display="inline" id="Reproducing_kernel_Hilbert_space:45">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

.</p>

<p>Mercer's theorem states that the spectral decomposition of the integral operator 

<math display="inline" id="Reproducing_kernel_Hilbert_space:46">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>K</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{K}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Reproducing_kernel_Hilbert_space:47">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 yields a series representation of 

<math display="inline" id="Reproducing_kernel_Hilbert_space:48">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 in terms of the eigenvalues and eigenfunctions of 

<math display="inline" id="Reproducing_kernel_Hilbert_space:49">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>K</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{K}
  </annotation>
 </semantics>
</math>

. This then implies that 

<math display="inline" id="Reproducing_kernel_Hilbert_space:50">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 is a reproducing kernel so that the corresponding RKHS can be defined in terms of these eigenvalues and eigenfunctions. We provide the details below.</p>

<p>Under these assumptions 

<math display="inline" id="Reproducing_kernel_Hilbert_space:51">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{k}
  </annotation>
 </semantics>
</math>

 is a compact, continuous, self-adjoint, and positive operator. The <a href="spectral_theorem" title="wikilink">spectral theorem</a> for self-adjoint operators implies that there is an at most countable decreasing sequence 

<math display="inline" id="Reproducing_kernel_Hilbert_space:52">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>σ</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>i</mi>
   </msub>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>i</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\sigma_{i})_{i}\geq 0
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Reproducing_kernel_Hilbert_space:53">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>lim</mo>
     <mrow>
      <mi>i</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
    <msub>
     <mi>σ</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>i</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim_{i\to\infty}\sigma_{i}=0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Reproducing_kernel_Hilbert_space:54">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>T</mi>
     <mi>K</mi>
    </msub>
    <msub>
     <mi>ϕ</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>σ</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>ϕ</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>K</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>i</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>i</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{K}\phi_{i}(x)=\sigma_{i}\phi_{i}(x)
  </annotation>
 </semantics>
</math>

, where the 

<math display="inline" id="Reproducing_kernel_Hilbert_space:55">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>ϕ</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>i</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\phi_{i}\}
  </annotation>
 </semantics>
</math>

 form an orthonormal basis of 

<math display="inline" id="Reproducing_kernel_Hilbert_space:56">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{2}(X)
  </annotation>
 </semantics>
</math>

. By the positivity 

<math display="inline" id="Reproducing_kernel_Hilbert_space:57">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{k}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Reproducing_kernel_Hilbert_space:58">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mi>i</mi>
   </msub>
   <mo>></mo>
   <mrow>
    <mn>0</mn>
    <mrow></mrow>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">0</cn>
     <mtext></mtext>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{i}>0\text{ }\forall i
  </annotation>
 </semantics>
</math>

. One can also show that 

<math display="inline" id="Reproducing_kernel_Hilbert_space:59">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{k}
  </annotation>
 </semantics>
</math>

 maps continuously into the space of continuous functions 

<math display="inline" id="Reproducing_kernel_Hilbert_space:60">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(X)
  </annotation>
 </semantics>
</math>

 and therefore we may choose continuous functions as the eigenvectors, that is, 

<math display="inline" id="Reproducing_kernel_Hilbert_space:61">
 <semantics>
  <mrow>
   <msub>
    <mi>ϕ</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow></mrow>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>X</ci>
     <mtext></mtext>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{i}\in C(X)\text{ }\forall i
  </annotation>
 </semantics>
</math>

. Then by Mercer's theorem 

<math display="inline" id="Reproducing_kernel_Hilbert_space:62">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 may be written in terms of the eigenvalues and continuous eigenfunctions as</p>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:63">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mrow>
     <mpadded width="+1.7pt">
      <msub>
       <mi>σ</mi>
       <mi>j</mi>
      </msub>
     </mpadded>
     <msub>
      <mi>ϕ</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>ϕ</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <ci>j</ci>
      </apply>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <ci>j</ci>
      </apply>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x,y)=\sum_{j=1}^{\infty}\sigma_{j}\,\phi_{j}(x)\,\phi_{j}(y)
  </annotation>
 </semantics>
</math>

</p>

<p>for all 

<math display="inline" id="Reproducing_kernel_Hilbert_space:64">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <ci>y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,y
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Reproducing_kernel_Hilbert_space:65">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Reproducing_kernel_Hilbert_space:66">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>lim</mo>
     <mrow>
      <mi>n</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
    <mrow>
     <msub>
      <mo>sup</mo>
      <mrow>
       <mi>u</mi>
       <mo>,</mo>
       <mi>v</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mrow>
        <mi>K</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>u</mi>
         <mo>,</mo>
         <mi>v</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <msubsup>
         <mo largeop="true" symmetric="true">∑</mo>
         <mrow>
          <mi>j</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>n</mi>
        </msubsup>
        <mrow>
         <mpadded width="+1.7pt">
          <msub>
           <mi>σ</mi>
           <mi>j</mi>
          </msub>
         </mpadded>
         <msub>
          <mi>ϕ</mi>
          <mi>j</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>u</mi>
          <mo rspace="4.2pt" stretchy="false">)</mo>
         </mrow>
         <msub>
          <mi>ϕ</mi>
          <mi>j</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>v</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>n</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">supremum</csymbol>
       <list>
        <ci>u</ci>
        <ci>v</ci>
       </list>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>K</ci>
         <interval closure="open">
          <ci>u</ci>
          <ci>v</ci>
         </interval>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <eq></eq>
            <ci>j</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <ci>n</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>σ</ci>
           <ci>j</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ϕ</ci>
           <ci>j</ci>
          </apply>
          <ci>u</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ϕ</ci>
           <ci>j</ci>
          </apply>
          <ci>v</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim_{n\to\infty}\sup_{u,v}|K(u,v)-\sum_{j=1}^{n}\sigma_{j}\,\phi_{j}(u)\,\phi%
_{j}(v)|=0.
  </annotation>
 </semantics>
</math>

 This above series representation is referred to as a Mercer kernel or Mercer representation of 

<math display="inline" id="Reproducing_kernel_Hilbert_space:67">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

.</p>

<p>Furthermore, it can be shown that the RKHS 

<math display="inline" id="Reproducing_kernel_Hilbert_space:68">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Reproducing_kernel_Hilbert_space:69">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 is given by</p>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:70">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mi>f</mi>
    <mo>∈</mo>
    <msub>
     <mi>L</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo mathsize="260%" stretchy="false">|</mo>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mfrac>
     <msup>
      <mrow>
       <mo>⟨</mo>
       <mi>f</mi>
       <mo>,</mo>
       <msub>
        <mi>ϕ</mi>
        <mi>i</mi>
       </msub>
       <mo>⟩</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <msub>
      <mi>σ</mi>
      <mi>i</mi>
     </msub>
    </mfrac>
    <mo><</mo>
    <mi mathvariant="normal">∞</mi>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">H</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">f</csymbol>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <cn type="integer">2</cn>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">X</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <list>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ϕ</ci>
         <ci>i</ci>
        </apply>
       </list>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <lt></lt>
     <infinity></infinity>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=\left\{f{\in}L_{2}(X)\mathrel{\Bigg|}\sum_{i=1}^{\infty}\frac{\left\langle f%
,\phi_{i}\right\rangle^{2}}{\sigma_{i}}<\infty\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>where the inner product of 

<math display="inline" id="Reproducing_kernel_Hilbert_space:71">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 given by 

<math display="inline" id="Reproducing_kernel_Hilbert_space:72">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo>⟨</mo>
      <mi>f</mi>
      <mo>,</mo>
      <mi>g</mi>
      <mo>⟩</mo>
     </mrow>
     <mi>H</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mfrac>
      <mrow>
       <msub>
        <mrow>
         <mo>⟨</mo>
         <mi>f</mi>
         <mo>,</mo>
         <msub>
          <mi>ϕ</mi>
          <mi>i</mi>
         </msub>
         <mo>⟩</mo>
        </mrow>
        <msub>
         <mi>L</mi>
         <mn>2</mn>
        </msub>
       </msub>
       <msub>
        <mrow>
         <mo>⟨</mo>
         <mi>g</mi>
         <mo>,</mo>
         <msub>
          <mi>ϕ</mi>
          <mi>i</mi>
         </msub>
         <mo>⟩</mo>
        </mrow>
        <msub>
         <mi>L</mi>
         <mn>2</mn>
        </msub>
       </msub>
      </mrow>
      <msub>
       <mi>σ</mi>
       <mi>i</mi>
      </msub>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <list>
      <ci>f</ci>
      <ci>g</ci>
     </list>
     <ci>H</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <list>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ϕ</ci>
          <ci>i</ci>
         </apply>
        </list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <list>
         <ci>g</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ϕ</ci>
          <ci>i</ci>
         </apply>
        </list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\langle f,g\right\rangle_{H}=\sum_{i=1}^{\infty}\frac{\left\langle f,\phi%
_{i}\right\rangle_{L_{2}}\left\langle g,\phi_{i}\right\rangle_{L_{2}}}{\sigma_%
{i}}.
  </annotation>
 </semantics>
</math>

 This representation of the RKHS has application in probability and statistics, for example to the <a href="Karhunen–Loève_theorem" title="wikilink"> Karhunen-Loeve representation</a> for stochastic processes and <a href="kernel_PCA" title="wikilink">kernel PCA</a>.</p>
<h2 id="feature-maps">Feature Maps</h2>

<p>A <strong>feature map</strong> is a map 

<math display="inline" id="Reproducing_kernel_Hilbert_space:73">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <mi>F</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>φ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <ci>F</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi:X\rightarrow F
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Reproducing_kernel_Hilbert_space:74">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is a Hilbert space which we will call the feature space. The first sections presented the connection between bounded/continuous evaluation functions, positive definite functions, and integral operators and in this section we provide another representation of the RKHS in terms of feature maps.</p>

<p>We first note that every feature map defines a kernel via</p>

<p><mtpl></mtpl></p>

<p>Clearly 

<math display="inline" id="Reproducing_kernel_Hilbert_space:75">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 is symmetric and positive definiteness follows from the properties of inner product in 

<math display="inline" id="Reproducing_kernel_Hilbert_space:76">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

. Conversely, every positive definite function and corresponding reproducing kernel Hilbert space has infinitely many associated feature maps such that () holds.</p>

<p>For example, we can trivially take 

<math display="inline" id="Reproducing_kernel_Hilbert_space:77">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>F</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=H
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Reproducing_kernel_Hilbert_space:78">
 <semantics>
  <mrow>
   <mrow>
    <mi>φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>K</mi>
    <mi>x</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>φ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi(x)=K_{x}
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Reproducing_kernel_Hilbert_space:79">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in X
  </annotation>
 </semantics>
</math>

. Then () is satisfied by the reproducing property. Another classical example of a feature map relates to the previous section regarding integral operators by taking 

<math display="inline" id="Reproducing_kernel_Hilbert_space:80">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <msup>
    <mi mathvariant="normal">ℓ</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>F</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-ℓ</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=\ell^{2}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Reproducing_kernel_Hilbert_space:81">
 <semantics>
  <mrow>
   <mrow>
    <mi>φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msqrt>
       <msub>
        <mi>σ</mi>
        <mi>i</mi>
       </msub>
      </msqrt>
      <msub>
       <mi>ϕ</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>φ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <times></times>
      <apply>
       <root></root>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϕ</ci>
       <ci>i</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi(x)=(\sqrt{\sigma_{i}}\phi_{i}(x))_{i}
  </annotation>
 </semantics>
</math>

.</p>

<p>This connection between kernels and feature maps provides us with a new way to understand positive definite functions and hence reproducing kernels as inner products in 

<math display="inline" id="Reproducing_kernel_Hilbert_space:82">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

. Moreover, every feature map can naturally define a RKHS by means of the definition of a positive definite function.</p>

<p>Lastly, feature maps allow us to construct function spaces that reveal another perspective on the RKHS. Consider the linear space</p>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:83">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mi>φ</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>f</mi>
    <mo>:</mo>
    <mi>X</mi>
    <mo>→</mo>
    <mi>ℝ</mi>
    <mo stretchy="false">|</mo>
    <mo>∃</mo>
    <mi>w</mi>
    <mo>∈</mo>
    <mi>F</mi>
    <mo>,</mo>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <msub>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>w</mi>
      <mo>,</mo>
      <mi>φ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>F</mi>
    </msub>
    <mo>,</mo>
    <mo>∀</mo>
    <mrow></mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>X</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <ci>φ</ci>
    </apply>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-|</ci>
     <exists></exists>
     <csymbol cd="unknown">w</csymbol>
     <in></in>
     <csymbol cd="unknown">F</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-⟨</ci>
       <csymbol cd="unknown">w</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">φ</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-⟩</ci>
      </cerror>
      <ci>F</ci>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <mtext></mtext>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">X</csymbol>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{\varphi}=\{f:X\to\mathbb{R}|\exists w\in F,f(x)=\langle w,\varphi(x)\rangle%
_{F},\forall\text{ }x\in X\}.
  </annotation>
 </semantics>
</math>

</p>

<p>We can define a norm on 

<math display="inline" id="Reproducing_kernel_Hilbert_space:84">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>φ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{\varphi}
  </annotation>
 </semantics>
</math>

 by</p>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:85">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo fence="true">||</mo>
      <mi>f</mi>
      <mo fence="true">||</mo>
     </mrow>
     <mi>φ</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mtext>inf</mtext>
     <mrow>
      <mo stretchy="false">{</mo>
      <msub>
       <mrow>
        <mo fence="true">||</mo>
        <mi>w</mi>
        <mo fence="true">||</mo>
       </mrow>
       <mi>F</mi>
      </msub>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mi>w</mi>
        <mo>∈</mo>
        <mi>F</mi>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mrow>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>=</mo>
         <msub>
          <mrow>
           <mo stretchy="false">⟨</mo>
           <mi>w</mi>
           <mo>,</mo>
           <mrow>
            <mi>φ</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>x</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo stretchy="false">⟩</mo>
          </mrow>
          <mi>F</mi>
         </msub>
        </mrow>
        <mo>,</mo>
        <mrow>
         <mrow>
          <mo>∀</mo>
          <mrow>
           <mrow></mrow>
           <mi>x</mi>
          </mrow>
         </mrow>
         <mo>∈</mo>
         <mi>X</mi>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>f</ci>
     </apply>
     <ci>φ</ci>
    </apply>
    <apply>
     <times></times>
     <mtext>inf</mtext>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <ci>w</ci>
       </apply>
       <ci>F</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <in></in>
        <ci>w</ci>
        <ci>F</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <eq></eq>
         <apply>
          <times></times>
          <ci>f</ci>
          <ci>x</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <list>
           <ci>w</ci>
           <apply>
            <times></times>
            <ci>φ</ci>
            <ci>x</ci>
           </apply>
          </list>
          <ci>F</ci>
         </apply>
        </apply>
        <apply>
         <in></in>
         <apply>
          <csymbol cd="latexml">for-all</csymbol>
          <apply>
           <times></times>
           <mtext></mtext>
           <ci>x</ci>
          </apply>
         </apply>
         <ci>X</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ||f||_{\varphi}=\text{inf}\{||w||_{F}:w\in F,f(x)=\langle w,\varphi(x)\rangle_%
{F},\forall\text{ }x\in X\}.
  </annotation>
 </semantics>
</math>

</p>

<p>It can be shown that 

<math display="inline" id="Reproducing_kernel_Hilbert_space:86">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>φ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{\varphi}
  </annotation>
 </semantics>
</math>

 is a RKHS with kernel defined by 

<math display="inline" id="Reproducing_kernel_Hilbert_space:87">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <list>
     <apply>
      <times></times>
      <ci>φ</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>φ</ci>
      <ci>y</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x,y)=\langle\varphi(x),\varphi(y)\rangle
  </annotation>
 </semantics>
</math>

. This representation implies that the elements of the RKHS are inner products of elements in the feature space and can accordingly be seen as hyperplanes. This view of the RKHS is related to the <a href="kernel_trick" title="wikilink">kernel trick</a> in machine learning. <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="properties">Properties</h2>

<p>The following properties of RKHSs may be useful to readers.</p>
<ul>
<li>Let 

<math display="inline" id="Reproducing_kernel_Hilbert_space:88">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>p</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <eq></eq>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (X_{i})_{i=1}^{p}
  </annotation>
 </semantics>
</math>

 be a sequence of sets and 

<math display="inline" id="Reproducing_kernel_Hilbert_space:89">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>K</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>p</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <eq></eq>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (K_{i})_{i=1}^{p}
  </annotation>
 </semantics>
</math>

 be a collection of corresponding positive definite functions on 

<math display="inline" id="Reproducing_kernel_Hilbert_space:90">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>p</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <eq></eq>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (X_{i})_{i=1}^{p}
  </annotation>
 </semantics>
</math>

. It then follows that</li>
</ul>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:91">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>p</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mi>p</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>K</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>K</mi>
     <mi>p</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>p</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mi>p</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <interval closure="open">
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>p</ci>
       </apply>
      </vector>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>p</ci>
       </apply>
      </vector>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <cn type="integer">1</cn>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
     </interval>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <ci>p</ci>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>p</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K((x_{1},\dots,x_{p}),(y_{1},\dots,y_{p}))=K_{1}(x_{1},y_{1})\dots K_{p}(x_{p}%
,y_{p})
  </annotation>
 </semantics>
</math>

</p>

<p>is a kernel on 

<math display="inline" id="Reproducing_kernel_Hilbert_space:92">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>×</mo>
    <mi mathvariant="normal">…</mi>
    <mo>×</mo>
    <msub>
     <mi>X</mi>
     <mi>p</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=X_{1}\times\dots\times X_{p}
  </annotation>
 </semantics>
</math>

.</p>
<ul>
<li>Let 

<math display="inline" id="Reproducing_kernel_Hilbert_space:93">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>0</mn>
   </msub>
   <mo>⊂</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{0}\subset X
  </annotation>
 </semantics>
</math>

, then the restriction of 

<math display="inline" id="Reproducing_kernel_Hilbert_space:94">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Reproducing_kernel_Hilbert_space:95">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>0</mn>
   </msub>
   <mo>×</mo>
   <msub>
    <mi>X</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{0}\times X_{0}
  </annotation>
 </semantics>
</math>

 is also a reproducing kernel.</li>
</ul>
<ul>
<li>Consider a normalized kernel 

<math display="inline" id="Reproducing_kernel_Hilbert_space:96">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Reproducing_kernel_Hilbert_space:97">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>x</ci>
     </interval>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x,x)=1
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Reproducing_kernel_Hilbert_space:98">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in X
  </annotation>
 </semantics>
</math>

. Define a pseudo-metric on X as</li>
</ul>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:99">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>d</mi>
     <mi>K</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msubsup>
    <mrow>
     <mo fence="true">||</mo>
     <mrow>
      <msub>
       <mi>K</mi>
       <mi>x</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>K</mi>
       <mi>y</mi>
      </msub>
     </mrow>
     <mo fence="true">||</mo>
    </mrow>
    <mi>H</mi>
    <mn>2</mn>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mi>K</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow></mrow>
    <mrow>
     <mo>∀</mo>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <ci>K</ci>
      </apply>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>K</ci>
          <ci>x</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>K</ci>
          <ci>y</ci>
         </apply>
        </apply>
       </apply>
       <ci>H</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>K</ci>
        <interval closure="open">
         <ci>x</ci>
         <ci>y</ci>
        </interval>
       </apply>
      </apply>
      <mtext></mtext>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{K}(x,y)=||K_{x}-K_{y}||_{H}^{2}=2(1-K(x,y))\text{ }\forall x\in X
  </annotation>
 </semantics>
</math>

.</p>

<p>By the <a href="Cauchy–Schwarz_inequality" title="wikilink">Cauchy–Schwarz inequality</a>,</p>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:100">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>K</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>≤</mo>
     <mrow>
      <mi>K</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>K</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow></mrow>
      <mrow>
       <mo>∀</mo>
       <mi>x</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>y</mi>
     <mo>∈</mo>
     <mi>X</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <ci>K</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>K</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>x</ci>
      </interval>
      <ci>K</ci>
      <interval closure="open">
       <ci>y</ci>
       <ci>y</ci>
      </interval>
      <mtext></mtext>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>y</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x,y)^{2}\leq K(x,x)K(y,y)\text{ }\forall x,y\in X.
  </annotation>
 </semantics>
</math>

</p>

<p>This inequality allows us to view 

<math display="inline" id="Reproducing_kernel_Hilbert_space:101">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 as a measure of similarity between inputs. If 

<math display="inline" id="Reproducing_kernel_Hilbert_space:102">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
   </mrow>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>x</ci>
     <ci>y</ci>
    </list>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,y\in X
  </annotation>
 </semantics>
</math>

 are similar then 

<math display="inline" id="Reproducing_kernel_Hilbert_space:103">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x,y)
  </annotation>
 </semantics>
</math>

 will be closer to 1 while if 

<math display="inline" id="Reproducing_kernel_Hilbert_space:104">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
   </mrow>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>x</ci>
     <ci>y</ci>
    </list>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,y\in X
  </annotation>
 </semantics>
</math>

 are dissimilar then 

<math display="inline" id="Reproducing_kernel_Hilbert_space:105">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x,y)
  </annotation>
 </semantics>
</math>

 will be closer to 0.</p>
<ul>
<li>The closure of the span of 

<math display="inline" id="Reproducing_kernel_Hilbert_space:106">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>K</mi>
    <mi>x</mi>
   </msub>
   <mo stretchy="false">|</mo>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>X</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{K_{x}|x\in X\}
  </annotation>
 </semantics>
</math>

 coincides with 

<math display="inline" id="Reproducing_kernel_Hilbert_space:107">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

. <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
</ul>
<h2 id="examples">Examples</h2>

<p>Common examples of kernels include:</p>
<ul>
<li><strong>Linear Kernel</strong>:</li>
</ul>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:108">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <list>
     <ci>x</ci>
     <ci>y</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x,y)=\langle x,y\rangle
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li><strong>Polynomial Kernel</strong>:</li>
</ul>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:109">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>α</mi>
        <mrow>
         <mo stretchy="false">⟨</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>y</mi>
         <mo stretchy="false">⟩</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
    </msup>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mo>∈</mo>
     <mi>ℝ</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>d</mi>
     <mo>∈</mo>
     <mi>ℕ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>K</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>α</ci>
        <list>
         <ci>x</ci>
         <ci>y</ci>
        </list>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <ci>d</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>α</ci>
      <ci>ℝ</ci>
     </apply>
     <apply>
      <in></in>
      <ci>d</ci>
      <ci>ℕ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x,y)=(\alpha\langle x,y\rangle+1)^{d},\alpha{\in}\mathbb{R},d{\in}\mathbb{N}
  </annotation>
 </semantics>
</math>

</p>

<p>Other common examples are kernels which satisfy 

<math display="inline" id="Reproducing_kernel_Hilbert_space:110">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mi>y</mi>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>K</ci>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x,y)=K(\|x-y\|)
  </annotation>
 </semantics>
</math>

. These are the radial basis function kernels.</p>
<ul>
<li><strong>Radial Basis Function Kernels</strong>:</li>
</ul>

<p>:*<strong>Gaussian Kernel</strong>:</p>
<dl>
<dd><dl>
<dd>Sometimes referred to as the <a href="Radial_basis_function_kernel" title="wikilink">Radial basis function kernel</a>, or squared exponential kernel
</dd>
<dd>

<math display="inline" id="Reproducing_kernel_Hilbert_space:111">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mfrac>
       <msup>
        <mrow>
         <mo>∥</mo>
         <mrow>
          <mi>x</mi>
          <mo>-</mo>
          <mi>y</mi>
         </mrow>
         <mo>∥</mo>
        </mrow>
        <mn>2</mn>
       </msup>
       <mrow>
        <mn>2</mn>
        <msup>
         <mi>σ</mi>
         <mn>2</mn>
        </msup>
       </mrow>
      </mfrac>
     </mrow>
    </msup>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>σ</mi>
    <mo>></mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>K</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="latexml">norm</csymbol>
          <apply>
           <minus></minus>
           <ci>x</ci>
           <ci>y</ci>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>σ</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <ci>σ</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x,y)=e^{-\frac{\|x-y\|^{2}}{2\sigma^{2}}},\sigma>0
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>:* <strong>Laplacian Kernel</strong>:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Reproducing_kernel_Hilbert_space:112">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mfrac>
       <mrow>
        <mo>∥</mo>
        <mrow>
         <mi>x</mi>
         <mo>-</mo>
         <mi>y</mi>
        </mrow>
        <mo>∥</mo>
       </mrow>
       <mi>σ</mi>
      </mfrac>
     </mrow>
    </msup>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>σ</mi>
    <mo>></mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>K</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <minus></minus>
          <ci>x</ci>
          <ci>y</ci>
         </apply>
        </apply>
        <ci>σ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <ci>σ</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x,y)=e^{-\frac{\|x-y\|}{\sigma}},\sigma>0
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>We also provide examples of <a href="Bergman_kernel" title="wikilink">Bergman kernels</a>. Let <em>X</em> be finite and let <em>H</em> consist of all complex-valued functions on <em>X</em>. Then an element of <em>H</em> can be represented as an array of complex numbers. If the usual <a href="inner_product" title="wikilink">inner product</a> is used, then <em>K<sub>x</sub></em> is the function whose value is 1 at <em>x</em> and 0 everywhere else, and <em>K(x,y)</em> can be thought of as an identity matrix since <em>K(x,y)=1</em> when <em>x=y</em> and <em>K(x,y)=0</em> otherwise. In this case, <em>H</em> is isomorphic to <strong>C</strong><sup><em>n</em></sup>.</p>

<p>The case of <em>X</em> = <strong><a href="unit_disc" title="wikilink">D</a></strong> is more sophisticated, here the <a href="Bergman_space" title="wikilink">Bergman space</a> <a href="H_square" title="wikilink"><em>H</em><sup>2</sup>(<strong>D</strong>)</a> is the space of <a href="square-integrable_function" title="wikilink">square-integrable</a> <a href="holomorphic_function" title="wikilink">holomorphic functions</a> on <strong>D</strong>. It can be shown that the reproducing kernel for <em>H</em><sup>2</sup>(<strong>D</strong>) is</p>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:113">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>π</mi>
     </mfrac>
     <mfrac>
      <mn>1</mn>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mrow>
          <mi>x</mi>
          <mover accent="true">
           <mi>y</mi>
           <mo>¯</mo>
          </mover>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>π</ci>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>x</ci>
         <apply>
          <ci>normal-¯</ci>
          <ci>y</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x,y)=\frac{1}{\pi}\frac{1}{(1-x\overline{y})^{2}}.
  </annotation>
 </semantics>
</math>

</p>

<p>Lastly, the space of band limited functions 

<math display="inline" id="Reproducing_kernel_Hilbert_space:114">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Reproducing_kernel_Hilbert_space:115">
 <semantics>
  <mrow>
   <msup>
    <mi>L</mi>
    <mn>2</mn>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ℝ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>L</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>ℝ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{2}(\mathbb{R})
  </annotation>
 </semantics>
</math>

 with bandwidth 

<math display="inline" id="Reproducing_kernel_Hilbert_space:116">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 are a RKHS with reproducing kernel</p>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:117">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mi>sin</mi>
       <mi>π</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <mi>y</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>π</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <mi>y</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <sin></sin>
       <ci>π</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>π</ci>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x,y)=\frac{\sin\pi(x-y)}{\pi(x-y)}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="extension-to-vector-valued-functions">Extension to Vector-Valued Functions</h2>

<p>In this section we extend the definition of the RKHS to spaces of vector-valued functions as this extension is particularly important in <a href="multi-task_learning" title="wikilink">multi-task learning</a> and manifold regularization. The main difference is that the reproducing kernel 

<math display="inline" id="Reproducing_kernel_Hilbert_space:118">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

 is a symmetric function that is now a positive semi-definite <em>matrix</em> for any 

<math display="inline" id="Reproducing_kernel_Hilbert_space:119">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <ci>y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,y
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Reproducing_kernel_Hilbert_space:120">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

. More formally, we define a vector-valued RKHS (vvRKHS) as a Hilbert space of functions 

<math display="inline" id="Reproducing_kernel_Hilbert_space:121">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <msup>
     <mi>ℝ</mi>
     <mi>T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:X\to\mathbb{R}^{T}
  </annotation>
 </semantics>
</math>

 such that for all 

<math display="inline" id="Reproducing_kernel_Hilbert_space:122">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mi>T</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>c</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\in\mathbb{R}^{T}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Reproducing_kernel_Hilbert_space:123">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in X
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Reproducing_kernel_Hilbert_space:124">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Γ</mi>
     <mi>x</mi>
    </msub>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>H</mi>
    <mtext>for</mtext>
    <mi>y</mi>
   </mrow>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Γ</ci>
       <ci>x</ci>
      </apply>
      <ci>c</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Γ</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>H</ci>
      <mtext>for</mtext>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma_{x}c(y)=\Gamma(x,y)c\in H\text{ for }y\in X
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="inline" id="Reproducing_kernel_Hilbert_space:125">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <msub>
     <mi mathvariant="normal">Γ</mi>
     <mi>x</mi>
    </msub>
    <mi>c</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mi>X</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>c</mi>
     <mo>∈</mo>
     <msup>
      <mi>ℝ</mi>
      <mi>T</mi>
     </msup>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Γ</ci>
      <ci>x</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <in></in>
      <ci>c</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℝ</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\Gamma_{x}c:x\in X,c\in\mathbb{R}^{T}\}
  </annotation>
 </semantics>
</math>

</p>

<p>This second property parallels the reproducing property for the scalar-valued case. We note that this definition can also be connected to integral operators, bounded evaluation functions, and feature maps as we saw for the scalar-valued RKHS. We can equivalently define the vvRKHS as a vector-valued Hilbert space with a bounded evaluation functional and show that this implies the existence of a unique reproducing kernel by the Riesz Representation theorem. Mercer's theorem can also be extended to address the vector-valued setting and we can therefore obtain a feature map view of the vvRKHS. Lastly, it can also be shown that the closure of the span of 

<math display="inline" id="Reproducing_kernel_Hilbert_space:126">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 coincides with 

<math display="inline" id="Reproducing_kernel_Hilbert_space:127">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Λ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>T</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Λ</ci>
    <set>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>T</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda=\{1,\dots,T\}
  </annotation>
 </semantics>
</math>

, another property similar to the scalar-valued case.</p>

<p>We can gain intuition for the vvRKHS by taking a component-wise perspective on these spaces. In particular, we find that every vvRKHS is isometrically <a class="uri" href="isomorphic" title="wikilink">isomorphic</a> to a scalar-valued RKHS on a particular input space. Let 

<math display="inline" id="Reproducing_kernel_Hilbert_space:128">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>×</mo>
   <mi mathvariant="normal">Λ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>normal-Λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\times\Lambda
  </annotation>
 </semantics>
</math>

. Consider the space 

<math display="inline" id="Reproducing_kernel_Hilbert_space:129">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mi>X</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>t</mi>
     <mo>∈</mo>
     <mi mathvariant="normal">Λ</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>t</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <in></in>
      <ci>t</ci>
      <ci>normal-Λ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\gamma_{(x,t)}:x\in X,t\in\Lambda\}
  </annotation>
 </semantics>
</math>

 and the corresponding reproducing kernel</p>

<p>As noted above, the RKHS associated to this reproducing kernel is given by the closure of the span of 

<math display="inline" id="Reproducing_kernel_Hilbert_space:130">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mpadded lspace="5pt" width="+5pt">
      <mi>γ</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>γ</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>t</ci>
      </interval>
     </apply>
     <interval closure="open">
      <ci>y</ci>
      <ci>s</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>γ</ci>
     <interval closure="open">
      <interval closure="open">
       <ci>x</ci>
       <ci>t</ci>
      </interval>
      <interval closure="open">
       <ci>y</ci>
       <ci>s</ci>
      </interval>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \gamma_{(x,t)}(y,s)=\gamma((x,t),(y,s))
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Reproducing_kernel_Hilbert_space:131">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>X</mi>
    <mo>×</mo>
    <mi mathvariant="normal">Λ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <interval closure="open">
      <ci>x</ci>
      <ci>t</ci>
     </interval>
     <interval closure="open">
      <ci>y</ci>
      <ci>s</ci>
     </interval>
    </list>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>normal-Λ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,t),(y,s)\in X\times\Lambda
  </annotation>
 </semantics>
</math>

 for every set of pairs 

<math display="block" id="Reproducing_kernel_Hilbert_space:132">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Γ</mi>
     <msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>γ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo>,</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Γ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
      <interval closure="open">
       <ci>t</ci>
       <ci>s</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>γ</ci>
     <interval closure="open">
      <interval closure="open">
       <ci>x</ci>
       <ci>t</ci>
      </interval>
      <interval closure="open">
       <ci>y</ci>
       <ci>s</ci>
      </interval>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma(x,y)_{(t,s)}=\gamma((x,t),(y,s)).
  </annotation>
 </semantics>
</math>

.</p>

<p>The connection to the scalar-valued RKHS can then be made by the fact that every matrix-valued kernel can be identified with a kernel of the form of () via</p>

<p>

<math display="inline" id="Reproducing_kernel_Hilbert_space:133">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi mathvariant="normal">Γ</mi>
    </msub>
    <mo>→</mo>
    <msub>
     <mi>H</mi>
     <mi>γ</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>D</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>normal-Γ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>γ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D:H_{\Gamma}\to H_{\gamma}
  </annotation>
 </semantics>
</math>

</p>

<p>Moreover, every kernel with the form of () defines a matrix-valued kernel with the above expression. Now letting the map 

<math display="inline" id="Reproducing_kernel_Hilbert_space:134">
 <semantics>
  <msub>
   <mi>e</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{t}
  </annotation>
 </semantics>
</math>

 be defined as</p>

<p>

<math display="inline" id="Reproducing_kernel_Hilbert_space:135">
 <semantics>
  <msup>
   <mi>t</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>t</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{th}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Reproducing_kernel_Hilbert_space:136">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>T</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{T}
  </annotation>
 </semantics>
</math>

 is the 

<math display="inline" id="Reproducing_kernel_Hilbert_space:137">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 component of the canonical basis for 

<math display="inline" id="Reproducing_kernel_Hilbert_space:138">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi mathvariant="normal">Γ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>normal-Γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{\Gamma}
  </annotation>
 </semantics>
</math>

, one can show that 

<math display="inline" id="Reproducing_kernel_Hilbert_space:139">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>γ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>γ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{\gamma}
  </annotation>
 </semantics>
</math>

 is bijective and an isometry between 

<math display="inline" id="Reproducing_kernel_Hilbert_space:140">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 and 

<math display="block" id="Reproducing_kernel_Hilbert_space:141">
 <semantics>
  <mrow>
   <mrow>
    <mi>γ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>K</mi>
     <mi>T</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>γ</ci>
     <interval closure="open">
      <interval closure="open">
       <ci>x</ci>
       <ci>t</ci>
      </interval>
      <interval closure="open">
       <ci>y</ci>
       <ci>s</ci>
      </interval>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>K</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <ci>T</ci>
     </apply>
     <interval closure="open">
      <ci>t</ci>
      <ci>s</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma((x,t),(y,s))=K(x,y)K_{T}(t,s)
  </annotation>
 </semantics>
</math>

.</p>

<p>While this view of the vvRKHS can be quite useful in multi-task learning, it should be noted that this isometry does not reduce the study of the vector-valued case to that of the scalar-valued case. In fact, this isometry procedure can make both the scalar-valued kernel and the input space too difficult to work with in practice as properties of the original kernels are often lost. <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>An important class of matrix-valued reproducing kernels are <em>separable</em> kernels which can factorized as the product of a scalar valued kernel and a 

<math display="inline" id="Reproducing_kernel_Hilbert_space:142">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <ci>y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,y
  </annotation>
 </semantics>
</math>

-dimensional symmetric positive semi-definite matrix. In light of our previous discussion these kernels are of the form</p>

<p>

<math display="inline" id="Reproducing_kernel_Hilbert_space:143">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

</p>

<p>for all 

<math display="inline" id="Reproducing_kernel_Hilbert_space:144">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>,</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>t</ci>
    <ci>s</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t,s
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Reproducing_kernel_Hilbert_space:145">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 and <span class="LaTeX">$t,s$</span> in <span class="LaTeX">$T$</span>. As the scalar-valued kernel encodes dependencies between the inputs, we can observe that the matrix-valued kernel encodes dependencies among both the inputs and the outputs.</p>

<p>We lastly remark that the above theory can be further extended to spaces of functions with values in function spaces but obtaining kernels for these spaces is a more difficult task. <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Positive_definite_kernel" title="wikilink">Positive definite kernel</a></li>
<li><a href="Mercer's_theorem" title="wikilink">Mercer's theorem</a></li>
<li><a href="Kernel_trick" title="wikilink">Kernel trick</a></li>
<li><a href="Kernel_embedding_of_distributions" title="wikilink">Kernel embedding of distributions</a></li>
<li><a href="Representer_theorem" title="wikilink">Representer theorem</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>Alvarez, Mauricio, Rosasco, Lorenzo and Lawrence, Neil, “Kernels for Vector-Valued Functions: a Review,” <a class="uri" href="http://arxiv.org/abs/1106.6251">http://arxiv.org/abs/1106.6251</a>, June 2011.</li>
<li></li>
<li>Berlinet, Alain and Thomas, Christine. <em>Reproducing kernel Hilbert spaces in Probability and Statistics</em>, Kluwer Academic Publishers, 2004.</li>
<li></li>
<li>De Vito, Ernest, Umanita, Veronica, and Villa, Silvia. "An extension of Mercer theorem to vector-valued measurable kernels," <a class="uri" href="http://arxiv.org/pdf/1110.4017.pdf">http://arxiv.org/pdf/1110.4017.pdf</a>, June 2013.</li>
<li>Durrett, Greg. 9.520 Course Notes, Massachusetts Institute of Technology, <a class="uri" href="http://www.mit.edu/~9.520/scribe-notes/class03_gdurett.pdf">http://www.mit.edu/~9.520/scribe-notes/class03_gdurett.pdf</a>, February 2010.</li>
<li></li>
<li>Okutmustur, Baver. “Reproducing Kernel Hilbert Spaces,” Ph.D. dissertation, Bilkent University, <a class="uri" href="http://www.thesis.bilkent.edu.tr/0002953.pdf">http://www.thesis.bilkent.edu.tr/0002953.pdf</a>, August 2005.</li>
<li>Paulsen, Vern. “An introduction to the theory of reproducing kernel Hilbert spaces,” <a class="uri" href="http://www.math.uh.edu/∼vern/rkhs.pdf">http://www.math.uh.edu/∼vern/rkhs.pdf</a>.</li>
<li></li>
<li>Rosasco, Lorenzo and Poggio, Thomas. "A Regularization Tour of Machine Learning - MIT 9.520 Lecture Notes" Manuscript, Dec. 2014.</li>
<li><a href="Grace_Wahba" title="wikilink"> Wahba, Grace</a>, <em>Spline Models for Observational Data</em>, <a href="http://www.siam.org/books/">SIAM</a>, 1990.</li>
<li>Zhang, Haizhang, Xu, Yuesheng, and Zhang, Qinghui (2012). "Refinement of Operator-valued Reproducing Kernels." Journal of Machine Learning Research 13 91-136.</li>
</ul>

<p>"</p>

<p><a href="Category:Hilbert_space" title="wikilink">Category:Hilbert space</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Okutmustur<a href="#fnref1">↩</a></li>
<li id="fn2">Paulson<a href="#fnref2">↩</a></li>
<li id="fn3">Durrett<a href="#fnref3">↩</a></li>
<li id="fn4">Rosasco<a href="#fnref4">↩</a></li>
<li id="fn5">Rosasco<a href="#fnref5">↩</a></li>
<li id="fn6">De Vito<a href="#fnref6">↩</a></li>
<li id="fn7">Zhang<a href="#fnref7">↩</a></li>
<li id="fn8">Alvarez<a href="#fnref8">↩</a></li>
<li id="fn9">Rosasco<a href="#fnref9">↩</a></li>
</ol>
</section>
</body>
</html>
