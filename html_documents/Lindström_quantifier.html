<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1867">Lindström quantifier</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Lindström quantifier</h1>
<hr/>

<p>In <a href="mathematical_logic" title="wikilink">mathematical logic</a>, a <strong>Lindström quantifier</strong> is a <a href="generalized_quantifier" title="wikilink">generalized polyadic quantifier</a>. They are a generalization of first-order quantifiers, such as the <a href="existential_quantifier" title="wikilink">existential quantifier</a>, the <a href="universal_quantifier" title="wikilink">universal quantifier</a>, and the <a href="counting_quantifier" title="wikilink">counting quantifiers</a>. They were introduced by <a href="Per_Lindström" title="wikilink">Per Lindström</a> in 1966. They were later studied for their applications in <a href="logic_in_computer_science" title="wikilink">logic in computer science</a> and database <a href="query_language" title="wikilink">query languages</a>.</p>
<h2 id="generalization-of-first-order-quantifiers">Generalization of first-order quantifiers</h2>

<p>In order to facilitate discussion, some notational conventions need explaining. The expression</p>

<p>

<math display="block" id="Lindström_quantifier:0">
 <semantics>
  <mrow>
   <msup>
    <mi>ϕ</mi>
    <mrow>
     <mi>A</mi>
     <mo>,</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mover accent="true">
      <mi>a</mi>
      <mo stretchy="false">¯</mo>
     </mover>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mi>A</mi>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mi>A</mi>
     <mo>⊧</mo>
     <mrow>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mover accent="true">
        <mi>a</mi>
        <mo stretchy="false">¯</mo>
       </mover>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ϕ</ci>
     <list>
      <ci>A</ci>
      <ci>x</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>a</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">models</csymbol>
      <ci>A</ci>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <interval closure="closed">
        <ci>x</ci>
        <apply>
         <ci>normal-¯</ci>
         <ci>a</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi^{A,x,\bar{a}}=\{x\in A\colon A\models\phi[x,\bar{a}]\}
  </annotation>
 </semantics>
</math>

</p>

<p>for <em>A</em> an <em>L</em>-structure (or <em>L</em>-model) in a language <em>L</em>,<em>φ</em> an <em>L</em>-formula, and 

<math display="inline" id="Lindström_quantifier:1">
 <semantics>
  <mover accent="true">
   <mi>a</mi>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{a}
  </annotation>
 </semantics>
</math>

 a tuple of elements of the domain dom(<em>A</em>) of <em>A</em>. In other words, 

<math display="inline" id="Lindström_quantifier:2">
 <semantics>
  <msup>
   <mi>ϕ</mi>
   <mrow>
    <mi>A</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mover accent="true">
     <mi>a</mi>
     <mo stretchy="false">¯</mo>
    </mover>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ϕ</ci>
    <list>
     <ci>A</ci>
     <ci>x</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>a</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi^{A,x,\bar{a}}
  </annotation>
 </semantics>
</math>

 denotes a (<a href="monadic_(arity)" title="wikilink">monadic</a>) property defined on dom(A). In general, where <em>x</em> is replaced by an <em>n</em>-tuple 

<math display="inline" id="Lindström_quantifier:3">
 <semantics>
  <mover accent="true">
   <mi>x</mi>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{x}
  </annotation>
 </semantics>
</math>


 of free variables, 

<math display="inline" id="Lindström_quantifier:4">
 <semantics>
  <msup>
   <mi>ϕ</mi>
   <mrow>
    <mi>A</mi>
    <mo>,</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">¯</mo>
    </mover>
    <mo>,</mo>
    <mover accent="true">
     <mi>a</mi>
     <mo stretchy="false">¯</mo>
    </mover>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ϕ</ci>
    <list>
     <ci>A</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <ci>normal-¯</ci>
      <ci>a</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi^{A,\bar{x},\bar{a}}
  </annotation>
 </semantics>
</math>

 denotes an <em>n</em>-ary relation defined on dom(<em>A</em>). Each quantifier 

<math display="inline" id="Lindström_quantifier:5">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{A}
  </annotation>
 </semantics>
</math>

 is relativized to a structure, since each quantifier is viewed as a family of relations (between relations) on that structure. For a concrete example, take the universal and existential quantifiers ∀ and ∃, respectively. Their truth conditions can be specified as</p>

<p>

<math display="block" id="Lindström_quantifier:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>⊧</mo>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mi>x</mi>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mover accent="true">
        <mi>a</mi>
        <mo stretchy="false">¯</mo>
       </mover>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <msup>
     <mi>ϕ</mi>
     <mrow>
      <mi>A</mi>
      <mo>,</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mover accent="true">
       <mi>a</mi>
       <mo stretchy="false">¯</mo>
      </mover>
     </mrow>
    </msup>
    <mo>∈</mo>
    <msub>
     <mo>∀</mo>
     <mi>A</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <apply>
     <csymbol cd="latexml">models</csymbol>
     <ci>A</ci>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>ϕ</ci>
       <interval closure="closed">
        <ci>x</ci>
        <apply>
         <ci>normal-¯</ci>
         <ci>a</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ϕ</ci>
      <list>
       <ci>A</ci>
       <ci>x</ci>
       <apply>
        <ci>normal-¯</ci>
        <ci>a</ci>
       </apply>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\models\forall x\phi[x,\bar{a}]\iff\phi^{A,x,\bar{a}}\in\forall_{A}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Lindström_quantifier:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mo>⊧</mo>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <mi>x</mi>
       <mi>ϕ</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mover accent="true">
         <mi>a</mi>
         <mo stretchy="false">¯</mo>
        </mover>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>⇔</mo>
    <mrow>
     <msup>
      <mi>ϕ</mi>
      <mrow>
       <mi>A</mi>
       <mo>,</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mover accent="true">
        <mi>a</mi>
        <mo stretchy="false">¯</mo>
       </mover>
      </mrow>
     </msup>
     <mo>∈</mo>
     <msub>
      <mo>∃</mo>
      <mi>A</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <apply>
     <csymbol cd="latexml">models</csymbol>
     <ci>A</ci>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>ϕ</ci>
       <interval closure="closed">
        <ci>x</ci>
        <apply>
         <ci>normal-¯</ci>
         <ci>a</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ϕ</ci>
      <list>
       <ci>A</ci>
       <ci>x</ci>
       <apply>
        <ci>normal-¯</ci>
        <ci>a</ci>
       </apply>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <exists></exists>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\models\exists x\phi[x,\bar{a}]\iff\phi^{A,x,\bar{a}}\in\exists_{A},
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Lindström_quantifier:8">
 <semantics>
  <msub>
   <mo>∀</mo>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall_{A}
  </annotation>
 </semantics>
</math>


 is the singleton whose sole member is dom(<em>A</em>), and 

<math display="inline" id="Lindström_quantifier:9">
 <semantics>
  <msub>
   <mo>∃</mo>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <exists></exists>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists_{A}
  </annotation>
 </semantics>
</math>

 is the set of all non-empty subsets of dom(<em>A</em>) (i.e. the <a href="power_set" title="wikilink">power set</a> of dom(<em>A</em>) minus the empty set). In other words, each quantifier is a family of properties on dom(<em>A</em>), so each is called a <em>monadic</em> quantifier. Any quantifier defined as an <em>n</em> &gt; 0-ary relation between properties on dom(<em>A</em>) is called <em>monadic</em>. Lindström introduced polyadic ones that are <em>n</em> &gt; 0-ary relations between relations on domains of structures.</p>

<p>Before we go on to Lindström's generalization, notice that any family of properties on dom(<em>A</em>) can be regarded as a monadic generalized quantifier. For example, the quantifier "there are exactly <em>n</em> things such that..." is a family of subsets of the domain a structure, each of which has a cardinality off size <em>n</em>. Then, "there are exactly 2 things such that φ" is true in A iff the set of things that are such that φ is a member of the set of all subsets of dom(<em>A</em>) of size 2.</p>

<p>A Lindström quantifier is a polyadic generalized quantifier, so instead being a relation between subsets of the domain, it is a relation between relations defined on the domain. For example, the quantifier 

<math display="inline" id="Lindström_quantifier:10">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mi>A</mi>
   </msub>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <msub>
    <mi>z</mi>
    <mn>1</mn>
   </msub>
   <msub>
    <mi>z</mi>
    <mn>2</mn>
   </msub>
   <msub>
    <mi>z</mi>
    <mn>3</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>ψ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>θ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>z</mi>
        <mn>1</mn>
       </msub>
       <msub>
        <mi>z</mi>
        <mn>2</mn>
       </msub>
       <msub>
        <mi>z</mi>
        <mn>3</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <cn type="integer">3</cn>
    </apply>
    <vector>
     <apply>
      <times></times>
      <ci>ϕ</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>ψ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>θ</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{A}x_{1}x_{2}y_{1}z_{1}z_{2}z_{3}(\phi(x_{1}x_{2}),\psi(y_{1}),\theta(z_{1}z%
_{2}z_{3}))
  </annotation>
 </semantics>
</math>

 is defined semantically as</p>

<p>

<math display="block" id="Lindström_quantifier:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>⊧</mo>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mi>A</mi>
     </msub>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>z</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>z</mi>
      <mn>2</mn>
     </msub>
     <msub>
      <mi>z</mi>
      <mn>3</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ϕ</mi>
      <mo>,</mo>
      <mi>ψ</mi>
      <mo>,</mo>
      <mi>θ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>a</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>ϕ</mi>
      <mrow>
       <mi>A</mi>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo>,</mo>
       <mover accent="true">
        <mi>a</mi>
        <mo stretchy="false">¯</mo>
       </mover>
      </mrow>
     </msup>
     <mo>,</mo>
     <msup>
      <mi>ψ</mi>
      <mrow>
       <mi>A</mi>
       <mo>,</mo>
       <msub>
        <mi>y</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mover accent="true">
        <mi>a</mi>
        <mo stretchy="false">¯</mo>
       </mover>
      </mrow>
     </msup>
     <mo>,</mo>
     <msup>
      <mi>θ</mi>
      <mrow>
       <mi>A</mi>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>z</mi>
         <mn>1</mn>
        </msub>
        <msub>
         <mi>z</mi>
         <mn>2</mn>
        </msub>
        <msub>
         <mi>z</mi>
         <mn>3</mn>
        </msub>
       </mrow>
       <mo>,</mo>
       <mover accent="true">
        <mi>a</mi>
        <mo stretchy="false">¯</mo>
       </mover>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <msub>
     <mi>Q</mi>
     <mi>A</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <apply>
     <csymbol cd="latexml">models</csymbol>
     <ci>A</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>A</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">3</cn>
      </apply>
      <vector>
       <ci>ϕ</ci>
       <ci>ψ</ci>
       <ci>θ</ci>
      </vector>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>a</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <vector>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ϕ</ci>
       <list>
        <ci>A</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <ci>normal-¯</ci>
         <ci>a</ci>
        </apply>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ψ</ci>
       <list>
        <ci>A</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <ci>normal-¯</ci>
         <ci>a</ci>
        </apply>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>θ</ci>
       <list>
        <ci>A</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <cn type="integer">3</cn>
         </apply>
        </apply>
        <apply>
         <ci>normal-¯</ci>
         <ci>a</ci>
        </apply>
       </list>
      </apply>
     </vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\models Q_{A}x_{1}x_{2}y_{1}z_{1}z_{2}z_{3}(\phi,\psi,\theta)[a]\iff(\phi^{A,%
x_{1}x_{2},\bar{a}},\psi^{A,y_{1},\bar{a}},\theta^{A,z_{1}z_{2}z_{3},\bar{a}})%
\in Q_{A}
  </annotation>
 </semantics>
</math>

 </p>

<p>where</p>

<p>

<math display="block" id="Lindström_quantifier:12">
 <semantics>
  <mrow>
   <msup>
    <mi>ϕ</mi>
    <mrow>
     <mi>A</mi>
     <mo>,</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">¯</mo>
     </mover>
     <mo>,</mo>
     <mover accent="true">
      <mi>a</mi>
      <mo stretchy="false">¯</mo>
     </mover>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <msup>
      <mi>A</mi>
      <mi>n</mi>
     </msup>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mi>A</mi>
     <mo>⊧</mo>
     <mrow>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mover accent="true">
        <mi>x</mi>
        <mo stretchy="false">¯</mo>
       </mover>
       <mo>,</mo>
       <mover accent="true">
        <mi>a</mi>
        <mo stretchy="false">¯</mo>
       </mover>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ϕ</ci>
     <list>
      <ci>A</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <ci>normal-¯</ci>
       <ci>a</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </vector>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">models</csymbol>
      <ci>A</ci>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <interval closure="closed">
        <apply>
         <ci>normal-¯</ci>
         <ci>x</ci>
        </apply>
        <apply>
         <ci>normal-¯</ci>
         <ci>a</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi^{A,\bar{x},\bar{a}}=\{(x_{1},\dots,x_{n})\in A^{n}\colon A\models\phi[%
\bar{x},\bar{a}]\}
  </annotation>
 </semantics>
</math>

</p>

<p>for an <em>n</em>-tuple 

<math display="inline" id="Lindström_quantifier:13">
 <semantics>
  <mover accent="true">
   <mi>x</mi>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{x}
  </annotation>
 </semantics>
</math>


 of variables.</p>

<p>Lindström quantifiers are classified according to the number structure of their parameters. For example 

<math display="inline" id="Lindström_quantifier:14">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mi>x</mi>
   <mi>y</mi>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>ψ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>x</ci>
    <ci>y</ci>
    <ci>ϕ</ci>
    <ci>x</ci>
    <ci>ψ</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Qxy\phi(x)\psi(y)
  </annotation>
 </semantics>
</math>

 is a type (1,1) quantifier, whereas 

<math display="inline" id="Lindström_quantifier:15">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mi>x</mi>
   <mi>y</mi>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>x</ci>
    <ci>y</ci>
    <ci>ϕ</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Qxy\phi(x,y)
  </annotation>
 </semantics>
</math>

 is a type (2) quantifier. An example of type (1,1) quantifier is <a href="Hartig's_quantifier" title="wikilink">Hartig's quantifier</a> testing equicardinality, i.e. the extension of {A, B ⊆ M: |A| = |B|}. An example of a type (4) quantifier is the <a href="Henkin_quantifier" title="wikilink">Henkin quantifier</a>.</p>
<h2 id="expressiveness-hierarchy">Expressiveness hierarchy</h2>

<p>The first result in this direction was obtained by Lindström (1966) who showed that a type (1,1) quantifier was not definable in terms of a type (1) quantifier. After Lauri Hella (1989) developed a general technique for proving the relative expressiveness of quantifiers, the resulting hierarchy turned out to be <a href="Lexicographical_order" title="wikilink">lexicographically ordered</a> by quantifier type:</p>
<dl>
<dd><dl>
<dd>(1) &lt; (1, 1) &lt; . . . &lt; (2) &lt; (2, 1) &lt; (2, 1, 1) &lt; . . . &lt; (2, 2) &lt; . . . (3) &lt; . . .
</dd>
</dl>
</dd>
</dl>

<p>For every type <em>t</em>, there is a quantifier of that type that is not definable in first-order logic extended with quantifiers that are of types less than <em>t</em>.</p>
<h2 id="as-precursors-to-lindströms-theorem">As precursors to Lindström's theorem</h2>

<p>Although Lindström had only partially developed the hierarchy of quantifiers which now bear his name, it was enough for him to observe that some nice properties of first-order logic are lost when it is extended with certain generalized quantifiers. For example, adding a "there exist finitely many" quantifier results in a loss of <a href="Compactness_theorem" title="wikilink">compactness</a>, whereas adding a "there exist uncountably many" quantifier to first-order logic results in a logic no longer satisfying the <a href="Löwenheim–Skolem_theorem" title="wikilink">Löwenheim–Skolem theorem</a>. In 1969 Lindström proved a much stronger result now known as <a href="Lindström's_theorem" title="wikilink">Lindström's theorem</a>, which intuitively states that first-order logic is the "strongest" logic having both properties.</p>
<h2 id="algorithmic-characterization">Algorithmic characterization</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>L. Hella. "Definability hierarchies of generalized quantifiers", <a href="Annals_of_Pure_and_Applied_Logic" title="wikilink">Annals of Pure and Applied Logic</a>, 43(3):235–271, 1989, .</li>
<li>L. Hella. "Logical hierarchies in PTIME". In Proceedings of the 7th <a href="IEEE_Symposium_on_Logic_in_Computer_Science" title="wikilink">IEEE Symposium on Logic in Computer Science</a>, 1992.</li>
<li>L. Hella, K. Luosto, and <a href="J._Vaananen" title="wikilink">J. Vaananen</a>. "The hierarchy theorem for generalized quantifiers". <em><a href="Journal_of_Symbolic_Logic" title="wikilink">Journal of Symbolic Logic</a></em>, 61(3):802–817, 1996.</li>
<li></li>
<li>

<p>.</p></li>
<li></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Jouko Väänanen (ed.), <em>Generalized Quantifiers and Computation. 9th European Summer School in Logic, Language, and Information. ESSLLI’97 Workshop. Aix-en-Provence, France, August 11–22, 1997. Revised Lectures</em>, Springer <a href="Lecture_Notes_in_Computer_Science" title="wikilink">Lecture Notes in Computer Science</a> 1754, ISBN 3-540-66993-0</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>Dag Westerståhl, 2011. '<a href="http://plato.stanford.edu/entries/generalized-quantifiers/">Generalized Quantifiers</a>'. <a href="Stanford_Encyclopedia_of_Philosophy" title="wikilink">Stanford Encyclopedia of Philosophy</a>.</li>
</ul>

<p>"</p>

<p><a href="Category:Finite_model_theory" title="wikilink">Category:Finite model theory</a> <a class="uri" href="Category:Quantification" title="wikilink">Category:Quantification</a></p>
</body>
</html>
