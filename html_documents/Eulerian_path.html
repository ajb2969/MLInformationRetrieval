<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="131">Eulerian path</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Eulerian path</h1>
<hr/>

<p>  In <a href="graph_theory" title="wikilink">graph theory</a>, a <strong>Eulerian trail</strong> (or <strong>Eulerian path</strong>) is a <a href="Trail_(graph_theory)" title="wikilink">trail</a> in a graph which visits every <a href="edge_(graph_theory)" title="wikilink">edge</a> exactly once. Similarly, an <strong>Eulerian circuit</strong> or <strong>Eulerian cycle</strong> is an Eulerian trail which starts and ends on the same <a href="vertex_(graph_theory)" title="wikilink">vertex</a>. They were first discussed by <a href="Leonhard_Euler" title="wikilink">Leonhard Euler</a> while solving the famous <a href="Seven_Bridges_of_Königsberg" title="wikilink">Seven Bridges of Königsberg</a> problem in 1736. Mathematically the problem can be stated like this:</p>
<dl>
<dd>Given the graph in the image, is it possible to construct a path (or a <a href="cycle_(graph_theory)" title="wikilink">cycle</a>, i.e. a path starting and ending on the same vertex) which visits each edge exactly once?
</dd>
</dl>

<p>Euler proved that a necessary condition for the existence of Eulerian circuits is that all vertices in the graph have an even <a href="degree_(graph_theory)" title="wikilink">degree</a>, and stated without proof that connected graphs with all vertices of even degree have an Eulerian circuit. The first complete proof of this latter claim was published posthumously in 1873 by <a href="Carl_Hierholzer" title="wikilink">Carl Hierholzer</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The term <strong>Eulerian graph</strong> has two common meanings in graph theory. One meaning is a graph with an Eulerian circuit, and the other is a graph with every vertex of even degree. These definitions coincide for connected graphs.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>For the existence of Eulerian trails it is necessary that zero or two vertices have an odd degree; this means the Königsberg graph is <em>not</em> Eulerian. If there are no vertices of odd degree, all Eulerian trails are circuits. If there are exactly two vertices of odd degree, all Eulerian trails start at one of them and end at the other. A graph that has an Eulerian trail but not an Eulerian circuit is called <strong>semi-Eulerian</strong>.</p>
<h2 id="definition">Definition</h2>

<p>An <strong>Eulerian trail</strong>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> or <strong>Euler walk</strong> in an <a href="undirected_graph" title="wikilink">undirected graph</a> is a walk that uses each edge exactly once. If such a walk exists, the graph is called <strong>traversable</strong> or <strong>semi-eulerian</strong>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>An <strong>Eulerian cycle</strong>,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> <strong>Eulerian circuit</strong> or <strong>Euler tour</strong> in an undirected graph is a <a href="cycle_(graph_theory)" title="wikilink">cycle</a> that uses each edge exactly once. If such a cycle exists, the graph is called <strong>Eulerian</strong> or <strong>unicursal</strong>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The term "Eulerian graph" is also sometimes used in a weaker sense to denote a graph where every vertex has even degree. For finite <a href="connected_graph" title="wikilink">connected graphs</a> the two definitions are equivalent, while a possibly unconnected graph is Eulerian in the weaker sense if and only if each connected component has an Eulerian cycle.</p>

<p>For <a href="directed_graph" title="wikilink">directed graphs</a>, "path" has to be replaced with <em><a href="directed_path_(graph_theory)" title="wikilink">directed path</a></em> and "cycle" with <em><a href="directed_cycle" title="wikilink">directed cycle</a></em>.</p>

<p>The definition and properties of Eulerian trails, cycles and graphs are valid for <a href="multigraph" title="wikilink">multigraphs</a> as well.</p>

<p>An <strong>Eulerian orientation</strong> of an undirected graph <em>G</em> is an assignment of a direction to each edge of <em>G</em> such that, at each vertex <em>v</em>, the indegree of <em>v</em> equals the outdegree of <em>v</em>. Such an orientation exists for any undirected graph in which every vertex has even degree, and may be found by constructing an Euler tour in each connected component of <em>G</em> and then orienting the edges according to the tour.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Every Eulerian orientation of a connected graph is a <a href="strong_orientation" title="wikilink">strong orientation</a>, an orientation that makes the resulting directed graph <a href="strongly_connected" title="wikilink">strongly connected</a>.</p>
<h2 id="properties">Properties</h2>
<ul>
<li>An undirected graph has an Eulerian cycle if and only if every vertex has even degree, and all of its vertices with nonzero degree belong to a single <a href="Connected_component_(graph_theory)" title="wikilink">connected component</a>.</li>
<li>An undirected graph can be decomposed into edge-disjoint <a href="cycle_(graph_theory)" title="wikilink">cycles</a> if and only if all of its vertices have even degree. So, a graph has an Eulerian cycle if and only if it can be decomposed into edge-disjoint cycles and its nonzero-degree vertices belong to a single connected component.</li>
<li>An undirected graph has an Eulerian trail if and only if at most two vertices have odd degree, and if all of its vertices with nonzero degree belong to a single connected component.</li>
<li>A directed graph has an Eulerian cycle if and only if every vertex has equal <a href="in_degree_(graph_theory)" title="wikilink">in degree</a> and <a href="out_degree_(graph_theory)" title="wikilink">out degree</a>, and all of its vertices with nonzero degree belong to a single <a href="strongly_connected_component" title="wikilink">strongly connected component</a>. Equivalently, a directed graph has an Eulerian cycle if and only if it can be decomposed into edge-disjoint <a href="cycle_(graph_theory)" title="wikilink">directed cycles</a> and all of its vertices with nonzero degree belong to a single strongly connected component.</li>
<li>A directed graph has an Eulerian trail if and only if at most one vertex has (<a href="out_degree_(graph_theory)" title="wikilink">out-degree</a>) − (<a href="in_degree_(graph_theory)" title="wikilink">in-degree</a>) = 1, at most one vertex has (in-degree) − (out-degree) = 1, every other vertex has equal in-degree and out-degree, and all of its vertices with nonzero degree belong to a single connected component of the underlying undirected graph.</li>
</ul>
<h2 id="constructing-eulerian-trails-and-circuits">Constructing Eulerian trails and circuits</h2>
<h3 id="fleurys-algorithm">Fleury's algorithm</h3>

<p><strong>Fleury's algorithm</strong> is an elegant but inefficient algorithm which dates to 1883.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Consider a graph known to have all edges in the same component and at most two vertices of odd degree. The algorithm starts at a vertex of odd degree, or, if the graph has none, it starts with an arbitrarily chosen vertex. At each step it chooses the next edge in the path to be one whose deletion would not disconnect the graph, unless there is no such edge, in which case it picks the remaining edge left at the current vertex. It then moves to the other endpoint of that vertex and deletes the chosen edge. At the end of the algorithm there are no edges left, and the sequence from which the edges were chosen forms an Eulerian cycle if the graph has no vertices of odd degree, or an Eulerian trail if there are exactly two vertices of odd degree.</p>

<p>While the <em>graph traversal</em> in Fleury's algorithm is linear in the number of edges, i.e. <em>O</em>(|<em>E</em>|), we also need to factor in the complexity of detecting <a href="Bridge_(graph_theory)" title="wikilink">bridges</a>. If we are to re-run <a href="Robert_Tarjan" title="wikilink">Tarjan</a>'s linear time bridge-finding algorithm after the removal of every edge, Fleury's algorithm will have a time complexity of <em>O</em>(|<em>E</em>|<sup>2</sup>). A dynamic bridge-finding algorithm of  allows this to be improved to 

<math display="inline" id="Eulerian_path:0">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>E</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mrow>
      <msup>
       <mi>log</mi>
       <mn>3</mn>
      </msup>
      <mrow>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>E</mi>
        <mo stretchy="false">|</mo>
       </mrow>
       <mrow>
        <mi>log</mi>
        <mrow>
         <mi>log</mi>
         <mrow>
          <mo stretchy="false">|</mo>
          <mi>E</mi>
          <mo stretchy="false">|</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <abs></abs>
      <ci>E</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <log></log>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <abs></abs>
        <ci>E</ci>
       </apply>
       <apply>
        <log></log>
        <apply>
         <log></log>
         <apply>
          <abs></abs>
          <ci>E</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(|E|\log^{3}|E|\log\log|E|)
  </annotation>
 </semantics>
</math>

 but this is still significantly slower than alternative algorithms.</p>
<h3 id="hierholzers-algorithm">Hierholzer's algorithm</h3>

<p><a href="Carl_Hierholzer" title="wikilink">Hierholzer</a>'s 1873 paper provides a different method for finding Euler cycles that is more efficient than Fleury's algorithm:</p>
<ul>
<li>Choose any starting vertex <em>v</em>, and follow a trail of edges from that vertex until returning to <em>v</em>. It is not possible to get stuck at any vertex other than <em>v</em>, because the even degree of all vertices ensures that, when the trail enters another vertex <em>w</em> there must be an unused edge leaving <em>w</em>. The tour formed in this way is a closed tour, but may not cover all the vertices and edges of the initial graph.</li>
<li>As long as there exists a vertex <em>u</em> that belongs to the current tour but that has adjacent edges not part of the tour, start another trail from <em>u</em>, following unused edges until returning to <em>u</em>, and join the tour formed in this way to the previous tour.</li>
</ul>

<p>By using a data structure such as a <a href="doubly_linked_list" title="wikilink">doubly linked list</a> to maintain the set of unused edges incident to each vertex, to maintain the list of vertices on the current tour that have unused edges, and to maintain the tour itself, the individual operations of the algorithm (finding unused edges exiting each vertex, finding a new starting vertex for a tour, and connecting two tours that share a vertex) may be performed in constant time each, so the overall algorithm takes <a href="linear_time" title="wikilink">linear time</a>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="counting-eulerian-circuits">Counting Eulerian circuits</h2>
<h3 id="complexity-issues">Complexity issues</h3>

<p>The number of Eulerian circuits in <em><a href="Directed_graph" title="wikilink">digraphs</a></em> can be calculated using the so-called <strong><a href="BEST_theorem" title="wikilink">BEST theorem</a></strong>, named after <a href="N._G._de_Bruijn" title="wikilink">de <strong>B</strong>ruijn</a>, <a href="Tatyana_Pavlovna_Ehrenfest" title="wikilink">van Aardenne-<strong>E</strong>hrenfest</a>, <a href="Cedric_Smith_(statistician)" title="wikilink"><strong>S</strong>mith</a> and <a href="W._T._Tutte" title="wikilink"><strong>T</strong>utte</a>. The formula states that the number of Eulerian circuits in a digraph is the product of certain degree factorials and the number of rooted <a href="Arborescence_(graph_theory)" title="wikilink">arborescences</a>. The latter can be computed as a <a class="uri" href="determinant" title="wikilink">determinant</a>, by the <a href="matrix_tree_theorem" title="wikilink">matrix tree theorem</a>, giving a polynomial time algorithm.</p>

<p>BEST theorem is first stated in this form in a "note added in proof" to the Aardenne-Ehrenfest and de Bruijn paper (1951). The original proof was <a href="bijective_proof" title="wikilink">bijective</a> and generalized the <a href="de_Bruijn_sequence" title="wikilink">de Bruijn sequences</a>. It is a variation on an earlier result by Smith and Tutte (1941).</p>

<p>Counting the number of Eulerian circuits on <em>undirected</em> graphs is much more difficult. This problem is known to be <a href="Sharp-P" title="wikilink">#P</a>-complete.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> In a positive direction, a <a href="Markov_chain_Monte_Carlo" title="wikilink">Markov chain Monte Carlo</a> approach, via the <em>Kotzig transformations</em> (introduced by <a href="Anton_Kotzig" title="wikilink">Anton Kotzig</a> in 1968) is believed to give a sharp approximation for the number of Eulerian circuits in a graph, though as yet there is no proof of this fact (even for graphs of bounded degree).</p>
<h3 id="special-cases">Special cases</h3>

<p>The <a href="Asymptotic_analysis" title="wikilink">asymptotic formula</a> for the number of Eulerian circuits in the <a href="complete_graph" title="wikilink">complete graphs</a> was determined by <a href="Brendan_McKay" title="wikilink">McKay</a> and Robinson (1995):<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>

<math display="block" id="Eulerian_path:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>e</mi>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>K</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <msup>
      <mi>π</mi>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <msup>
      <mi>e</mi>
      <mrow>
       <mrow>
        <mo>-</mo>
        <mrow>
         <msup>
          <mi>n</mi>
          <mn>2</mn>
         </msup>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mn>11</mn>
        <mo>/</mo>
        <mn>12</mn>
       </mrow>
      </mrow>
     </msup>
     <msup>
      <mi>n</mi>
      <mrow>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mn>2</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <mrow>
      <mo maxsize="120%" minsize="120%">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mrow>
        <mi>O</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msup>
          <mi>n</mi>
          <mrow>
           <mrow>
            <mo>-</mo>
            <mrow>
             <mn>1</mn>
             <mo>/</mo>
             <mn>2</mn>
            </mrow>
           </mrow>
           <mo>+</mo>
           <mi>ϵ</mi>
          </mrow>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo maxsize="120%" minsize="120%">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>c</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>π</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>n</ci>
          <cn type="integer">2</cn>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">11</cn>
        <cn type="integer">12</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>O</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <apply>
         <plus></plus>
         <apply>
          <minus></minus>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <cn type="integer">2</cn>
          </apply>
         </apply>
         <ci>ϵ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ec(K_{n})=2^{(n+1)/2}\pi^{1/2}e^{-n^{2}/2+11/12}n^{(n-2)(n+1)/2}\bigl(1+O(n^{-%
1/2+\epsilon})\bigr).
  </annotation>
 </semantics>
</math>

</p>

<p>A similar formula was later obtained by M.I. Isaev (2009) for <a href="complete_bipartite_graph" title="wikilink">complete bipartite graphs</a>:<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>

<math display="block" id="Eulerian_path:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>e</mi>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>K</mi>
       <mrow>
        <mi>n</mi>
        <mo>,</mo>
        <mi>n</mi>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mi>n</mi>
          <mo>/</mo>
          <mn>2</mn>
         </mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
      <mrow>
       <mn>2</mn>
       <mi>n</mi>
      </mrow>
     </msup>
     <msup>
      <mn>2</mn>
      <mrow>
       <mrow>
        <msup>
         <mi>n</mi>
         <mn>2</mn>
        </msup>
        <mo>-</mo>
        <mi>n</mi>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
     </msup>
     <msup>
      <mi>π</mi>
      <mrow>
       <mrow>
        <mo>-</mo>
        <mi>n</mi>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
     </msup>
     <msup>
      <mi>n</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo maxsize="120%" minsize="120%">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mrow>
        <mi>O</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msup>
          <mi>n</mi>
          <mrow>
           <mrow>
            <mo>-</mo>
            <mrow>
             <mn>1</mn>
             <mo>/</mo>
             <mn>2</mn>
            </mrow>
           </mrow>
           <mo>+</mo>
           <mi>ϵ</mi>
          </mrow>
         </msup>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo maxsize="120%" minsize="120%">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>c</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <list>
       <ci>n</ci>
       <ci>n</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <factorial></factorial>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>π</ci>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <ci>n</ci>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>O</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <apply>
         <plus></plus>
         <apply>
          <minus></minus>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <cn type="integer">2</cn>
          </apply>
         </apply>
         <ci>ϵ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ec(K_{n,n})=(n/2-1)!^{2n}2^{n^{2}-n+1/2}\pi^{-n+1/2}n^{n-1}\bigl(1+O(n^{-1/2+%
\epsilon})\bigr).
  </annotation>
 </semantics>
</math>

</p>
<h2 id="applications">Applications</h2>

<p>Eulerian trails are used in <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a> to reconstruct the <a href="DNA_sequence" title="wikilink">DNA sequence</a> from its fragments.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> They are also used in <a class="uri" href="CMOS" title="wikilink">CMOS</a> circuit design to find an optimal <a href="logic_gate" title="wikilink">logic gate</a> ordering.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Eulerian_matroid" title="wikilink">Eulerian matroid</a>, an abstract generalization of Eulerian graphs</li>
<li><a href="Five_room_puzzle" title="wikilink">Five room puzzle</a></li>
<li><a href="Handshaking_lemma" title="wikilink">Handshaking lemma</a>, proven by Euler in his original paper, showing that any undirected connected graph has an even number of odd-degree vertices</li>
<li><a href="Hamiltonian_path" title="wikilink">Hamiltonian path</a> – a path that visits each <em>vertex</em> exactly once.</li>
<li><a href="Route_inspection_problem" title="wikilink">Route inspection problem</a>, search for the shortest path that visits all edges, possibly repeating edges if an Eulerian path does not exist.</li>
<li><a href="Veblen's_theorem" title="wikilink">Veblen's theorem</a>, that graphs with even vertex degree can be partitioned into edge-disjoint cycles regardless of their connectivity</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>Euler, L., "<a href="http://www.math.dartmouth.edu/~euler/pages/E053.html">Solutio problematis ad geometriam situs pertinentis</a>", <em>Comment. Academiae Sci. I. Petropolitanae</em> <strong>8</strong> (1736), 128–140.</li>
<li>

<p>.</p></li>
<li>Lucas, E., <em>Récréations Mathématiques IV</em>, Paris, 1921.</li>
<li>Fleury, "Deux problemes de geometrie de situation", <em>Journal de mathematiques elementaires</em> (1883), 257–261.</li>
<li><a href="Tatyana_Pavlovna_Ehrenfest" title="wikilink">T. van Aardenne-Ehrenfest</a> and <a href="Nicolaas_Govert_de_Bruijn" title="wikilink">N. G. de Bruijn</a> (1951) "Circuits and trees in oriented linear graphs", <a href="Simon_Stevin_(journal)" title="wikilink">Simon Stevin</a> 28: 203–217.</li>
<li></li>
<li><a href="W._T._Tutte" title="wikilink">W. T. Tutte</a> and <a href="Cedric_Smith_(statistician)" title="wikilink">C. A. B. Smith</a> (1941) "On Unicursal Paths in a Network of Degree 4", <a href="American_Mathematical_Monthly" title="wikilink">American Mathematical Monthly</a> 48: 233–237.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>[<a class="uri" href="http://mathforum.org/kb/message.jspa?messageID=3648262&amp;tstart">http://mathforum.org/kb/message.jspa?messageID=3648262&amp;tstart;</a>;=135 Discussion of early mentions of Fleury's algorithm].</li>
<li><a href="http://www.encyclopediaofmath.org/index.php/Euler_tour"><em>Euler tour</em></a> at <a href="Encyclopedia_of_Mathematics" title="wikilink">Encyclopedia of Mathematics</a>.</li>
</ul>

<p>"</p>

<p><a href="Category:Graph_theory_objects" title="wikilink">Category:Graph theory objects</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">N. L. Biggs, E. K. Lloyd and R. J. Wilson, Graph Theory 1736–1936, Clarendon Press, Oxford, 1976, 8–9, ISBN 0-19-853901-0.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">Some people reserve the terms <em>path</em> and <em>cycle</em> to mean <em>non-self-intersecting</em> path and cycle. A (potentially) self-intersecting path is known as a <strong>trail</strong> or an <strong>open walk</strong>; and a (potentially) self-intersecting cycle, a <strong>circuit</strong> or a <strong>closed walk</strong>. This ambiguity can be avoided by using the terms Eulerian trail and Eulerian circuit when self-intersection is allowed.<a href="#fnref3">↩</a></li>
<li id="fn4">Jun-ichi Yamaguchi, <a href="http://jwilson.coe.uga.edu/EMAT6680/Yamaguchi/emat6690/essay1/GT.html">Introduction of Graph Theory</a>.<a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">Schaum's outline of theory and problems of graph theory By V. K. Balakrishnan [<a class="uri" href="http://books.google.co.uk/books?id=1NTPbSehvWsC&amp;lpg">http://books.google.co.uk/books?id=1NTPbSehvWsC&amp;lpg;</a>;=PA60&amp;dq;=unicursal&amp;pg;=PA60#v=onepage&amp;q;=unicursal&amp;f;=false].<a href="#fnref6">↩</a></li>
<li id="fn7">.<a href="#fnref7">↩</a></li>
<li id="fn8">.<a href="#fnref8">↩</a></li>
<li id="fn9">.<a href="#fnref9">↩</a></li>
<li id="fn10">Brightwell and <a href="Peter_Winkler" title="wikilink">Winkler</a>, "<a href="http://www.cdam.lse.ac.uk/Reports/Files/cdam-2004-12.pdf">Note on Counting Eulerian Circuits</a>", 2004.<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="Brendan_McKay" title="wikilink">Brendan McKay</a> and Robert W. Robinson, <a href="http://cs.anu.edu.au/~bdm/papers/euler.pdf">Asymptotic enumeration of eulerian circuits in the complete graph</a>, <em><a class="uri" href="Combinatorica" title="wikilink">Combinatorica</a></em>, 10 (1995), no. 4, 367–377.<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
</ol>
</section>
</body>
</html>
