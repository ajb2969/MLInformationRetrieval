<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="618">Turing degree</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Turing degree</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a> and <a href="mathematical_logic" title="wikilink">mathematical logic</a> the <strong>Turing degree</strong> (named after <a href="Alan_Turing" title="wikilink">Alan Turing</a>) or <strong>degree of unsolvability</strong> of a set of natural numbers measures the level of algorithmic unsolvability of the set. The concept of Turing degree is fundamental in <a href="recursion_theory" title="wikilink">computability theory</a>, where sets of natural numbers are often regarded as <a href="decision_problem" title="wikilink">decision problems</a>. The Turing degree of a set tells how difficult it is to solve the decision problem associated with the set, that is, to determine whether an arbitrary number is in the given set.</p>

<p>Two sets are <strong>Turing equivalent</strong> if they have the same level of unsolvability; each Turing degree is a collection of Turing equivalent sets, so that two sets are in different Turing degrees exactly when they are not Turing equivalent. Furthermore, the Turing degrees are <a href="partial_order" title="wikilink">partially ordered</a> so that if the Turing degree of a set <em>X</em> is less than the Turing degree of a set <em>Y</em> then any (noncomputable) procedure that correctly decides whether numbers are in <em>Y</em> can be effectively converted to a procedure that correctly decides whether numbers are in <em>X</em>. It is in this sense that the Turing degree of a set corresponds to its level of algorithmic unsolvability.</p>

<p>The Turing degrees were introduced by <a href="Emil_Leon_Post" title="wikilink">Emil Leon Post</a> (1944), and many fundamental results were established by <a href="Stephen_Cole_Kleene" title="wikilink">Stephen Cole Kleene</a> and Post (1954). The Turing degrees have been an area of intense research since then. Many proofs in the area make use of a proof technique known as the <strong>priority method</strong>.</p>
<h2 id="turing-equivalence">Turing equivalence</h2>

<p>For the rest of this article, the word <em>set</em> will refer to a set of natural numbers. A set <em>X</em> is said to be <strong><a href="Turing_reducible" title="wikilink">Turing reducible</a></strong> to a set <em>Y</em> if there is an <a href="oracle_Turing_machine" title="wikilink">oracle Turing machine</a> that decides membership in <em>X</em> when given an oracle for membership in <em>Y</em>. The notation <em>X</em> ‚â§<sub>T</sub> <em>Y</em> indicates that <em>X</em> is Turing reducible to <em>Y</em>.</p>

<p>Two sets <em>X</em> and <em>Y</em> are defined to be <strong>Turing equivalent</strong> if <em>X</em> is Turing reducible to <em>Y</em> and <em>Y</em> is Turing reducible to <em>X</em>. The notation <em>X</em> ‚â°<sub>T</sub> <em>Y</em> indicates that <em>X</em> and <em>Y</em> are Turing equivalent. The relation ‚â°<sub>T</sub> can be seen to be an <a href="equivalence_relation" title="wikilink">equivalence relation</a>, which means that for all sets <em>X</em>, <em>Y</em>, and <em>Z</em>:</p>
<ul>
<li><em>X</em> ‚â°<sub>T</sub> <em>X</em></li>
<li><em>X</em> ‚â°<sub>T</sub> <em>Y</em> implies <em>Y</em> ‚â°<sub>T</sub> <em>X</em></li>
<li>If <em>X</em> ‚â°<sub>T</sub> <em>Y</em> and <em>Y</em> ‚â°<sub>T</sub> <em>Z</em> then <em>X</em> ‚â°<sub>T</sub> <em>Z</em>.</li>
</ul>

<p>A <strong>Turing degree</strong> is an <a href="equivalence_class" title="wikilink">equivalence class</a> of the relation ‚â°<sub>T</sub>. The notation [<em>X</em>] denotes the equivalence class containing a set <em>X</em>. The entire collection of Turing degrees is denoted 

<math display="inline" id="Turing_degree:0">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíü</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíü</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{D}
  </annotation>
 </semantics>
</math>

.</p>

<p>The Turing degrees have a <a href="partial_order" title="wikilink">partial order</a> ‚â§ defined so that [<em>X</em>] ‚â§ [<em>Y</em>] if and only if <em>X</em> ‚â§<sub>T</sub> <em>Y</em>. There is a unique Turing degree containing all the computable sets, and this degree is less than every other degree. It is denoted <strong>0</strong> (zero) because it is the least element of the poset 

<math display="inline" id="Turing_degree:1">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíü</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíü</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{D}
  </annotation>
 </semantics>
</math>

. (It is common to use boldface notation for Turing degrees, in order to distinguish them from sets. When no confusion can occur, such as with [<em>X</em>], the boldface is not necessary.)</p>

<p>For any sets <em>X</em> and <em>Y</em>, X <strong>join</strong> Y, written <em>X ‚äï Y</em>, is defined to be the union of the sets } and }. The Turing degree of <em>X ‚äï Y</em> is the <a href="Join_(mathematics)" title="wikilink">least upper bound</a> of the degrees of <em>X</em> and <em>Y</em>. Thus 

<math display="inline" id="Turing_degree:2">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíü</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíü</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{D}
  </annotation>
 </semantics>
</math>

 is a <a class="uri" href="join-semilattice" title="wikilink">join-semilattice</a>. The least upper bound of degrees <strong>a</strong> and <strong>b</strong> is denoted <strong>a</strong> ‚à™ <strong>b</strong>. It is known that 

<math display="inline" id="Turing_degree:3">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíü</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíü</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{D}
  </annotation>
 </semantics>
</math>

 is not a lattice, as there are pairs of degrees with no greatest lower bound.</p>

<p>For any set <em>X</em> the notation <em>X</em>‚Ä≤ denotes the set of indices of oracle machines that halt when using <em>X</em> as an oracle. The set <em>X</em>‚Ä≤ is called the <strong><a href="Turing_jump" title="wikilink">Turing jump</a></strong> of <em>X</em>. The Turing jump of a degree [<em>X</em>] is defined to be the degree [<em>X</em>‚Ä≤]; this is a valid definition because <em>X</em>‚Ä≤ ‚â°<sub>T</sub> <em>Y</em>‚Ä≤ whenever <em>X</em> ‚â°<sub>T</sub> <em>Y</em>. A key example is <strong>0</strong>‚Ä≤, the degree of the <a href="halting_problem" title="wikilink">halting problem</a>.</p>
<h2 id="basic-properties-of-the-turing-degrees">Basic properties of the Turing degrees</h2>
<ul>
<li>Every Turing degree is <a href="countably_infinite" title="wikilink">countably infinite</a>, that is, it contains exactly 

<math display="inline" id="Turing_degree:4">
 <semantics>
  <msub>
   <mi mathvariant="normal">‚Ñµ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-‚Ñµ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \aleph_{0}
  </annotation>
 </semantics>
</math>

 sets.</li>
</ul>
<ul>
<li>There are 

<math display="inline" id="Turing_degree:5">
 <semantics>
  <msup>
   <mn>2</mn>
   <msub>
    <mi mathvariant="normal">‚Ñµ</mi>
    <mn>0</mn>
   </msub>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-‚Ñµ</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{\aleph_{0}}
  </annotation>
 </semantics>
</math>

 distinct Turing degrees.</li>
</ul>
<ul>
<li>For each degree <strong>a</strong> the strict inequality <strong>a</strong> &lt; <strong>a</strong>‚Ä≤ holds.</li>
</ul>
<ul>
<li>For each degree <strong>a</strong>, the set of degrees below <strong>a</strong> is <a href="Countable_set" title="wikilink">at most countable</a>. The set of degrees greater than <strong>a</strong> has size 

<math display="inline" id="Turing_degree:6">
 <semantics>
  <msup>
   <mn>2</mn>
   <msub>
    <mi mathvariant="normal">‚Ñµ</mi>
    <mn>0</mn>
   </msub>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-‚Ñµ</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{\aleph_{0}}
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<h2 id="structure-of-the-turing-degrees">Structure of the Turing degrees</h2>

<p>A great deal of research has been conducted into the structure of the Turing degrees. The following survey lists only some of the many known results. One general conclusion that can be drawn from the research is that the structure of the Turing degrees is extremely complicated.</p>
<h3 id="order-properties">Order properties</h3>
<ul>
<li>There are <strong>minimal degrees</strong>. A degree <strong>a</strong> is <em>minimal</em> if <strong>a</strong> is nonzero and there is no degree between <strong>0</strong> and <strong>a</strong>. Thus the order relation on the degrees is not a <a href="dense_order" title="wikilink">dense order</a>.</li>
</ul>
<ul>
<li>For every nonzero degree <strong>a</strong> there is a degree <strong>b</strong> incomparable with <strong>a</strong>.</li>
</ul>
<ul>
<li>There is a set of 

<math display="inline" id="Turing_degree:7">
 <semantics>
  <msup>
   <mn>2</mn>
   <msub>
    <mi mathvariant="normal">‚Ñµ</mi>
    <mn>0</mn>
   </msub>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-‚Ñµ</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{\aleph_{0}}
  </annotation>
 </semantics>
</math>

 pairwise incomparable Turing degrees.</li>
</ul>
<ul>
<li>There are pairs of degrees with no greatest lower bound. Thus 

<math display="inline" id="Turing_degree:8">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíü</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíü</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{D}
  </annotation>
 </semantics>
</math>

 is not a lattice.</li>
</ul>
<ul>
<li>Every countable partially ordered set can be embedded in the Turing degrees.</li>
</ul>
<ul>
<li>No infinite, strictly increasing sequence of degrees has a least upper bound.</li>
</ul>
<h3 id="properties-involving-the-jump">Properties involving the jump</h3>
<ul>
<li>For every degree <strong>a</strong> there is a degree strictly between <strong>a</strong> and <strong>a‚Ä≤</strong>. In fact, there is a countable sequence of pairwise incomparable degrees between <strong>a</strong> and <strong>a‚Ä≤</strong>.</li>
</ul>
<ul>
<li>A degree <strong>a</strong> is of the form <strong>b‚Ä≤</strong> if and only if <strong>0‚Ä≤</strong> ‚â§ <strong>a</strong>.</li>
</ul>
<ul>
<li>For any degree <strong>a</strong> there is a degree <strong>b</strong> such that <strong>a</strong> &lt; <strong>b</strong> and <strong>b‚Ä≤</strong> = <strong>a‚Ä≤</strong>; such a degree <strong>b</strong> is called <em>low</em> relative to <strong>a</strong>.</li>
</ul>
<ul>
<li>There is an infinite sequence <strong>a</strong><sub>i</sub> of degrees such that <strong>a</strong>‚Ä≤<sub>i+1</sub> ‚â§ <strong>a</strong><sub>i</sub> for each <em>i</em>.</li>
</ul>
<h3 id="logical-properties">Logical properties</h3>
<ul>
<li>Simpson (1977) showed that the first-order theory of 

<math display="inline" id="Turing_degree:9">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíü</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíü</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{D}
  </annotation>
 </semantics>
</math>

 in the language  or  is <a href="Many-one_reduction" title="wikilink">many-one equivalent</a> to the theory of true second-order arithmetic. This indicates that the structure of 

<math display="inline" id="Turing_degree:10">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíü</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíü</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{D}
  </annotation>
 </semantics>
</math>

 is extremely complicated.</li>
</ul>
<ul>
<li>Shore and Slaman (1999) showed that the jump operator is definable in the first-order structure of the degrees with the language ‚å© ‚â§, =‚å™.</li>
</ul>
<h2 id="structure-of-the-r.e.-turing-degrees">Structure of the r.e. Turing degrees</h2>

<p>A degree is called r.e. (recursively enumerable) if it contains a <a href="recursively_enumerable_set" title="wikilink">recursively enumerable set</a>. Every r.e. degree is less than or equal to <strong>0‚Ä≤</strong> but not every degree less than <strong>0‚Ä≤</strong> is an r.e. degree.</p>
<ul>
<li>(<a href="Gerald_Sacks" title="wikilink">G. E. Sacks</a>, 1964) The r.e degrees are dense; between any two r.e. degrees there is a third r.e degree.</li>
</ul>
<ul>
<li>(A. H. Lachlan, 1966a and C. E. M. Yates, 1966) There are two r.e. degrees with no greatest lower bound in the r.e. degrees.</li>
</ul>
<ul>
<li>(A. H. Lachlan, 1966a and C. E. M. Yates, 1966) There is a pair of nonzero r.e. degrees whose greatest lower bound is <strong>0</strong>.</li>
</ul>
<ul>
<li>(S. K. Thomason, 1971) Every finite distributive lattice can be embedded into the r.e. degrees. In fact, the countable atomless Boolean algebra can be embedded in a manner that preserves suprema and infima.</li>
</ul>
<ul>
<li>(A. H. Lachlan and <a href="Robert_I._Soare" title="wikilink">R. I. Soare</a>, 1980) Not all finite lattices can be embedded in the r.e. degrees (via an embedding that preserves suprema and infima). The following particular lattice cannot be embedded in the r.e. degrees:</li>
</ul>
<dl>
<dd><dl>
<dd>
</dd>
</dl>
</dd>
</dl>
<ul>
<li>(A. H. Lachlan, 1966b) There is no pair of r.e. degrees whose greatest lower bound is <strong>0</strong> and whose least upper bound is <strong>0‚Ä≤</strong>. This result is informally called the <em>nondiamond theorem</em>.</li>
</ul>
<ul>
<li>(<a href="Leo_Harrington" title="wikilink">L. A. Harrington</a> and <a href="Theodore_Slaman" title="wikilink">T. A. Slaman</a>, see Nies, Shore, and Slaman (1998)) The first-order theory of the r.e. degrees in the language ‚å© <strong>0</strong>, ‚â§, = ‚å™ is many-one equivalent to the theory of true first order arithmetic.</li>
</ul>
<h2 id="posts-problem-and-the-priority-method">Post's problem and the priority method</h2>

<p><a href="Emil_Post" title="wikilink">Emil Post</a> studied the r.e. Turing degrees and asked whether there is any r.e. degree strictly between <strong>0</strong> and <strong>0‚Ä≤</strong>. The problem of constructing such a degree (or showing that none exist) became known as <strong>Post's problem</strong>. This problem was solved independently by Friedberg and <a class="uri" href="Muchnik" title="wikilink">Muchnik</a> in the 1950s, who showed that these intermediate r.e. degrees do exist. Their proofs each developed the same new method for constructing r.e. degrees which came to be known as the <strong>priority method</strong>. The priority method is now the main technique for establishing results about r.e. sets.</p>

<p>The idea of the priority method for constructing an r.e. set <em>X</em> is to list a countable sequence of <em>requirements</em> that <em>X</em> must satisfy. For example, to construct an r.e. set <em>X</em> between <strong>0</strong> and <strong>0‚Ä≤</strong> it is enough to satisfy the requirements <em>A<sub>e</sub></em> and <em>B<sub>e</sub></em> for each natural number <em>e</em>, where <em>A<sub>e</sub></em> requires that the oracle machine with index <em>e</em> does not compute 0‚Ä≤ from <em>X</em> and <em>B<sub>e</sub></em> requires that the Turing machine with index <em>e</em> (and no oracle) does not compute <em>X</em>. These requirements are put into a <em>priority ordering</em>, which is an explicit bijection of the requirements and the natural numbers. The proof proceeds inductively with one stage for each natural number; these stages can be thought of as steps of time during which the set <em>X</em> is enumerated. At each stage, numbers may be put into <em>X</em> or forever prevented from entering <em>X</em> in an attempt to <em>satisfy</em> requirements (that is, force them to hold once all of <em>X</em> has been enumerated). Sometimes, a number can be enumerated into <em>X</em> to satisfy one requirement but doing this would cause a previously satisfied requirement to become unsatisfied (that is, to be <em>injured</em>). The priority order on requirements is used to determine which requirement to satisfy in this case. The informal idea is that if a requirement is injured then it will eventually stop being injured after all higher priority requirements have stopped being injured, although not every priority argument has this property. An argument must be made that the overall set <em>X</em> is r.e. and satisfies all the requirements. Priority arguments can be used to prove many facts about r.e. sets; the requirements used and the manner in which they are satisfied must be carefully chosen to produce the required result.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Martin_measure" title="wikilink">Martin measure</a></li>
</ul>
<h2 id="references">References</h2>
<h3 id="monographs-undergraduate-level">Monographs (undergraduate level)</h3>
<ul>
<li>Cooper, S.B. <em>Computability theory</em>. Chapman &amp; Hall/CRC, Boca Raton, FL, 2004. ISBN 1-58488-237-9</li>
</ul>
<ul>
<li>Cutland, N. <em>Computability.</em> Cambridge University Press, Cambridge-New York, 1980. ISBN 0-521-22384-9; ISBN 0-521-29465-7</li>
</ul>
<h3 id="monographs-and-survey-articles-graduate-level">Monographs and survey articles (graduate level)</h3>
<ul>
<li>Ambos-Spies, K. and Fejer, P. Degrees of Unsolvability. Unpublished. <a class="uri" href="http://www.cs.umb.edu/~fejer/articles/History_of_Degrees.pdf">http://www.cs.umb.edu/~fejer/articles/History_of_Degrees.pdf</a></li>
</ul>
<ul>
<li>Lerman, M. <em>Degrees of unsolvability.</em> Perspectives in Mathematical Logic. Springer-Verlag, Berlin, 1983. ISBN 3-540-12155-2</li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li>Rogers, H. <em>The Theory of Recursive Functions and Effective Computability</em>, MIT Press. ISBN 0-262-68052-1; ISBN 0-07-053522-1</li>
</ul>
<ul>
<li>Sacks, Gerald E. <em>Degrees of Unsolvability</em> (Annals of Mathematics Studies), Princeton University Press. ISBN 978-0691079417</li>
</ul>
<ul>
<li>Simpson, S. Degrees of unsolvability: a survey of results. <em>Handbook of Mathematical Logic</em>, North-Holland, 1977, pp.¬†631‚Äì652.</li>
</ul>
<ul>
<li>Shoenfield, Joseph R. <em>Degrees of Unsolvability</em>, North-Holland/Elsevier, ISBN 978-0720420616.</li>
</ul>
<ul>
<li>Shore, R. The theories of the T, tt, and wtt r.e. degrees: undecidability and beyond. Proceedings of the IX Latin American Symposium on Mathematical Logic, Part 1 (Bah√≠a Blanca, 1992), 61‚Äì70, Notas L√≥gica Mat., 38, Univ. Nac. del Sur, Bah√≠a Blanca, 1993.</li>
</ul>
<ul>
<li>Soare, R. <em>Recursively enumerable sets and degrees.</em> Perspectives in Mathematical Logic. Springer-Verlag, Berlin, 1987. ISBN 3-540-15299-7</li>
</ul>
<ul>
<li>Soare, Robert I. Recursively enumerable sets and degrees. <em>Bull. Amer. Math. Soc.</em> 84 (1978), no. 6, 1149‚Äì1181. </li>
</ul>
<h3 id="research-papers">Research papers</h3>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a> <a href="Category:Theory_of_computation" title="wikilink">Category:Theory of computation</a></p>
</body>
</html>
