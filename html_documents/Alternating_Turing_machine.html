<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="576">Alternating Turing machine</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Alternating Turing machine</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, an <strong>alternating Turing machine</strong> (<strong>ATM</strong>) is a <a href="non-deterministic_Turing_machine" title="wikilink">non-deterministic Turing machine</a> (<strong>NTM</strong>) with a rule for accepting computations that generalizes the rules used in the definition of the <a href="complexity_class" title="wikilink">complexity classes</a> <a href="NP_(complexity)" title="wikilink">NP</a> and <a class="uri" href="co-NP" title="wikilink">co-NP</a>. The concept of an ATM was set forth by <a href="Ashok_K._Chandra" title="wikilink">Chandra</a> and <a href="Larry_Stockmeyer" title="wikilink">Stockmeyer</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and independently by <a href="Dexter_Kozen" title="wikilink">Kozen</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> in 1976, with a joint journal publication in 1981.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="definitions">Definitions</h2>
<h3 id="informal-description">Informal description</h3>

<p>The definition of NP uses the <em>existential mode</em> of computation: if <em>any</em> choice leads to an accepting state, then the whole computation accepts. The definition of co-NP uses the <em>universal mode</em> of computation: only if <em>all</em> choices lead to an accepting state, then the whole computation accepts. An alternating Turing machine (or to be more precise, the definition of acceptance for such a machine) alternates between these modes.</p>

<p>An <strong>alternating Turing machine</strong> is a <a href="non-deterministic_Turing_machine" title="wikilink">non-deterministic Turing machine</a> whose states are divided into two sets: <strong>existential states</strong> and <strong>universal states</strong>. An existential state is accepting if some transition leads to an accepting state; a universal state is accepting if every transition leads to an accepting state. (Thus a universal state with no transitions accepts unconditionally; an existential state with no transitions rejects unconditionally). The machine as a whole accepts if the initial state is accepting.</p>
<h3 id="formal-definition">Formal definition</h3>

<p>Formally, a (one-tape) <strong>alternating Turing machine</strong> is a 5-<a class="uri" href="tuple" title="wikilink">tuple</a> 

<math display="inline" id="Alternating_Turing_machine:0">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Q</mi>
    <mo>,</mo>
    <mi mathvariant="normal">Œì</mi>
    <mo>,</mo>
    <mi>Œ¥</mi>
    <mo>,</mo>
    <msub>
     <mi>q</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <mi>g</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <vector>
     <ci>Q</ci>
     <ci>normal-Œì</ci>
     <ci>Œ¥</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>g</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=(Q,\Gamma,\delta,q_{0},g)
  </annotation>
 </semantics>
</math>

 where</p>
<ul>
<li>

<math display="inline" id="Alternating_Turing_machine:1">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is the finite set of states</li>
<li>

<math display="inline" id="Alternating_Turing_machine:2">
 <semantics>
  <mi mathvariant="normal">Œì</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Œì</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

 is the finite tape alphabet</li>
<li>

<math display="inline" id="Alternating_Turing_machine:3">
 <semantics>
  <mrow>
   <mi>Œ¥</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mo>√ó</mo>
     <mi mathvariant="normal">Œì</mi>
    </mrow>
    <mo>‚Üí</mo>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">ùí´</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>Q</mi>
       <mo>√ó</mo>
       <mi mathvariant="normal">Œì</mi>
       <mo>√ó</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mi>L</mi>
        <mo>,</mo>
        <mi>R</mi>
        <mo stretchy="false">}</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>Œ¥</ci>
    <apply>
     <ci>normal-‚Üí</ci>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>normal-Œì</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ùí´</ci>
      <apply>
       <times></times>
       <ci>Q</ci>
       <ci>normal-Œì</ci>
       <set>
        <ci>L</ci>
        <ci>R</ci>
       </set>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta:Q\times\Gamma\rightarrow\mathcal{P}(Q\times\Gamma\times\{L,R\})
  </annotation>
 </semantics>
</math>


 is called the transition function (<em>L</em> shifts the head left and <em>R</em> shifts the head right)</li>
<li>

<math display="inline" id="Alternating_Turing_machine:4">
 <semantics>
  <mrow>
   <msub>
    <mi>q</mi>
    <mn>0</mn>
   </msub>
   <mo>‚àà</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{0}\in Q
  </annotation>
 </semantics>
</math>

 is the initial state</li>
<li>

<math display="inline" id="Alternating_Turing_machine:5">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>:</mo>
   <mrow>
    <mi>Q</mi>
    <mo>‚Üí</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mo>‚àß</mo>
     <mo>,</mo>
     <mo>‚à®</mo>
     <mo>,</mo>
     <mrow>
      <mi>a</mi>
      <mi>c</mi>
      <mi>c</mi>
      <mi>e</mi>
      <mi>p</mi>
      <mi>t</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>r</mi>
      <mi>e</mi>
      <mi>j</mi>
      <mi>e</mi>
      <mi>c</mi>
      <mi>t</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>Q</ci>
     <set>
      <and></and>
      <or></or>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>c</ci>
       <ci>c</ci>
       <ci>e</ci>
       <ci>p</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <ci>r</ci>
       <ci>e</ci>
       <ci>j</ci>
       <ci>e</ci>
       <ci>c</ci>
       <ci>t</ci>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g:Q\rightarrow\{\wedge,\vee,accept,reject\}
  </annotation>
 </semantics>
</math>

 specifies the type of each state</li>
</ul>

<p>If <em>M</em> is in a state 

<math display="inline" id="Alternating_Turing_machine:6">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>‚àà</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>q</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\in Q
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Alternating_Turing_machine:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <mi>c</mi>
    <mi>c</mi>
    <mi>e</mi>
    <mi>p</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>q</ci>
    </apply>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>c</ci>
     <ci>c</ci>
     <ci>e</ci>
     <ci>p</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(q)=accept
  </annotation>
 </semantics>
</math>

 then that configuration is said to be <em>accepting</em>, and if 

<math display="inline" id="Alternating_Turing_machine:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>r</mi>
    <mi>e</mi>
    <mi>j</mi>
    <mi>e</mi>
    <mi>c</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>q</ci>
    </apply>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>e</ci>
     <ci>j</ci>
     <ci>e</ci>
     <ci>c</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(q)=reject
  </annotation>
 </semantics>
</math>


 the configuration is said to be <em>rejecting</em>. A configuration with 

<math display="inline" id="Alternating_Turing_machine:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mo>‚àß</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>q</ci>
    </apply>
    <and></and>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(q)=\wedge
  </annotation>
 </semantics>
</math>

 is said to be accepting if all configurations reachable in one step are accepting, and rejecting if some configuration reachable in one step is rejecting. A configuration with 

<math display="inline" id="Alternating_Turing_machine:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mo>‚à®</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>q</ci>
    </apply>
    <or></or>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(q)=\vee
  </annotation>
 </semantics>
</math>

 is said to be accepting when there exists some configuration reachable in one step which is accepting and rejecting when all configurations reachable in one step are rejecting (this is the type of all states in an NTM). <em>M</em> is said to accept an input string <em>w</em> if the initial configuration of <em>M</em> (the state of <em>M</em> is 

<math display="inline" id="Alternating_Turing_machine:11">
 <semantics>
  <msub>
   <mi>q</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{0}
  </annotation>
 </semantics>
</math>

, the head is at the left end of the tape, and the tape contains <em>w</em>) is accepting, and to reject if the initial configuration is rejecting.</p>
<h3 id="resource-bounds">Resource bounds</h3>

<p>When deciding if a configuration of an ATM is accepting or rejecting using the above definition, it is not necessary to examine all configurations reachable from the current configuration. In particular, an existential configuration can be labelled as accepting if any successor configuration is found to be accepting, and a universal configuration can be labelled as rejecting if any successor configuration is found to be rejecting.</p>

<p>An ATM decides a <a href="formal_language" title="wikilink">formal language</a> in time 

<math display="inline" id="Alternating_Turing_machine:12">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(n)
  </annotation>
 </semantics>
</math>

 if, on any input of length 

<math display="inline" id="Alternating_Turing_machine:13">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


, examining configurations only up to 

<math display="inline" id="Alternating_Turing_machine:14">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(n)
  </annotation>
 </semantics>
</math>

 steps is sufficient to label the initial configuration as accepting or rejecting. An ATM decides a language in space 

<math display="inline" id="Alternating_Turing_machine:15">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(n)
  </annotation>
 </semantics>
</math>

 if examining configurations which do not modify tape cells beyond the 

<math display="inline" id="Alternating_Turing_machine:16">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(n)
  </annotation>
 </semantics>
</math>

 cell from the left is sufficient.</p>

<p>A language which is decided by some ATM in time 

<math display="inline" id="Alternating_Turing_machine:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mo>‚ãÖ</mo>
    <mi>t</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-‚ãÖ</ci>
     <ci>c</ci>
     <ci>t</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\cdot t(n)
  </annotation>
 </semantics>
</math>

 for some constant 

<math display="inline" id="Alternating_Turing_machine:18">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>c</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c>0
  </annotation>
 </semantics>
</math>


 is said to be in the class 

<math display="inline" id="Alternating_Turing_machine:19">
 <semantics>
  <mrow>
   <mi>ATIME</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>t</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ATIME</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm ATIME}(t(n))
  </annotation>
 </semantics>
</math>

, and a language decided in space 

<math display="inline" id="Alternating_Turing_machine:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mo>‚ãÖ</mo>
    <mi>s</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-‚ãÖ</ci>
     <ci>c</ci>
     <ci>s</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\cdot s(n)
  </annotation>
 </semantics>
</math>

 is said to be in the class 

<math display="inline" id="Alternating_Turing_machine:21">
 <semantics>
  <mrow>
   <mi>ASPACE</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ASPACE</ci>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm ASPACE}(s(n))
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="example">Example</h2>

<p>Perhaps the simplest problem for alternating machines to solve is the <a href="quantified_Boolean_formula_problem" title="wikilink">quantified Boolean formula problem</a>, which is a generalization of the <a href="Boolean_satisfiability_problem" title="wikilink">Boolean satisfiability problem</a> in which each variable can be bound by either an existential or a universal quantifier. The alternating machine branches existentially to try all possible values of an existentially quantified variable and universally to try all possible values of a universally quantified variable, in the left-to-right order in which they are bound. After deciding a value for all quantified variables, the machine accepts if the resulting Boolean formula evaluates to true, and rejects if it evaluates to false. Thus at an existentially quantified variable the machine is accepting if a value can be substituted for the variable which renders the remaining problem satisfiable, and at a universally quantified variable the machine is accepting if any value can be substituted and the remaining problem is satisfiable.</p>

<p>Such a machine decides quantified Boolean formulas in time 

<math display="inline" id="Alternating_Turing_machine:22">
 <semantics>
  <msup>
   <mi>n</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{2}
  </annotation>
 </semantics>
</math>

 and space 

<math display="inline" id="Alternating_Turing_machine:23">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


.</p>

<p>The Boolean satisfiability problem can be viewed as the special case where all variables are existentially quantified, allowing ordinary nondeterminism, which uses only existential branching, to solve it efficiently.</p>
<h2 id="complexity-classes-and-comparison-to-deterministic-turing-machines">Complexity classes and comparison to deterministic Turing machines</h2>

<p>The following <a href="complexity_classes" title="wikilink">complexity classes</a> are useful to define for ATMs:</p>
<ul>
<li>

<math display="inline" id="Alternating_Turing_machine:24">
 <semantics>
  <mrow>
   <mi>AP</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">‚ãÉ</mo>
     <mrow>
      <mi>k</mi>
      <mo>></mo>
      <mn>0</mn>
     </mrow>
    </msub>
    <mrow>
     <mi>ATIME</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>n</mi>
       <mi>k</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>AP</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <union></union>
      <apply>
       <gt></gt>
       <ci>k</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>ATIME</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm AP}=\bigcup_{k>0}{\rm ATIME}(n^{k})
  </annotation>
 </semantics>
</math>

 are the languages decidable in polynomial time</li>
<li>

<math display="inline" id="Alternating_Turing_machine:25">
 <semantics>
  <mrow>
   <mi>APSPACE</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">‚ãÉ</mo>
     <mrow>
      <mi>k</mi>
      <mo>></mo>
      <mn>0</mn>
     </mrow>
    </msub>
    <mrow>
     <mi>ASPACE</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>n</mi>
       <mi>k</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>APSPACE</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <union></union>
      <apply>
       <gt></gt>
       <ci>k</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>ASPACE</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm APSPACE}=\bigcup_{k>0}{\rm ASPACE}(n^{k})
  </annotation>
 </semantics>
</math>

 are the languages decidable in polynomial space</li>
<li>

<math display="inline" id="Alternating_Turing_machine:26">
 <semantics>
  <mrow>
   <mi>AEXPTIME</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">‚ãÉ</mo>
     <mrow>
      <mi>k</mi>
      <mo>></mo>
      <mn>0</mn>
     </mrow>
    </msub>
    <mrow>
     <mi>ATIME</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>k</mi>
       <mi>n</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>AEXPTIME</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <union></union>
      <apply>
       <gt></gt>
       <ci>k</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>ATIME</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>k</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm AEXPTIME}=\bigcup_{k>0}{\rm ATIME}(k^{n})
  </annotation>
 </semantics>
</math>

 are the languages decidable in exponential time</li>
</ul>

<p>These are similar to the definitions of <a href="P_(complexity)" title="wikilink">P</a>, <a class="uri" href="PSPACE" title="wikilink">PSPACE</a>, and <a class="uri" href="EXPTIME" title="wikilink">EXPTIME</a>, considering the resources used by an ATM rather than a deterministic Turing machine. Chandra, Kozen, and Stockmeyer<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> proved the theorems</p>
<ul>
<li>AP = PSPACE</li>
<li>APSPACE = EXPTIME</li>
<li>AEXPTIME = <a class="uri" href="EXPSPACE" title="wikilink">EXPSPACE</a></li>
<li>

<math display="inline" id="Alternating_Turing_machine:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>ASPACE</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">‚ãÉ</mo>
     <mrow>
      <mi>c</mi>
      <mo>></mo>
      <mn>0</mn>
     </mrow>
    </msub>
    <mrow>
     <mi>DTIME</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mn>2</mn>
       <mrow>
        <mi>c</mi>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>DTIME</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mn>2</mn>
      <mrow>
       <mi>O</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>ASPACE</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <union></union>
       <apply>
        <gt></gt>
        <ci>c</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>DTIME</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <times></times>
         <ci>c</ci>
         <ci>f</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>DTIME</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <times></times>
        <ci>O</ci>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{ASPACE}(f(n))=\bigcup_{c>0}{\rm DTIME}(2^{cf(n)})={\rm DTIME}(2^{O(f(n%
))})
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Alternating_Turing_machine:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>ATIME</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚äÜ</mo>
   <mrow>
    <mi>DSPACE</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <ci>ATIME</ci>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>DSPACE</ci>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{ATIME}(g(n))\subseteq{\rm DSPACE}(g(n))
  </annotation>
 </semantics>
</math>


</li>
<li>

<math display="inline" id="Alternating_Turing_machine:29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>NSPACE</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>‚äÜ</mo>
    <mrow>
     <msub>
      <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">‚ãÉ</mo>
      <mrow>
       <mi>c</mi>
       <mo>></mo>
       <mn>0</mn>
      </mrow>
     </msub>
     <mrow>
      <mi>ATIME</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>c</mi>
         <mo>√ó</mo>
         <mi>g</mi>
        </mrow>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <times></times>
     <ci>NSPACE</ci>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <union></union>
      <apply>
       <gt></gt>
       <ci>c</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>ATIME</ci>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <ci>c</ci>
        <ci>g</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{NSPACE}(g(n))\subseteq\bigcup_{c>0}{\rm ATIME}(c\times g(n)^{2}),
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>when 

<math display="inline" id="Alternating_Turing_machine:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚â•</mo>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)\geq\log(n)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Alternating_Turing_machine:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚â•</mo>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(n)\geq\log(n)
  </annotation>
 </semantics>
</math>

.</p>

<p>A more general form of these relationships is expressed by the <a href="parallel_computation_thesis" title="wikilink">parallel computation thesis</a>.</p>
<h2 id="bounded-alternation">Bounded alternation</h2>
<h3 id="definition">Definition</h3>

<p>An <strong>alternating Turing machine with <em>k</em> alternations</strong> is an alternating Turing machine which switches from an existential to a universal state or vice versa no more than <em>k</em>‚àí1 times. (It is an alternating Turing machine whose states are divided into <em>k</em> sets. The states in even-numbered sets are universal and the states in odd-numbered sets are existential (or vice versa). The machine has no transitions between a state in set <em>i</em> and a state in set <em>j</em> {\rm ATIME}(C,j)=\Sigma_j {\rm TIME}(C) is the class of function in time 

<math display="inline" id="Alternating_Turing_machine:32">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>‚àà</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>f</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\in C
  </annotation>
 </semantics>
</math>

 beginning by existential state and alternating at most 

<math display="inline" id="Alternating_Turing_machine:33">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>j</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j-1
  </annotation>
 </semantics>
</math>


 times. It is called the 

<math display="inline" id="Alternating_Turing_machine:34">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

th level of the 

<math display="inline" id="Alternating_Turing_machine:35">
 <semantics>
  <mrow>
   <mi>TIME</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>TIME</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm TIME}(C)
  </annotation>
 </semantics>
</math>

 hierarchy.</p>

<p>

<math display="inline" id="Alternating_Turing_machine:36">
 <semantics>
  <mrow>
   <mrow>
    <mi>coATIME</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi mathvariant="normal">Œ†</mi>
     <mi>j</mi>
    </msub>
    <mi>TIME</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>coATIME</ci>
     <interval closure="open">
      <ci>C</ci>
      <ci>j</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Œ†</ci>
      <ci>j</ci>
     </apply>
     <ci>TIME</ci>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm coATIME}(C,j)=\Pi_{j}{\rm TIME}(C)
  </annotation>
 </semantics>
</math>

 is the same classes, but beginning by a universal state, it is the complement of the language of 

<math display="inline" id="Alternating_Turing_machine:37">
 <semantics>
  <mrow>
   <mi>ATIME</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ATIME</ci>
    <interval closure="open">
     <ci>f</ci>
     <ci>j</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm ATIME}(f,j)
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="inline" id="Alternating_Turing_machine:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>ASPACE</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi mathvariant="normal">Œ£</mi>
     <mi>SPACE</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ASPACE</ci>
     <interval closure="open">
      <ci>C</ci>
      <ci>j</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Œ£</ci>
      <ci>SPACE</ci>
     </apply>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm ASPACE}(C,j)=\Sigma_{\rm SPACE}(C)
  </annotation>
 </semantics>
</math>


 is defined similarly for space bounded computation.</p>
<h3 id="example-1">Example</h3>

<p>Consider the <a href="circuit_minimization_problem" title="wikilink">circuit minimization problem</a>: given a circuit <em>A</em> computing a <a href="Boolean_function" title="wikilink">Boolean function</a> <em>f</em> and a number <em>n</em>, determine if there is a circuit with at most <em>n</em> gates that computes the same function <em>f</em>. An alternating Turing machine, with one alternation, starting in an existential state, can solve this problem in polynomial time (by guessing a circuit <em>B</em> with at most <em>n</em> gates, then switching to a universal state, guessing an input, and checking that the output of <em>B</em> on that input matches the output of <em>A</em> on that input).</p>
<h3 id="collapsing-classes">Collapsing classes</h3>

<p>It is said that a hierarchy <em>collapses</em> to level 

<math display="inline" id="Alternating_Turing_machine:39">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 if every language in level 

<math display="inline" id="Alternating_Turing_machine:40">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>‚â•</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>k</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\geq j
  </annotation>
 </semantics>
</math>

 of the hierarchy is in its level 

<math display="inline" id="Alternating_Turing_machine:41">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

.</p>

<p>As a corollary of the <a href="Immerman‚ÄìSzelepcs√©nyi_theorem" title="wikilink">Immerman‚ÄìSzelepcs√©nyi theorem</a>, the logarithmic space hierarchy collapses to its first level.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> As a corollary the 

<math display="inline" id="Alternating_Turing_machine:42">
 <semantics>
  <mrow>
   <mi>SPACE</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>SPACE</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm SPACE}(f)
  </annotation>
 </semantics>
</math>

 hierarchy collapses to its first level when 

<math display="inline" id="Alternating_Turing_machine:43">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Œ©</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>log</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>f</ci>
    <apply>
     <times></times>
     <ci>normal-Œ©</ci>
     <log></log>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=\Omega(\log)
  </annotation>
 </semantics>
</math>


 is <a href="space_constructible" title="wikilink">space constructible</a>.</p>
<h3 id="special-cases">Special cases</h3>

<p>An alternating Turing machine in polynomial time with <em>k</em> alternations, starting in an existential (respectively, universal) state can decide all the problems in the class 

<math display="inline" id="Alternating_Turing_machine:44">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Œ£</mi>
   <mi>k</mi>
   <mi>p</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Œ£</ci>
     <ci>k</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{k}^{p}
  </annotation>
 </semantics>
</math>

 (respectively, 

<math display="inline" id="Alternating_Turing_machine:45">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Œ†</mi>
   <mi>k</mi>
   <mi>p</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Œ†</ci>
     <ci>k</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{k}^{p}
  </annotation>
 </semantics>
</math>

).<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> These classes are sometimes denoted 

<math display="inline" id="Alternating_Turing_machine:46">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Œ£</mi>
    <mi>k</mi>
   </msub>
   <mi mathvariant="normal">P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Œ£</ci>
     <ci>k</ci>
    </apply>
    <ci>normal-P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{k}\rm{P}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Alternating_Turing_machine:47">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Œ†</mi>
    <mi>k</mi>
   </msub>
   <mi mathvariant="normal">P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Œ†</ci>
     <ci>k</ci>
    </apply>
    <ci>normal-P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{k}\rm{P}
  </annotation>
 </semantics>
</math>

, respectively. See the <a href="polynomial_hierarchy" title="wikilink">polynomial hierarchy</a> article for details.</p>

<p>Another special case of time hierarchies is the <a href="LH_(complexity)" title="wikilink">logarithmic hierarchy</a>.</p>
<h2 id="references">References</h2>
<ul>
<li>

<p>Section 10.3: Alternation, pp.¬†348‚Äì354.</p></li>
<li>

<p>Section 10.3: Alternation, pp.¬†380‚Äì386.</p></li>
<li>

<p>Section 16.2: Alternation, pp.¬†399‚Äì401.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Models_of_computation" title="wikilink">Category:Models of computation</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">‚Ü©</a></li>
<li id="fn2"><a href="#fnref2">‚Ü©</a></li>
<li id="fn3"><a href="#fnref3">‚Ü©</a></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">‚Ü©</a></li>
<li id="fn6"><a href="#fnref6">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
