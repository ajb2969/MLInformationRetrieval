<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="348">Sun-Ni law</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Sun-Ni law</h1>
<hr/>

<p><strong>Sun-Ni's Law</strong> (or Sun and Ni's Law, also known as memory-bounded speedup), is a memory-bounded <a class="uri" href="speedup" title="wikilink">speedup</a> model which states that as computing power increases the corresponding increase in problem size is constrained by the system’s memory capacity. In general, as a system grows in computational power, the problems run on the system increase in size. Analogous to <a href="Amdahl's_law" title="wikilink">Amdahl's law</a>, which says that the problem size remains constant as system sizes grow, and <a href="Gustafson's_law" title="wikilink">Gustafson's law</a>, which proposes that the problem size should scale but be bound by a fixed amount of time, Sun-Ni's Law states the problem size should scale but be bound by the memory capacity of the system. Sun-Ni's Law <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> was initially proposed by Xian-He Sun and Lionel Ni at the Proceedings of <a href="ACM/IEEE_Supercomputing_Conference" title="wikilink">IEEE Supercomputing Conference 1990</a>.</p>

<p>With the increasing disparity between CPU speed and memory data access latency, application execution time often depends on the memory speed of the system.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> As predicted by Sun and Ni, data access has become the premier performance bottleneck for high-end computing. From this fact one can see the intuition behind Sun-Ni's Law, as system resources increase, applications are often bottleneck by memory speed and bandwidth, thus an application can achieve a larger speedup by utilizing all the memory capacity in the system. Sun-Ni's Law can be applied to different layers of a <a href="memory_hierarchy" title="wikilink">memory hierarchy</a> system, from <a href="CPU_cache" title="wikilink">L1 cache</a> to main memory. Through its memory-bounded function,<em>W=G(M)</em>, it reveals the trade-off between computing and memory in algorithm and <a href="Computer_architecture" title="wikilink">system architecture</a> design.</p>

<p>All three speedup models, Sun-Ni, Gustafson, and Amdahl, provide a metric to analyze speedup for <a href="Parallel_computing" title="wikilink">Parallel computing</a>. Amdahl’s law focuses on the time reduction for a given fixed-size problem. Amdahl’s law states that the sequential portion of the problem (algorithm) limits the total speedup that can be achieved as system resources increase. Gustafson’s law suggests that it is beneficial to build a large-scale parallel system as the speedup can grow linearly with the system size if the problem size is scaled up to maintain a fixed execution time.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Yet as memory access latency often becomes the dominant factor in an application’s execution time,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> applications may not scale up to meet the time bound constraint.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Sun-Ni's Law, instead of constraining the problem size by time, constrains the problem by the memory capacity of the system, or in other words bounds based on memory. Sun-Ni's Law is a generalization of Amdahl's Law and Gustafson's Law. When the memory-bounded function <em>G(M)=1</em>, it resolves to Amdahl's law, when the memory-bounded function <em>G(M)=m</em>,the number of processors, it resolves to Gustafson's Law.</p>
<h2 id="derivation-of-sun-nis-law">Derivation of Sun-Ni's Law</h2>

<p>Let 

<math display="inline" id="Sun-Ni_law:0">
 <semantics>
  <msup>
   <mi>W</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>W</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle W^{*}
  </annotation>
 </semantics>
</math>

 be the scaled workload under a memory space constraint. The memory bounded speedup can be defined as:</p>

<p><em><code>Sequential</code> <code>Time</code> <code>to</code> <code>Solve</code> <code>W</code><sup><code>*</code></sup><code>/Parallel</code> <code>Time</code> <code>to</code> <code>Solve</code> <code>W</code><sup><code>*</code></sup></em></p>

<p>Suppose 

<math display="inline" id="Sun-Ni_law:1">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle f
  </annotation>
 </semantics>
</math>

 is the portion of the workload that can be parallelized and 

<math display="inline" id="Sun-Ni_law:2">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mi>f</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle(1-f)
  </annotation>
 </semantics>
</math>

 is the sequential portion of the workload.</p>

<p>Let 

<math display="inline" id="Sun-Ni_law:3">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle y=g(x)
  </annotation>
 </semantics>
</math>

 be the function that reflects the parallel workload increase factor as the memory capacity increases m times.</p>

<p>Let

<math display="block" id="Sun-Ni_law:4">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>W</ci>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle W=g(M)
  </annotation>
 </semantics>
</math>

 and

<math display="block" id="Sun-Ni_law:5">
 <semantics>
  <mrow>
   <msup>
    <mi>W</mi>
    <mo>*</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>m</mi>
      <mo>⋅</mo>
      <mi>M</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>W</ci>
     <times></times>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <ci>normal-⋅</ci>
      <ci>m</ci>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle W^{*}=g(m\cdot M)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Sun-Ni_law:6">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle M
  </annotation>
 </semantics>
</math>

 is the memory capacity of one node.</p>

<p>Thus, 

<math display="inline" id="Sun-Ni_law:7">
 <semantics>
  <mrow>
   <msup>
    <mi>W</mi>
    <mo>*</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>m</mi>
       <mo>⋅</mo>
       <msup>
        <mi>g</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>W</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>W</ci>
     <times></times>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <ci>m</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>g</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <ci>W</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{*}=g(m\cdot g^{-1}(W))
  </annotation>
 </semantics>
</math>

</p>

<p>The memory bounded speedup is then:</p>

<p>

<math display="inline" id="Sun-Ni_law:8">
 <semantics>
  <mfrac>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>W</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mo>⋅</mo>
      <mi>g</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>m</mi>
        <mo>⋅</mo>
        <msup>
         <mi>g</mi>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>W</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>W</mi>
    </mrow>
    <mo>+</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mo>⋅</mo>
       <mi>g</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>m</mi>
         <mo>⋅</mo>
         <msup>
          <mi>g</mi>
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msup>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>W</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mi>m</mi>
    </mfrac>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>f</ci>
      </apply>
      <ci>W</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <ci>f</ci>
       <ci>g</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <ci>m</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>g</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <ci>W</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>f</ci>
      </apply>
      <ci>W</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <ci>f</ci>
        <ci>g</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <ci>normal-⋅</ci>
         <ci>m</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>g</ci>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
        <ci>W</ci>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{(1-f)W+f\cdot g(m\cdot g^{-1}(W))}{(1-f)W+\frac{f\cdot g(m\cdot g^{-1}(W%
))}{m}}
  </annotation>
 </semantics>
</math>

</p>

<p>For any power function 

<math display="inline" id="Sun-Ni_law:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <msup>
     <mi>x</mi>
     <mi>b</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>a</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle g(x)=ax^{b}
  </annotation>
 </semantics>
</math>

 and for any rational numbers <em>a</em> and <em>b</em>, we have:</p>

<p>

<math display="inline" id="Sun-Ni_law:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>m</mi>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>m</mi>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>b</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>m</mi>
      <mi>b</mi>
     </msup>
     <mo>⋅</mo>
     <mi>a</mi>
    </mrow>
    <msup>
     <mi>x</mi>
     <mi>b</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>m</mi>
     <mi>b</mi>
    </msup>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>g</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>x</ci>
       </apply>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>m</ci>
        <ci>b</ci>
       </apply>
       <ci>a</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>m</ci>
       <ci>b</ci>
      </apply>
      <ci>g</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <ci>normal-¯</ci>
       <ci>g</ci>
      </apply>
      <ci>m</ci>
      <ci>g</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(mx)=a(mx)^{b}=m^{b}\cdot ax^{b}=m^{b}g(x)=\bar{g}(m)g(x)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Sun-Ni_law:11">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>g</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-¯</ci>
     <ci>g</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\bar{g}(m)
  </annotation>
 </semantics>
</math>

 is the power function with the coefficient as 1.</p>

<p>Thus by taking the highest degree term to determine the complexity of the algorithm, we can rewrite memory bounded speedup as:</p>

<p>

<math display="inline" id="Sun-Ni_law:12">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>f</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>W</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mo>⋅</mo>
       <mover accent="true">
        <mi>g</mi>
        <mo stretchy="false">¯</mo>
       </mover>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>m</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>W</mi>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>f</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>W</mi>
     </mrow>
     <mo>+</mo>
     <mfrac>
      <mrow>
       <mrow>
        <mi>f</mi>
        <mo>⋅</mo>
        <mover accent="true">
         <mi>g</mi>
         <mo stretchy="false">¯</mo>
        </mover>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>m</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>W</mi>
      </mrow>
      <mi>m</mi>
     </mfrac>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mo>⋅</mo>
       <mover accent="true">
        <mi>g</mi>
        <mo stretchy="false">¯</mo>
       </mover>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>m</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mfrac>
      <mrow>
       <mrow>
        <mi>f</mi>
        <mo>⋅</mo>
        <mover accent="true">
         <mi>g</mi>
         <mo stretchy="false">¯</mo>
        </mover>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>m</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mi>m</mi>
     </mfrac>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>f</ci>
       </apply>
       <ci>W</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <ci>f</ci>
        <apply>
         <ci>normal-¯</ci>
         <ci>g</ci>
        </apply>
       </apply>
       <ci>m</ci>
       <ci>W</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>f</ci>
       </apply>
       <ci>W</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <ci>normal-⋅</ci>
         <ci>f</ci>
         <apply>
          <ci>normal-¯</ci>
          <ci>g</ci>
         </apply>
        </apply>
        <ci>m</ci>
        <ci>W</ci>
       </apply>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>f</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <ci>f</ci>
        <apply>
         <ci>normal-¯</ci>
         <ci>g</ci>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>f</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <ci>normal-⋅</ci>
         <ci>f</ci>
         <apply>
          <ci>normal-¯</ci>
          <ci>g</ci>
         </apply>
        </apply>
        <ci>m</ci>
       </apply>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{(1-f)W+f\cdot\bar{g}(m)W}{(1-f)W+\frac{f\cdot\bar{g}(m)W}{m}}=\frac{(1-f%
)+f\cdot\bar{g}(m)}{(1-f)+\frac{f\cdot\bar{g}(m)}{m}}
  </annotation>
 </semantics>
</math>

</p>

<p>In this equation, 

<math display="inline" id="Sun-Ni_law:13">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>g</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-¯</ci>
     <ci>g</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\bar{g}(m)
  </annotation>
 </semantics>
</math>

 represents the influence of memory change on the change in problem size.</p>

<p>Suppose 

<math display="inline" id="Sun-Ni_law:14">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-¯</ci>
      <ci>g</ci>
     </apply>
     <ci>m</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\bar{g}(m)=1
  </annotation>
 </semantics>
</math>

, Then the memory-bounded speedup model reduces to <a href="Amdahl's_law" title="wikilink">Amdahl's law</a>, since problem size is fixed or independent of resource increase.</p>

<p>Suppose 

<math display="inline" id="Sun-Ni_law:15">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-¯</ci>
      <ci>g</ci>
     </apply>
     <ci>m</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\bar{g}(m)=m
  </annotation>
 </semantics>
</math>

, Then the memory-bounded speedup model reduces to <a href="Gustafson's_law" title="wikilink">Gustafson's law</a>, which means when memory capacity increases <em>m</em> times and the workload also increases <em>m</em> times all the data needed is local to every node in the system.</p>

<p>Often, for simplicity and for matching the notation of Amdahl's Law and Gustafson's Law, the letter <em>G</em> is used to represent the memory bound function 

<math display="inline" id="Sun-Ni_law:16">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>g</mi>
    <mo stretchy="false">¯</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-¯</ci>
     <ci>g</ci>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\bar{g}(m)
  </annotation>
 </semantics>
</math>

, and <em>n</em> replaces <em>m</em>. Using this notation we get:</p>

<p>

<math display="inline" id="Sun-Ni_law:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mi>p</mi>
    <mi>e</mi>
    <mi>e</mi>
    <mi>d</mi>
    <mi>u</mi>
    <msub>
     <mi>p</mi>
     <mtext>memory-bounded</mtext>
    </msub>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mo>⋅</mo>
       <mi>G</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mfrac>
      <mrow>
       <mrow>
        <mi>f</mi>
        <mo>⋅</mo>
        <mi>G</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mi>n</mi>
     </mfrac>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>p</ci>
     <ci>e</ci>
     <ci>e</ci>
     <ci>d</ci>
     <ci>u</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <mtext>memory-bounded</mtext>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>f</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <ci>f</ci>
        <ci>G</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>f</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <ci>normal-⋅</ci>
         <ci>f</ci>
         <ci>G</ci>
        </apply>
        <ci>n</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Speedup_{\text{memory-bounded}}=\frac{(1-f)+f\cdot G(n)}{(1-f)+\frac{f\cdot G(%
n)}{n}}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="examples">Examples</h2>

<p>Suppose one would like to determine the memory-bounded speedup of matrix multiplication. The memory requirement of matrix multiplication is roughly 

<math display="inline" id="Sun-Ni_law:18">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mn>3</mn>
    <msup>
     <mi>N</mi>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <times></times>
     <cn type="integer">3</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>N</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle x=3N^{2}
  </annotation>
 </semantics>
</math>

 where <em>N</em> is the dimension of the two <em>N X N</em> source matrices. And the computation requirement is 

<math display="inline" id="Sun-Ni_law:19">
 <semantics>
  <mrow>
   <mn>2</mn>
   <msup>
    <mi>N</mi>
    <mn>3</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>N</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2N^{3}
  </annotation>
 </semantics>
</math>

</p>

<p>Thus we have:</p>

<p>

<math display="inline" id="Sun-Ni_law:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>/</mo>
       <mn>3</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mn>3</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>2</mn>
     <msup>
      <mn>3</mn>
      <mrow>
       <mn>3</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
    </mfrac>
    <msup>
     <mi>x</mi>
     <mrow>
      <mn>3</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <divide></divide>
        <ci>x</ci>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">3</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">3</cn>
        <apply>
         <divide></divide>
         <cn type="integer">3</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <apply>
        <divide></divide>
        <cn type="integer">3</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)=2(x/3)^{3/2}=\frac{2}{3^{3/2}}x^{3/2}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sun-Ni_law:21">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">¯</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>x</mi>
    <mrow>
     <mn>3</mn>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-¯</ci>
      <ci>g</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <apply>
      <divide></divide>
      <cn type="integer">3</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{g}(x)=x^{3/2}
  </annotation>
 </semantics>
</math>

</p>

<p>Thus the memory-bounded speedup is for matrix multiplication is:</p>

<p>

<math display="inline" id="Sun-Ni_law:22">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mo>⋅</mo>
       <mover accent="true">
        <mi>g</mi>
        <mo stretchy="false">¯</mo>
       </mover>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>m</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mfrac>
      <mrow>
       <mrow>
        <mi>f</mi>
        <mo>⋅</mo>
        <mover accent="true">
         <mi>g</mi>
         <mo stretchy="false">¯</mo>
        </mover>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>m</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mi>m</mi>
     </mfrac>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>f</mi>
      <mo>⋅</mo>
      <msup>
       <mi>m</mi>
       <mrow>
        <mn>3</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </msup>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>f</mi>
      <mo>⋅</mo>
      <msup>
       <mi>m</mi>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>f</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <ci>f</ci>
        <apply>
         <ci>normal-¯</ci>
         <ci>g</ci>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>f</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <ci>normal-⋅</ci>
         <ci>f</ci>
         <apply>
          <ci>normal-¯</ci>
          <ci>g</ci>
         </apply>
        </apply>
        <ci>m</ci>
       </apply>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>f</ci>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>m</ci>
        <apply>
         <divide></divide>
         <cn type="integer">3</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>f</ci>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>m</ci>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{(1-f)+f\cdot\bar{g}(m)}{(1-f)+\frac{f\cdot\bar{g}(m)}{m}}=\frac{(1-f)+f%
\cdot m^{3/2}}{(1-f)+f\cdot m^{1/2}}
  </annotation>
 </semantics>
</math>

</p>

<p>The following is another matrix multiplication example which illustrates the rapid increase in parallel execution time.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The execution time of a <em>N X N</em> matrix for a uniprocessor is

<math display="block" id="Sun-Ni_law:23">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3})
  </annotation>
 </semantics>
</math>

. While the memory usage is

<math display="block" id="Sun-Ni_law:24">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2})
  </annotation>
 </semantics>
</math>

</p>

<p>Suppose a <em>10000</em>-by-<em>10000</em> matrix takes <em>800 MB</em> of memory and can be factorized in <em>1</em> hour on a uniprocessor. Now for the scaled workload suppose is possible to factorize a <em>320,000</em>-by-<em>320,000</em> matrix in <em>32</em> hours. The time increase is quite large, but the increase in problem size may be more valuable for someones whose premier goal is accuracy. For example, an astrophysicist may be more interested in simulating an <a href="N-body_problem" title="wikilink">N-body problem</a> with as the number of particles as large as possible.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> This example shows for computation intensive applications, memory capacity does not need to proportionally scale up with computing power.</p>
<h2 id="applicationseffects-of-sun-nis-law">Applications/Effects of Sun-Ni's Law</h2>

<p>The memory-bounded speedup model is the first work to reveal that memory is the performance constraint for high-end computing and presents a quantitative mathematical formulation for the trade-off between memory and computing. It is based on the memory-bounded function,<em>W=G(n)</em>, where W is the work and thus also the computation for most applications. <em>M</em> is the memory requirement in terms of capacity, and <em>G</em> is the reuse rate. <em>W=G(M)</em> gives a very simple, but effective, description of the relation between computation and memory requirement. From an architecture viewpoint, the memory-bounded model suggests the size, as well as speed, of the cache(s) should match the CPU performance. Today, modern microprocessors such as the <a href="Pentium_Pro" title="wikilink">Pentium Pro</a>, <a href="Alpha_21164" title="wikilink">Alpha 21164</a>, <a href="StrongARM" title="wikilink">Strong Arm SA110</a>, and Longson-3A use 80% or more of their transistors for the on-chip cache rather than computing components. From an algorithm design viewpoint, we should reduce the number of memory accesses. That is, reuse the data when it is possible. The function <em>G()</em> gives the reuse rate. Today, the term <a href="memory_bound_function" title="wikilink">memory bound functions</a> has become a general term which refers to functions which involve extensive memory access.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Memory complexity analysis has become a discipline of computer algorithm analysis.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Theoretical_computer_science" title="wikilink">Category:Theoretical computer science</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.ece.eng.wayne.edu/~sjiang/ECE7610-winter-11/scalability.pdf">1</a> Another View on Parallel Speedup, Xian-He Sun and Lionel Ni, Proceedings of <a href="ACM/IEEE_Supercomputing_Conference" title="wikilink">IEEE Supercomputing Conference '90</a>.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://www.di.unisa.it/~vitsca/SC-2011/DesignPrinciplesMulticoreProcessors/Sun1993.pdf">2</a> Scalable Problems and Memory-Bounded Speedup, X.H. Sun, and L. Ni, Journal of Parallel and Distributed Computing, Vol. 19, p.27-37, Sept.1993.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://www.di.unisa.it/~vitsca/SC-2011/DesignPrinciplesMulticoreProcessors/Wulf1995.pdf">3</a> Hitting the Memory Wall:Implications of the Obvious, Wm.A. Wulf and Sally A. McKee, ACM SIGARCH Computer Architecture News Vol. 23 p. 20–24 March 1995.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="http://www.cs.iit.edu/~scs/psfiles/Reevaluating%20Amdahl%27s%20Law.pdf">4</a> Reevaluating Amdahl's Law in the Multicore Era, Xian-He Sun and Yong Chen, Journal of Parallel and Distributed Computing, Vol. 70 p.183-188, February 2010.<a href="#fnref4">↩</a></li>
<li id="fn5">[<a class="uri" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.158.2815&amp;rep">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.158.2815&amp;rep;</a>;=rep1&amp;type;=pdf] Scaling the Bandwidth Wall:Challenges in and Avenues for CMP Scaling, Brian M. Rogers, Anil Krishna, Gorden B. Bell, Ken Vu, Xiaowei Jiang, and Yan Solihin, ACM SIGARCH Computer Architecture News, Vol. 37 p.371-382, June 2009<a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10">U.Meyer, P.Sanders, and J.F. Sibeyn (Eds.), Algorithms for Memory Hierarchies, Vol. 2625 of LNCS Springer, 2003.<a href="#fnref10">↩</a></li>
</ol>
</section>
</body>
</html>
