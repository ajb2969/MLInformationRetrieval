<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="623">Gaussian filter</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Gaussian filter</h1>
<hr/>

<p> In <a class="uri" href="electronics" title="wikilink">electronics</a> and <a href="signal_processing" title="wikilink">signal processing</a>, a <strong>Gaussian filter</strong> is a <a href="filter_(signal_processing)" title="wikilink">filter</a> whose <a href="impulse_response" title="wikilink">impulse response</a> is a <a href="Gaussian_function" title="wikilink">Gaussian function</a> (or an approximation to it). Gaussian filters have the properties of having no overshoot to a step function input while minimizing the rise and fall time. This behavior is closely connected to the fact that the Gaussian filter has the minimum possible <a href="group_delay" title="wikilink">group delay</a>. It is considered the ideal <a href="time_domain" title="wikilink">time domain</a> filter, just as the <a href="sinc_filter" title="wikilink">sinc</a> is the ideal frequency domain filter.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> These properties are important in areas such as <a href="Oscilloscope#The_vertical_amplifier" title="wikilink">oscilloscopes</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and digital telecommunication systems.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Mathematically, a Gaussian filter modifies the input signal by <a class="uri" href="convolution" title="wikilink">convolution</a> with a Gaussian function; this transformation is also known as the <a href="Weierstrass_transform" title="wikilink">Weierstrass transform</a>.</p>
<h2 id="definition">Definition</h2>

<p>The one-dimensional Gaussian filter has an impulse response given by</p>

<p>

<math display="block" id="Gaussian_filter:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msqrt>
     <mfrac>
      <mi>a</mi>
      <mi>π</mi>
     </mfrac>
    </msqrt>
    <mo>⋅</mo>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>a</mi>
       <mo>⋅</mo>
       <msup>
        <mi>x</mi>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <root></root>
      <apply>
       <divide></divide>
       <ci>a</ci>
       <ci>π</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <ci>normal-⋅</ci>
        <ci>a</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)=\sqrt{\frac{a}{\pi}}\cdot e^{-a\cdot x^{2}}
  </annotation>
 </semantics>
</math>

 and the frequency response is given by the <a href="Fourier_transform#Square-integrable_functions" title="wikilink">Fourier transform</a></p>

<p>

<math display="block" id="Gaussian_filter:1">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <msup>
        <mi>π</mi>
        <mn>2</mn>
       </msup>
       <msup>
        <mi>f</mi>
        <mn>2</mn>
       </msup>
      </mrow>
      <mi>a</mi>
     </mfrac>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>g</ci>
     </apply>
     <ci>f</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>π</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>a</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{g}(f)=e^{-\frac{\pi^{2}f^{2}}{a}}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Gaussian_filter:2">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 the ordinary frequency. These equations can also be expressed with the <a href="standard_deviation" title="wikilink">standard deviation</a> as parameter</p>

<p>

<math display="block" id="Gaussian_filter:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <msqrt>
       <mrow>
        <mn>2</mn>
        <mi>π</mi>
       </mrow>
      </msqrt>
      <mo>⋅</mo>
      <mi>σ</mi>
     </mrow>
    </mfrac>
    <mo>⋅</mo>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mfrac>
       <msup>
        <mi>x</mi>
        <mn>2</mn>
       </msup>
       <mrow>
        <mn>2</mn>
        <msup>
         <mi>σ</mi>
         <mn>2</mn>
        </msup>
       </mrow>
      </mfrac>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <root></root>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>π</ci>
        </apply>
       </apply>
       <ci>σ</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>σ</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)=\frac{1}{\sqrt{2\pi}\cdot\sigma}\cdot e^{-\frac{x^{2}}{2\sigma^{2}}}
  </annotation>
 </semantics>
</math>

 and the frequency response is given by</p>

<p>

<math display="block" id="Gaussian_filter:4">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <mfrac>
      <msup>
       <mi>f</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <mn>2</mn>
       <msubsup>
        <mi>σ</mi>
        <mi>f</mi>
        <mn>2</mn>
       </msubsup>
      </mrow>
     </mfrac>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>g</ci>
     </apply>
     <ci>f</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>σ</ci>
          <ci>f</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{g}(f)=e^{-\frac{f^{2}}{2\sigma_{f}^{2}}}
  </annotation>
 </semantics>
</math>

 By writing 

<math display="inline" id="Gaussian_filter:5">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 as a function of 

<math display="inline" id="Gaussian_filter:6">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 with the two equations for 

<math display="inline" id="Gaussian_filter:7">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)
  </annotation>
 </semantics>
</math>

 and as a function of 

<math display="inline" id="Gaussian_filter:8">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{f}
  </annotation>
 </semantics>
</math>

 with the two equations for 

<math display="inline" id="Gaussian_filter:9">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>g</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>g</ci>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{g}(f)
  </annotation>
 </semantics>
</math>

 it can be shown that the product of the standard deviation and the standard deviation in the frequency domain is given by</p>

<p>

<math display="block" id="Gaussian_filter:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mo>⋅</mo>
    <msub>
     <mi>σ</mi>
     <mi>f</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mn>2</mn>
     <mi>π</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <ci>σ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>π</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\cdot\sigma_{f}=\frac{1}{2\pi}
  </annotation>
 </semantics>
</math>

, where the standard deviations are expressed in their physical units, e.g. in the case of time and frequency in seconds and Hertz.</p>

<p>In two dimensions, it is the product of two such Gaussians, one per direction:</p>

<p>

<math display="block" id="Gaussian_filter:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
      <msup>
       <mi>σ</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mfrac>
    <mo>⋅</mo>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mfrac>
       <mrow>
        <msup>
         <mi>x</mi>
         <mn>2</mn>
        </msup>
        <mo>+</mo>
        <msup>
         <mi>y</mi>
         <mn>2</mn>
        </msup>
       </mrow>
       <mrow>
        <mn>2</mn>
        <msup>
         <mi>σ</mi>
         <mn>2</mn>
        </msup>
       </mrow>
      </mfrac>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>σ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>y</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>σ</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x,y)=\frac{1}{2\pi\sigma^{2}}\cdot e^{-\frac{x^{2}+y^{2}}{2\sigma^{2}}}
  </annotation>
 </semantics>
</math>

 <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>where <em>x</em> is the distance from the origin in the horizontal axis, <em>y</em> is the distance from the origin in the vertical axis, and <em>σ</em> is the <a href="standard_deviation" title="wikilink">standard deviation</a> of the Gaussian distribution.</p>
<h2 id="digital-implementation">Digital implementation</h2>

<p>The Gaussian function is non-zero for 

<math display="inline" id="Gaussian_filter:12">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>-</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">∞</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <interval closure="open">
     <apply>
      <minus></minus>
      <infinity></infinity>
     </apply>
     <infinity></infinity>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in(-\infty,\infty)
  </annotation>
 </semantics>
</math>

 and would theoretically require an infinite window length. However, since it decays rapidly, it is often reasonable to truncate the filter window and implement the filter directly for narrow windows, in effect by using a simple rectangular window function. In other cases, the truncation may introduce significant errors. Better results can be achieved by instead using a different <a href="window_function" title="wikilink">window function</a>; see <a href="scale_space_implementation" title="wikilink">scale space implementation</a> for details.</p>

<p>Filtering involves convolution. The filter function is said to be the kernel of an integral transform. The Gaussian kernel is continuous. Most commonly, the discrete equivalent is the <a href="sampled_Gaussian_kernel" title="wikilink">sampled Gaussian kernel</a> that is produced by sampling points from the continuous Gaussian. An alternate method is to use the <a href="discrete_Gaussian_kernel" title="wikilink">discrete Gaussian kernel</a> which has superior characteristics for some purposes. Unlike the sampled Gaussian kernel, the discrete Gaussian kernel is the solution to the discrete <a href="diffusion_equation" title="wikilink">diffusion equation</a>.</p>

<p>Since the <a href="Fourier_transform" title="wikilink">Fourier transform</a> of the Gaussian function yields a Gaussian function, the signal (preferably after being divided into overlapping windowed blocks) can be transformed with a <a href="Fast_Fourier_transform" title="wikilink">Fast Fourier transform</a>, multiplied with a Gaussian function and transformed back. This is the standard procedure of applying an arbitrary <a href="finite_impulse_response" title="wikilink">finite impulse response</a> filter, with the only difference that the Fourier transform of the filter window is explicitly known.</p>

<p>Due to the <a href="central_limit_theorem" title="wikilink">central limit theorem</a>, the Gaussian can be approximated by several runs of a very simple filter such as the <a href="moving_average" title="wikilink">moving average</a>. The simple moving average corresponds to <a class="uri" href="convolution" title="wikilink">convolution</a> with the constant <a class="uri" href="B-spline" title="wikilink">B-spline</a> ( a rectangular pulse ), and, for example, four iterations of a moving average yields a cubic B-spline as filter window which approximates the Gaussian quite well.</p>

<p>In the discrete case the standard deviations are related by</p>

<p>

<math display="block" id="Gaussian_filter:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mo>⋅</mo>
    <msub>
     <mi>σ</mi>
     <mi>f</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mi>N</mi>
    <mrow>
     <mn>2</mn>
     <mi>π</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <ci>σ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <ci>N</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>π</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\cdot\sigma_{f}=\frac{N}{2\pi}
  </annotation>
 </semantics>
</math>

, where the standard deviations are expressed in number of samples and <em>N</em> is the total number of samples. Borrowing the terms from statistics, the <a href="standard_deviation" title="wikilink">standard deviation</a> of a filter can be interpreted as a measure of its size. The cut-off frequency of a Gaussian filter might be defined by the standard deviation in the frequency domain yielding</p>

<p>

<math display="block" id="Gaussian_filter:14">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>c</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>σ</mi>
    <mi>f</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mn>2</mn>
     <mi>π</mi>
     <mi>σ</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>σ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{c}=\sigma_{f}=\frac{1}{2\pi\sigma}
  </annotation>
 </semantics>
</math>

, where all quantities are expressed in their physical units. If 

<math display="inline" id="Gaussian_filter:15">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 is measured in samples the cut-off frequency (in physical units) can be calculated with</p>

<p>

<math display="block" id="Gaussian_filter:16">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>c</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mi>F</mi>
     <mi>s</mi>
    </msub>
    <mrow>
     <mn>2</mn>
     <mi>π</mi>
     <mi>σ</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>c</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>π</ci>
      <ci>σ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{c}=\frac{F_{s}}{2\pi\sigma}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Gaussian_filter:17">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{s}
  </annotation>
 </semantics>
</math>

 is the sample rate. The response value of the Gaussian filter at this cut-off frequency equals exp(-0.5)≈0.607.</p>

<p>However, it is more common to define the cut-off frequency as the half power point: where the filter response is reduced to 0.5 ( -3 dB ) in the power spectrum, or 1/

<math display="inline" id="Gaussian_filter:18">
 <semantics>
  <msqrt>
   <mn>2</mn>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{2}
  </annotation>
 </semantics>
</math>

 ≈ 0.707 in the amplitude spectrum (see e.g. <a href="Butterworth_filter#Original_paper" title="wikilink">Butterworth filter</a>). For an arbitrary cut-off value 1/<em>c</em> for the response of the filter the cut-off frequency is given by</p>

<p>

<math display="block" id="Gaussian_filter:19">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>c</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msqrt>
     <mrow>
      <mn>2</mn>
      <mrow>
       <mi>ln</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msqrt>
    <mo>⋅</mo>
    <msub>
     <mi>σ</mi>
     <mi>f</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>c</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <root></root>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <ln></ln>
        <ci>c</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{c}=\sqrt{2\ln(c)}\cdot\sigma_{f}
  </annotation>
 </semantics>
</math>

 For <em>c</em>=2 the constant before the standard deviation in the frequency domain in the last equation equals approximately 1.1774, which is half the Full Width at Half Maximum (FWHM) (see <a href="Gaussian_function#Properties" title="wikilink">Gaussian function</a>). For <em>c</em>=

<math display="inline" id="Gaussian_filter:20">
 <semantics>
  <msqrt>
   <mn>2</mn>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{2}
  </annotation>
 </semantics>
</math>

 this constant equals approximately 0.8326. These values are quite close to 1.</p>

<p>A simple moving average corresponds to a <a href="uniform_distribution_(discrete)" title="wikilink">uniform probability distribution</a> and thus its filter width of size 

<math display="inline" id="Gaussian_filter:21">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 has standard deviation 

<math display="inline" id="Gaussian_filter:22">
 <semantics>
  <msqrt>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>n</mi>
       <mn>2</mn>
      </msup>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mn>12</mn>
   </mrow>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">12</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{({n}^{2}-1)/12}
  </annotation>
 </semantics>
</math>

. Thus the application of successive 

<math display="inline" id="Gaussian_filter:23">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 moving averages with sizes 

<math display="inline" id="Gaussian_filter:24">
 <semantics>
  <mrow>
   <msub>
    <mi>n</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>n</mi>
    <mi>m</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>m</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {n}_{1},\dots,{n}_{m}
  </annotation>
 </semantics>
</math>

 yield a standard deviation of</p>

<p>

<math display="block" id="Gaussian_filter:25">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>=</mo>
   <msqrt>
    <mfrac>
     <mrow>
      <mrow>
       <msubsup>
        <mi>n</mi>
        <mn>1</mn>
        <mn>2</mn>
       </msubsup>
       <mo>+</mo>
       <mi mathvariant="normal">⋯</mi>
       <mo>+</mo>
       <msubsup>
        <mi>n</mi>
        <mi>m</mi>
        <mn>2</mn>
       </msubsup>
      </mrow>
      <mo>-</mo>
      <mi>m</mi>
     </mrow>
     <mn>12</mn>
    </mfrac>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>σ</ci>
    <apply>
     <root></root>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <ci>normal-⋯</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>m</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
      <cn type="integer">12</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma=\sqrt{\frac{{n}_{1}^{2}+\cdots+{n}_{m}^{2}-m}{12}}
  </annotation>
 </semantics>
</math>

. (Note that standard deviations do not sum up, but <a href="variance" title="wikilink">variances</a> do.)</p>

<p>A gaussian kernel requires 

<math display="inline" id="Gaussian_filter:26">
 <semantics>
  <mrow>
   <mrow>
    <mn>6</mn>
    <mi>σ</mi>
   </mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <cn type="integer">6</cn>
     <ci>σ</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   6{\sigma}-1
  </annotation>
 </semantics>
</math>

 values, e.g. for a 

<math display="inline" id="Gaussian_filter:27">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\sigma}
  </annotation>
 </semantics>
</math>

 of 3 it needs a kernel of length 17. A running mean filter of 5 points will have a sigma of 

<math display="inline" id="Gaussian_filter:28">
 <semantics>
  <msqrt>
   <mn>2</mn>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\sqrt{2}}
  </annotation>
 </semantics>
</math>

. Running it three times will give a 

<math display="inline" id="Gaussian_filter:29">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\sigma}
  </annotation>
 </semantics>
</math>

 of 2.42. It remains to be seen where the advantage is over using a gaussian rather than a poor approximation.</p>

<p>When applied in two dimensions, this formula produces a Gaussian surface that has a maximum at the origin, whose <a href=":wikt:contour" title="wikilink">contours</a> are <a href="concentric_circles" title="wikilink">concentric circles</a> with the origin as center. A two dimensional <a class="uri" href="convolution" title="wikilink">convolution</a> <a href="Matrix_(mathematics)" title="wikilink">matrix</a> is precomputed from the formula and convolved with two dimensional data. Each element in the resultant matrix new value is set to a <a href="weighted_average" title="wikilink">weighted average</a> of that elements neighborhood. The focal element receives the heaviest weight (having the highest Gaussian value) and neighboring elements receive smaller weights as their distance to the focal element increases. In Image processing, each element in the matrix represents a pixel attribute such as brightness or a color intensity, and the overall effect is called <a href="Gaussian_blur" title="wikilink">Gaussian blur</a>.</p>

<p>The Gaussian filter is non-causal which means the filter window is symmetric about the origin in the time-domain. This makes the Gaussian filter physically unrealizable. This is usually of no consequence for applications where the filter bandwidth is much larger than the signal. In real-time systems, a delay is incurred because incoming samples need to fill the filter window before the filter can be applied to the signal. While no amount of delay can make a theoretical Gaussian filter causal (because the Gaussian function is non-zero everywhere), the Gaussian function converges to zero so rapidly that a causal approximation can achieve any required tolerance with a modest delay, even to the accuracy of <a href="IEEE_floating_point" title="wikilink">floating point representation</a>.</p>
<h2 id="applications">Applications</h2>
<ul>
<li><a class="uri" href="GSM" title="wikilink">GSM</a> since it applies <a class="uri" href="GMSK" title="wikilink">GMSK</a> modulation</li>
<li>the Gaussian filter is also used in <a class="uri" href="GFSK" title="wikilink">GFSK</a>.</li>
<li><a href="Canny_edge_detector" title="wikilink">Canny Edge Detector</a> used in image processing.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Butterworth_filter" title="wikilink">Butterworth filter</a></li>
<li><a href="Comb_filter" title="wikilink">Comb filter</a></li>
<li><a href="Chebyshev_filter" title="wikilink">Chebyshev filter</a></li>
<li><a href="Discrete_Gaussian_kernel" title="wikilink">Discrete Gaussian kernel</a></li>
<li><a href="Elliptic_filter" title="wikilink">Elliptic filter</a></li>
<li><a href="Gaussian_blur" title="wikilink">Gaussian blur</a></li>
<li><a href="Gaussian_Pyramid" title="wikilink">Gaussian Pyramid</a></li>
<li><a href="Scale_space" title="wikilink">Scale space</a></li>
<li><a href="Scale_space_implementation" title="wikilink">Scale space implementation</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Linear_filters" title="wikilink">Category:Linear filters</a> <a href="Category:Gaussian_function" title="wikilink">Category:Gaussian function</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Filtering in the Time and Frequency Domains by Herman J. Blinchikoff, Anatol I. Zverev<a href="#fnref1">↩</a></li>
<li id="fn2"><a class="uri" href="http://www.radiomuseum.org/forumdata/users/4767/file/Tektronix_VerticalAmplifierCircuits_Part1.pdf">http://www.radiomuseum.org/forumdata/users/4767/file/Tektronix_VerticalAmplifierCircuits_Part1.pdf</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a class="uri" href="http://www.picosecond.com/objects/AN-7a.pdf">http://www.picosecond.com/objects/AN-7a.pdf</a><a href="#fnref3">↩</a></li>
<li id="fn4">R.A. Haddad and A.N. Akansu, "A Class of Fast Gaussian Binomial Filters for Speech and Image Processing," IEEE Transactions on Acoustics, Speech and Signal Processing, vol. 39, pp 723-727, March 1991.<a href="#fnref4">↩</a></li>
<li id="fn5">Shapiro, L. G. &amp; Stockman, G. C: "Computer Vision", page 137, 150. Prentence Hall, 2001<a href="#fnref5">↩</a></li>
<li id="fn6">Mark S. Nixon and Alberto S. Aguado. <em>Feature Extraction and Image Processing</em>. Academic Press, 2008, p. 88.<a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
