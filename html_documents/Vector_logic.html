<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1954">Vector logic</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Vector logic</h1>
<hr/>

<p><strong>Vector logic</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> is an <a href="Algebra" title="wikilink"> algebraic</a> <a href="Mathematical_model" title="wikilink"> model</a> of elementary <a class="uri" href="logic" title="wikilink">logic</a> based on <a href="Matrix_(mathematics)" title="wikilink">matrix algebra</a>. Vector logic assumes that the <a href="truth_value" title="wikilink">truth values</a> map on <a href="Vector_(mathematics_and_physics)" title="wikilink"> vectors</a>, and that the <a href="Monadic_predicate_calculus" title="wikilink"> monadic</a> and <a href="Binary_function" title="wikilink"> dyadic</a> operations are executed by matrix operators.</p>
<h2 id="overview">Overview</h2>

<p>Classic <a href="Truth_value#Classical_logic" title="wikilink"> binary</a> logic is represented by a small set of mathematical functions depending on one (monadic ) or two (dyadic) variables. In the binary set, the value 1 corresponds to <em><a href="True_(logic)" title="wikilink">true</a></em> and the value 0 to <em><a href="False_(logic)" title="wikilink"> false</a></em>. A two-valued vector logic requires a correspondence between the truth-values <em>true</em> (t) and <em>false</em> (f), and two <em>q</em>-dimensional normalized column vectors composed by real numbers <em>s</em> and <em>n</em>, hence:</p>

<p>

<math display="block" id="Vector_logic:0">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>↦</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>t</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\mapsto s
  </annotation>
 </semantics>
</math>

    and    

<math display="inline" id="Vector_logic:1">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>↦</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\mapsto n
  </annotation>
 </semantics>
</math>

</p>

<p>(where 

<math display="inline" id="Vector_logic:2">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>≥</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>q</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\geq 2
  </annotation>
 </semantics>
</math>

 is an arbitrary natural number, and “normalized” means that the <a href="Euclidean_norm" title="wikilink">length</a> of the vector is 1; usually s and n are orthogonal vectors). This correspondence generates a space of vector truth-values: <em>V</em><sub>2</sub> = {<em>s</em>,<em>n</em>}. The basic logical operations defined using this set of vectors lead to matrix operators.</p>

<p>The operations of vector logic are based on the scalar product between <em>q</em>-dimensional column vectors

<math display="block" id="Vector_logic:3">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>u</mi>
     <mi>T</mi>
    </msup>
    <mi>v</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>u</ci>
      <ci>T</ci>
     </apply>
     <ci>v</ci>
    </apply>
    <list>
     <ci>u</ci>
     <ci>v</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u^{T}v=\langle u,v\rangle
  </annotation>
 </semantics>
</math>

: the orthonormality between vectors <em>s</em> and <em>n</em> implies that 

<math display="inline" id="Vector_logic:4">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>u</ci>
     <ci>v</ci>
    </list>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle u,v\rangle=1
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Vector_logic:5">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>=</mo>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>u</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u=v
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Vector_logic:6">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>u</ci>
     <ci>v</ci>
    </list>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle u,v\rangle=0
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Vector_logic:7">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>≠</mo>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>u</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\neq v
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="monadic-operators">Monadic operators</h3>

<p>The monadic operators result from the application 

<math display="inline" id="Vector_logic:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mi>o</mi>
    <mi>n</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>V</mi>
     <mn>2</mn>
    </msub>
    <mo>→</mo>
    <msub>
     <mi>V</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>M</ci>
     <ci>o</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Mon:V_{2}\to V_{2}
  </annotation>
 </semantics>
</math>

, and the associated matrices have <em>q</em> rows and <em>q</em> columns. The two basic monadic operators for this two-valued vector logic are the <a href="Identity_function" title="wikilink">identity</a> and the <a href="Logical_negation" title="wikilink">negation</a>:</p>
<ul>
<li><strong>Identity</strong>: A logical identity ID(p)is represented by matrix 

<math display="inline" id="Vector_logic:9">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>s</mi>
     <msup>
      <mi>s</mi>
      <mi>T</mi>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>n</mi>
     <msup>
      <mi>n</mi>
      <mi>T</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>I</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I=ss^{T}+nn^{T}
  </annotation>
 </semantics>
</math>

. This matrix operates as follows: <em>Ip</em> = <em>p</em>, <em>p</em> ∈ <em>V</em><sub>2</sub>; due to the orthogonality of <em>s</em> respect to <em>n</em>, we have 

<math display="inline" id="Vector_logic:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mi>s</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>s</mi>
     <msup>
      <mi>s</mi>
      <mi>T</mi>
     </msup>
     <mi>s</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>n</mi>
     <msup>
      <mi>n</mi>
      <mi>T</mi>
     </msup>
     <mi>s</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>s</mi>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>n</mi>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>I</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>s</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <ci>T</ci>
       </apply>
       <ci>s</ci>
      </apply>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <ci>T</ci>
       </apply>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>s</ci>
       <list>
        <ci>s</ci>
        <ci>s</ci>
       </list>
      </apply>
      <apply>
       <times></times>
       <ci>n</ci>
       <list>
        <ci>n</ci>
        <ci>s</ci>
       </list>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Is=ss^{T}s+nn^{T}s=s\langle s,s\rangle+n\langle n,s\rangle=s
  </annotation>
 </semantics>
</math>

,   and conversely 

<math display="inline" id="Vector_logic:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mi>n</mi>
   </mrow>
   <mo>=</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>I</ci>
     <ci>n</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   In=n
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li><strong>Negation</strong>: A logical negation ¬p is represented by matrix 

<math display="inline" id="Vector_logic:12">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>n</mi>
     <msup>
      <mi>s</mi>
      <mi>T</mi>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>s</mi>
     <msup>
      <mi>n</mi>
      <mi>T</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=ns^{T}+sn^{T}
  </annotation>
 </semantics>
</math>

 Consequently, <em>Ns</em> = <em>n</em> and <em>Nn</em> = <em>s</em>. The <a href="Involution_(mathematics)" title="wikilink">involutory</a> behavior of the logical negation, namely that ¬(¬<em>p</em>) equals <em>p</em>, corresponds with the fact that <em>N</em><sup>2</sup> = <em>I</em>. Is important to note that this vector logic identity matrix is not generally an <a href="identity_matrix" title="wikilink">identity matrix</a> in the sense of matrix algebra.</li>
</ul>
<h3 id="dyadic-operators">Dyadic operators</h3>

<p>The 16 two-valued dyadic operators correspond to functions of the type 

<math display="inline" id="Vector_logic:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mi>y</mi>
    <mi>a</mi>
    <mi>d</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>V</mi>
      <mn>2</mn>
     </msub>
     <mo>⊗</mo>
     <msub>
      <mi>V</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>→</mo>
    <msub>
     <mi>V</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>y</ci>
     <ci>a</ci>
     <ci>d</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Dyad:V_{2}\otimes V_{2}\to V_{2}
  </annotation>
 </semantics>
</math>

; the dyadic matrices have <em>q</em> rows and <em>q</em><sup>2</sup> columns. The matrices that execute these dyadic operations are based on the properties of the <a href="Kronecker_product" title="wikilink">Kronecker product</a>.</p>

<p>Two properties of this product are essential for the formalism of vector logic: </p>

<p>Using these properties, expressions for dyadic logic functions can be obtained:</p>
<ul>
<li><strong><a href="∧" title="wikilink">Conjunction</a></strong>. The conjunction (p∧q) is executed by a matrix that acts on two vector truth-values

<math display="block" id="Vector_logic:14">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>u</mi>
     <mo>⊗</mo>
     <mi>v</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>u</ci>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(u\otimes v)
  </annotation>
 </semantics>
</math>

 .This matrix reproduces the features of the classical conjunction truth-table in its formulation:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Vector_logic:15">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>s</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>s</mi>
        <mo>⊗</mo>
        <mi>s</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>T</mi>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>n</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>s</mi>
        <mo>⊗</mo>
        <mi>n</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>T</mi>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>n</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>⊗</mo>
        <mi>s</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>T</mi>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>n</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>⊗</mo>
        <mi>n</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>T</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>s</ci>
        <ci>s</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>s</ci>
        <ci>n</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>n</ci>
        <ci>s</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>n</ci>
        <ci>n</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=s(s\otimes s)^{T}+n(s\otimes n)^{T}+n(n\otimes s)^{T}+n(n\otimes n)^{T}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>and verifies
</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Vector_logic:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>s</mi>
       <mo>⊗</mo>
       <mi>s</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>s</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>s</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(s\otimes s)=s,
  </annotation>
 </semantics>
</math>

 and
</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Vector_logic:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>s</mi>
       <mo>⊗</mo>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>⊗</mo>
       <mi>s</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>⊗</mo>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>n</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>C</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>s</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>C</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>n</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>C</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>n</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(s\otimes n)=C(n\otimes s)=C(n\otimes n)=n.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li><strong><a href="∨" title="wikilink">Disjunction</a></strong>. The disjunction (p∨q) is executed by the matrix</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Vector_logic:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>s</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>s</mi>
         <mo>⊗</mo>
         <mi>s</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>T</mi>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>s</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>s</mi>
         <mo>⊗</mo>
         <mi>n</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>T</mi>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>s</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>⊗</mo>
         <mi>s</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>T</mi>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>n</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>⊗</mo>
         <mi>n</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>T</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>s</ci>
        <ci>s</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>s</ci>
        <ci>n</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>n</ci>
        <ci>s</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>n</ci>
        <ci>n</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=s(s\otimes s)^{T}+s(s\otimes n)^{T}+s(n\otimes s)^{T}+n(n\otimes n)^{T},
  </annotation>
 </semantics>
</math>

 resulting in
</dd>
<dd>

<math display="inline" id="Vector_logic:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>s</mi>
      <mo>⊗</mo>
      <mi>s</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>s</mi>
      <mo>⊗</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>⊗</mo>
      <mi>s</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>D</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>s</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>D</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>s</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>D</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>n</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(s\otimes s)=D(s\otimes n)=D(n\otimes s)=s
  </annotation>
 </semantics>
</math>

 and
</dd>
<dd>

<math display="inline" id="Vector_logic:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>⊗</mo>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>n</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>n</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(n\otimes n)=n.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li><strong><a href="Logical_implication" title="wikilink">Implication</a></strong>. The implication corresponds in classical logic to the expression p → q ≡ ¬p ∨ q. The vector logic version of this equivalence leads to a matrix that represents this implication in vector logic

<math display="block" id="Vector_logic:21">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>N</mi>
      <mo>⊗</mo>
      <mi>I</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <apply>
     <times></times>
     <ci>D</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>N</ci>
      <ci>I</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=D(N\otimes I)
  </annotation>
 </semantics>
</math>

. The explicit expression for this implication is:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Vector_logic:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>s</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>s</mi>
         <mo>⊗</mo>
         <mi>s</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>T</mi>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>n</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>s</mi>
         <mo>⊗</mo>
         <mi>n</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>T</mi>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>s</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>⊗</mo>
         <mi>s</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>T</mi>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>n</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>⊗</mo>
         <mi>n</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>T</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>s</ci>
        <ci>s</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>s</ci>
        <ci>n</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>n</ci>
        <ci>s</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>n</ci>
        <ci>n</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=s(s\otimes s)^{T}+n(s\otimes n)^{T}+s(n\otimes s)^{T}+n(n\otimes n)^{T},
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>and the properties of classical implication are satisfied:
</dd>
<dd>

<math display="inline" id="Vector_logic:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>s</mi>
      <mo>⊗</mo>
      <mi>s</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>⊗</mo>
      <mi>s</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>⊗</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>s</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>n</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>n</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(s\otimes s)=L(n\otimes s)=L(n\otimes n)=s
  </annotation>
 </semantics>
</math>

 and
</dd>
<dd>

<math display="inline" id="Vector_logic:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>s</mi>
       <mo>⊗</mo>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>n</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>s</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(s\otimes n)=n.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li><strong><a href="Logical_equivalence" title="wikilink">Equivalence</a> and <a href="Exclusive_or" title="wikilink">Exclusive or</a></strong>. In vector logic the equivalence p≡q is represented by the following matrix:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Vector_logic:25">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>s</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>s</mi>
        <mo>⊗</mo>
        <mi>s</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>T</mi>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>n</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>s</mi>
        <mo>⊗</mo>
        <mi>n</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>T</mi>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>n</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>⊗</mo>
        <mi>s</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>T</mi>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>s</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>⊗</mo>
        <mi>n</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>T</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>E</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>s</ci>
        <ci>s</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>s</ci>
        <ci>n</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>n</ci>
        <ci>s</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>n</ci>
        <ci>n</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=s(s\otimes s)^{T}+n(s\otimes n)^{T}+n(n\otimes s)^{T}+s(n\otimes n)^{T}
  </annotation>
 </semantics>
</math>

 with
</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Vector_logic:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>s</mi>
      <mo>⊗</mo>
      <mi>s</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>⊗</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>s</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>n</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(s\otimes s)=E(n\otimes n)=s
  </annotation>
 </semantics>
</math>

 and
</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Vector_logic:27">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>s</mi>
       <mo>⊗</mo>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>⊗</mo>
       <mi>s</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>n</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>s</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>n</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(s\otimes n)=E(n\otimes s)=n.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>The Exclusive or is the negation of the equivalence, ¬(p≡q); it corresponds with the matrix 

<math display="inline" id="Vector_logic:28">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <mi>N</mi>
    <mi>E</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=NE
  </annotation>
 </semantics>
</math>

 given by
</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Vector_logic:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>n</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>s</mi>
         <mo>⊗</mo>
         <mi>s</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>T</mi>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>s</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>s</mi>
         <mo>⊗</mo>
         <mi>n</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>T</mi>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>s</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>⊗</mo>
         <mi>s</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>T</mi>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>n</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>⊗</mo>
         <mi>n</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>T</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>s</ci>
        <ci>s</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>s</ci>
        <ci>n</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>n</ci>
        <ci>s</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>n</ci>
        <ci>n</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=n(s\otimes s)^{T}+s(s\otimes n)^{T}+s(n\otimes s)^{T}+n(n\otimes n)^{T},
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>with 

<math display="inline" id="Vector_logic:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>s</mi>
      <mo>⊗</mo>
      <mi>s</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>⊗</mo>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>X</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>s</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>X</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>n</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(s\otimes s)=X(n\otimes n)=n
  </annotation>
 </semantics>
</math>

 and
</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Vector_logic:31">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>s</mi>
       <mo>⊗</mo>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>X</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>⊗</mo>
       <mi>s</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>s</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>X</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>s</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>X</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>n</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(s\otimes n)=X(n\otimes s)=s.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li><strong><a href="Sheffer_stroke" title="wikilink">NAND</a> and <a href="Peirce_arrow" title="wikilink">NOR</a></strong></li>
</ul>

<p>The matrices <em>S</em> and <em>P</em> correspond to the <a href="Sheffer_stroke" title="wikilink">Sheffer</a> (NAND) and the <a href="Logical_NOR" title="wikilink">Peirce</a> (NOR) operations, respectively:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Vector_logic:32">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mi>N</mi>
    <mi>C</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=NC
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Vector_logic:33">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mi>N</mi>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=ND
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h3 id="de-morgans-law">De Morgan's law</h3>

<p>In the two-valued logic, the conjunction and the disjunction operations satisfy the <a href="De_Morgan's_Laws" title="wikilink">De Morgan's law</a>: p∧q≡¬(¬p∨¬q), and its dual: p∨q≡¬(¬p∧¬q)). For the two-valued vector logic this Law is also verified:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Vector_logic:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>u</mi>
      <mo>⊗</mo>
      <mi>v</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>N</mi>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>N</mi>
        <mi>u</mi>
       </mrow>
       <mo>⊗</mo>
       <mi>N</mi>
      </mrow>
      <mi>v</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>u</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>D</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <ci>N</ci>
        <ci>u</ci>
       </apply>
       <ci>N</ci>
      </apply>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(u\otimes v)=ND(Nu\otimes Nv)
  </annotation>
 </semantics>
</math>

, where <em>u</em> and <em>v</em> are two logic vectors.
</dd>
</dl>
</dd>
</dl>

<p>The Kronecker product implies the following factorization:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Vector_logic:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>u</mi>
       <mo>⊗</mo>
       <mi>v</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>N</mi>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>N</mi>
       <mo>⊗</mo>
       <mi>N</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>u</mi>
       <mo>⊗</mo>
       <mi>v</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>u</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>D</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>N</ci>
      <ci>N</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>u</ci>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(u\otimes v)=ND(N\otimes N)(u\otimes v).
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Then it can be proved that in the two–dimensional vector logic the De Morgan's law is a law involving operators, and not only a law concerning operations:<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Vector_logic:36">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mi>N</mi>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>N</mi>
      <mo>⊗</mo>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>D</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>N</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=ND(N\otimes N)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h3 id="law-of-contraposition">Law of contraposition</h3>

<p>In the classical propositional calculus, the <a href="Contraposition_(traditional_logic)" title="wikilink">Law of Contraposition</a> <em>p</em> → <em>q</em> ≡ ¬<em>q</em> → ¬<em>p</em> is proved because the equivalence holds for all the possible combinations of truth-values of <em>p</em> and <em>q</em>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Instead, in vector logic, the law of contraposition emerges from a chain of equalities within the rules of matrix algebra and Kronecker products, as shown in what follows:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Vector_logic:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>u</mi>
      <mo>⊗</mo>
      <mi>v</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>N</mi>
      <mo>⊗</mo>
      <mi>I</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>u</mi>
      <mo>⊗</mo>
      <mi>v</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>N</mi>
       <mi>u</mi>
      </mrow>
      <mo>⊗</mo>
      <mi>v</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>N</mi>
        <mi>u</mi>
       </mrow>
       <mo>⊗</mo>
       <mi>N</mi>
      </mrow>
      <mi>N</mi>
      <mi>v</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>u</ci>
       <ci>v</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>D</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>N</ci>
       <ci>I</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>u</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>D</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <ci>N</ci>
        <ci>u</ci>
       </apply>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>D</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <apply>
         <times></times>
         <ci>N</ci>
         <ci>u</ci>
        </apply>
        <ci>N</ci>
       </apply>
       <ci>N</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <csymbol cd="latexml">absent</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(u\otimes v)=D(N\otimes I)(u\otimes v)=D(Nu\otimes v)=D(Nu\otimes NNv)=
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Vector_logic:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>N</mi>
        <mi>N</mi>
        <mi>v</mi>
       </mrow>
       <mo>⊗</mo>
       <mi>N</mi>
      </mrow>
      <mi>u</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>N</mi>
      <mo>⊗</mo>
      <mi>I</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>N</mi>
        <mi>v</mi>
       </mrow>
       <mo>⊗</mo>
       <mi>N</mi>
      </mrow>
      <mi>u</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>N</mi>
        <mi>v</mi>
       </mrow>
       <mo>⊗</mo>
       <mi>N</mi>
      </mrow>
      <mi>u</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>D</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <apply>
         <times></times>
         <ci>N</ci>
         <ci>N</ci>
         <ci>v</ci>
        </apply>
        <ci>N</ci>
       </apply>
       <ci>u</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>D</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>N</ci>
       <ci>I</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <apply>
         <times></times>
         <ci>N</ci>
         <ci>v</ci>
        </apply>
        <ci>N</ci>
       </apply>
       <ci>u</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <apply>
         <times></times>
         <ci>N</ci>
         <ci>v</ci>
        </apply>
        <ci>N</ci>
       </apply>
       <ci>u</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(NNv\otimes Nu)=D(N\otimes I)(Nv\otimes Nu)=L(Nv\otimes Nu)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>This result is based in the fact that <em>D</em>, the disjunction matrix, represents a commutative operation.</p>
<h2 id="many-valued-two-dimensional-logic">Many-valued two-dimensional logic</h2>

<p><a href="Many-valued_logic" title="wikilink">Many-valued logic</a> was developed by many researchers, particularly by <a href="Jan_Łukasiewicz" title="wikilink">Jan Łukasiewicz</a> and allows extending logical operations to truth-values that include uncertainties.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> In the case of two-valued vector logic, uncertainties in the truth values can be introduced using vectors with <em>s</em> and <em>n</em> weighted by probabilities.</p>

<p>Let 

<math display="inline" id="Vector_logic:39">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>ϵ</mi>
     <mi>s</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>δ</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>f</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>ϵ</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <ci>δ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=\epsilon s+\delta n
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Vector_logic:40">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ϵ</mi>
     <mo>,</mo>
     <mi>δ</mi>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>ϵ</mi>
     <mo>+</mo>
     <mi>δ</mi>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <list>
      <ci>ϵ</ci>
      <ci>δ</ci>
     </list>
     <interval closure="closed">
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </interval>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <ci>ϵ</ci>
      <ci>δ</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon,\delta\in[0,1],\epsilon+\delta=1
  </annotation>
 </semantics>
</math>

 be this kind of “probabilistic” vectors. Here, the many-valued character of the logic is introduced <a href="A_priori_and_a_posteriori" title="wikilink"><em>a posteriori</em></a> via the uncertainties introduced in the inputs.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h3 id="scalar-projections-of-vector-outputs">Scalar projections of vector outputs</h3>

<p>The outputs of this many-valued logic can be projected on scalar functions and generate a particular class of probabilistic logic with similarities with the many-valued logic of Reichenbach.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Given two vectors 

<math display="inline" id="Vector_logic:41">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mi>s</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>β</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>u</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>α</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <ci>β</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u=\alpha s+\beta n
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Vector_logic:42">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>α</mi>
      <mo>′</mo>
     </msup>
     <mi>s</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msup>
      <mi>β</mi>
      <mo>′</mo>
     </msup>
     <mi>n</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>v</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>α</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>β</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v=\alpha^{\prime}s+\beta^{\prime}n
  </annotation>
 </semantics>
</math>

 and a dyadic logical matrix 

<math display="inline" id="Vector_logic:43">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, a scalar probabilistic logic is provided by the projection over vector <em>s</em>:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Vector_logic:44">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mi>a</mi>
    <mi>l</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>scalars</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>s</mi>
     <mi>T</mi>
    </msup>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>vectors</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>a</ci>
     <ci>l</ci>
     <ci>scalars</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>T</ci>
     </apply>
     <ci>G</ci>
     <ci>vectors</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Val(\mathrm{scalars})=s^{T}G(\mathrm{vectors})
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Here are the main results of these projections:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Vector_logic:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <mi>O</mi>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>α</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>s</mi>
     <mi>T</mi>
    </msup>
    <mi>N</mi>
    <mi>u</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>N</ci>
      <ci>O</ci>
      <ci>T</ci>
      <ci>α</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>T</ci>
      </apply>
      <ci>N</ci>
      <ci>u</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>α</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   NOT(\alpha)=s^{T}Nu=1-\alpha
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Vector_logic:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>O</mi>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>α</mi>
     <mo>,</mo>
     <msup>
      <mi>α</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>s</mi>
     <mi>T</mi>
    </msup>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>u</mi>
      <mo>⊗</mo>
      <mi>v</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mo>+</mo>
     <msup>
      <mi>α</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>α</mi>
     <msup>
      <mi>α</mi>
      <mo>′</mo>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>R</ci>
      <interval closure="open">
       <ci>α</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>α</ci>
        <ci>normal-′</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>T</ci>
      </apply>
      <ci>D</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>u</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <ci>α</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>α</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>α</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>α</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   OR(\alpha,\alpha^{\prime})=s^{T}D(u\otimes v)=\alpha+\alpha^{\prime}-\alpha%
\alpha^{\prime}
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Vector_logic:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>N</mi>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>α</mi>
     <mo>,</mo>
     <msup>
      <mi>α</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>s</mi>
     <mi>T</mi>
    </msup>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>u</mi>
      <mo>⊗</mo>
      <mi>v</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>α</mi>
    <msup>
     <mi>α</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>N</ci>
      <ci>D</ci>
      <interval closure="open">
       <ci>α</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>α</ci>
        <ci>normal-′</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>T</ci>
      </apply>
      <ci>C</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>u</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>α</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>α</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   AND(\alpha,\alpha^{\prime})=s^{T}C(u\otimes v)=\alpha\alpha^{\prime}
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Vector_logic:48">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mi>M</mi>
    <mi>P</mi>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>α</mi>
     <mo>,</mo>
     <msup>
      <mi>α</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>s</mi>
     <mi>T</mi>
    </msup>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>u</mi>
      <mo>⊗</mo>
      <mi>v</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mi>α</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <msup>
        <mi>α</mi>
        <mo>′</mo>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>I</ci>
      <ci>M</ci>
      <ci>P</ci>
      <ci>L</ci>
      <interval closure="open">
       <ci>α</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>α</ci>
        <ci>normal-′</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>T</ci>
      </apply>
      <ci>L</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>u</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>α</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>α</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   IMPL(\alpha,\alpha^{\prime})=s^{T}L(u\otimes v)=1-\alpha(1-\alpha^{\prime})
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Vector_logic:49">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mi>O</mi>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>α</mi>
     <mo>,</mo>
     <msup>
      <mi>α</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>s</mi>
     <mi>T</mi>
    </msup>
    <mi>X</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>u</mi>
      <mo>⊗</mo>
      <mi>v</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mo>+</mo>
     <msup>
      <mi>α</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <mi>α</mi>
     <msup>
      <mi>α</mi>
      <mo>′</mo>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>O</ci>
      <ci>R</ci>
      <interval closure="open">
       <ci>α</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>α</ci>
        <ci>normal-′</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>T</ci>
      </apply>
      <ci>X</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>u</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <ci>α</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>α</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>α</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>α</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   XOR(\alpha,\alpha^{\prime})=s^{T}X(u\otimes v)=\alpha+\alpha^{\prime}-2\alpha%
\alpha^{\prime}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>The associated negations are:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Vector_logic:50">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <mi>O</mi>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>α</mi>
     <mo>,</mo>
     <msup>
      <mi>α</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mi>O</mi>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>α</mi>
      <mo>,</mo>
      <msup>
       <mi>α</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>O</ci>
     <ci>R</ci>
     <interval closure="open">
      <ci>α</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>α</ci>
       <ci>normal-′</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>R</ci>
      <interval closure="open">
       <ci>α</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>α</ci>
        <ci>normal-′</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   NOR(\alpha,\alpha^{\prime})=1-OR(\alpha,\alpha^{\prime})
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Vector_logic:51">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <mi>A</mi>
    <mi>N</mi>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>α</mi>
     <mo>,</mo>
     <msup>
      <mi>α</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mi>A</mi>
     <mi>N</mi>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>α</mi>
      <mo>,</mo>
      <msup>
       <mi>α</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>A</ci>
     <ci>N</ci>
     <ci>D</ci>
     <interval closure="open">
      <ci>α</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>α</ci>
       <ci>normal-′</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>N</ci>
      <ci>D</ci>
      <interval closure="open">
       <ci>α</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>α</ci>
        <ci>normal-′</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   NAND(\alpha,\alpha^{\prime})=1-AND(\alpha,\alpha^{\prime})
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Vector_logic:52">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mi>Q</mi>
    <mi>U</mi>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>α</mi>
     <mo>,</mo>
     <msup>
      <mi>α</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mi>X</mi>
     <mi>O</mi>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>α</mi>
      <mo>,</mo>
      <msup>
       <mi>α</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>Q</ci>
     <ci>U</ci>
     <ci>I</ci>
     <interval closure="open">
      <ci>α</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>α</ci>
       <ci>normal-′</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>O</ci>
      <ci>R</ci>
      <interval closure="open">
       <ci>α</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>α</ci>
        <ci>normal-′</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   EQUI(\alpha,\alpha^{\prime})=1-XOR(\alpha,\alpha^{\prime})
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>If the scalar values belong to the set {0, ½, 1}, this many-valued scalar logic is for many of the operators almost identical to the 3-valued logic of Łukasiewicz. Also, it has been proved that when the monadic or dyadic operators act over probabilistic vectors belonging to this set, the output is also an element of this set.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="history">History</h2>

<p>The approach has been inspired in <a href="neural_network" title="wikilink">neural network</a> models based on the use of high-dimensional matrices and vectors.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Vector logic is a direct translation into a matrix-vector formalism of the classical <a href="Boolean_algebra" title="wikilink">Boolean polynomials</a>.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> This kind of formalism has been applied to develop a <a href="fuzzy_logic" title="wikilink">fuzzy logic</a> in terms of <a href="complex_numbers" title="wikilink">complex numbers</a>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Other matrix and vector approaches to logical calculus have been developed in the framework of <a href="quantum_physics" title="wikilink">quantum physics</a>, <a href="computer_science" title="wikilink">computer science</a> and <a class="uri" href="optics" title="wikilink">optics</a>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> Early attempts to use linear algebra to represent logic operations can be referred to <a href="Charles_Sanders_Peirce" title="wikilink">Peirce</a> and <a href="Irving_Copi" title="wikilink">Copilowish</a>.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> The <a href="Indian_people" title="wikilink"> Indian</a> biophysicist <a href="G.N._Ramachandran" title="wikilink">G.N. Ramachandran</a> developed a formalism using algebraic matrices and vectors to represent many operations of classical Jain Logic known as Syad and Saptbhangi. <a href="Indian_logic" title="wikilink">Indian logic</a>.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> It requires independent affirmative evidence for each assertion in a proposition, and does not make the assumption for binary complementation.</p>
<h2 id="boolean-polynomials">Boolean polynomials</h2>

<p><a href="George_Boole" title="wikilink">George Boole</a> established the development of logical operations as polynomials.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> For the case of monadic operators (such as <a href="Identity_function" title="wikilink">identity</a> or <a href="Logical_negation" title="wikilink">negation</a>), the Boolean polynomials look as follows:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Vector_logic:53">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <cn type="integer">1</cn>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <cn type="integer">0</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=f(1)x+f(0)(1-x)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>The four different monadic operations result from the different binary values for the coefficients. Identity operation requires <em>f</em>(1) = 1 and <em>f</em>(0) = 0, and negation occurs if <em>f</em>(1) = 0 and <em>f</em>(0) = 1. For the 16 dyadic operators, the Boolean polynomials are of the form:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Vector_logic:54">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>x</mi>
     <mi>y</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>y</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>y</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>y</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <cn type="integer">1</cn>
       <cn type="integer">1</cn>
      </interval>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
      </interval>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>y</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </interval>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>x</ci>
      </apply>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </interval>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>x</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)=f(1,1)xy+f(1,0)x(1-y)+f(0,1)(1-x)y+f(0,0)(1-x)(1-y)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>The dyadic operations can be translated to this polynomial format when the coefficients <em>f</em> take the values indicated in the respective <a href="truth_table" title="wikilink">truth tables</a>. For instance: the <a href="Sheffer_stroke" title="wikilink">NAND</a> operation requires that:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Vector_logic:55">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(1,1)=0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Vector_logic:56">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(1,0)=f(0,1)=f(0,0)=1
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
</dd>
</dl>

<p>These Boolean polynomials can be immediately extended to any number of variables, producing a large potential variety of logical operators. In vector logic, the matrix-vector structure of logical operators is an exact translation to the format of liner algebra of these Boolean polynomials, where the <em>x</em> and <em>1-x</em> correspond to vectors <em>s</em> and <em>n</em> respectively (the same for <em>y</em> and <em>1-y</em>). In the example of NAND, <em>f(1,1)=n</em> and <em>f(1,0)=f(0,1)=f(0,0)=s</em> and the matrix version becomes:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Vector_logic:57">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>n</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>s</mi>
        <mo>⊗</mo>
        <mi>s</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>T</mi>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>s</mi>
          <mo>⊗</mo>
          <mi>n</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>T</mi>
       </msup>
       <mo>+</mo>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>n</mi>
          <mo>⊗</mo>
          <mi>s</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>T</mi>
       </msup>
       <mo>+</mo>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>n</mi>
          <mo>⊗</mo>
          <mi>n</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>T</mi>
       </msup>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>s</ci>
        <ci>s</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="latexml">tensor-product</csymbol>
          <ci>s</ci>
          <ci>n</ci>
         </apply>
         <ci>T</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="latexml">tensor-product</csymbol>
          <ci>n</ci>
          <ci>s</ci>
         </apply>
         <ci>T</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="latexml">tensor-product</csymbol>
          <ci>n</ci>
          <ci>n</ci>
         </apply>
         <ci>T</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=n(s\otimes s)^{T}+s[(s\otimes n)^{T}+(n\otimes s)^{T}+(n\otimes n)^{T}]
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h2 id="extensions">Extensions</h2>
<ul>
<li>Vector logic can be extended to include many truth values since large dimensional vector spaces allow to create many orthogonal truth values and the corresponding logical matrices.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></li>
<li>Logical modalities can be fully represented in this context, with recursive process inspired in <a href="Artificial_neuron" title="wikilink">neural models</a><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></li>
<li>Some cognitive problems about logical computations can be analyzed using this formalism, in particular recursive decisions. Any logical expression of classical propositional calculus can be naturally represented by a <a href="tree_structure" title="wikilink">tree structure</a>.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> This fact is retained by vector logic, and has been partially used in neural models focused in the investigation of the branched structure of natural languages.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a><a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a><a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a><a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a><ref>beim Graben, P., Gerth, S. (2012) Geometric representations for minimalist grammars. Journal of Logic, Language and Information, 21, 393-432 .</ref></li>
</ul>

<p><a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>
<ul>
<li>The computation via reversible operations as the <a href="Fredkin_gate" title="wikilink">Fredkin gate</a> can be implemented in vector logic. This implementations provides explicit expressions for matrix operators that produce the input format and the output filtering necessary for obtaining computations<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a><a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></li>
<li><a href="Elementary_cellular_automaton" title="wikilink">Elementary cellular automata</a> can be analyzed using the operator structure of vector logic; this analysis leads to a spectral decomposition of the laws governing the its dynamics<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a><a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Fuzzy_logic" title="wikilink">Fuzzy logic</a></li>
<li><a href="Quantum_logic" title="wikilink">Quantum logic</a></li>
<li><a href="Boolean_algebra" title="wikilink">Boolean algebra</a></li>
<li><a href="Propositional_calculus" title="wikilink">Propositional calculus</a></li>
<li><a href="George_Boole" title="wikilink">George Boole</a></li>
<li><a href="Jan_Łukasiewicz" title="wikilink">Jan Łukasiewicz</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a class="uri" href="Category:Logic" title="wikilink">Category:Logic</a> <a href="Category:Boolean_algebra" title="wikilink">Category:Boolean algebra</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Mizraji, E. (1992). <a href="http://www.sciencedirect.com/science/article/pii/016501149290216Q">Vector logics: the matrix-vector representation of logical calculus.</a> Fuzzy Sets and Systems, 50, 179–185, 1992<a href="#fnref1">↩</a></li>
<li id="fn2">Mizraji, E. (2008) <a href="http://logcom.oxfordjournals.org/content/18/1/97.full.pdf">Vector logic: a natural algebraic representation of the fundamental logical gates.</a> Journal of Logic and Computation, 18, 97–121, 2008<a href="#fnref2">↩</a></li>
<li id="fn3">Mizraji, E. (1996) The operators of vector logic. Mathematical Logic Quarterly, 42, 27–39<a href="#fnref3">↩</a></li>
<li id="fn4">Suppes, P. (1957) Introduction to Logic, Van Nostrand Reinhold, New York.<a href="#fnref4">↩</a></li>
<li id="fn5">Łukasiewicz, J. (1980) Selected Works. L. Borkowski, ed., pp. 153–178. North-Holland, Amsterdam, 1980<a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7">Rescher, N. (1969) Many-Valued Logic. McGraw–Hill, New York<a href="#fnref7">↩</a></li>
<li id="fn8">Blanché, R. (1968) Introduction à la Logique Contemporaine, Armand Colin, Paris<a href="#fnref8">↩</a></li>
<li id="fn9">Klir, G.J., Yuan, G. (1995) Fuzzy Sets and Fuzzy Logic. Prentice–Hall, New Jersey<a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11">Kohonen, T. (1977) Associative Memory: A System-Theoretical Approach. Springer-Verlag, New York<a href="#fnref11">↩</a></li>
<li id="fn12">Mizraji, E. (1989) <a href="http://link.springer.com/article/10.1007%2FBF02458441">Context-dependent associations in linear distributed memories</a>. Bulletin of Mathematical Biology, 50, 195–205<a href="#fnref12">↩</a></li>
<li id="fn13">Boole, G. (1854) An Investigation of the Laws of Thought, on which are Founded the Theories of Logic and Probabilities. Macmillan, London, 1854; Dover, New York Reedition, 1958<a href="#fnref13">↩</a></li>
<li id="fn14">Dick, S. (2005) Towards complex fuzzy logic. IEEE Transactions on Fuzzy Systems, 15,405–414, 2005<a href="#fnref14">↩</a></li>
<li id="fn15">Mittelstaedt, P. (1968) Philosophische Probleme der Modernen Physik, Bibliographisches Institut, Mannheim<a href="#fnref15">↩</a></li>
<li id="fn16">Stern, A. (1988) Matrix Logic: Theory and Applications. North-Holland, Amsterdam<a href="#fnref16">↩</a></li>
<li id="fn17">Westphal, J., Hardy, J. (2005) Logic as a vector system. Journal of Logic and Computation, 15, 751–765<a href="#fnref17">↩</a></li>
<li id="fn18">Copilowish, I.M. (1948) Matrix development of the calculus of relations. Journal of Symbolic Logic, 13, 193–203<a href="#fnref18">↩</a></li>
<li id="fn19">Jain, M.K. (2011) Logic of evidence-based inference propositions, Current Science, 1663–1672, 100<a href="#fnref19">↩</a></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23">Mizraji, E. (1994) [<a class="uri" href="http://projecteuclid.org/DPubS?verb=Display&amp;version">http://projecteuclid.org/DPubS?verb=Display&amp;version;</a>;=1.0&amp;service;=UI&amp;handle;=euclid.ndjfl/1094061864&amp;page;=record Modalities in vector logic]. Notre Dame Journal of Formal Logic, 35, 272–283<a href="#fnref23">↩</a></li>
<li id="fn24"></li>
<li id="fn25">Mizraji, E., Lin, J. (2002) The dynamics of logical decisions. Physica D, 168–169, 386–396<a href="#fnref25">↩</a></li>
<li id="fn26">beim Graben, P., Potthast, R. (2009). Inverse problems in dynamic cognitive modeling. Chaos, 19, 015103<a href="#fnref26">↩</a></li>
<li id="fn27">beim Graben, P., Pinotsis, D., Saddy, D., Potthast, R. (2008). Language processing with dynamic ﬁelds. Cogn. Neurodyn., 2, 79–88<a href="#fnref27">↩</a></li>
<li id="fn28">beim Graben, P., Gerth, S., Vasishth, S.(2008) Towards dynamical system models of language-related brain potentials. Cogn. Neurodyn., 2, 229–255<a href="#fnref28">↩</a></li>
<li id="fn29">Binazzi, A.(2012) <a href="http://www.fupress.net/index.php/sf/article/view/11649">Cognizione logica e modelli mentali.</a> Studi sulla formazione, 1–2012, pag. 69–84<a href="#fnref29">↩</a></li>
<li id="fn30"></li>
<li id="fn31"></li>
<li id="fn32">Mizraji, E. (2006) The parts and the whole: inquiring how the interaction of simple subsystems generates complexity. International Journal of General Systems, 35, pp. 395–415.<a href="#fnref32">↩</a></li>
<li id="fn33">Arruti, C., Mizraji, E. (2006) Hidden potentialities. International Journal of General Systems, 35, 461–469.<a href="#fnref33">↩</a></li>
</ol>
</section>
</body>
</html>
