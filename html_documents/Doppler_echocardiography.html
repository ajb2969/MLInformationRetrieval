<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="769">Doppler echocardiography</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Doppler echocardiography</h1>
<hr/>

<p><strong>Doppler echocardiography</strong> is a procedure that uses <a href="Medical_ultrasonography" title="wikilink">ultrasound</a> technology to examine the <a class="uri" href="heart" title="wikilink">heart</a> or <a href="blood_vessel" title="wikilink">blood vessels</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> An <a href="echocardiography" title="wikilink">echocardiogram</a> uses high frequency sound waves to create an image of the heart while the use of Doppler technology allows determination of the speed and direction of <a href="blood_flow" title="wikilink">blood flow</a> by utilizing the <a href="Doppler_effect" title="wikilink">Doppler effect</a>.</p>

<p>An echocardiogram can, within certain limits, produce accurate assessment of the direction of <a href="blood_flow" title="wikilink">blood flow</a> and the <a class="uri" href="velocity" title="wikilink">velocity</a> of blood and cardiac tissue at any arbitrary point using the Doppler effect. One of the limitations is that the ultrasound beam should be as parallel to the blood flow as possible. Velocity measurements allow assessment of <a href="cardiac_valve" title="wikilink">cardiac valve</a> areas and function, any abnormal communications between the left and right side of the heart, any leaking of blood through the valves (<a href="valvular_regurgitation" title="wikilink">valvular regurgitation</a>), calculation of the <a href="cardiac_output" title="wikilink">cardiac output</a> and calculation of <a href="E/A_ratio" title="wikilink">E/A ratio</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> (a measure of <a href="diastolic_dysfunction" title="wikilink">diastolic dysfunction</a>). Contrast-enhanced ultrasound using gas-filled microbubble contrast media can be used to improve velocity or other flow-related medical measurements.</p>

<p>An advantage of Doppler echocardiography is that it can be used to measure blood flow within the heart without <a href="invasive_(medical)" title="wikilink">invasive</a> procedures such as <a href="cardiac_catheterization" title="wikilink">cardiac catheterization</a>.</p>

<p>In addition, with slightly different filter/gain settings, the method can measure tissue velocities by <a href="Tissue_Doppler_echocardiography" title="wikilink">Tissue Doppler echocardiography</a>. The combination of flow and tissue velocities can be used for estimating left ventricular filling <a class="uri" href="pressure" title="wikilink">pressure</a>, although only under certain conditions.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Although "Doppler" has become synonymous with "velocity measurement" in medical imaging, in many cases it is not the frequency shift (Doppler shift) of the received signal that is measured, but the phase shift (when the received signal arrives). However, the calculation result will end up identical.</p>

<p>This procedure is frequently used to examine children's hearts for <a href="heart_disease" title="wikilink">heart disease</a> because there is no age or size requirement.</p>
<h2 id="d-doppler-imaging">2D Doppler Imaging</h2>

<p>Unlike 1D Doppler imaging, which can only provide one-dimensional velocity and has dependency on the beam to flow angle,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> 2D velocity estimation using Doppler ultrasound is able to generate velocity vectors with axial and lateral velocity components. 2D velocity is useful even if complex flow conditions such as stenosis and bifurcation exist. There are two major methods of 2D velocity estimation using ultrasound: Speckle tracking and crossed beam Vector Doppler, which are based on measuring the time shifts and phase shifts respectively.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="vector-doppler">Vector Doppler</h3>

<p>Vector Doppler is a natural extension of the traditional 1D Doppler imaging based on phase shift. The phase shift is found by taking the autocorrelation between echoes from two consecutive firings.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The main idea of Vector Doppler is to divide the transducer into three apertures: one at the center as the transmit aperture and two on each side as the receive apertures. The phase shifts measured from left and right apertures are combined to give the axial and lateral velocity components. The positions and the relative angles between apertures need to be tuned according to the depth of the vessel and the lateral position of the region of interest.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="speckle-tracking">Speckle tracking</h3>

<p>Speckle tracking, which is a well-established method in video compression and other applications, can be used to estimate blood flow in ultrasound systems. The basic idea of speckle tracking is to find the best match of a certain speckle from one frame within a search region in subsequent frames.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The decorrelation between frames is one of the major factors degrading its performance. The decorrelation is mainly caused by the different velocity of pixels within a speckle, as they do not move as a block. This is less severe when measuring the flow at the center, as the changing rate of the velocity is the lowest. The flow at the center usually has the largest velocity magnitude, called peak velocity. It is the most needed information in some cases, such as diagnosing stenosis.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> There are mainly three methods of finding the best match: SAD (Sum of absolute difference), SSD (Sum of squared difference) and Cross correlation. Assume 

<math display="inline" id="Doppler_echocardiography:0">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>0</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">0</cn>
    </apply>
    <interval closure="open">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{0}(i,j)
  </annotation>
 </semantics>
</math>

 is a pixel in the kernel and 

<math display="inline" id="Doppler_echocardiography:1">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mi>α</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>j</mi>
     <mo>+</mo>
     <mi>β</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <interval closure="open">
     <apply>
      <plus></plus>
      <ci>i</ci>
      <ci>α</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>j</ci>
      <ci>β</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1}(i+\alpha,j+\beta)
  </annotation>
 </semantics>
</math>

 is the mapped pixel shifted by 

<math display="inline" id="Doppler_echocardiography:2">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>α</mi>
   <mo>,</mo>
   <mi>β</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>α</ci>
    <ci>β</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\alpha,\beta)
  </annotation>
 </semantics>
</math>

 in the search region.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>SAD is calculated as: 

<math display="inline" id="Doppler_echocardiography:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>α</mi>
     <mo>,</mo>
     <mi>β</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>X</mi>
         <mn>0</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>i</mi>
         <mo>,</mo>
         <mi>j</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>X</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>i</mi>
          <mo>+</mo>
          <mi>α</mi>
         </mrow>
         <mo>,</mo>
         <mrow>
          <mi>j</mi>
          <mo>+</mo>
          <mi>β</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <interval closure="open">
      <ci>α</ci>
      <ci>β</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <cn type="integer">0</cn>
         </apply>
         <interval closure="open">
          <ci>i</ci>
          <ci>j</ci>
         </interval>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <cn type="integer">1</cn>
         </apply>
         <interval closure="open">
          <apply>
           <plus></plus>
           <ci>i</ci>
           <ci>α</ci>
          </apply>
          <apply>
           <plus></plus>
           <ci>j</ci>
           <ci>β</ci>
          </apply>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(\alpha,\beta)=\sum_{i=1}\sum_{j=1}|X_{0}(i,j)-X_{1}(i+\alpha,j+\beta)|
  </annotation>
 </semantics>
</math>


</p>

<p>SSD is calculated as: 

<math display="inline" id="Doppler_echocardiography:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>α</mi>
     <mo>,</mo>
     <mi>β</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <msub>
          <mi>X</mi>
          <mn>0</mn>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>i</mi>
          <mo>,</mo>
          <mi>j</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <msub>
          <mi>X</mi>
          <mn>1</mn>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>i</mi>
           <mo>+</mo>
           <mi>α</mi>
          </mrow>
          <mo>,</mo>
          <mrow>
           <mi>j</mi>
           <mo>+</mo>
           <mi>β</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <interval closure="open">
      <ci>α</ci>
      <ci>β</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <cn type="integer">0</cn>
         </apply>
         <interval closure="open">
          <ci>i</ci>
          <ci>j</ci>
         </interval>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <cn type="integer">1</cn>
         </apply>
         <interval closure="open">
          <apply>
           <plus></plus>
           <ci>i</ci>
           <ci>α</ci>
          </apply>
          <apply>
           <plus></plus>
           <ci>j</ci>
           <ci>β</ci>
          </apply>
         </interval>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(\alpha,\beta)=\sum_{i=1}\sum_{j=1}(X_{0}(i,j)-X_{1}(i+\alpha,j+\beta))^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>Normalized cross correlation coefficient is calculated as: 

<math display="inline" id="Doppler_echocardiography:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>α</mi>
     <mo>,</mo>
     <mi>β</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mstyle displaystyle="false">
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mstyle>
     <mrow>
      <mstyle displaystyle="false">
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>j</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mstyle>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <msub>
           <mi>X</mi>
           <mn>0</mn>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>i</mi>
           <mo>,</mo>
           <mi>j</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mover accent="true">
          <msub>
           <mi>X</mi>
           <mn>0</mn>
          </msub>
          <mo stretchy="false">¯</mo>
         </mover>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <msub>
           <mi>X</mi>
           <mn>1</mn>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>i</mi>
            <mo>+</mo>
            <mi>α</mi>
           </mrow>
           <mo>,</mo>
           <mrow>
            <mi>j</mi>
            <mo>+</mo>
            <mi>β</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mover accent="true">
          <msub>
           <mi>X</mi>
           <mn>1</mn>
          </msub>
          <mo stretchy="false">¯</mo>
         </mover>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <msqrt>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mstyle displaystyle="false">
         <msub>
          <mo largeop="true" symmetric="true">∑</mo>
          <mrow>
           <mi>i</mi>
           <mo>=</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mstyle>
        <mrow>
         <mstyle displaystyle="false">
          <msub>
           <mo largeop="true" symmetric="true">∑</mo>
           <mrow>
            <mi>j</mi>
            <mo>=</mo>
            <mn>1</mn>
           </mrow>
          </msub>
         </mstyle>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mrow>
             <msub>
              <mi>X</mi>
              <mn>0</mn>
             </msub>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>i</mi>
              <mo>,</mo>
              <mi>j</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo>-</mo>
            <mover accent="true">
             <msub>
              <mi>X</mi>
              <mn>0</mn>
             </msub>
             <mo stretchy="false">¯</mo>
            </mover>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mn>2</mn>
         </msup>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mstyle displaystyle="false">
         <msub>
          <mo largeop="true" symmetric="true">∑</mo>
          <mrow>
           <mi>i</mi>
           <mo>=</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mstyle>
        <mrow>
         <mstyle displaystyle="false">
          <msub>
           <mo largeop="true" symmetric="true">∑</mo>
           <mrow>
            <mi>j</mi>
            <mo>=</mo>
            <mn>1</mn>
           </mrow>
          </msub>
         </mstyle>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mrow>
             <msub>
              <mi>X</mi>
              <mn>1</mn>
             </msub>
             <mrow>
              <mo stretchy="false">(</mo>
              <mrow>
               <mi>i</mi>
               <mo>+</mo>
               <mi>α</mi>
              </mrow>
              <mo>,</mo>
              <mrow>
               <mi>j</mi>
               <mo>+</mo>
               <mi>β</mi>
              </mrow>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo>-</mo>
            <mover accent="true">
             <msub>
              <mi>X</mi>
              <mn>1</mn>
             </msub>
             <mo stretchy="false">¯</mo>
            </mover>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mn>2</mn>
         </msup>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msqrt>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <interval closure="open">
      <ci>α</ci>
      <ci>β</ci>
     </interval>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>X</ci>
           <cn type="integer">0</cn>
          </apply>
          <interval closure="open">
           <ci>i</ci>
           <ci>j</ci>
          </interval>
         </apply>
         <apply>
          <ci>normal-¯</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>X</ci>
           <cn type="integer">0</cn>
          </apply>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>X</ci>
           <cn type="integer">1</cn>
          </apply>
          <interval closure="open">
           <apply>
            <plus></plus>
            <ci>i</ci>
            <ci>α</ci>
           </apply>
           <apply>
            <plus></plus>
            <ci>j</ci>
            <ci>β</ci>
           </apply>
          </interval>
         </apply>
         <apply>
          <ci>normal-¯</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>X</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <root></root>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>j</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <minus></minus>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>X</ci>
             <cn type="integer">0</cn>
            </apply>
            <interval closure="open">
             <ci>i</ci>
             <ci>j</ci>
            </interval>
           </apply>
           <apply>
            <ci>normal-¯</ci>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>X</ci>
             <cn type="integer">0</cn>
            </apply>
           </apply>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>j</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <minus></minus>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>X</ci>
             <cn type="integer">1</cn>
            </apply>
            <interval closure="open">
             <apply>
              <plus></plus>
              <ci>i</ci>
              <ci>α</ci>
             </apply>
             <apply>
              <plus></plus>
              <ci>j</ci>
              <ci>β</ci>
             </apply>
            </interval>
           </apply>
           <apply>
            <ci>normal-¯</ci>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>X</ci>
             <cn type="integer">1</cn>
            </apply>
           </apply>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(\alpha,\beta)=\frac{\sum_{i=1}\sum_{j=1}(X_{0}(i,j)-\bar{X_{0}})(X_{1}(i+%
\alpha,j+\beta)-\bar{X_{1}})}{\sqrt{(\sum_{i=1}\sum_{j=1}(X_{0}(i,j)-\bar{X_{0%
}})^{2})(\sum_{i=1}\sum_{j=1}(X_{1}(i+\alpha,j+\beta)-\bar{X_{1}})^{2})}}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Doppler_echocardiography:6">
 <semantics>
  <mover accent="true">
   <msub>
    <mi>X</mi>
    <mn>0</mn>
   </msub>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{X_{0}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Doppler_echocardiography:7">
 <semantics>
  <mover accent="true">
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{X_{1}}
  </annotation>
 </semantics>
</math>

 are the average values of 

<math display="inline" id="Doppler_echocardiography:8">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>0</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">0</cn>
    </apply>
    <interval closure="open">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{0}(i,j)
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Doppler_echocardiography:9">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <interval closure="open">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1}(i,j)
  </annotation>
 </semantics>
</math>

 respectively. The 

<math display="inline" id="Doppler_echocardiography:10">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>α</mi>
   <mo>,</mo>
   <mi>β</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>α</ci>
    <ci>β</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\alpha,\beta)
  </annotation>
 </semantics>
</math>

 pair that gives the lowest D for SAD and SSD, or the largest ρ for the cross correlation, is selected as the estimation of the movement. The velocity is then calculated as the movement divided by the time difference between the frames. Usually the median or average of multiple estimations is taken to give more accurate result.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h4 id="sub-pixel-accuracy">Sub pixel accuracy</h4>

<p>In ultrasound systems, lateral resolution is usually much lower than the axial resolution. The poor lateral resolution in the <a href="Medical_ultrasonography#Modes_of_sonography" title="wikilink">B-mode</a> image also results in poor lateral resolution in flow estimation. Therefore, sub pixel resolution is needed to improve the accuracy of the estimation in the lateral dimension. In the meantime, we could reduce the sampling frequency along the axial dimension to save computations and memories if the sub pixel movement is estimated accurately enough. There are generally two kinds of methods to obtain the sub pixel accuracy: interpolation methods, such as parabolic fit, and phase based methods in which the peak lag is found when the phase of the analytic cross correlation function crosses zero.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h5 id="interpolation-methodparabolic-fit">Interpolation method(parabolic fit)</h5>
<figure><b>(Figure)</b>
<figcaption>Interpolation to find peak</figcaption>
</figure>

<p>As shown in the right figure, parabolic fit can help find the real peak of the cross correlation function. The equation for parabolic fit in 1D is:<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> 

<math display="inline" id="Doppler_echocardiography:11">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mrow>
     <mi>i</mi>
     <mi>n</mi>
     <mi>t</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>k</mi>
     <mi>s</mi>
    </msub>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>R</mi>
         <mn>12</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mi>k</mi>
           <mi>s</mi>
          </msub>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>R</mi>
         <mn>12</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mi>k</mi>
           <mi>s</mi>
          </msub>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mn>2</mn>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mrow>
          <msub>
           <mi>R</mi>
           <mn>12</mn>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <msub>
             <mi>k</mi>
             <mi>s</mi>
            </msub>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mn>2</mn>
          <msub>
           <mi>R</mi>
           <mn>12</mn>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>k</mi>
            <mi>s</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msub>
          <mi>R</mi>
          <mn>12</mn>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mi>k</mi>
            <mi>s</mi>
           </msub>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>n</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <cn type="integer">12</cn>
        </apply>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>k</ci>
          <ci>s</ci>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <cn type="integer">12</cn>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>k</ci>
          <ci>s</ci>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <plus></plus>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>R</ci>
           <cn type="integer">12</cn>
          </apply>
          <apply>
           <plus></plus>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>k</ci>
            <ci>s</ci>
           </apply>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>R</ci>
           <cn type="integer">12</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>k</ci>
           <ci>s</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>R</ci>
          <cn type="integer">12</cn>
         </apply>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>k</ci>
           <ci>s</ci>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{int}=k_{s}-\frac{(R_{12}(k_{s}+1)-R_{12}(k_{s}-1))}{2(R_{12}(k_{s}+1)-2R_{1%
2}(k_{s})+R_{12}(k_{s}-1))}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Doppler_echocardiography:12">
 <semantics>
  <msub>
   <mi>R</mi>
   <mn>12</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <cn type="integer">12</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{12}
  </annotation>
 </semantics>
</math>

 is the cross correlation function and 

<math display="inline" id="Doppler_echocardiography:13">
 <semantics>
  <msub>
   <mi>k</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{s}
  </annotation>
 </semantics>
</math>


 is the originally found peak. 

<math display="inline" id="Doppler_echocardiography:14">
 <semantics>
  <msub>
   <mi>k</mi>
   <mrow>
    <mi>i</mi>
    <mi>n</mi>
    <mi>t</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>n</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{int}
  </annotation>
 </semantics>
</math>

 is then used to find the displacement of scatterers after interpolation. For the 2D scenario, this is done in both the axial and lateral dimensions. Some other techniques can be used to improve the accuracy and robustness of the interpolation method, including parabolic fit with bias compensation and matched filter interpolation.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h5 id="phase-based-method">Phase based method</h5>

<p>The main idea of this method is to generate synthetic lateral phase and use it to find the phase that crosses zero at the peak lag.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<figure><b>(Figure)</b>
<figcaption>Lateral phase generation</figcaption>
</figure>

<p>The right figure illustrates the procedure of creating the synthetic lateral phase, as a first step. Basically, the lateral spectrum is split in two to generate two spectra with nonzero center frequencies. The cross correlation is done for both the up signal and down signal, creating 

<math display="inline" id="Doppler_echocardiography:15">
 <semantics>
  <msub>
   <mi>R</mi>
   <mrow>
    <mi>u</mi>
    <mi>p</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <apply>
     <times></times>
     <ci>u</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{up}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Doppler_echocardiography:16">
 <semantics>
  <msub>
   <mi>R</mi>
   <mrow>
    <mi>d</mi>
    <mi>o</mi>
    <mi>w</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>o</ci>
     <ci>w</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{down}
  </annotation>
 </semantics>
</math>

 respectively.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> The lateral correlation function and axial correlation function are then calculated as follows: 

<math display="inline" id="Doppler_echocardiography:17">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mrow>
      <mi>l</mi>
      <mi>a</mi>
      <mi>t</mi>
      <mi>e</mi>
      <mi>r</mi>
      <mi>a</mi>
      <mi>l</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>R</mi>
      <mrow>
       <mi>u</mi>
       <mi>p</mi>
      </mrow>
     </msub>
     <mo>*</mo>
     <msubsup>
      <mi>R</mi>
      <mrow>
       <mi>d</mi>
       <mi>o</mi>
       <mi>w</mi>
       <mi>n</mi>
      </mrow>
      <mo>*</mo>
     </msubsup>
    </mrow>
   </mrow>
   <mo>;</mo>
   <mrow>
    <msub>
     <mi>R</mi>
     <mrow>
      <mi>a</mi>
      <mi>x</mi>
      <mi>i</mi>
      <mi>a</mi>
      <mi>l</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>R</mi>
      <mrow>
       <mi>u</mi>
       <mi>p</mi>
      </mrow>
     </msub>
     <mo>*</mo>
     <msub>
      <mi>R</mi>
      <mrow>
       <mi>d</mi>
       <mi>o</mi>
       <mi>w</mi>
       <mi>n</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <apply>
       <times></times>
       <ci>l</ci>
       <ci>a</ci>
       <ci>t</ci>
       <ci>e</ci>
       <ci>r</ci>
       <ci>a</ci>
       <ci>l</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <apply>
        <times></times>
        <ci>u</ci>
        <ci>p</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <apply>
         <times></times>
         <ci>d</ci>
         <ci>o</ci>
         <ci>w</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <times></times>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>x</ci>
       <ci>i</ci>
       <ci>a</ci>
       <ci>l</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <apply>
        <times></times>
        <ci>u</ci>
        <ci>p</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>o</ci>
        <ci>w</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{lateral}=R_{up}*R_{down}^{*};R_{axial}=R_{up}*R_{down}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Doppler_echocardiography:18">
 <semantics>
  <msubsup>
   <mi>R</mi>
   <mrow>
    <mi>d</mi>
    <mi>o</mi>
    <mi>w</mi>
    <mi>n</mi>
   </mrow>
   <mo>*</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>o</ci>
      <ci>w</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{down}^{*}
  </annotation>
 </semantics>
</math>


 is the complex conjugate of 

<math display="inline" id="Doppler_echocardiography:19">
 <semantics>
  <msub>
   <mi>R</mi>
   <mrow>
    <mi>d</mi>
    <mi>o</mi>
    <mi>w</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>o</ci>
     <ci>w</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{down}
  </annotation>
 </semantics>
</math>

.</p>

<p>It is obvious that they have the same magnitude, and the integer peak is found using traditional cross correlation methods. After the integer peak is located, a 3 by 3 region surrounding the peak is then extracted with its phase information. For both the lateral and axial dimensions, the zero crossings of a one-dimensional correlation function at the other dimension’s lags are found, and a linear least squares fitted line is created accordingly. The intersection of the two lines gives the estimate of the 2D displacement.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h3 id="comparison-between-vector-doppler-and-speckle-tracking">Comparison between Vector Doppler and Speckle tracking</h3>

<p>Both methods could be used for 2D Velocity Vector Imaging, but Speckle Tracking would be easier to extend to 3D. Also, in Vector Doppler, the depth and resolution of the region of interest are limited by the aperture size and the maximum angle between the transmit and receive apertures, while Speckle Tracking has the flexibility of alternating the size of the kernel and search region to adapt to different resolution requirement. However, vector Doppler is less computationally complex than speckle tracking.</p>
<h3 id="volumetric-flow-estimation">Volumetric flow estimation</h3>

<p>Velocity estimation from conventional Doppler requires knowledge of the beam-to-flow angle (<a href="Inclination_angle" title="wikilink">Inclination angle</a>) to produce reasonable results for regular flows and does a poor job of estimating complex flow patterns, such as those due to stenosis and/or bifurcation. Volumetric flow estimation requires integrating velocity across the vessel cross-section, with assumptions about the vessel geometry, further complicating flow estimates. 2D Doppler data can be used to calculate the volumetric flow in certain integration plane.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> The integration plane is chosen to be perpendicular to the beam, and Doppler power (generated from power Doppler mode of <a href="Doppler_ultrasound" title="wikilink">Doppler ultrasound</a>) can be used to differentiate between the components that are inside and outside the vessel. This method does not require prior knowledge of the Doppler angle, flow profile and vessel geometry.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<h2 id="promise-of-3d">Promise of 3D</h2>

<p>Until recently, ultrasound images have been 2D views and have relied on highly trained specialists to properly orient the probe and select the position within the body to image with only few and complex visual cues. The complete measurement of 3D velocity vectors makes many post processing techniques possible. Not only the volumetric flow across any plane is measurable, but also other physical information such as stress and pressure can be calculated based on the 3D velocity field. However, it is quite challenging to measure the complex blood flow to give velocity vectors, due to the fast acquisition rate and the massive computations needed for it. Plane wave technique is thus promising as it can generate very high frame rate.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Medical_ultrasonography" title="wikilink">Medical ultrasonography</a> section: <a href="Medical_ultrasonography#Doppler_sonography" title="wikilink">Doppler sonography</a></li>
<li><a class="uri" href="Echocardiography" title="wikilink">Echocardiography</a></li>
<li><a href="American_Society_of_Echocardiography" title="wikilink">American Society of Echocardiography</a></li>
<li><a href="Christian_Doppler" title="wikilink">Christian Doppler</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://folk.ntnu.no/stoylen/strainrate/Ultrasound/">Basic ultrasound, echocardiography and Doppler for clinicians</a></li>
<li><a href="http://www.echotext.info/">Echocardiography Textbook by Bonita Anderson</a></li>
<li><a href="http://www.americanheart.org/presenter.jhtml?identifier=3005161">Echocardiography (Ultrasound of the heart)</a></li>
<li><a href="http://www.echoincontext.com/doppler01/doppler01_01.asp">Doppler Examination - Introduction</a></li>
<li><a href="http://www.echoincontext.com/doppler01/doppler01_02.asp">The Doppler Principle and the Study of Cardiac Flows</a></li>
</ul>

<p>"</p>

<p><a href="Category:Medical_ultrasonography" title="wikilink">Category:Medical ultrasonography</a> <a href="Category:Medical_equipment" title="wikilink">Category:Medical equipment</a> <a href="Category:Cardiac_procedures" title="wikilink">Category:Cardiac procedures</a> <a href="Category:Multidimensional_signal_processing" title="wikilink">Category:Multidimensional signal processing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://www.bioline.org.br/request?mj04008">1</a> Abdul Latif Mohamed, Jun Yong, Jamil Masiyati, Lee Lim, Sze Chec Tee. <em>The Prevalence Of Diastolic Dysfunction In Patients With Hypertension Referred For Echocardiographic Assessment of Left Ventricular Function.</em> Malaysian Journal of Medical Sciences, Vol. 11, No. 1, January 2004, pp. 66-74<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">J. A. Jensen, Estimation of Blood Velocities Using Ultrasound, A Signal Processing Approach, New York: Cambridge University Press, 1996.<a href="#fnref4">↩</a></li>
<li id="fn5">P. S. a. L. L. Abigail Swillens, "Two-Dimensional Blood Velocity Estimation With Ultrasound: Speckle Tracking Versus Crossed-Beam Vector Doppler Based on Flow Simulations in a Carotid Bifurcation Model," IEEE Transactions on Ultrasonics, Ferroelectrics, and Frequency Control, pp. 327-338, 2010.<a href="#fnref5">↩</a></li>
<li id="fn6">R. S. C. Cobbold, Foundations of Biomedical Ultrasound, Oxford University Press, 2007.<a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9">G. Reutern, M. Goertler, N. Bornstein, M. Sette, D. Evans, A. Hetzel, M. Kaps, F. Perren, A. Razumovky, T. Shiogai, E. Titianova, P. Traubner, N. Venketasubramanian, L. Wong and M. Yasaka, "Grading Carotid Stenosis Using Ultrasonic Methods," Stroke, Journal of the American Heart Association, vol. 43, pp. 916-921, 2012.<a href="#fnref9">↩</a></li>
<li id="fn10">J. Luo and E. E. Konofagou, "A Fast Motion and Strain Estimation," in Ultrasound Symposium, 2010.<a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12">X. Chen, M. J. Zohdy, S. Y. Emelianov and M. O'Donnell, "Lateral Speckle Tracking Using Synthetic Lateral Phase," IEEE Transactions on Ultrasonics, Ferroelectrcs and Frequency Control, vol. 51, no. 5, pp. 540-550, 2004.<a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14">X. Lai and H. Torp, "Interpolation Methods for Time-Delay Estimation Using Cross-Correlation Method for Blood Velocity Measurement," IEEE Transactions on Ultrasonics, Ferroelectrcs and Frequency Control, vol. 46, no. 2, pp. 277-290, 1999.<a href="#fnref14">↩</a></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18">M. Richards, O. Kripfgans, J. Rubin, A. Hall and J. Fowlkes, "Mean Volume Flow Estimation in Pulsatile Flow Conditions," Ultrasound in Med. &amp; Biol., vol. 35, pp. 1880-1891, 2009.<a href="#fnref18">↩</a></li>
<li id="fn19"></li>
<li id="fn20">J. Udesen, F. Gran, K. Hansen, J. Jensen, C. Thomsen and M. Nielsen, "High Frame Rate Blood Vector Velocity Imaging Using Plane Waves: Simulations and Preliminary Experiments," IEEE Transactions on Ultrasonics, Ferroelectrics and Frequency Control, vol. 55, no. 8, pp. 1729-1743, 2008.<a href="#fnref20">↩</a></li>
</ol>
</section>
</body>
</html>
