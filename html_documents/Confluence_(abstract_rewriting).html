<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="725">Confluence (abstract rewriting)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Confluence (abstract rewriting)</h1>
<hr/>

<p> In computer science, <strong>confluence</strong> is a property of <a class="uri" href="rewriting" title="wikilink">rewriting</a> systems, describing which terms in such a system can be rewritten in more than one way, to yield the same result. This article describes the properties in the most abstract setting of an <a href="abstract_rewriting_system" title="wikilink">abstract rewriting system</a>.</p>
<h2 id="motivating-examples">Motivating examples</h2>

<p>The usual rules of elementary arithmetic form an abstract rewriting system. For example, the expression (11 + 9) × (2 + 4) can be evaluated starting either at the left or at the right parentheses; however, in both cases the same result is obtained eventually. This suggests that the arithmetic rewriting system is a confluent one.</p>

<p>

<math display="inline" id="Confluence_(abstract_rewriting):0">
 <semantics>
  <mtable>
   <mtr>
    <mtd class="ltx_border_l ltx_border_t" columnalign="right">
     <mrow>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\color</mtext>
      </merror>
      <mi>M</mi>
      <mi>i</mi>
      <mi>d</mi>
      <mi>n</mi>
      <mi>i</mi>
      <mi>g</mi>
      <mi>h</mi>
      <mi>t</mi>
      <mi>B</mi>
      <mi>l</mi>
      <mi>u</mi>
      <mi>e</mi>
      <mtext>eval left</mtext>
     </mrow>
    </mtd>
    <mtd class="ltx_border_t">
    </mtd>
    <mtd class="ltx_border_t" columnalign="center">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>11</mn>
        <mo>+</mo>
        <mn>9</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>×</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>2</mn>
        <mo>+</mo>
        <mn>4</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd class="ltx_border_t">
    </mtd>
    <mtd class="ltx_border_r ltx_border_t" columnalign="left">
     <mrow>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\color</mtext>
      </merror>
      <mi>M</mi>
      <mi>i</mi>
      <mi>d</mi>
      <mi>n</mi>
      <mi>i</mi>
      <mi>g</mi>
      <mi>h</mi>
      <mi>t</mi>
      <mi>B</mi>
      <mi>l</mi>
      <mi>u</mi>
      <mi>e</mi>
      <mtext>eval right</mtext>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd class="ltx_border_l">
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mrow>
       <merror class="ltx_ERROR undefined undefined">
        <mtext>\color</mtext>
       </merror>
       <mi>M</mi>
       <mi>i</mi>
       <mi>d</mi>
       <mi>n</mi>
       <mi>i</mi>
       <mi>g</mi>
       <mi>h</mi>
       <mi>t</mi>
       <mi>B</mi>
       <mi>l</mi>
       <mi>u</mi>
       <mi>e</mi>
      </mrow>
      <mo>↙</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd columnalign="center">
     <mrow>
      <mrow>
       <merror class="ltx_ERROR undefined undefined">
        <mtext>\color</mtext>
       </merror>
       <mi>M</mi>
       <mi>i</mi>
       <mi>d</mi>
       <mi>n</mi>
       <mi>i</mi>
       <mi>g</mi>
       <mi>h</mi>
       <mi>t</mi>
       <mi>B</mi>
       <mi>l</mi>
       <mi>u</mi>
       <mi>e</mi>
      </mrow>
      <mo>↘</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd class="ltx_border_r">
    </mtd>
   </mtr>
   <mtr>
    <mtd class="ltx_border_l" columnalign="right">
     <mrow>
      <mn>20</mn>
      <mo>×</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>2</mn>
        <mo>+</mo>
        <mn>4</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd></mtd>
    <mtd class="ltx_border_r" columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>11</mn>
        <mo>+</mo>
        <mn>9</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>×</mo>
      <mn>6</mn>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd class="ltx_border_l">
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mrow>
       <merror class="ltx_ERROR undefined undefined">
        <mtext>\color</mtext>
       </merror>
       <mi>M</mi>
       <mi>i</mi>
       <mi>d</mi>
       <mi>n</mi>
       <mi>i</mi>
       <mi>g</mi>
       <mi>h</mi>
       <mi>t</mi>
       <mi>B</mi>
       <mi>l</mi>
       <mi>u</mi>
       <mi>e</mi>
      </mrow>
      <mo>↘</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd columnalign="center">
     <mrow>
      <mrow>
       <merror class="ltx_ERROR undefined undefined">
        <mtext>\color</mtext>
       </merror>
       <mi>M</mi>
       <mi>i</mi>
       <mi>d</mi>
       <mi>n</mi>
       <mi>i</mi>
       <mi>g</mi>
       <mi>h</mi>
       <mi>t</mi>
       <mi>B</mi>
       <mi>l</mi>
       <mi>u</mi>
       <mi>e</mi>
      </mrow>
      <mo>↙</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd class="ltx_border_r">
    </mtd>
   </mtr>
   <mtr>
    <mtd class="ltx_border_l" columnalign="right">
     <mrow>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\color</mtext>
      </merror>
      <mi>M</mi>
      <mi>i</mi>
      <mi>d</mi>
      <mi>n</mi>
      <mi>i</mi>
      <mi>g</mi>
      <mi>h</mi>
      <mi>t</mi>
      <mi>B</mi>
      <mi>l</mi>
      <mi>u</mi>
      <mi>e</mi>
      <mtext>eval right</mtext>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd columnalign="center">
     <mrow>
      <mn>20</mn>
      <mo>×</mo>
      <mn>6</mn>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd class="ltx_border_r" columnalign="left">
     <mrow>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\color</mtext>
      </merror>
      <mi>M</mi>
      <mi>i</mi>
      <mi>d</mi>
      <mi>n</mi>
      <mi>i</mi>
      <mi>g</mi>
      <mi>h</mi>
      <mi>t</mi>
      <mi>B</mi>
      <mi>l</mi>
      <mi>u</mi>
      <mi>e</mi>
      <mtext>eval left</mtext>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd class="ltx_border_l">
    </mtd>
    <mtd></mtd>
    <mtd columnalign="center">
     <mrow>
      <mrow>
       <merror class="ltx_ERROR undefined undefined">
        <mtext>\color</mtext>
       </merror>
       <mi>M</mi>
       <mi>i</mi>
       <mi>d</mi>
       <mi>n</mi>
       <mi>i</mi>
       <mi>g</mi>
       <mi>h</mi>
       <mi>t</mi>
       <mi>B</mi>
       <mi>l</mi>
       <mi>u</mi>
       <mi>e</mi>
      </mrow>
      <mo>↓</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd></mtd>
    <mtd class="ltx_border_r">
    </mtd>
   </mtr>
   <mtr>
    <mtd class="ltx_border_b ltx_border_l">
    </mtd>
    <mtd class="ltx_border_b">
    </mtd>
    <mtd class="ltx_border_b" columnalign="center">
     <mn>120</mn>
    </mtd>
    <mtd class="ltx_border_b">
    </mtd>
    <mtd class="ltx_border_b ltx_border_r">
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <times></times>
      <mtext>\color</mtext>
      <ci>M</ci>
      <ci>i</ci>
      <ci>d</ci>
      <ci>n</ci>
      <ci>i</ci>
      <ci>g</ci>
      <ci>h</ci>
      <ci>t</ci>
      <ci>B</ci>
      <ci>l</ci>
      <ci>u</ci>
      <ci>e</ci>
      <mtext>eval left</mtext>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <cn type="integer">11</cn>
       <cn type="integer">9</cn>
      </apply>
      <apply>
       <plus></plus>
       <cn type="integer">2</cn>
       <cn type="integer">4</cn>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <times></times>
      <mtext>\color</mtext>
      <ci>M</ci>
      <ci>i</ci>
      <ci>d</ci>
      <ci>n</ci>
      <ci>i</ci>
      <ci>g</ci>
      <ci>h</ci>
      <ci>t</ci>
      <ci>B</ci>
      <ci>l</ci>
      <ci>u</ci>
      <ci>e</ci>
      <mtext>eval right</mtext>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <ci>normal-↙</ci>
      <apply>
       <times></times>
       <mtext>\color</mtext>
       <ci>M</ci>
       <ci>i</ci>
       <ci>d</ci>
       <ci>n</ci>
       <ci>i</ci>
       <ci>g</ci>
       <ci>h</ci>
       <ci>t</ci>
       <ci>B</ci>
       <ci>l</ci>
       <ci>u</ci>
       <ci>e</ci>
      </apply>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <ci>normal-↘</ci>
      <apply>
       <times></times>
       <mtext>\color</mtext>
       <ci>M</ci>
       <ci>i</ci>
       <ci>d</ci>
       <ci>n</ci>
       <ci>i</ci>
       <ci>g</ci>
       <ci>h</ci>
       <ci>t</ci>
       <ci>B</ci>
       <ci>l</ci>
       <ci>u</ci>
       <ci>e</ci>
      </apply>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <cn type="integer">20</cn>
      <apply>
       <plus></plus>
       <cn type="integer">2</cn>
       <cn type="integer">4</cn>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <cn type="integer">11</cn>
       <cn type="integer">9</cn>
      </apply>
      <cn type="integer">6</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <ci>normal-↘</ci>
      <apply>
       <times></times>
       <mtext>\color</mtext>
       <ci>M</ci>
       <ci>i</ci>
       <ci>d</ci>
       <ci>n</ci>
       <ci>i</ci>
       <ci>g</ci>
       <ci>h</ci>
       <ci>t</ci>
       <ci>B</ci>
       <ci>l</ci>
       <ci>u</ci>
       <ci>e</ci>
      </apply>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <ci>normal-↙</ci>
      <apply>
       <times></times>
       <mtext>\color</mtext>
       <ci>M</ci>
       <ci>i</ci>
       <ci>d</ci>
       <ci>n</ci>
       <ci>i</ci>
       <ci>g</ci>
       <ci>h</ci>
       <ci>t</ci>
       <ci>B</ci>
       <ci>l</ci>
       <ci>u</ci>
       <ci>e</ci>
      </apply>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <mtext>\color</mtext>
      <ci>M</ci>
      <ci>i</ci>
      <ci>d</ci>
      <ci>n</ci>
      <ci>i</ci>
      <ci>g</ci>
      <ci>h</ci>
      <ci>t</ci>
      <ci>B</ci>
      <ci>l</ci>
      <ci>u</ci>
      <ci>e</ci>
      <mtext>eval right</mtext>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <times></times>
      <cn type="integer">20</cn>
      <cn type="integer">6</cn>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <times></times>
      <mtext>\color</mtext>
      <ci>M</ci>
      <ci>i</ci>
      <ci>d</ci>
      <ci>n</ci>
      <ci>i</ci>
      <ci>g</ci>
      <ci>h</ci>
      <ci>t</ci>
      <ci>B</ci>
      <ci>l</ci>
      <ci>u</ci>
      <ci>e</ci>
      <mtext>eval left</mtext>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <ci>normal-↓</ci>
      <apply>
       <times></times>
       <mtext>\color</mtext>
       <ci>M</ci>
       <ci>i</ci>
       <ci>d</ci>
       <ci>n</ci>
       <ci>i</ci>
       <ci>g</ci>
       <ci>h</ci>
       <ci>t</ci>
       <ci>B</ci>
       <ci>l</ci>
       <ci>u</ci>
       <ci>e</ci>
      </apply>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cn type="integer">120</cn>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{|rcccl|}\hline\color{MidnightBlue}{\mbox{eval left}}&&(11+9)%
\times(2+4)&&\color{MidnightBlue}{\mbox{eval right}}\\
&\color{MidnightBlue}{\swarrow}&&\color{MidnightBlue}{\searrow}&\\
20\times(2+4)&&&&(11+9)\times 6\\
&\color{MidnightBlue}{\searrow}&&\color{MidnightBlue}{\swarrow}&\\
\color{MidnightBlue}{\mbox{eval right}}&&20\times 6&&\color{MidnightBlue}{%
\mbox{eval left}}\\
&&\color{MidnightBlue}{\downarrow}&&\\
&&120&&\\
\hline\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>A second, more abstract example is obtained from the following proof of each <a href="Group_(mathematics)" title="wikilink">group</a> element equalling the <a href="Group_(mathematics)#Definition" title="wikilink">inverse</a> of its inverse: <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Group axioms</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>A1</strong></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>A2</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>A3</strong>    </p></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Proof of <strong>R4</strong>: <em>a</em><sup>−1</sup>⋅(<em>a</em>⋅<em>b</em>) = <em>b</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>=</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>=</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>=</p></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Proof of <strong>R6</strong>: (<em>a</em><sup>−1</sup>)<sup>−1</sup> ⋅ 1 = <em>a</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>=</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>=</p></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Proof of <strong>R10</strong>: (<em>a</em><sup>−1</sup>)<sup>−1</sup> ⋅ <em>b</em> = <em>a</em> ⋅ <em>b</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>=</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>=</p></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Proof of <strong>R11</strong>: <em>a</em> ⋅ 1 = <em>a</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>=</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>=</p></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Proof of <strong>R12</strong>: (<em>a</em><sup>−1</sup>)<sup>−1</sup> = <em>a</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>=</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>=</p></td>
</tr>
</tbody>
</table>

<p>This proof starts from the given group axioms A1-A3, and establishes five propositions R4, R6, R10, R11, and R12, each of them using some earlier ones, and R12 being the main theorem. Some of the proofs require non-obvious, if not creative, steps, like applying axiom A2 in reverse, thereby rewriting "1" to "<em>a</em><sup>−1</sup> ⋅ a" in the first step of R6's proof. One of the historical motivations to develop the <em>theory of term rewriting</em> was to avoid the need for such steps, which are difficult to find by an unexperienced human, let alone by a computer program.</p>

<p>If a <a href="Term_rewriting#Term_rewriting_systems" title="wikilink">term rewriting system</a> is <strong>confluent</strong> and <em><a href="Rewriting#Termination" title="wikilink">terminating</a></em>, a straight-forward method exists to prove equality between two expressions (a.k.a. <em><a href="term_(logic)" title="wikilink">terms</a></em>) <em>s</em> and <em>t</em>: Starting with <em>s</em>, apply equalities<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> from left to right as long as possible, eventually obtaining a term <em>s’</em>. Obtain from <em>t</em> a term <em>t’</em> in a similar way. If both terms <em>s’</em> and <em>t’</em> literally agree, then <em>s</em> and <em>t</em> are (not surprisingly) proven equal. More important, if they disagree, <em>s</em> and <em>t</em> cannot be equal. That is, any two terms <em>s</em> and <em>t</em> that can be proven equal at all, can be so by that method.</p>

<p>The success of that method doesn't depend on a certain sophisticated order in which to apply rewrite rules, as <strong>confluence</strong> ensures that any sequence of rule applications will eventually lead to the same result (while the <em>termination</em> property ensures that any sequence will eventually reach an end at all). Therefore, if a confluent and terminating term rewriting system can be provided for some equational theory,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> not a tinge of creativity is required to perform proofs of term equality; that task hence becomes amenable to computer programs. Modern approaches handle more general <em>abstract rewriting systems</em> rather than <em>term</em> rewriting systems; the latter are a special case of the former.</p>
<h2 id="general-case-and-theory">General case and theory</h2>
<figure><b>(Figure)</b>
<figcaption>Pic.2: Confluence diagram|200px|thumb|In this diagram, 

<math display="inline" id="Confluence_(abstract_rewriting):1">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 reduces to both 

<math display="inline" id="Confluence_(abstract_rewriting):2">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Confluence_(abstract_rewriting):3">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 in zero or more rewrite steps (denoted by the asterisk). In order for the rewrite relation to be confluent, both reducts must in turn reduce to some common 

<math display="inline" id="Confluence_(abstract_rewriting):4">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

.</figcaption>
</figure>

<p>A rewriting system can be expressed as a directed graph in which nodes represent expressions and edges represent rewrites. So, for example, if the expression <em>a</em> can be rewritten into <em>b</em>, then we say that <em>b</em> is a <em>reduct</em> of <em>a</em> (alternatively, <em>a</em> <em>reduces to</em> <em>b</em>, or <em>b</em> is an <em>expansion</em> of <em>a</em>). This is represented using arrow notation; <em>a</em> → <em>b</em> indicates that <em>a</em> reduces to <em>b</em>. Intuitively, this means that the corresponding graph has a directed edge from <em>a</em> to <em>b</em>.</p>

<p>If there is a path between two graph nodes <em>c</em> and <em>d</em>, then the intermediate nodes form a <em>reduction sequence</em>. So, for instance, if <em>c</em> → <em>c</em>’ → <em>c</em>’’ → ... → <em>d</em>’ → <em>d</em>, then we can write <em>c</em> →<sup>*</sup> <em>d</em>, indicating the existence of a reduction sequence from <em>c</em> to <em>d</em>. Formally, →<sup>*</sup> is the <a href="Closure_(mathematics)#P_closures_of_binary_relations" title="wikilink">reflexive-transitive closure</a> of →. Using the example from the previous paragraph, we have (11+9)×(2+4) → 20×(2+4) and 20×(2+4) → 20×6, so (11+9)×(2+4) →<sup>*</sup> 20×6.</p>

<p>With this established, confluence can be defined as follows. Let <em>a</em>, <em>b</em>, <em>c</em> ∈ <em>S</em>, with <em>a</em> →<sup>*</sup> <em>b</em> and <em>a</em> →<sup>*</sup> <em>c</em>. <em>a</em> is deemed confluent if there exists a <em>d</em> ∈ <em>S</em> with <em>b</em> →<sup>*</sup> <em>d</em> and <em>c</em> →<sup>*</sup> <em>d</em>. If every <em>a</em> ∈ <em>S</em> is confluent, we say that → is confluent, or has the <em>Church-Rosser property</em>. This property is also sometimes called the <em>diamond property</em>, after the shape of the diagram shown on the right. Some authors reserve the term <em>diamond property</em> for a variant of the diagram with single reductions everywhere; that is, whenever <em>a</em> → <em>b</em> and <em>a</em> → <em>c</em>, there must exist a <em>d</em> such that <em>b</em> → <em>d</em> and <em>c</em> → <em>d</em>. The single-reduction variant is strictly stronger than the multi-reduction one.</p>
<h3 id="local-confluence">Local confluence</h3>

<p> </p>

<p>An element <em>a</em> ∈ <em>S</em> is said to be locally (or weakly) confluent if for all <em>b</em>, <em>c</em> ∈ <em>S</em> with <em>a</em> → <em>b</em> and <em>a</em> → <em>c</em> there exists <em>d</em> ∈ <em>S</em> with <em>b</em> →<sup>*</sup> <em>d</em> and <em>c</em> →* <em>d</em>. If every <em>a</em> ∈ <em>S</em> is locally confluent, then → is called locally (or weakly) confluent, or having the <em>weak Church-Rosser property</em>. This is different from confluence in that <em>b</em> and <em>c</em> must be reduced from <em>a</em> in one step. In analogy with this, confluence is sometimes referred to as <em>global confluence</em>.</p>

<p>The relation →<sup>*</sup>, introduced as a notation for reduction sequences, may be viewed as a rewriting system in its own right, whose relation is the <a href="Closure_(mathematics)#P_closures_of_binary_relations" title="wikilink">reflexive-transitive closure</a> of <em>→</em>. Since a sequence of reduction sequences is again a reduction sequence (or, equivalently, since forming the reflexive-transitive closure is <a href="idempotence#Unary_operation" title="wikilink">idempotent</a>), →<sup>**</sup> = →<sup>*</sup>. It follows that → is confluent if and only if →<sup>*</sup> is locally confluent.</p>

<p>A rewriting system may be locally confluent without being (globally) confluent. Examples are shown in picture 3 and 4. However, <a href="Newman's_lemma" title="wikilink">Newman's lemma</a> states that if a locally confluent rewriting system has no infinite reduction sequences (in which case it is said to be <em>terminating</em> or <em>strongly normalizing</em>), then it is globally confluent.</p>
<h3 id="semi-confluence">Semi-confluence</h3>

<p>The definition of local confluence differs from that of global confluence in that only elements reached from a given element in a single rewriting step are considered. By considering one element reached in a single step and another element reached by an arbitrary sequence, we arrive at the intermediate concept of semi-confluence: <em>a</em> ∈ <em>S</em> is said to be semi-confluent if for all <em>b</em>, <em>c</em> ∈ <em>S</em> with <em>a</em> → <em>b</em> and <em>a</em> →<sup>*</sup> <em>c</em> there exists <em>d</em> ∈ <em>S</em> with <em>b</em> →<sup>*</sup> <em>d</em> and <em>c</em> →<sup>*</sup> <em>d</em>; if every <em>a</em> ∈ <em>S</em> is semi-confluent, we say that → is semi-confluent.</p>

<p>A semi-confluent element need not be confluent, but a semi-confluent rewriting system is necessarily confluent, and a confluent system is trivially semi-confluent.</p>
<h3 id="strong-confluence">Strong confluence</h3>

<p>Strong confluence is another variation on local confluence that allows us to conclude that a rewriting system is globally confluent. An element <em>a</em> ∈ <em>S</em> is said to be strongly confluent if for all <em>b</em>, <em>c</em> ∈ <em>S</em> with <em>a</em> → <em>b</em> and <em>a</em> → <em>c</em> there exists <em>d</em> ∈ <em>S</em> with <em>b</em> →<sup>*</sup> <em>d</em> and either <em>c</em> → <em>d</em> or <em>c</em> = <em>d</em>; if every <em>a</em> ∈ <em>S</em> is strongly confluent, we say that → is strongly confluent.</p>

<p>A strongly confluent element need not be confluent, but a strongly confluent rewriting system is necessarily confluent.</p>
<h2 id="examples-of-confluent-systems">Examples of confluent systems</h2>
<ul>
<li>Reduction of polynomials modulo an ideal is a confluent rewrite system provided one works with a <a href="Gröbner_basis" title="wikilink">Gröbner basis</a>.</li>
<li><a href="Matsumoto's_theorem_(group_theory)" title="wikilink">Matsumoto's theorem</a> follows from confluence of the braid relations.</li>
<li>β-reduction of λ-terms is confluent by the <a href="Church-Rosser_theorem" title="wikilink">Church-Rosser theorem</a>.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Church–Rosser_theorem" title="wikilink">Church–Rosser theorem</a></li>
<li><a href="Convergence_(logic)" title="wikilink">Convergence (logic)</a></li>
<li><a href="Critical_pair_(logic)" title="wikilink">Critical pair (logic)</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li><em>Term Rewriting Systems</em>, Terese, Cambridge Tracts in Theoretical Computer Science, 2003.</li>
<li><em>Term Rewriting and All That</em>, <a href="Franz_Baader" title="wikilink">Franz Baader</a> and <a href="Tobias_Nipkow" title="wikilink">Tobias Nipkow</a>, Cambridge University Press, 1998</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Rewriting_systems" title="wikilink">Category:Rewriting systems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">; here: p.134; axiom and proposition names follow the original text<a href="#fnref1">↩</a></li>
<li id="fn2">then called <em>rewrite rules</em> to emphasize their left-to-right orientation<a href="#fnref2">↩</a></li>
<li id="fn3">The <a href="Knuth–Bendix_completion_algorithm" title="wikilink">Knuth–Bendix completion algorithm</a> can be used to compute such a system from a given set of equations. Such a system e.g. for groups is shown <a href="Word_problem_(mathematics)#Example:_A_term_rewriting_system_to_decide_the_word_problem_in_the_free_group" title="wikilink">here</a>, with its propositions consistently numbered. Using it, a proof of e.g. R6 consists in applying R11 and R12 in any order to (<em>a</em><sup>−1</sup>)<sup>−1</sup>⋅1 to obtain <em>a</em>.; no other rules are applicable.<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
