<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="59">Flow network</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Flow network</h1>
<hr/>

<p>In <a href="graph_theory" title="wikilink">graph theory</a>, a <strong>flow network</strong> (also known as a <strong>transportation network</strong>) is a <a href="directed_graph" title="wikilink">directed graph</a> where each edge has a <strong>capacity</strong> and each edge receives a flow. The amount of flow on an edge cannot exceed the capacity of the edge. Often in <a href="operations_research" title="wikilink">operations research</a>, a directed graph is called a <strong>network</strong>. The vertices are called <strong>nodes</strong> and the edges are called <strong>arcs</strong>. A flow must satisfy the restriction that the amount of flow into a node equals the amount of flow out of it, unless it is a <strong>source</strong>, which has only outgoing flow, or <strong>sink</strong>, which has only incoming flow. A network can be used to model traffic in a road system, circulation with demands, fluids in pipes, currents in an electrical circuit, or anything similar in which something travels through a network of nodes.</p>
<h2 id="definition">Definition</h2>

<p>Let 

<math display="inline" id="Flow_network:0">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

 be a finite <a href="directed_graph" title="wikilink">directed graph</a> in which every <a href="edge_(graph_theory)" title="wikilink">edge</a> 

<math display="inline" id="Flow_network:1">
 <semantics>
  <mrow>
   <mrow>
    <mo lspace="7.5pt" stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ (u,v)\in E
  </annotation>
 </semantics>
</math>

 has a non-negative, real-valued capacity 

<math display="inline" id="Flow_network:2">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>c</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ c(u,v)
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Flow_network:3">
 <semantics>
  <mrow>
   <mrow>
    <mo lspace="7.5pt" stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∉</mo>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ (u,v)\not\in E
  </annotation>
 </semantics>
</math>


, we assume that 

<math display="inline" id="Flow_network:4">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="5pt" width="+5pt">
     <mi>c</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>c</ci>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ c(u,v)=0
  </annotation>
 </semantics>
</math>

. We distinguish two vertices: a source 

<math display="inline" id="Flow_network:5">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>s</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ s
  </annotation>
 </semantics>
</math>

 and a sink 

<math display="inline" id="Flow_network:6">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>t</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ t
  </annotation>
 </semantics>
</math>

. A flow in a flow network is a <a href="real_number" title="wikilink">real</a> <a href="function_(mathematics)" title="wikilink">function</a> 

<math display="inline" id="Flow_network:7">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>V</mi>
     <mo>×</mo>
     <mi>V</mi>
    </mrow>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>V</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ f:V\times V\rightarrow\mathbb{R}
  </annotation>
 </semantics>
</math>

 with the following three properties for all nodes 

<math display="inline" id="Flow_network:8">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>u</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ u
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Flow_network:9">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>v</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ v
  </annotation>
 </semantics>
</math>

:</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Capacity constraints</strong>:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Flow_network:10">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="5pt" width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ f(u,v)\leq c(u,v)
  </annotation>
 </semantics>
</math>

. The flow along an edge cannot exceed its capacity.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>Skew symmetry</strong>:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Flow_network:11">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="5pt" width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>v</ci>
       <ci>u</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ f(u,v)=-f(v,u)
  </annotation>
 </semantics>
</math>

. The net flow from 

<math display="inline" id="Flow_network:12">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>u</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ u
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Flow_network:13">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>v</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ v
  </annotation>
 </semantics>
</math>


 must be the opposite of the net flow from 

<math display="inline" id="Flow_network:14">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>v</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ v
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Flow_network:15">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>u</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ u
  </annotation>
 </semantics>
</math>

 (see example).</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Flow conservation</strong>:</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Flow_network:16">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" lspace="7.5pt" symmetric="true">∑</mo>
     <mrow>
      <mi>w</mi>
      <mo>∈</mo>
      <mi>V</mi>
     </mrow>
    </msub>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>w</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>w</ci>
       <ci>V</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>w</ci>
      </interval>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \sum_{w\in V}f(u,w)=0
  </annotation>
 </semantics>
</math>

, unless 

<math display="inline" id="Flow_network:17">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>u</mi>
   </mpadded>
   <mo>=</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>u</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ u=s
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Flow_network:18">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>u</mi>
   </mpadded>
   <mo>=</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>u</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ u=t
  </annotation>
 </semantics>
</math>


. The net flow to a node is zero, except for the source, which "produces" flow, and the sink, which "consumes" flow.</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>i.e. <em>' Flow conservation</em>' implies

<math display="block" id="Flow_network:19">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" lspace="7.5pt" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>E</mi>
     </mrow>
    </munder>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo>,</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>E</mi>
     </mrow>
    </munder>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <interval closure="open">
        <ci>u</ci>
        <ci>v</ci>
       </interval>
       <ci>E</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <interval closure="open">
        <ci>v</ci>
        <ci>z</ci>
       </interval>
       <ci>E</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>v</ci>
       <ci>z</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \sum_{(u,v)\in E}f(u,v)=\sum_{(v,z)\in E}f(v,z)
  </annotation>
 </semantics>
</math>

, for each vertex 

<math display="inline" id="Flow_network:20">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>v</mi>
   </mpadded>
   <mo>∈</mo>
   <mrow>
    <mi>V</mi>
    <mo>∖</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>s</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <apply>
     <setdiff></setdiff>
     <ci>V</ci>
     <set>
      <ci>s</ci>
      <ci>t</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ {v\in V\setminus\{s,t\}}
  </annotation>
 </semantics>
</math>

</p>

<p>Notice that 

<math display="inline" id="Flow_network:21">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>f</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ f(u,v)
  </annotation>
 </semantics>
</math>

 is the <em>net</em> flow from 

<math display="inline" id="Flow_network:22">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>u</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ u
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Flow_network:23">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>v</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ v
  </annotation>
 </semantics>
</math>


. If the graph represents a physical network, and if there is a real flow of, for example, 4 units from 

<math display="inline" id="Flow_network:24">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>u</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ u
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Flow_network:25">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>v</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ v
  </annotation>
 </semantics>
</math>

, and a real flow of 3 units from 

<math display="inline" id="Flow_network:26">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>v</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ v
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Flow_network:27">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>u</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ u
  </annotation>
 </semantics>
</math>

, we have 

<math display="inline" id="Flow_network:28">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="5pt" width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ f(u,v)=1
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Flow_network:29">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="5pt" width="+5pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>v</ci>
      <ci>u</ci>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ f(v,u)=-1
  </annotation>
 </semantics>
</math>

.</p>

<p>Basically we can say that flow for a physical network is flow leaving at s = 

<math display="inline" id="Flow_network:30">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" lspace="7.5pt" symmetric="true">∑</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mi>E</mi>
    </mrow>
   </msub>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <interval closure="open">
       <ci>s</ci>
       <ci>v</ci>
      </interval>
      <ci>E</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>s</ci>
      <ci>v</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ \sum_{(s,v)\in E}f(s,v)
  </annotation>
 </semantics>
</math>

</p>

<p>The <strong>residual capacity</strong> of an edge is 

<math display="inline" id="Flow_network:31">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mpadded lspace="5pt" width="+5pt">
      <mi>c</mi>
     </mpadded>
     <mi>f</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>f</ci>
     </apply>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>c</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ c_{f}(u,v)=c(u,v)-f(u,v)
  </annotation>
 </semantics>
</math>

. This defines a <strong>residual network</strong> denoted 

<math display="inline" id="Flow_network:32">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="5pt" width="+5pt">
     <mi>G</mi>
    </mpadded>
    <mi>f</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <msub>
     <mi>E</mi>
     <mi>f</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>f</ci>
    </apply>
    <interval closure="open">
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>f</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ G_{f}(V,E_{f})
  </annotation>
 </semantics>
</math>

, giving the amount of <em>available</em> capacity. See that there can be a path from 

<math display="inline" id="Flow_network:33">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>u</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ u
  </annotation>
 </semantics>
</math>


 to 

<math display="inline" id="Flow_network:34">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>v</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ v
  </annotation>
 </semantics>
</math>

 in the residual network, even though there is no path from 

<math display="inline" id="Flow_network:35">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>u</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ u
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Flow_network:36">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>v</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ v
  </annotation>
 </semantics>
</math>

 in the original network. Since flows in opposite directions cancel out, <em>decreasing</em> the flow from 

<math display="inline" id="Flow_network:37">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>v</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ v
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Flow_network:38">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>u</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ u
  </annotation>
 </semantics>
</math>


 is the same as <em>increasing</em> the flow from 

<math display="inline" id="Flow_network:39">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>u</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ u
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Flow_network:40">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>v</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ v
  </annotation>
 </semantics>
</math>

. An <strong>augmenting path</strong> is a path 

<math display="inline" id="Flow_network:41">
 <semantics>
  <mrow>
   <mo lspace="7.5pt" stretchy="false">(</mo>
   <msub>
    <mi>u</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>u</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>u</mi>
    <mi>k</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>k</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ (u_{1},u_{2},\dots,u_{k})
  </annotation>
 </semantics>
</math>

 in the residual network, where 

<math display="inline" id="Flow_network:42">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="5pt" width="+5pt">
     <mi>u</mi>
    </mpadded>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ u_{1}=s
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Flow_network:43">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="5pt" width="+5pt">
     <mi>u</mi>
    </mpadded>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>k</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ u_{k}=t
  </annotation>
 </semantics>
</math>


, and 

<math display="inline" id="Flow_network:44">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mpadded lspace="5pt" width="+5pt">
      <mi>c</mi>
     </mpadded>
     <mi>f</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>u</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>u</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>f</ci>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ c_{f}(u_{i},u_{i+1})>0
  </annotation>
 </semantics>
</math>

. A network is at <a href="maximum_flow" title="wikilink">maximum flow</a> if and only if there is no augmenting path in the residual network 

<math display="inline" id="Flow_network:45">
 <semantics>
  <msub>
   <mpadded lspace="5pt" width="+5pt">
    <mi>G</mi>
   </mpadded>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ G_{f}
  </annotation>
 </semantics>
</math>

 .</p>

<p>So 

<math display="inline" id="Flow_network:46">
 <semantics>
  <msub>
   <mpadded lspace="5pt" width="+5pt">
    <mi>G</mi>
   </mpadded>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ G_{f}
  </annotation>
 </semantics>
</math>

 is constructed using graph G as follows:</p>

<p>1. Vertices of 

<math display="inline" id="Flow_network:47">
 <semantics>
  <msub>
   <mpadded lspace="5pt" width="+5pt">
    <mi>G</mi>
   </mpadded>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ G_{f}
  </annotation>
 </semantics>
</math>

 = 

<math display="inline" id="Flow_network:48">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>V</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ V
  </annotation>
 </semantics>
</math>


</p>

<p>2. Edges of 

<math display="inline" id="Flow_network:49">
 <semantics>
  <msub>
   <mpadded lspace="5pt" width="+5pt">
    <mi>G</mi>
   </mpadded>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ G_{f}
  </annotation>
 </semantics>
</math>

 = 

<math display="inline" id="Flow_network:50">
 <semantics>
  <msub>
   <mpadded lspace="5pt" width="+5pt">
    <mi>E</mi>
   </mpadded>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ E_{f}
  </annotation>
 </semantics>
</math>

 defined as-</p>

<p>For each edge 

<math display="inline" id="Flow_network:51">
 <semantics>
  <mrow>
   <mrow>
    <mo lspace="7.5pt" stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ (x,y)\in E
  </annotation>
 </semantics>
</math>

</p>

<p><code>    (i). If </code>

<math display="inline" id="Flow_network:52">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded lspace="5pt" width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo><</mo>
    <mrow>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ f(x,y)<c(x,y),
  </annotation>
 </semantics>
</math>

<code> make Forward edge </code>

<math display="inline" id="Flow_network:53">
 <semantics>
  <mrow>
   <mrow>
    <mo lspace="7.5pt" stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi>E</mi>
    <mi>f</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ (x,y)\in E_{f}
  </annotation>
 </semantics>
</math>


<code> with '''capacity ''' </code>

<math display="inline" id="Flow_network:54">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="5pt" width="+5pt">
     <mi>c</mi>
    </mpadded>
    <mi>f</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>c</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ c_{f}=c(x,y)-f(x,y)
  </annotation>
 </semantics>
</math>

<code>.</code><br/>
<code>    (ii). If </code>

<math display="inline" id="Flow_network:55">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded lspace="5pt" width="+5pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>></mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ f(x,y)>0,
  </annotation>
 </semantics>
</math>

<code> make Backward edge </code>

<math display="inline" id="Flow_network:56">
 <semantics>
  <mrow>
   <mrow>
    <mo lspace="7.5pt" stretchy="false">(</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi>E</mi>
    <mi>f</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>y</ci>
     <ci>x</ci>
    </interval>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ (y,x)\in E_{f}
  </annotation>
 </semantics>
</math>

<code> with '''capacity ''' </code>

<math display="inline" id="Flow_network:57">
 <semantics>
  <mrow>
   <msub>
    <mpadded lspace="5pt" width="+5pt">
     <mi>c</mi>
    </mpadded>
    <mi>f</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ c_{f}=f(x,y)
  </annotation>
 </semantics>
</math>

<code>.</code></p>

<p>This concept is used in <a href="Ford–Fulkerson_algorithm" title="wikilink">Ford–Fulkerson algorithm</a> which computes the <a href="maximum_flow" title="wikilink">maximum flow</a> in a flow network.</p>

<p>Sometimes one needs to model a network with more than one source, a <strong>supersource</strong> is introduced to the graph.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> This consists of a vertex connected to each of the sources with edges of infinite capacity, so as to act as a global source. A similar construct for sinks is called a <strong>supersink</strong>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="example">Example</h2>

<p> To the right you see a flow network with source labeled 

<math display="inline" id="Flow_network:58">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>


, sink 

<math display="inline" id="Flow_network:59">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, and four additional nodes. The flow and capacity is denoted 

<math display="inline" id="Flow_network:60">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>/</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>f</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f/c
  </annotation>
 </semantics>
</math>

. Notice how the network upholds skew symmetry, capacity constraints and flow conservation. The total amount of flow from 

<math display="inline" id="Flow_network:61">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Flow_network:62">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is 5, which can be easily seen from the fact that the total outgoing flow from 

<math display="inline" id="Flow_network:63">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>


 is 5, which is also the incoming flow to 

<math display="inline" id="Flow_network:64">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

. We know that no flow appears or disappears in any of the other nodes.</p>

<p> Below you see the residual network for the given flow. Notice how there is positive residual capacity on some edges where the original capacity is zero, for example for the edge 

<math display="inline" id="Flow_network:65">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>d</mi>
   <mo>,</mo>
   <mi>c</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>d</ci>
    <ci>c</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (d,c)
  </annotation>
 </semantics>
</math>

. This flow is not a <a href="max_flow" title="wikilink">maximum flow</a>. There is available capacity along the paths 

<math display="inline" id="Flow_network:66">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>s</mi>
   <mo>,</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>c</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>s</ci>
    <ci>a</ci>
    <ci>c</ci>
    <ci>t</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,a,c,t)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Flow_network:67">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>s</mi>
   <mo>,</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo>,</mo>
   <mi>d</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>s</ci>
    <ci>a</ci>
    <ci>b</ci>
    <ci>d</ci>
    <ci>t</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,a,b,d,t)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Flow_network:68">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>s</mi>
   <mo>,</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo>,</mo>
   <mi>d</mi>
   <mo>,</mo>
   <mi>c</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>s</ci>
    <ci>a</ci>
    <ci>b</ci>
    <ci>d</ci>
    <ci>c</ci>
    <ci>t</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,a,b,d,c,t)
  </annotation>
 </semantics>
</math>


, which are then the augmenting paths. The residual capacity of the first path is 

<math display="inline" id="Flow_network:69">
 <semantics>
  <mrow>
   <mi>min</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>c</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo>,</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo>,</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mi>c</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo>,</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo>,</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mi>c</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo>,</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo>,</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <min></min>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>c</ci>
      <interval closure="open">
       <ci>s</ci>
       <ci>a</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>s</ci>
       <ci>a</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>c</ci>
      <interval closure="open">
       <ci>a</ci>
       <ci>c</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>a</ci>
       <ci>c</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>c</ci>
      <interval closure="open">
       <ci>c</ci>
       <ci>t</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>c</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min(c(s,a)-f(s,a),c(a,c)-f(a,c),c(c,t)-f(c,t))
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Flow_network:70">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>5</mn>
      <mo>-</mo>
      <mn>3</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mn>3</mn>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mn>2</mn>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <min></min>
      <apply>
       <minus></minus>
       <cn type="integer">5</cn>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">3</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <min></min>
      <cn type="integer">2</cn>
      <cn type="integer">1</cn>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\min(5-3,3-2,2-1)=\min(2,1,1)=1
  </annotation>
 </semantics>
</math>

. Notice that as long as there exists some path with a positive residual capacity, the flow will not be maximum. The residual capacity for some path is the minimum residual capacity of all edges in that path.</p>
<h2 id="applications">Applications</h2>

<p>Picture a series of water pipes, fitting into a network. Each pipe is of a certain diameter, so it can only maintain a flow of a certain amount of water. Anywhere that pipes meet, the total amount of water coming into that junction must be equal to the amount going out, otherwise we would quickly run out of water, or we would have a buildup of water. We have a water inlet, which is the source, and an outlet, the sink. A flow would then be one possible way for water to get from source to sink so that the total amount of water coming out of the outlet is consistent. Intuitively, the total flow of a network is the rate at which water comes out of the outlet.</p>

<p>Flows can pertain to people or material over transportation networks, or to electricity over <a href="electrical_distribution" title="wikilink">electrical distribution</a> systems. For any such physical network, the flow coming into any intermediate node needs to equal the flow going out of that node. This conservation constraint was formalized as <a href="Kirchhoff's_current_law" title="wikilink">Kirchhoff's current law</a>.</p>

<p>Flow networks also find applications in <a class="uri" href="ecology" title="wikilink">ecology</a>: flow networks arise naturally when considering the flow of nutrients and energy between different organizations in a <a href="food_web" title="wikilink">food web</a>. The mathematical problems associated with such networks are quite different from those that arise in networks of fluid or traffic flow. The field of ecosystem network analysis, developed by <a href="Robert_Ulanowicz" title="wikilink">Robert Ulanowicz</a> and others, involves using concepts from <a href="information_theory" title="wikilink">information theory</a> and <a class="uri" href="thermodynamics" title="wikilink">thermodynamics</a> to study the evolution of these networks over time.</p>

<p>The simplest and most common problem using flow networks is to find what is called the <a href="maximum_flow_problem" title="wikilink">maximum flow</a>, which provides the largest possible total flow from the source to the sink in a given graph. There are many other problems which can be solved using max flow algorithms, if they are appropriately modeled as flow networks, such as <a href="bipartite_matching" title="wikilink">bipartite matching</a>, the <a href="assignment_problem" title="wikilink">assignment problem</a> and the <a href="transportation_problem" title="wikilink">transportation problem</a>. Maximum flow problems can be solved efficiently with the <a href="relabel-to-front_algorithm" title="wikilink">relabel-to-front algorithm</a>. The <a href="max-flow_min-cut_theorem" title="wikilink">max-flow min-cut theorem</a> states that finding a maximal network flow is equivalent to finding a <a href="Cut_(graph_theory)" title="wikilink">cut</a> of minimum capacity that separates the source and the sink. Where a cut is the division of vertices such that the source is in one division and the sink is in another.</p>

<p>In a <a href="multi-commodity_flow_problem" title="wikilink">multi-commodity flow problem</a>, you have multiple sources and sinks, and various "commodities" which are to flow from a given source to a given sink. This could be for example various goods that are produced at various factories, and are to be delivered to various given customers through the <em>same</em> transportation network.</p>

<p>In a <a href="minimum_cost_flow_problem" title="wikilink">minimum cost flow problem</a>, each edge 

<math display="inline" id="Flow_network:71">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>,</mo>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>u</ci>
    <ci>v</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u,v
  </annotation>
 </semantics>
</math>

 has a given cost 

<math display="inline" id="Flow_network:72">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(u,v)
  </annotation>
 </semantics>
</math>

, and the cost of sending the flow 

<math display="inline" id="Flow_network:73">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(u,v)
  </annotation>
 </semantics>
</math>


 across the edge is 

<math display="inline" id="Flow_network:74">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⋅</mo>
    <mi>k</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
     <ci>k</ci>
    </apply>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(u,v)\cdot k(u,v)
  </annotation>
 </semantics>
</math>

. The objective is to send a given amount of flow from the source to the sink, at the lowest possible price.</p>

<p>In a <a href="circulation_problem" title="wikilink">circulation problem</a>, you have a lower bound 

<math display="inline" id="Flow_network:75">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l(u,v)
  </annotation>
 </semantics>
</math>

 on the edges, in addition to the upper bound 

<math display="inline" id="Flow_network:76">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(u,v)
  </annotation>
 </semantics>
</math>

. Each edge also has a cost. Often, flow conservation holds for <em>all</em> nodes in a circulation problem, and there is a connection from the sink back to the source. In this way, you can dictate the total flow with 

<math display="inline" id="Flow_network:77">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <interval closure="open">
     <ci>t</ci>
     <ci>s</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l(t,s)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Flow_network:78">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <interval closure="open">
     <ci>t</ci>
     <ci>s</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(t,s)
  </annotation>
 </semantics>
</math>


. The flow <em>circulates</em> through the network, hence the name of the problem.</p>

<p>In a <strong>network with gains</strong> or <strong>generalized network</strong> each edge has a <strong><a href="gain_graph" title="wikilink">gain</a></strong>, a real number (not zero) such that, if the edge has gain <em>g</em>, and an amount <em>x</em> flows into the edge at its tail, then an amount <em>gx</em> flows out at the head.</p>

<p>In a <strong>source localization problem</strong>, an algorithm tries to identify the most likely source node of information diffusion through a partially observed network. This can be done in linear time for trees and cubic time for arbitrary networks and has applications ranging from tracking mobile phone users to identifying the originating village of disease outbreaks.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Braess'_paradox" title="wikilink">Braess' paradox</a></li>
<li><a class="uri" href="Centrality" title="wikilink">Centrality</a></li>
<li><a href="Constructal_theory" title="wikilink">Constructal theory</a></li>
<li><a href="Ford–Fulkerson_algorithm" title="wikilink">Ford–Fulkerson algorithm</a></li>
<li><a href="Dinic's_algorithm" title="wikilink">Dinic's algorithm</a></li>
<li><a href="Flow_(computer_networking)" title="wikilink">Flow (computer networking)</a></li>
<li><a href="Flow_graph" title="wikilink">Flow graph</a></li>
<li><a href="Max-flow_min-cut_theorem" title="wikilink">Max-flow min-cut theorem</a></li>
<li><a href="Oriented_matroid" title="wikilink">Oriented matroid</a></li>
<li><a href="Shortest_path_problem" title="wikilink">Shortest path problem</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www-b2.is.tokushima-u.ac.jp/~ikeda/suuri/maxflow/Maxflow.shtml">Maximum Flow Problem</a></li>
<li>[<a class="uri" href="http://www.topcoder.com/tc?module=Static&amp;d1">http://www.topcoder.com/tc?module=Static&amp;d1;</a>;=tutorials&amp;d2;=maxFlow Maximum Flow]</li>
<li><a href="http://www.dis.uniroma1.it/~challenge9/download.shtml">Real graph instances</a></li>
<li><a href="http://www.di.unipi.it/di/groups/optimize/"> Software, papers, test graphs, etc.</a></li>
<li><a href="http://www.avglab.com/andrew/soft.html">[Software and papers for network flow problems</a></li>
<li><a href="http://lemon.cs.elte.hu/">Lemon C++ library with several maximum flow and minimum cost circulation algorithms</a></li>
<li><a href="http://quickgraph.codeplex.com/">QuickGraph</a>, graph data structures and algorithms for .Net</li>
</ul>

<p>"</p>

<p><a href="Category:Network_flow" title="wikilink">Category:Network flow</a> <a href="Category:Graph_algorithms" title="wikilink">Category:Graph algorithms</a> <a href="Category:Operations_research" title="wikilink">Category:Operations research</a> <a href="Category:Directed_graphs" title="wikilink">Category:Directed graphs</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a class="uri" href="http://www.pedropinto.org.s3.amazonaws.com/publications/locating_source_diffusion_networks.pdf">http://www.pedropinto.org.s3.amazonaws.com/publications/locating_source_diffusion_networks.pdf</a><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
