<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1040">Performance engineering</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Performance engineering</h1>
<hr/>

<p><strong>Performance engineering</strong> or SPE (Systems Performance Engineering or Software Performance Engineering) within <a href="systems_engineering" title="wikilink">systems engineering</a>, encompasses the set of roles, skills, activities, practices, tools, and deliverables applied at every phase of the <a href="systems_development_life_cycle" title="wikilink">systems development life cycle</a> which ensures that a solution will be designed, implemented, and operationally supported to meet the <a href="non-functional_requirement" title="wikilink">non-functional requirements</a> for performance (such as <a class="uri" href="throughput" title="wikilink">throughput</a>, <a href="Latency_(engineering)" title="wikilink">latency</a>, or <a href="Computer_memory" title="wikilink">memory</a> usage).</p>

<p>It may be alternatively referred to as <em>software performance engineering</em> or <a href="application_performance_engineering" title="wikilink">application performance engineering</a> within <a href="software_engineering" title="wikilink">software engineering</a>. As the connection between application success and business success continues to gain recognition, particularly in the mobile space, application performance engineering has taken on a preventative and perfective<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> role within the software development life cycle. As such, the term is typically used to describe the processes, people and technologies required to effectively test non-functional requirements, ensure adherence to service levels and optimize application performance prior to deployment.</p>

<p>The term <em>performance engineering</em> encompasses more than just the software and supporting infrastructure, and as such the term performance engineering is preferable from a macro view. Adherence to the non-functional requirements is also validated post-deployment by monitoring the production systems. This is part of <a href="IT_service_management" title="wikilink">IT service management</a> (see also <a href="Information_Technology_Infrastructure_Library" title="wikilink">ITIL</a>).</p>

<p>Performance engineering has become a separate discipline at a number of large corporations, with tasking separate but parallel to Systems Engineering. It is pervasive, involving people from multiple organizational units; but predominantly within the <a href="information_technology" title="wikilink">information technology</a> organization.</p>
<h2 id="performance-engineering-objectives">Performance engineering objectives</h2>
<ul>
<li>Increase business revenue by ensuring the system can process transactions within the requisite timeframe</li>
<li>Eliminate system failure requiring scrapping and writing off the system development effort due to performance objective failure</li>
<li>Eliminate late system deployment due to <a href="performance_(disambiguation)" title="wikilink">performance</a> issues</li>
<li>Eliminate avoidable system rework due to performance issues</li>
<li>Eliminate avoidable system tuning efforts</li>
<li>Avoid additional and unnecessary hardware acquisition costs</li>
<li>Reduce increased software maintenance costs due to performance problems in production</li>
<li>Reduce increased software maintenance costs due to software impacted by ad hoc performance fixes</li>
<li>Reduce additional operational overhead for handling system issues due to performance problems</li>
<li>Identify future bottlenecks by simulation over prototype</li>
</ul>
<h2 id="performance-engineering-approach">Performance engineering approach</h2>

<p>Because this discipline is applied within multiple methodologies, the following activities will occur within differently specified phases. However if the phases of the <a href="IBM_Rational_Unified_Process" title="wikilink">rational unified process</a> (RUP) are used as a framework, then the activities will occur as follows:</p>
<h3 id="inception">Inception</h3>

<p>During this first conceptual phase of a program or project, critical <a href="business_process" title="wikilink">business processes</a> are identified. Typically they are classified as critical based upon revenue value, cost savings, or other assigned business value. This classification is done by the business unit, not the IT organization.</p>

<p>High level risks that may impact system performance are identified and described at this time. An example might be known performance risks for a particular vendor system.</p>

<p>Finally performance activities, roles, and deliverables are identified for the Elaboration phase. Activities and resource loading are incorporated into the Elaboration phase project plans.</p>
<h3 id="elaboration">Elaboration</h3>

<p>During this defining phase, the critical business processes are decomposed to critical <a href="use_cases" title="wikilink">use cases</a>. Such use cases will be decomposed further, as needed, to single page (screen) transitions. These are the use cases that will be subjected to script driven <a href="performance_testing" title="wikilink">performance testing</a>.</p>

<p>The type of requirements that relate to Performance Engineering are the <a href="non-functional_requirements" title="wikilink">non-functional requirements</a>, or NFR. While a functional requirement relates to <strong>what</strong> business operations are to be performed, a performance related non-functional requirement will relate to <strong>how fast</strong> that business operation performs under defined circumstances.</p>

<p>The concept of "defined circumstances" is vital. For example:</p>
<ul>
<li>Invalid – the system should respond to user input within 10 seconds.</li>
<li>Valid – for use case ABC the system will respond to a valid user entry within 5 seconds for a median load of 250 active users and 2000 logged in users 95% of the time; or within 10 seconds for a peak load of 500 active users and 4000 logged in users 90% of the time.</li>
</ul>

<p>Note the critical difference between the two specifications. The first example provides no conditions. The second clearly identifies the conditions under which the system is to perform. The second example may have a <a href="service_level_agreement" title="wikilink">service level agreement</a>, the first should not. The capacity planners and architects can actually design and build a system to meet the criteria for the valid nonfunctional requirement – but not for the invalid one. Testers may build a reliable performance test for the second example, but not for the invalid example.</p>

<p>Each critical use case must have an associated NFR. If, for a given use case, no existing NFR is applicable, a new NFR specific to that use case must be created.</p>

<p>Non functional requirements are not limited to use cases. The overall <strong>system volumetrics</strong> must be specified. These will describe the overall system load over a specified time period, defining how many of each type of business transaction will be executed per unit of time. Commonly volumetrics describe a typical business day, and then are broken down for each hour. This will describe how system load will vary over the course of the day. For example: 1200 of transaction A, 300 of transaction B, 3300 of transaction C, etc. for a given business day; then in hour 1 so many executions of A, B, C etc., in hour 2 so many transaction executions, and so on. The information is often formatted in a tabular form for clarity. If different user classes are executing the transactions, this information will also be incorporated in the NFR documentation. Finally, the transactions may be classified as to general type, normally being user interaction, report generation, and batch processing.</p>

<p>The system volumetrics documented in the NFR documentation will be used as inputs for both <a href="load_testing" title="wikilink">load testing</a> and <a href="stress_testing" title="wikilink">stress testing</a> of the system during the <a href="Software_performance_testing" title="wikilink">performance test</a>. Computer scientist have been using all kinds of approaches, e.g., Queueing Theory, to develop performance evaluation models. <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>At this point it is suggested that performance modeling be performed using the use case information as input. This may be done using a performance lab, and using prototypes and mockups of the "to be" system; or a vendor provided modeling tool may be used; or even merely a spreadsheet workbook, where each use case is modeled in a single sheet, and a summary sheet is used to provide high level information for all of the use cases.</p>

<p>It is recommended that <a href="Unified_Modeling_Language" title="wikilink">Unified Modeling Language</a> <a href="sequence_diagrams" title="wikilink">sequence diagrams</a> be generated at the physical tier level for each use case. The physical tiers are represented by the vertical object columns, and the message communication between the tiers by the horizontal arrows. Timing information should be associated with each horizontal arrow; this should correlate with the performance model.</p>

<p>Some performance engineering activities related to performance testing should be executed in this phase. They include validating a performance <a href="test_strategy" title="wikilink">test strategy</a>, developing a performance test plan, determining the sizing of test data sets, developing a performance test data plan, and identifying performance test scenarios.</p>

<p>For any system of significant impact, a monitoring plan and a monitoring design are developed in this phase. Performance engineering applies a subset of activities related to performance monitoring, both for the performance test environment as well as for the production environment.</p>

<p>The risk document generated in the previous phase is revisited here. A risk mitigation plan is determined for each identified performance risk; and time, cost, and responsibility is determined and documented.</p>

<p>Finally performance activities, roles, and deliverables are identified for the Construction phase. Activities and resource loading are incorporated into the Construction phase project plans. These will be elaborated for each iteration.</p>
<h3 id="construction">Construction</h3>

<p>Early in this phase a number of performance tool related activities are required. These include:</p>
<ul>
<li>Identify key development team members as subject matter experts for the selected tools</li>
<li>Specify a <a href="Profiler_(computer_science)" title="wikilink">profiling</a> tool for the development/component unit test environment</li>
<li>Specify an automated unit (component) performance test tool for the development/component unit test environment; this is used when no GUI yet exists to drive the components under development</li>
<li>Specify an automated tool for driving server-side unit (components) for the development/component unit test environment</li>
<li>Specify an automated multi-user capable script-driven end-to-end tool for the development/component unit test environment; this is used to execute screen-driven use cases</li>
<li>Identify a database test data load tool for the development/component unit test environment; this is required to ensure that the database optimizer chooses correct execution paths and to enable reinitializing and reloading the database as needed</li>
<li>Deploy the performance tools for the development team</li>
<li>Presentations and training must be given to development team members on the selected tools</li>
</ul>

<p>A member of the performance engineering practice and the development technical team leads should work together to identify performance-oriented best practices for the development team. Ideally the development organization should already have a body of best practices, but often these do not include or emphasize those best practices that impact system performance.</p>

<p>The concept of application instrumentation should be introduced here with the participation of the IT Monitoring organization. Several vendor monitoring systems have performance capabilities, these normally operate at the operating system, network, and server levels; e.g. CPU utilization, memory utilization, disk I/O, and for J2EE servers the JVM performance including garbage collection.</p>

<p>But this type of monitoring does not permit the tracking of use case level performance. To reach this level of monitoring capability may require that the application itself be instrumented. Alternatively, a monitoring toolset that works at the switch level may be used. (Examples might be <a class="uri" href="TeaLeaf" title="wikilink">TeaLeaf</a>'s Cx technology, <a href="Quest_Software" title="wikilink">Quest Software</a>'s Foglight, <a class="uri" href="Hewlett-Packard" title="wikilink">Hewlett-Packard</a>'s RUM, <a class="uri" href="NetQoS" title="wikilink">NetQoS</a>'s SuperAgent, or <a class="uri" href="Compuware" title="wikilink">Compuware</a>'s agentless ClientVantage.) The monitoring group should have specified the requirements in a previous phase, and should work with the development team to ensure that use case level monitoring is built in.</p>

<p>The group responsible for infrastructural <a href="performance_tuning" title="wikilink">performance tuning</a> should have an established "base model" checklist to tune the operating systems, network, servers (application, web, database, load balancer, etc.), and any message queueing software. Then as the performance test team starts to gather data, they should commence tuning the environment more specifically for the system to be deployed. This requires the active support of subject matter experts, for example, database tuning normally requires a DBA who has special skills in that area.</p>

<p>The performance test team normally does not execute performance tests in the development environment, but rather in a specialized pre-deployment environment that is configured to be as close as possible to the planned production environment. This team will execute <a href="performance_testing" title="wikilink">performance testing</a> against <a href="test_case" title="wikilink">test cases</a>, validating that the critical use cases conform to the specified non-functional requirements. The team will execute <a href="load_testing" title="wikilink">load testing</a> against a normally expected (median) load as well as a peak load. They will often run <a href="stress_test" title="wikilink">stress tests</a> that will identify the system bottlenecks. The data gathered, and the analyses, will be fed back to the group that does performance tuning. Where necessary, the system will be tuned to bring nonconforming tests into conformance with the non-functional requirements.</p>

<p>If performance engineering has been properly applied at each iteration and phase of the project to this point, hopefully this will be sufficient to enable the system to receive performance certification. However, if for some reason (perhaps proper performance engineering working practices were not applied) there are tests that cannot be tuned into compliance, then it will be necessary to return portions of the system to development for refactoring. In some cases the problem can be resolved with additional hardware, but adding more hardware leads quickly to diminishing returns.</p>

<p>For example: suppose we can improve 70% of a module by parallelizing it, and run on 4 CPUs instead of 1 CPU. If α is the fraction of a calculation that is sequential, and (1-α) is the fraction that can be parallelized, then the maximum speedup that can be achieved by using P processors is given according to <a href="Amdahl's_Law" title="wikilink">Amdahl's Law</a>

<math display="block" id="Performance_engineering:0">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mrow>
    <mi>α</mi>
    <mo>+</mo>
    <mfrac>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>α</mi>
     </mrow>
     <mi>P</mi>
    </mfrac>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <plus></plus>
     <ci>α</ci>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>α</ci>
      </apply>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{\alpha+\frac{1-\alpha}{P}}
  </annotation>
 </semantics>
</math>

</p>

<p>In this example we would get: 1/(.3+(1-.3)/4)=2.105. So for quadrupling the processing power we only doubled the performance (from 1 to 2.105). And we are now well on the way to diminishing returns. If we go on to double the computing power again from 4 to 8 processors we get 1/(.3+(1-.3)/8)=2.581. So now by doubling the processing power again we only got a performance improvement of about one fifth (from 2.105 to 2.581).</p>
<h3 id="transition">Transition</h3>

<p>During this final phase the system is deployed to the production environment. A number of preparatory steps are required. These include:</p>
<ul>
<li>Configuring the operating systems, network, servers (application, web, database, load balancer, etc.), and any message queueing software according to the base checklists and the optimizations identified in the performance test environment</li>
<li>Ensuring all performance monitoring software is deployed and configured</li>
<li>Running Statistics on the database after the production data load is completed</li>
</ul>

<p>Once the new system is deployed, ongoing operations pick up performance activities, including:</p>
<ul>
<li>Validating that weekly and monthly performance reports indicate that critical use cases perform within the specified non functional requirement criteria</li>
<li>Where use cases are falling outside of NFR criteria, submit defects</li>
<li>Identify projected trends from monthly and quarterly reports, and on a quarterly basis, execute <a href="capacity_planning" title="wikilink">capacity planning</a> management activities</li>
</ul>
<h2 id="service-management">Service management</h2>

<p>In the operational domain (post production deployment) performance engineering focuses primarily within three areas: <a href="ITIL#Service_level_management" title="wikilink">service level management</a>, <a href="ITIL#Capacity_management" title="wikilink">capacity management</a>, and <a href="ITIL#Problem_management" title="wikilink">problem management</a>.</p>
<h3 id="service-level-management">Service level management</h3>

<p>In the service level management area, performance engineering is concerned with <a href="service_level_agreement" title="wikilink">service level agreements</a> and the associated systems monitoring that serves to validate service level compliance, detect problems, and identify trends. For example, when real user monitoring is deployed it is possible to ensure that user transactions are being executed in conformance with specified non-functional requirements. Transaction response time is logged in a database such that queries and reports can be run against the data. This permits trend analysis that can be useful for capacity management. When user transactions fall out of band, the events should generate alerts so that attention may be applied to the situation.</p>
<h3 id="capacity-management">Capacity management</h3>

<p>For capacity management, performance engineering focuses on ensuring that the systems will remain within performance compliance. This means executing <a href="trend_analysis" title="wikilink">trend analysis</a> on historical monitoring generated data, such that the future time of non compliance is predictable. For example, if a system is showing a trend of slowing transaction processing (which might be due to growing data set sizes, or increasing numbers of concurrent users, or other factors) then at some point the system will no longer meet the criteria specified within the service level agreements. Capacity management is charged with ensuring that additional capacity is added in advance of that point (additional CPUs, more memory, new database indexing, et cetera) so that the trend lines are reset and the system will remain within the specified performance range.</p>
<h3 id="problem-management">Problem management</h3>

<p>Within the problem management domain, the performance engineering practices are focused on resolving the root cause of performance related problems. These typically involve system tuning, changing operating system or device parameters, or even refactoring the application software to resolve poor performance due to poor design or bad coding practices.</p>
<h2 id="monitoring">Monitoring</h2>

<p>To ensure that there is proper feedback validating that the system meets the NFR specified performance metrics, any major system needs a monitoring subsystem. The planning, design, installation, configuration, and control of the monitoring subsystem is specified by an appropriately defined Monitoring Process. The benefits are as follows:</p>
<ol>
<li>It is possible to establish service level agreements at the use case level.</li>
<li>It is possible to turn on and turn off monitoring at periodic points or to support problem resolution.</li>
<li>It enables the generation of regular reports.</li>
<li>It enables the ability to track trends over time – such as the impact of increasing user loads and growing data sets on use case level performance.</li>
</ol>

<p>The trend analysis component of this cannot be undervalued. This functionality, properly implemented, will enable predicting when a given application undergoing gradually increasing user loads and growing data sets will exceed the specified non functional performance requirements for a given use case. This permits proper management budgeting, acquisition of, and deployment of the required resources to keep the system running within the parameters of the non functional performance requirements.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="http://www.diplom.de/MA-Thesis__Master-17047/Integration_of_Performance_Management_into_the_Application_Lifecycle.html">Integration of Performance Management in Information Technology Infrastructure Library</a> (ITIL)</li>
<li><a href="Java_performance" title="wikilink">Java performance</a></li>
<li><a href="Non-functional_requirements" title="wikilink">Non-functional requirements</a></li>
<li><a href="Performance_testing" title="wikilink">Performance testing</a></li>
<li><a href="Performance_tuning" title="wikilink">Performance tuning</a></li>
<li><a class="uri" href="Scalability" title="wikilink">Scalability</a></li>
<li><a href="Software_engineering" title="wikilink">Software engineering</a></li>
<li><a href="Software_performance_testing" title="wikilink">Software performance testing</a></li>
<li><a href="Software_quality" title="wikilink">Software quality</a></li>
<li><a href="Software_testing" title="wikilink">Software testing</a></li>
<li><a href="Systems_engineering" title="wikilink">Systems engineering</a></li>
<li><a href="Use_cases" title="wikilink">Use cases</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li><a href="http://www1.practicalperformanceanalyst.com">Practical Performance Analyst - Performance Engineering Community &amp; Body Of Knowledge</a></li>
<li><a href="http://www.mindtree.com/downloads/MindTree%20-%20Performance%20Engineering%20Flyer.pdf">Performance Engineering Methodology</a></li>
<li><a href="http://www-128.ibm.com/developerworks/rational/library/4215.html">A Performance Engineering Strategy</a></li>
<li><a href="http://test.cmg.org/conference/cmg2004/awards/4083.pdf">A Performance Process Maturity Model</a></li>
<li><a href="http://www.amazon.com/Every-Computer-Performance-Book-Computers/dp/1482657759/">The Every Computer Performance Book</a></li>
<li><a href="http://webdiis.unizar.es/CRPetri/papers/jcampos/03_MC_SERP.pdf">Exploring UML for Performance Engineering</a></li>
<li><a href="http://fortuitous.com/docs/primers/PE_Model_Intro.pdf">Introduction to Modeling Based Performance Engineering</a></li>
<li><a href="http://www.ins.com/assets/A6BE9064-50DC-4E00-9B52-BA265DA722D6.pdf">Leveraging ITIL to Improve Application Performance</a></li>
<li><a href="http://channel9.msdn.com/wiki/default.aspx/PerformanceWiki.PerformanceEngineering">Patterns &amp; Practices Performance Engineering</a></li>
<li><a href="http://www.perfeng.com/papers/pdcp.pdf">Performance and Scalability of Distributed Software Architectures</a></li>
<li><a href="http://www.perfeng.com/papers/bestprac.pdf">Performance Engineering Best Practices (High Level)</a></li>
<li>[<a class="uri" href="http://delivery.acm.org/10.1145/340000/336553/p189-pooley.pdf?key1=336553&amp;key2">http://delivery.acm.org/10.1145/340000/336553/p189-pooley.pdf?key1=336553&amp;key2;</a>;=4989881611&amp;coll;=GUIDE&amp;dl;=GUIDE,ACM&amp;CFID;=11111111&amp;CFTOKEN;=2222222 Software Engineering and Performance: A Road-map] $</li>
<li><a href="http://fortuitous.com/docs/whitepapers/Performance_Cost.pdf">The Vicious Cycle of Computer Systems Performance and IT Operational Costs</a></li>
<li><a href="http://blogs.technet.com/winserverperformance/">Microsoft Windows Server Performance Team</a></li>
<li><a href="http://www.cmg.org/measureit/issues/mit23/m_23_2.html">Gathering Performance Requirements</a></li>
<li><a href="http://sergeibaranov.sys-con.com/node/46513">Performance Testing Web Services: Strategies and Best Practices</a></li>
<li><a href="http://www.cmg.org/measureit/issues/mit49/m_49_12.html">Performance Evaluation of an Air Traffic Control System using the Application Response Measurement (ARM) Standard</a></li>
</ul>

<p>"</p>

<p><a href="Category:Information_technology_management" title="wikilink">Category:Information technology management</a> <a href="Category:Performance_management" title="wikilink">Category:Performance management</a> <a href="Category:Software_optimization" title="wikilink">Category:Software optimization</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">"Banking Industry Lessons Learned in Outsourcing Testing Services," Gartner. August 2, 2012.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
