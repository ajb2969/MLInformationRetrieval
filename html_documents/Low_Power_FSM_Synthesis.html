<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1742">Low Power FSM Synthesis</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Low Power FSM Synthesis</h1>
<hr/>
<h2 id="introduction">Introduction</h2>

<p>Finite State Machines (FSMs) are widely used to implement control logic in various applications such as microprocessors, digital transmission, digital filters and digital signal processing. Even for designs containing a good number of datapath elements, the controller occupies a sizeable portion. As the devices are mostly portable and hand-held, reducing power dissipation has emerged as the primary concern of today’s VLSI designers. While the datapath elements can be shutdown when they are not being used, controllers are always active. As a result, the controller consumes a good amount of system power. Thus, power-efficient synthesis of FSM has come up as a very important problem domain, attracting lot of research. The synthesis method must be able to reduce both dynamic power and leakage power consumed by the circuit.</p>
<h2 id="fsm-synthesis">FSM Synthesis</h2>

<p>An FSM can be defined as a quintuplet that consists of a set of primary inputs, a set of primary outputs, a set of states, a next-state function and an output function. The next-state function maps the present-state and the primary inputs to a next-state; the output function maps the primary inputs and present-state onto the primary outputs. Any deterministic sequential function can be represented by the use of this model. FSM can be separated into two parts viz., combinational circuit and memory.</p>

<p>The optimal synthesis of finite-state machines is an important step in digital design. The three basic steps involved in the FSM synthesis are:</p>
<ol>
<li><strong>State Minimization</strong>:The number of states is reduced by recognizing the equivalent states that are present in the FSM and merging them. When state minimization is possible, it is deemed that the resulting FSM will be easier to build</li>
<li><strong>State Encoding</strong>: The complexity of the combinational logic depends on the assignment of codes to each of the states in the FSM. This is also referred to as <strong>state assignment</strong>. A good state assignment reduces the cost of implementation significantly. There are many encoding techniques such as Gray coding, Binary coding, One-Hot coding, etc.</li>
<li><strong>Determination of Boolean functions for next-state and output functions</strong>: The Boolean equations can be obtained by a two-level structure or random-logic by an interconnection of logic primitives. In either case, Boolean minimization, logical partitioning and decomposition are essential for an efficient realization</li>
</ol>
<h2 id="low-power-synthesis">Low Power Synthesis</h2>

<p>In CMOS circuits, power is dissipated in a gate when the gate output changes from 0 to 1 or from 1 to 0. Optimizing for low average power consumption in digital CMOS circuits is in most of the cases motivated by reducing the problems related to either heat generated by the integrated circuit (IC) or by limited power supply resources, as in portable battery-operated equipment.</p>

<p>The most common approach for low power FSM synthesis to divide the FSM into two or more sub-FSMs in which at any given instant only one of these is active. The power minimization problem can be considered at various levels viz., algorithmic, architectural, logic and circuit levels. The dynamic power consumed in synchronous CMOS circuits is given by:</p>

<p><code>                                 </code>

<math display="inline" id="Low_Power_FSM_Synthesis:0">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>V</mi>
     <mrow>
      <mi>D</mi>
      <mi>D</mi>
     </mrow>
     <mn>2</mn>
    </msubsup>
    <mi>f</mi>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>i</mi>
     </msub>
     <mrow>
      <msub>
       <mi>α</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>C</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <apply>
        <times></times>
        <ci>D</ci>
        <ci>D</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <ci>f</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=V_{DD}^{2}f\sum_{i}{\alpha_{i}}{C_{i}}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Low_Power_FSM_Synthesis:1">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i}
  </annotation>
 </semantics>
</math>

 is the probability of a signal transmission within a clock period at node 

<math display="inline" id="Low_Power_FSM_Synthesis:2">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Low_Power_FSM_Synthesis:3">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}
  </annotation>
 </semantics>
</math>

 is the switched capacitance, 

<math display="inline" id="Low_Power_FSM_Synthesis:4">
 <semantics>
  <msub>
   <mi>V</mi>
   <mrow>
    <mi>D</mi>
    <mi>D</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{DD}
  </annotation>
 </semantics>
</math>

 is the supply voltage and 

<math display="inline" id="Low_Power_FSM_Synthesis:5">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is the clock frequency.</p>
<h2 id="synthesis-methods">Synthesis Methods</h2>
<ol>
<li>Partitioning of the FSM physically increases the area of the circuit but reduces the dynamic power consumed.</li>
<li>In the synthesis, state encoding plays an important role for efficient realization. The Boolean distance between the codes is minimized with a high transition probability, using a probability descriptor of the FSM.</li>
<li>In <strong>input disabling precomputational based</strong> approach, datapath units which are combinational logic are turned off to disable the values to the input signals. This reduces the dynamic power</li>
<li>In sequential circuits, gate-clock techniques such as <strong>Power gating</strong> are used to disable the clock signal to the parts of the system that are idle</li>
<li>For complex microprocessors, floating point units and cache memory blocks are turned off when idle. This method is called <strong>dynamic power management</strong></li>
</ol>
<h2 id="limitations">Limitations</h2>

<p><code>   The amount of power that is saved by partitioning the FSM is mainly determined by how good the partitioning algorithm can cluster strongly connected states together in sub-FSMs and by how large the cost is, in terms of power, to make a state transition from one sub-FSM to another.</code></p>
<h2 id="references">References</h2>
<ol>
<li><a class="uri" href="http://www.nptel.ac.in/courses/106103016/9">http://www.nptel.ac.in/courses/106103016/9</a></li>
<li>L. Benini, G. De Micheli, State assignment for low power dissipation, IEEE Journal on Solid State Circuits (1994) 32–40</li>
<li>W. Noeth, R. Kolla., Spanning tree-based state encoding for low power dissipation, Design Automation and Test in Europe (1999)</li>
<li>Sambhu Nath Pradhan, M. Tilak Kumar, and Santanu Chattopadhyay. 2011. Low power finite state machine synthesis using power-gating. Integr. VLSI J. 44, 3 (June 2011), 175-184</li>
<li>Sue-Hong Chow, Yi-Cheng Ho, TingTing Hwang, and C. L. Liu. 1996. Low power realization of finite state machines—a decomposition approach. ACM Trans. Des. Autom. Electron. Syst. 1, 3 (July 1996)</li>
</ol>

<p>"</p>

<p><a href="Category:Computer_science" title="wikilink">Category:Computer science</a></p>
</body>
</html>
