<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="619">Rounding</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Rounding</h1>
<hr/>

<p><strong>Rounding</strong> a <a href="numerical_value" title="wikilink">numerical value</a> means replacing it by another value that is approximately equal but has a shorter, simpler, or more explicit representation; for example, replacing £23.4476 with £23.45, or the fraction 312/937 with 1/3, or the expression √2 with 1.414.</p>

<p>Rounding is often done to obtain a value that is easier to <a class="uri" href="report" title="wikilink">report</a> and <a class="uri" href="communicate" title="wikilink">communicate</a> than the original. Rounding can also be important to avoid <a href="overprecision" title="wikilink">misleadingly precise</a> reporting of a computed number, <a class="uri" href="measurement" title="wikilink">measurement</a> or <a class="uri" href="estimate" title="wikilink">estimate</a>; for example, a quantity that was computed as 123,456 but is known to be <a href="Accuracy_and_precision" title="wikilink">accurate</a> only to within a few hundred units is better stated as "about 123,500."</p>

<p>On the other hand, rounding of exact numbers will introduce some <a href="round-off_error" title="wikilink">round-off error</a> in the reported result. Rounding is almost unavoidable when reporting many computations — especially when dividing two numbers in <a class="uri" href="integer" title="wikilink">integer</a> or <a href="fixed-point_arithmetic" title="wikilink">fixed-point arithmetic</a>; when computing mathematical functions such as <a href="square_root" title="wikilink">square roots</a>, <a href="logarithm" title="wikilink">logarithms</a>, and <a href="sine" title="wikilink">sines</a>; or when using a <a href="floating_point" title="wikilink">floating point</a> representation with a fixed number of <a href="significant_digit" title="wikilink">significant digits</a>. In a sequence of calculations, these rounding errors generally accumulate, and in certain <a class="uri" href="ill-conditioned" title="wikilink">ill-conditioned</a> cases they may make the result meaningless.</p>

<p>Accurate rounding of <a href="transcendental_function" title="wikilink">transcendental mathematical functions</a> is difficult because the number of extra digits that need to be calculated to resolve whether to round up or down cannot be known in advance. This problem is known as "the table-maker's dilemma".</p>

<p>Rounding has many similarities to the <a href="quantization_(signal_processing)" title="wikilink">quantization</a> that occurs when <a href="physical_quantity" title="wikilink">physical quantities</a> must be encoded by numbers or <a href="digital_signal" title="wikilink">digital signals</a>.</p>

<p>A wavy <a href="equals_sign" title="wikilink">equals sign</a> (<big><strong><a class="uri" href="≈" title="wikilink">≈</a></strong></big>) is sometimes used to indicate rounding of exact numbers. For example: 9.98 ≈ 10.</p>
<h2 id="types-of-rounding">Types of rounding</h2>

<p>Typical rounding problems are:</p>
<ul>
<li>approximating an irrational number by a fraction, e.g., <a href="pi" title="wikilink">π</a> by 22/7;</li>
<li>approximating a fraction with periodic decimal expansion by a finite decimal fraction, e.g., 5/3 by 1.6667;</li>
<li>replacing a <a href="rational_number" title="wikilink">rational number</a> by a fraction with smaller numerator and denominator, e.g., 3122/9417 by 1/3;</li>
<li>replacing a fractional <a href="decimal_number" title="wikilink">decimal number</a> by one with fewer digits, e.g., 2.1784 dollars by 2.18 dollars;</li>
<li>replacing a decimal <a class="uri" href="integer" title="wikilink">integer</a> by an integer with more trailing zeros, e.g., 23,217 people by 23,200 people; or, in general,</li>
<li>replacing a value by a multiple of a specified amount, e.g., 48.2 seconds by 45 seconds (a multiple of 15 s).</li>
</ul>
<h2 id="rounding-to-a-specified-increment">Rounding to a specified increment</h2>

<p>The most common type of rounding is to round to an integer; or, more generally, to an integer multiple of some increment — such as rounding to whole tenths of seconds, hundredths of a dollar, to whole multiples of 1/2 or 1/8 inch, to whole dozens or thousands, etc.</p>

<p>In general, rounding a number <em>x</em> to a multiple of some specified increment <em>m</em> entails the following steps:</p>
<ol>
<li>Divide <em>x</em> by <em>m</em>, let the result be <em>y</em>;</li>
<li>Round <em>y</em> to an integer value, call it <em>q</em>;</li>
<li>Multiply <em>q</em> by <em>m</em> to obtain the rounded value <em>z</em>.</li>
</ol>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Rounding:0">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mrow>
    <mi>round</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>round</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>/</mo>
       <mi>m</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⋅</mo>
    <mpadded width="+1.7pt">
     <mi>m</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>z</ci>
     <apply>
      <times></times>
      <ci>round</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>m</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <ci>round</ci>
       <apply>
        <divide></divide>
        <ci>x</ci>
        <ci>m</ci>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=\mathrm{round}(x,m)=\mathrm{round}(x/m)\cdot m\,
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>For example, rounding <em>x</em> = 2.1784 dollars to whole cents (i.e., to a multiple of 0.01) entails computing <em>y</em> = <em>x</em>/<em>m</em> = 2.1784/0.01 = 217.84, then rounding <em>y</em> to the integer <em>q</em> = 218, and finally computing <em>z</em> = <em>q</em>×<em>m</em> = 218×0.01 = 2.18.</p>

<p>When rounding to a predetermined number of <a href="significant_figure" title="wikilink">significant digits</a>, the increment <em>m</em> depends on the magnitude of the number to be rounded (or of the rounded result).</p>

<p>The increment <em>m</em> is normally a finite fraction in whatever <a href="number_system" title="wikilink">number system</a> is used to represent the numbers. For display to humans, that usually means the <a href="decimal_number" title="wikilink">decimal number system</a> (that is, <em>m</em> is an integer times a <a href="power_(mathematics)" title="wikilink">power</a> of 10, like 1/1000 or 25/100). For intermediate values stored in digital computers, it often means the <a href="binary_number" title="wikilink">binary number system</a> (<em>m</em> is an integer times a power of 2).</p>

<p>The abstract single-argument "round()" function that returns an integer from an arbitrary real value has at least a dozen distinct concrete definitions presented in the <a href="#Rounding_to_integer" title="wikilink">rounding to integer</a> section. The abstract two-argument "round()" function is formally defined here, but in many cases it is used with the implicit value <em>m</em> = 1 for the increment and then reduces to the equivalent abstract single-argument function, with also the same dozen distinct concrete definitions.</p>
<h2 id="rounding-to-integer">Rounding to integer</h2>

<p>The most basic form of rounding is to replace an arbitrary number by an integer. All the following rounding modes are concrete implementations of the abstract single-argument "round()" function presented and used in the previous sections.</p>

<p>There are many ways of rounding a number <em>y</em> to an integer <em>q</em>. The most common ones are</p>
<ul>
<li><strong>round down</strong> (or take the <strong><a href="floor_and_ceiling_functions" title="wikilink">floor</a></strong>, or <strong>round towards minus infinity</strong>): <em>q</em> is the largest integer that does not exceed <em>y</em>.

<p>

<math display="block" id="Rounding:1">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>=</mo>
   <mrow>
    <mi>floor</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>⌊</mo>
    <mi>y</mi>
    <mo>⌋</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mo>⌈</mo>
     <mrow>
      <mo>-</mo>
      <mi>y</mi>
     </mrow>
     <mo rspace="4.2pt">⌉</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>q</ci>
     <apply>
      <times></times>
      <ci>floor</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <floor></floor>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <ceiling></ceiling>
       <apply>
        <minus></minus>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q=\mathrm{floor}(y)=\left\lfloor y\right\rfloor=-\left\lceil-y\right\rceil\,
  </annotation>
 </semantics>
</math>

</p></li>
<li><strong>round up</strong> (or take the <strong><a href="floor_and_ceiling_functions" title="wikilink">ceiling</a></strong>, or <strong>round towards plus infinity</strong>): <em>q</em> is the smallest integer that is not less than <em>y</em>.

<p>

<math display="block" id="Rounding:2">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>=</mo>
   <mrow>
    <mi>ceil</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>⌈</mo>
    <mi>y</mi>
    <mo>⌉</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mo>⌊</mo>
     <mrow>
      <mo>-</mo>
      <mi>y</mi>
     </mrow>
     <mo rspace="4.2pt">⌋</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>q</ci>
     <apply>
      <times></times>
      <ci>ceil</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ceiling></ceiling>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <floor></floor>
       <apply>
        <minus></minus>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q=\mathrm{ceil}(y)=\left\lceil y\right\rceil=-\left\lfloor-y\right\rfloor\,
  </annotation>
 </semantics>
</math>

</p></li>
<li><strong>round towards zero</strong> (or <strong><a href="truncation" title="wikilink">truncate</a></strong>, or <strong>round away from infinity</strong>): <em>q</em> is the integer part of <em>y</em>, without its fraction digits.

<p>

<math display="block" id="Rounding:3">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>=</mo>
   <mrow>
    <mi>truncate</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>sgn</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo>⌊</mo>
     <mrow>
      <mo>|</mo>
      <mi>y</mi>
      <mo>|</mo>
     </mrow>
     <mo>⌋</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mo>sgn</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mo>⌈</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mo>|</mo>
        <mi>y</mi>
        <mo>|</mo>
       </mrow>
      </mrow>
      <mo rspace="4.2pt">⌉</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>q</ci>
     <apply>
      <times></times>
      <ci>truncate</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <ci>sgn</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <floor></floor>
       <apply>
        <abs></abs>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <ci>sgn</ci>
        <ci>y</ci>
       </apply>
       <apply>
        <ceiling></ceiling>
        <apply>
         <minus></minus>
         <apply>
          <abs></abs>
          <ci>y</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q=\mathrm{truncate}(y)=\operatorname{sgn}(y)\left\lfloor\left|y\right|\right%
\rfloor=-\operatorname{sgn}(y)\left\lceil-\left|y\right|\right\rceil\,
  </annotation>
 </semantics>
</math>

</p></li>
<li><strong>round away from zero</strong> (or <strong>round towards infinity</strong>): if <em>y</em> is an integer, <em>q</em> is <em>y</em>; else <em>q</em> is the integer that is closest to 0 and is such that <em>y</em> is between 0 and <em>q</em>.

<p>

<math display="block" id="Rounding:4">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>sgn</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo>⌈</mo>
     <mrow>
      <mo>|</mo>
      <mi>y</mi>
      <mo>|</mo>
     </mrow>
     <mo>⌉</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mo>sgn</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mo>⌊</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mo>|</mo>
        <mi>y</mi>
        <mo>|</mo>
       </mrow>
      </mrow>
      <mo rspace="4.2pt">⌋</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>q</ci>
     <apply>
      <times></times>
      <apply>
       <ci>sgn</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <ceiling></ceiling>
       <apply>
        <abs></abs>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <ci>sgn</ci>
        <ci>y</ci>
       </apply>
       <apply>
        <floor></floor>
        <apply>
         <minus></minus>
         <apply>
          <abs></abs>
          <ci>y</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q=\operatorname{sgn}(y)\left\lceil\left|y\right|\right\rceil=-\operatorname{%
sgn}(y)\left\lfloor-\left|y\right|\right\rfloor\,
  </annotation>
 </semantics>
</math>

</p></li>
<li><strong>round to nearest</strong>: <em>q</em> is the integer that is closest to <em>y</em> (see below for tie-breaking rules).</li>
</ul>

<p>The first four methods are called <strong>directed rounding</strong>, as the displacements from the original number <em>y</em> to the rounded value <em>q</em> are all directed towards or away from the same limiting value (0, <a href="Extended_real_number_line" title="wikilink">+∞</a>, or −∞).</p>

<p>If <em>y</em> is positive, round-down is the same as round-towards-zero, and round-up is the same as round-away-from-zero. If <em>y</em> is negative, round-down is the same as round-away-from-zero, and round-up is the same as round-towards-zero. In any case, if <em>y</em> is integer, <em>q</em> is just <em>y</em>.</p>

<p>Where many calculations are done in sequence, the choice of rounding method can have a very significant effect on the result. A famous instance involved a new <a href="stock_index" title="wikilink">index</a> set up by the <a href="Vancouver_Stock_Exchange" title="wikilink">Vancouver Stock Exchange</a> in 1982. It was initially set at 1000.000 (three decimal places of accuracy), and after 22 months had fallen to about 520 — whereas <a href="stock_price" title="wikilink">stock prices</a> had generally increased in the period. The problem was caused by the index being recalculated thousands of times daily, and always being rounded down to 3 decimal places, in such a way that the rounding errors accumulated. Recalculating with better rounding gave an index value of 1098.892 at the end of the same period.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h3 id="tie-breaking">Tie-breaking</h3>

<p>Rounding a number <em>y</em> to the nearest integer requires some tie-breaking rule for those cases when <em>y</em> is exactly half-way between two integers — that is, when the fraction part of <em>y</em> is exactly 0.5.</p>
<h4 id="round-half-up">Round half up</h4>

<p>The following tie-breaking rule, called <strong>round half up</strong> (or <strong>round half towards positive infinity</strong>), is widely used in many disciplines. That is, half-way values <em>y</em> are always rounded up.</p>
<ul>
<li>If the fraction of <em>y</em> is exactly 0.5, then <em>q</em> = <em>y</em> + 0.5.

<p>

<math display="block" id="Rounding:5">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>=</mo>
   <mrow>
    <mo>⌊</mo>
    <mrow>
     <mi>y</mi>
     <mo>+</mo>
     <mn>0.5</mn>
    </mrow>
    <mo>⌋</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mo>⌈</mo>
     <mrow>
      <mrow>
       <mo>-</mo>
       <mi>y</mi>
      </mrow>
      <mo>-</mo>
      <mn>0.5</mn>
     </mrow>
     <mo>⌉</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>q</ci>
     <apply>
      <floor></floor>
      <apply>
       <plus></plus>
       <ci>y</ci>
       <cn type="float">0.5</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <ceiling></ceiling>
       <apply>
        <minus></minus>
        <apply>
         <minus></minus>
         <ci>y</ci>
        </apply>
        <cn type="float">0.5</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q=\left\lfloor y+0.5\right\rfloor=-\left\lceil-y-0.5\right\rceil
  </annotation>
 </semantics>
</math>

</p></li>
</ul>

<p>For example, by this rule the value 23.5 gets rounded to 24, but −23.5 gets rounded to −23.</p>

<p>However, some programming languages (such as Java) define <em>HALF_UP</em> as <em>round half away from zero</em>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>If it were not for the 0.5 fractions, the round-off errors introduced by the round to nearest method would be symmetric: for every fraction that gets rounded up (such as 0.268), there is a complementary fraction (namely, 0.732) that gets rounded down by the same amount. When rounding a large set of numbers with <a class="uri" href="random" title="wikilink">random</a> fractional parts, these rounding errors would statistically compensate each other, and the <a href="expectation_(mathematics)" title="wikilink">expected</a> (average) value of the rounded numbers would be equal to the expected value of the original numbers.</p>

<p>However, the <em>round half up</em> tie-breaking rule is not symmetric, as the fractions that are exactly 0.5 always get rounded up. This asymmetry introduces a positive bias in the round-off errors. For example, if the fraction of <em>y</em> consists of three random decimal digits, then the expected value of <em>q</em> will be 0.0005 higher than the expected value of <em>y</em>. For this reason, round-to-nearest with the <em>round half up</em> rule is also (ambiguously) known as <strong>asymmetric rounding</strong>.</p>

<p>One reason for rounding up at 0.5 is that for positive decimals, only the first figure after the decimal point needs be examined. For example, when looking at 17.5000…, the "5" alone determines that the number should be rounded up, to 18 in this case. This is not true for negative decimals, such as −17.5000…, where all the fractional figures of the value need to be examined to determine if it should round to −17, if it were −17.5000000, or to −18, if it were −17.5000001 or smaller.</p>
<h4 id="round-half-down">Round half down</h4>

<p>One may also use <strong>round half down</strong> (or <strong>round half towards negative infinity</strong>) as opposed to the more common <em>round half up</em>.</p>
<ul>
<li>If the fraction of <em>y</em> is exactly 0.5, then <em>q</em> = <em>y</em> − 0.5.

<p>

<math display="block" id="Rounding:6">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>=</mo>
   <mrow>
    <mo>⌈</mo>
    <mrow>
     <mi>y</mi>
     <mo>-</mo>
     <mn>0.5</mn>
    </mrow>
    <mo>⌉</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mo>⌊</mo>
     <mrow>
      <mrow>
       <mo>-</mo>
       <mi>y</mi>
      </mrow>
      <mo>+</mo>
      <mn>0.5</mn>
     </mrow>
     <mo rspace="4.2pt">⌋</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>q</ci>
     <apply>
      <ceiling></ceiling>
      <apply>
       <minus></minus>
       <ci>y</ci>
       <cn type="float">0.5</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <floor></floor>
       <apply>
        <plus></plus>
        <apply>
         <minus></minus>
         <ci>y</ci>
        </apply>
        <cn type="float">0.5</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q=\left\lceil y-0.5\right\rceil=-\left\lfloor-y+0.5\right\rfloor\,
  </annotation>
 </semantics>
</math>

</p></li>
</ul>

<p>For example, 23.5 gets rounded to 23, and −23.5 gets rounded to −24.</p>

<p>The <em>round half down</em> tie-breaking rule is not symmetric, as the fractions that are exactly 0.5 always get rounded down. This asymmetry introduces a negative bias in the roundoff errors. For example, if the fraction of <em>y</em> consists of three random decimal digits, then the expected value of <em>q</em> will be 0.0005 lower than the expected value of <em>y</em>. For this reason, round-to-nearest with the <em>round half down</em> rule is also (ambiguously) known as <strong>asymmetric rounding</strong>.</p>
<h4 id="round-half-towards-zero">Round half towards zero</h4>

<p>One may also <strong>round half towards zero</strong> (or <strong>round half away from infinity</strong>) as opposed to the conventional <em>round half away from zero</em>.</p>
<ul>
<li>If the fraction of <em>y</em> is exactly 0.5, then <em>q</em> = <em>y</em> − 0.5 if <em>y</em> is positive, and <em>q</em> = <em>y</em> + 0.5 if <em>y</em> is negative.

<p>

<math display="block" id="Rounding:7">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>sgn</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo>⌈</mo>
     <mrow>
      <mrow>
       <mo>|</mo>
       <mi>y</mi>
       <mo>|</mo>
      </mrow>
      <mo>-</mo>
      <mn>0.5</mn>
     </mrow>
     <mo>⌉</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mo>sgn</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mo>⌊</mo>
      <mrow>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mo>|</mo>
         <mi>y</mi>
         <mo>|</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mn>0.5</mn>
      </mrow>
      <mo rspace="4.2pt">⌋</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>q</ci>
     <apply>
      <times></times>
      <apply>
       <ci>sgn</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <ceiling></ceiling>
       <apply>
        <minus></minus>
        <apply>
         <abs></abs>
         <ci>y</ci>
        </apply>
        <cn type="float">0.5</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <ci>sgn</ci>
        <ci>y</ci>
       </apply>
       <apply>
        <floor></floor>
        <apply>
         <plus></plus>
         <apply>
          <minus></minus>
          <apply>
           <abs></abs>
           <ci>y</ci>
          </apply>
         </apply>
         <cn type="float">0.5</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q=\operatorname{sgn}(y)\left\lceil\left|y\right|-0.5\right\rceil=-%
\operatorname{sgn}(y)\left\lfloor-\left|y\right|+0.5\right\rfloor\,
  </annotation>
 </semantics>
</math>

</p></li>
</ul>

<p>For example, 23.5 gets rounded to 23, and −23.5 gets rounded to −23.</p>

<p>This method also treats positive and negative values symmetrically, and therefore is free of overall bias if the original numbers are positive or negative with equal probability.</p>
<h4 id="round-half-away-from-zero">Round half away from zero</h4>

<p>The other tie-breaking method commonly taught and used is the <strong>round half away from zero</strong> (or <strong>round half towards infinity</strong>), namely:</p>
<ul>
<li>If the fraction of <em>y</em> is exactly 0.5, then <em>q</em> = <em>y</em> + 0.5 if <em>y</em> is positive, and <em>q</em> = <em>y</em> − 0.5 if <em>y</em> is negative.

<p>

<math display="block" id="Rounding:8">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>sgn</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mo>⌊</mo>
     <mrow>
      <mrow>
       <mo>|</mo>
       <mi>y</mi>
       <mo>|</mo>
      </mrow>
      <mo>+</mo>
      <mn>0.5</mn>
     </mrow>
     <mo>⌋</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mo>sgn</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mo>⌈</mo>
      <mrow>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mo>|</mo>
         <mi>y</mi>
         <mo>|</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mn>0.5</mn>
      </mrow>
      <mo rspace="4.2pt">⌉</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>q</ci>
     <apply>
      <times></times>
      <apply>
       <ci>sgn</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <floor></floor>
       <apply>
        <plus></plus>
        <apply>
         <abs></abs>
         <ci>y</ci>
        </apply>
        <cn type="float">0.5</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <ci>sgn</ci>
        <ci>y</ci>
       </apply>
       <apply>
        <ceiling></ceiling>
        <apply>
         <minus></minus>
         <apply>
          <minus></minus>
          <apply>
           <abs></abs>
           <ci>y</ci>
          </apply>
         </apply>
         <cn type="float">0.5</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q=\operatorname{sgn}(y)\left\lfloor\left|y\right|+0.5\right\rfloor=-%
\operatorname{sgn}(y)\left\lceil-\left|y\right|-0.5\right\rceil\,
  </annotation>
 </semantics>
</math>

</p></li>
</ul>

<p>For example, 23.5 gets rounded to 24, and −23.5 gets rounded to −24.</p>

<p>This method treats positive and negative values symmetrically, and therefore is free of overall bias if the original numbers are positive or negative with equal probability.</p>

<p>It is often used for currency conversions and price roundings (when the amount is first converted into the smallest significant subdivision of the currency, such as cents of a euro) as it is easy to explain by just considering the first fractional digit, independently of supplementary precision digits or sign of the amount (for strict equivalence between the paying and recipient of the amount).</p>
<h4 id="round-half-to-even">Round half to even</h4>

<p>A tie-breaking rule that is less biased is <strong>round half to even</strong>, namely:</p>
<ul>
<li>If the fraction of <em>y</em> is 0.5, then <em>q</em> is the <em>even</em> integer nearest to <em>y</em>.</li>
</ul>

<p>Thus, for example, +23.5 becomes +24, as does +24.5; while −23.5 becomes −24, as does −24.5.</p>

<p>This method treats positive and negative values symmetrically, and is therefore free of sign bias. More importantly, for reasonable distributions of <em>y</em> values, the expected (average) value of the rounded numbers is the same as that of the original numbers. However, this rule will introduce a towards-zero bias when  is even, and a towards-infinity bias for when it is odd.</p>

<p>This variant of the round-to-nearest method is also called <strong>unbiased rounding</strong>, <strong>convergent rounding</strong>, <strong>statistician's rounding</strong>, <strong>Dutch rounding</strong>, <strong>Gaussian rounding</strong>, <strong>odd–even rounding</strong>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> or <strong>bankers' rounding</strong>.</p>

<p>This is the default rounding mode used in <a href="IEEE_floating_point" title="wikilink">IEEE 754</a> computing functions and operators.</p>
<h4 id="round-half-to-odd">Round half to odd</h4>

<p>A similar tie-breaking rule is <strong>round half to odd</strong>:</p>
<ul>
<li>If the fraction of <em>y</em> is 0.5, then <em>q</em> is the <em>odd</em> integer nearest to <em>y</em>.</li>
</ul>

<p>Thus, for example, +23.5 becomes +23, as does +22.5; while −23.5 becomes −23, as does −22.5.</p>

<p>This method also treats positive and negative values symmetrically, and is therefore free of sign bias. More importantly, for reasonable distributions of <em>y</em> values, the expected (average) value of the rounded numbers is the same as that of the original numbers. However, this rule will introduce a towards-zero bias when  is odd, and a towards-infinity bias for when it is even.</p>

<p>This variant is almost never used in computations, except in situations where one wants to avoid rounding 0.5 or −0.5 to zero; or to avoid increasing the scale of floating point numbers, which have a limited exponent range. With <em>round half to even</em>, a non <em>infinite</em> number would round to infinity, and a small <em>denormal</em> value would round to a normal non-zero value. Effectively, this mode prefers preserving the existing scale of tie numbers, avoiding out of range results when possible for even based number systems (such as binary and decimal).</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Value</p></th>
<th style="text-align: left;">
<p>Round<br/>
down<br/>
<small>(towards −∞)</small></p></th>
<th style="text-align: left;">
<p>Round<br/>
up<br/>
<small>(towards +∞)</small></p></th>
<th style="text-align: left;">
<p>Round<br/>
towards zero</p></th>
<th style="text-align: left;">
<p>Round<br/>
away from zero</p></th>
<th style="text-align: left;">
<p>Round<br/>
to nearest</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Round half<br/>
down<br/>
<small>(towards −∞)</small></p></td>
<td style="text-align: left;">
<p>Round half<br/>
up<br/>
<small>(towards +∞)</small></p></td>
<td style="text-align: left;">
<p>Round half<br/>
towards zero</p></td>
<td style="text-align: left;">
<p>Round half<br/>
away from zero</p></td>
<td style="text-align: left;">
<p>Round half<br/>
to even</p></td>
<td style="text-align: left;">
<p>Round half<br/>
to odd</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>+1.6</p></td>
<td style="text-align: left;">
<p>+1</p></td>
<td style="text-align: left;">
<p>+2</p></td>
<td style="text-align: left;">
<p>+1</p></td>
<td style="text-align: left;">
<p>+2</p></td>
<td style="text-align: left;">
<p>+2</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>+1.5</p></td>
<td style="text-align: left;">
<p>+1</p></td>
<td style="text-align: left;">
<p>+2</p></td>
<td style="text-align: left;">
<p>+1</p></td>
<td style="text-align: left;">
<p>+2</p></td>
<td style="text-align: left;">
<p>+2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>+1.4</p></td>
<td style="text-align: left;">
<p>rowspan="2" +1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>+0.6</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>+1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>+1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>+0.5</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>+1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>+1</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>+0.4</p></td>
<td style="text-align: left;">
<p>rowspan="2" 0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>−0.4</p></td>
<td style="text-align: left;">
<p>−1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>−1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>−0.5</p></td>
<td style="text-align: left;">
<p>−1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>−1</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>−0.6</p></td>
<td style="text-align: left;">
<p>rowspan="2" −1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>−1.4</p></td>
<td style="text-align: left;">
<p>−2</p></td>
<td style="text-align: left;">
<p>−1</p></td>
<td style="text-align: left;">
<p>−1</p></td>
<td style="text-align: left;">
<p>−2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>−1.5</p></td>
<td style="text-align: left;">
<p>−2</p></td>
<td style="text-align: left;">
<p>−1</p></td>
<td style="text-align: left;">
<p>−1</p></td>
<td style="text-align: left;">
<p>−2</p></td>
<td style="text-align: left;">
<p>−2</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>−1.6</p></td>
<td style="text-align: left;">
<p>−2</p></td>
</tr>
<tr class="even">
</tr>
</tbody>
</table>
<h3 id="stochastic-rounding">Stochastic rounding</h3>

<p>Another unbiased tie-breaking method is <strong>stochastic rounding</strong>:</p>
<ul>
<li>If the fractional part of <em>y</em> is 0.5, choose <em>q</em> randomly among  and , with equal probability.</li>
</ul>

<p>Like round-half-to-even, this rule is essentially free of overall bias; but it is also fair among even and odd <em>q</em> values. On the other hand, it introduces a random component into the result; performing the same computation twice on the same data may yield two different results. Also, it is open to nonconscious bias if humans (rather than computers or devices of chance) are "randomly" deciding in which direction to round.</p>
<h3 id="alternating-tie-breaking">Alternating tie-breaking</h3>

<p>One method, more obscure than most, is <strong>round half alternatingly</strong>.</p>
<ul>
<li>If the fractional part is 0.5, alternate round up and round down: for the first occurrence of a 0.5 fractional part, round up; for the second occurrence, round down; so on so forth.</li>
</ul>

<p>This suppresses the random component of the result, if occurrences of 0.5 fractional parts can be effectively numbered. But it can still introduce a positive or negative bias according to the direction of rounding assigned to the first occurrence, if the total number of occurrences is odd.</p>
<h2 id="dithering-and-error-diffusion">Dithering and error diffusion</h2>

<p>When digitising continuous signals, for example images or sound, the overall effect of a number of measurements is more important than the accuracy of each individual measurement. In these circumstances <a class="uri" href="dithering" title="wikilink">dithering</a>, and a related technique, <a href="error_diffusion" title="wikilink">error diffusion</a>, are normally used. A related technique called <a href="pulse-width_modulation" title="wikilink">pulse-width modulation</a> is used to achieve analogue type output from an inertial device by rapidly pulsing the power with a variable duty cycle.</p>

<p>Error diffusion tries to ensure the error on average is minimized. When dealing with a gentle slope from one to zero the output would be zero for the first few terms until the sum of the error and the current value becomes greater than 0.5, in which case a 1 is output and the difference subtracted from the error so far. <a href="Floyd–Steinberg_dithering" title="wikilink">Floyd–Steinberg dithering</a> is a popular error diffusion procedure when digitising images.</p>
<h2 id="rounding-to-simple-fractions">Rounding to simple fractions</h2>

<p>In some contexts it is desirable to round a given number <em>x</em> to a "neat" fraction — that is, the nearest fraction <em>z</em> = <em>m</em>/<em>n</em> whose numerator <em>m</em> and denominator <em>n</em> do not exceed a given maximum. This problem is fairly distinct from that of rounding a value to a fixed number of decimal or binary digits, or to a multiple of a given unit <em>m</em>. This problem is related to <a href="Farey_sequence" title="wikilink">Farey sequences</a>, the <a href="Stern–Brocot_tree" title="wikilink">Stern–Brocot tree</a>, and <a href="continued_fraction" title="wikilink">continued fractions</a>.</p>
<h2 id="scaled-rounding">Scaled rounding</h2>

<p>This type of rounding, which is also named <strong>rounding to a logarithmic scale</strong>, is a variant of <a href="#Rounding_to_a_specified_increment" title="wikilink">Rounding to a specified increment</a>. Rounding on a logarithmic scale is accomplished by taking the log of the amount and doing normal rounding to the nearest value on the log scale.</p>

<p>For example resistors are supplied with <a href="preferred_number" title="wikilink">preferred numbers</a> on a logarithmic scale. For example for resistors with 10% accuracy they are supplied with nominal values 100, 121, 147, 178, 215 etc. If a calculation indicates a resistor of 165 ohms is required then log(147)=2.167, log(165)=2.217 and log(178)=2.250. The logarithm of 165 is closer to the logarithm of 178 therefore a 178 ohm resistor would be the first choice if there are no other considerations.</p>
<h2 id="round-to-available-value">Round to available value</h2>

<p>Finished <a class="uri" href="lumber" title="wikilink">lumber</a>, writing paper, capacitors, and many other products are usually sold in only a few standard sizes.</p>

<p>Many design procedures describe how to calculate an approximate value, and then "round" to some standard size using phrases such as "round down to nearest standard value", "round up to nearest standard value", or "round to nearest standard value".<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>When a set of <a href="preferred_value" title="wikilink">preferred values</a> is equally spaced on a logarithmic scale, choosing the closest <a href="preferred_value" title="wikilink">preferred value</a> to any given value can be seen as a kind of scaled rounding. Such "rounded" values can be directly calculated.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="floating-point-rounding">Floating-point rounding</h2>

<p>In floating-point arithmetic, rounding aims to turn a given value <em>x</em> into a value <em>z</em> with a specified number of <em>significant</em> digits. In other words, <em>z</em> should be a multiple of a number <em>m</em> that depends on the magnitude of <em>x</em>. The number <em>m</em> is a power of the base (usually 2 or 10) of the floating-point representation.</p>

<p>Apart from this detail, all the variants of rounding discussed above apply to the rounding of floating-point numbers as well. The algorithm for such rounding is presented in the <a href="#Scaled_rounding" title="wikilink">Scaled rounding</a> section above, but with a constant scaling factor , and an integer base .</p>

<p>For results where the rounded result would overflow the result for a directed rounding is either the appropriate signed infinity, or the highest representable positive finite number (or the lowest representable negative finite number if <em>x</em> is negative), depending on the direction of rounding. The result of an overflow for the usual case of <em>round to nearest</em> is always the appropriate infinity.</p>
<h2 id="double-rounding">Double rounding</h2>

<p>Rounding a number twice in succession to different precisions, with the latter precision being coarser, is not guaranteed to give the same result as rounding once to the final precision except in the case of directed rounding. For instance rounding 9.46 to one decimal gives 9.5, and then 10 when rounding to integer using rounding half to even, but would give 9 when rounded to integer directly.</p>

<p>In <em>Martinez v. Allstate</em> and <em>Sendejo v. Farmers</em>, litigated between 1995 and 1997, the insurance companies argued that double rounding premiums was permissible and in fact required. The US courts ruled against the insurance companies and ordered them to adopt rules to ensure single rounding.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>Some computer languages and the <a href="IEEE_754-2008" title="wikilink">IEEE 754-2008</a> standard dictate that in straightforward calculations the result should not be rounded twice. This has been a particular problem with Java as it is designed to be run identically on different machines, special programming tricks have had to be used to achieve this with <a class="uri" href="x87" title="wikilink">x87</a> floating point.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> The Java language was changed to allow different results where the difference does not matter and require a <a class="uri" href="strictfp" title="wikilink">strictfp</a> qualifier to be used when the results have to conform accurately.</p>
<h2 id="exact-computation-with-rounded-arithmetic">Exact computation with rounded arithmetic</h2>

<p>It is possible to use rounded arithmetic to evaluate the exact value of a function with a discrete domain and range. For example, if we know that an integer <em>n</em> is a perfect square, we can compute its square root by converting <em>n</em> to a floating-point value <em>x</em>, computing the approximate square root <em>y</em> of <em>x</em> with floating point, and then rounding <em>y</em> to the nearest integer <em>q</em>. If <em>n</em> is not too big, the floating-point roundoff error in <em>y</em> will be less than 0.5, so the rounded value <em>q</em> will be the exact square root of <em>n</em>. In most modern computers, this method may be much faster than computing the square root of <em>n</em> by an all-integer algorithm.</p>
<h2 id="table-makers-dilemma">Table-maker's dilemma</h2>

<p><a href="William_Kahan" title="wikilink">William Kahan</a> coined the term "The Table-Maker's Dilemma" for the unknown cost of rounding <a href="transcendental_function" title="wikilink">transcendental functions</a>:</p>
<blockquote>

<p>"Nobody knows how much it would cost to compute <em>y<sup>w</sup></em> correctly rounded for <em>every</em> two floating-point arguments at which it does not over/underflow. Instead, reputable math libraries compute elementary <a href="transcendental_function" title="wikilink">transcendental functions</a> mostly within slightly more than half an <a href="Unit_in_the_last_place" title="wikilink">ulp</a> and almost always well within one ulp. Why can't <em>y<sup>w</sup></em> be rounded within half an ulp like SQRT? Because nobody knows how much computation it would cost... No general way exists to predict how many extra digits will have to be carried to compute a transcendental expression and round it <em>correctly</em> to some preassigned number of digits. Even the fact (if true) that a finite number of extra digits will ultimately suffice may be a deep theorem."<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
</blockquote>

<p>The <a href="IEEE_floating_point_standard" title="wikilink">IEEE floating point standard</a> guarantees that add, subtract, multiply, divide, <a href="fused_multiply–add" title="wikilink">fused multiply–add</a>, square root, and floating point remainder will give the correctly rounded result of the infinite precision operation. No such guarantee was given in the 1985 standard for more complex functions and they are typically only accurate to within the last bit at best. However, the 2008 standard guarantees that conforming implementations will give correctly rounded results which respect the active rounding mode; implementation of the functions, however, is optional.</p>

<p>Using the <a href="Gelfond–Schneider_theorem" title="wikilink">Gelfond–Schneider theorem</a> and <a href="Lindemann–Weierstrass_theorem" title="wikilink">Lindemann–Weierstrass theorem</a> many of the standard elementary functions can be proved to return <a href="transcendental_number" title="wikilink">transcendental</a> results when given rational non-zero arguments; therefore it is always possible to correctly round such functions. However, determining a limit for a given precision on how accurate results need to be computed, before a correctly rounded result can be guaranteed, may demand a lot of computation time.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>Some packages offer correct rounding. The <a href="MPFR" title="wikilink">GNU MPFR</a> package gives correctly rounded arbitrary precision results. Some other libraries implement elementary functions with correct rounding in double precision:</p>
<ul>
<li><a class="uri" href="IBM" title="wikilink">IBM</a>'s libultim, in rounding to nearest only.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></li>
<li><a href="Sun_Microsystems" title="wikilink">Sun Microsystems</a>'s libmcr, in the 4 rounding modes.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></li>
<li>CRlibm, written in the Arénaire team (LIP, <a href="ENS_Lyon" title="wikilink">ENS Lyon</a>). It supports the 4 rounding modes and is proved.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></li>
</ul>

<p>There exist <a href="computable_number" title="wikilink">computable numbers</a> which a rounded value can never be determined no matter how many digits are calculated. Specific instances cannot be given but this follows from the undecidability of the <a href="halting_problem" title="wikilink">halting problem</a>. For instance, if <a href="Goldbach's_conjecture" title="wikilink">Goldbach's conjecture</a> is true but <a class="uri" href="unprovable" title="wikilink">unprovable</a>, then the result of rounding the following value up to the next integer cannot be determined: 10<sup>−<em>n</em></sup> where <em>n</em> is the first even number greater than 4 which is not the sum of two primes, or 0 if there is no such number. The result is 1 if such a number exists and 0 if no such number exists. The value before rounding can however be approximated to any given precision even if the conjecture is unprovable.</p>
<h2 id="history">History</h2>

<p>The concept of rounding is very old, perhaps older even than the concept of division. Some ancient <a href="clay_tablet" title="wikilink">clay tablets</a> found in <a class="uri" href="Mesopotamia" title="wikilink">Mesopotamia</a> contain tables with rounded values of <a href="Multiplicative_inverse" title="wikilink">reciprocals</a> and square roots in base 60.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> Rounded approximations to <a href="pi" title="wikilink">π</a>, the length of the year, and the length of the month are also ancient—see <a href="base_60#Examples" title="wikilink">base 60#Examples</a>.</p>

<p>The <em>Round-to-even</em> method has served as the <a class="uri" href="ASTM" title="wikilink">ASTM</a> (E-29) standard since 1940. The origin of the terms <em>unbiased rounding</em> and <em>statistician's rounding</em> are fairly self-explanatory. In the 1906 4th edition of <em>Probability and Theory of Errors</em> <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> <a href="Robert_Simpson_Woodward" title="wikilink">Robert Simpson Woodward</a> called this "the computer's rule" indicating that it was then in common use by <a href="human_computer" title="wikilink">human computers</a> who calculated mathematical tables. <a href="Churchill_Eisenhart" title="wikilink">Churchill Eisenhart</a> indicated the practice was already "well established" in data analysis by the 1940s.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>The origin of the term <em>bankers' rounding</em> remains more obscure. If this rounding method was ever a standard in banking, the evidence has proved extremely difficult to find. To the contrary, section 2 of the European Commission report <em>The Introduction of the Euro and the Rounding of Currency Amounts</em> <a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> suggests that there had previously been no standard approach to rounding in banking; and it specifies that "half-way" amounts should be rounded up.</p>

<p>Until the 1980s, the rounding method used in floating-point computer arithmetic was usually fixed by the hardware, poorly documented, inconsistent, and different for each brand and model of computer. This situation changed after the IEEE 754 floating point standard was adopted by most computer manufacturers. The standard allows the user to choose among several rounding modes, and in each case specifies precisely how the results should be rounded. These features made numerical computations more predictable and machine-independent, and made possible the efficient and consistent implementation of <a href="interval_arithmetic" title="wikilink">interval arithmetic</a>.</p>
<h2 id="rounding-functions-in-programming-languages">Rounding functions in programming languages</h2>

<p>Most <a href="programming_language" title="wikilink">programming languages</a> provide functions or special syntax to round fractional numbers in various ways. The earliest numeric languages, such as <a class="uri" href="FORTRAN" title="wikilink">FORTRAN</a> and <a href="C_(programming_language)" title="wikilink">C</a>, would provide only one method, usually truncation (towards zero). This default method could be implied in certain contexts, such as when assigning a fractional number to an <a href="integer_(computing)" title="wikilink">integer</a> <a href="variable_(programming)" title="wikilink">variable</a>, or using a fractional number as an index of an <a href="array_data_type" title="wikilink">array</a>. Other kinds of rounding had to be programmed explicitly; for example, rounding a positive number to the nearest integer could be implemented by adding 0.5 and truncating.</p>

<p>In the last decades, however, the syntax and/or the standard <a href="library_(computing)" title="wikilink">libraries</a> of most languages have commonly provided at least the four basic rounding functions (up, down, to nearest, and towards zero). The tie-breaking method may vary depending the language and version, and/or may be selectable by the programmer. Several languages follow the lead of the IEEE-754 floating-point standard, and define these functions as taking a <a href="Double_precision_floating-point_format" title="wikilink">double precision float</a> argument and returning the result of the same type, which then may be converted to an integer if necessary. This approach may avoid spurious <a href="arithmetic_overflow" title="wikilink">overflows</a> since floating-point types have a larger range than integer types. Some languages, such as <a class="uri" href="PHP" title="wikilink">PHP</a>, provide functions that round a value to a specified number of decimal digits, e.g. from 4321.5678 to 4321.57 or 4300. In addition, many languages provide a <a class="uri" href="printf" title="wikilink">printf</a> or similar string formatting function, which allows one to convert a fractional number to a string, rounded to a user-specified number of decimal places (the <em>precision</em>). On the other hand, truncation (round to zero) is still the default rounding method used by many languages, especially for the division of two integer values.</p>

<p>On the opposite, <a href="Cascading_Style_Sheets" title="wikilink">CSS</a> and <a href="Scalable_Vector_Graphics" title="wikilink">SVG</a> do not define any specific maximum precision for numbers and measurements, that are treated and exposed in their <a href="Document_Object_Model" title="wikilink">DOM</a> and in their <a href="Interface_description_language" title="wikilink">IDL</a> interface as strings as if they had infinite precision, and do not discriminate between integers and floating point values; however, the implementations of these languages will typically convert these numbers into IEEE-754 double floating points before exposing the computed digits with a limited precision (notably within standard <a class="uri" href="JavaScript" title="wikilink">JavaScript</a> or <a class="uri" href="ECMAScript" title="wikilink">ECMAScript</a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> interface bindings).</p>
<h2 id="other-rounding-standards">Other rounding standards</h2>

<p>Some disciplines or institutions have issued standards or directives for rounding.</p>
<h3 id="u.s.-weather-observations">U.S. Weather Observations</h3>

<p>In a guideline issued in mid-1966,<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> the <a href="United_States" title="wikilink">U.S.</a> <a href="Office_of_the_Federal_Coordinator_for_Meteorology" title="wikilink">Office of the Federal Coordinator for Meteorology</a> determined that weather data should be rounded to the nearest round number, with the "round half up" tie-breaking rule. For example, 1.5 rounded to integer should become 2, and −1.5 should become −1. Prior to that date, the tie-breaking rule was "round half away from zero".</p>
<h3 id="negative-zero-in-meteorology">Negative zero in meteorology</h3>

<p>Some <a href="meteorology" title="wikilink">meteorologists</a> may write "−0" to indicate a temperature between 0.0 and −0.5 degrees (exclusive) that was rounded to integer. This notation is used when the negative sign is considered important, no matter how small is the magnitude; for example, when rounding temperatures in the <a class="uri" href="Celsius" title="wikilink">Celsius</a> scale, where below zero indicates freezing.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Gal's_accurate_tables" title="wikilink">Gal's accurate tables</a></li>
<li><a href="Interval_arithmetic" title="wikilink">Interval arithmetic</a></li>
<li><a href="ISO_80000-1" title="wikilink">ISO 80000-1:2009</a></li>
<li><a href="Kahan_summation_algorithm" title="wikilink">Kahan summation algorithm</a></li>
<li><a href="Nearest_integer_function" title="wikilink">Nearest integer function</a></li>
<li><a class="uri" href="Truncation" title="wikilink">Truncation</a></li>
<li><a href="Signed-digit_representation" title="wikilink">Signed-digit representation</a></li>
<li><a href="Swedish_rounding" title="wikilink">Swedish rounding</a>, to avoid the use of coins of extremely low value</li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://www.clivemaxfield.com/diycalculator/popup-m-round.shtml">An introduction to different rounding algorithms</a> that is accessible to a general audience but especially useful to those studying computer science and electronics.</li>
<li><a href="http://support.microsoft.com/kb/196652">How To Implement Custom Rounding Procedures</a> by Microsoft</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Arithmetic" title="wikilink">Category:Arithmetic</a> <a href="Category:Computer_arithmetic" title="wikilink">Category:Computer arithmetic</a> <a href="Category:Theory_of_computation" title="wikilink">Category:Theory of computation</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://mscweb.gsfc.nasa.gov/543web/files/GSFC-X-673-64-1F.pdf">Engineering Drafting Standards Manual</a> (NASA), X-673-64-1F, p90<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="http://www.kennethkuhn.com/students/ee431/text/voltage_regulators_zeners.pdf">"Zener Diode Voltage Regulators"</a><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="http://stellafane.org/tm/atm/test/tester-3.html">"Build a Mirror Tester"</a><a href="#fnref5">↩</a></li>
<li id="fn6">Bruce Trump, Christine Schneider. "Excel Formula Calculates Standard 1%-Resistor Values". Electronic Design, January 21, 2002. <a href="http://electronicdesign.com/article/components/excel-formula-calculates-standard-1-resistor-value.aspx">1</a><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><em>Handbook of Floating-Point Arithmetic</em>, J.-M. Muller et al., Chapter 12 <em>Solving the Table Maker's Dilemma</em>, 2011.<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="http://it.stlawu.edu/%7Edmelvill/mesomath/tablets/YBC7289.html">Duncan J. Melville. "YBC 7289 clay tablet". 2006</a><a href="#fnref15">↩</a></li>
<li id="fn16"><a class="uri" href="http://historical.library.cornell.edu/cgi-bin/cul.math/docviewer?did=05170001&amp;view">http://historical.library.cornell.edu/cgi-bin/cul.math/docviewer?did=05170001&amp;view;</a>;=50&amp;frames;=0&amp;seq;=48<a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a class="uri" href="http://ec.europa.eu/economy_finance/publications/publication1224_en.pdf">http://ec.europa.eu/economy_finance/publications/publication1224_en.pdf</a><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf">ECMA-262 ECMAScript Language Specification</a><a href="#fnref19">↩</a></li>
<li id="fn20">OFCM, 2005: <a href="http://www.ofcm.gov/fmh-1/fmh1.htm">Federal Meteorological Handbook No. 1</a>, Washington, DC., 104 pp.<a href="#fnref20">↩</a></li>
</ol>
</section>
</body>
</html>
