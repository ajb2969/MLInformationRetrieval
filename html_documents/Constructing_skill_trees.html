<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1667">Constructing skill trees</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Constructing skill trees</h1>
<hr/>

<p><strong>Constructing skill trees</strong> (CST) is a hierarchical <a href="reinforcement_learning" title="wikilink">reinforcement learning</a> algorithm which can build skill trees from a set of sample solution trajectories obtained from demonstration. CST uses an incremental MAP(<a href="maximum_a_posteriori" title="wikilink">maximum a posteriori</a>) change point detection algorithm to segment each demonstration trajectory into skills and integrate the results into a skill tree. CST was introduced by <a href="George_Konidaris" title="wikilink">George Konidaris</a>, <a href="Scott_Kuindersma" title="wikilink">Scott Kuindersma</a>, <a href="Andrew_Barto" title="wikilink">Andrew Barto</a> and <a href="Roderic_Grupen" title="wikilink">Roderic Grupen</a> in 2010.</p>
<h2 id="algorithm">Algorithm</h2>

<p>CST consists of mainly three parts;change point detection, alignment and merging. The main focus of CST is online change-point detection. The change-point detection algorithm is used to segment data into skills and uses the sum of discounted reward 

<math display="inline" id="Constructing_skill_trees:0">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{t}
  </annotation>
 </semantics>
</math>

 as the target regression variable. Each skill is assigned an appropriate abstraction. A <a href="particle_filter" title="wikilink">particle filter</a> is used to control the computational complexity of CST.</p>

<p>The change point detection algorithm is implemented as follows. The data for times 

<math display="inline" id="Constructing_skill_trees:1">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>∈</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>t</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\in T
  </annotation>
 </semantics>
</math>

 and models Q with prior 

<math display="inline" id="Constructing_skill_trees:2">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <mo>∈</mo>
    <mi>Q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">q</csymbol>
     <in></in>
     <csymbol cd="unknown">Q</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(q\in Q)
  </annotation>
 </semantics>
</math>

 are given. The algorithm is assumed to be able to fit a segment from time 

<math display="inline" id="Constructing_skill_trees:3">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>j</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j+1
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Constructing_skill_trees:4">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 using model 

<math display="inline" id="Constructing_skill_trees:5">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 with the fit probability 

<math display="inline" id="Constructing_skill_trees:6">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>j</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <vector>
     <ci>j</ci>
     <ci>t</ci>
     <ci>q</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(j,t,q)
  </annotation>
 </semantics>
</math>

. A linear regression model with Gaussian noise is used to compute 

<math display="inline" id="Constructing_skill_trees:7">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>j</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <vector>
     <ci>j</ci>
     <ci>t</ci>
     <ci>q</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(j,t,q)
  </annotation>
 </semantics>
</math>

. The Gaussian noise prior has mean zero, and variance which follows 

<math display="inline" id="Constructing_skill_trees:8">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mi>n</mi>
   <mi>v</mi>
   <mi>e</mi>
   <mi>r</mi>
   <mi>s</mi>
   <mi>e</mi>
   <mi>G</mi>
   <mi>a</mi>
   <mi>m</mi>
   <mi>m</mi>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mfrac>
     <mi>v</mi>
     <mn>2</mn>
    </mfrac>
    <mo>,</mo>
    <mfrac>
     <mi>u</mi>
     <mn>2</mn>
    </mfrac>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>n</ci>
    <ci>v</ci>
    <ci>e</ci>
    <ci>r</ci>
    <ci>s</ci>
    <ci>e</ci>
    <ci>G</ci>
    <ci>a</ci>
    <ci>m</ci>
    <ci>m</ci>
    <ci>a</ci>
    <interval closure="open">
     <apply>
      <divide></divide>
      <ci>v</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <divide></divide>
      <ci>u</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   InverseGamma(\frac{v}{2},\frac{u}{2})
  </annotation>
 </semantics>
</math>

. The prior for each weight follows 

<math display="inline" id="Constructing_skill_trees:9">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mi>o</mi>
   <mi>r</mi>
   <mi>m</mi>
   <mi>a</mi>
   <mi>l</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mrow>
     <msup>
      <mi>σ</mi>
      <mn>2</mn>
     </msup>
     <mi>δ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>o</ci>
    <ci>r</ci>
    <ci>m</ci>
    <ci>a</ci>
    <ci>l</ci>
    <interval closure="open">
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>σ</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>δ</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Normal(0,\sigma^{2}\delta)
  </annotation>
 </semantics>
</math>

.</p>

<p>The fit probability 

<math display="inline" id="Constructing_skill_trees:10">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>j</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <vector>
     <ci>j</ci>
     <ci>t</ci>
     <ci>q</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(j,t,q)
  </annotation>
 </semantics>
</math>

 is computed by the following equation.</p>

<p>

<math display="inline" id="Constructing_skill_trees:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>j</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <msup>
      <mi>π</mi>
      <mrow>
       <mo>-</mo>
       <mfrac>
        <mi>n</mi>
        <mn>2</mn>
       </mfrac>
      </mrow>
     </msup>
     <msup>
      <mi>δ</mi>
      <mi>m</mi>
     </msup>
    </mfrac>
    <msup>
     <mrow>
      <mo>|</mo>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>A</mi>
         <mo>+</mo>
         <mi>D</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo>|</mo>
     </mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
    </msup>
    <mfrac>
     <msup>
      <mi>u</mi>
      <mfrac>
       <mi>v</mi>
       <mn>2</mn>
      </mfrac>
     </msup>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>y</mi>
        <mo>+</mo>
        <mi>u</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mfrac>
       <mrow>
        <mi>u</mi>
        <mo>+</mo>
        <mi>v</mi>
       </mrow>
       <mn>2</mn>
      </mfrac>
     </msup>
    </mfrac>
    <mfrac>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mfrac>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mi>v</mi>
        </mrow>
        <mn>2</mn>
       </mfrac>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mfrac>
        <mi>v</mi>
        <mn>2</mn>
       </mfrac>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <vector>
      <ci>j</ci>
      <ci>t</ci>
      <ci>q</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>π</ci>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>δ</ci>
       <ci>m</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <plus></plus>
         <ci>A</ci>
         <ci>D</ci>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>u</ci>
       <apply>
        <divide></divide>
        <ci>v</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <ci>y</ci>
        <ci>u</ci>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <plus></plus>
         <ci>u</ci>
         <ci>v</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>normal-Γ</ci>
       <apply>
        <divide></divide>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <ci>v</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Γ</ci>
       <apply>
        <divide></divide>
        <ci>v</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(j,t,q)=\frac{\pi^{-\frac{n}{2}}}{\delta^{m}}\left|(A+D)^{-1}\right|^{\frac{1%
}{2}}\frac{u^{\frac{v}{2}}}{(y+u)^{\frac{u+v}{2}}}\frac{\Gamma(\frac{n+v}{2})}%
{\Gamma({\frac{v}{2}})}
  </annotation>
 </semantics>
</math>

</p>

<p>Then, CST compute the probability of the changepoint at time j with model q, 

<math display="inline" id="Constructing_skill_trees:12">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>t</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>j</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>t</ci>
    </apply>
    <interval closure="open">
     <ci>j</ci>
     <ci>q</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{t}(j,q)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Constructing_skill_trees:13">
 <semantics>
  <msubsup>
   <mi>P</mi>
   <mi>j</mi>
   <mrow>
    <mi>M</mi>
    <mi>A</mi>
    <mi>P</mi>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>A</ci>
      <ci>P</ci>
     </apply>
    </apply>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{MAP}_{j}
  </annotation>
 </semantics>
</math>

 using an <a href="Viterbi_algorithm" title="wikilink">Viterbi algorithm</a>.</p>

<p>

<math display="inline" id="Constructing_skill_trees:14">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>P</mi>
     <mi>t</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>j</mi>
     <mo>,</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mi>G</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>t</mi>
         <mo>-</mo>
         <mi>j</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>j</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msubsup>
     <mi>P</mi>
     <mi>j</mi>
     <mrow>
      <mi>M</mi>
      <mi>A</mi>
      <mi>P</mi>
     </mrow>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>t</ci>
     </apply>
     <interval closure="open">
      <ci>j</ci>
      <ci>q</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>G</ci>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>P</ci>
     <vector>
      <ci>j</ci>
      <ci>t</ci>
      <ci>q</ci>
     </vector>
     <ci>p</ci>
     <ci>q</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>P</ci>
       <apply>
        <times></times>
        <ci>M</ci>
        <ci>A</ci>
        <ci>P</ci>
       </apply>
      </apply>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{t}(j,q)=(1-G(t-j-1))P(j,t,q)p(q)P^{MAP}_{j}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Constructing_skill_trees:15">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Φ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(x_{i})
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Constructing_skill_trees:16">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

: a vector of m basis functions evaluated at state 

<math display="inline" id="Constructing_skill_trees:17">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mi>j</mi>
       </mrow>
       <mi>t</mi>
      </msubsup>
      <msubsup>
       <mi>R</mi>
       <mi>i</mi>
       <mn>2</mn>
      </msubsup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msup>
      <mi>b</mi>
      <mi>T</mi>
     </msup>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mo>+</mo>
        <mi>D</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mi>b</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <sum></sum>
        <ci>t</ci>
       </apply>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>R</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <ci>A</ci>
        <ci>D</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=(\sum^{t}_{i=j}R^{2}_{i})-b^{T}(A+D)^{-1}b
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Constructing_skill_trees:18">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mi>j</mi>
     </mrow>
     <mi>t</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>i</mi>
     </msub>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>b</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <sum></sum>
       <ci>t</ci>
      </apply>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-Φ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b=\sum^{t}_{i=j}R_{i}\Phi(x_{i})
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Constructing_skill_trees:19">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mi>i</mi>
     </mrow>
     <mi>T</mi>
    </msubsup>
    <mrow>
     <msup>
      <mi>γ</mi>
      <mrow>
       <mi>j</mi>
       <mo>-</mo>
       <mi>i</mi>
      </mrow>
     </msup>
     <msub>
      <mi>r</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <sum></sum>
       <ci>T</ci>
      </apply>
      <apply>
       <eq></eq>
       <ci>j</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>γ</ci>
       <apply>
        <minus></minus>
        <ci>j</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{i}=\sum^{T}_{j=i}\gamma^{j-i}r_{j}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Constructing_skill_trees:20">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Constructing_skill_trees:21">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mi>t</mi>
    <mo>-</mo>
    <mi>j</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <minus></minus>
     <ci>t</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=t-j
  </annotation>
 </semantics>
</math>

: Gamma function</p>

<p>

<math display="inline" id="Constructing_skill_trees:22">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Constructing_skill_trees:23">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

: The number of basis functions q has.</p>

<p>

<math display="inline" id="Constructing_skill_trees:24">
 <semantics>
  <msup>
   <mi>δ</mi>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>δ</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta^{-1}
  </annotation>
 </semantics>
</math>

: an m by m matrix with 

<math display="inline" id="Constructing_skill_trees:25">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

 on the diagonal and zeros else where</p>

<p>The skill length 

<math display="inline" id="Constructing_skill_trees:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>p</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi>l</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>l</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>p</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>l</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(l)=(1-p)^{l-1}p
  </annotation>
 </semantics>
</math>

 is assumed to follow a Geometric distribution with parameter p</p>

<p>

<math display="inline" id="Constructing_skill_trees:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>p</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>l</mi>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>l</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>p</ci>
      </apply>
      <ci>l</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(l)=(1-(1-p)^{l})
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Constructing_skill_trees:28">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mi>k</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=\frac{1}{k}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Constructing_skill_trees:29">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>:</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>k</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k:
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Constructing_skill_trees:30">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mi>L</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(NL)
  </annotation>
 </semantics>
</math>

Expected skill length</p>

<p>Using the method above, CST can segment data into a skill chain. The time complexity of the change point detection is 

<math display="inline" id="Constructing_skill_trees:31">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>N</mi>
     <mi>c</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(Nc)
  </annotation>
 </semantics>
</math>

 and storage size is 

<math display="inline" id="Constructing_skill_trees:32">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Constructing_skill_trees:33">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is the number of particles, 

<math display="inline" id="Constructing_skill_trees:34">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>j</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <vector>
     <ci>j</ci>
     <ci>t</ci>
     <ci>q</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(j,t,q)
  </annotation>
 </semantics>
</math>

 is the time of computing 

<math display="inline" id="Constructing_skill_trees:35">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(c)
  </annotation>
 </semantics>
</math>

, and there are 

<math display="inline" id="Constructing_skill_trees:36">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>j</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <vector>
     <ci>j</ci>
     <ci>t</ci>
     <ci>q</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(j,t,q)
  </annotation>
 </semantics>
</math>

 change points.</p>

<p>Next step is alignment. CST needs to align the component skills because the change-point does not occur in the exactly same places. Thus, when segmenting second trajectory after segmenting the first trajectory, it has a bias on the location of change point in the second trajectory. This bias follows a mixture of gaussians.</p>

<p>The last step is merging. CST merges skill chains into a skill tree. CST merges a pair of trajectory segments by allocating the same skill. All trajectories have the same goal and it merges two chains by starting at their final segments. If two segments are statistically similar, it merges them. This procedure is repeated until it fails to merge a pair of skill segments. 

<math display="inline" id="Constructing_skill_trees:37">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>∈</mo>
   <mrow>
    <mi>p</mi>
    <mi>a</mi>
    <mi>r</mi>
    <mi>t</mi>
    <mi>i</mi>
    <mi>c</mi>
    <mi>l</mi>
    <mi>e</mi>
    <mi>s</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>p</ci>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>a</ci>
     <ci>r</ci>
     <ci>t</ci>
     <ci>i</ci>
     <ci>c</ci>
     <ci>l</ci>
     <ci>e</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\in particles
  </annotation>
 </semantics>
</math>

 are used to determine whether a pair of trajectories are modeled better as one skill or as two different skills.</p>
<h2 id="pseudocode">Pseudocode</h2>

<p>The following <a class="uri" href="pseudocode" title="wikilink">pseudocode</a> describes the change point detection algorithm:</p>

<p><code>  particles = [];</code><br/>
<code>  Process each incoming data point</code><br/>
<code>  for t=1:T</code><br/>
<code>     //Compute fit probabilities for all particles      </code><br/>
<code>     for </code>

<math display="inline" id="Constructing_skill_trees:38">
 <semantics>
  <msub>
   <mi>max</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <max></max>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max_{p}
  </annotation>
 </semantics>
</math>

<code> </code><br/>
<code>        p_tjq=(1-G(t-p.pos-1))*p.fit_prob*model_prior(p.model)*p.prev_MAP </code><br/>
<code>        p.MAP=p_tjq*g(t-p.pos)/(1-G(t-p.pos-1))</code><br/>
<code>     end</code><br/>
<code>     //Filter if necessary</code><br/>
<code>     if the number of particles &gt;= N</code><br/>
<code>        particles=particle_filter(p.MAP, M)</code><br/>
<code>     end</code><br/>
<code>     //Determine the Viterbi path</code><br/>
<code>     for t==1</code><br/>
<code>        max_path=[]</code><br/>
<code>        max_MAP=1/|Q|</code><br/>
<code>     else</code><br/>
<code>        max_particle=</code>

<math display="inline" id="Constructing_skill_trees:39">
 <semantics>
  <mo>∪</mo>
  <annotation-xml encoding="MathML-Content">
   <union></union>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cup
  </annotation>
 </semantics>
</math>

<code>p.MAP</code><br/>
<code>        max_path=max_particle.path </code>

<math display="inline" id="Constructing_skill_trees:40">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>∈</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>q</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\in Q
  </annotation>
 </semantics>
</math>

<code> max_particle</code><br/>
<code>        max_MAP=max_particle.MAP</code><br/>
<code>     end</code><br/>
<code>     //Create new particles for a changepoint at time t</code><br/>
<code>     for </code>

<math display="inline" id="Constructing_skill_trees:41">
 <semantics>
  <mo>∪</mo>
  <annotation-xml encoding="MathML-Content">
   <union></union>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cup
  </annotation>
 </semantics>
</math>

<br/>
<code>        new_p=create_particle(model=q, pos=t, prev_MAP=max_MAP, path=max_path)</code><br/>
<code>        p=p </code>

<math display="inline" id="Constructing_skill_trees:42">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>∈</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>p</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\in P
  </annotation>
 </semantics>
</math>

<code> new_p</code><br/>
<code>     end</code><br/>
<code>     //Update all particles</code><br/>
<code>     for </code>

<math display="inline" id="Constructing_skill_trees:43">
 <semantics>
  <msub>
   <mi mathvariant="normal">Φ</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Φ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi_{t}
  </annotation>
 </semantics>
</math>

<br/>
<code>        particles=update_particle(current_state, current_reward,p)      </code><br/>
<code>     end</code><br/>
<code>  end</code><br/>
<code>  //Return the most likely path to the final point</code><br/>
<code>  return max_path</code></p>

<p><code>  function update_particle(current_state, current_reward, particle);</code><br/>
<code>  p=particle</code><br/>
<code>  r_t=current_reward</code><br/>
<code>  //Initialization</code><br/>
<code>  if t==0</code><br/>
<code>     p.A=zero matrix(p.m,p.m)</code><br/>
<code>     p.b=zero vector(p.m)</code><br/>
<code>     p.z=zero vector(p.m)</code><br/>
<code>     p.sum r=0</code><br/>
<code>     p.tr1=0</code><br/>
<code>     p.tr2=0</code><br/>
<code>  end</code><br/>
<code>  //Compute the basis function vector for the current state</code><br/>
<code>  </code>

<math display="inline" id="Constructing_skill_trees:44">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

<code>=p.</code>

<math display="inline" id="Constructing_skill_trees:45">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Φ</mi>
    <mi>t</mi>
   </msub>
   <msubsup>
    <mi mathvariant="normal">Φ</mi>
    <mi>t</mi>
    <mi>T</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Φ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Φ</ci>
      <ci>t</ci>
     </apply>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi_{t}\Phi_{t}^{T}
  </annotation>
 </semantics>
</math>

<code>(current state)</code><br/>
<code>  //Update sufficient statistics</code><br/>
<code>  p.A=p.A+</code>

<math display="inline" id="Constructing_skill_trees:46">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

<br/>
<code>  p.z=</code>

<math display="inline" id="Constructing_skill_trees:47">
 <semantics>
  <msub>
   <mi mathvariant="normal">Φ</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Φ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi_{t}
  </annotation>
 </semantics>
</math>

<code>p.z+</code>

<math display="inline" id="Constructing_skill_trees:48">
 <semantics>
  <msub>
   <mi>r</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{t}
  </annotation>
 </semantics>
</math>

<br/>
<code>  p.b=p.b+</code>

<math display="inline" id="Constructing_skill_trees:49">
 <semantics>
  <msup>
   <mi>γ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>γ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma^{2}
  </annotation>
 </semantics>
</math>

<code> p.z</code><br/>
<code>  p.tr1=1+ </code>

<math display="inline" id="Constructing_skill_trees:50">
 <semantics>
  <msubsup>
   <mi>r</mi>
   <mi>t</mi>
   <mn>2</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>t</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{t}^{2}
  </annotation>
 </semantics>
</math>

<code> p.tr1</code><br/>
<code>  p.sum r=sum p.r+ </code>

<math display="inline" id="Constructing_skill_trees:51">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <msub>
    <mi>r</mi>
    <mi>t</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>γ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma r_{t}
  </annotation>
 </semantics>
</math>

<code> p.tr1+2</code>

<math display="inline" id="Constructing_skill_trees:52">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

<code> p.tr2</code><br/>
<code>  p.tr2=</code>

<math display="inline" id="Constructing_skill_trees:53">
 <semantics>
  <msub>
   <mi>r</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{t}
  </annotation>
 </semantics>
</math>

<code>p.tr2+</code>

<math display="inline" id="Constructing_skill_trees:54">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

<code> p.tr1</code><br/>
<code>  p.fit_prob=compute_fit_prob(p,v,u,delta,</code><span class="LaTeX">$\gamma$</span><code>)</code></p>
<h2 id="assumptions">Assumptions</h2>

<p>CTS assume that the demonstrated skills form a tree, the domain reward function is known and the best model for merging a pair of skills is the model selected for representing both individually.</p>
<h2 id="advantages">Advantages</h2>

<p>CTS is much faster learning algorithm than <a href="skill_chaining" title="wikilink">skill chaining</a>. CTS can be applied to learning higher dimensional policies. Even unsuccessful episode can improve skills. Skills acquired using agent-centric features can be used for other problems.</p>
<h2 id="uses">Uses</h2>

<p>CST has been used to acquire skills from human demonstration in the <a class="uri" href="PinBall" title="wikilink">PinBall</a> domain. It has been also used to acquire skills from human demonstration on a mobile manipulator.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Machine_learning_algorithms" title="wikilink">Category:Machine learning algorithms</a></p>
</body>
</html>
