<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="315">Singular value decomposition</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Singular value decomposition</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Visualization of the SVD of a two-dimensional, real <a href="Shear_mapping" title="wikilink">shearing matrix</a> 

<math display="inline" id="Singular_value_decomposition:0">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

. First, we see the <a href="unit_disc" title="wikilink">unit disc</a> in blue together with the two <a href="standard_basis" title="wikilink">canonical unit vectors</a>. We then see the action of 

<math display="inline" id="Singular_value_decomposition:1">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

, which distorts the disk to an <a class="uri" href="ellipse" title="wikilink">ellipse</a>. The SVD decomposes 

<math display="inline" id="Singular_value_decomposition:2">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 into three simple transformations: an initial <a href="Rotation_matrix" title="wikilink">rotation</a> <mtpl></mtpl>, a <a href="Scaling_matrix" title="wikilink">scaling</a> 

<math display="inline" id="Singular_value_decomposition:3">
 <semantics>
  <mi>𝚺</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚺</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Σ}
  </annotation>
 </semantics>
</math>


 along the coordinate axes, and a final rotation 

<math display="inline" id="Singular_value_decomposition:4">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}
  </annotation>
 </semantics>
</math>

. The lengths <mtpl></mtpl> and <mtpl></mtpl> of the <a href="Ellipse#Elements_of_an_ellipse" title="wikilink">semi-axes</a> of the ellipse are the <a href="singular_value" title="wikilink">singular values</a> of 

<math display="inline" id="Singular_value_decomposition:5">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

, namely <mtpl></mtpl> and <mtpl></mtpl>.</figcaption>
</figure>

<p>In <a href="linear_algebra" title="wikilink">linear algebra</a>, the <strong>singular value decomposition</strong> (<strong>SVD</strong>) is a <a href="Matrix_decomposition" title="wikilink">factorization</a> of a <a href="real_number" title="wikilink">real</a> or <a href="complex_number" title="wikilink">complex</a> <a href="matrix_(mathematics)" title="wikilink">matrix</a>. It has many useful applications in <a href="signal_processing" title="wikilink">signal processing</a> and statistics.</p>

<p>Formally, the singular value decomposition of an 

<math display="inline" id="Singular_value_decomposition:6">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m×n
  </annotation>
 </semantics>
</math>

 real or complex matrix 

<math display="inline" id="Singular_value_decomposition:7">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 is a factorization of the form <mtpl> <strong>UΣV</strong><sup>∗</sup>}}</mtpl>, where 

<math display="inline" id="Singular_value_decomposition:8">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}
  </annotation>
 </semantics>
</math>


 is an 

<math display="inline" id="Singular_value_decomposition:9">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi mathvariant="normal">×</mi>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>normal-×</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m×m
  </annotation>
 </semantics>
</math>

 real or complex <a href="unitary_matrix" title="wikilink">unitary matrix</a>, 

<math display="inline" id="Singular_value_decomposition:10">
 <semantics>
  <mi>𝚺</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚺</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Σ}
  </annotation>
 </semantics>
</math>

 is an 

<math display="inline" id="Singular_value_decomposition:11">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m×n
  </annotation>
 </semantics>
</math>

 <a href="rectangular_diagonal_matrix" title="wikilink">rectangular diagonal matrix</a> with non-negative real numbers on the diagonal, and <mtpl></mtpl> (the <a href="conjugate_transpose" title="wikilink">conjugate transpose</a> of 

<math display="inline" id="Singular_value_decomposition:12">
 <semantics>
  <mi>𝐕</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐕</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}
  </annotation>
 </semantics>
</math>

, or simply the transpose of 

<math display="inline" id="Singular_value_decomposition:13">
 <semantics>
  <mi>𝐕</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐕</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}
  </annotation>
 </semantics>
</math>


 if 

<math display="inline" id="Singular_value_decomposition:14">
 <semantics>
  <mi>𝐕</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐕</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}
  </annotation>
 </semantics>
</math>

 is real) is an 

<math display="inline" id="Singular_value_decomposition:15">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n×n
  </annotation>
 </semantics>
</math>

 real or complex <a href="unitary_matrix" title="wikilink">unitary matrix</a>. The diagonal entries <mtpl></mtpl> of 

<math display="inline" id="Singular_value_decomposition:16">
 <semantics>
  <mi>𝚺</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚺</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Σ}
  </annotation>
 </semantics>
</math>

 are known as the <strong><a href="singular_value" title="wikilink">singular values</a></strong> of 

<math display="inline" id="Singular_value_decomposition:17">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

. The 

<math display="inline" id="Singular_value_decomposition:18">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>


 columns of 

<math display="inline" id="Singular_value_decomposition:19">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}
  </annotation>
 </semantics>
</math>

 and the 

<math display="inline" id="Singular_value_decomposition:20">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 columns of 

<math display="inline" id="Singular_value_decomposition:21">
 <semantics>
  <mi>𝐕</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐕</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}
  </annotation>
 </semantics>
</math>

 are called the <strong>left-singular vectors</strong> and <strong>right-singular vectors</strong> of 

<math display="inline" id="Singular_value_decomposition:22">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

, respectively.</p>

<p>The singular value decomposition and the <a class="uri" href="eigendecomposition" title="wikilink">eigendecomposition</a> are closely related. Namely:</p>

<p>:* The left-singular vectors of 

<math display="inline" id="Singular_value_decomposition:23">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>


 are <a class="uri" href="eigenvectors" title="wikilink">eigenvectors</a> of <mtpl></mtpl>.</p>

<p>:* The right-singular vectors of 

<math display="inline" id="Singular_value_decomposition:24">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 are eigenvectors of <mtpl></mtpl>.</p>

<p>:* The non-zero singular values of 

<math display="inline" id="Singular_value_decomposition:25">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 (found on the diagonal entries of 

<math display="inline" id="Singular_value_decomposition:26">
 <semantics>
  <mi>𝚺</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚺</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Σ}
  </annotation>
 </semantics>
</math>

) are the square roots of the non-zero <a class="uri" href="eigenvalues" title="wikilink">eigenvalues</a> of both <mtpl></mtpl> and <mtpl></mtpl>.</p>

<p>Applications that employ the SVD include computing the <a href="Moore–Penrose_pseudoinverse" title="wikilink">pseudoinverse</a>, <a href="least_squares" title="wikilink">least squares</a> fitting of data, multivariable control, matrix approximation, and determining the <a href="rank_of_a_matrix" title="wikilink">rank</a>, <a href="range_of_a_matrix" title="wikilink">range</a> and <a href="kernel_(matrix)" title="wikilink">null space</a> of a matrix.</p>
<h2 id="statement-of-the-theorem">Statement of the theorem</h2>

<p>Suppose 

<math display="inline" id="Singular_value_decomposition:27">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 is a 

<math display="inline" id="Singular_value_decomposition:28">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m×n
  </annotation>
 </semantics>
</math>


 <a href="matrix_(mathematics)" title="wikilink">matrix</a> whose entries come from the <a href="field_(mathematics)" title="wikilink">field</a> 

<math display="inline" id="Singular_value_decomposition:29">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

, which is either the field of <a href="real_number" title="wikilink">real numbers</a> or the field of <a href="complex_number" title="wikilink">complex numbers</a>. Then there exists a factorization of the form</p>

<p>

<math display="block" id="Singular_value_decomposition:30">
 <semantics>
  <mrow>
   <mi>𝐌</mi>
   <mo>=</mo>
   <mrow>
    <mi>𝐔</mi>
    <mi>𝚺</mi>
    <msup>
     <mi>𝐕</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐌</ci>
    <apply>
     <times></times>
     <ci>𝐔</ci>
     <ci>𝚺</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐕</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}=\mathbf{U}\boldsymbol{\Sigma}\mathbf{V}^{*}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Singular_value_decomposition:31">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}
  </annotation>
 </semantics>
</math>

 is an 

<math display="inline" id="Singular_value_decomposition:32">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi mathvariant="normal">×</mi>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>normal-×</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m×m
  </annotation>
 </semantics>
</math>

 <a href="unitary_matrix" title="wikilink">unitary matrix</a> over 

<math display="inline" id="Singular_value_decomposition:33">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>


 (<a href="orthogonal_matrix" title="wikilink">orthogonal matrix</a> if 

<math display="inline" id="Singular_value_decomposition:34">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>=</mo>
   <mi>𝐑</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>K</ci>
    <ci>𝐑</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K=\mathbf{R}
  </annotation>
 </semantics>
</math>

), 

<math display="inline" id="Singular_value_decomposition:35">
 <semantics>
  <mi>𝚺</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚺</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Σ}
  </annotation>
 </semantics>
</math>

 is a 

<math display="inline" id="Singular_value_decomposition:36">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m×n
  </annotation>
 </semantics>
</math>

 <a href="diagonal_matrix" title="wikilink">diagonal matrix</a> with non-negative real numbers on the diagonal, and the 

<math display="inline" id="Singular_value_decomposition:37">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n×n
  </annotation>
 </semantics>
</math>

 unitary matrix <mtpl></mtpl> denotes the <a href="conjugate_transpose" title="wikilink">conjugate transpose</a> of the 

<math display="inline" id="Singular_value_decomposition:38">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n×n
  </annotation>
 </semantics>
</math>


 unitary matrix 

<math display="inline" id="Singular_value_decomposition:39">
 <semantics>
  <mi>𝐕</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐕</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}
  </annotation>
 </semantics>
</math>

. Such a factorization is called a singular value decomposition of 

<math display="inline" id="Singular_value_decomposition:40">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

.</p>

<p>The diagonal entries <mtpl></mtpl> of 

<math display="inline" id="Singular_value_decomposition:41">
 <semantics>
  <mi>𝚺</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚺</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Σ}
  </annotation>
 </semantics>
</math>

 are known as the <strong><a href="singular_value" title="wikilink">singular values</a></strong> of 

<math display="inline" id="Singular_value_decomposition:42">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

. A common convention is to list the singular values in descending order. In this case, the diagonal matrix 

<math display="inline" id="Singular_value_decomposition:43">
 <semantics>
  <mi>𝚺</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚺</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Σ}
  </annotation>
 </semantics>
</math>


 is uniquely determined by 

<math display="inline" id="Singular_value_decomposition:44">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 (though the matrices 

<math display="inline" id="Singular_value_decomposition:45">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Singular_value_decomposition:46">
 <semantics>
  <mi>𝐕</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐕</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}
  </annotation>
 </semantics>
</math>

 are not).</p>
<h2 id="intuitive-interpretations">Intuitive interpretations</h2>
<figure><b>(Figure)</b>
<figcaption>The image shows:<br/>
<strong>Upper Left:</strong> The unit disc with the two canonical unit vectors<br/>
<strong>Upper Right:</strong> Unit disc transformed with M and singular Values <mtpl></mtpl> and <mtpl></mtpl> indicated<br/>
<strong>Lower Left:</strong> The action of <mtpl></mtpl> on the unit disc. This is just a rotation.<br/>
<strong>Lower Right:</strong> The action of <mtpl></mtpl> on the unit disc. Sigma scales in vertically and horizontally.<br/>
In this special case, the singular values are Phi and 1/Phi where Phi is the <a href="Golden_ratio" title="wikilink">Golden ratio</a>. <mtpl></mtpl> is a (counter clockwise) rotation by an angle alpha where alpha satisfies tan(alpha) = -Phi. 

<math display="inline" id="Singular_value_decomposition:47">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}
  </annotation>
 </semantics>
</math>

 is a rotation by an angle beta with tan(beta) = Phi-1</figcaption>
</figure>
<h3 id="rotation-scaling">Rotation, scaling</h3>

<p>In the special, yet common case when 

<math display="inline" id="Singular_value_decomposition:48">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>


 is an 

<math display="inline" id="Singular_value_decomposition:49">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi mathvariant="normal">×</mi>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>normal-×</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m×m
  </annotation>
 </semantics>
</math>

 real <a href="square_matrix" title="wikilink">square matrix</a> with positive <a class="uri" href="determinant" title="wikilink">determinant</a>, <mtpl></mtpl>, and 

<math display="inline" id="Singular_value_decomposition:50">
 <semantics>
  <mi>𝚺</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚺</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Σ}
  </annotation>
 </semantics>
</math>

 are real 

<math display="inline" id="Singular_value_decomposition:51">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi mathvariant="normal">×</mi>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>normal-×</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m×m
  </annotation>
 </semantics>
</math>

 matrices as well, 

<math display="inline" id="Singular_value_decomposition:52">
 <semantics>
  <mi>𝚺</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚺</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Σ}
  </annotation>
 </semantics>
</math>

 can be regarded as a <a href="scaling_matrix" title="wikilink">scaling matrix</a>, and <mtpl></mtpl> can be viewed as <a href="rotation_matrix" title="wikilink">rotation matrices</a>. Thus the expression <mtpl></mtpl> can be intuitively interpreted as a <a href="Function_composition" title="wikilink">composition</a> (or <a class="uri" href="sequence" title="wikilink">sequence</a>) of three geometrical <a href="Transformation_(geometry)" title="wikilink">transformations</a>: a <a href="Rotation_(geometry)" title="wikilink">rotation</a>, a <a href="Scaling_(geometry)" title="wikilink">scaling</a>, and another rotation. For instance, the figure above explains how a <a href="shear_matrix" title="wikilink">shear matrix</a> can be described as such a sequence.</p>
<h3 id="singular-values-as-semiaxes-of-an-ellipse-or-ellipsoid">Singular values as semiaxes of an ellipse or ellipsoid</h3>

<p>As shown in the figure, the <a href="singular_values" title="wikilink">singular values</a> can be interpreted as the semiaxes of an <a class="uri" href="ellipse" title="wikilink">ellipse</a> in 2D. This concept can be generalized to 

<math display="inline" id="Singular_value_decomposition:53">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


-dimensional <a href="Euclidean_space" title="wikilink">Euclidean space</a>, with the singular values of any 

<math display="inline" id="Singular_value_decomposition:54">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n×n
  </annotation>
 </semantics>
</math>

 <a href="square_matrix" title="wikilink">square matrix</a> being viewed as the semiaxes of an 

<math display="inline" id="Singular_value_decomposition:55">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-dimensional <a class="uri" href="ellipsoid" title="wikilink">ellipsoid</a>. See <a href="#Geometric_meaning" title="wikilink">below</a> for further details.</p>
<h3 id="the-columns-of-u-and-v-are-orthonormal-bases">The columns of <em>U</em> and <em>V</em> are orthonormal bases</h3>

<p>Since 

<math display="inline" id="Singular_value_decomposition:56">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}
  </annotation>
 </semantics>
</math>

 and <mtpl></mtpl> are unitary, the columns of each of them form a set of <a href="orthonormal_vectors" title="wikilink">orthonormal vectors</a>, which can be regarded as <a href="basis_vectors" title="wikilink">basis vectors</a>. By the definition of a unitary matrix, the same is true for their conjugate transposes <mtpl></mtpl> and 

<math display="inline" id="Singular_value_decomposition:57">
 <semantics>
  <mi>𝐕</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐕</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}
  </annotation>
 </semantics>
</math>

. In short, the columns of <mtpl></mtpl>, and <mtpl></mtpl> are <a href="Orthonormal_basis" title="wikilink">orthonormal bases</a>.</p>
<h2 id="example">Example</h2>

<p>Consider the 

<math display="inline" id="Singular_value_decomposition:58">
 <semantics>
  <mrow>
   <mn>4</mn>
   <mi mathvariant="normal">×</mi>
   <mn>5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">4</cn>
    <ci>normal-×</ci>
    <cn type="integer">5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4×5
  </annotation>
 </semantics>
</math>


 matrix</p>

<p>

<math display="block" id="Singular_value_decomposition:59">
 <semantics>
  <mrow>
   <mi>𝐌</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>2</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>3</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>4</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐌</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">2</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">3</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">4</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}=\begin{bmatrix}1&0&0&0&2\\
0&0&3&0&0\\
0&0&0&0&0\\
0&4&0&0&0\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>A singular value decomposition of this matrix is given by <mtpl></mtpl></p>

<p>

<math display="inline" id="Singular_value_decomposition:60">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\mathbf{U}
  </annotation>
 </semantics>
</math>


</p>

<p>Notice 

<math display="inline" id="Singular_value_decomposition:61">
 <semantics>
  <mi>𝚺</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚺</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Σ}
  </annotation>
 </semantics>
</math>

 is zero outside of the diagonal and one diagonal element is zero. Furthermore, because the matrices 

<math display="inline" id="Singular_value_decomposition:62">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}
  </annotation>
 </semantics>
</math>

 and <mtpl></mtpl> are <a href="unitary_matrix" title="wikilink">unitary</a>, multiplying by their respective conjugate transposes yields <a href="identity_matrix" title="wikilink">identity matrices</a>, as shown below. In this case, because 

<math display="inline" id="Singular_value_decomposition:63">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}
  </annotation>
 </semantics>
</math>

 and <mtpl></mtpl> are real valued, they each are an <a href="orthogonal_matrix" title="wikilink">orthogonal matrix</a>.</p>

<p>

<math display="inline" id="Singular_value_decomposition:64">
 <semantics>
  <msup>
   <mi>𝐔𝐔</mi>
   <mi>𝐓</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝐔𝐔</ci>
    <ci>𝐓</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\mathbf{U}\mathbf{U^{T}}
  </annotation>
 </semantics>
</math>


</p>

<p>This particular singular value decomposition is not unique. Choosing 

<math display="inline" id="Singular_value_decomposition:65">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 such that</p>

<p>

<math display="block" id="Singular_value_decomposition:66">
 <semantics>
  <mrow>
   <msup>
    <mi>𝐕</mi>
    <mo>*</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msqrt>
        <mn>0.2</mn>
       </msqrt>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <msqrt>
        <mn>0.8</mn>
       </msqrt>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msqrt>
        <mn>0.4</mn>
       </msqrt>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <msqrt>
        <mn>0.5</mn>
       </msqrt>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <msqrt>
         <mn>0.1</mn>
        </msqrt>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>-</mo>
        <msqrt>
         <mn>0.4</mn>
        </msqrt>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <msqrt>
        <mn>0.5</mn>
       </msqrt>
      </mtd>
      <mtd columnalign="center">
       <msqrt>
        <mn>0.1</mn>
       </msqrt>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐕</ci>
     <times></times>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <apply>
       <root></root>
       <cn type="float">0.2</cn>
      </apply>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <apply>
       <root></root>
       <cn type="float">0.8</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <root></root>
       <cn type="float">0.4</cn>
      </apply>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <apply>
       <root></root>
       <cn type="float">0.5</cn>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <root></root>
        <cn type="float">0.1</cn>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <minus></minus>
       <apply>
        <root></root>
        <cn type="float">0.4</cn>
       </apply>
      </apply>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
      <apply>
       <root></root>
       <cn type="float">0.5</cn>
      </apply>
      <apply>
       <root></root>
       <cn type="float">0.1</cn>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}^{*}=\begin{bmatrix}0&1&0&0&0\\
0&0&1&0&0\\
\sqrt{0.2}&0&0&0&\sqrt{0.8}\\
\sqrt{0.4}&0&0&\sqrt{0.5}&-\sqrt{0.1}\\
-\sqrt{0.4}&0&0&\sqrt{0.5}&\sqrt{0.1}\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>is also a valid singular value decomposition.</p>
<h2 id="singular-values-singular-vectors-and-their-relation-to-the-svd">Singular values, singular vectors, and their relation to the SVD</h2>

<p>A non-negative real number 

<math display="inline" id="Singular_value_decomposition:67">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   σ
  </annotation>
 </semantics>
</math>

 is a <strong><a href="singular_value" title="wikilink">singular value</a></strong> for 

<math display="inline" id="Singular_value_decomposition:68">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 if and only if there exist unit-length vectors <em>u</em> in <em>K<sup>m</sup></em> and <em>v</em> in <em>K<sup>n</sup></em> such that</p>

<p>

<math display="block" id="Singular_value_decomposition:69">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐌</mi>
    <mover accent="true">
     <mi>v</mi>
     <mo stretchy="false">→</mo>
    </mover>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>σ</mi>
    <mpadded width="+1.7pt">
     <mover accent="true">
      <mi>u</mi>
      <mo stretchy="false">→</mo>
     </mover>
    </mpadded>
    <mtext>and</mtext>
    <msup>
     <mi>𝐌</mi>
     <mo>*</mo>
    </msup>
    <mover accent="true">
     <mi>u</mi>
     <mo stretchy="false">→</mo>
    </mover>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>σ</mi>
    <mover accent="true">
     <mi>v</mi>
     <mo stretchy="false">→</mo>
    </mover>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>𝐌</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>v</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>σ</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>u</ci>
      </apply>
      <mtext>and</mtext>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐌</ci>
       <times></times>
      </apply>
      <apply>
       <ci>normal-→</ci>
       <ci>u</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>σ</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}\vec{v}=\sigma\vec{u}\,\text{ and }\mathbf{M}^{*}\vec{u}=\sigma\vec{v}
  </annotation>
 </semantics>
</math>

</p>

<p>The vectors <em>u</em> and <em>v</em> are called <strong>left-singular</strong> and <strong>right-singular vectors</strong> for 

<math display="inline" id="Singular_value_decomposition:70">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   σ
  </annotation>
 </semantics>
</math>

, respectively.</p>

<p>In any singular value decomposition</p>

<p>

<math display="block" id="Singular_value_decomposition:71">
 <semantics>
  <mrow>
   <mi>𝐌</mi>
   <mo>=</mo>
   <mrow>
    <mi>𝐔</mi>
    <mi>𝚺</mi>
    <msup>
     <mi>𝐕</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐌</ci>
    <apply>
     <times></times>
     <ci>𝐔</ci>
     <ci>𝚺</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐕</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}=\mathbf{U}\boldsymbol{\Sigma}\mathbf{V}^{*}
  </annotation>
 </semantics>
</math>

</p>

<p>the diagonal entries of 

<math display="inline" id="Singular_value_decomposition:72">
 <semantics>
  <mi>𝚺</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚺</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Σ}
  </annotation>
 </semantics>
</math>

 are equal to the singular values of 

<math display="inline" id="Singular_value_decomposition:73">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

. The columns of 

<math display="inline" id="Singular_value_decomposition:74">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Singular_value_decomposition:75">
 <semantics>
  <mi>𝐕</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐕</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}
  </annotation>
 </semantics>
</math>

 are, respectively, left- and right-singular vectors for the corresponding singular values. Consequently, the above theorem implies that:</p>
<ul>
<li>An 

<math display="inline" id="Singular_value_decomposition:76">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m×n
  </annotation>
 </semantics>
</math>

 matrix 

<math display="inline" id="Singular_value_decomposition:77">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 has at most 

<math display="inline" id="Singular_value_decomposition:78">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <mrow>
    <mi>m</mi>
    <mi>i</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>i</ci>
     <ci>n</ci>
     <interval closure="open">
      <ci>m</ci>
      <ci>n</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=min(m,n)
  </annotation>
 </semantics>
</math>

 distinct singular values.</li>
<li>It is always possible to find an <a href="orthogonal_basis" title="wikilink">orthogonal basis</a> 

<math display="inline" id="Singular_value_decomposition:79">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}
  </annotation>
 </semantics>
</math>

 for <mtpl></mtpl> consisting of left-singular vectors of 

<math display="inline" id="Singular_value_decomposition:80">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

.</li>
<li>It is always possible to find an orthogonal basis 

<math display="inline" id="Singular_value_decomposition:81">
 <semantics>
  <mi>𝐕</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐕</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}
  </annotation>
 </semantics>
</math>

 for <mtpl></mtpl> consisting of right-singular vectors of 

<math display="inline" id="Singular_value_decomposition:82">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>A singular value for which we can find two left (or right) singular vectors that are linearly independent is called <em>degenerate</em>.</p>

<p>Non-degenerate singular values always have unique left- and right-singular vectors, up to multiplication by a unit-phase factor <em>e</em><sup><strong>i</strong>φ</sup> (for the real case up to sign). Consequently, if all singular values of 

<math display="inline" id="Singular_value_decomposition:83">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 are non-degenerate and non-zero, then its singular value decomposition is unique, up to multiplication of a column of 

<math display="inline" id="Singular_value_decomposition:84">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}
  </annotation>
 </semantics>
</math>

 by a unit-phase factor and simultaneous multiplication of the corresponding column of 

<math display="inline" id="Singular_value_decomposition:85">
 <semantics>
  <mi>𝐕</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐕</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}
  </annotation>
 </semantics>
</math>

 by the same unit-phase factor.</p>

<p>Degenerate singular values, by definition, have non-unique singular vectors. Furthermore, if <em>u</em><sub>1</sub> and <em>u</em><sub>2</sub> are two left-singular vectors which both correspond to the singular value σ, then any normalized linear combination of the two vectors is also a left-singular vector corresponding to the singular value σ. The similar statement is true for right-singular vectors. Consequently, if 

<math display="inline" id="Singular_value_decomposition:86">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 has degenerate singular values, then its singular value decomposition is not unique.</p>
<h2 id="applications-of-the-svd">Applications of the SVD</h2>
<h3 id="pseudoinverse">Pseudoinverse</h3>

<p>The singular value decomposition can be used for computing the <a href="Moore–Penrose_pseudoinverse" title="wikilink">pseudoinverse</a> of a matrix. Indeed, the pseudoinverse of the matrix 

<math display="inline" id="Singular_value_decomposition:87">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 with singular value decomposition <mtpl> <strong>UΣV</strong><sup>∗</sup>}}</mtpl> is</p>

<p>

<math display="block" id="Singular_value_decomposition:88">
 <semantics>
  <mrow>
   <msup>
    <mi>𝐌</mi>
    <mo>+</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>𝐕</mi>
    <msup>
     <mi>𝚺</mi>
     <mo>+</mo>
    </msup>
    <msup>
     <mi>𝐔</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐌</ci>
     <plus></plus>
    </apply>
    <apply>
     <times></times>
     <ci>𝐕</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝚺</ci>
      <plus></plus>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐔</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}^{+}=\mathbf{V}\boldsymbol{\Sigma}^{+}\mathbf{U}^{*}
  </annotation>
 </semantics>
</math>

</p>

<p>where <mtpl></mtpl> is the pseudoinverse of 

<math display="inline" id="Singular_value_decomposition:89">
 <semantics>
  <mi>𝚺</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚺</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Σ}
  </annotation>
 </semantics>
</math>

, which is formed by replacing every non-zero diagonal entry by its <a href="Multiplicative_inverse" title="wikilink">reciprocal</a> and transposing the resulting matrix. The pseudoinverse is one way to solve <a href="linear_least_squares_(mathematics)" title="wikilink">linear least squares</a> problems.</p>
<h3 id="solving-homogeneous-linear-equations">Solving homogeneous linear equations</h3>

<p>A set of <a href="homogeneous_linear_equation" title="wikilink">homogeneous linear equations</a> can be written as 

<math display="inline" id="Singular_value_decomposition:90">
 <semantics>
  <mrow>
   <mi>𝐀𝐱</mi>
   <mo>=</mo>
   <mn>𝟎</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐀𝐱</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Ax}=\mathbf{0}
  </annotation>
 </semantics>
</math>

 for a matrix 

<math display="inline" id="Singular_value_decomposition:91">
 <semantics>
  <mi>𝐀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

 and vector 

<math display="inline" id="Singular_value_decomposition:92">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

. A typical situation is that 

<math display="inline" id="Singular_value_decomposition:93">
 <semantics>
  <mi>𝐀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

 is known and a non-zero 

<math display="inline" id="Singular_value_decomposition:94">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 is to be determined which satisfies the equation. Such an 

<math display="inline" id="Singular_value_decomposition:95">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 belongs to 

<math display="inline" id="Singular_value_decomposition:96">
 <semantics>
  <mi>𝐀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

's <a href="Kernel_(matrix)" title="wikilink">null space</a> and is sometimes called a (right) null vector of 

<math display="inline" id="Singular_value_decomposition:97">
 <semantics>
  <mi>𝐀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

. The vector 

<math display="inline" id="Singular_value_decomposition:98">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 can be characterized as a right-singular vector corresponding to a singular value of 

<math display="inline" id="Singular_value_decomposition:99">
 <semantics>
  <mi>𝐀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

 that is zero. This observation means that if 

<math display="inline" id="Singular_value_decomposition:100">
 <semantics>
  <mi>𝐀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

 is a <a href="square_matrix" title="wikilink">square matrix</a> and has no vanishing singular value, the equation has no non-zero 

<math display="inline" id="Singular_value_decomposition:101">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 as a solution. It also means that if there are several vanishing singular values, any linear combination of the corresponding right-singular vectors is a valid solution. Analogously to the definition of a (right) null vector, a non-zero 

<math display="inline" id="Singular_value_decomposition:102">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 satisfying <mtpl> <strong>0</strong>}}</mtpl>, with <mtpl></mtpl> denoting the conjugate transpose of 

<math display="inline" id="Singular_value_decomposition:103">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

, is called a left null vector of 

<math display="inline" id="Singular_value_decomposition:104">
 <semantics>
  <mi>𝐀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="total-least-squares-minimization">Total least squares minimization</h3>

<p>A <a href="total_least_squares" title="wikilink">total least squares</a> problem refers to determining the vector 

<math display="inline" id="Singular_value_decomposition:105">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 which minimizes the <a href="Vector_norm#p-norm" title="wikilink">2-norm</a> of a vector 

<math display="inline" id="Singular_value_decomposition:106">
 <semantics>
  <mi>𝐀𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Ax}
  </annotation>
 </semantics>
</math>

 under the constraint 

<math display="inline" id="Singular_value_decomposition:107">
 <semantics>
  <mrow>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mi>𝐱</mi>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <factorial></factorial>
    <factorial></factorial>
    <csymbol cd="unknown">x</csymbol>
    <factorial></factorial>
    <factorial></factorial>
    <eq></eq>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{!!}}\mathbf{x}{{!!}}=1
  </annotation>
 </semantics>
</math>

. The solution turns out to be the right-singular vector of 

<math display="inline" id="Singular_value_decomposition:108">
 <semantics>
  <mi>𝐀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

 corresponding to the smallest singular value.</p>
<h3 id="range-null-space-and-rank">Range, null space and rank</h3>

<p>Another application of the SVD is that it provides an explicit representation of the <a href="Column_space" title="wikilink">range</a> and <a href="null_space" title="wikilink">null space</a> of a matrix 

<math display="inline" id="Singular_value_decomposition:109">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

. The right-singular vectors corresponding to vanishing singular values of 

<math display="inline" id="Singular_value_decomposition:110">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 span the null space of 

<math display="inline" id="Singular_value_decomposition:111">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

. E.g., the null space is spanned by the last two columns of 

<math display="inline" id="Singular_value_decomposition:112">
 <semantics>
  <mi>𝐕</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐕</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}
  </annotation>
 </semantics>
</math>

 in the above example. The left-singular vectors corresponding to the non-zero singular values of 

<math display="inline" id="Singular_value_decomposition:113">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 span the range of 

<math display="inline" id="Singular_value_decomposition:114">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

. As a consequence, the <a href="rank_of_a_matrix" title="wikilink">rank</a> of 

<math display="inline" id="Singular_value_decomposition:115">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 equals the number of non-zero singular values which is the same as the number of non-zero diagonal elements in 

<math display="inline" id="Singular_value_decomposition:116">
 <semantics>
  <mi>𝚺</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚺</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Σ}
  </annotation>
 </semantics>
</math>

.</p>

<p>In numerical linear algebra the singular values can be used to determine the <em>effective rank</em> of a matrix, as <a href="rounding_error" title="wikilink">rounding error</a> may lead to small but non-zero singular values in a rank deficient matrix.</p>
<h3 id="low-rank-matrix-approximation">Low-rank matrix approximation</h3>

<p>Some practical applications need to solve the problem of approximating a matrix 

<math display="inline" id="Singular_value_decomposition:117">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 with another matrix 

<math display="inline" id="Singular_value_decomposition:118">
 <semantics>
  <mover accent="true">
   <mi>𝐌</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>𝐌</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{\mathbf{M}}
  </annotation>
 </semantics>
</math>

, said <a href="#Truncated_SVD" title="wikilink">truncated</a>, which has a specific rank 

<math display="inline" id="Singular_value_decomposition:119">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

. In the case that the approximation is based on minimizing the <a href="Frobenius_norm" title="wikilink">Frobenius norm</a> of the difference between 

<math display="inline" id="Singular_value_decomposition:120">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Singular_value_decomposition:121">
 <semantics>
  <mover accent="true">
   <mi>𝐌</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>𝐌</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{\mathbf{M}}
  </annotation>
 </semantics>
</math>

 under the constraint that 

<math display="inline" id="Singular_value_decomposition:122">
 <semantics>
  <mrow>
   <mrow>
    <mo>rank</mo>
    <mrow>
     <mo>(</mo>
     <mover accent="true">
      <mi>𝐌</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>rank</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>𝐌</ci>
     </apply>
    </apply>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{rank}\left(\tilde{\mathbf{M}}\right)=r
  </annotation>
 </semantics>
</math>

 it turns out that the solution is given by the SVD of 

<math display="inline" id="Singular_value_decomposition:123">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

, namely</p>

<p>

<math display="block" id="Singular_value_decomposition:124">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>𝐌</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mi>𝐔</mi>
    <mover accent="true">
     <mi>𝚺</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <msup>
     <mi>𝐕</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-~</ci>
     <ci>𝐌</ci>
    </apply>
    <apply>
     <times></times>
     <ci>𝐔</ci>
     <apply>
      <ci>normal-~</ci>
      <ci>𝚺</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐕</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{\mathbf{M}}=\mathbf{U}\tilde{\boldsymbol{\Sigma}}\mathbf{V}^{*}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Singular_value_decomposition:125">
 <semantics>
  <mover accent="true">
   <mi>𝚺</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>𝚺</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{\boldsymbol{\Sigma}}
  </annotation>
 </semantics>
</math>

 is the same matrix as 

<math display="inline" id="Singular_value_decomposition:126">
 <semantics>
  <mi>𝚺</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚺</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Σ}
  </annotation>
 </semantics>
</math>

 except that it contains only the 

<math display="inline" id="Singular_value_decomposition:127">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 largest singular values (the other singular values are replaced by zero). This is known as the <strong>Eckart–Young theorem</strong>, as it was proved by those two authors in 1936 (although it was later found to have been known to earlier authors; see ).</p>
<h3 id="separable-models">Separable models</h3>

<p>The SVD can be thought of as decomposing a matrix into a weighted, ordered sum of separable matrices. By separable, we mean that a matrix 

<math display="inline" id="Singular_value_decomposition:128">
 <semantics>
  <mi>𝐀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

 can be written as an <a href="outer_product" title="wikilink">outer product</a> of two vectors 

<math display="inline" id="Singular_value_decomposition:129">
 <semantics>
  <mrow>
   <mi>𝐀</mi>
   <mo>=</mo>
   <mrow>
    <mi>𝐮</mi>
    <mi mathvariant="normal">⊗</mi>
    <mi>𝐯</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐀</ci>
    <apply>
     <times></times>
     <ci>𝐮</ci>
     <ci>normal-⊗</ci>
     <ci>𝐯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}=\mathbf{u}⊗\mathbf{v}
  </annotation>
 </semantics>
</math>

, or, in coordinates, 

<math display="inline" id="Singular_value_decomposition:130">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>u</mi>
     <mi>i</mi>
    </msub>
    <msub>
     <mi>v</mi>
     <mi>j</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{ij}=u_{i}v_{j}
  </annotation>
 </semantics>
</math>

. Specifically, the matrix 

<math display="inline" id="Singular_value_decomposition:131">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 can be decomposed as:</p>

<p>

<math display="block" id="Singular_value_decomposition:132">
 <semantics>
  <mrow>
   <mi>𝐌</mi>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <msub>
     <mi>𝐀</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <mrow>
      <msub>
       <mi>σ</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>𝐔</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>⊗</mo>
     <msubsup>
      <mi>𝐕</mi>
      <mi>i</mi>
      <mo>†</mo>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>𝐌</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐀</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐔</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐕</ci>
         <ci>i</ci>
        </apply>
        <ci>normal-†</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}=\sum_{i}\mathbf{A}_{i}=\sum_{i}\sigma_{i}\mathbf{U}_{i}\otimes%
\mathbf{V}_{i}^{\dagger}
  </annotation>
 </semantics>
</math>

</p>

<p>Here <mtpl></mtpl> and <mtpl></mtpl> are the 

<math display="inline" id="Singular_value_decomposition:133">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th columns of the corresponding SVD matrices, <mtpl></mtpl> are the ordered singular values, and each <mtpl></mtpl> is separable. The SVD can be used to find the decomposition of an image processing filter into separable horizontal and vertical filters. Note that the number of non-zero <mtpl></mtpl> is exactly the rank of the matrix.</p>

<p>Separable models often arise in biological systems, and the SVD decomposition is useful to analyze such systems. For example, some visual area V1 simple cells' receptive fields can be well described<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> by a <a href="Gabor_filter" title="wikilink">Gabor filter</a> in the space domain multiplied by a modulation function in the time domain. Thus, given a linear filter evaluated through, for example, <a href="Spike-triggered_average" title="wikilink">reverse correlation</a>, one can rearrange the two spatial dimensions into one dimension, thus yielding a two-dimensional filter (space, time) which can be decomposed through SVD. The first column of 

<math display="inline" id="Singular_value_decomposition:134">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}
  </annotation>
 </semantics>
</math>

 in the SVD decomposition is then a Gabor while the first column of 

<math display="inline" id="Singular_value_decomposition:135">
 <semantics>
  <mi>𝐕</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐕</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}
  </annotation>
 </semantics>
</math>

 represents the time modulation (or vice versa). One may then define an index of separability,</p>

<p>

<math display="block" id="Singular_value_decomposition:136">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <mo>=</mo>
    <mfrac>
     <msubsup>
      <mi>σ</mi>
      <mn>1</mn>
      <mn>2</mn>
     </msubsup>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mi>i</mi>
      </msub>
      <msubsup>
       <mi>σ</mi>
       <mi>i</mi>
       <mn>2</mn>
      </msubsup>
     </mrow>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>α</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <ci>i</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=\frac{\sigma_{1}^{2}}{\sum_{i}\sigma_{i}^{2}},
  </annotation>
 </semantics>
</math>

</p>

<p>which is the fraction of the power in the matrix M which is accounted for by the first separable matrix in the decomposition.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h3 id="nearest-orthogonal-matrix">Nearest orthogonal matrix</h3>

<p>It is possible to use the SVD of a square matrix 

<math display="inline" id="Singular_value_decomposition:137">
 <semantics>
  <mi>𝐀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

 to determine the <a href="orthogonal_matrix" title="wikilink">orthogonal matrix</a> 

<math display="inline" id="Singular_value_decomposition:138">
 <semantics>
  <mi>𝐎</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐎</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{O}
  </annotation>
 </semantics>
</math>

 closest to 

<math display="inline" id="Singular_value_decomposition:139">
 <semantics>
  <mi>𝐀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

. The closeness of fit is measured by the <a href="Frobenius_norm" title="wikilink">Frobenius norm</a> of 

<math display="inline" id="Singular_value_decomposition:140">
 <semantics>
  <mrow>
   <mi>𝐎</mi>
   <mi mathvariant="normal">−</mi>
   <mi>𝐀</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐎</ci>
    <ci>normal-−</ci>
    <ci>𝐀</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{O}−\mathbf{A}
  </annotation>
 </semantics>
</math>

. The solution is the product <mtpl></mtpl>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> This intuitively makes sense because an orthogonal matrix would have the decomposition <mtpl></mtpl> where 

<math display="inline" id="Singular_value_decomposition:141">
 <semantics>
  <mi>𝐈</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐈</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{I}
  </annotation>
 </semantics>
</math>

 is the identity matrix, so that if <mtpl> <strong>UΣV</strong><sup>∗</sup>}}</mtpl> then the product <mtpl> <strong>UV</strong><sup>∗</sup>}}</mtpl> amounts to replacing the singular values with ones.</p>

<p>A similar problem, with interesting applications in <a href="shape_analysis_(digital_geometry)" title="wikilink">shape analysis</a>, is the <a href="orthogonal_Procrustes_problem" title="wikilink">orthogonal Procrustes problem</a>, which consists of finding an orthogonal matrix 

<math display="inline" id="Singular_value_decomposition:142">
 <semantics>
  <mi>𝐎</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐎</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{O}
  </annotation>
 </semantics>
</math>

 which most closely maps 

<math display="inline" id="Singular_value_decomposition:143">
 <semantics>
  <mi>𝐀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Singular_value_decomposition:144">
 <semantics>
  <mi>𝐁</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐁</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{B}
  </annotation>
 </semantics>
</math>

. Specifically,</p>

<p>

<math display="block" id="Singular_value_decomposition:145">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐎</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>arg</mi>
       <munder>
        <mi>min</mi>
        <mi>𝛀</mi>
       </munder>
      </mrow>
      <msub>
       <mrow>
        <mo>∥</mo>
        <mrow>
         <mrow>
          <mi>𝐀</mi>
          <mi>𝛀</mi>
         </mrow>
         <mo>-</mo>
         <mi>𝐁</mi>
        </mrow>
        <mo>∥</mo>
       </mrow>
       <mi>F</mi>
      </msub>
     </mrow>
     <mrow>
      <mpadded width="+5pt">
       <mi>subject</mi>
      </mpadded>
      <mi>to</mi>
     </mrow>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>𝛀</mi>
      <mi>T</mi>
     </msup>
     <mi>𝛀</mi>
    </mrow>
    <mo>=</mo>
    <mi>𝐈</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>𝐎</ci>
     <list>
      <apply>
       <times></times>
       <apply>
        <arg></arg>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <min></min>
         <ci>𝛀</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <ci>𝐀</ci>
           <ci>𝛀</ci>
          </apply>
          <ci>𝐁</ci>
         </apply>
        </apply>
        <ci>F</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>subject</ci>
       <ci>to</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝛀</ci>
       <ci>T</ci>
      </apply>
      <ci>𝛀</ci>
     </apply>
     <ci>𝐈</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{O}=\arg\min_{\boldsymbol{\Omega}}\|\mathbf{A}\boldsymbol{\Omega}-%
\mathbf{B}\|_{F}\quad\mathrm{subject\ to}\quad\boldsymbol{\Omega}^{T}%
\boldsymbol{\Omega}=\mathbf{I}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Singular_value_decomposition:146">
 <semantics>
  <mrow>
   <mo>∥</mo>
   <mo>⋅</mo>
   <msub>
    <mo>∥</mo>
    <mi>F</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">parallel-to</csymbol>
    <ci>normal-⋅</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">parallel-to</csymbol>
     <ci>F</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\cdot\|_{F}
  </annotation>
 </semantics>
</math>

 denotes the Frobenius norm.</p>

<p>This problem is equivalent to finding the nearest orthogonal matrix to a given matrix <mtpl> <strong>A</strong><sup>T</sup><strong>B</strong>}}</mtpl>.</p>
<h3 id="the-kabsch-algorithm">The Kabsch algorithm</h3>

<p>The <a href="Kabsch_algorithm" title="wikilink">Kabsch algorithm</a> (called <a href="Wahba's_problem" title="wikilink">Wahba's problem</a> in other fields) uses SVD to compute the optimal rotation (with respect to least-squares minimization) that will align a set of points with a corresponding set of points. It is used, among other applications, to compare the structures of molecules.</p>
<h3 id="signal-processing">Signal processing</h3>

<p>The SVD and pseudoinverse have been successfully applied to signal processing and big data, e.g., in genomic signal processing.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="other-examples">Other examples</h3>

<p>The SVD is also applied extensively to the study of linear <a href="inverse_problem" title="wikilink">inverse problems</a>, and is useful in the analysis of regularization methods such as that of <a href="Tikhonov_regularization" title="wikilink">Tikhonov</a>. It is widely used in statistics where it is related to <a href="principal_component_analysis" title="wikilink">principal component analysis</a> and to <a href="Correspondence_analysis" title="wikilink">Correspondence analysis</a>, and in <a href="signal_processing" title="wikilink">signal processing</a> and <a href="pattern_recognition" title="wikilink">pattern recognition</a>. It is also used in output-only <a href="modal_analysis" title="wikilink">modal analysis</a>, where the non-scaled <a href="mode_shape" title="wikilink">mode shapes</a> can be determined from the singular vectors. Yet another usage is <a href="latent_semantic_indexing" title="wikilink">latent semantic indexing</a> in natural language text processing.</p>

<p>SVD is significantly important for solving nonlinear inverse problems where usually a truncated SVD (TSVD) is used as representation of model. An important application is constructing computational models of subsurface oil and gas reservoirs .<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>The SVD also plays a crucial role in the field of <a href="quantum_information" title="wikilink">quantum information</a>, in a form often referred to as the <a href="Schmidt_decomposition" title="wikilink">Schmidt decomposition</a>. Through it, states of two quantum systems are naturally decomposed, providing a necessary and sufficient condition for them to be <a href="Quantum_entanglement" title="wikilink">entangled</a>: if the rank of the 

<math display="inline" id="Singular_value_decomposition:147">
 <semantics>
  <mi>𝚺</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚺</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Σ}
  </annotation>
 </semantics>
</math>

 matrix is larger than one.</p>

<p>One application of SVD to rather large matrices is in <a href="numerical_weather_prediction" title="wikilink">numerical weather prediction</a>, where <a href="Lanczos_algorithm" title="wikilink">Lanczos methods</a> are used to estimate the most linearly quickly growing few perturbations to the central numerical weather prediction over a given initial forward time period; i.e., the singular vectors corresponding to the largest singular values of the linearized propagator for the global weather over that time interval. The output singular vectors in this case are entire weather systems. These perturbations are then run through the full nonlinear model to generate an <a href="ensemble_forecasting" title="wikilink">ensemble forecast</a>, giving a handle on some of the uncertainty that should be allowed for around the current central prediction.</p>

<p>SVD has also been applied to reduced order modelling. The aim of reduced order modelling is to reduce the number of degrees of freedom in a complex system which is to be modelled. SVD was coupled with <a href="radial_basis_functions" title="wikilink">radial basis functions</a> to interpolate solutions to three-dimensional unsteady flow problems.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>Singular value decomposition is used in <a href="recommender_systems" title="wikilink">recommender systems</a> to predict people's item ratings.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Distributed algorithms have been developed for the purpose of calculating the SVD on clusters of commodity machines.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>Low-rank SVD has been applied for hotspot detection from spatiotemporal data with application to disease <a class="uri" href="outbreak" title="wikilink">outbreak</a> detection .<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> A combination of SVD and <a href="Higher-order_singular_value_decomposition" title="wikilink">higher-order SVD</a> also has been applied for real time event detection from complex data streams (multivariate data with space and time dimensions) in <a href="Disease_surveillance" title="wikilink">Disease surveillance</a>.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="relation-to-eigenvalue-decomposition">Relation to eigenvalue decomposition</h2>

<p>The singular value decomposition is very general in the sense that it can be applied to any 

<math display="inline" id="Singular_value_decomposition:148">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m×n
  </annotation>
 </semantics>
</math>

 matrix whereas <a href="eigenvalue_decomposition" title="wikilink">eigenvalue decomposition</a> can only be applied to certain classes of square matrices. Nevertheless, the two decompositions are related.</p>

<p>Given an SVD of 

<math display="inline" id="Singular_value_decomposition:149">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

, as described above, the following two relations hold:</p>

<p>

<math display="inline" id="Singular_value_decomposition:150">
 <semantics>
  <mrow>
   <msup>
    <mi>𝐌</mi>
    <mo>*</mo>
   </msup>
   <mi>𝐌</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐌</ci>
     <times></times>
    </apply>
    <ci>𝐌</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\mathbf{M}^{*}\mathbf{M}
  </annotation>
 </semantics>
</math>


</p>

<p>The right-hand sides of these relations describe the eigenvalue decompositions of the left-hand sides. Consequently:</p>

<p>:* The columns of 

<math display="inline" id="Singular_value_decomposition:151">
 <semantics>
  <mi>𝐕</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐕</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}
  </annotation>
 </semantics>
</math>

 (right-singular vectors) are <a class="uri" href="eigenvectors" title="wikilink">eigenvectors</a> of <mtpl></mtpl>.</p>

<p>:* The columns of 

<math display="inline" id="Singular_value_decomposition:152">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}
  </annotation>
 </semantics>
</math>

 (left-singular vectors) are eigenvectors of <mtpl></mtpl>.</p>

<p>:* The non-zero elements of 

<math display="inline" id="Singular_value_decomposition:153">
 <semantics>
  <mi>𝚺</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚺</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Σ}
  </annotation>
 </semantics>
</math>

 (non-zero singular values) are the square roots of the non-zero <a class="uri" href="eigenvalues" title="wikilink">eigenvalues</a> of <mtpl></mtpl> or <mtpl></mtpl>.</p>

<p>In the special case that 

<math display="inline" id="Singular_value_decomposition:154">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 is a <a href="normal_matrix" title="wikilink">normal matrix</a>, which by definition must be square, the <a href="Spectral_theorem#Finite-dimensional_case" title="wikilink">spectral theorem</a> says that it can be <a href="Unitary_transform" title="wikilink">unitarily</a> <a href="Diagonalizable_matrix" title="wikilink">diagonalized</a> using a basis of <a href="eigenvector" title="wikilink">eigenvectors</a>, so that it can be written <mtpl> <strong>UDU</strong><sup>∗</sup>}}</mtpl> for a unitary matrix 

<math display="inline" id="Singular_value_decomposition:155">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}
  </annotation>
 </semantics>
</math>

 and a diagonal matrix 

<math display="inline" id="Singular_value_decomposition:156">
 <semantics>
  <mi>𝐃</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐃</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{D}
  </annotation>
 </semantics>
</math>

. When 

<math display="inline" id="Singular_value_decomposition:157">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 is also <a href="Positive-definite_matrix" title="wikilink">positive semi-definite</a>, the decomposition <mtpl> <strong>UDU</strong><sup>∗</sup>}}</mtpl> is also a singular value decomposition.</p>

<p>However, the eigenvalue decomposition and the singular value decomposition differ for all other matrices 

<math display="inline" id="Singular_value_decomposition:158">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

: the eigenvalue decomposition is <mtpl> <strong>UDU</strong><sup>−1</sup>}}</mtpl> where 

<math display="inline" id="Singular_value_decomposition:159">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}
  </annotation>
 </semantics>
</math>

 is not necessarily unitary and 

<math display="inline" id="Singular_value_decomposition:160">
 <semantics>
  <mi>𝐃</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐃</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{D}
  </annotation>
 </semantics>
</math>

 is not necessarily positive semi-definite, while the SVD is <mtpl> <strong>UΣV</strong><sup>∗</sup>}}</mtpl> where 

<math display="inline" id="Singular_value_decomposition:161">
 <semantics>
  <mi>𝚺</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚺</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Σ}
  </annotation>
 </semantics>
</math>

 is a diagonal positive semi-definite, and 

<math display="inline" id="Singular_value_decomposition:162">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Singular_value_decomposition:163">
 <semantics>
  <mi>𝐕</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐕</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}
  </annotation>
 </semantics>
</math>

 are unitary matrices that are not necessarily related except through the matrix 

<math display="inline" id="Singular_value_decomposition:164">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="existence">Existence</h2>

<p>An eigenvalue 

<math display="inline" id="Singular_value_decomposition:165">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 of a matrix 

<math display="inline" id="Singular_value_decomposition:166">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 is characterized by the algebraic relation 

<math display="inline" id="Singular_value_decomposition:167">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐌</mi>
    <mi>u</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>λ</mi>
    <mi>u</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝐌</ci>
     <ci>u</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}u=λu
  </annotation>
 </semantics>
</math>

. When 

<math display="inline" id="Singular_value_decomposition:168">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 is <a href="Hermitian_matrix" title="wikilink">Hermitian</a>, a variational characterization is also available. Let 

<math display="inline" id="Singular_value_decomposition:169">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 be a real 

<math display="inline" id="Singular_value_decomposition:170">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n×n
  </annotation>
 </semantics>
</math>

 <a href="symmetric_matrix" title="wikilink">symmetric matrix</a>. Define</p>

<p>

<math display="block" id="Singular_value_decomposition:171">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mi>f</mi>
       <mo>:</mo>
       <mrow>
        <msup>
         <mi>𝐑</mi>
         <mi>n</mi>
        </msup>
        <mo>→</mo>
        <mi>𝐑</mi>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mrow>
        <msup>
         <mi>x</mi>
         <mi>T</mi>
        </msup>
        <mi>𝐌</mi>
        <mi>x</mi>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
   </mtable>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">cases</csymbol>
    <apply>
     <ci>normal-:</ci>
     <ci>f</ci>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐑</ci>
       <ci>n</ci>
      </apply>
      <ci>𝐑</ci>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>T</ci>
      </apply>
      <ci>𝐌</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{cases}f:\mathbf{R}^{n}\to\mathbf{R}\\
f(x)=x^{T}\mathbf{M}x\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>By the <a href="extreme_value_theorem" title="wikilink">extreme value theorem</a>, this continuous function attains a maximum at some <em>u</em> when restricted to the closed unit sphere {||<em>x</em>|| ≤ 1}. By the <a href="Lagrange_multipliers" title="wikilink">Lagrange multipliers</a> theorem, <em>u</em> necessarily satisfies</p>

<p>

<math display="block" id="Singular_value_decomposition:172">
 <semantics>
  <mrow>
   <mrow>
    <mo>∇</mo>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>∇</mo>
    <mrow>
     <msup>
      <mi>x</mi>
      <mi>T</mi>
     </msup>
     <mi>𝐌</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>λ</mi>
    <mo>⋅</mo>
    <mrow>
     <mo>∇</mo>
     <mrow>
      <msup>
       <mi>x</mi>
       <mi>T</mi>
      </msup>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-∇</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <ci>normal-∇</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>T</ci>
       </apply>
       <ci>𝐌</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <ci>λ</ci>
      <apply>
       <ci>normal-∇</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <ci>T</ci>
        </apply>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla f=\nabla x^{T}\mathbf{M}x=\lambda\cdot\nabla x^{T}x
  </annotation>
 </semantics>
</math>

</p>

<p>where the nabla symbol, 

<math display="inline" id="Singular_value_decomposition:173">
 <semantics>
  <mi mathvariant="normal">∇</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-∇</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ∇
  </annotation>
 </semantics>
</math>

, is the <a class="uri" href="del" title="wikilink">del</a> operator.</p>

<p>A short calculation shows the above leads to 

<math display="inline" id="Singular_value_decomposition:174">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐌</mi>
    <mi>u</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>λ</mi>
    <mi>u</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝐌</ci>
     <ci>u</ci>
    </apply>
    <apply>
     <times></times>
     <ci>λ</ci>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}u=λu
  </annotation>
 </semantics>
</math>

 (symmetry of 

<math display="inline" id="Singular_value_decomposition:175">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 is needed here). Therefore 

<math display="inline" id="Singular_value_decomposition:176">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 is the largest eigenvalue of 

<math display="inline" id="Singular_value_decomposition:177">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

. The same calculation performed on the orthogonal complement of <em>u</em> gives the next largest eigenvalue and so on. The complex Hermitian case is similar; there <em>f</em>(<em>x</em>) = <em>x* M x</em> is a real-valued function of 

<math display="inline" id="Singular_value_decomposition:178">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2n
  </annotation>
 </semantics>
</math>

 real variables.</p>

<p>Singular values are similar in that they can be described algebraically or from variational principles. Although, unlike the eigenvalue case, Hermiticity, or symmetry, of 

<math display="inline" id="Singular_value_decomposition:179">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 is no longer required.</p>

<p>This section gives these two arguments for existence of singular value decomposition.</p>
<h3 id="based-on-the-spectral-theorem">Based on the spectral theorem</h3>

<p>Let 

<math display="inline" id="Singular_value_decomposition:180">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 be an 

<math display="inline" id="Singular_value_decomposition:181">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m×n
  </annotation>
 </semantics>
</math>

 complex matrix. Since <mtpl></mtpl> is positive semi-definite and Hermitian, by the <a href="spectral_theorem" title="wikilink">spectral theorem</a>, there exists a unitary 

<math display="inline" id="Singular_value_decomposition:182">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n×n
  </annotation>
 </semantics>
</math>

 matrix 

<math display="inline" id="Singular_value_decomposition:183">
 <semantics>
  <mi>𝐕</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐕</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}
  </annotation>
 </semantics>
</math>

 such that</p>

<p>

<math display="block" id="Singular_value_decomposition:184">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>𝐕</mi>
     <mo>*</mo>
    </msup>
    <msup>
     <mi>𝐌</mi>
     <mo>*</mo>
    </msup>
    <mi>𝐌𝐕</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mi>𝐃</mi>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐕</ci>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐌</ci>
      <times></times>
     </apply>
     <ci>𝐌𝐕</ci>
    </apply>
    <matrix>
     <matrixrow>
      <ci>𝐃</ci>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}^{*}\mathbf{M}^{*}\mathbf{M}\mathbf{V}=\begin{bmatrix}\mathbf{D}&0\\
0&0\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Singular_value_decomposition:185">
 <semantics>
  <mi>𝐃</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐃</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{D}
  </annotation>
 </semantics>
</math>

 is diagonal and positive definite. Partition 

<math display="inline" id="Singular_value_decomposition:186">
 <semantics>
  <mi>𝐕</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐕</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}
  </annotation>
 </semantics>
</math>

 appropriately so we can write</p>

<p>

<math display="block" id="Singular_value_decomposition:187">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msubsup>
         <mi>𝐕</mi>
         <mn>1</mn>
         <mo>*</mo>
        </msubsup>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msubsup>
         <mi>𝐕</mi>
         <mn>2</mn>
         <mo>*</mo>
        </msubsup>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <msup>
     <mi>𝐌</mi>
     <mo>*</mo>
    </msup>
    <mi>𝐌</mi>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>𝐕</mi>
         <mn>1</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>𝐕</mi>
         <mn>2</mn>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msubsup>
         <mi>𝐕</mi>
         <mn>1</mn>
         <mo>*</mo>
        </msubsup>
        <msup>
         <mi>𝐌</mi>
         <mo>*</mo>
        </msup>
        <msub>
         <mi>𝐌𝐕</mi>
         <mn>1</mn>
        </msub>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <msubsup>
         <mi>𝐕</mi>
         <mn>1</mn>
         <mo>*</mo>
        </msubsup>
        <msup>
         <mi>𝐌</mi>
         <mo>*</mo>
        </msup>
        <msub>
         <mi>𝐌𝐕</mi>
         <mn>2</mn>
        </msub>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msubsup>
         <mi>𝐕</mi>
         <mn>2</mn>
         <mo>*</mo>
        </msubsup>
        <msup>
         <mi>𝐌</mi>
         <mo>*</mo>
        </msup>
        <msub>
         <mi>𝐌𝐕</mi>
         <mn>1</mn>
        </msub>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <msubsup>
         <mi>𝐕</mi>
         <mn>2</mn>
         <mo>*</mo>
        </msubsup>
        <msup>
         <mi>𝐌</mi>
         <mo>*</mo>
        </msup>
        <msub>
         <mi>𝐌𝐕</mi>
         <mn>2</mn>
        </msub>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mi>𝐃</mi>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐕</ci>
          <cn type="integer">1</cn>
         </apply>
         <times></times>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐕</ci>
          <cn type="integer">2</cn>
         </apply>
         <times></times>
        </apply>
       </matrixrow>
      </matrix>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐌</ci>
       <times></times>
      </apply>
      <ci>𝐌</ci>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐕</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐕</ci>
         <cn type="integer">2</cn>
        </apply>
       </matrixrow>
      </matrix>
     </apply>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐕</ci>
          <cn type="integer">1</cn>
         </apply>
         <times></times>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝐌</ci>
         <times></times>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐌𝐕</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐕</ci>
          <cn type="integer">1</cn>
         </apply>
         <times></times>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝐌</ci>
         <times></times>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐌𝐕</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐕</ci>
          <cn type="integer">2</cn>
         </apply>
         <times></times>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝐌</ci>
         <times></times>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐌𝐕</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐕</ci>
          <cn type="integer">2</cn>
         </apply>
         <times></times>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝐌</ci>
         <times></times>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐌𝐕</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <ci>𝐃</ci>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}\mathbf{V}_{1}^{*}\\
\mathbf{V}_{2}^{*}\end{bmatrix}\mathbf{M}^{*}\mathbf{M}\begin{bmatrix}\mathbf{%
V}_{1}&\mathbf{V}_{2}\end{bmatrix}=\begin{bmatrix}\mathbf{V}_{1}^{*}\mathbf{M}%
^{*}\mathbf{M}\mathbf{V}_{1}&\mathbf{V}_{1}^{*}\mathbf{M}^{*}\mathbf{M}\mathbf%
{V}_{2}\\
\mathbf{V}_{2}^{*}\mathbf{M}^{*}\mathbf{M}\mathbf{V}_{1}&\mathbf{V}_{2}^{*}%
\mathbf{M}^{*}\mathbf{M}\mathbf{V}_{2}\end{bmatrix}=\begin{bmatrix}\mathbf{D}&%
0\\
0&0\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore:</p>

<p>

<math display="block" id="Singular_value_decomposition:188">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>𝐕</mi>
      <mn>1</mn>
      <mo>*</mo>
     </msubsup>
     <msup>
      <mi>𝐌</mi>
      <mo>*</mo>
     </msup>
     <msub>
      <mi>𝐌𝐕</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>=</mo>
    <mi>𝐃</mi>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mi>𝐕</mi>
      <mn>2</mn>
      <mo>*</mo>
     </msubsup>
     <msup>
      <mi>𝐌</mi>
      <mo>*</mo>
     </msup>
     <msub>
      <mi>𝐌𝐕</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>=</mo>
    <mn>0.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐕</ci>
        <cn type="integer">1</cn>
       </apply>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐌</ci>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐌𝐕</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>𝐃</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐕</ci>
        <cn type="integer">2</cn>
       </apply>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐌</ci>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐌𝐕</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}_{1}^{*}\mathbf{M}^{*}\mathbf{M}\mathbf{V}_{1}=\mathbf{D},\qquad%
\mathbf{V}_{2}^{*}\mathbf{M}^{*}\mathbf{M}\mathbf{V}_{2}=\mathbf{0}.
  </annotation>
 </semantics>
</math>

</p>

<p>The second equation implies <mtpl> <strong>0</strong>}}</mtpl>. Also, since 

<math display="inline" id="Singular_value_decomposition:189">
 <semantics>
  <mi>𝐕</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐕</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}
  </annotation>
 </semantics>
</math>

 is unitary:</p>

<p>

<math display="inline" id="Singular_value_decomposition:190">
 <semantics>
  <mrow>
   <msubsup>
    <mi>𝐕</mi>
    <mn>1</mn>
    <mo>*</mo>
   </msubsup>
   <msub>
    <mi>𝐕</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐕</ci>
      <cn type="integer">1</cn>
     </apply>
     <times></times>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐕</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\mathbf{V}_{1}^{*}\mathbf{V}_{1}
  </annotation>
 </semantics>
</math>


</p>

<p>where the subscripts on the identity matrices are there to keep in mind that they are of different dimensions. Define</p>

<p>

<math display="block" id="Singular_value_decomposition:191">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐔</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐌𝐕</mi>
     <mn>1</mn>
    </msub>
    <msup>
     <mi>𝐃</mi>
     <mrow>
      <mo>-</mo>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐔</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐌𝐕</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐃</ci>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}_{1}=\mathbf{M}\mathbf{V}_{1}\mathbf{D}^{-\frac{1}{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>Then</p>

<p>

<math display="block" id="Singular_value_decomposition:192">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐔</mi>
     <mn>1</mn>
    </msub>
    <msup>
     <mi>𝐃</mi>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
    </msup>
    <msubsup>
     <mi>𝐕</mi>
     <mn>1</mn>
     <mo>*</mo>
    </msubsup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐌𝐕</mi>
     <mn>1</mn>
    </msub>
    <msup>
     <mi>𝐃</mi>
     <mrow>
      <mo>-</mo>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </mrow>
    </msup>
    <msup>
     <mi>𝐃</mi>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
    </msup>
    <msubsup>
     <mi>𝐕</mi>
     <mn>1</mn>
     <mo>*</mo>
    </msubsup>
   </mrow>
   <mo>=</mo>
   <mi>𝐌</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐔</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐃</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐕</ci>
        <cn type="integer">1</cn>
       </apply>
       <times></times>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐌𝐕</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐃</ci>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐃</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐕</ci>
        <cn type="integer">1</cn>
       </apply>
       <times></times>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>𝐌</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}_{1}\mathbf{D}^{\frac{1}{2}}\mathbf{V}_{1}^{*}=\mathbf{M}\mathbf{V}_%
{1}\mathbf{D}^{-\frac{1}{2}}\mathbf{D}^{\frac{1}{2}}\mathbf{V}_{1}^{*}=\mathbf%
{M}
  </annotation>
 </semantics>
</math>

</p>

<p>We see that this is almost the desired result, except that <mtpl></mtpl> and <mtpl></mtpl> are not unitary in general since they might not be square. However, we do know that for <mtpl></mtpl>, the number of rows is greater than the number of columns since the dimensions of 

<math display="inline" id="Singular_value_decomposition:193">
 <semantics>
  <mi>𝐃</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐃</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{D}
  </annotation>
 </semantics>
</math>

 is no greater than 

<math display="inline" id="Singular_value_decomposition:194">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Singular_value_decomposition:195">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. Also, since</p>

<p>

<math display="block" id="Singular_value_decomposition:196">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>𝐔</mi>
     <mn>1</mn>
     <mo>*</mo>
    </msubsup>
    <msub>
     <mi>𝐔</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>𝐃</mi>
     <mrow>
      <mo>-</mo>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </mrow>
    </msup>
    <msubsup>
     <mi>𝐕</mi>
     <mn>1</mn>
     <mo>*</mo>
    </msubsup>
    <msup>
     <mi>𝐌</mi>
     <mo>*</mo>
    </msup>
    <msub>
     <mi>𝐌𝐕</mi>
     <mn>1</mn>
    </msub>
    <msup>
     <mi>𝐃</mi>
     <mrow>
      <mo>-</mo>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </mrow>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>𝐃</mi>
     <mrow>
      <mo>-</mo>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </mrow>
    </msup>
    <msup>
     <mi>𝐃𝐃</mi>
     <mrow>
      <mo>-</mo>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </mrow>
    </msup>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>𝐈</mi>
    <mn>𝟏</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐔</ci>
        <cn type="integer">1</cn>
       </apply>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐔</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐃</ci>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐕</ci>
        <cn type="integer">1</cn>
       </apply>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐌</ci>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐌𝐕</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐃</ci>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐃</ci>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐃𝐃</ci>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐈</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}_{1}^{*}\mathbf{U}_{1}=\mathbf{D}^{-\frac{1}{2}}\mathbf{V}_{1}^{*}%
\mathbf{M}^{*}\mathbf{M}\mathbf{V}_{1}\mathbf{D}^{-\frac{1}{2}}=\mathbf{D}^{-%
\frac{1}{2}}\mathbf{D}\mathbf{D}^{-\frac{1}{2}}=\mathbf{I_{1}}
  </annotation>
 </semantics>
</math>

</p>

<p>the columns in <mtpl></mtpl> are orthonormal and can be extended to an orthonormal basis. This means, we can choose <mtpl></mtpl> such that the following matrix is unitary:</p>

<p>

<math display="block" id="Singular_value_decomposition:197">
 <semantics>
  <mrow>
   <mi>𝐔</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>𝐔</mi>
        <mn>1</mn>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>𝐔</mi>
        <mn>2</mn>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐔</ci>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐔</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐔</ci>
       <cn type="integer">2</cn>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}=\begin{bmatrix}\mathbf{U}_{1}&\mathbf{U}_{2}\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>For <mtpl></mtpl> we already have <mtpl></mtpl> to make it unitary. Now, define</p>

<p>

<math display="block" id="Singular_value_decomposition:198">
 <semantics>
  <mrow>
   <mi>𝚺</mi>
   <mo>=</mo>
   <mrow>
    <mo>[</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mo>[</mo>
        <mtable displaystyle="true">
         <mtr>
          <mtd columnalign="center">
           <msup>
            <mi>𝐃</mi>
            <mfrac>
             <mn>1</mn>
             <mn>2</mn>
            </mfrac>
           </msup>
          </mtd>
          <mtd columnalign="center">
           <mn>0</mn>
          </mtd>
         </mtr>
         <mtr>
          <mtd columnalign="center">
           <mn>0</mn>
          </mtd>
          <mtd columnalign="center">
           <mn>0</mn>
          </mtd>
         </mtr>
        </mtable>
        <mo>]</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝚺</ci>
    <matrix>
     <matrixrow>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝐃</ci>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\Sigma}=\begin{bmatrix}\begin{bmatrix}\mathbf{D}^{\frac{1}{2}}&0\\
0&0\end{bmatrix}\\
0\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>where extra zero rows are added <strong>or removed</strong> to make the number of zero rows equal the number of columns of <mtpl></mtpl>. Then</p>

<p>

<math display="block" id="Singular_value_decomposition:199">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>𝐔</mi>
         <mn>1</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>𝐔</mi>
         <mn>2</mn>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>[</mo>
         <mtable displaystyle="true">
          <mtr>
           <mtd columnalign="center">
            <msup>
             <mi>D</mi>
             <mfrac>
              <mn>1</mn>
              <mn>2</mn>
             </mfrac>
            </msup>
           </mtd>
           <mtd columnalign="center">
            <mn>0</mn>
           </mtd>
          </mtr>
          <mtr>
           <mtd columnalign="center">
            <mn>0</mn>
           </mtd>
           <mtd columnalign="center">
            <mn>0</mn>
           </mtd>
          </mtr>
         </mtable>
         <mo>]</mo>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <msup>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>𝐕</mi>
          <mn>1</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>𝐕</mi>
          <mn>2</mn>
         </msub>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
     <mo>*</mo>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>𝐔</mi>
         <mn>1</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>𝐔</mi>
         <mn>2</mn>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <msup>
          <mi>𝐃</mi>
          <mfrac>
           <mn>1</mn>
           <mn>2</mn>
          </mfrac>
         </msup>
         <msubsup>
          <mi>𝐕</mi>
          <mn>1</mn>
          <mo>*</mo>
         </msubsup>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐔</mi>
     <mn>1</mn>
    </msub>
    <msup>
     <mi>𝐃</mi>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
    </msup>
    <msubsup>
     <mi>𝐕</mi>
     <mn>1</mn>
     <mo>*</mo>
    </msubsup>
   </mrow>
   <mo>=</mo>
   <mi>𝐌</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐔</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐔</ci>
         <cn type="integer">2</cn>
        </apply>
       </matrixrow>
      </matrix>
      <matrix>
       <matrixrow>
        <matrix>
         <matrixrow>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>D</ci>
           <apply>
            <divide></divide>
            <cn type="integer">1</cn>
            <cn type="integer">2</cn>
           </apply>
          </apply>
          <cn type="integer">0</cn>
         </matrixrow>
         <matrixrow>
          <cn type="integer">0</cn>
          <cn type="integer">0</cn>
         </matrixrow>
        </matrix>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <matrix>
        <matrixrow>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐕</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐕</ci>
          <cn type="integer">2</cn>
         </apply>
        </matrixrow>
       </matrix>
       <times></times>
      </apply>
     </apply>
     <apply>
      <times></times>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐔</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐔</ci>
         <cn type="integer">2</cn>
        </apply>
       </matrixrow>
      </matrix>
      <matrix>
       <matrixrow>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>𝐃</ci>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <cn type="integer">2</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐕</ci>
           <cn type="integer">1</cn>
          </apply>
          <times></times>
         </apply>
        </apply>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐔</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐃</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐕</ci>
        <cn type="integer">1</cn>
       </apply>
       <times></times>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>𝐌</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}\mathbf{U}_{1}&\mathbf{U}_{2}\end{bmatrix}\begin{bmatrix}\begin%
{bmatrix}\mathbf{}D^{\frac{1}{2}}&0\\
0&0\end{bmatrix}\\
0\end{bmatrix}\begin{bmatrix}\mathbf{V}_{1}&\mathbf{V}_{2}\end{bmatrix}^{*}=%
\begin{bmatrix}\mathbf{U}_{1}&\mathbf{U}_{2}\end{bmatrix}\begin{bmatrix}%
\mathbf{D}^{\frac{1}{2}}\mathbf{V}_{1}^{*}\\
0\end{bmatrix}=\mathbf{U}_{1}\mathbf{D}^{\frac{1}{2}}\mathbf{V}_{1}^{*}=%
\mathbf{M}
  </annotation>
 </semantics>
</math>

</p>

<p>which is the desired result:</p>

<p>

<math display="block" id="Singular_value_decomposition:200">
 <semantics>
  <mrow>
   <mi>𝐌</mi>
   <mo>=</mo>
   <mrow>
    <mi>𝐔</mi>
    <mi>𝚺</mi>
    <msup>
     <mi>𝐕</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐌</ci>
    <apply>
     <times></times>
     <ci>𝐔</ci>
     <ci>𝚺</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐕</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}=\mathbf{U}\boldsymbol{\Sigma}\mathbf{V}^{*}
  </annotation>
 </semantics>
</math>

</p>

<p>Notice the argument could begin with diagonalizing <mtpl></mtpl> rather than <mtpl></mtpl> (This shows directly that <mtpl></mtpl> and <mtpl></mtpl> have the same non-zero eigenvalues).</p>
<h3 id="based-on-variational-characterization">Based on variational characterization</h3>

<p>The singular values can also be characterized as the maxima of <mtpl></mtpl>, considered as a function of 

<math display="inline" id="Singular_value_decomposition:201">
 <semantics>
  <mi>𝐮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Singular_value_decomposition:202">
 <semantics>
  <mi>𝐯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{v}
  </annotation>
 </semantics>
</math>

, over particular subspaces. The singular vectors are the values of 

<math display="inline" id="Singular_value_decomposition:203">
 <semantics>
  <mi>𝐮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Singular_value_decomposition:204">
 <semantics>
  <mi>𝐯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{v}
  </annotation>
 </semantics>
</math>

 where these maxima are attained.</p>

<p>Let 

<math display="inline" id="Singular_value_decomposition:205">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 denote an 

<math display="inline" id="Singular_value_decomposition:206">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m×n
  </annotation>
 </semantics>
</math>

 matrix with real entries. Let <mtpl></mtpl> and <mtpl></mtpl> denote the sets of unit 2-norm vectors in <mtpl></mtpl> and <mtpl></mtpl> respectively. Define the function</p>

<p>

<math display="block" id="Singular_value_decomposition:207">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>𝐮</mi>
       <mo>,</mo>
       <mi>𝐯</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msup>
       <mi>𝐮</mi>
       <mi>T</mi>
      </msup>
      <mi>𝐌𝐯</mi>
     </mrow>
    </mrow>
    <mo rspace="22.5pt">,</mo>
    <mrow>
     <mrow>
      <mi>𝐮</mi>
      <mo>∈</mo>
      <msup>
       <mi>S</mi>
       <mrow>
        <mi>m</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>𝐯</mi>
      <mo>∈</mo>
      <msup>
       <mi>S</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>σ</ci>
      <interval closure="open">
       <ci>𝐮</ci>
       <ci>𝐯</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐮</ci>
       <ci>T</ci>
      </apply>
      <ci>𝐌𝐯</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>𝐮</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <in></in>
      <ci>𝐯</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(\mathbf{u},\mathbf{v})=\mathbf{u}^{T}\mathbf{M}\mathbf{v},\qquad\mathbf%
{u}\in S^{m-1},\mathbf{v}\in S^{n-1}.
  </annotation>
 </semantics>
</math>

</p>

<p>Consider the function 

<math display="inline" id="Singular_value_decomposition:208">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   σ
  </annotation>
 </semantics>
</math>

 restricted to <mtpl></mtpl>. Since both <mtpl></mtpl> and <mtpl></mtpl> are <a href="compact_space" title="wikilink">compact</a> sets, their <a href="Product_topology" title="wikilink">product</a> is also compact. Furthermore, since 

<math display="inline" id="Singular_value_decomposition:209">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   σ
  </annotation>
 </semantics>
</math>

 is continuous, it attains a largest value for at least one pair of vectors <mtpl></mtpl> and <mtpl></mtpl>. This largest value is denoted <mtpl></mtpl> and the corresponding vectors are denoted <mtpl></mtpl> and <mtpl></mtpl>. Since <mtpl></mtpl> is the largest value of 

<math display="inline" id="Singular_value_decomposition:210">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐮</mi>
    <mo>,</mo>
    <mi>𝐯</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>σ</ci>
    <interval closure="open">
     <ci>𝐮</ci>
     <ci>𝐯</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   σ(\mathbf{u},\mathbf{v})
  </annotation>
 </semantics>
</math>

 it must be non-negative. If it were negative, changing the sign of either <mtpl></mtpl> or <mtpl></mtpl> would make it positive and therefore larger.</p>
<dl>
<dd><strong>Statement.</strong> <mtpl></mtpl> are left and right-singular vectors of 

<math display="inline" id="Singular_value_decomposition:211">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 with corresponding singular value <em>σ</em><sub>1</sub>.
</dd>
</dl>

<p><strong>Proof:</strong> Similar to the eigenvalues case, by assumption the two vectors satisfy the Lagrange multiplier equation:</p>

<p>

<math display="block" id="Singular_value_decomposition:212">
 <semantics>
  <mrow>
   <mrow>
    <mo>∇</mo>
    <mi>σ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>∇</mo>
     <mrow>
      <msup>
       <mi>𝐮</mi>
       <mi>T</mi>
      </msup>
      <mi>𝐌𝐯</mi>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>λ</mi>
      <mn>1</mn>
     </msub>
     <mo>⋅</mo>
     <mrow>
      <mo>∇</mo>
      <mrow>
       <msup>
        <mi>𝐮</mi>
        <mi>T</mi>
       </msup>
       <mi>𝐮</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>λ</mi>
      <mn>2</mn>
     </msub>
     <mo>⋅</mo>
     <mrow>
      <mo>∇</mo>
      <mrow>
       <msup>
        <mi>𝐯</mi>
        <mi>T</mi>
       </msup>
       <mi>𝐯</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-∇</ci>
     <ci>σ</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-∇</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐮</ci>
        <ci>T</ci>
       </apply>
       <ci>𝐌𝐯</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <ci>normal-∇</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝐮</ci>
         <ci>T</ci>
        </apply>
        <ci>𝐮</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <ci>normal-∇</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝐯</ci>
         <ci>T</ci>
        </apply>
        <ci>𝐯</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla\sigma=\nabla\mathbf{u}^{T}\mathbf{M}\mathbf{v}-\lambda_{1}\cdot\nabla%
\mathbf{u}^{T}\mathbf{u}-\lambda_{2}\cdot\nabla\mathbf{v}^{T}\mathbf{v}
  </annotation>
 </semantics>
</math>

</p>

<p>After some algebra, this becomes</p>

<p>

<math display="inline" id="Singular_value_decomposition:213">
 <semantics>
  <msub>
   <mi>𝐌𝐯</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐌𝐯</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\mathbf{M}\mathbf{v}_{1}
  </annotation>
 </semantics>
</math>


</p>

<p>Multiplying the first equation from left by 

<math display="inline" id="Singular_value_decomposition:214">
 <semantics>
  <msubsup>
   <mi>𝐮</mi>
   <mn>1</mn>
   <mi>T</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐮</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}_{1}^{T}
  </annotation>
 </semantics>
</math>

 and the second equation from left by 

<math display="inline" id="Singular_value_decomposition:215">
 <semantics>
  <msubsup>
   <mi>𝐯</mi>
   <mn>1</mn>
   <mi>T</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐯</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{v}_{1}^{T}
  </annotation>
 </semantics>
</math>


 and taking 

<math display="inline" id="Singular_value_decomposition:216">
 <semantics>
  <mrow>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mi>𝐮</mi>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mo>=</mo>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mi>𝐯</mi>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <factorial></factorial>
    <factorial></factorial>
    <csymbol cd="unknown">u</csymbol>
    <factorial></factorial>
    <factorial></factorial>
    <eq></eq>
    <factorial></factorial>
    <factorial></factorial>
    <csymbol cd="unknown">v</csymbol>
    <factorial></factorial>
    <factorial></factorial>
    <eq></eq>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{!!}}\mathbf{u}{{!!}}={{!!}}\mathbf{v}{{!!}}=1
  </annotation>
 </semantics>
</math>

 into account gives</p>

<p>

<math display="block" id="Singular_value_decomposition:217">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>σ</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mn>2</mn>
     <msub>
      <mi>λ</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>2</mn>
     <msub>
      <mi>λ</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{1}=2\lambda_{1}=2\lambda_{2}.
  </annotation>
 </semantics>
</math>

</p>

<p>Plugging this into the pair of equations above, we have</p>

<p>

<math display="inline" id="Singular_value_decomposition:218">
 <semantics>
  <msub>
   <mi>𝐌𝐯</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐌𝐯</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\mathbf{M}\mathbf{v}_{1}
  </annotation>
 </semantics>
</math>


</p>

<p>This proves the statement.</p>

<p>More singular vectors and singular values can be found by maximizing 

<math display="inline" id="Singular_value_decomposition:219">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐮</mi>
    <mo>,</mo>
    <mi>𝐯</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>σ</ci>
    <interval closure="open">
     <ci>𝐮</ci>
     <ci>𝐯</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   σ(\mathbf{u},\mathbf{v})
  </annotation>
 </semantics>
</math>

 over normalized 

<math display="inline" id="Singular_value_decomposition:220">
 <semantics>
  <mrow>
   <mi>𝐮</mi>
   <mo>,</mo>
   <mi>𝐯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>𝐮</ci>
    <ci>𝐯</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u},\mathbf{v}
  </annotation>
 </semantics>
</math>

 which are orthogonal to <mtpl></mtpl> and <mtpl></mtpl>, respectively.</p>

<p>The passage from real to complex is similar to the eigenvalue case.</p>
<h2 id="geometric-meaning">Geometric meaning</h2>

<p>Because 

<math display="inline" id="Singular_value_decomposition:221">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Singular_value_decomposition:222">
 <semantics>
  <mi>𝐕</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐕</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}
  </annotation>
 </semantics>
</math>

 are unitary, we know that the columns <mtpl></mtpl> of 

<math display="inline" id="Singular_value_decomposition:223">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}
  </annotation>
 </semantics>
</math>

 yield an <a href="orthonormal_basis" title="wikilink">orthonormal basis</a> of <mtpl></mtpl> and the columns <mtpl></mtpl> of 

<math display="inline" id="Singular_value_decomposition:224">
 <semantics>
  <mi>𝐕</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐕</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}
  </annotation>
 </semantics>
</math>

 yield an orthonormal basis of <mtpl></mtpl> (with respect to the standard <a href="scalar_product" title="wikilink">scalar products</a> on these spaces).</p>

<p>The <a href="linear_transformation" title="wikilink">linear transformation</a></p>

<p>

<math display="block" id="Singular_value_decomposition:225">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mi>T</mi>
       <mo>:</mo>
       <mrow>
        <msup>
         <mi>K</mi>
         <mi>n</mi>
        </msup>
        <mo>→</mo>
        <msup>
         <mi>K</mi>
         <mi>m</mi>
        </msup>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mi>x</mi>
       <mo>↦</mo>
       <mrow>
        <mi>𝐌</mi>
        <mi>x</mi>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
   </mtable>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">cases</csymbol>
    <apply>
     <ci>normal-:</ci>
     <ci>T</ci>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>K</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>K</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>𝐌</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{cases}T:K^{n}\to K^{m}\\
x\mapsto\mathbf{M}x\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>has a particularly simple description with respect to these orthonormal bases: we have</p>

<p>

<math display="block" id="Singular_value_decomposition:226">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>𝐕</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msub>
       <mi>σ</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>𝐔</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
    <mo rspace="22.5pt">,</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mrow>
      <mn>1</mn>
      <mo>,</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo>,</mo>
      <mrow>
       <mi>min</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>m</mi>
        <mo>,</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>T</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐕</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐔</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>i</ci>
     <list>
      <cn type="integer">1</cn>
      <ci>normal-⋯</ci>
      <apply>
       <min></min>
       <ci>m</ci>
       <ci>n</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(\mathbf{V}_{i})=\sigma_{i}\mathbf{U}_{i},\qquad i=1,\cdots,\min(m,n),
  </annotation>
 </semantics>
</math>

</p>

<p>where <mtpl></mtpl> is the 

<math display="inline" id="Singular_value_decomposition:227">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th diagonal entry of 

<math display="inline" id="Singular_value_decomposition:228">
 <semantics>
  <mi>𝚺</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚺</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Σ}
  </annotation>
 </semantics>
</math>

, and <mtpl> 0}}</mtpl> for 

<math display="inline" id="Singular_value_decomposition:229">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>></mo>
   <mrow>
    <mi>m</mi>
    <mi>i</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>i</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>i</ci>
     <ci>n</ci>
     <interval closure="open">
      <ci>m</ci>
      <ci>n</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i>min(m,n)
  </annotation>
 </semantics>
</math>

.</p>

<p>The geometric content of the SVD theorem can thus be summarized as follows: for every linear map <mtpl></mtpl> one can find orthonormal bases of <mtpl></mtpl> and <mtpl></mtpl> such that 

<math display="inline" id="Singular_value_decomposition:230">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 maps the 

<math display="inline" id="Singular_value_decomposition:231">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th basis vector of <mtpl></mtpl> to a non-negative multiple of the 

<math display="inline" id="Singular_value_decomposition:232">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th basis vector of <mtpl></mtpl>, and sends the left-over basis vectors to zero. With respect to these bases, the map 

<math display="inline" id="Singular_value_decomposition:233">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is therefore represented by a diagonal matrix with non-negative real diagonal entries.</p>

<p>To get a more visual flavour of singular values and SVD decomposition — at least when working on real vector spaces — consider the sphere 

<math display="inline" id="Singular_value_decomposition:234">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 of radius one in <mtpl></mtpl>. The linear map 

<math display="inline" id="Singular_value_decomposition:235">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 maps this sphere onto an <a class="uri" href="ellipsoid" title="wikilink">ellipsoid</a> in <mtpl></mtpl>. Non-zero singular values are simply the lengths of the <a href="Semi-minor_axis" title="wikilink">semi-axes</a> of this ellipsoid. Especially when 

<math display="inline" id="Singular_value_decomposition:236">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=m
  </annotation>
 </semantics>
</math>

, and all the singular values are distinct and non-zero, the SVD of the linear map 

<math display="inline" id="Singular_value_decomposition:237">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 can be easily analysed as a succession of three consecutive moves: consider the ellipsoid 

<math display="inline" id="Singular_value_decomposition:238">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(S)
  </annotation>
 </semantics>
</math>

 and specifically its axes; then consider the directions in <mtpl></mtpl> sent by 

<math display="inline" id="Singular_value_decomposition:239">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 onto these axes. These directions happen to be mutually orthogonal. Apply first an isometry <mtpl></mtpl> sending these directions to the coordinate axes of <mtpl></mtpl>. On a second move, apply an <a class="uri" href="endomorphism" title="wikilink">endomorphism</a> 

<math display="inline" id="Singular_value_decomposition:240">
 <semantics>
  <mi>𝐃</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐃</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{D}
  </annotation>
 </semantics>
</math>

 diagonalized along the coordinate axes and stretching or shrinking in each direction, using the semi-axes lengths of 

<math display="inline" id="Singular_value_decomposition:241">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(S)
  </annotation>
 </semantics>
</math>

 as stretching coefficients. The composition <mtpl></mtpl> then sends the unit-sphere onto an ellipsoid isometric to 

<math display="inline" id="Singular_value_decomposition:242">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(S)
  </annotation>
 </semantics>
</math>

. To define the third and last move 

<math display="inline" id="Singular_value_decomposition:243">
 <semantics>
  <mi>𝐔</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{U}
  </annotation>
 </semantics>
</math>

, apply an isometry to this ellipsoid so as to carry it over 

<math display="inline" id="Singular_value_decomposition:244">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(S)
  </annotation>
 </semantics>
</math>

. As can be easily checked, the composition <mtpl></mtpl> coincides with 

<math display="inline" id="Singular_value_decomposition:245">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="calculating-the-svd">Calculating the SVD</h2>
<h3 id="numerical-approach">Numerical approach</h3>

<p>The SVD of a matrix 

<math display="inline" id="Singular_value_decomposition:246">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 is typically computed by a two-step procedure. In the first step, the matrix is reduced to a <a href="bidiagonal_matrix" title="wikilink">bidiagonal matrix</a>. This takes <a href="big_O_notation" title="wikilink">O</a>(<em>mn</em><sup>2</sup>) floating-point operations (flops), assuming that <em>m</em> ≥ <em>n</em>. The second step is to compute the SVD of the bidiagonal matrix. This step can only be done with an <a href="iterative_method" title="wikilink">iterative method</a> (as with <a href="eigenvalue_algorithm" title="wikilink">eigenvalue algorithms</a>). However, in practice it suffices to compute the SVD up to a certain precision, like the <a href="machine_epsilon" title="wikilink">machine epsilon</a>. If this precision is considered constant, then the second step takes O(<em>n</em>) iterations, each costing O(<em>n</em>) flops. Thus, the first step is more expensive, and the overall cost is O(<em>mn</em><sup>2</sup>) flops .</p>

<p>The first step can be done using <a href="Householder_reflection" title="wikilink">Householder reflections</a> for a cost of 4<em>mn</em><sup>2</sup> − 4<em>n</em><sup>3</sup>/3 flops, assuming that only the singular values are needed and not the singular vectors. If <em>m</em> is much larger than <em>n</em> then it is advantageous to first reduce the matrix <em>M</em> to a triangular matrix with the <a href="QR_decomposition" title="wikilink">QR decomposition</a> and then use Householder reflections to further reduce the matrix to bidiagonal form; the combined cost is 2<em>mn</em><sup>2</sup> + 2<em>n</em><sup>3</sup> flops .</p>

<p>The second step can be done by a variant of the <a href="QR_algorithm" title="wikilink">QR algorithm</a> for the computation of eigenvalues, which was first described by . The <a class="uri" href="LAPACK" title="wikilink">LAPACK</a> subroutine DBDSQR<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> implements this iterative method, with some modifications to cover the case where the singular values are very small . Together with a first step using Householder reflections and, if appropriate, QR decomposition, this forms the DGESVD<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> routine for the computation of the singular value decomposition.</p>

<p>The same algorithm is implemented in the <a href="GNU_Scientific_Library" title="wikilink">GNU Scientific Library</a> (GSL). The GSL also offers an alternative method, which uses a one-sided <a href="Jacobi_orthogonalization" title="wikilink">Jacobi orthogonalization</a> in step 2 . This method computes the SVD of the bidiagonal matrix by solving a sequence of 2 × 2 SVD problems, similar to how the <a href="Jacobi_eigenvalue_algorithm" title="wikilink">Jacobi eigenvalue algorithm</a> solves a sequence of 2 × 2 eigenvalue methods . Yet another method for step 2 uses the idea of <a href="divide-and-conquer_eigenvalue_algorithm" title="wikilink">divide-and-conquer eigenvalue algorithms</a> .</p>

<p>There is an alternative way which is not explicitly using the eigenvalue decomposition.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> Usually the singular value problem of a matrix 

<math display="inline" id="Singular_value_decomposition:247">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 is converted into an equivalent symmetric eigenvalue problem such as <mtpl></mtpl>, <mtpl></mtpl>, or</p>

<p>

<math display="block" id="Singular_value_decomposition:248">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mi>𝐎</mi>
      </mtd>
      <mtd columnalign="center">
       <mi>𝐌</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msup>
        <mi>𝐌</mi>
        <mo>*</mo>
       </msup>
      </mtd>
      <mtd columnalign="center">
       <mi>𝐎</mi>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <ci>𝐎</ci>
     <ci>𝐌</ci>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐌</ci>
      <times></times>
     </apply>
     <ci>𝐎</ci>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{pmatrix}\mathbf{O}&\mathbf{M}\\
\mathbf{M}^{*}&\mathbf{O}\end{pmatrix}.
  </annotation>
 </semantics>
</math>

 The approaches using eigenvalue decompositions are based on <a href="QR_algorithm" title="wikilink">QR algorithm</a> which is well-developed to be stable and fast. Note that the singular values are not complex and right- and left- singular vectors are not required to form any similarity transformation. Alternating <a href="QR_decomposition" title="wikilink">QR decomposition</a> and <a href="LQ_decomposition" title="wikilink">LQ decomposition</a> can be claimed to use iteratively to find the real diagonal matrix with <a href="Hermitian_matrix" title="wikilink">Hermitian matrices</a>. <a href="QR_decomposition" title="wikilink">QR decomposition</a> gives 

<math display="inline" id="Singular_value_decomposition:249">
 <semantics>
  <mrow>
   <mi>𝐌</mi>
   <mi mathvariant="normal">⇒</mi>
   <mi>𝐐𝐑</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐌</ci>
    <ci>normal-⇒</ci>
    <ci>𝐐𝐑</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}⇒\mathbf{Q}\mathbf{R}
  </annotation>
 </semantics>
</math>

 and <a href="LQ_decomposition" title="wikilink">LQ decomposition</a> of 

<math display="inline" id="Singular_value_decomposition:250">
 <semantics>
  <mi>𝐑</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}
  </annotation>
 </semantics>
</math>

 gives <mtpl></mtpl>. Thus, at every iteration, we have <mtpl></mtpl>, update 

<math display="inline" id="Singular_value_decomposition:251">
 <semantics>
  <mrow>
   <mi>𝐌</mi>
   <mi mathvariant="normal">⇐</mi>
   <mi>𝐋</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐌</ci>
    <ci>normal-⇐</ci>
    <ci>𝐋</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}⇐\mathbf{L}
  </annotation>
 </semantics>
</math>

 and repeat the orthogonalizations. Eventually, <a href="QR_decomposition" title="wikilink">QR decomposition</a> and <a href="LQ_decomposition" title="wikilink">LQ decomposition</a> iteratively provide unitary matrices for left- and right- singular matrices, respectively. This approach does not come with any acceleration method such as spectral shifts and deflation as in QR algorithm. It is because the shift method is not easily defined without using similarity transformation. But it is very simple to implement where the speed does not matter. Also it give us a good interpretation that only orthogonal/unitary transformations can obtain SVD as the <a href="QR_algorithm" title="wikilink">QR algorithm</a> can calculate the <a href="eigenvalue_decomposition" title="wikilink">eigenvalue decomposition</a>.</p>
<h3 id="analytic-result-of-2-2-svd">Analytic result of 2 × 2 SVD</h3>

<p>The singular values of a 2 × 2 matrix can be found analytically. Let the matrix be 

<math display="inline" id="Singular_value_decomposition:252">
 <semantics>
  <mrow>
   <mi>𝐌</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>z</mi>
      <mn>0</mn>
     </msub>
     <mi>𝐈</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>z</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>σ</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>z</mi>
      <mn>2</mn>
     </msub>
     <msub>
      <mi>σ</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>z</mi>
      <mn>3</mn>
     </msub>
     <msub>
      <mi>σ</mi>
      <mn>3</mn>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐌</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>𝐈</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}=z_{0}\mathbf{I}+z_{1}\sigma_{1}+z_{2}\sigma_{2}+z_{3}\sigma_{3}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Singular_value_decomposition:253">
 <semantics>
  <mrow>
   <msub>
    <mi>z</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <mi>ℂ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <ci>i</ci>
    </apply>
    <ci>ℂ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{i}\in\mathbb{C}
  </annotation>
 </semantics>
</math>

 are complex numbers that parameterize the matrix, 

<math display="inline" id="Singular_value_decomposition:254">
 <semantics>
  <mi>𝐈</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐈</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{I}
  </annotation>
 </semantics>
</math>

 is the identity matrix, and 

<math display="inline" id="Singular_value_decomposition:255">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{i}
  </annotation>
 </semantics>
</math>

 denote the <a href="Pauli_matrices" title="wikilink">Pauli matrices</a>. Then its two singular values are given by</p>

<p>

<math display="inline" id="Singular_value_decomposition:256">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mo>±</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <csymbol cd="latexml">plus-or-minus</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\sigma_{\pm}
  </annotation>
 </semantics>
</math>


</p>
<h2 id="reduced-svds">Reduced SVDs</h2>

<p>In applications it is quite unusual for the full SVD, including a full unitary decomposition of the null-space of the matrix, to be required. Instead, it is often sufficient (as well as faster, and more economical for storage) to compute a reduced version of the SVD. The following can be distinguished for an <em>m</em>×<em>n</em> matrix <em>M</em> of rank <em>r</em>:</p>
<h3 id="thin-svd">Thin SVD</h3>

<p>

<math display="block" id="Singular_value_decomposition:257">
 <semantics>
  <mrow>
   <mi>𝐌</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐔</mi>
     <mi>n</mi>
    </msub>
    <msub>
     <mi>𝚺</mi>
     <mi>n</mi>
    </msub>
    <msup>
     <mi>𝐕</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐌</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐔</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝚺</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐕</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}=\mathbf{U}_{n}\boldsymbol{\Sigma}_{n}\mathbf{V}^{*}
  </annotation>
 </semantics>
</math>

</p>

<p>Only the <em>n</em> column vectors of <em>U</em> corresponding to the row vectors of <em>V*</em> are calculated. The remaining column vectors of <em>U</em> are not calculated. This is significantly quicker and more economical than the full SVD if <em>n</em>≪<em>m</em>. The matrix <em>U</em><sub>n</sub> is thus <em>m</em>×<em>n</em>, Σ<sub>n</sub> is <em>n</em>×<em>n</em> diagonal, and <em>V</em> is <em>n</em>×<em>n</em>.</p>

<p>The first stage in the calculation of a thin SVD will usually be a <a href="QR_decomposition" title="wikilink">QR decomposition</a> of <em>M</em>, which can make for a significantly quicker calculation if <em>n</em>≪<em>m</em>.</p>
<h3 id="compact-svd">Compact SVD</h3>

<p>

<math display="block" id="Singular_value_decomposition:258">
 <semantics>
  <mrow>
   <mi>𝐌</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐔</mi>
     <mi>r</mi>
    </msub>
    <msub>
     <mi>𝚺</mi>
     <mi>r</mi>
    </msub>
    <msubsup>
     <mi>𝐕</mi>
     <mi>r</mi>
     <mo>*</mo>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐌</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐔</ci>
      <ci>r</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝚺</ci>
      <ci>r</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐕</ci>
       <ci>r</ci>
      </apply>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}=\mathbf{U}_{r}\boldsymbol{\Sigma}_{r}\mathbf{V}_{r}^{*}
  </annotation>
 </semantics>
</math>

</p>

<p>Only the <em>r</em> column vectors of <em>U</em> and <em>r</em> row vectors of <em>V*</em> corresponding to the non-zero singular values Σ<sub>r</sub> are calculated. The remaining vectors of <em>U</em> and <em>V*</em> are not calculated. This is quicker and more economical than the thin SVD if <em>r</em>≪<em>n</em>. The matrix <em>U</em><sub>r</sub> is thus <em>m</em>×<em>r</em>, Σ<sub>r</sub> is <em>r</em>×<em>r</em> diagonal, and <em>V</em><sub>r</sub>* is <em>r</em>×<em>n</em>.</p>
<h3 id="truncated-svd">Truncated SVD</h3>

<p>

<math display="block" id="Singular_value_decomposition:259">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>𝐌</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐔</mi>
     <mi>t</mi>
    </msub>
    <msub>
     <mi>𝚺</mi>
     <mi>t</mi>
    </msub>
    <msubsup>
     <mi>𝐕</mi>
     <mi>t</mi>
     <mo>*</mo>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-~</ci>
     <ci>𝐌</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐔</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝚺</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐕</ci>
       <ci>t</ci>
      </apply>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{\mathbf{M}}=\mathbf{U}_{t}\boldsymbol{\Sigma}_{t}\mathbf{V}_{t}^{*}
  </annotation>
 </semantics>
</math>

</p>

<p>Only the <em>t</em> column vectors of <em>U</em> and <em>t</em> row vectors of <em>V*</em> corresponding to the <em>t</em> largest singular values Σ<sub>t</sub> are calculated. The rest of the matrix is discarded. This can be much quicker and more economical than the compact SVD if <em>t</em>≪<em>r</em>. The matrix <em>U</em><sub>t</sub> is thus <em>m</em>×<em>t</em>, Σ<sub>t</sub> is <em>t</em>×<em>t</em> diagonal, and <em>V</em><sub>t</sub>* is <em>t</em>×<em>n</em>.</p>

<p>Of course the truncated SVD is no longer an exact decomposition of the original matrix <em>M</em>, but as discussed <a href="#Low-rank_matrix_approximation" title="wikilink">above</a>, the approximate matrix 

<math display="inline" id="Singular_value_decomposition:260">
 <semantics>
  <mover accent="true">
   <mi>𝐌</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>𝐌</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{\mathbf{M}}
  </annotation>
 </semantics>
</math>

 is in a very useful sense the closest approximation to <em>M</em> that can be achieved by a matrix of rank <em>t</em>.</p>
<h2 id="norms">Norms</h2>
<h3 id="ky-fan-norms">Ky Fan norms</h3>

<p>The sum of the <em>k</em> largest singular values of <em>M</em> is a <a href="matrix_norm" title="wikilink">matrix norm</a>, the <a href="Ky_Fan" title="wikilink">Ky Fan</a> <em>k</em>-norm of <em>M</em>.</p>

<p>The first of the Ky Fan norms, the Ky Fan 1-norm is the same as the <a href="operator_norm" title="wikilink">operator norm</a> of <em>M</em> as a linear operator with respect to the Euclidean norms of <em>K</em><sup><em>m</em></sup> and <em>K</em><sup><em>n</em></sup>. In other words, the Ky Fan 1-norm is the operator norm induced by the standard <em>l</em><sup>2</sup> Euclidean inner product. For this reason, it is also called the operator 2-norm. One can easily verify the relationship between the Ky Fan 1-norm and singular values. It is true in general, for a bounded operator <em>M</em> on (possibly infinite-dimensional) Hilbert spaces</p>

<p>

<math display="block" id="Singular_value_decomposition:261">
 <semantics>
  <mrow>
   <mrow>
    <mo>∥</mo>
    <mi>𝐌</mi>
    <mo>∥</mo>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <msup>
       <mi>𝐌</mi>
       <mo>*</mo>
      </msup>
      <mi>𝐌</mi>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <ci>𝐌</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐌</ci>
        <times></times>
       </apply>
       <ci>𝐌</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\mathbf{M}\|=\|\mathbf{M}^{*}\mathbf{M}\|^{\frac{1}{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>But, in the matrix case, (<em>M* M</em>)<sup>½</sup> is a <a href="normal_matrix" title="wikilink">normal matrix</a>, so ||<em>M* M</em>||<sup>½</sup> is the largest eigenvalue of (<em>M* M</em>)<sup>½</sup>, i.e. the largest singular value of <em>M</em>.</p>

<p>The last of the Ky Fan norms, the sum of all singular values, is the <a href="trace_class" title="wikilink">trace norm</a> (also known as the 'nuclear norm'), defined by ||<em>M</em>|| = Tr[(<em>M* M</em>)<sup>½</sup>] (the eigenvalues of <em>M* M</em> are the squares of the singular values).</p>
<h3 id="hilbertschmidt-norm">Hilbert–Schmidt norm</h3>

<p>The singular values are related to another norm on the space of operators. Consider the <a href="Hilbert–Schmidt_operator" title="wikilink">Hilbert–Schmidt</a> inner product on the 

<math display="inline" id="Singular_value_decomposition:262">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n×n
  </annotation>
 </semantics>
</math>

 matrices, defined by</p>

<p>

<math display="block" id="Singular_value_decomposition:263">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>𝐌</mi>
     <mo>,</mo>
     <mi>𝐍</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>trace</mo>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mi>𝐍</mi>
        <mo>*</mo>
       </msup>
       <mi>𝐌</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <ci>𝐌</ci>
     <ci>𝐍</ci>
    </list>
    <apply>
     <ci>trace</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐍</ci>
       <times></times>
      </apply>
      <ci>𝐌</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\mathbf{M},\mathbf{N}\rangle=\operatorname{trace}\left(\mathbf{N}^{*}%
\mathbf{M}\right).
  </annotation>
 </semantics>
</math>

</p>

<p>So the induced norm is</p>

<p>

<math display="block" id="Singular_value_decomposition:264">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mi>𝐌</mi>
     <mo>∥</mo>
    </mrow>
    <mo>=</mo>
    <msqrt>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>𝐌</mi>
      <mo>,</mo>
      <mi>𝐌</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </msqrt>
    <mo>=</mo>
    <msqrt>
     <mrow>
      <mo>trace</mo>
      <mrow>
       <mo>(</mo>
       <mrow>
        <msup>
         <mi>𝐌</mi>
         <mo>*</mo>
        </msup>
        <mi>𝐌</mi>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </msqrt>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>𝐌</ci>
     </apply>
     <apply>
      <root></root>
      <list>
       <ci>𝐌</ci>
       <ci>𝐌</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <root></root>
      <apply>
       <ci>trace</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝐌</ci>
         <times></times>
        </apply>
        <ci>𝐌</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\mathbf{M}\|=\sqrt{\langle\mathbf{M},\mathbf{M}\rangle}=\sqrt{\operatorname{%
trace}\left(\mathbf{M}^{*}\mathbf{M}\right)}.
  </annotation>
 </semantics>
</math>

</p>

<p>Since the trace is invariant under unitary equivalence, this shows</p>

<p>

<math display="block" id="Singular_value_decomposition:265">
 <semantics>
  <mrow>
   <mrow>
    <mo>∥</mo>
    <mi>𝐌</mi>
    <mo>∥</mo>
   </mrow>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <msubsup>
      <mi>σ</mi>
      <mi>i</mi>
      <mn>2</mn>
     </msubsup>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <ci>𝐌</ci>
    </apply>
    <apply>
     <root></root>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <ci>i</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\mathbf{M}\|=\sqrt{\sum_{i}\sigma_{i}^{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>where <mtpl></mtpl> are the singular values of 

<math display="inline" id="Singular_value_decomposition:266">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

. This is called the <strong><a href="Frobenius_norm" title="wikilink">Frobenius norm</a></strong>, <strong>Schatten 2-norm</strong>, or <strong>Hilbert–Schmidt norm</strong> of 

<math display="inline" id="Singular_value_decomposition:267">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

. Direct calculation shows that the Frobenius norm of <mtpl> (<em>m<sub>ij</sub></em>)}}</mtpl> coincides with:</p>

<p>

<math display="block" id="Singular_value_decomposition:268">
 <semantics>
  <mrow>
   <msqrt>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </munder>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>m</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
       <mo stretchy="false">|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </msqrt>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{\sum_{ij}|m_{ij}|^{2}}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="tensor-svd">Tensor SVD</h2>

<p>Two types of tensor decompositions exist, which generalise the SVD to multi-way arrays. One of them decomposes a tensor into a sum of rank-1 tensors, which is called a <a href="tensor_rank_decomposition" title="wikilink">tensor rank decomposition</a>. The second type of decomposition computes the orthonormal subspaces associated with the different factors appearing in the tensor product of vector spaces in which the tensor lives. This decomposition is referred to in the literature as the <a href="Higher-order_singular_value_decomposition" title="wikilink">higher-order SVD</a> (HOSVD) or <a href="Tucker_decomposition" title="wikilink">Tucker3/TuckerM</a>. In addition, <a href="multilinear_principal_component_analysis" title="wikilink">multilinear principal component analysis</a> in <a href="multilinear_subspace_learning" title="wikilink">multilinear subspace learning</a> involves the same mathematical operations as Tucker decomposition, being used in a different context of <a href="dimensionality_reduction" title="wikilink">dimensionality reduction</a>.</p>
<h2 id="bounded-operators-on-hilbert-spaces">Bounded operators on Hilbert spaces</h2>

<p>The factorization <mtpl> <strong>UΣV</strong><sup>∗</sup>}}</mtpl> can be extended to a <a href="bounded_operator" title="wikilink">bounded operator</a> <em>M</em> on a separable Hilbert space <em>H</em>. Namely, for any bounded operator <em>M</em>, there exist a <a href="partial_isometry" title="wikilink">partial isometry</a> <em>U</em>, a unitary <em>V</em>, a measure space (<em>X</em>, <em>μ</em>), and a non-negative measurable <em>f</em> such that</p>

<p>

<math display="block" id="Singular_value_decomposition:269">
 <semantics>
  <mrow>
   <mi>𝐌</mi>
   <mo>=</mo>
   <mrow>
    <mi>𝐔</mi>
    <msub>
     <mi>T</mi>
     <mi>f</mi>
    </msub>
    <msup>
     <mi>𝐕</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐌</ci>
    <apply>
     <times></times>
     <ci>𝐔</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐕</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}=\mathbf{U}T_{f}\mathbf{V}^{*}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Singular_value_decomposition:270">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{f}
  </annotation>
 </semantics>
</math>

 is the <a href="multiplication_operator" title="wikilink">multiplication by <em>f</em></a> on <em>L</em><sup>2</sup>(<em>X</em>, <em>μ</em>).</p>

<p>This can be shown by mimicking the linear algebraic argument for the matricial case above. <em>VT<sub>f</sub> V*</em> is the unique positive square root of <em>M*M</em>, as given by the <a href="Borel_functional_calculus" title="wikilink">Borel functional calculus</a> for <a href="self_adjoint_operator" title="wikilink">self adjoint operators</a>. The reason why <em>U</em> need not be unitary is because, unlike the finite-dimensional case, given an isometry <em>U</em><sub>1</sub> with nontrivial kernel, a suitable <em>U</em><sub>2</sub> may not be found such that</p>

<p>

<math display="block" id="Singular_value_decomposition:271">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <msub>
       <mi>U</mi>
       <mn>1</mn>
      </msub>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <msub>
       <mi>U</mi>
       <mn>2</mn>
      </msub>
     </mtd>
    </mtr>
   </mtable>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <cn type="integer">1</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>U</ci>
      <cn type="integer">2</cn>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}U_{1}\\
U_{2}\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>is a unitary operator.</p>

<p>As for matrices, the singular value factorization is equivalent to the <a href="polar_decomposition" title="wikilink">polar decomposition</a> for operators: we can simply write</p>

<p>

<math display="block" id="Singular_value_decomposition:272">
 <semantics>
  <mrow>
   <mi>𝐌</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>𝐔𝐕</mi>
      <mo>*</mo>
     </msup>
     <mo>⋅</mo>
     <mi>𝐕</mi>
    </mrow>
    <msub>
     <mi>T</mi>
     <mi>f</mi>
    </msub>
    <msup>
     <mi>𝐕</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐌</ci>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐔𝐕</ci>
       <times></times>
      </apply>
      <ci>𝐕</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐕</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}=\mathbf{U}\mathbf{V}^{*}\cdot\mathbf{V}T_{f}\mathbf{V}^{*}
  </annotation>
 </semantics>
</math>

</p>

<p>and notice that <em>U V*</em> is still a partial isometry while <em>VT<sub>f</sub> V*</em> is positive.</p>
<h3 id="singular-values-and-compact-operators">Singular values and compact operators</h3>

<p>To extend notion of singular values and left/right-singular vectors to the operator case, one needs to restrict to <a href="compact_operator_on_Hilbert_space" title="wikilink">compact operators</a>. It is a general fact that compact operators on <a href="Banach_space" title="wikilink">Banach spaces</a> have only discrete spectrum. This is also true for compact operators on Hilbert spaces, since <a href="Hilbert_space" title="wikilink">Hilbert spaces</a> are a special case of Banach spaces. If 

<math display="inline" id="Singular_value_decomposition:273">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is compact, every non-zero 

<math display="inline" id="Singular_value_decomposition:274">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

 in its spectrum is an eigenvalue. Furthermore, a compact self adjoint operator can be diagonalized by its eigenvectors. If 

<math display="inline" id="Singular_value_decomposition:275">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 is compact, so is <mtpl></mtpl>. Applying the diagonalization result, the unitary image of its positive square root <mtpl></mtpl> has a set of orthonormal eigenvectors  corresponding to strictly positive eigenvalues  For any 

<math display="inline" id="Singular_value_decomposition:276">
 <semantics>
  <mrow>
   <mi>ψ</mi>
   <mi mathvariant="normal">∈</mi>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ψ</ci>
    <ci>normal-∈</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ψ∈H
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Singular_value_decomposition:277">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐌</mi>
    <mi>ψ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>𝐔</mi>
    <msub>
     <mi>T</mi>
     <mi>f</mi>
    </msub>
    <msup>
     <mi>𝐕</mi>
     <mo>*</mo>
    </msup>
    <mi>ψ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <mrow>
      <mo>⟨</mo>
      <mrow>
       <mi>𝐔</mi>
       <msub>
        <mi>T</mi>
        <mi>f</mi>
       </msub>
       <msup>
        <mi>𝐕</mi>
        <mo>*</mo>
       </msup>
       <mi>ψ</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>𝐔</mi>
       <msub>
        <mi>e</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo>⟩</mo>
     </mrow>
     <mi>𝐔</mi>
     <msub>
      <mi>e</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <msub>
      <mi>σ</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo>⟨</mo>
      <mi>ψ</mi>
      <mo>,</mo>
      <mrow>
       <mi>𝐕</mi>
       <msub>
        <mi>e</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo>⟩</mo>
     </mrow>
     <mi>𝐔</mi>
     <msub>
      <mi>e</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>𝐌</ci>
      <ci>ψ</ci>
     </apply>
     <apply>
      <times></times>
      <ci>𝐔</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐕</ci>
       <times></times>
      </apply>
      <ci>ψ</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <list>
        <apply>
         <times></times>
         <ci>𝐔</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>T</ci>
          <ci>f</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>𝐕</ci>
          <times></times>
         </apply>
         <ci>ψ</ci>
        </apply>
        <apply>
         <times></times>
         <ci>𝐔</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>e</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </list>
       <ci>𝐔</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <ci>i</ci>
       </apply>
       <list>
        <ci>ψ</ci>
        <apply>
         <times></times>
         <ci>𝐕</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>e</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </list>
       <ci>𝐔</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}\psi=\mathbf{U}T_{f}\mathbf{V}^{*}\psi=\sum_{i}\left\langle\mathbf{U%
}T_{f}\mathbf{V}^{*}\psi,\mathbf{U}e_{i}\right\rangle\mathbf{U}e_{i}=\sum_{i}%
\sigma_{i}\left\langle\psi,\mathbf{V}e_{i}\right\rangle\mathbf{U}e_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>where the series converges in the norm topology on 

<math display="inline" id="Singular_value_decomposition:278">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

. Notice how this resembles the expression from the finite-dimensional case. <mtpl></mtpl> are called the singular values of 

<math display="inline" id="Singular_value_decomposition:279">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

.  (resp. ) can be considered the left-singular (resp. right-singular) vectors of 

<math display="inline" id="Singular_value_decomposition:280">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

.</p>

<p><a href="Compact_operator_on_Hilbert_space" title="wikilink">Compact operators on a Hilbert space</a> are the closure of <a href="finite-rank_operator" title="wikilink">finite-rank operators</a> in the uniform operator topology. The above series expression gives an explicit such representation. An immediate consequence of this is:</p>
<dl>
<dd><strong>Theorem.</strong> 

<math display="inline" id="Singular_value_decomposition:281">
 <semantics>
  <mi>𝐌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}
  </annotation>
 </semantics>
</math>

 is compact if and only if <mtpl></mtpl> is compact.
</dd>
</dl>
<h2 id="history">History</h2>

<p>The singular value decomposition was originally developed by <a href="differential_geometry" title="wikilink">differential geometers</a>, who wished to determine whether a real <a href="bilinear_form" title="wikilink">bilinear form</a> could be made equal to another by independent orthogonal transformations of the two spaces it acts on. <a href="Eugenio_Beltrami" title="wikilink">Eugenio Beltrami</a> and <a href="Camille_Jordan" title="wikilink">Camille Jordan</a> discovered independently, in 1873 and 1874 respectively, that the singular values of the bilinear forms, represented as a matrix, form a <a href="Complete_set_of_invariants" title="wikilink">complete set</a> of <a href="invariant_(mathematics)" title="wikilink">invariants</a> for bilinear forms under orthogonal substitutions. <a href="James_Joseph_Sylvester" title="wikilink">James Joseph Sylvester</a> also arrived at the singular value decomposition for real square matrices in 1889, apparently independently of both Beltrami and Jordan. Sylvester called the singular values the <em>canonical multipliers</em> of the matrix <em>A</em>. The fourth mathematician to discover the singular value decomposition independently is Autonne in 1915, who arrived at it via the <a href="polar_decomposition" title="wikilink">polar decomposition</a>. The first proof of the singular value decomposition for rectangular and complex matrices seems to be by <a href="Carl_Eckart" title="wikilink">Carl Eckart</a> and Gale Young in 1936;<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> they saw it as a generalization of the <a href="Principal_axis_theorem" title="wikilink">principal axis</a> transformation for <a href="Hermitian_matrix" title="wikilink">Hermitian matrices</a>.</p>

<p>In 1907, <a href="Erhard_Schmidt" title="wikilink">Erhard Schmidt</a> defined an analog of singular values for <a href="integral_operator" title="wikilink">integral operators</a> (which are compact, under some weak technical assumptions); it seems he was unaware of the parallel work on singular values of finite matrices. This theory was further developed by <a href="Émile_Picard" title="wikilink">Émile Picard</a> in 1910, who is the first to call the numbers 

<math display="inline" id="Singular_value_decomposition:282">
 <semantics>
  <msub>
   <mi>σ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>σ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{k}
  </annotation>
 </semantics>
</math>

 <em>singular values</em> (or in French, <em>valeurs singulières</em>).</p>

<p>Practical methods for computing the SVD date back to <a href="Ervand_Kogbetliantz" title="wikilink">Kogbetliantz</a> in 1954, 1955 and <a href="Magnus_Hestenes" title="wikilink">Hestenes</a> in 1958.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> resembling closely the <a href="Jacobi_eigenvalue_algorithm" title="wikilink">Jacobi eigenvalue algorithm</a>, which uses plane rotations or <a href="Givens_rotation" title="wikilink">Givens rotations</a>. However, these were replaced by the method of <a href="Gene_H._Golub" title="wikilink">Gene Golub</a> and <a href="William_Kahan" title="wikilink">William Kahan</a> published in 1965,<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> which uses <a href="Householder_transformation" title="wikilink">Householder transformations</a> or reflections. In 1970, Golub and Christian Reinsch<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> published a variant of the Golub/Kahan algorithm that is still the one most-used today.</p>
<h2 id="see-also">See also</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>Halldor, Bjornsson and Venegas, Silvia A. (1997). <a href="http://brunnur.vedur.is/pub/halldor/TEXT/eofsvd.html">"A manual for EOF and SVD analyses of climate data"</a>. McGill University, CCGCR Report No. 97-1, Montréal, Québec, 52pp.</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://engineerjs.com/doc/ejs/engine/linalg-1/_svd.html">Online SVD calculator</a></li>
</ul>

<p>"</p>

<p><a href="Category:Singular_value_decomposition" title="wikilink"> </a> <a href="Category:Linear_algebra" title="wikilink">Category:Linear algebra</a> <a href="Category:Numerical_linear_algebra" title="wikilink">Category:Numerical linear algebra</a> <a href="Category:Matrix_theory" title="wikilink">Category:Matrix theory</a> <a href="Category:Matrix_decompositions" title="wikilink">Category:Matrix decompositions</a> <a href="Category:Functional_analysis" title="wikilink">Category:Functional analysis</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://www.wou.edu/~beavers/Talks/Willamette1106.pdf">The Singular Value Decomposition in Symmetric (Lowdin) Orthogonalization and Data Compression</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="http://www.netlib.org/lapack/double/dbdsqr.f">Netlib.org</a><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="http://www.netlib.org/lapack/double/dgesvd.f">Netlib.org</a><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="http://www.mathworks.co.kr/matlabcentral/fileexchange/12674-simple-svd">mathworks.co.kr/matlabcentral/fileexchange/12674-simple-svd</a><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
</ol>
</section>
</body>
</html>
