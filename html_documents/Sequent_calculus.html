<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1485">Sequent calculus</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Sequent calculus</h1>
<hr/>

<p><strong>Sequent calculus</strong> is, in essence, a style of formal logical <a href="argument" title="wikilink">argumentation</a> where every line of a proof is a conditional <a href="tautology_(logic)" title="wikilink">tautology</a> (called a <a class="uri" href="sequent" title="wikilink">sequent</a> by <a href="Gerhard_Gentzen" title="wikilink">Gerhard Gentzen</a>) instead of an unconditional tautology. Each conditional tautology is inferred from other conditional tautologies on earlier lines in a formal argument according to rules and procedures of <a class="uri" href="inference" title="wikilink">inference</a>, giving a better approximation to the style of natural deduction used by mathematicians than <a href="David_Hilbert" title="wikilink">David Hilbert's</a> earlier style of formal logic where every line was an unconditional tautology. (This is the essence of the idea, but there are several over-simplifications here. For example, there may be non-logical axioms upon which all propositions are implicitly dependent. Then sequents signify conditional <a href="theorem" title="wikilink">theorems</a> in a <a href="first-order_logic" title="wikilink">first-order language</a> rather than conditional tautologies.)</p>

<p>Sequent calculus is one of several extant styles of <a href="proof_calculus" title="wikilink">proof calculus</a> for expressing line-by-line logical arguments.</p>
<ul>
<li><a href="Hilbert_system" title="wikilink">Hilbert style</a>. Every line is an unconditional tautology (or theorem).</li>
<li>Gentzen style. Every line is a conditional tautology (or theorem) with zero or more conditions on the left.
<ul>
<li><a href="Natural_deduction" title="wikilink">Natural deduction</a>. Every (conditional) line has exactly one asserted proposition on the right.</li>
<li>Sequent calculus. Every (conditional) line has zero or more asserted propositions on the right.</li>
</ul></li>
</ul>

<p>In other words, natural deduction and sequent calculus systems are particular distinct kinds of Gentzen-style systems. Hilbert-style systems typically have a very small number of inference rules, relying more on sets of axioms. Gentzen-style systems typically have very few axioms, if any, relying more on sets of rules.</p>

<p>Gentzen-style systems have significant practical and theoretical advantages compared to Hilbert-style systems. For example, both natural deduction and sequent calculus systems facilitate the elimination and introduction of universal and existential <a href="Quantification_(logic)" title="wikilink">quantifiers</a> so that unquantified logical expressions can be manipulated according to the much simpler rules of <a href="propositional_calculus" title="wikilink">propositional calculus</a>. In a typical argument, quantifiers are eliminated, then propositional calculus is applied to unquantified expressions (which typically contain free variables), and then the quantifiers are reintroduced. This very much parallels the way in which mathematical proofs are carried out in practice by mathematicians. Predicate calculus proofs are generally much easier to discover with this approach, and are often shorter. Natural deduction systems are more suited to practical theorem-proving. Sequent calculus systems are more suited to theoretical analysis.</p>
<h2 id="introduction">Introduction</h2>

<p>In <a href="proof_theory" title="wikilink">proof theory</a> and <a href="mathematical_logic" title="wikilink">mathematical logic</a>, <strong>sequent calculus</strong> is a family of <a href="formal_system" title="wikilink">formal systems</a> sharing a certain style of inference and certain formal properties. The first sequent calculi, systems <strong>LK</strong> and <strong>LJ</strong>, were introduced in 1934/1935 by Gerhard Gentzen<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> as a tool for studying <a href="natural_deduction" title="wikilink">natural deduction</a> in <a href="first-order_logic" title="wikilink">first-order logic</a> (in <a href="Classical_logic" title="wikilink">classical</a> and <a href="Intuitionistic_logic" title="wikilink">intuitionistic</a> versions, respectively). Gentzen's so-called "Main Theorem" (<em>Hauptsatz</em>) about LK and LJ was the <a href="cut-elimination_theorem" title="wikilink">cut-elimination theorem</a>,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> a result with far-reaching <a href="Metatheory" title="wikilink">meta-theoretic</a> consequences, including <a class="uri" href="consistency" title="wikilink">consistency</a>. Gentzen further demonstrated the power and flexibility of this technique a few years later, applying a cut-elimination argument to give a (transfinite) <a href="Gentzen's_consistency_proof" title="wikilink">proof of the consistency of Peano arithmetic</a>, in surprising response to <a href="Gödel's_incompleteness_theorems" title="wikilink">Gödel's incompleteness theorems</a>. Since this early work, sequent calculi, also called <strong>Gentzen systems</strong>,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> and the general concepts relating to them, have been widely applied in the fields of proof theory, mathematical logic, and <a href="automated_deduction" title="wikilink">automated deduction</a>.</p>
<h3 id="hilbert-style-deduction-systems">Hilbert-style deduction systems</h3>

<p>One way to classify different styles of deduction systems is to look at the form of <em><a href="Judgment_(mathematical_logic)" title="wikilink">judgments</a></em> in the system, <em>i.e.</em>, which things may appear as the conclusion of a (sub)proof. The simplest judgment form is used in <a href="Hilbert-style_deduction_system" title="wikilink">Hilbert-style deduction systems</a>, where a judgment has the form</p>

<p>

<math display="block" id="Sequent_calculus:0">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>B</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\,
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Sequent_calculus:1">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is any formula of first-order-logic (or whatever logic the deduction system applies to, <em>e.g.</em>, propositional calculus or a <a href="higher-order_logic" title="wikilink">higher-order logic</a> or a <a href="modal_logic" title="wikilink">modal logic</a>). The theorems are those formulae that appear as the concluding judgment in a valid proof. A Hilbert-style system needs no distinction between formulae and judgments; we make one here solely for comparison with the cases that follow.</p>

<p>The price paid for the simple syntax of a Hilbert-style system is that complete formal proofs tend to get extremely long. Concrete arguments about proofs in such a system almost always appeal to the <a href="deduction_theorem" title="wikilink">deduction theorem</a>. This leads to the idea of including the deduction theorem as a formal rule in the system, which happens in <a href="natural_deduction" title="wikilink">natural deduction</a>.</p>
<h3 id="natural-deduction-systems">Natural deduction systems</h3>

<p>In natural deduction, judgments have the shape</p>

<p>

<math display="block" id="Sequent_calculus:2">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>⊢</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>n</ci>
     </apply>
    </list>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1},A_{2},\ldots,A_{n}\vdash B
  </annotation>
 </semantics>
</math>

 where the 

<math display="inline" id="Sequent_calculus:3">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>


's and 

<math display="inline" id="Sequent_calculus:4">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 are again formulae and 

<math display="inline" id="Sequent_calculus:5">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>n</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\geq 0
  </annotation>
 </semantics>
</math>

. Permutations of the 

<math display="inline" id="Sequent_calculus:6">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>

's are immaterial. In other words, a judgment consists of a list (possibly empty) of formulae on the left-hand side of a <a href="Turnstile_(symbol)" title="wikilink">turnstile</a> symbol "

<math display="inline" id="Sequent_calculus:7">
 <semantics>
  <mo>⊢</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">proves</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash
  </annotation>
 </semantics>
</math>

", with a single formula on the right-hand side.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> The theorems are those formulae 

<math display="inline" id="Sequent_calculus:8">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>


 such that 

<math display="inline" id="Sequent_calculus:9">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash B
  </annotation>
 </semantics>
</math>

 (with an empty left-hand side) is the conclusion of a valid proof. (In some presentations of natural deduction, the 

<math display="inline" id="Sequent_calculus:10">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>

s and the turnstile are not written down explicitly; instead a two-dimensional notation from which they can be inferred is used.)</p>

<p>The standard semantics of a judgment in natural deduction is that it asserts that whenever<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> 

<math display="inline" id="Sequent_calculus:11">
 <semantics>
  <msub>
   <mi>A</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Sequent_calculus:12">
 <semantics>
  <msub>
   <mi>A</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{2}
  </annotation>
 </semantics>
</math>

, etc., are all true, 

<math display="inline" id="Sequent_calculus:13">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>


 will also be true. The judgments</p>

<p>

<math display="block" id="Sequent_calculus:14">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>⊢</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>n</ci>
     </apply>
    </list>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1},\ldots,A_{n}\vdash B
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Sequent_calculus:15">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>A</mi>
       <mn>1</mn>
      </msub>
      <mo>∧</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo>∧</mo>
      <msub>
       <mi>A</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash(A_{1}\land\cdots\land A_{n})\rightarrow B
  </annotation>
 </semantics>
</math>

 are equivalent in the strong sense that a proof of either one may be extended to a proof of the other.</p>
<h3 id="sequent-calculus-systems">Sequent calculus systems</h3>

<p>Finally, <em>sequent calculus</em> generalizes the form of a natural deduction judgment to</p>

<p>

<math display="block" id="Sequent_calculus:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>A</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>A</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>⊢</mo>
    <mrow>
     <msub>
      <mi>B</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>B</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>n</ci>
     </apply>
    </list>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <ci>k</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1},\ldots,A_{n}\vdash B_{1},\ldots,B_{k},
  </annotation>
 </semantics>
</math>

 a syntactic object called a sequent. The formulas on left-hand side of the <a href="Turnstile_(symbol)" title="wikilink">turnstile</a> are called the <em>antecedent</em>, and the formulas on right-hand side are called the <em>succedent</em> or <em>consequent</em>; together they are called <em>cedents</em> or <em>sequents</em>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Again, 

<math display="inline" id="Sequent_calculus:17">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sequent_calculus:18">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{i}
  </annotation>
 </semantics>
</math>


 are formulae, and 

<math display="inline" id="Sequent_calculus:19">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sequent_calculus:20">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 are nonnegative integers, that is, the left-hand-side or the right-hand-side (or neither or both) may be empty. As in natural deduction, theorems are those 

<math display="inline" id="Sequent_calculus:21">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Sequent_calculus:22">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash B
  </annotation>
 </semantics>
</math>

 is the conclusion of a valid proof. The empty sequent, having both cedents empty, is defined to be false.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>The standard semantics of a sequent is an assertion that whenever <em>every</em> 

<math display="inline" id="Sequent_calculus:23">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>


 is true, <em>at least one</em> 

<math display="inline" id="Sequent_calculus:24">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{i}
  </annotation>
 </semantics>
</math>

 will also be true.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> One way to express this is that a comma to the left of the turnstile should be thought of as an "and", and a comma to the right of the turnstile should be thought of as an (inclusive) "or". The sequents</p>

<p>

<math display="block" id="Sequent_calculus:25">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>A</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <msub>
     <mi>B</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>B</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>n</ci>
     </apply>
    </list>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <ci>k</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1},\ldots,A_{n}\vdash B_{1},\ldots,B_{k}
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Sequent_calculus:26">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>A</mi>
       <mn>1</mn>
      </msub>
      <mo>∧</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo>∧</mo>
      <msub>
       <mi>A</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>B</mi>
       <mn>1</mn>
      </msub>
      <mo>∨</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo>∨</mo>
      <msub>
       <mi>B</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <or></or>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash(A_{1}\land\cdots\land A_{n})\rightarrow(B_{1}\lor\cdots\lor B_{k})
  </annotation>
 </semantics>
</math>

 are equivalent in the strong sense that a proof of either one may be extended to a proof of the other.</p>

<p>At first sight, this extension of the judgment form may appear to be a strange complication — it is not motivated by an obvious shortcoming of natural deduction, and it is initially confusing that the comma seems to mean entirely different things on the two sides of the turnstile. However, in a <a href="Classical_logic" title="wikilink">classical context</a> the semantics of the sequent can also (by propositional tautology) be expressed either as</p>

<p>

<math display="block" id="Sequent_calculus:27">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <msub>
      <mi>A</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <msub>
      <mi>A</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>∨</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∨</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <msub>
      <mi>A</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>∨</mo>
    <msub>
     <mi>B</mi>
     <mn>1</mn>
    </msub>
    <mo>∨</mo>
    <msub>
     <mi>B</mi>
     <mn>2</mn>
    </msub>
    <mo>∨</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∨</mo>
    <msub>
     <mi>B</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <or></or>
     <apply>
      <times></times>
      <not></not>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <not></not>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <not></not>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash\neg A_{1}\lor\neg A_{2}\lor\cdots\lor\neg A_{n}\lor B_{1}\lor B_{2}\lor%
\cdots\lor B_{k}
  </annotation>
 </semantics>
</math>

 (at least one of the As is false, or one of the Bs is true) or as</p>

<p>

<math display="block" id="Sequent_calculus:28">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>A</mi>
       <mn>1</mn>
      </msub>
      <mo>∧</mo>
      <msub>
       <mi>A</mi>
       <mn>2</mn>
      </msub>
      <mo>∧</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo>∧</mo>
      <msub>
       <mi>A</mi>
       <mi>n</mi>
      </msub>
      <mo>∧</mo>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <msub>
        <mi>B</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo>∧</mo>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <msub>
        <mi>B</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo>∧</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo>∧</mo>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <msub>
        <mi>B</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <not></not>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <not></not>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <not></not>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <times></times>
       <not></not>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash\neg(A_{1}\land A_{2}\land\cdots\land A_{n}\land\neg B_{1}\land\neg B_{2%
}\land\cdots\land\neg B_{k})
  </annotation>
 </semantics>
</math>

 (it cannot be the case that all of the As are true and all of the Bs are false). In these formulations, the only difference between formulae on either side of the turnstile is that one side is negated. Thus, swapping left for right in a sequent corresponds to negating all of the constituent formulae. This means that a symmetry such as <a href="De_Morgan's_laws" title="wikilink">De Morgan's laws</a>, which manifests itself as logical negation on the semantic level, translates directly into a left-right symmetry of sequents — and indeed, the inference rules in sequent calculus for dealing with conjunction (∧) are mirror images of those dealing with disjunction (∨).</p>

<p>Many logicians feel that this symmetric presentation offers a deeper insight in the structure of the logic than other styles of proof system, where the classical duality of negation is not as apparent in the rules.</p>
<h3 id="distinction-between-natural-deduction-and-sequent-calculus">Distinction between natural deduction and sequent calculus</h3>

<p>Gentzen asserted a sharp distinction between his single-output natural deduction systems (NK and NJ) and his multiple-output sequent calculus systems (LK and LJ). He wrote that the intuitionistic natural deduction system NJ was somewhat ugly.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> He said that the special role of the <a href="law_of_excluded_middle" title="wikilink">excluded middle</a> in the classical natural deduction system NK is removed in the classical sequent calculus system LK.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> He said that the sequent calculus LJ gave more symmetry than natural deduction NJ in the case of intuitionistic logic, as also in the case of classical logic (LK versus NK).<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> Then he said that in addition to these reasons, the sequent calculus with multiple succedent formulas is intended particularly for his principal theorem ("Hauptsatz").<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h3 id="origin-of-word-sequent">Origin of word "sequent"</h3>

<p>The word "sequent" is taken from the word "Sequenz" in Gentzen's 1934 paper.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> Kleene makes the following comment on the translation into English: "Gentzen says 'Sequenz', which we translate as 'sequent', because we have already used 'sequence' for any succession of objects, where the German is 'Folge'."<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h2 id="the-system-lk">The system LK</h2>

<p>This section introduces the rules of the sequent calculus <strong>LK</strong> (which just stands for “<strong>k</strong>lassische Prädikaten<strong>l</strong>ogik”), as introduced by Gentzen in 1934. A (formal) proof in this calculus is a sequence of sequents, where each of the sequents is derivable from sequents appearing earlier in the sequence by using one of the <a href="rule_of_inference" title="wikilink">rules</a> below.</p>
<h3 id="inference-rules">Inference rules</h3>

<p>The following notation will be used:</p>
<ul>
<li>

<math display="inline" id="Sequent_calculus:29">
 <semantics>
  <mo>⊢</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">proves</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash
  </annotation>
 </semantics>
</math>

 known as the <a href="Turnstile_(symbol)" title="wikilink">turnstile</a>, separates the <em>assumptions</em> on the left from the <em>propositions</em> on the right</li>
<li>

<math display="inline" id="Sequent_calculus:30">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sequent_calculus:31">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 denote formulae of first-order predicate logic (one may also restrict this to propositional logic),</li>
<li>

<math display="inline" id="Sequent_calculus:32">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>,</mo>
   <mi mathvariant="normal">Δ</mi>
   <mo>,</mo>
   <mi mathvariant="normal">Σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>normal-Γ</ci>
    <ci>normal-Δ</ci>
    <ci>normal-Σ</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma,\Delta,\Sigma
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Sequent_calculus:33">
 <semantics>
  <mi mathvariant="normal">Π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi
  </annotation>
 </semantics>
</math>


 are finite (possibly empty) sequences of formulae (in fact, the order of formulae do not matter; see subsection <a href="Sequent_calculus#Structural_rules" title="wikilink">Structural Rules</a>), called contexts,
<ul>
<li>when on the <em>left</em> of the 

<math display="inline" id="Sequent_calculus:34">
 <semantics>
  <mo>⊢</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">proves</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash
  </annotation>
 </semantics>
</math>

, the sequence of formulas is considered <em>conjunctively</em> (all assumed to hold at the same time),</li>
<li>while on the <em>right</em> of the 

<math display="inline" id="Sequent_calculus:35">
 <semantics>
  <mo>⊢</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">proves</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash
  </annotation>
 </semantics>
</math>

, the sequence of formulas is considered <em>disjunctively</em> (at least one of the formulas must hold for any assignment of variables),</li>
</ul></li>
<li>

<math display="inline" id="Sequent_calculus:36">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 denotes an arbitrary term,</li>
<li>

<math display="inline" id="Sequent_calculus:37">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sequent_calculus:38">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>


 denote variables.</li>
<li>a variable is said to occur <a href="Free_variables_and_bound_variables" title="wikilink">free</a> within a formula if it occurs outside the scope of quantifiers 

<math display="inline" id="Sequent_calculus:39">
 <semantics>
  <mo>∀</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">for-all</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Sequent_calculus:40">
 <semantics>
  <mo>∃</mo>
  <annotation-xml encoding="MathML-Content">
   <exists></exists>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists
  </annotation>
 </semantics>
</math>

.</li>
<li>

<math display="inline" id="Sequent_calculus:41">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>t</mi>
     <mo>/</mo>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <divide></divide>
      <ci>t</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A[t/x]
  </annotation>
 </semantics>
</math>

 denotes the formula that is obtained by substituting the term 

<math display="inline" id="Sequent_calculus:42">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 for every free occurrence of the variable 

<math display="inline" id="Sequent_calculus:43">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 in formula 

<math display="inline" id="Sequent_calculus:44">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 with the restriction that the term 

<math display="inline" id="Sequent_calculus:45">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 must be free for the variable 

<math display="inline" id="Sequent_calculus:46">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Sequent_calculus:47">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 (i.e., no occurrence of any variable in 

<math display="inline" id="Sequent_calculus:48">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>


 becomes bound in 

<math display="inline" id="Sequent_calculus:49">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>t</mi>
     <mo>/</mo>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <divide></divide>
      <ci>t</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A[t/x]
  </annotation>
 </semantics>
</math>

).</li>
<li>

<math display="inline" id="Sequent_calculus:50">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   WL
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sequent_calculus:51">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   WR
  </annotation>
 </semantics>
</math>

 stand for <em>Weakening Left/Right</em>, 

<math display="inline" id="Sequent_calculus:52">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   CL
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sequent_calculus:53">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   CR
  </annotation>
 </semantics>
</math>


 for <em>Contraction</em>, and 

<math display="inline" id="Sequent_calculus:54">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   PL
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sequent_calculus:55">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   PR
  </annotation>
 </semantics>
</math>

 for <em>Permutation</em>.</li>
</ul>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Axiom:</p></td>
<td style="text-align: left;">
<p>Cut:</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:56">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mi></mi>
     <mrow>
      <mi>A</mi>
      <mo>⊢</mo>
      <mi>A</mi>
     </mrow>
    </mfrac>
   </mstyle>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>A</ci>
      <ci>A</ci>
     </apply>
    </apply>
    <ci>I</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\qquad}{A\vdash A}\quad(I)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:57">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mo>,</mo>
       <mi>A</mi>
       <mi>A</mi>
       <mo>,</mo>
       <mi mathvariant="normal">Σ</mi>
      </mrow>
      <mo>⊢</mo>
      <mi mathvariant="normal">Π</mi>
     </mrow>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mo>,</mo>
       <mi mathvariant="normal">Σ</mi>
      </mrow>
      <mo>⊢</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mo>,</mo>
       <mi mathvariant="normal">Π</mi>
      </mrow>
     </mrow>
    </mfrac>
   </mstyle>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐶𝑢𝑡</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="latexml">proves</csymbol>
       <ci>normal-Γ</ci>
       <list>
        <ci>normal-Δ</ci>
        <ci>A</ci>
        <ci>A</ci>
        <ci>normal-Σ</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="latexml">proves</csymbol>
       <share href="#.cmml">
       </share>
       <ci>normal-Π</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <list>
       <ci>normal-Γ</ci>
       <ci>normal-Σ</ci>
      </list>
      <list>
       <ci>normal-Δ</ci>
       <ci>normal-Π</ci>
      </list>
     </apply>
    </apply>
    <ci>𝐶𝑢𝑡</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma\vdash\Delta,A\qquad A,\Sigma\vdash\Pi}{\Gamma,\Sigma\vdash\Delta%
,\Pi}\quad(\mathit{Cut})
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Left logical rules:</p></td>
<td style="text-align: left;">
<p>Right logical rules:</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:58">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mo>,</mo>
       <mi>A</mi>
      </mrow>
      <mo>⊢</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mo>,</mo>
       <mrow>
        <mi>A</mi>
        <mi mathvariant="italic">and</mi>
        <mi>B</mi>
       </mrow>
      </mrow>
      <mo>⊢</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
    </mfrac>
   </mstyle>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="italic">and</mi>
     <msub>
      <mi>L</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <list>
       <ci>normal-Γ</ci>
       <ci>A</ci>
      </list>
      <ci>normal-Δ</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <list>
       <ci>normal-Γ</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>italic- and</ci>
        <ci>B</ci>
       </apply>
      </list>
      <ci>normal-Δ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>italic- and</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma,A\vdash\Delta}{\Gamma,A\and B\vdash\Delta}\quad({\and}L_{1})
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:59">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mrow>
       <mi>A</mi>
       <mo>,</mo>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
     </mrow>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mrow>
       <mrow>
        <mi>A</mi>
        <mi>B</mi>
       </mrow>
       <mo>,</mo>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
     </mrow>
    </mfrac>
   </mstyle>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>R</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <list>
       <ci>A</ci>
       <ci>normal-Δ</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <list>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>B</ci>
       </apply>
       <ci>normal-Δ</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <cn type="integer">1</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma\vdash A,\Delta}{\Gamma\vdash AB,\Delta}\quad({}R_{1})
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:60">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mo>,</mo>
       <mi>B</mi>
      </mrow>
      <mo>⊢</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mo>,</mo>
       <mrow>
        <mi>A</mi>
        <mi mathvariant="italic">and</mi>
        <mi>B</mi>
       </mrow>
      </mrow>
      <mo>⊢</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
    </mfrac>
   </mstyle>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="italic">and</mi>
     <msub>
      <mi>L</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <list>
       <ci>normal-Γ</ci>
       <ci>B</ci>
      </list>
      <ci>normal-Δ</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <list>
       <ci>normal-Γ</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>italic- and</ci>
        <ci>B</ci>
       </apply>
      </list>
      <ci>normal-Δ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>italic- and</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma,B\vdash\Delta}{\Gamma,A\and B\vdash\Delta}\quad({\and}L_{2})
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:61">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mrow>
       <mi>B</mi>
       <mo>,</mo>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
     </mrow>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mrow>
       <mrow>
        <mi>A</mi>
        <mi>B</mi>
       </mrow>
       <mo>,</mo>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
     </mrow>
    </mfrac>
   </mstyle>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>R</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <list>
       <ci>B</ci>
       <ci>normal-Δ</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <list>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>B</ci>
       </apply>
       <ci>normal-Δ</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma\vdash B,\Delta}{\Gamma\vdash AB,\Delta}\quad({}R_{2})
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:62">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mo>,</mo>
       <mi>A</mi>
      </mrow>
      <mo>⊢</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi mathvariant="normal">Σ</mi>
       <mo>,</mo>
       <mi>B</mi>
      </mrow>
      <mo>⊢</mo>
      <mi mathvariant="normal">Π</mi>
     </mrow>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mo>,</mo>
       <mi mathvariant="normal">Σ</mi>
       <mo>,</mo>
       <mrow>
        <mi>A</mi>
        <mi>B</mi>
       </mrow>
      </mrow>
      <mo>⊢</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mo>,</mo>
       <mi mathvariant="normal">Π</mi>
      </mrow>
     </mrow>
    </mfrac>
   </mstyle>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>L</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="latexml">proves</csymbol>
       <list>
        <ci>normal-Γ</ci>
        <ci>A</ci>
       </list>
       <list>
        <ci>normal-Δ</ci>
        <ci>normal-Σ</ci>
        <ci>B</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="latexml">proves</csymbol>
       <share href="#.cmml">
       </share>
       <ci>normal-Π</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <list>
       <ci>normal-Γ</ci>
       <ci>normal-Σ</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>B</ci>
       </apply>
      </list>
      <list>
       <ci>normal-Δ</ci>
       <ci>normal-Π</ci>
      </list>
     </apply>
    </apply>
    <ci>L</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma,A\vdash\Delta\qquad\Sigma,B\vdash\Pi}{\Gamma,\Sigma,AB\vdash%
\Delta,\Pi}\quad({}L)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:63">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mrow>
       <mi>A</mi>
       <mo>,</mo>
       <mi mathvariant="normal">Δ</mi>
       <mi mathvariant="normal">Σ</mi>
      </mrow>
      <mo>⊢</mo>
      <mrow>
       <mi>B</mi>
       <mo>,</mo>
       <mi mathvariant="normal">Π</mi>
      </mrow>
     </mrow>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mo>,</mo>
       <mi mathvariant="normal">Σ</mi>
      </mrow>
      <mo>⊢</mo>
      <mrow>
       <mrow>
        <mi>A</mi>
        <mi mathvariant="italic">and</mi>
        <mi>B</mi>
       </mrow>
       <mo>,</mo>
       <mi mathvariant="normal">Δ</mi>
       <mo>,</mo>
       <mi mathvariant="normal">Π</mi>
      </mrow>
     </mrow>
    </mfrac>
   </mstyle>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="italic">and</mi>
     <mi>R</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="latexml">proves</csymbol>
       <ci>normal-Γ</ci>
       <list>
        <ci>A</ci>
        <ci>normal-Δ</ci>
        <ci>normal-Σ</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="latexml">proves</csymbol>
       <share href="#.cmml">
       </share>
       <list>
        <ci>B</ci>
        <ci>normal-Π</ci>
       </list>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <list>
       <ci>normal-Γ</ci>
       <ci>normal-Σ</ci>
      </list>
      <list>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>italic- and</ci>
        <ci>B</ci>
       </apply>
       <ci>normal-Δ</ci>
       <ci>normal-Π</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>italic- and</ci>
     <ci>R</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma\vdash A,\Delta\qquad\Sigma\vdash B,\Pi}{\Gamma,\Sigma\vdash A%
\and B,\Delta,\Pi}\quad({\and}R)
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:64">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mrow>
       <mi>A</mi>
       <mo>,</mo>
       <mi mathvariant="normal">Δ</mi>
       <mi mathvariant="normal">Σ</mi>
       <mo>,</mo>
       <mi>B</mi>
      </mrow>
      <mo>⊢</mo>
      <mi mathvariant="normal">Π</mi>
     </mrow>
     <mrow>
      <mrow>
       <mrow>
        <mi mathvariant="normal">Γ</mi>
        <mo>,</mo>
        <mi mathvariant="normal">Σ</mi>
        <mo>,</mo>
        <mi>A</mi>
       </mrow>
       <mo>→</mo>
       <mi>B</mi>
      </mrow>
      <mo>⊢</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mo>,</mo>
       <mi mathvariant="normal">Π</mi>
      </mrow>
     </mrow>
    </mfrac>
   </mstyle>
   <mspace width="veryverythickmathspace">
   </mspace>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi></mi>
     <mo>→</mo>
     <mi>L</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">annotated</csymbol>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="latexml">proves</csymbol>
       <ci>normal-Γ</ci>
       <list>
        <ci>A</ci>
        <ci>normal-Δ</ci>
        <ci>normal-Σ</ci>
        <ci>B</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="latexml">proves</csymbol>
       <share href="#.cmml">
       </share>
       <ci>normal-Π</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <apply>
       <ci>normal-→</ci>
       <list>
        <ci>normal-Γ</ci>
        <ci>normal-Σ</ci>
        <ci>A</ci>
       </list>
       <ci>B</ci>
      </apply>
      <list>
       <ci>normal-Δ</ci>
       <ci>normal-Π</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <csymbol cd="latexml">absent</csymbol>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma\vdash A,\Delta\qquad\Sigma,B\vdash\Pi}{\Gamma,\Sigma,A%
\rightarrow B\vdash\Delta,\Pi}\quad({\rightarrow}L)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:65">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mo>,</mo>
       <mi>A</mi>
      </mrow>
      <mo>⊢</mo>
      <mrow>
       <mi>B</mi>
       <mo>,</mo>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
     </mrow>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mrow>
       <mi>A</mi>
       <mo>→</mo>
       <mrow>
        <mi>B</mi>
        <mo>,</mo>
        <mi mathvariant="normal">Δ</mi>
       </mrow>
      </mrow>
     </mrow>
    </mfrac>
   </mstyle>
   <mspace width="veryverythickmathspace">
   </mspace>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi></mi>
     <mo>→</mo>
     <mi>R</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">annotated</csymbol>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <list>
       <ci>normal-Γ</ci>
       <ci>A</ci>
      </list>
      <list>
       <ci>B</ci>
       <ci>normal-Δ</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>A</ci>
       <list>
        <ci>B</ci>
        <ci>normal-Δ</ci>
       </list>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <csymbol cd="latexml">absent</csymbol>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma,A\vdash B,\Delta}{\Gamma\vdash A\rightarrow B,\Delta}\quad({%
\rightarrow}R)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:66">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mrow>
       <mi>A</mi>
       <mo>,</mo>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
     </mrow>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mo>,</mo>
       <mrow>
        <mi mathvariant="normal">¬</mi>
        <mi>A</mi>
       </mrow>
      </mrow>
      <mo>⊢</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
    </mfrac>
   </mstyle>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>L</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <list>
       <ci>A</ci>
       <ci>normal-Δ</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <list>
       <ci>normal-Γ</ci>
       <apply>
        <times></times>
        <not></not>
        <ci>A</ci>
       </apply>
      </list>
      <ci>normal-Δ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>L</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma\vdash A,\Delta}{\Gamma,\lnot A\vdash\Delta}\quad({\lnot}L)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:67">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mo>,</mo>
       <mi>A</mi>
      </mrow>
      <mo>⊢</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mrow>
       <mrow>
        <mi mathvariant="normal">¬</mi>
        <mi>A</mi>
       </mrow>
       <mo>,</mo>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
     </mrow>
    </mfrac>
   </mstyle>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>R</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <list>
       <ci>normal-Γ</ci>
       <ci>A</ci>
      </list>
      <ci>normal-Δ</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <list>
       <apply>
        <times></times>
        <not></not>
        <ci>A</ci>
       </apply>
       <ci>normal-Δ</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>R</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma,A\vdash\Delta}{\Gamma\vdash\lnot A,\Delta}\quad({\lnot}R)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:68">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mo>,</mo>
       <mrow>
        <mi>A</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mrow>
          <mi>t</mi>
          <mo>/</mo>
          <mi>x</mi>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>⊢</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mo>,</mo>
       <mrow>
        <mo>∀</mo>
        <mrow>
         <mi>x</mi>
         <mi>A</mi>
        </mrow>
       </mrow>
      </mrow>
      <mo>⊢</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
    </mfrac>
   </mstyle>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>∀</mo>
     <mi>L</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <list>
       <ci>normal-Γ</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <divide></divide>
          <ci>t</ci>
          <ci>x</ci>
         </apply>
        </apply>
       </apply>
      </list>
      <ci>normal-Δ</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <list>
       <ci>normal-Γ</ci>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>A</ci>
        </apply>
       </apply>
      </list>
      <ci>normal-Δ</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>L</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma,A[t/x]\vdash\Delta}{\Gamma,\forall xA\vdash\Delta}\quad({\forall%
}L)
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:69">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mrow>
       <mrow>
        <mi>A</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mrow>
          <mi>y</mi>
          <mo>/</mo>
          <mi>x</mi>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
     </mrow>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mrow>
       <mrow>
        <mo>∀</mo>
        <mrow>
         <mi>x</mi>
         <mi>A</mi>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
     </mrow>
    </mfrac>
   </mstyle>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>∀</mo>
     <mi>R</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <list>
       <apply>
        <times></times>
        <ci>A</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <divide></divide>
          <ci>y</ci>
          <ci>x</ci>
         </apply>
        </apply>
       </apply>
       <ci>normal-Δ</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <list>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>A</ci>
        </apply>
       </apply>
       <ci>normal-Δ</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>R</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma\vdash A[y/x],\Delta}{\Gamma\vdash\forall xA,\Delta}\quad({%
\forall}R)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:70">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mo>,</mo>
       <mrow>
        <mi>A</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mrow>
          <mi>y</mi>
          <mo>/</mo>
          <mi>x</mi>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>⊢</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mo>,</mo>
       <mrow>
        <mo>∃</mo>
        <mrow>
         <mi>x</mi>
         <mi>A</mi>
        </mrow>
       </mrow>
      </mrow>
      <mo>⊢</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
    </mfrac>
   </mstyle>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>∃</mo>
     <mi>L</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <list>
       <ci>normal-Γ</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <divide></divide>
          <ci>y</ci>
          <ci>x</ci>
         </apply>
        </apply>
       </apply>
      </list>
      <ci>normal-Δ</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <list>
       <ci>normal-Γ</ci>
       <apply>
        <exists></exists>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>A</ci>
        </apply>
       </apply>
      </list>
      <ci>normal-Δ</ci>
     </apply>
    </apply>
    <apply>
     <exists></exists>
     <ci>L</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma,A[y/x]\vdash\Delta}{\Gamma,\exists xA\vdash\Delta}\quad({\exists%
}L)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:71">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mrow>
       <mrow>
        <mi>A</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mrow>
          <mi>t</mi>
          <mo>/</mo>
          <mi>x</mi>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
     </mrow>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mrow>
       <mrow>
        <mo>∃</mo>
        <mrow>
         <mi>x</mi>
         <mi>A</mi>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
     </mrow>
    </mfrac>
   </mstyle>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>∃</mo>
     <mi>R</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <list>
       <apply>
        <times></times>
        <ci>A</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <divide></divide>
          <ci>t</ci>
          <ci>x</ci>
         </apply>
        </apply>
       </apply>
       <ci>normal-Δ</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <list>
       <apply>
        <exists></exists>
        <apply>
         <times></times>
         <ci>x</ci>
         <ci>A</ci>
        </apply>
       </apply>
       <ci>normal-Δ</ci>
      </list>
     </apply>
    </apply>
    <apply>
     <exists></exists>
     <ci>R</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma\vdash A[t/x],\Delta}{\Gamma\vdash\exists xA,\Delta}\quad({%
\exists}R)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Left structural rules:</p></td>
<td style="text-align: left;">
<p>Right structural rules:</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:72">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mo>,</mo>
       <mi>A</mi>
      </mrow>
      <mo>⊢</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
    </mfrac>
   </mstyle>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝑊𝐿</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <ci>normal-Δ</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <list>
       <ci>normal-Γ</ci>
       <ci>A</ci>
      </list>
      <ci>normal-Δ</ci>
     </apply>
    </apply>
    <ci>𝑊𝐿</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma\vdash\Delta}{\Gamma,A\vdash\Delta}\quad(\mathit{WL})
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:73">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mrow>
       <mi>A</mi>
       <mo>,</mo>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
     </mrow>
    </mfrac>
   </mstyle>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝑊𝑅</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <ci>normal-Δ</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <list>
       <ci>A</ci>
       <ci>normal-Δ</ci>
      </list>
     </apply>
    </apply>
    <ci>𝑊𝑅</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma\vdash\Delta}{\Gamma\vdash A,\Delta}\quad(\mathit{WR})
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:74">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mo>,</mo>
       <mi>A</mi>
       <mo>,</mo>
       <mi>A</mi>
      </mrow>
      <mo>⊢</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
     <mrow>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mo>,</mo>
       <mi>A</mi>
      </mrow>
      <mo>⊢</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
    </mfrac>
   </mstyle>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐶𝐿</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <list>
       <ci>normal-Γ</ci>
       <ci>A</ci>
       <ci>A</ci>
      </list>
      <ci>normal-Δ</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <list>
       <ci>normal-Γ</ci>
       <ci>A</ci>
      </list>
      <ci>normal-Δ</ci>
     </apply>
    </apply>
    <ci>𝐶𝐿</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma,A,A\vdash\Delta}{\Gamma,A\vdash\Delta}\quad(\mathit{CL})
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:75">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mrow>
       <mi>A</mi>
       <mo>,</mo>
       <mi>A</mi>
       <mo>,</mo>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
     </mrow>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mrow>
       <mi>A</mi>
       <mo>,</mo>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
     </mrow>
    </mfrac>
   </mstyle>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐶𝑅</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <list>
       <ci>A</ci>
       <ci>A</ci>
       <ci>normal-Δ</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <list>
       <ci>A</ci>
       <ci>normal-Δ</ci>
      </list>
     </apply>
    </apply>
    <ci>𝐶𝑅</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma\vdash A,A,\Delta}{\Gamma\vdash A,\Delta}\quad(\mathit{CR})
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:76">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mrow>
       <msub>
        <mi mathvariant="normal">Γ</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi>A</mi>
       <mo>,</mo>
       <mi>B</mi>
       <mo>,</mo>
       <msub>
        <mi mathvariant="normal">Γ</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo>⊢</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
     <mrow>
      <mrow>
       <msub>
        <mi mathvariant="normal">Γ</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi>B</mi>
       <mo>,</mo>
       <mi>A</mi>
       <mo>,</mo>
       <msub>
        <mi mathvariant="normal">Γ</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo>⊢</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
    </mfrac>
   </mstyle>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝑃𝐿</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Γ</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>A</ci>
       <ci>B</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Γ</ci>
        <cn type="integer">2</cn>
       </apply>
      </list>
      <ci>normal-Δ</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Γ</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>B</ci>
       <ci>A</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Γ</ci>
        <cn type="integer">2</cn>
       </apply>
      </list>
      <ci>normal-Δ</ci>
     </apply>
    </apply>
    <ci>𝑃𝐿</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma_{1},A,B,\Gamma_{2}\vdash\Delta}{\Gamma_{1},B,A,\Gamma_{2}\vdash%
\Delta}\quad(\mathit{PL})
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:77">
 <semantics>
  <mrow>
   <mstyle displaystyle="true">
    <mfrac>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mrow>
       <msub>
        <mi mathvariant="normal">Δ</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi>A</mi>
       <mo>,</mo>
       <mi>B</mi>
       <mo>,</mo>
       <msub>
        <mi mathvariant="normal">Δ</mi>
        <mn>2</mn>
       </msub>
      </mrow>
     </mrow>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>⊢</mo>
      <mrow>
       <msub>
        <mi mathvariant="normal">Δ</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi>B</mi>
       <mo>,</mo>
       <mi>A</mi>
       <mo>,</mo>
       <msub>
        <mi mathvariant="normal">Δ</mi>
        <mn>2</mn>
       </msub>
      </mrow>
     </mrow>
    </mfrac>
   </mstyle>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝑃𝑅</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Δ</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>A</ci>
       <ci>B</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Δ</ci>
        <cn type="integer">2</cn>
       </apply>
      </list>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <ci>normal-Γ</ci>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Δ</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>B</ci>
       <ci>A</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Δ</ci>
        <cn type="integer">2</cn>
       </apply>
      </list>
     </apply>
    </apply>
    <ci>𝑃𝑅</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma\vdash\Delta_{1},A,B,\Delta_{2}}{\Gamma\vdash\Delta_{1},B,A,%
\Delta_{2}}\quad(\mathit{PR})
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p><em>Restrictions: In the rules 

<math display="inline" id="Sequent_calculus:78">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo>∀</mo>
    <mi>R</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ({\forall}R)
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Sequent_calculus:79">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo>∃</mo>
    <mi>L</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ({\exists}L)
  </annotation>
 </semantics>
</math>

, the variable 

<math display="inline" id="Sequent_calculus:80">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 must not occur free within 

<math display="inline" id="Sequent_calculus:81">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sequent_calculus:82">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

. Alternatively, the variable 

<math display="inline" id="Sequent_calculus:83">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>


 must not appear anywhere in the respective lower sequents.</em></p>
<h3 id="an-intuitive-explanation">An intuitive explanation</h3>

<p>The above rules can be divided into two major groups: <em>logical</em> and <em>structural</em> ones. Each of the logical rules introduces a new logical formula either on the left or on the right of the <a href="Turnstile_(symbol)" title="wikilink">turnstile</a> 

<math display="inline" id="Sequent_calculus:84">
 <semantics>
  <mo>⊢</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">proves</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash
  </annotation>
 </semantics>
</math>

. In contrast, the structural rules operate on the structure of the sequents, ignoring the exact shape of the formulae. The two exceptions to this general scheme are the axiom of identity (I) and the rule of (Cut).</p>

<p>Although stated in a formal way, the above rules allow for a very intuitive reading in terms of classical logic. Consider, for example, the rule 

<math display="inline" id="Sequent_calculus:85">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi mathvariant="italic">and</mi>
    <msub>
     <mi>L</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>italic- and</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ({\and}L_{1})
  </annotation>
 </semantics>
</math>

. It says that, whenever one can prove that 

<math display="inline" id="Sequent_calculus:86">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

 can be concluded from some sequence of formulae that contain 

<math display="inline" id="Sequent_calculus:87">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, then one can also conclude 

<math display="inline" id="Sequent_calculus:88">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>


 from the (stronger) assumption, that 

<math display="inline" id="Sequent_calculus:89">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi mathvariant="italic">and</mi>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>italic- and</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\and B
  </annotation>
 </semantics>
</math>

 holds. Likewise, the rule 

<math display="inline" id="Sequent_calculus:90">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>R</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ({\neg}R)
  </annotation>
 </semantics>
</math>

 states that, if 

<math display="inline" id="Sequent_calculus:91">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

 and A suffice to conclude 

<math display="inline" id="Sequent_calculus:92">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

, then from Γ alone one can either still conclude 

<math display="inline" id="Sequent_calculus:93">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>


 or A must be false, i.e. 

<math display="inline" id="Sequent_calculus:94">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\neg}A
  </annotation>
 </semantics>
</math>

 holds. All the rules can be interpreted in this way.</p>

<p>For an intuition about the quantifier rules, consider the rule 

<math display="inline" id="Sequent_calculus:95">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo>∀</mo>
    <mi>R</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ({\forall}R)
  </annotation>
 </semantics>
</math>

. Of course concluding that 

<math display="inline" id="Sequent_calculus:96">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mrow>
    <mi>x</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall{x}A
  </annotation>
 </semantics>
</math>

 holds just from the fact that 

<math display="inline" id="Sequent_calculus:97">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>y</mi>
     <mo>/</mo>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <divide></divide>
      <ci>y</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A[y/x]
  </annotation>
 </semantics>
</math>

 is true is not in general possible. If, however, the variable y is not mentioned elsewhere (i.e. it can still be chosen freely, without influencing the other formulae), then one may assume, that 

<math display="inline" id="Sequent_calculus:98">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>y</mi>
     <mo>/</mo>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <divide></divide>
      <ci>y</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A[y/x]
  </annotation>
 </semantics>
</math>


 holds for any value of y. The other rules should then be pretty straightforward.</p>

<p>Instead of viewing the rules as descriptions for legal derivations in predicate logic, one may also consider them as instructions for the construction of a proof for a given statement. In this case the rules can be read bottom-up; for example, 

<math display="inline" id="Sequent_calculus:99">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi mathvariant="italic">and</mi>
    <mi>R</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>italic- and</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ({\and}R)
  </annotation>
 </semantics>
</math>

 says that, to prove that 

<math display="inline" id="Sequent_calculus:100">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi mathvariant="italic">and</mi>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>italic- and</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\and B
  </annotation>
 </semantics>
</math>

 follows from the assumptions 

<math display="inline" id="Sequent_calculus:101">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sequent_calculus:102">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

, it suffices to prove that A can be concluded from 

<math display="inline" id="Sequent_calculus:103">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>


 and B can be concluded from 

<math display="inline" id="Sequent_calculus:104">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

, respectively. Note that, given some antecedent, it is not clear how this is to be split into 

<math display="inline" id="Sequent_calculus:105">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sequent_calculus:106">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

. However, there are only finitely many possibilities to be checked since the antecedent by assumption is finite. This also illustrates how proof theory can be viewed as operating on proofs in a combinatorial fashion: given proofs for both A and B, one can construct a proof for A∧B.</p>

<p>When looking for some proof, most of the rules offer more or less direct recipes of how to do this. The rule of cut is different: It states that, when a formula A can be concluded and this formula may also serve as a premise for concluding other statements, then the formula A can be "cut out" and the respective derivations are joined. When constructing a proof bottom-up, this creates the problem of guessing A (since it does not appear at all below). The <a href="cut-elimination_theorem" title="wikilink">cut-elimination theorem</a> is thus crucial to the applications of sequent calculus in <a href="automated_deduction" title="wikilink">automated deduction</a>: it states that all uses of the cut rule can be eliminated from a proof, implying that any provable sequent can be given a <em>cut-free</em> proof.</p>

<p>The second rule that is somewhat special is the axiom of identity (I). The intuitive reading of this is obvious: every formula proves itself. Like the cut rule, the axiom of identity is somewhat redundant: the <a href="completeness_of_atomic_initial_sequents" title="wikilink">completeness of atomic initial sequents</a> states that the rule can be restricted to <a href="atomic_formula" title="wikilink">atomic formulas</a> without any loss of provability.</p>

<p>Observe that all rules have mirror companions, except the ones for implication. This reflects the fact that the usual language of first-order logic does not include the "is not implied by" connective 

<math display="inline" id="Sequent_calculus:107">
 <semantics>
  <mo>↚</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>↚</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not\leftarrow
  </annotation>
 </semantics>
</math>

 that would be the De Morgan dual of implication. Adding such a connective with its natural rules would make the calculus completely left-right symmetric.</p>
<h3 id="example-derivations">Example derivations</h3>

<p>Here is the derivation of "

<math display="inline" id="Sequent_calculus:108">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mrow>
    <mi>A</mi>
    <mi mathvariant="normal">¬</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <ci>A</ci>
     <not></not>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash A\lnot A
  </annotation>
 </semantics>
</math>


", known as the <em><a href="Law_of_excluded_middle" title="wikilink">Law of excluded middle</a></em> (<em>tertium non datur</em> in Latin).</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:109">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>I</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (I)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:110">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>⊢</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>A</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\vdash A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:111">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>R</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lnot R)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:112">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
    </mrow>
    <mo>,</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <list>
     <apply>
      <times></times>
      <not></not>
      <ci>A</ci>
     </apply>
     <ci>A</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash\lnot A,A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:113">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>R</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (R_{2})
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:114">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
    </mrow>
    <mo>,</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <list>
     <apply>
      <times></times>
      <ci>A</ci>
      <not></not>
      <ci>A</ci>
     </apply>
     <ci>A</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash A\lnot A,A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:115">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>P</mi>
    <mi>R</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (PR)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:116">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mrow>
    <mi>A</mi>
    <mo>,</mo>
    <mrow>
     <mi>A</mi>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <list>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <not></not>
      <ci>A</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash A,A\lnot A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:117">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>R</mi>
    <mn>1</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (R_{1})
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:118">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>A</mi>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <list>
     <apply>
      <times></times>
      <ci>A</ci>
      <not></not>
      <ci>A</ci>
     </apply>
     <apply>
      <times></times>
      <ci>A</ci>
      <not></not>
      <ci>A</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash A\lnot A,A\lnot A
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:119">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>C</mi>
    <mi>R</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (CR)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:120">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mrow>
    <mi>A</mi>
    <mi mathvariant="normal">¬</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <ci>A</ci>
     <not></not>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash A\lnot A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
</tbody>
</table>

<p>Next is the proof of a simple fact involving quantifiers. Note that the converse is not true, and its falsity can be seen when attempting to derive it bottom-up, because an existing free variable cannot be used in substitution in the rules 

<math display="inline" id="Sequent_calculus:121">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo>∀</mo>
    <mi>R</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall R)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sequent_calculus:122">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo>∃</mo>
    <mi>L</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\exists L)
  </annotation>
 </semantics>
</math>

.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:123">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>I</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (I)
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:124">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <apply>
     <times></times>
     <ci>p</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x,y)\vdash p(x,y)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:125">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo>∀</mo>
    <mi>L</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall L)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:126">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>p</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\left(p(x,y)\right)\vdash p(x,y)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:127">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo>∃</mo>
    <mi>R</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\exists R)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:128">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\left(p(x,y)\right)\vdash\exists y\left(p(x,y)\right)
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:129">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo>∃</mo>
    <mi>L</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\exists L)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:130">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mo>∀</mo>
       <mrow>
        <mi>x</mi>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mi>p</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo>,</mo>
           <mi>y</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <times></times>
        <ci>x</ci>
        <apply>
         <times></times>
         <ci>p</ci>
         <interval closure="open">
          <ci>x</ci>
          <ci>y</ci>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists y\left(\forall x\left(p(x,y)\right)\right)\vdash\exists y\left(p(x,y)\right)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:131">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo>∀</mo>
    <mi>R</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall R)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:132">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mo>∀</mo>
       <mrow>
        <mi>x</mi>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mi>p</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo>,</mo>
           <mi>y</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mo>∃</mo>
       <mrow>
        <mi>y</mi>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mi>p</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo>,</mo>
           <mi>y</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <times></times>
        <ci>x</ci>
        <apply>
         <times></times>
         <ci>p</ci>
         <interval closure="open">
          <ci>x</ci>
          <ci>y</ci>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <exists></exists>
       <apply>
        <times></times>
        <ci>y</ci>
        <apply>
         <times></times>
         <ci>p</ci>
         <interval closure="open">
          <ci>x</ci>
          <ci>y</ci>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists y\left(\forall x\left(p(x,y)\right)\right)\vdash\forall x\left(\exists
y%
\left(p(x,y)\right)\right)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
</tbody>
</table>

<p>For something more interesting we shall prove 

<math display="inline" id="Sequent_calculus:133">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mrow>
    <mo>(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mrow>
     <mo>(</mo>
     <mi>B</mi>
     <mi>C</mi>
     <mo>)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo>(</mo>
      <mi>B</mi>
      <mo>→</mo>
      <mi mathvariant="normal">¬</mi>
      <mi>A</mi>
      <mo>)</mo>
     </mrow>
     <mi mathvariant="italic">and</mi>
     <mi mathvariant="normal">¬</mi>
     <mi>C</mi>
     <mo>)</mo>
    </mrow>
    <mo>→</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>A</mi>
    <mo>)</mo>
   </mrow>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-→</ci>
       <not></not>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">and</csymbol>
      <not></not>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <not></not>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\left(A\rightarrow\left(BC\right)\right)\rightarrow\left(\left(\left(B%
\rightarrow\lnot A\right)\and\lnot C\right)\rightarrow\lnot A\right)\right)
  </annotation>
 </semantics>
</math>


. It is straightforward to find the derivation, which exemplifies the usefulness of LK in automated proving.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:134">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>I</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (I)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:135">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>⊢</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>A</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\vdash A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:136">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>R</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lnot R)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:137">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
    </mrow>
    <mo>,</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <list>
     <apply>
      <times></times>
      <not></not>
      <ci>A</ci>
     </apply>
     <ci>A</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash\lnot A,A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:138">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>P</mi>
    <mi>R</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (PR)
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:139">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mrow>
    <mi>A</mi>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <list>
     <ci>A</ci>
     <apply>
      <times></times>
      <not></not>
      <ci>A</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash A,\lnot A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>  </p></td>
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>|  </p></td>
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:140">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>I</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (I)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:141">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>⊢</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>B</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\vdash B
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>  </p></td>
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>|  </p></td>
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:142">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>I</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (I)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:143">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>⊢</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>C</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\vdash C
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>rowspan=2 

<math display="inline" id="Sequent_calculus:144">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>L</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (L)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:145">
 <semantics>
  <mrow>
   <mrow>
    <mi>B</mi>
    <mi>C</mi>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mi>B</mi>
    <mo>,</mo>
    <mi>C</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <apply>
     <times></times>
     <ci>B</ci>
     <ci>C</ci>
    </apply>
    <list>
     <ci>B</ci>
     <ci>C</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   BC\vdash B,C
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:146">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>P</mi>
    <mi>R</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (PR)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:147">
 <semantics>
  <mrow>
   <mrow>
    <mi>B</mi>
    <mi>C</mi>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mi>C</mi>
    <mo>,</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <apply>
     <times></times>
     <ci>B</ci>
     <ci>C</ci>
    </apply>
    <list>
     <ci>C</ci>
     <ci>B</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   BC\vdash C,B
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:148">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>L</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lnot L)
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:149">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>B</mi>
     <mi>C</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>C</mi>
    </mrow>
   </mrow>
   <mo>⊢</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <list>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>C</ci>
     </apply>
     <apply>
      <times></times>
      <not></not>
      <ci>C</ci>
     </apply>
    </list>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   BC,\lnot C\vdash B
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>  </p></td>
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:150">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>I</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (I)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:151">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>A</mi>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <apply>
     <times></times>
     <not></not>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lnot A\vdash\lnot A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>rowspan=2 

<math display="inline" id="Sequent_calculus:152">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi></mi>
    <mo>→</mo>
    <mi>L</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <csymbol cd="latexml">absent</csymbol>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\rightarrow L)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:153">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mi>B</mi>
    <mi>C</mi>
    <mo>)</mo>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">¬</mi>
   <mi>C</mi>
   <mo>,</mo>
   <mrow>
    <mo>(</mo>
    <mi>B</mi>
    <mo>→</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>A</mi>
    <mo>)</mo>
   </mrow>
   <mo>⊢</mo>
   <mi mathvariant="normal">¬</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <not></not>
    <csymbol cd="unknown">C</csymbol>
    <ci>normal-,</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-→</ci>
     <not></not>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proves</csymbol>
    <not></not>
    <csymbol cd="unknown">A</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(BC\right),\lnot C,\left(B\rightarrow\lnot A\right)\vdash\lnot A
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:154">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi mathvariant="italic">and</mi>
    <msub>
     <mi>L</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>italic- and</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\and L_{1})
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:155">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mi>B</mi>
    <mi>C</mi>
    <mo>)</mo>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">¬</mi>
   <mi>C</mi>
   <mo>,</mo>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>(</mo>
     <mi>B</mi>
     <mo>→</mo>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
     <mo>)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi mathvariant="normal">¬</mi>
    <mi>C</mi>
    <mo>)</mo>
   </mrow>
   <mo>⊢</mo>
   <mi mathvariant="normal">¬</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <not></not>
    <csymbol cd="unknown">C</csymbol>
    <ci>normal-,</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-→</ci>
      <not></not>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <not></not>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proves</csymbol>
    <not></not>
    <csymbol cd="unknown">A</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(BC\right),\lnot C,\left(\left(B\rightarrow\lnot A\right)\and\lnot C%
\right)\vdash\lnot A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:156">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>P</mi>
    <mi>L</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (PL)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:157">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mi>B</mi>
    <mi>C</mi>
    <mo>)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>(</mo>
     <mi>B</mi>
     <mo>→</mo>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
     <mo>)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi mathvariant="normal">¬</mi>
    <mi>C</mi>
    <mo>)</mo>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">¬</mi>
   <mi>C</mi>
   <mo>⊢</mo>
   <mi mathvariant="normal">¬</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-→</ci>
      <not></not>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <not></not>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <not></not>
    <csymbol cd="unknown">C</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <not></not>
    <csymbol cd="unknown">A</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(BC\right),\left(\left(B\rightarrow\lnot A\right)\and\lnot C\right),\lnot
C%
\vdash\lnot A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:158">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi mathvariant="italic">and</mi>
    <msub>
     <mi>L</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>italic- and</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\and L_{2})
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:159">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mi>B</mi>
    <mi>C</mi>
    <mo>)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>(</mo>
     <mi>B</mi>
     <mo>→</mo>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
     <mo>)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi mathvariant="normal">¬</mi>
    <mi>C</mi>
    <mo>)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>(</mo>
     <mi>B</mi>
     <mo>→</mo>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
     <mo>)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi mathvariant="normal">¬</mi>
    <mi>C</mi>
    <mo>)</mo>
   </mrow>
   <mo>⊢</mo>
   <mi mathvariant="normal">¬</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-→</ci>
      <not></not>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <not></not>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-→</ci>
      <not></not>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <not></not>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proves</csymbol>
    <not></not>
    <csymbol cd="unknown">A</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(BC\right),\left(\left(B\rightarrow\lnot A\right)\and\lnot C\right),\left%
(\left(B\rightarrow\lnot A\right)\and\lnot C\right)\vdash\lnot A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:160">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>C</mi>
    <mi>L</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (CL)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:161">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mi>B</mi>
    <mi>C</mi>
    <mo>)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>(</mo>
     <mi>B</mi>
     <mo>→</mo>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
     <mo>)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi mathvariant="normal">¬</mi>
    <mi>C</mi>
    <mo>)</mo>
   </mrow>
   <mo>⊢</mo>
   <mi mathvariant="normal">¬</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-→</ci>
      <not></not>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <not></not>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proves</csymbol>
    <not></not>
    <csymbol cd="unknown">A</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(BC\right),\left(\left(B\rightarrow\lnot A\right)\and\lnot C\right)\vdash\lnot
A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:162">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>P</mi>
    <mi>L</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (PL)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:163">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>(</mo>
     <mi>B</mi>
     <mo>→</mo>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
     <mo>)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi mathvariant="normal">¬</mi>
    <mi>C</mi>
    <mo>)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo>(</mo>
    <mi>B</mi>
    <mi>C</mi>
    <mo>)</mo>
   </mrow>
   <mo>⊢</mo>
   <mi mathvariant="normal">¬</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-→</ci>
      <not></not>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <not></not>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proves</csymbol>
    <not></not>
    <csymbol cd="unknown">A</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\left(B\rightarrow\lnot A\right)\and\lnot C\right),\left(BC\right)\vdash\lnot
A
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>rowspan=2 

<math display="inline" id="Sequent_calculus:164">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi></mi>
    <mo>→</mo>
    <mi>L</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <csymbol cd="latexml">absent</csymbol>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\rightarrow L)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:165">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>(</mo>
     <mi>B</mi>
     <mo>→</mo>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
     <mo>)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi mathvariant="normal">¬</mi>
    <mi>C</mi>
    <mo>)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo>(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mrow>
     <mo>(</mo>
     <mi>B</mi>
     <mi>C</mi>
     <mo>)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mo>⊢</mo>
   <mi mathvariant="normal">¬</mi>
   <mi>A</mi>
   <mo>,</mo>
   <mi mathvariant="normal">¬</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-→</ci>
      <not></not>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <not></not>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proves</csymbol>
    <not></not>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-,</ci>
    <not></not>
    <csymbol cd="unknown">A</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\left(B\rightarrow\lnot A\right)\and\lnot C\right),\left(A\rightarrow%
\left(BC\right)\right)\vdash\lnot A,\lnot A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:166">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>C</mi>
    <mi>R</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (CR)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:167">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>(</mo>
     <mi>B</mi>
     <mo>→</mo>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
     <mo>)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi mathvariant="normal">¬</mi>
    <mi>C</mi>
    <mo>)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo>(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mrow>
     <mo>(</mo>
     <mi>B</mi>
     <mi>C</mi>
     <mo>)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mo>⊢</mo>
   <mi mathvariant="normal">¬</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-→</ci>
      <not></not>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <not></not>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proves</csymbol>
    <not></not>
    <csymbol cd="unknown">A</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\left(B\rightarrow\lnot A\right)\and\lnot C\right),\left(A\rightarrow%
\left(BC\right)\right)\vdash\lnot A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:168">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>P</mi>
    <mi>L</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (PL)
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:169">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mrow>
     <mo>(</mo>
     <mi>B</mi>
     <mi>C</mi>
     <mo>)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>(</mo>
     <mi>B</mi>
     <mo>→</mo>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
     <mo>)</mo>
    </mrow>
    <mi mathvariant="italic">and</mi>
    <mi mathvariant="normal">¬</mi>
    <mi>C</mi>
    <mo>)</mo>
   </mrow>
   <mo>⊢</mo>
   <mi mathvariant="normal">¬</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-→</ci>
      <not></not>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">and</csymbol>
     <not></not>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proves</csymbol>
    <not></not>
    <csymbol cd="unknown">A</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(A\rightarrow\left(BC\right)\right),\left(\left(B\rightarrow\lnot A\right%
)\and\lnot C\right)\vdash\lnot A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:170">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi></mi>
    <mo>→</mo>
    <mi>R</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <csymbol cd="latexml">absent</csymbol>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\rightarrow R)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:171">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mrow>
     <mo>(</mo>
     <mi>B</mi>
     <mi>C</mi>
     <mo>)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo>(</mo>
      <mi>B</mi>
      <mo>→</mo>
      <mi mathvariant="normal">¬</mi>
      <mi>A</mi>
      <mo>)</mo>
     </mrow>
     <mi mathvariant="italic">and</mi>
     <mi mathvariant="normal">¬</mi>
     <mi>C</mi>
     <mo>)</mo>
    </mrow>
    <mo>→</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>A</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proves</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-→</ci>
       <not></not>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">and</csymbol>
      <not></not>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <not></not>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(A\rightarrow\left(BC\right)\right)\vdash\left(\left(\left(B\rightarrow%
\lnot A\right)\and\lnot C\right)\rightarrow\lnot A\right)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Sequent_calculus:172">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi></mi>
    <mo>→</mo>
    <mi>R</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <csymbol cd="latexml">absent</csymbol>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\rightarrow R)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>align=center style='border-top:1px solid black;' 

<math display="inline" id="Sequent_calculus:173">
 <semantics>
  <mrow>
   <mo>⊢</mo>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>(</mo>
     <mi>A</mi>
     <mo>→</mo>
     <mrow>
      <mo>(</mo>
      <mi>B</mi>
      <mi>C</mi>
      <mo>)</mo>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mo>(</mo>
       <mi>B</mi>
       <mo>→</mo>
       <mi mathvariant="normal">¬</mi>
       <mi>A</mi>
       <mo>)</mo>
      </mrow>
      <mi mathvariant="italic">and</mi>
      <mi mathvariant="normal">¬</mi>
      <mi>C</mi>
      <mo>)</mo>
     </mrow>
     <mo>→</mo>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
     <mo>)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-→</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">B</csymbol>
       <csymbol cd="unknown">C</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">B</csymbol>
        <ci>normal-→</ci>
        <not></not>
        <csymbol cd="unknown">A</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <csymbol cd="unknown">and</csymbol>
       <not></not>
       <csymbol cd="unknown">C</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <not></not>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash\left(\left(A\rightarrow\left(BC\right)\right)\rightarrow\left(\left(%
\left(B\rightarrow\lnot A\right)\and\lnot C\right)\rightarrow\lnot A\right)\right)
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p> </p></td>
</tr>
</tbody>
</table>

<p>These derivations also emphasize the strictly formal structure of the sequent calculus. For example, the logical rules as defined above always act on a formula immediately adjacent to the turnstile, such that the permutation rules are necessary. Note, however, that this is in part an artifact of the presentation, in the original style of Gentzen. A common simplification involves the use of <a href="multiset" title="wikilink">multisets</a> of formulas in the interpretation of the sequent, rather than sequences, eliminating the need for an explicit permutation rule. This corresponds to shifting commutativity of assumptions and derivations outside the sequent calculus, whereas LK embeds it within the system itself.</p>
<h3 id="structural-rules">Structural rules</h3>

<p>The structural rules deserve some additional discussion.</p>

<p>Weakening (W) allows the addition of arbitrary elements to a sequence. Intuitively, this is allowed in the antecedent because we can always restrict the scope of our proof (if all cars have wheels, then it's safe to say that all black cars have wheels); and in the succedent because we can always allow for alternative conclusions (if all cars have wheels, then it's safe to say that all cars have either wheels or wings).</p>

<p>Contraction (C) and Permutation (P) assure that neither the order (P) nor the multiplicity of occurrences (C) of elements of the sequences matters. Thus, one could instead of <a href="sequence" title="wikilink">sequences</a> also consider <a href="Set_(mathematics)" title="wikilink">sets</a>.</p>

<p>The extra effort of using sequences, however, is justified since part or all of the structural rules may be omitted. Doing so, one obtains the so-called <a href="substructural_logic" title="wikilink">substructural logics</a>.</p>
<h3 id="properties-of-the-system-lk">Properties of the system LK</h3>

<p>This system of rules can be shown to be both <a href="soundness" title="wikilink">sound</a> and <a href="completeness_(logic)" title="wikilink">complete</a> with respect to first-order logic, i.e. a statement 

<math display="inline" id="Sequent_calculus:174">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>A</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\,
  </annotation>
 </semantics>
</math>

 follows <a href="semantics" title="wikilink">semantically</a> from a set of premises 

<math display="inline" id="Sequent_calculus:175">
 <semantics>
  <mpadded width="+1.7pt">
   <mi mathvariant="normal">Γ</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\,
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Sequent_calculus:176">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊨</mo>
    <mi>A</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⊨</ci>
    <ci>normal-Γ</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Gamma\vDash A)
  </annotation>
 </semantics>
</math>

 <a class="uri" href="iff" title="wikilink">iff</a> the sequent 

<math display="inline" id="Sequent_calculus:177">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Γ</mi>
   <mo>⊢</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>normal-Γ</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\vdash A
  </annotation>
 </semantics>
</math>

 can be derived by the above rules.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>

<p>In the sequent calculus, the rule of <a href="cut-elimination" title="wikilink">cut is admissible</a>. This result is also referred to as Gentzen's <em>Hauptsatz</em> ("Main Theorem").<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>
<h2 id="variants">Variants</h2>

<p>The above rules can be modified in various ways:</p>
<h3 id="minor-structural-alternatives">Minor structural alternatives</h3>

<p>There is some freedom of choice regarding the technical details of how sequents and structural rules are formalized. As long as every derivation in LK can be effectively transformed to a derivation using the new rules and vice versa, the modified rules may still be called LK.</p>

<p>First of all, as mentioned above, the sequents can be viewed to consist of sets or <a href="multiset" title="wikilink">multisets</a>. In this case, the rules for permuting and (when using sets) contracting formulae are obsolete.</p>

<p>The rule of weakening will become admissible, when the axiom (I) is changed, such that any sequent of the form 

<math display="inline" id="Sequent_calculus:178">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>,</mo>
    <mi>A</mi>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mi>A</mi>
    <mo>,</mo>
    <mi mathvariant="normal">Δ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <list>
     <ci>normal-Γ</ci>
     <ci>A</ci>
    </list>
    <list>
     <ci>A</ci>
     <ci>normal-Δ</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma,A\vdash A,\Delta
  </annotation>
 </semantics>
</math>


 can be concluded. This means that 

<math display="inline" id="Sequent_calculus:179">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 proves 

<math display="inline" id="Sequent_calculus:180">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 in any context. Any weakening that appears in a derivation can then be performed right at the start. This may be a convenient change when constructing proofs bottom-up.</p>

<p>Independent of these one may also change the way in which contexts are split within the rules: In the cases 

<math display="inline" id="Sequent_calculus:181">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="italic">and</mi>
     <mi>R</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>L</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>italic- and</ci>
     <ci>R</ci>
    </apply>
    <ci>L</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ({\and}R),({}L)
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Sequent_calculus:182">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi></mi>
    <mo>→</mo>
    <mi>L</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <csymbol cd="latexml">absent</csymbol>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ({\rightarrow}L)
  </annotation>
 </semantics>
</math>

 the left context is somehow split into 

<math display="inline" id="Sequent_calculus:183">
 <semantics>
  <mi mathvariant="normal">Γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Sequent_calculus:184">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

 when going upwards. Since contraction allows for the duplication of these, one may assume that the full context is used in both branches of the derivation. By doing this, one assures that no important premises are lost in the wrong branch. Using weakening, the irrelevant parts of the context can be eliminated later.</p>
<h3 id="absurdity">Absurdity</h3>

<p>One can introduce 

<math display="inline" id="Sequent_calculus:185">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

, the <a href="principle_of_explosion" title="wikilink">absurdity constant</a> representing <em>false</em>, with the axiom:</p>

<p>

<math display="block" id="Sequent_calculus:186">
 <semantics>
  <mfrac>
   <mi></mi>
   <mrow>
    <mo>⊥</mo>
    <mo>⊢</mo>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">continued-fraction</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="latexml">bottom</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <ci></ci>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{}{\bot\vdash\quad}
  </annotation>
 </semantics>
</math>

</p>

<p>Or if, as described above, weakening is to be an admissible rule, then with the axiom:</p>

<p>

<math display="block" id="Sequent_calculus:187">
 <semantics>
  <mfrac>
   <mi></mi>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>,</mo>
    <mo>⊥</mo>
    <mo>⊢</mo>
    <mi mathvariant="normal">Δ</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">continued-fraction</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">Γ</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="latexml">bottom</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <csymbol cd="unknown">Δ</csymbol>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{}{\Gamma,\bot\vdash\Delta}
  </annotation>
 </semantics>
</math>

</p>

<p>With 

<math display="inline" id="Sequent_calculus:188">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>


, negation can be subsumed as a special case of implication, via the definition 

<math display="inline" id="Sequent_calculus:189">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>A</mi>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mi>A</mi>
    <mo>→</mo>
    <mo>⊥</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <apply>
     <times></times>
     <not></not>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <ci>A</ci>
     <csymbol cd="latexml">bottom</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg A\iff A\to\bot
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="substructural-logics">Substructural logics</h3>

<p>Alternatively, one may restrict or forbid the use of some of the structural rules. This yields a variety of <a href="substructural_logic" title="wikilink">substructural logic</a> systems. They are generally weaker than LK (<em>i.e.</em>, they have fewer theorems), and thus not complete with respect to the standard semantics of first-order logic. However, they have other interesting properties that have led to applications in theoretical <a href="computer_science" title="wikilink">computer science</a> and <a href="artificial_intelligence" title="wikilink">artificial intelligence</a>.</p>
<h3 id="intuitionistic-sequent-calculus-system-lj">Intuitionistic sequent calculus: System LJ</h3>

<p>Surprisingly, some small changes in the rules of LK suffice to turn it into a proof system for <a href="intuitionistic_logic" title="wikilink">intuitionistic logic</a>.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> To this end, one has to restrict to sequents with exactly one formula on the right-hand side, and modify the rules to maintain this invariant. For example, 

<math display="inline" id="Sequent_calculus:190">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>L</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ({}L)
  </annotation>
 </semantics>
</math>

 is reformulated as follows (where C is an arbitrary formula):</p>

<p>

<math display="block" id="Sequent_calculus:191">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>,</mo>
      <mi>A</mi>
     </mrow>
     <mo>⊢</mo>
     <mrow>
      <mi>C</mi>
      <mi mathvariant="normal">Σ</mi>
      <mo>,</mo>
      <mi>B</mi>
     </mrow>
     <mo>⊢</mo>
     <mi>C</mi>
    </mrow>
    <mrow>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>,</mo>
      <mi mathvariant="normal">Σ</mi>
      <mo>,</mo>
      <mrow>
       <mi>A</mi>
       <mi>B</mi>
      </mrow>
     </mrow>
     <mo>⊢</mo>
     <mi>C</mi>
    </mrow>
   </mfrac>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>L</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">continued-fraction</csymbol>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="latexml">proves</csymbol>
       <list>
        <ci>normal-Γ</ci>
        <ci>A</ci>
       </list>
       <list>
        <ci>C</ci>
        <ci>normal-Σ</ci>
        <ci>B</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="latexml">proves</csymbol>
       <share href="#.cmml">
       </share>
       <ci>C</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">proves</csymbol>
      <list>
       <ci>normal-Γ</ci>
       <ci>normal-Σ</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>B</ci>
       </apply>
      </list>
      <ci>C</ci>
     </apply>
    </apply>
    <ci>L</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma,A\vdash C\qquad\Sigma,B\vdash C}{\Gamma,\Sigma,AB\vdash C}\quad(%
{}L)
  </annotation>
 </semantics>
</math>

</p>

<p>The resulting system is called LJ. It is sound and complete with respect to intuitionistic logic and admits a similar cut-elimination proof. This can be used in proving <a href="disjunction_and_existence_properties" title="wikilink">disjunction and existence properties</a>.</p>

<p>In fact, the only two rules in LK that need to be restricted to single-formula consequents are 

<math display="inline" id="Sequent_calculus:192">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi></mi>
    <mo>→</mo>
    <mi>R</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <csymbol cd="latexml">absent</csymbol>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ({\to}R)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sequent_calculus:193">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>R</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\neg R)
  </annotation>
 </semantics>
</math>


<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> (and the latter can be seen as a special case of the former, via 

<math display="inline" id="Sequent_calculus:194">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

 as described above). When multi-formula consequents are interpreted as disjunctions, all of the other inference rules of LK are actually derivable in LJ, while the offending rule is</p>

<p>

<math display="block" id="Sequent_calculus:195">
 <semantics>
  <mfrac>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Γ</mi>
     <mo>,</mo>
     <mi>A</mi>
    </mrow>
    <mo>⊢</mo>
    <mrow>
     <mi>B</mi>
     <mi>C</mi>
    </mrow>
   </mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊢</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>→</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>C</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">continued-fraction</csymbol>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <list>
      <ci>normal-Γ</ci>
      <ci>A</ci>
     </list>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>C</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">Γ</csymbol>
     <csymbol cd="latexml">proves</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">C</csymbol>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cfrac{\Gamma,A\vdash BC}{\Gamma\vdash(A\to B)C}
  </annotation>
 </semantics>
</math>

</p>

<p>This amounts to the propositional formula 

<math display="inline" id="Sequent_calculus:196">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mi>C</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>→</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\to(BC))\to((A\to B)C)
  </annotation>
 </semantics>
</math>

, a classical tautology that is not constructively valid.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Resolution_(logic)" title="wikilink">Resolution (logic)</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://scienceblogs.com/goodmath/2006/07/17/a-brief-diversion-sequent-calc/">A Brief Diversion: Sequent Calculus</a></li>
<li><a href="http://logitext.mit.edu/logitext.fcgi/tutorial">Interactive tutorial of the Sequent Calculus</a></li>
</ul>

<p>"</p>

<p><a href="Category:Proof_theory" title="wikilink">Category:Proof theory</a> <a href="Category:Logical_calculi" title="wikilink">Category:Logical calculi</a> <a href="Category:Automated_theorem_proving" title="wikilink">Category:Automated theorem proving</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">, .<a href="#fnref1">↩</a></li>
<li id="fn2">, gives a 5-page proof of the elimination theorem. See also pages 188, 250.<a href="#fnref2">↩</a></li>
<li id="fn3">, gives a very brief proof of the cut-elimination theorem.<a href="#fnref3">↩</a></li>
<li id="fn4">, calls Gentzen systems LC systems. Curry's emphasis is more on theory than on practical logic proofs.<a href="#fnref4">↩</a></li>
<li id="fn5">. This book is much more concerned with the theoretical, metamathematical implications of Gentzen-style sequent calculus than applications to practical logic proofs.<a href="#fnref5">↩</a></li>
<li id="fn6">, defines Gentzen systems and proves various theorems within these systems, including Gödel's completeness theorem and Gentzen's theorem.<a href="#fnref6">↩</a></li>
<li id="fn7">, gives a brief theoretical presentation of Gentzen systems. He uses the tableau proof layout style.<a href="#fnref7">↩</a></li>
<li id="fn8">, compares natural deduction systems, denoted LA, and Gentzen systems, denoted LC. Curry's emphasis is more theoretical than practical.<a href="#fnref8">↩</a></li>
<li id="fn9">, is an introductory presentation of practical natural deduction of this kind. This became the basis of <a href="System_L" title="wikilink">System L</a>.<a href="#fnref9">↩</a></li>
<li id="fn10"> is an elementary introduction to practical natural deduction based on the convenient abbreviated proof layout style <a href="System_L" title="wikilink">System L</a> based on .<a href="#fnref10">↩</a></li>
<li id="fn11">Here, "whenever" is used as an informal abbreviation "for every assignment of values to the free variables in the judgment"<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14">For explanations of the disjunctive semantics for the right side of sequents, see , , , ,  and .<a href="#fnref14">↩</a></li>
<li id="fn15">. "Der Kalkül <em>NJ</em> hat manche formale Unschönheiten."<a href="#fnref15">↩</a></li>
<li id="fn16">. "In dem klassischen Kalkül <em>NK</em> nahm der Satz vom ausgeschlossenen Dritten eine Sonderstellung unter den Schlußweisen ein [...], indem er sich der Einführungs- und Beseitigungssystematik nicht einfügte. Bei dem im folgenden anzugebenden logistischen klassichen Kalkül <em>LK</em> wird diese Sonderstellung aufgehoben."<a href="#fnref16">↩</a></li>
<li id="fn17">. "Die damit erreichte Symmetrie erweist sich als für die klassische Logik angemessener."<a href="#fnref17">↩</a></li>
<li id="fn18">. "Hiermit haben wir einige Gesichtspunkte zur Begründung der Aufstellung der folgenden Kalküle angegeben. Im wesentlichen ist ihre Form jedoch durch die Rücksicht auf den nachher zu beweisenden 'Hauptsatz' bestimmt und kann daher vorläufig nicht näher begründet werden."<a href="#fnref18">↩</a></li>
<li id="fn19"></li>
<li id="fn20">.<a href="#fnref20">↩</a></li>
<li id="fn21">, wrote in 1967 that "it was a major logical discovery by Gentzen 1934–5 that, when there is any (purely logical) proof of a proposition, there is a direct proof. The implications of this discovery are in theoretical logical investigations, rather than in building collections of proved formulas."<a href="#fnref21">↩</a></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24">, wrote: "Der Unterschied zwischen <em>intuitionistischer</em> und <em>klassischer</em> Logik ist bei den Kalkülen <em>LJ</em> und <em>LK</em> äußerlich ganz anderer Art als bei <em>NJ</em> und <em>NK</em>. Dort bestand er in Weglassung bzw. Hinzunahme des Satzes vom ausgeschlossenen Dritten, während er hier durch die Sukzedensbedingung ausgedrückt wird." English translation: "The difference between <em>intuitionistic</em> and <em>classical</em> logic is in the case of the calculi <em>LJ</em> and <em>LK</em> of an extremely, totally different kind to the case of <em>NJ</em> and <em>NK</em>. In the latter case, it consisted of the removal or addition respectively of the excluded middle rule, whereas in the former case, it is expressed through the succedent conditions."<a href="#fnref24">↩</a></li>
<li id="fn25">Structural Proof Theory (CUP, 2001), Sara Negri and Jan van Plato<a href="#fnref25">↩</a></li>
</ol>
</section>
</body>
</html>
