<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1935">De Morgan's laws</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>De Morgan's laws</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>De Morgan's Laws represented with Venn diagrams</figcaption>
</figure>

<p>In <a href="propositional_calculus" title="wikilink">propositional logic</a> and <a href="boolean_algebra" title="wikilink">boolean algebra</a>, <strong>De Morgan's laws</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> are a pair of transformation rules that are both <a href="validity" title="wikilink">valid</a> <a href="rule_of_inference" title="wikilink">rules of inference</a>. They are named after <a href="Augustus_De_Morgan" title="wikilink">Augustus De Morgan</a>, a 19th-century British mathematician. The rules allow the expression of <a href="Logical_conjunction" title="wikilink">conjunctions</a> and <a href="Logical_disjunction" title="wikilink">disjunctions</a> purely in terms of each other via <a href="logical_negation" title="wikilink">negation</a>.</p>

<p>The rules can be expressed in English as:</p>
<blockquote>

<p>The negation of a conjunction is the disjunction of the negations.<br/>
The negation of a disjunction is the conjunction of the negations.</p>
</blockquote>

<p>or informally as:</p>
<blockquote>

<p>"<strong><em>not (A and B)<strong><em>" is the same as "</em></strong>(not A) or (not B)<strong><em>" also, "</em></strong>not (A or B)<strong><em>" is the same as "</em></strong>(not A) and (not B)</em></strong>".</p>
</blockquote>

<p>The rules can be expressed in <a href="formal_language" title="wikilink">formal language</a> with two propositions <em>P</em> and <em>Q</em> as:</p>

<p>

<math display="block" id="De_Morgan's_laws:0">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>P</mi>
      <mo>∧</mo>
      <mi>Q</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>P</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>Q</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <apply>
     <not></not>
     <apply>
      <and></and>
      <ci>P</ci>
      <ci>Q</ci>
     </apply>
    </apply>
    <apply>
     <or></or>
     <apply>
      <times></times>
      <not></not>
      <ci>P</ci>
     </apply>
     <apply>
      <times></times>
      <not></not>
      <ci>Q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg(P\land Q)\iff(\neg P)\lor(\neg Q)
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="De_Morgan's_laws:1">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>P</mi>
      <mo>∨</mo>
      <mi>Q</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>P</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>Q</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <apply>
     <not></not>
     <apply>
      <or></or>
      <ci>P</ci>
      <ci>Q</ci>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <not></not>
      <ci>P</ci>
     </apply>
     <apply>
      <times></times>
      <not></not>
      <ci>Q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg(P\lor Q)\iff(\neg P)\land(\neg Q)
  </annotation>
 </semantics>
</math>

 where:</p>
<ul>
<li>¬ is the negation operator (NOT)</li>
<li>

<math display="inline" id="De_Morgan's_laws:2">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \land
  </annotation>
 </semantics>
</math>

 is the conjunction operator (AND)</li>
<li>

<math display="inline" id="De_Morgan's_laws:3">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor
  </annotation>
 </semantics>
</math>

 is the disjunction operator (OR)</li>
<li>⇔ is a <a href="metalogic" title="wikilink">metalogical</a> symbol meaning "can be replaced in a <a href="formal_proof" title="wikilink">logical proof</a> with"</li>
</ul>

<p>Applications of the rules include simplification of logical <a href="Expression_(computer_science)" title="wikilink">expressions</a> in <a href="computer_program" title="wikilink">computer programs</a> and digital circuit designs. De Morgan's laws are an example of a more general concept of <a href="duality_(mathematics)" title="wikilink">mathematical duality</a>.</p>
<h2 id="formal-notation">Formal notation</h2>

<p>The <em>negation of conjunction</em> rule may be written in <a class="uri" href="sequent" title="wikilink">sequent</a> notation:</p>

<p>

<math display="block" id="De_Morgan's_laws:4">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>P</mi>
      <mi mathvariant="italic">and</mi>
      <mi>Q</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>P</mi>
     <mi mathvariant="normal">¬</mi>
     <mi>Q</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <apply>
     <not></not>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>italic- and</ci>
      <ci>Q</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>P</ci>
     <not></not>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg(P\and Q)\vdash(\neg P\neg Q)
  </annotation>
 </semantics>
</math>

</p>

<p>The <em>negation of disjunction</em> rule may be written as:</p>

<p>

<math display="block" id="De_Morgan's_laws:5">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>P</mi>
      <mi>Q</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>P</mi>
     <mi mathvariant="italic">and</mi>
     <mi mathvariant="normal">¬</mi>
     <mi>Q</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <apply>
     <not></not>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>Q</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>P</ci>
     <ci>italic- and</ci>
     <not></not>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg(PQ)\vdash(\neg P\and\neg Q)
  </annotation>
 </semantics>
</math>

</p>

<p>In <a href="Rule_of_inference" title="wikilink">rule form</a>: <em>negation of conjunction</em></p>

<p>

<math display="block" id="De_Morgan's_laws:6">
 <semantics>
  <mfrac>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>P</mi>
      <mi mathvariant="italic">and</mi>
      <mi>Q</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mrow>
    <mi></mi>
    <mo>∴</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>P</mi>
     <mi mathvariant="normal">¬</mi>
     <mi>Q</mi>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <not></not>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>italic- and</ci>
      <ci>Q</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">therefore</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <times></times>
      <not></not>
      <ci>P</ci>
      <not></not>
      <ci>Q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\neg(P\and Q)}{\therefore\neg P\neg Q}
  </annotation>
 </semantics>
</math>

</p>

<p>and <em>negation of disjunction</em></p>

<p>

<math display="block" id="De_Morgan's_laws:7">
 <semantics>
  <mfrac>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>P</mi>
      <mi>Q</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mrow>
    <mi></mi>
    <mo>∴</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>P</mi>
     <mi mathvariant="italic">and</mi>
     <mi mathvariant="normal">¬</mi>
     <mi>Q</mi>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <not></not>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>Q</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">therefore</csymbol>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <times></times>
      <not></not>
      <ci>P</ci>
      <ci>italic- and</ci>
      <not></not>
      <ci>Q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\neg(PQ)}{\therefore\neg P\and\neg Q}
  </annotation>
 </semantics>
</math>

</p>

<p>and expressed as a truth-functional <a href="Tautology_(logic)" title="wikilink">tautology</a> or <a class="uri" href="theorem" title="wikilink">theorem</a> of propositional logic:</p>

<p>

<math display="inline" id="De_Morgan's_laws:8">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>P</mi>
     <mi mathvariant="italic">and</mi>
     <mi>Q</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <not></not>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>italic- and</ci>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\neg(P\and Q)
  </annotation>
 </semantics>
</math>


</p>

<p>where 

<math display="inline" id="De_Morgan's_laws:9">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="De_Morgan's_laws:10">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 are propositions expressed in some formal system.</p>
<h3 id="substitution-form">Substitution form</h3>

<p>De Morgan's laws are normally shown in the compact form above, with negation of the output on the left and negation of the inputs on the right. A clearer form for substitution can be stated as:</p>

<p>

<math display="inline" id="De_Morgan's_laws:11">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>P</mi>
    <mi mathvariant="italic">and</mi>
    <mi>Q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>italic- and</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle(P\and Q)
  </annotation>
 </semantics>
</math>


</p>

<p>This emphasizes the need to invert both the inputs and the output, as well as change the operator, when doing a substitution.</p>
<h3 id="set-theory-and-boolean-algebra">Set theory and Boolean algebra</h3>

<p>In set theory and <a href="Boolean_algebra_(logic)" title="wikilink">Boolean algebra</a>, it is often stated as "union and intersection interchange under complementation",<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> which can be formally expressed as:</p>

<p>

<math display="inline" id="De_Morgan's_laws:12">
 <semantics>
  <mover accent="true">
   <mrow>
    <mi>A</mi>
    <mo>∪</mo>
    <mi>B</mi>
   </mrow>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <union></union>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\overline{A\cup B}
  </annotation>
 </semantics>
</math>


</p>

<p>where:</p>
<ul>
<li>

<math display="inline" id="De_Morgan's_laws:13">
 <semantics>
  <mover accent="true">
   <mi>A</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{A}
  </annotation>
 </semantics>
</math>

 is the negation of A, the <a class="uri" href="overline" title="wikilink">overline</a> being written above the terms to be negated</li>
<li>∩ is the <a href="Intersection_(set_theory)" title="wikilink">intersection</a> operator (AND)</li>
<li>∪ is the <a href="Union_(set_theory)" title="wikilink">union</a> operator (OR)</li>
</ul>

<p>The generalized form is:</p>

<p>

<math display="inline" id="De_Morgan's_laws:14">
 <semantics>
  <mover accent="true">
   <mrow>
    <mstyle displaystyle="true">
     <munder>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋂</mo>
      <mrow>
       <mi>i</mi>
       <mo>∈</mo>
       <mi>I</mi>
      </mrow>
     </munder>
    </mstyle>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <intersect></intersect>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>I</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\overline{\bigcap_{i\in I}A_{i}}
  </annotation>
 </semantics>
</math>


</p>

<p>where <em>I</em> is some, possibly uncountable, indexing set.</p>

<p>In set notation, De Morgan's laws can be remembered using the <a class="uri" href="mnemonic" title="wikilink">mnemonic</a> "break the line, change the sign".<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="engineering">Engineering</h3>

<p>In <a href="electrical_and_computer_engineering" title="wikilink">electrical and computer engineering</a>, De Morgan's laws are commonly written as:</p>

<p>

<math display="block" id="De_Morgan's_laws:15">
 <semantics>
  <mrow>
   <mover accent="true">
    <mrow>
     <mi>A</mi>
     <mo>⋅</mo>
     <mi>B</mi>
    </mrow>
    <mo>¯</mo>
   </mover>
   <mo>≡</mo>
   <mrow>
    <mover accent="true">
     <mi>A</mi>
     <mo>¯</mo>
    </mover>
    <mo>+</mo>
    <mover accent="true">
     <mi>B</mi>
     <mo>¯</mo>
    </mover>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <ci>normal-⋅</ci>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-¯</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <ci>normal-¯</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{A\cdot B}\equiv\overline{A}+\overline{B}
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="De_Morgan's_laws:16">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mrow>
      <mi>A</mi>
      <mo>+</mo>
      <mi>B</mi>
     </mrow>
     <mo>¯</mo>
    </mover>
    <mo>≡</mo>
    <mrow>
     <mover accent="true">
      <mi>A</mi>
      <mo>¯</mo>
     </mover>
     <mo>⋅</mo>
     <mover accent="true">
      <mi>B</mi>
      <mo>¯</mo>
     </mover>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <plus></plus>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>A</ci>
     </apply>
     <apply>
      <ci>normal-¯</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{A+B}\equiv\overline{A}\cdot\overline{B},
  </annotation>
 </semantics>
</math>

</p>

<p>where:</p>
<ul>
<li>

<math display="inline" id="De_Morgan's_laws:17">
 <semantics>
  <mo>⋅</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⋅</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdot
  </annotation>
 </semantics>
</math>

 is a logical AND</li>
<li>

<math display="inline" id="De_Morgan's_laws:18">
 <semantics>
  <mo>+</mo>
  <annotation-xml encoding="MathML-Content">
   <plus></plus>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   +
  </annotation>
 </semantics>
</math>

 is a logical OR</li>
<li>the 

<math display="inline" id="De_Morgan's_laws:19">
 <semantics>
  <mover accent="true">
   <mrow>
    <mi>o</mi>
    <mi>v</mi>
    <mi>e</mi>
    <mi>r</mi>
    <mi>b</mi>
    <mi>a</mi>
    <mi>r</mi>
   </mrow>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>v</ci>
     <ci>e</ci>
     <ci>r</ci>
     <ci>b</ci>
     <ci>a</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{overbar}
  </annotation>
 </semantics>
</math>

 is the logical NOT of what is underneath the overbar.</li>
</ul>
<h3 id="text-searching">Text searching</h3>

<p>De Morgan’s laws commonly apply to text searching using Boolean operators AND, OR, and NOT. Consider a set of documents containing the words “cars” and “trucks”. De Morgan’s laws hold that these two searches will return the same set of documents:</p>
<dl>
<dd>Search A: NOT (cars OR trucks)
</dd>
<dd>Search B: (NOT cars) AND (NOT trucks)
</dd>
</dl>

<p>The corpus of documents containing “cars” or “trucks” can be represented by four documents:</p>
<dl>
<dd>Document 1: Contains only the word “cars”.
</dd>
<dd>Document 2: Contains only “trucks”.
</dd>
<dd>Document 3: Contains both “cars” and “trucks”.
</dd>
<dd>Document 4: Contains neither “cars” nor “trucks”.
</dd>
</dl>

<p>To evaluate Search A, clearly the search “(cars OR trucks)” will hit on Documents 1, 2, and 3. So the negation of that search (which is Search A) will hit everything else, which is Document 4.</p>

<p>Evaluating Search B, the search “(NOT cars)” will hit on documents that do not contain “cars”, which is Documents 2 and 4. Similarly the search “(NOT trucks)” will hit on Documents 1 and 4. Applying the AND operator to these two searches (which is Search B) will hit on the documents that are common to these two searches, which is Document 4.</p>

<p>A similar evaluation can be applied to show that the following two searches will return the same set of documents (Documents 1, 2, 4):</p>
<dl>
<dd>Search C: NOT (cars AND trucks)
</dd>
<dd>Search D: (NOT cars) OR (NOT trucks)
</dd>
</dl>
<h2 id="history">History</h2>

<p>The laws are named after <a href="Augustus_De_Morgan" title="wikilink">Augustus De Morgan</a> (1806–1871),<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> who introduced a formal version of the laws to classical <a href="propositional_logic" title="wikilink">propositional logic</a>. De Morgan's formulation was influenced by algebraization of logic undertaken by <a href="George_Boole" title="wikilink">George Boole</a>, which later cemented De Morgan's claim to the find. Nevertheless, a similar observation was made by <a class="uri" href="Aristotle" title="wikilink">Aristotle</a>, and was known to Greek and Medieval logicians.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> For example, in the 14th century, <a href="William_of_Ockham" title="wikilink">William of Ockham</a> wrote down the words that would result by reading the laws out.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> <a href="Jean_Buridan" title="wikilink">Jean Buridan</a>, in his <em>Summulae de Dialectica</em>, also describes rules of conversion that follow the lines of De Morgan's laws.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Still, De Morgan is given credit for stating the laws in the terms of modern formal logic, and incorporating them into the language of logic. De Morgan's laws can be proved easily, and may even seem trivial.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Nonetheless, these laws are helpful in making valid inferences in proofs and deductive arguments.</p>
<h2 id="informal-proof">Informal proof</h2>

<p>De Morgan's theorem may be applied to the negation of a <a class="uri" href="disjunction" title="wikilink">disjunction</a> or the negation of a <a href="Logical_conjunction" title="wikilink">conjunction</a> in all or part of a formula.</p>
<h3 id="negation-of-a-disjunction">Negation of a disjunction</h3>

<p>In the case of its application to a disjunction, consider the following claim: "it is false that either of A or B is true", which is written as:</p>

<p>

<math display="block" id="De_Morgan's_laws:20">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mo>∨</mo>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <not></not>
    <apply>
     <or></or>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg(A\lor B)
  </annotation>
 </semantics>
</math>

 In that it has been established that <em>neither</em> A nor B is true, then it must follow that both A is not true <a href="logical_AND" title="wikilink">and</a> B is not true, which may be written directly as:</p>

<p>

<math display="block" id="De_Morgan's_laws:21">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <times></times>
     <not></not>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\neg A)\wedge(\neg B)
  </annotation>
 </semantics>
</math>

 If either A or B <em>were</em> true, then the disjunction of A and B would be true, making its negation false. Presented in English, this follows the logic that "since two things are both false, it is also false that either of them is true".</p>

<p>Working in the opposite direction, the second expression asserts that A is false and B is false (or equivalently that "not A" and "not B" are true). Knowing this, a disjunction of A and B must be false also. The negation of said disjunction must thus be true, and the result is identical to the first claim.</p>
<h3 id="negation-of-a-conjunction">Negation of a conjunction</h3>

<p>The application of De Morgan's theorem to a conjunction is very similar to its application to a disjunction both in form and rationale. Consider the following claim: "it is false that A and B are both true", which is written as:</p>

<p>

<math display="block" id="De_Morgan's_laws:22">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>A</mi>
     <mo>∧</mo>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <not></not>
    <apply>
     <and></and>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg(A\land B)
  </annotation>
 </semantics>
</math>

 In order for this claim to be true, either or both of A or B must be false, for if they both were true, then the conjunction of A and B would be true, making its negation false. Thus, <a href="inclusive_or" title="wikilink">one (at least) or more</a> of A and B must be false (or equivalently, one or more of "not A" and "not B" must be true). This may be written directly as:</p>

<p>

<math display="block" id="De_Morgan's_laws:23">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>A</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <times></times>
     <not></not>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\neg A)\lor(\neg B)
  </annotation>
 </semantics>
</math>

 Presented in English, this follows the logic that "since it is false that two things are both true, at least one of them must be false".</p>

<p>Working in the opposite direction again, the second expression asserts that at least one of "not A" and "not B" must be true, or equivalently that at least one of A and B must be false. Since at least one of them must be false, then their conjunction would likewise be false. Negating said conjunction thus results in a true expression, and this expression is identical to the first claim.</p>
<h2 id="formal-proof">Formal proof</h2>

<p>The proof that 

<math display="inline" id="De_Morgan's_laws:24">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∩</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mi>c</mi>
    </msup>
    <mo>∪</mo>
    <msup>
     <mi>B</mi>
     <mi>c</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <intersect></intersect>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\cap B)^{c}=A^{c}\cup B^{c}
  </annotation>
 </semantics>
</math>

 is completed in 2 steps by proving both 

<math display="inline" id="De_Morgan's_laws:25">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∩</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </msup>
   <mo>⊆</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mi>c</mi>
    </msup>
    <mo>∪</mo>
    <msup>
     <mi>B</mi>
     <mi>c</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <intersect></intersect>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\cap B)^{c}\subseteq A^{c}\cup B^{c}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="De_Morgan's_laws:26">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>A</mi>
     <mi>c</mi>
    </msup>
    <mo>∪</mo>
    <msup>
     <mi>B</mi>
     <mi>c</mi>
    </msup>
   </mrow>
   <mo>⊆</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∩</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <intersect></intersect>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{c}\cup B^{c}\subseteq(A\cap B)^{c}
  </annotation>
 </semantics>
</math>

:</p>

<p>Let 

<math display="inline" id="De_Morgan's_laws:27">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∩</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <intersect></intersect>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in(A\cap B)^{c}
  </annotation>
 </semantics>
</math>

. Then, 

<math display="inline" id="De_Morgan's_laws:28">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <mrow>
    <mi>A</mi>
    <mo>∩</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>x</ci>
    <apply>
     <intersect></intersect>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\in A\cap B
  </annotation>
 </semantics>
</math>

. Because 

<math display="inline" id="De_Morgan's_laws:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>∩</mo>
    <mi>B</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>y</mi>
     <mo>∈</mo>
     <mrow>
      <mi>A</mi>
      <mtext>and</mtext>
      <mi>y</mi>
     </mrow>
     <mo>∈</mo>
     <mi>B</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <intersect></intersect>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>y</ci>
     <apply>
      <and></and>
      <apply>
       <in></in>
       <ci>y</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <mtext>and</mtext>
        <ci>y</ci>
       </apply>
      </apply>
      <apply>
       <in></in>
       <share href="#.cmml">
       </share>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\cap B=\{y|y\in A\text{ and }y\in B\}
  </annotation>
 </semantics>
</math>

, it must be the case that 

<math display="inline" id="De_Morgan's_laws:30">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>x</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\in A
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="De_Morgan's_laws:31">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>x</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\in B
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="De_Morgan's_laws:32">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>x</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\in A
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="De_Morgan's_laws:33">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mi>A</mi>
    <mi>c</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in A^{c}
  </annotation>
 </semantics>
</math>

, so 

<math display="inline" id="De_Morgan's_laws:34">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mi>c</mi>
    </msup>
    <mo>∪</mo>
    <msup>
     <mi>B</mi>
     <mi>c</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in A^{c}\cup B^{c}
  </annotation>
 </semantics>
</math>

. Similarly, if 

<math display="inline" id="De_Morgan's_laws:35">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>x</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\in B
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="De_Morgan's_laws:36">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mi>B</mi>
    <mi>c</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in B^{c}
  </annotation>
 </semantics>
</math>

, so 

<math display="inline" id="De_Morgan's_laws:37">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mi>c</mi>
    </msup>
    <mo>∪</mo>
    <msup>
     <mi>B</mi>
     <mi>c</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in A^{c}\cup B^{c}
  </annotation>
 </semantics>
</math>

. Thus, 

<math display="inline" id="De_Morgan's_laws:38">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mo stretchy="false">(</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-(</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x(
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="De_Morgan's_laws:39">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∩</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <intersect></intersect>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in(A\cap B)^{c}
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="De_Morgan's_laws:40">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mi>A</mi>
    <mi>c</mi>
   </msup>
   <mo>∪</mo>
   <msup>
    <mi>B</mi>
    <mi>c</mi>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>c</ci>
    </apply>
    <union></union>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <ci>c</ci>
    </apply>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in A^{c}\cup B^{c})
  </annotation>
 </semantics>
</math>

; that is, 

<math display="inline" id="De_Morgan's_laws:41">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∩</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </msup>
   <mo>⊆</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mi>c</mi>
    </msup>
    <mo>∪</mo>
    <msup>
     <mi>B</mi>
     <mi>c</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <intersect></intersect>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\cap B)^{c}\subseteq A^{c}\cup B^{c}
  </annotation>
 </semantics>
</math>

.</p>

<p>To prove the reverse direction, let 

<math display="inline" id="De_Morgan's_laws:42">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mi>c</mi>
    </msup>
    <mo>∪</mo>
    <msup>
     <mi>B</mi>
     <mi>c</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in A^{c}\cup B^{c}
  </annotation>
 </semantics>
</math>

, and assume 

<math display="inline" id="De_Morgan's_laws:43">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∩</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <intersect></intersect>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\in(A\cap B)^{c}
  </annotation>
 </semantics>
</math>

. Under that assumption, it must be the case that 

<math display="inline" id="De_Morgan's_laws:44">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mrow>
    <mi>A</mi>
    <mo>∩</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <intersect></intersect>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in A\cap B
  </annotation>
 </semantics>
</math>

; it follows that 

<math display="inline" id="De_Morgan's_laws:45">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="De_Morgan's_laws:46">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in B
  </annotation>
 </semantics>
</math>

, and thus 

<math display="inline" id="De_Morgan's_laws:47">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <msup>
    <mi>A</mi>
    <mi>c</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\in A^{c}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="De_Morgan's_laws:48">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <msup>
    <mi>B</mi>
    <mi>c</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\in B^{c}
  </annotation>
 </semantics>
</math>

. However, that means 

<math display="inline" id="De_Morgan's_laws:49">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mi>c</mi>
    </msup>
    <mo>∪</mo>
    <msup>
     <mi>B</mi>
     <mi>c</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>x</ci>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\in A^{c}\cup B^{c}
  </annotation>
 </semantics>
</math>

, in contradiction to the hypothesis that 

<math display="inline" id="De_Morgan's_laws:50">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mi>c</mi>
    </msup>
    <mo>∪</mo>
    <msup>
     <mi>B</mi>
     <mi>c</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in A^{c}\cup B^{c}
  </annotation>
 </semantics>
</math>

; the assumption 

<math display="inline" id="De_Morgan's_laws:51">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∩</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <intersect></intersect>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\in(A\cap B)^{c}
  </annotation>
 </semantics>
</math>

 must not be the case, meaning that 

<math display="inline" id="De_Morgan's_laws:52">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∩</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <intersect></intersect>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in(A\cap B)^{c}
  </annotation>
 </semantics>
</math>

 must be the case. Therefore, 

<math display="inline" id="De_Morgan's_laws:53">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mo stretchy="false">(</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-(</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x(
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="De_Morgan's_laws:54">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mi>c</mi>
    </msup>
    <mo>∪</mo>
    <msup>
     <mi>B</mi>
     <mi>c</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in A^{c}\cup B^{c}
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="De_Morgan's_laws:55">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>∩</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <intersect></intersect>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>c</ci>
    </apply>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in(A\cap B)^{c})
  </annotation>
 </semantics>
</math>

; that is, 

<math display="inline" id="De_Morgan's_laws:56">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>A</mi>
     <mi>c</mi>
    </msup>
    <mo>∪</mo>
    <msup>
     <mi>B</mi>
     <mi>c</mi>
    </msup>
   </mrow>
   <mo>⊆</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∩</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <intersect></intersect>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{c}\cup B^{c}\subseteq(A\cap B)^{c}
  </annotation>
 </semantics>
</math>

.</p>

<p>If 

<math display="inline" id="De_Morgan's_laws:57">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>A</mi>
     <mi>c</mi>
    </msup>
    <mo>∪</mo>
    <msup>
     <mi>B</mi>
     <mi>c</mi>
    </msup>
   </mrow>
   <mo>⊆</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∩</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <intersect></intersect>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{c}\cup B^{c}\subseteq(A\cap B)^{c}
  </annotation>
 </semantics>
</math>

 <em>and</em> 

<math display="inline" id="De_Morgan's_laws:58">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∩</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </msup>
   <mo>⊆</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mi>c</mi>
    </msup>
    <mo>∪</mo>
    <msup>
     <mi>B</mi>
     <mi>c</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <intersect></intersect>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\cap B)^{c}\subseteq A^{c}\cup B^{c}
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="De_Morgan's_laws:59">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∩</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mi>c</mi>
    </msup>
    <mo>∪</mo>
    <msup>
     <mi>B</mi>
     <mi>c</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <intersect></intersect>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\cap B)^{c}=A^{c}\cup B^{c}
  </annotation>
 </semantics>
</math>

; this concludes the proof of De Morgan's law.</p>

<p>The other De Morgan's law, 

<math display="inline" id="De_Morgan's_laws:60">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∪</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>A</mi>
     <mi>c</mi>
    </msup>
    <mo>∩</mo>
    <msup>
     <mi>B</mi>
     <mi>c</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <union></union>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <apply>
     <intersect></intersect>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\cup B)^{c}=A^{c}\cap B^{c}
  </annotation>
 </semantics>
</math>

, is proven similarly.</p>
<h2 id="extensions">Extensions</h2>
<figure><b>(Figure)</b>
<figcaption>De Morgan's Laws represented as a circuit with logic gates</figcaption>
</figure>

<p>In extensions of classical propositional logic, the duality still holds (that is, to any logical operator one can always find its dual), since in the presence of the identities governing negation, one may always introduce an operator that is the De Morgan dual of another. This leads to an important property of logics based on classical logic, namely the existence of <a href="negation_normal_form" title="wikilink">negation normal forms</a>: any formula is equivalent to another formula where negations only occur applied to the non-logical atoms of the formula. The existence of negation normal forms drives many applications, for example in <a href="digital_circuit" title="wikilink">digital circuit</a> design, where it is used to manipulate the types of <a href="logic_gate" title="wikilink">logic gates</a>, and in formal logic, where it is a prerequisite for finding the <a href="conjunctive_normal_form" title="wikilink">conjunctive normal form</a> and <a href="disjunctive_normal_form" title="wikilink">disjunctive normal form</a> of a formula. Computer programmers use them to simplify or properly negate complicated <a href="Conditional_(programming)" title="wikilink">logical conditions</a>. They are also often useful in computations in elementary <a href="probability_theory" title="wikilink">probability theory</a>.</p>

<p>Let one define the dual of any propositional operator P(<em>p</em>, <em>q</em>, ...) depending on elementary propositions <em>p</em>, <em>q</em>, ... to be the operator 

<math display="inline" id="De_Morgan's_laws:61">
 <semantics>
  <msup>
   <mtext>P</mtext>
   <mi>d</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <mtext>P</mtext>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{P}^{d}
  </annotation>
 </semantics>
</math>

 defined by</p>

<p>

<math display="block" id="De_Morgan's_laws:62">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mtext>P</mtext>
      <mi>d</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>p</mi>
      <mo>,</mo>
      <mi>q</mi>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>p</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>q</mi>
      </mrow>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>P</mtext>
      <ci>d</ci>
     </apply>
     <vector>
      <ci>p</ci>
      <ci>q</ci>
      <ci>normal-…</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>P</ci>
     <vector>
      <apply>
       <times></times>
       <not></not>
       <ci>p</ci>
      </apply>
      <apply>
       <times></times>
       <not></not>
       <ci>q</ci>
      </apply>
      <ci>normal-…</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mbox{P}^{d}(p,q,...)=\neg P(\neg p,\neg q,\dots).
  </annotation>
 </semantics>
</math>

</p>

<p>This idea can be generalised to quantifiers, so for example the <a href="universal_quantifier" title="wikilink">universal quantifier</a> and <a href="existential_quantifier" title="wikilink">existential quantifier</a> are duals:</p>

<p>

<math display="block" id="De_Morgan's_laws:63">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>x</mi>
      </mpadded>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <mpadded width="+1.7pt">
        <mi>x</mi>
       </mpadded>
       <mi mathvariant="normal">¬</mi>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>P</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>x</ci>
       <not></not>
       <ci>P</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\,P(x)\equiv\neg\exists x\,\neg P(x),
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="De_Morgan's_laws:64">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>x</mi>
      </mpadded>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <mpadded width="+1.7pt">
        <mi>x</mi>
       </mpadded>
       <mi mathvariant="normal">¬</mi>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>P</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>x</ci>
       <not></not>
       <ci>P</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x\,P(x)\equiv\neg\forall x\,\neg P(x).
  </annotation>
 </semantics>
</math>

</p>

<p>To relate these quantifier dualities to the De Morgan laws, set up a <a href="model_theory" title="wikilink">model</a> with some small number of elements in its domain <em>D</em>, such as</p>
<dl>
<dd><em>D</em> = {<em>a</em>, <em>b</em>, <em>c</em>}.
</dd>
</dl>

<p>Then</p>

<p>

<math display="block" id="De_Morgan's_laws:65">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>x</mi>
     </mpadded>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>P</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\,P(x)\equiv P(a)\land P(b)\land P(c)
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="De_Morgan's_laws:66">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>x</mi>
      </mpadded>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∨</mo>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∨</mo>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>P</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <or></or>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x\,P(x)\equiv P(a)\lor P(b)\lor P(c).\,
  </annotation>
 </semantics>
</math>

</p>

<p>But, using De Morgan's laws,</p>

<p>

<math display="block" id="De_Morgan's_laws:67">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>∨</mo>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>b</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>∨</mo>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <not></not>
     <apply>
      <or></or>
      <apply>
       <times></times>
       <not></not>
       <ci>P</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <not></not>
       <ci>P</ci>
       <ci>b</ci>
      </apply>
      <apply>
       <times></times>
       <not></not>
       <ci>P</ci>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(a)\land P(b)\land P(c)\equiv\neg(\neg P(a)\lor\neg P(b)\lor\neg P(c))
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="De_Morgan's_laws:68">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∨</mo>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∨</mo>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi mathvariant="normal">¬</mi>
        <mi>P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>a</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>∧</mo>
       <mrow>
        <mi mathvariant="normal">¬</mi>
        <mi>P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>b</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>∧</mo>
       <mrow>
        <mi mathvariant="normal">¬</mi>
        <mi>P</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>c</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <or></or>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <not></not>
     <apply>
      <and></and>
      <apply>
       <times></times>
       <not></not>
       <ci>P</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <not></not>
       <ci>P</ci>
       <ci>b</ci>
      </apply>
      <apply>
       <times></times>
       <not></not>
       <ci>P</ci>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(a)\lor P(b)\lor P(c)\equiv\neg(\neg P(a)\land\neg P(b)\land\neg P(c)),
  </annotation>
 </semantics>
</math>

</p>

<p>verifying the quantifier dualities in the model.</p>

<p>Then, the quantifier dualities can be extended further to <a href="modal_logic" title="wikilink">modal logic</a>, relating the box ("necessarily") and diamond ("possibly") operators:</p>

<p>

<math display="block" id="De_Morgan's_laws:69">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">□</mi>
     <mi>p</mi>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi mathvariant="normal">◇</mi>
     <mi mathvariant="normal">¬</mi>
     <mi>p</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>normal-◇</ci>
     <not></not>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box p\equiv\neg\Diamond\neg p,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="De_Morgan's_laws:70">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">◇</mi>
     <mi>p</mi>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi mathvariant="normal">□</mi>
     <mi mathvariant="normal">¬</mi>
     <mi>p</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>normal-◇</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>normal-□</ci>
     <not></not>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Diamond p\equiv\neg\Box\neg p.\,
  </annotation>
 </semantics>
</math>

</p>

<p>In its application to the <a href="alethic_modalities" title="wikilink">alethic modalities</a> of possibility and necessity, <a class="uri" href="Aristotle" title="wikilink">Aristotle</a> observed this case, and in the case of <a href="normal_modal_logic" title="wikilink">normal modal logic</a>, the relationship of these modal operators to the quantification can be understood by setting up models using <a href="Kripke_semantics" title="wikilink">Kripke semantics</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Isomorphism" title="wikilink">Isomorphism</a> (NOT operator as isomorphism between <a href="wikt:positive_logic" title="wikilink">positive logic</a> and <a href="wikt:negative_logic" title="wikilink">negative logic</a>)</li>
<li><a href="List_of_Boolean_algebra_topics" title="wikilink">List of Boolean algebra topics</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Boolean_algebra" title="wikilink">Category:Boolean algebra</a> <a href="Category:Duality_theories" title="wikilink">Category:Duality theories</a> <a href="Category:Rules_of_inference" title="wikilink">Category:Rules of inference</a> <a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a> <a href="Category:Theorems_in_propositional_logic" title="wikilink">Category:Theorems in propositional logic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Copi and Cohen<a href="#fnref1">↩</a></li>
<li id="fn2">Hurley<a href="#fnref2">↩</a></li>
<li id="fn3">Moore and Parker<a href="#fnref3">↩</a></li>
<li id="fn4"><em>Boolean Algebra</em> by R. L. Goodstein. ISBN 0-486-45894-6<a href="#fnref4">↩</a></li>
<li id="fn5">[<a class="uri" href="http://books.google.com/books?id=NdAjEDP5mDsC&amp;pg">http://books.google.com/books?id=NdAjEDP5mDsC&amp;pg;</a>;=PA81&amp;lpg;=PA81&amp;dq;=break+the+line+change+the+sign&amp;source;=web&amp;ots;=BtUl4oQOja&amp;sig;=H1Wz9e6Uv_bNeSbTvN6lr3s47PQ#PPA81,M1 <em>2000 Solved Problems in Digital Electronics</em>] by S. P. Bali<a href="#fnref5">↩</a></li>
<li id="fn6"><em><a href="http://www.mtsu.edu/~phys2020/Lectures/L19-L25/L3/DeMorgan/body_demorgan.html">DeMorgan’s Theorems</a></em> at mtsu.edu<a href="#fnref6">↩</a></li>
<li id="fn7">Bocheński's <em>History of Formal Logic</em><a href="#fnref7">↩</a></li>
<li id="fn8">William of Ockham, <em>Summa Logicae</em>, part II, sections 32 and 33.<a href="#fnref8">↩</a></li>
<li id="fn9">Jean Buridan, <em>Summula de Dialectica</em>. Trans. Gyula Klima. New Haven: Yale University Press, 2001. See especially Treatise 1, Chapter 7, Section 5. ISBN 0-300-08425-0<a href="#fnref9">↩</a></li>
<li id="fn10"><a href="http://www.engr.iupui.edu/~orr/webpages/cpt120/mathbios/ademo.htm">Augustus De Morgan (1806–1871)</a> by Robert H. Orr<a href="#fnref10">↩</a></li>
</ol>
</section>
</body>
</html>
