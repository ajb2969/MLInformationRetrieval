<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1180">Resolution (logic)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Resolution (logic)</h1>
<hr/>

<p>In <a href="mathematical_logic" title="wikilink">mathematical logic</a> and <a href="automated_theorem_proving" title="wikilink">automated theorem proving</a>, <strong>resolution</strong> is a rule of <a class="uri" href="inference" title="wikilink">inference</a> leading to a <a href="Reductio_ad_absurdum" title="wikilink">refutation</a> <a class="uri" href="theorem-proving" title="wikilink">theorem-proving</a> technique for sentences in <a href="propositional_logic" title="wikilink">propositional logic</a> and <a href="first-order_logic" title="wikilink">first-order logic</a>. In other words, iteratively applying the resolution rule in a suitable way allows for telling whether a <a href="propositional_formula" title="wikilink">propositional formula</a> is satisfiable and for proving that a first-order formula is unsatisfiable. Attempting to prove a satisfiable first-order formula as unsatisfiable may result in a nonterminating computation; this problem doesn't occur in propositional logic.</p>

<p>The resolution rule can be traced back to Davis and Putnam (1960);<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> however, their <a href="Davis-Putnam_algorithm" title="wikilink">algorithm</a> required to try all <a href="ground_instance" title="wikilink">ground instances</a> of the given formula. This source of combinatorial explosion was eliminated in 1965 by <a href="John_Alan_Robinson" title="wikilink">John Alan Robinson</a>'s syntactical <a href="Unification_(computer_science)" title="wikilink">unification algorithm</a>, which allowed one to instantiate the formula during the proof "on demand" just as far as needed to keep <a href="refutation_completeness" title="wikilink">refutation completeness</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>The clause produced by a resolution rule is sometimes called a <strong>resolvent</strong>.</p>
<h2 id="resolution-in-propositional-logic">Resolution in propositional logic</h2>
<h3 id="resolution-rule">Resolution rule</h3>

<p>The <strong>resolution rule</strong> in propositional logic is a single valid inference rule that produces a new clause implied by two <a href="Clause_(logic)" title="wikilink">clauses</a> containing complementary literals. A <a href="literal_(mathematical_logic)" title="wikilink">literal</a> is a propositional variable or the negation of a propositional variable. Two literals are said to be complements if one is the negation of the other (in the following, 

<math display="inline" id="Resolution_(logic):0">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lnot c
  </annotation>
 </semantics>
</math>

 is taken to be the complement to 

<math display="inline" id="Resolution_(logic):1">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

). The resulting clause contains all the literals that do not have complements. Formally:</p>

<p>

<math display="block" id="Resolution_(logic):2">
 <semantics>
  <mfrac>
   <mrow>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>∨</mo>
     <mi mathvariant="normal">…</mi>
     <mo>∨</mo>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>∨</mo>
     <mi>c</mi>
     <mo>∨</mo>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>∨</mo>
     <mi mathvariant="normal">…</mi>
     <mo>∨</mo>
     <msub>
      <mi>a</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo>∨</mo>
     <mi mathvariant="normal">…</mi>
     <mo>∨</mo>
     <msub>
      <mi>b</mi>
      <mrow>
       <mi>j</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>∨</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>c</mi>
     </mrow>
     <mo>∨</mo>
     <msub>
      <mi>b</mi>
      <mrow>
       <mi>j</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>∨</mo>
     <mi mathvariant="normal">…</mi>
     <mo>∨</mo>
     <msub>
      <mi>b</mi>
      <mi>m</mi>
     </msub>
    </mrow>
   </mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>∨</mo>
    <mi mathvariant="normal">…</mi>
    <mo>∨</mo>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>∨</mo>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>∨</mo>
    <mi mathvariant="normal">…</mi>
    <mo>∨</mo>
    <msub>
     <mi>a</mi>
     <mi>n</mi>
    </msub>
    <mo>∨</mo>
    <msub>
     <mi>b</mi>
     <mn>1</mn>
    </msub>
    <mo>∨</mo>
    <mi mathvariant="normal">…</mi>
    <mo>∨</mo>
    <msub>
     <mi>b</mi>
     <mrow>
      <mi>j</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>∨</mo>
    <msub>
     <mi>b</mi>
     <mrow>
      <mi>j</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>∨</mo>
    <mi mathvariant="normal">…</mi>
    <mo>∨</mo>
    <msub>
     <mi>b</mi>
     <mi>m</mi>
    </msub>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <list>
     <apply>
      <or></or>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>c</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <or></or>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <apply>
        <minus></minus>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <not></not>
       <ci>c</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <apply>
        <plus></plus>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </list>
    <apply>
     <or></or>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <apply>
       <minus></minus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <apply>
       <plus></plus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{a_{1}\lor\ldots\vee a_{i-1}\lor c\lor a_{i+1}\vee\ldots\lor a_{n},\quad b%
_{1}\lor\ldots\vee b_{j-1}\lor\lnot c\lor b_{j+1}\vee\ldots\lor b_{m}}{a_{1}%
\lor\ldots\lor a_{i-1}\lor a_{i+1}\lor\ldots\lor a_{n}\lor b_{1}\lor\ldots\lor
b%
_{j-1}\lor b_{j+1}\lor\ldots\lor b_{m}}
  </annotation>
 </semantics>
</math>

 where</p>
<dl>
<dd>all 

<math display="inline" id="Resolution_(logic):3">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

s, 

<math display="inline" id="Resolution_(logic):4">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

s and 

<math display="inline" id="Resolution_(logic):5">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 are literals,
</dd>
<dd>the dividing line stands for <a href="logical_consequence" title="wikilink">entails</a>
</dd>
</dl>

<p>The clause produced by the resolution rule is called the <em>resolvent</em> of the two input clauses. It is the principle of <em><a href="consensus_theorem" title="wikilink">consensus</a></em> applied to clauses rather than terms.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>When the two clauses contain more than one pair of complementary literals, the resolution rule can be applied (independently) for each such pair; however, the result is always a <a href="tautology_(logic)" title="wikilink">tautology</a>.</p>

<p><a href="Modus_ponens" title="wikilink">Modus ponens</a> can be seen as a special case of resolution (of a one-literal clause and a two-literal clause).</p>

<p>

<math display="block" id="Resolution_(logic):6">
 <semantics>
  <mfrac>
   <mrow>
    <mi>p</mi>
    <mo>→</mo>
    <mrow>
     <mi>q</mi>
     <mo>,</mo>
     <mi>p</mi>
    </mrow>
   </mrow>
   <mi>q</mi>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <ci>normal-→</ci>
     <ci>p</ci>
     <list>
      <ci>q</ci>
      <ci>p</ci>
     </list>
    </apply>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{p\rightarrow q,p}{q}
  </annotation>
 </semantics>
</math>

 is equivalent to</p>

<p>

<math display="block" id="Resolution_(logic):7">
 <semantics>
  <mfrac>
   <mrow>
    <mrow>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>p</mi>
     </mrow>
     <mo>∨</mo>
     <mi>q</mi>
    </mrow>
    <mo>,</mo>
    <mi>p</mi>
   </mrow>
   <mi>q</mi>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <list>
     <apply>
      <or></or>
      <apply>
       <times></times>
       <not></not>
       <ci>p</ci>
      </apply>
      <ci>q</ci>
     </apply>
     <ci>p</ci>
    </list>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\lnot p\lor q,p}{q}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="a-resolution-technique">A resolution technique</h3>

<p>When coupled with a complete <a href="search_algorithm" title="wikilink">search algorithm</a>, the resolution rule yields a sound and complete algorithm for deciding the <em>satisfiability</em> of a propositional formula, and, by extension, the <a class="uri" href="validity" title="wikilink">validity</a> of a sentence under a set of axioms.</p>

<p>This resolution technique uses <a href="proof_by_contradiction" title="wikilink">proof by contradiction</a> and is based on the fact that any sentence in propositional logic can be transformed into an equivalent sentence in <a href="conjunctive_normal_form" title="wikilink">conjunctive normal form</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The steps are as follows.</p>
<ul>
<li>All sentences in the knowledge base and the <em>negation</em> of the sentence to be proved (the <em>conjecture</em>) are conjunctively connected.</li>
<li>The resulting sentence is transformed into a conjunctive normal form with the conjuncts viewed as elements in a set, <em>S</em>, of clauses.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a>
<ul>
<li>For example 

<math display="inline" id="Resolution_(logic):8">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>A</mi>
      <mn>1</mn>
     </msub>
     <mo>∨</mo>
     <msub>
      <mi>A</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>B</mi>
      <mn>1</mn>
     </msub>
     <mo>∨</mo>
     <msub>
      <mi>B</mi>
      <mn>2</mn>
     </msub>
     <mo>∨</mo>
     <msub>
      <mi>B</mi>
      <mn>3</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>C</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <or></or>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <or></or>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A_{1}\lor A_{2})\land(B_{1}\lor B_{2}\lor B_{3})\land(C_{1})
  </annotation>
 </semantics>
</math>

 gives rise to the set 

<math display="inline" id="Resolution_(logic):9">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <msub>
      <mi>A</mi>
      <mn>1</mn>
     </msub>
     <mo>∨</mo>
     <msub>
      <mi>A</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>B</mi>
      <mn>1</mn>
     </msub>
     <mo>∨</mo>
     <msub>
      <mi>B</mi>
      <mn>2</mn>
     </msub>
     <mo>∨</mo>
     <msub>
      <mi>B</mi>
      <mn>3</mn>
     </msub>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>C</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <set>
     <apply>
      <or></or>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <or></or>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <cn type="integer">1</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\{A_{1}\lor A_{2},B_{1}\lor B_{2}\lor B_{3},C_{1}\}
  </annotation>
 </semantics>
</math>

.</li>
</ul></li>
<li>The resolution rule is applied to all possible pairs of clauses that contain complementary literals. After each application of the resolution rule, the resulting sentence is simplified by removing repeated literals. If the sentence contains complementary literals, it is discarded (as a tautology). If not, and if it is not yet present in the clause set <em>S</em>, it is added to <em>S</em>, and is considered for further resolution inferences.</li>
<li>If after applying a resolution rule the <em>empty clause</em> is derived, the original formula is unsatisfiable (or <em>contradictory</em>), and hence it can be concluded that the initial conjecture <a href="Logical_consequence" title="wikilink">follows from</a> the axioms.</li>
<li>If, on the other hand, the empty clause cannot be derived, and the resolution rule cannot be applied to derive any more new clauses, the conjecture is not a theorem of the original knowledge base.</li>
</ul>

<p>One instance of this algorithm is the original <a href="Davis–Putnam_algorithm" title="wikilink">Davis–Putnam algorithm</a> that was later refined into the <a href="DPLL_algorithm" title="wikilink">DPLL algorithm</a> that removed the need for explicit representation of the resolvents.</p>

<p>This description of the resolution technique uses a set <em>S</em> as the underlying data-structure to represent resolution derivations. Lists, Trees and Directed Acyclic Graphs are other possible and common alternatives. Tree representations are more faithful to the fact that the resolution rule is binary. Together with a sequent notation for clauses, a tree representation also makes it clear to see how the resolution rule is related to a special case of the cut-rule, restricted to atomic cut-formulas. However, tree representations are not as compact as set or list representations, because they explicitly show redundant subderivations of clauses that are used more than once in the derivation of the empty clause. Graph representations can be as compact in the number of clauses as list representations and they also store structural information regarding which clauses were resolved to derive each resolvent.</p>
<h2 id="a-simple-example">A simple example</h2>

<p>

<math display="inline" id="Resolution_(logic):10">
 <semantics>
  <mfrac>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mo>∨</mo>
     <mi>b</mi>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>a</mi>
     </mrow>
     <mo>∨</mo>
     <mi>c</mi>
    </mrow>
   </mrow>
   <mrow>
    <mi>b</mi>
    <mo>∨</mo>
    <mi>c</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <list>
     <apply>
      <or></or>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <or></or>
      <apply>
       <times></times>
       <not></not>
       <ci>a</ci>
      </apply>
      <ci>c</ci>
     </apply>
    </list>
    <apply>
     <or></or>
     <ci>b</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{a\vee b,\quad\neg a\vee c}{b\vee c}
  </annotation>
 </semantics>
</math>

</p>

<p>In plain language: Suppose 

<math display="inline" id="Resolution_(logic):11">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is false. In order for the premise 

<math display="inline" id="Resolution_(logic):12">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∨</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\vee b
  </annotation>
 </semantics>
</math>

 to be true, 

<math display="inline" id="Resolution_(logic):13">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 must be true. Alternatively, suppose 

<math display="inline" id="Resolution_(logic):14">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is true. In order for the premise 

<math display="inline" id="Resolution_(logic):15">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>a</mi>
   </mrow>
   <mo>∨</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <times></times>
     <not></not>
     <ci>a</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg a\vee c
  </annotation>
 </semantics>
</math>

 to be true, 

<math display="inline" id="Resolution_(logic):16">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 must be true. Therefore regardless of falsehood or veracity of 

<math display="inline" id="Resolution_(logic):17">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, if both premises hold, then the conclusion 

<math display="inline" id="Resolution_(logic):18">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>∨</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>b</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\vee c
  </annotation>
 </semantics>
</math>

 is true.</p>
<h2 id="resolution-in-first-order-logic">Resolution in first order logic</h2>

<p>Resolution rule can be generalized to <a href="first-order_logic" title="wikilink">first-order logic</a> to:<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>

<math display="block" id="Resolution_(logic):19">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <msub>
      <mi mathvariant="normal">Γ</mi>
      <mn>1</mn>
     </msub>
     <mo>∪</mo>
     <mrow>
      <mrow>
       <mo>{</mo>
       <msub>
        <mi>L</mi>
        <mn>1</mn>
       </msub>
       <mo rspace="9.3pt">}</mo>
      </mrow>
      <msub>
       <mi mathvariant="normal">Γ</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo>∪</mo>
     <mrow>
      <mo>{</mo>
      <msub>
       <mi>L</mi>
       <mn>2</mn>
      </msub>
      <mo>}</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi mathvariant="normal">Γ</mi>
        <mn>1</mn>
       </msub>
       <mo>∪</mo>
       <msub>
        <mi mathvariant="normal">Γ</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>ϕ</mi>
    </mrow>
   </mfrac>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <union></union>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Γ</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <set>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <cn type="integer">1</cn>
        </apply>
       </set>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Γ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <set>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <cn type="integer">2</cn>
       </apply>
      </set>
     </apply>
     <apply>
      <times></times>
      <apply>
       <union></union>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Γ</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Γ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>ϕ</ci>
     </apply>
    </apply>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\Gamma_{1}\cup\left\{L_{1}\right\}\,\,\,\,\Gamma_{2}\cup\left\{L_{2}%
\right\}}{(\Gamma_{1}\cup\Gamma_{2})\phi}\phi
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Resolution_(logic):20">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 is a <a href="most_general_unifier" title="wikilink">most general unifier</a> of 

<math display="inline" id="Resolution_(logic):21">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Resolution_(logic):22">
 <semantics>
  <mover accent="true">
   <msub>
    <mi>L</mi>
    <mn>2</mn>
   </msub>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{L_{2}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Resolution_(logic):23">
 <semantics>
  <msub>
   <mi mathvariant="normal">Γ</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Γ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Resolution_(logic):24">
 <semantics>
  <msub>
   <mi mathvariant="normal">Γ</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Γ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma_{2}
  </annotation>
 </semantics>
</math>

 have no common variables.</p>
<h3 id="example">Example</h3>

<p>The clauses 

<math display="inline" id="Resolution_(logic):25">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>x</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x),Q(x)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Resolution_(logic):26">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>P</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg P(b)
  </annotation>
 </semantics>
</math>

 can apply this rule with 

<math display="inline" id="Resolution_(logic):27">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mi>b</mi>
    <mo>/</mo>
    <mi>x</mi>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <apply>
     <divide></divide>
     <ci>b</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [b/x]
  </annotation>
 </semantics>
</math>

 as unifier.</p>

<p>Here x is a variable and b is a constant.</p>

<p>

<math display="block" id="Resolution_(logic):28">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>Q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo rspace="9.3pt" stretchy="false">)</mo>
      </mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>b</mi>
     <mo>/</mo>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <list>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>Q</ci>
       <ci>x</ci>
       <not></not>
       <ci>P</ci>
       <ci>b</ci>
      </apply>
     </list>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <divide></divide>
      <ci>b</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{P(x),Q(x)\,\,\,\,\neg P(b)}{Q(b)}[b/x]
  </annotation>
 </semantics>
</math>

</p>

<p>Here we see that</p>
<ul>
<li>The clauses 

<math display="inline" id="Resolution_(logic):29">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>x</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x),Q(x)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Resolution_(logic):30">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>P</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg P(b)
  </annotation>
 </semantics>
</math>

 are the inference’s premises</li>
</ul>
<ul>
<li>

<math display="inline" id="Resolution_(logic):31">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(b)
  </annotation>
 </semantics>
</math>

 (the resolvent of the premises) is its conclusion.</li>
</ul>
<ul>
<li>The literal 

<math display="inline" id="Resolution_(logic):32">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x)
  </annotation>
 </semantics>
</math>

 is the left resolved literal,</li>
</ul>
<ul>
<li>The literal 

<math display="inline" id="Resolution_(logic):33">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>P</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg P(b)
  </annotation>
 </semantics>
</math>

 is the right resolved literal,</li>
</ul>
<ul>
<li>

<math display="inline" id="Resolution_(logic):34">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is the resolved atom or pivot.</li>
</ul>
<ul>
<li>

<math display="inline" id="Resolution_(logic):35">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mi>b</mi>
    <mo>/</mo>
    <mi>x</mi>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <apply>
     <divide></divide>
     <ci>b</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [b/x]
  </annotation>
 </semantics>
</math>

 is the most general unifier of the resolved literals.</li>
</ul>
<h3 id="informal-explanation">Informal explanation</h3>

<p>In first order logic, resolution condenses the traditional <a href="syllogism" title="wikilink">syllogisms</a> of <a href="rule_of_inference" title="wikilink">logical inference</a> down to a single rule.</p>

<p>To understand how resolution works, consider the following example syllogism of <a href="term_logic" title="wikilink">term logic</a>:</p>
<dl>
<dd>All Greeks are Europeans.
</dd>
<dd>Homer is a Greek.
</dd>
<dd>Therefore, Homer is a European.
</dd>
</dl>

<p>Or, more generally:</p>

<p>

<math display="block" id="Resolution_(logic):36">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⇒</mo>
    <mrow>
     <mi>Q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x.P(x)\Rightarrow Q(x)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Resolution_(logic):37">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(a)
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd>Therefore, 

<math display="inline" id="Resolution_(logic):38">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(a)
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>To recast the reasoning using the resolution technique, first the clauses must be converted to <a href="conjunctive_normal_form" title="wikilink">conjunctive normal form</a> (CNF). In this form, all <a href="Quantification_(logic)" title="wikilink">quantification</a> becomes implicit: <a href="Universal_quantification" title="wikilink">universal quantifiers</a> on variables (<em>X</em>, <em>Y</em>, …) are simply omitted as understood, while <a href="Existential_quantification" title="wikilink">existentially-quantified</a> variables are replaced by <a href="Skolem_function" title="wikilink">Skolem functions</a>.</p>

<p>

<math display="block" id="Resolution_(logic):39">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∨</mo>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <times></times>
     <not></not>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg P(x)\vee Q(x)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Resolution_(logic):40">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(a)
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd>Therefore, 

<math display="inline" id="Resolution_(logic):41">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(a)
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>So the question is, how does the resolution technique derive the last clause from the first two? The rule is simple:</p>
<ul>
<li>Find two clauses containing the same predicate, where it is negated in one clause but not in the other.</li>
<li>Perform a <a href="Unification_(computing)" title="wikilink">unification</a> on the two predicates. (If the unification fails, you made a bad choice of predicates. Go back to the previous step and try again.)</li>
<li>If any unbound variables which were bound in the unified predicates also occur in other predicates in the two clauses, replace them with their bound values (terms) there as well.</li>
<li>Discard the unified predicates, and combine the remaining ones from the two clauses into a new clause, also joined by the "∨" operator.</li>
</ul>

<p>To apply this rule to the above example, we find the predicate <em>P</em> occurs in negated form</p>
<dl>
<dd>¬<em>P</em>(<em>X</em>)
</dd>
</dl>

<p>in the first clause, and in non-negated form</p>
<dl>
<dd><em>P</em>(<em>a</em>)
</dd>
</dl>

<p>in the second clause. <em>X</em> is an unbound variable, while <em>a</em> is a bound value (term). Unifying the two produces the substitution</p>
<dl>
<dd><em>X</em> 

<math display="inline" id="Resolution_(logic):42">
 <semantics>
  <mo>↦</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">maps-to</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mapsto
  </annotation>
 </semantics>
</math>

 <em>a</em>
</dd>
</dl>

<p>Discarding the unified predicates, and applying this substitution to the remaining predicates (just <em>Q</em>(<em>X</em>), in this case), produces the conclusion:</p>
<dl>
<dd><em>Q</em>(<em>a</em>)
</dd>
</dl>

<p>For another example, consider the syllogistic form</p>
<dl>
<dd>All Cretans are islanders.
</dd>
<dd>All islanders are liars.
</dd>
<dd>Therefore all Cretans are liars.
</dd>
</dl>

<p>Or more generally,</p>
<dl>
<dd>∀<em>X</em> <em>P</em>(<em>X</em>) → <em>Q</em>(<em>X</em>)
</dd>
<dd>∀<em>X</em> <em>Q</em>(<em>X</em>) → <em>R</em>(<em>X</em>)
</dd>
<dd>Therefore, ∀<em>X</em> <em>P</em>(<em>X</em>) → <em>R</em>(<em>X</em>)
</dd>
</dl>

<p>In CNF, the antecedents become:</p>
<dl>
<dd>¬<em>P</em>(<em>X</em>) ∨ <em>Q</em>(<em>X</em>)
</dd>
<dd>¬<em>Q</em>(<em>Y</em>) ∨ <em>R</em>(<em>Y</em>)
</dd>
</dl>

<p>(Note that the variable in the second clause was renamed to make it clear that variables in different clauses are distinct.)</p>

<p>Now, unifying <em>Q</em>(<em>X</em>) in the first clause with ¬<em>Q</em>(<em>Y</em>) in the second clause means that <em>X</em> and <em>Y</em> become the same variable anyway. Substituting this into the remaining clauses and combining them gives the conclusion:</p>
<dl>
<dd>¬<em>P</em>(<em>X</em>) ∨ <em>R</em>(<em>X</em>)
</dd>
</dl>

<p>The resolution rule, as defined by Robinson, also incorporated factoring, which unifies two literals in the same clause, before or during the application of resolution as defined above. The resulting inference rule is refutation-complete,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> in that a set of clauses is unsatisfiable if and only if there exists a derivation of the empty clause using resolution alone.</p>
<h2 id="implementations">Implementations</h2>
<ul>
<li><a class="uri" href="CARINE" title="wikilink">CARINE</a></li>
<li><a href="Gandalf_(theorem_prover)" title="wikilink">Gandalf</a></li>
<li><a href="Otter_(theorem_prover)" title="wikilink">Otter</a></li>
<li><a class="uri" href="Prover9" title="wikilink">Prover9</a></li>
<li><a href="SNARK_(theorem_prover)" title="wikilink">SNARK</a></li>
<li><a class="uri" href="SPASS" title="wikilink">SPASS</a></li>
<li><a href="Vampire_(theorem_prover)" title="wikilink">Vampire</a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Condensed_detachment" title="wikilink">Condensed detachment</a> — an earlier version of resolution</li>
<li><a href="Inductive_logic_programming" title="wikilink">Inductive logic programming</a></li>
<li><a href="Inverse_resolution" title="wikilink">Inverse resolution</a></li>
<li><a href="Logic_programming" title="wikilink">Logic programming</a></li>
<li><a href="Method_of_analytic_tableaux" title="wikilink">Method of analytic tableaux</a></li>
<li><a href="SLD_resolution" title="wikilink">SLD resolution</a></li>
<li><a href="Resolution_inference" title="wikilink">Resolution inference</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>Approaches to <strong>non-clausal resolution</strong>, i.e. resolution of first-order formulas that need not be in <a href="clausal_normal_form" title="wikilink">clausal normal form</a>, are presented in:</p>
<ul>
<li></li>
<li>

<p>(Cited from Manna, Waldinger, 1980 as: "A Proof Procedure for Non-Clausal First-Order Logic", 1978)</p></li>
<li>

<p>A preprint appearead in Dec 1978 as <a href="http://www.sri.com/sites/default/files/uploads/publications/pdf/725.pdf">SRI Technical Note 177</a></p></li>
<li></li>
<li>

<p>[<a class="uri" href="http://www.zentralblatt-math.org/ioport/en/?id=2297405&amp;type">http://www.zentralblatt-math.org/ioport/en/?id=2297405&amp;type;</a>;=pdf Summary]</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:1965_introductions" title="wikilink">Category:1965 introductions</a> <a href="Category:Rules_of_inference" title="wikilink">Category:Rules of inference</a> <a href="Category:Automated_theorem_proving" title="wikilink">Category:Automated theorem proving</a> <a href="Category:Theorems_in_propositional_logic" title="wikilink">Category:Theorems in propositional logic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"> Here: p.210, "III. Rule for Eliminating Atomic Formulas".<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">D.E. Knuth, <em>The Art of Computer Programming</em> <strong>4A</strong>: <em>Combinatorial Algorithms</em>, part 1, p. 539<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">Enrique P. Arís, Juan L. González y Fernando M. Rubio, Lógica Computacional, Thomson, (2005).<a href="#fnref6">↩</a></li>
<li id="fn7"> p. 350 (=p.286 in the 1st edition of 1995)<a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
