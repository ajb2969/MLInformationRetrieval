<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1703">Vehicle routing problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Vehicle routing problem</h1>
<hr/>

<p> The <strong>vehicle routing problem (VRP)</strong> is a <a href="combinatorial_optimization" title="wikilink">combinatorial optimization</a> and <a href="integer_programming" title="wikilink">integer programming</a> problem which asks "What is the optimal set of routes for a fleet of vehicles to traverse in order to deliver to a given set of customers?". It generalises the well-known <a href="Travelling_Salesman_Problem" title="wikilink">Travelling Salesman Problem</a> (TSP). It first appeared in a paper by <a href="George_Dantzig" title="wikilink">George Dantzig</a> and John Ramser in 1959,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> in which first algorithmic approach was written and was applied to petrol deliveries. Often, the context is that of delivering goods located at a central depot to customers who have placed orders for such goods. The objective of the VRP is to minimize the total route cost. In 1964, Clarke and Wright improved on Dantzig and Ramser's approach using an effective greedy approach called the savings algorithm.</p>

<p>Determining the optimal solution is an <a class="uri" href="NP-hard" title="wikilink">NP-hard</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> problem in <a href="combinatorial_optimization" title="wikilink">combinatorial optimization</a>, so the size of problems that can be solved optimally is limited . The commercial solvers therefore tend to use heuristics due to the size of real world VRPs and the frequency that they may have to be solved.</p>

<p>The VRP has many obvious applications in industry. In fact the use of computer optimisation programs can give savings of 5% to a company <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> as transportation is usually a significant component of the cost of a product (10%) <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> - indeed the transportation sector makes up 10% of the <a href="European_Union" title="wikilink">EU's</a> <a href="Gross_domestic_product" title="wikilink">GDP</a>. Consequently, any savings created by the VRP, even less than 5%, are significant.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="setting-up-the-problem">Setting up the problem</h2>

<p>The VRP concerns the service of a delivery company. How things are delivered from one or more <em>depots</em> which has a given set of home <em>vehicles</em> and operated by a set of <em>drivers</em> who can move on a given <em>road network</em> to a set of <em>customers</em>. It asks for a determination of a set of <em>routes</em>, <em>S</em>, (one route for each vehicle that must start and finish at its own depot) such that all customers' requirements and operational constraints are satisfied and the <em>global transportation cost</em> is minimised. This cost may be monetary, distance or otherwise.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>The road network can be described using a <a href="Graph_(mathematics)" title="wikilink">graph</a> where the arcs are roads and vertices are junctions between them. The arcs may be directed or undirected due to the possible presence of one way streets or different costs in each direction. Each arc has an associated cost which is generally its length or travel time which may be dependent on vehicle type.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>To know the global cost of each route, the travel cost and the travel time between each customer and the depot must be known. To do this our original graph is transformed into one where the vertices are the customers and depot and the arcs are the roads between them. The cost on each arc is the lowest cost between the two points on the original road network. This is easy to do as <a href="shortest_path_problems" title="wikilink">shortest path problems</a> are relatively easy to solve. This transforms the sparse original graph into a <a href="complete_graph" title="wikilink">complete graph</a>. For each pair of vertices <em>i</em> and <em>j</em>, there exists an arc <em>(i,j)</em> of the complete graph whose cost is written as 

<math display="inline" id="Vehicle_routing_problem:0">
 <semantics>
  <msub>
   <mi>C</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{ij}
  </annotation>
 </semantics>
</math>

 and is defined to be the cost of shortest path from <em>i</em> to <em>j</em>. The travel time 

<math display="inline" id="Vehicle_routing_problem:1">
 <semantics>
  <msub>
   <mi>t</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{ij}
  </annotation>
 </semantics>
</math>

 is the sum of the travel times of the arcs on the shortest path from <em>i</em> to <em>j</em> on the original road graph.</p>

<p>Sometimes it is impossible to satisfy all of a customer's demands and in such cases solvers may reduce some customers' demands or leave some customers unserved. To deal with these situations a priority variable for each customer can be introduced or associated penalties for the partial or lack of service for each customer given <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>The objective function of a VRP can be very different depending on the particular application of the result but a few of the more common objectives are:<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<ul>
<li>Minimise the global transportation cost based on the global distance travelled as well as the fixed costs associated with the used vehicles and drivers</li>
<li>Minimise the number of vehicles needed to serve all customers</li>
<li>Least variation in travel time and vehicle load</li>
<li>Minimise penalties for low quality service</li>
</ul>
<h2 id="vrp-flavours">VRP flavours</h2>

<p><a href="File:Map_of_vrp_subproblems.jpg" title="wikilink">thumb|right|upright=1.75|A map showing the relationship between common VRP subproblems.</a></p>

<p>Several variations and specializations of the vehicle routing problem exist:</p>
<ul>
<li>Vehicle Routing Problem with Pickup and Delivery (VRPPD): A number of goods need to be moved from certain pickup locations to other delivery locations. The goal is to find optimal routes for a fleet of vehicles to visit the pickup and drop-off locations.</li>
<li>Vehicle Routing Problem with <a href="LIFO_(computing)" title="wikilink">LIFO</a>: Similar to the VRPPD, except an additional restriction is placed on the loading of the vehicles: at any delivery location, the item being delivered must be the item most recently picked up. This scheme reduces the loading and unloading times at delivery locations because there is no need to temporarily unload items other than the ones that should be dropped off.</li>
<li>Vehicle Routing Problem with Time Windows (VRPTW): The delivery locations have time windows within which the deliveries (or visits) must be made.</li>
<li>Capacitated Vehicle Routing Problem: CVRP or CVRPTW. The vehicles have limited carrying capacity of the goods that must be delivered.</li>
<li>Vehicle Routing Problem with Multiple Trips (VRPMT): The vehicles can do more than one route.</li>
<li>Open Vehicle Routing Problem (OVRP): Vehicles are not required to return to the depot.</li>
</ul>

<p>Several software vendors have built software products to solve the various VRP problems. Numerous articles are available for more detail on their research and results.</p>

<p>Although VRP is related to the <a href="Job_Shop_Scheduling" title="wikilink">Job Shop Scheduling</a> Problem, the two problems are typically solved using different techniques.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="exact-solution-methods">Exact solution methods</h2>

<p>There are thee main different approaches to modelling the VRP</p>
<ol>
<li><strong>Vehicle flow formulations</strong> - this uses integer variables associated with each arc that count the number of times that the edge is traversed by a vehicle. It is generally used for basic VRPs. This is good for cases where the solution cost can be expressed as the sum of any costs associated with the arcs. However it can't be used to handle many practical applications.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></li>
</ol>
<ol>
<li><strong>Commodity flow formulations</strong> - additional integer variables are associated with the arcs or edges which represent the flow of commodities along the paths travelled by the vehicles. This has only recently been used to find an exact solution.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></li>
</ol>
<ol>
<li>Set partitioning problem - These have an exponential number of binary variables which are each associated with a different feasible circuit. The VRP is then instead formulated as a set partitioning problem which asks what is the collection of circuits with minimum cost that satisfy the VRP constraints. This allows for very general route costs.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></li>
</ol>
<h3 id="vehicle-flow-formulations">Vehicle flow formulations</h3>

<p>The formulation of the TSP by Dantzig, Fulkerson and Johnson was extended to create the two index vehicle flow formulations for the VRP</p>

<p>

<math display="inline" id="Vehicle_routing_problem:2">
 <semantics>
  <mrow>
   <mtext>min</mtext>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>∈</mo>
      <mi>V</mi>
     </mrow>
    </msub>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>∈</mo>
       <mi>V</mi>
      </mrow>
     </msub>
     <mrow>
      <msub>
       <mi>c</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>min</mtext>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>V</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>j</ci>
        <ci>V</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{min}\sum_{i\in V}\sum_{j\in V}c_{ij}x_{ij}
  </annotation>
 </semantics>
</math>

 subject to</p>

<p>

<math display="inline" id="Vehicle_routing_problem:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>∈</mo>
       <mi>V</mi>
      </mrow>
     </msub>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>j</mi>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mi>V</mi>
     <mo>\</mo>
     <mrow>
      <mo>{</mo>
      <mn>0</mn>
      <mo>}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>i</ci>
        <ci>V</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>j</ci>
     </apply>
     <apply>
      <ci>normal-\</ci>
      <ci>V</ci>
      <set>
       <cn type="integer">0</cn>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i\in V}x_{ij}=1~{}~{}~{}~{}\forall j\in V\backslash\left\{0\right\}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Vehicle_routing_problem:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>∈</mo>
       <mi>V</mi>
      </mrow>
     </msub>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mi>V</mi>
     <mo>\</mo>
     <mrow>
      <mo>{</mo>
      <mn>0</mn>
      <mo>}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>j</ci>
        <ci>V</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>i</ci>
     </apply>
     <apply>
      <ci>normal-\</ci>
      <ci>V</ci>
      <set>
       <cn type="integer">0</cn>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{j\in V}x_{ij}=1~{}~{}~{}~{}\forall i\in V\backslash\left\{0\right\}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Vehicle_routing_problem:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>∈</mo>
      <mi>V</mi>
     </mrow>
    </msub>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>i</mi>
      <mn>0</mn>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>K</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>V</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i\in V}x_{i0}=K
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Vehicle_routing_problem:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>∈</mo>
      <mi>V</mi>
     </mrow>
    </msub>
    <msub>
     <mi>x</mi>
     <mrow>
      <mn>0</mn>
      <mi>j</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>K</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>j</ci>
       <ci>V</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <times></times>
       <cn type="integer">0</cn>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{j\in V}x_{0j}=K
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Vehicle_routing_problem:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>∉</mo>
       <mi>V</mi>
      </mrow>
     </msub>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>∈</mo>
        <mi>S</mi>
       </mrow>
      </msub>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mi>r</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>S</mi>
     </mrow>
     <mo>⊆</mo>
     <mrow>
      <mi>V</mi>
      <mo>\</mo>
      <mrow>
       <mo>{</mo>
       <mn>0</mn>
       <mo>}</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>S</mi>
     <mo>≠</mo>
     <mi mathvariant="normal">∅</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <geq></geq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <notin></notin>
        <ci>i</ci>
        <ci>V</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <in></in>
         <ci>j</ci>
         <ci>S</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <subset></subset>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>S</ci>
      </apply>
      <apply>
       <ci>normal-\</ci>
       <ci>V</ci>
       <set>
        <cn type="integer">0</cn>
       </set>
      </apply>
     </apply>
     <apply>
      <neq></neq>
      <ci>S</ci>
      <emptyset></emptyset>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i\notin V}\sum_{j\in S}x_{ij}\geq r(s)~{}~{}~{}~{}\forall S\subseteq V%
\backslash\left\{0\right\},S\neq\emptyset
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Vehicle_routing_problem:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo>∈</mo>
    <mrow>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mrow>
      <mo>∀</mo>
      <mi>i</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>j</mi>
    <mo>∈</mo>
    <mi>V</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <list>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>i</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <in></in>
     <ci>j</ci>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{ij}\in{0,1}~{}~{}~{}~{}\forall i,j\in V
  </annotation>
 </semantics>
</math>

</p>

<p>Constraint 1 and 2 say that exactly one arc enters and exactly one leaves each vertex associated with a customer respectively. Constraint 3 and 4 says that the number of vehicles leaving the depot is the same as the number entering. We say that 3, 4 and 5 are the capacity cut constraints, these impose that the routes must be connected and that the demand on each route must not exceed the vehicle capacity.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>One arbitrary constraint among the <em>2|V|</em> constraints is actually implied by the remaining <em>2|V|-1</em> ones so it can be removed. Each cut defined by a customer set <em>S$</em> is crossed by a number of arcs not smaller than <em>r(s)</em> (minimum number of vehicles needed to serve set <em>S</em>).<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>An alternative formulation may be obtained by transforming the capacity cut constraints into generalised subtour elimination constraints (GSECs). 

<math display="inline" id="Vehicle_routing_problem:9">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>∈</mo>
      <mi>S</mi>
     </mrow>
    </msub>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>∈</mo>
       <mi>S</mi>
      </mrow>
     </msub>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>S</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>r</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>j</ci>
        <ci>S</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <abs></abs>
      <ci>S</ci>
     </apply>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i\in S}\sum_{j\in S}x_{ij}\leq|S|-r(s)
  </annotation>
 </semantics>
</math>

 which imposes that at least <em>r(s)</em> arcs leave each customer set <em>S</em>.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>GCECs and CCCs have an exponential number of constraints so it is practically impossible to solve the linear relaxation. A possible way to solve this is to consider a limited subset of these constraints and add the rest if needed.</p>

<p>A different method again is to use a family of constraints which have a polynomial cardinality which are known as the MTZ constraints, they were first proposed for the TSP <a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> and subsequently extended by Christofides, Mingozzi and Toth.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> 

<math display="inline" id="Vehicle_routing_problem:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>u</mi>
       <mi>i</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>u</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>C</mi>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mrow>
      <mi>C</mi>
      <mo>-</mo>
      <msub>
       <mi>d</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mrow>
      <mo>∀</mo>
      <mi>i</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>j</mi>
     <mo>∈</mo>
     <mrow>
      <mi>V</mi>
      <mo>\</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mn>0</mn>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mi>i</mi>
      <mo>≠</mo>
      <mi>j</mi>
     </mrow>
     <mrow>
      <mrow>
       <mrow>
        <mtext>s.t.</mtext>
        <msub>
         <mi>d</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo>+</mo>
       <msub>
        <mi>d</mi>
        <mi>j</mi>
       </msub>
      </mrow>
      <mo>≤</mo>
      <mi>C</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>C</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <list>
      <apply>
       <minus></minus>
       <ci>C</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>i</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>j</ci>
      <apply>
       <ci>normal-\</ci>
       <ci>V</ci>
       <set>
        <cn type="integer">0</cn>
       </set>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <neq></neq>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <leq></leq>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <mtext>s.t.</mtext>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>d</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>d</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>C</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}-u_{j}+Cx_{ij}\leq C-d_{j}~{}~{}~{}~{}~{}~{}\forall i,j\in V\backslash\{0%
\},i\neq j~{}~{}~{}~{}\text{s.t. }d_{i}+d_{j}\leq C
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Vehicle_routing_problem:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>d</mi>
     <mi>i</mi>
    </msub>
    <mo>≤</mo>
    <msub>
     <mi>u</mi>
     <mi>i</mi>
    </msub>
    <mo>≤</mo>
    <mi>C</mi>
   </mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mi>V</mi>
     <mo>\</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <leq></leq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <leq></leq>
      <share href="#.cmml">
      </share>
      <ci>C</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>i</ci>
     </apply>
     <apply>
      <ci>normal-\</ci>
      <ci>V</ci>
      <set>
       <cn type="integer">0</cn>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{i}\leq u_{i}\leq C~{}~{}~{}~{}~{}~{}\forall i\in V\backslash\{0\}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Vehicle_routing_problem:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>u</mi>
     <mi>i</mi>
    </msub>
    <mo rspace="5.8pt">,</mo>
    <mi>i</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>V</mi>
    <mo>\</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>i</ci>
     </apply>
     <ci>i</ci>
    </list>
    <apply>
     <ci>normal-\</ci>
     <ci>V</ci>
     <set>
      <cn type="integer">0</cn>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i},~{}i\in V\backslash\{0\}
  </annotation>
 </semantics>
</math>

 is an additional continuous variable which represents the load of the vehicle after visiting customer <em>i</em> and <em>d_i</em> is the demand of customer <em>i</em>. These impose both the connectivity and the capacity requirements. When 

<math display="inline" id="Vehicle_routing_problem:13">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{ij}=0
  </annotation>
 </semantics>
</math>

 constraint then <em>i</em> 'is not binding' since 

<math display="inline" id="Vehicle_routing_problem:14">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mi>i</mi>
   </msub>
   <mo>≤</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>i</ci>
    </apply>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}\leq C
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Vehicle_routing_problem:15">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mi>j</mi>
   </msub>
   <mo>≥</mo>
   <msub>
    <mi>d</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{j}\geq d_{j}
  </annotation>
 </semantics>
</math>

 whereas 

<math display="inline" id="Vehicle_routing_problem:16">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{ij}=1
  </annotation>
 </semantics>
</math>

 they impose that 

<math display="inline" id="Vehicle_routing_problem:17">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mi>j</mi>
   </msub>
   <mo>≥</mo>
   <mrow>
    <msub>
     <mi>u</mi>
     <mi>i</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>d</mi>
     <mi>j</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{j}\geq u_{i}+d_{j}
  </annotation>
 </semantics>
</math>

.</p>

<p>These have been used extensively to model the basic VRP (CVRP) and the VRPB. However their power is limited to these simple problems. They can only be used when the cost of the solution can be expressed as the sum of the costs of the arc costs. We cannot also know which vehicle traverses each arc. Hence we cannot use this for more complex models where the cost and or feasibility is dependent on the order of the customers or the vehicles used.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<h2 id="free-software-for-solving-vrp">Free software for solving VRP</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Name<br/>
(alphabetically)</p></th>
<th style="text-align: left;">
<p>License</p></th>
<th style="text-align: left;">
<p>API language</p></th>
<th style="text-align: left;">
<p>Brief info</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>jsprit</p></td>
<td style="text-align: left;">
<p>LGPL</p></td>
<td style="text-align: left;">
<p>Java</p></td>
<td style="text-align: left;">
<p>lightweight, java based, open source toolkit for solving rich VRPs. <a href="http://jsprit.github.io/">link</a> An Excel-compatible user interface for jsprit is available with mapping, reporting and route editing functionality. <a href="http://www.opendoorlogistics.com/new-version-released-vehicle-fleet-scheduling/">link</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Open-VRP</p></td>
<td style="text-align: left;">
<p><a href="http://opensource.franz.com/preamble.html">LLGPL</a></p></td>
<td style="text-align: left;">
<p>Lisp</p></td>
<td style="text-align: left;">
<p>Open-VRP for Lisp, hosted on Github. <a href="https://github.com/mck-/Open-VRP">link</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="OptaPlanner" title="wikilink">OptaPlanner</a></p></td>
<td style="text-align: left;">
<p><a href="Apache_License" title="wikilink">Apache License</a></p></td>
<td style="text-align: left;">
<p>Java</p></td>
<td style="text-align: left;">
<p>Open Source Java constraint solver (<a href="http://www.optaplanner.org">optaplanner.org</a>) with VRP examples.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>SYMPHONY</p></td>
<td style="text-align: left;">
<p><a href="Common_Public_License" title="wikilink">Common Public License</a> 1.0</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Open-source solver for mixed-integer linear programs (MILPs) with support for VRPs. <a href="http://projects.coin-or.org/SYMPHONY">link</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>VRP Spreadsheet Solver</p></td>
<td style="text-align: left;">
<p>Creative Commons Attribution 4.0 International License</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Microsoft Excel and VBA based open source solver, with a link to public GIS for data retrieval. <a href="http://verolog.deis.unibo.it/vrp-spreadsheet-solver">link</a> Video tutorial <a href="https://www.youtube.com/watch?v=enCBp2lBn64">link</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>vrphlibrary (VRPH)</p></td>
<td style="text-align: left;">
<p><a href="Common_Public_License" title="wikilink">Common Public License</a> 1.0</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Home page of open source VRPH software <a href="http://sites.google.com/site/vrphlibrary/">link</a> and hosting page on <a class="uri" href="COIN-OR" title="wikilink">COIN-OR</a> <a href="http://sites.google.com/site/vrphlibrary/">link</a>.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>vroom</p></td>
<td style="text-align: left;">
<p>?</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>Open source libraries for the VRP and dynamic VRP. <a href="http://victorpillac.com/vroom/">link</a></p></td>
</tr>
</tbody>
</table>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Chinese_postman_problem" title="wikilink">Chinese postman problem</a></li>
<li><a href="Travelling_salesman_problem" title="wikilink">Travelling salesman problem</a></li>
<li><a href="Intelligent_Water_Drops_algorithm" title="wikilink">Intelligent Water Drops algorithm</a></li>
<li><a href="Vehicle_rescheduling_problem" title="wikilink">Vehicle rescheduling problem</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://neo.lcc.uma.es/vrp">The VRP Web - Extensive information, test instances and various VRP variants</a></li>
<li><a href="http://www.orms-today.org/surveys/Vehicle_Routing/vrss.html">Vehicle Routing Software Survey - an INFORMS review</a></li>
<li><a href="http://www.dna-evolutions.com/dnaappletsample.html">Demo applet of a genetic algorithm solving TSPs and VRPTW problems</a></li>
<li><a href="http://www.routyn.com">Routyn - commercial software for solving VRPs</a></li>
<li><a href="http://www.optimoroute.com">Optimo Route - commercial CVRPTW solver</a></li>
<li><a href="https://routific.com">Routific - commercial CVRPPDTW software</a></li>
</ul>

<p>"</p>

<p><a href="Category:NP-complete_problems" title="wikilink">Category:NP-complete problems</a> <a href="Category:Operations_research" title="wikilink">Category:Operations research</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"></li>
</ol>
</section>
</body>
</html>
