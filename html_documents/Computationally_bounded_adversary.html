<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1830">Computationally bounded adversary</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Computationally bounded adversary</h1>
<hr>In [[information theory]], the '''computationally bounded adversary''' problem is a different way of looking at the problem of sending data over a noisy channel. In previous models the best that could be done was ensuring correct de
<p>coding for up to <em>d</em>/2 errors, where d was the Hamming distance of the code. The problem with doing it this way is that it does not take into consideration the actual amount of computing power available to the adversary. Rather, it only concerns itself with how many bits of a given code word can change and still have the message decode properly. In the computationally bounded adversary model the channel – the <a href="Adversary_(cryptography)" title="wikilink"> adversary</a> – is restricted to only being able to perform a reasonable amount of computation to decide which bits of the code word need to change. In other words, this model does not need to consider how many errors can possibly be handled, but only how many errors could possibly be introduced given a reasonable amount of computing power on the part of the adversary. Once the channel has been given this restriction it becomes possible to construct codes that are both faster to encode and decode compared to previous methods that can also handle a large number of errors.</p>
<h2 id="comparison-to-other-models">Comparison to other models</h2>
<h3 id="worst-case-model">Worst-case model</h3>

<p>At first glance, the <a href="worst-case_complexity" title="wikilink"> worst-case model</a> seems intuitively ideal. The guarantee that an algorithm will succeed no matter what is, of course, highly alluring. However, it demands too much. A real-life adversary cannot spend an indefinite amount of time examining a message in order to find the one error pattern which an algorithm would struggle with.</p>

<p>As a comparison, consider the <a class="uri" href="Quicksort" title="wikilink">Quicksort</a> algorithm. In the worst-case scenario, Quicksort makes O(<em>n</em><sup>2</sup>) comparisons; however, such an occurrence is rare. Quicksort almost invariably makes O(<em>n</em> log <em>n</em>) comparisons instead, and even outperforms other algorithms which can guarantee O(<em>n</em> log <em>n</em>) behavior. Let us suppose an adversary wishes to force the Quicksort algorithm to make O(<em>n</em><sup>2</sup>) comparisons. Then he would have to search all of the <em>n</em>! permutations of the input string and test the algorithm on each until he found the one for which the algorithm runs significantly slower. But since this would take O(<em>n</em>!) time, it is clearly infeasible for an adversary to do this. Similarly, it is unreasonable to assume an adversary for an encoding and decoding system would be able to test every single error pattern in order to find the most effective one.</p>
<h3 id="stochastic-noise-model">Stochastic noise model</h3>

<p>The stochastic noise model can be described as a kind of "dumb" noise model. That is to say that it does not have the adaptability to deal with "intelligent" threats. Even if the attacker is bounded it is still possible that they might be able to overcome the stochastic model with a bit of cleverness. The stochastic model has no real way to fight against this sort of attack and as such as unsuited to dealing with the kind of "intelligent" threats that would be preferable to have defenses against.</p>
<hr/>

<p>Therefore, a computationally bounded adversarial model has been proposed as a compromise between the two. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> This forces one to consider that messages may be perverted in conscious, even malicious ways, but without forcing an algorithm designer to worry about rare cases which likely will never occur.</p>
<h2 id="applications">Applications</h2>
<h3 id="comparison-to-stochastic-noise-channel">Comparison to stochastic noise channel</h3>

<p>Since any computationally bounded adversary could in O(<em>n</em>) time flip a coin for each bit, it is intuitively clear that any encoding and decoding system which can work against this adversary must also work in the stochastic noise model. The converse is less simple; however, it can be shown that any system which works in the stochastic noise model can also efficiently encode and decode against a computationally bounded adversary, and only at an additional cost which is polynomial in <em>n</em>. <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The following method to accomplish this was designed by Dick Lipton, and is taken from:<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a>  Let 

<math display="inline" id="Computationally_bounded_adversary:0">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <list></list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E()
  </annotation>
 </semantics>
</math>

 be an encoder for the stochastic noise model and 

<math display="inline" id="Computationally_bounded_adversary:1">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <list></list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D()
  </annotation>
 </semantics>
</math>

 be a simple decoder for the same, each of which runs in polynomial time. Furthermore, let both the sender and receiver share some random permutation function 

<math display="inline" id="Computationally_bounded_adversary:2">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 and a random pattern 

<math display="inline" id="Computationally_bounded_adversary:3">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

.</p>

<p>For encoding: 1. Let 

<math display="inline" id="Computationally_bounded_adversary:4">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=E(M)
  </annotation>
 </semantics>
</math>

.</p>

<p>2. Let 

<math display="inline" id="Computationally_bounded_adversary:5">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>π</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊕</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Y</ci>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <times></times>
      <ci>π</ci>
      <ci>X</ci>
     </apply>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=\pi(X)\oplus R
  </annotation>
 </semantics>
</math>

.</p>

<p>3. Transmit 

<math display="inline" id="Computationally_bounded_adversary:6">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

</p>

<p>Then for decoding: 1. Receive 

<math display="inline" id="Computationally_bounded_adversary:7">
 <semantics>
  <msup>
   <mi>Y</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>Y</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y^{\prime}
  </annotation>
 </semantics>
</math>

. Compute 

<math display="inline" id="Computationally_bounded_adversary:8">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>π</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>Y</mi>
       <mo>′</mo>
      </msup>
      <mo>⊕</mo>
      <mi>R</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Z</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>π</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Y</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>R</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z=\pi^{-1}(Y^{\prime}\oplus R)
  </annotation>
 </semantics>
</math>

.</p>

<p>2. Calculate 

<math display="inline" id="Computationally_bounded_adversary:9">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=D(Z)
  </annotation>
 </semantics>
</math>

.</p>

<p>Similarly to the Quicksort comparison above, if the channel wants to do something smart, it must first test all the permutations. However, this is infeasible for a computationally bounded adversary, so the most it can do is make a random error pattern 

<math display="inline" id="Computationally_bounded_adversary:10">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

. But then:</p>

<p>

<math display="block" id="Computationally_bounded_adversary:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>Z</mi>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>π</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>Y</mi>
        <mo>′</mo>
       </msup>
       <mo>⊕</mo>
       <mi>R</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>π</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>Y</mi>
       <mo>⊕</mo>
       <mi>N</mi>
       <mo>⊕</mo>
       <mi>R</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>Z</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>π</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">direct-sum</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Y</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>R</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>π</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">direct-sum</csymbol>
       <ci>Y</ci>
       <ci>N</ci>
       <ci>R</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z=\pi^{-1}(Y^{\prime}\oplus R)=\pi^{-1}(Y\oplus N\oplus R),
  </annotation>
 </semantics>
</math>

</p>

<p>since 

<math display="inline" id="Computationally_bounded_adversary:12">
 <semantics>
  <mrow>
   <msup>
    <mi>Y</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>Y</mi>
    <mo>⊕</mo>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Y</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <ci>Y</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y^{\prime}=Y\oplus N
  </annotation>
 </semantics>
</math>

 by definition.</p>

<p>

<math display="block" id="Computationally_bounded_adversary:13">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>π</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>Y</mi>
       <mo>⊕</mo>
       <mi>R</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊕</mo>
    <msup>
     <mi>N</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>π</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">direct-sum</csymbol>
       <ci>Y</ci>
       <ci>R</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>N</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\pi^{-1}(Y\oplus R)\oplus N^{\prime}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Computationally_bounded_adversary:14">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>N</mi>
     <mo>′</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>π</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>N</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>N</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>π</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N^{\prime}=\pi^{-1}(N),
  </annotation>
 </semantics>
</math>

</p>

<p>since any permutation is linear with respect to XOR,</p>

<p>

<math display="block" id="Computationally_bounded_adversary:15">
 <semantics>
  <mrow>
   <mrow>
    <mi></mi>
    <mo>=</mo>
    <mrow>
     <mi>X</mi>
     <mo>⊕</mo>
     <msup>
      <mi>N</mi>
      <mo>′</mo>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <ci>X</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>N</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =X\oplus N^{\prime},
  </annotation>
 </semantics>
</math>

</p>

<p>as per the definition of 

<math display="inline" id="Computationally_bounded_adversary:16">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 above.</p>

<p>Since 

<math display="inline" id="Computationally_bounded_adversary:17">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 is random, 

<math display="inline" id="Computationally_bounded_adversary:18">
 <semantics>
  <msup>
   <mi>N</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>N</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N^{\prime}
  </annotation>
 </semantics>
</math>

 is just random noise and we can use the simple decoder to decode the received message and get back 

<math display="inline" id="Computationally_bounded_adversary:19">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="specific-applications">Specific applications</h2>

<p>By assuming a computationally bounded adversary, it is possibly to design a <a href="locally_decodable_code" title="wikilink">locally decodable code</a> which is both efficient and near-optimal, with a negligible error probability. These codes are used in complexity theory for things like self-correcting computations, probabilistically checkable proof systems, and worst-case to average-case hardness reductions in the constructions of pseudo-random generators. They are useful in cryptography as a result of their connection with <a href="private_information_retrieval" title="wikilink">private information retrieval</a> protocols. They are also in a number of database applications like <a class="uri" href="fault-tolerant" title="wikilink">fault-tolerant</a> data storage. <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Furthermore, it is possible to construct codes which surpass known bounds for worst-case codes--specifically, unique decoding with a 

<math display="inline" id="Computationally_bounded_adversary:20">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-R
  </annotation>
 </semantics>
</math>

 error rate. <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> This can be done by concatenating timestamped digital signatures onto messages. A computationally bounded channel cannot forge a signature; and while it may have valid past signatures, the receiver can use <a href="list_decoding" title="wikilink">list decoding</a> and select a message only if its signature has the correct timestamp.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Computational_complexity_theory" title="wikilink">Category:Computational complexity theory</a> <a href="Category:Coding_theory" title="wikilink">Category:Coding theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</hr></body>
</html>
