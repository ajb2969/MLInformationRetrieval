<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1229">Catamorphism</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Catamorphism</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a href="category_theory" title="wikilink">category theory</a>, the concept of <strong>catamorphism</strong> (from <a href="Greek_language" title="wikilink">Greek</a>: <a href="wikt:κατά" title="wikilink">κατά</a> = <em>downwards</em> or <em>according to</em>; <a href="wikt:μορφή" title="wikilink">μορφή</a> = <em>form</em> or <em>shape</em>) denotes the unique <a class="uri" href="homomorphism" title="wikilink">homomorphism</a> from an <a href="initial_algebra" title="wikilink">initial algebra</a> into some other algebra.</p>

<p>In <a href="functional_programming" title="wikilink">functional programming</a>, catamorphisms provide generalizations of <em><a href="Fold_(higher-order_function)" title="wikilink">folds</a></em> of <a href="List_(computing)" title="wikilink">lists</a> to arbitrary <a href="algebraic_data_type" title="wikilink">algebraic data types</a>, which can be described as <a href="initial_algebra" title="wikilink">initial algebras</a>. The dual concept is that of <a class="uri" href="anamorphism" title="wikilink">anamorphism</a> and they generalize <em>unfolds</em>. See also <a href="Hylomorphism_(computer_science)" title="wikilink">Hylomorphism</a>.</p>
<h2 id="definition">Definition</h2>

<p>Consider an <a href="Initial_algebra" title="wikilink">initial</a> <a href="F-algebra" title="wikilink"><em>F</em>-algebra</a> (<em>A</em>, <em>in</em>) for some <a class="uri" href="endofunctor" title="wikilink">endofunctor</a> <em>F</em> of some <a href="category_(mathematics)" title="wikilink">category</a> into itself. Here <em>in</em> is a <a class="uri" href="morphism" title="wikilink">morphism</a> from <em>FA</em> to <em>A</em>. Since it is initial, we know that whenever (<em>X</em>, <em>f</em>) is another <em>F</em>-algebra, i.e. a morphism <em>f</em> from <em>FX</em> to <em>X</em>, there is a unique <a class="uri" href="homomorphism" title="wikilink">homomorphism</a> <em>h</em> from (<em>A</em>, <em>in</em>) to (<em>X</em>, <em>f</em>). By the definition of the category of <em>F</em>-algebras, this <em>h</em> corresponds to a morphism from <em>A</em> to <em>X</em>, conventionally also denoted <em>h</em>, such that <em>h <strong>.</strong> in = f <strong>.</strong> Fh</em>. In the context of <em>F</em>-algebras, the uniquely specified morphism from the initial object is denoted by <strong>cata</strong> <strong><em>f</em></strong> and hence characterized by the following relationship:</p>
<ul>
<li>

<math display="inline" id="Catamorphism:0">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>cata</mi>
    </mpadded>
    <mi>f</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>h</ci>
    <apply>
     <times></times>
     <ci>cata</ci>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h=\mathrm{cata}\ f
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Catamorphism:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mo>∘</mo>
     <mi>i</mi>
    </mrow>
    <mi>n</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mo>∘</mo>
     <mi>F</mi>
    </mrow>
    <mi>h</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <compose></compose>
      <ci>h</ci>
      <ci>i</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <compose></compose>
      <ci>f</ci>
      <ci>F</ci>
     </apply>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h\circ in=f\circ Fh
  </annotation>
 </semantics>
</math>

</li>
</ul>
<h2 id="terminology-and-history">Terminology and history</h2>

<p>Another notation found in the literature is 

<math display="inline" id="Catamorphism:2">
 <semantics>
  <mrow>
   <mo rspace="0.8pt" stretchy="false">(</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>f</mi>
    <mo rspace="0.8pt" stretchy="false">|</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\!|f|\!)
  </annotation>
 </semantics>
</math>

. The open brackets used are known as <strong>banana brackets</strong>, after which catamorphisms are sometimes referred to as <em>bananas</em>, as mentioned in . One of the first publications to introduce the notion of a catamorphism in the context of programming was the paper “Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire”, by <a href="Erik_Meijer_(computer_scientist)" title="wikilink">Erik Meijer</a> <em>et al.</em><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>, which was in the context of the <a class="uri" href="Squiggol" title="wikilink">Squiggol</a> formalism. The general categorical definition was given by <a href="Grant_Malcolm" title="wikilink">Grant Malcolm</a>. <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="examples">Examples</h2>

<p>We give a series of examples, and then a more global approach to catamorphisms, in the <a href="Haskell_(programming_language)" title="wikilink">Haskell</a> programming language.</p>
<h3 id="iteration">Iteration</h3>

<p>Iteration-step prescriptions lead to natural numbers as initial object.</p>

<p>Consider the functor <code>f</code> mapping a data type <code>b</code> to a data type <code>f b</code>, which contains a copy of each term from <code>b</code> as well as one additional term <code>Nothing</code> (<code>f</code> can be the <code>Maybe</code> functor in Haskell). Let an instance of a <em>StepAlgebra</em> be a function from <code>f b -&gt; b</code>, which maps <code>Nothing</code> to a fixed term <code>nil</code> of <code>b</code>, and where the actions on the copied terms will be called <code>next</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">StepAlgebra</span> b <span class="fu">=</span> (b, b<span class="ot">-&gt;</span>b) <span class="co">-- the algebras, which we encode as pairs (nil, next)</span>

<span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Zero</span> <span class="fu">|</span> <span class="dt">Succ</span> <span class="dt">Nat</span> <span class="co">-- which is the initial algebra for the functor described above</span>

<span class="ot">foldSteps ::</span> <span class="dt">StepAlgebra</span> b <span class="ot">-&gt;</span> (<span class="dt">Nat</span> <span class="ot">-&gt;</span> b) <span class="co">-- the catamorphisms map from Nat to b</span>
foldSteps (nil, next) <span class="dt">Zero</span>       <span class="fu">=</span> nil
foldSteps (nil, next) (<span class="dt">Succ</span> nat) <span class="fu">=</span> next <span class="fu">$</span> foldSteps (nil, next) nat</code></pre></div>

<p>As a silly example, consider the algebra on strings encoded as <code>("go!", \s -&gt; "wait.. " ++ s)</code>, for which <code>Nothing</code> is mapped to <code>"go!"</code> and otherwise <code>"wait.. "</code> is prepended. As <code>(Succ . Succ . Succ . Succ $ Zero)</code> denotes the number four in <code>Nat</code>, the following will evaluate to "wait.. wait.. wait.. wait.. go!": <code>foldSteps ("go!", \s -&gt; "wait.. " ++ s) (Succ . Succ . Succ . Succ $ Zero)</code>. We can easily change the code to a more useful operation, say repeated operation of an algebraic operation on numbers, just by changing the F-algebra <code>(nil, next)</code>, which is passed to <code>foldSteps</code></p>
<h3 id="list-fold">List fold</h3>

<p>For a fixed type <code>a</code>, consider the functor mapping types <code>b</code> to the product type of the two. We moreover also add a term <code>Nil</code> to this type. Here an f-algebra will map <code>Nil</code> to some special term <code>nil</code> of <code>b</code> or "merge" a pair coming from the product type into a term of <code>b</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">ContainerAlgebra</span> a b <span class="fu">=</span> (b, a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="co">-- f-algebra encoded as (nil, merge)</span>

<span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a) <span class="co">-- which turns out to be the initial algbera</span>

<span class="ot">foldrList ::</span> <span class="dt">ContainerAlgebra</span> a b <span class="ot">-&gt;</span> (<span class="dt">List</span> a <span class="ot">-&gt;</span> b) <span class="co">-- catamorphisms map from (List a) to b</span>
foldrList (nil, merge) <span class="dt">Nil</span>         <span class="fu">=</span> nil
foldrList (nil, merge) (<span class="dt">Cons</span> x xs) <span class="fu">=</span> merge x <span class="fu">$</span> foldrList (nil, merge) xs</code></pre></div>

<p>As an example, consider the algebra on numbers types encoded as <code>(3, \x-&gt; \y-&gt; x*y)</code>, for which the number from <code>a</code> acts on the number from <code>b</code> by plain multiplication. Then the following will evaluate to 3.000.000: <code>foldrList (3, \x-&gt; \y-&gt; x*y) (Cons 10 $ Cons 100 $ Cons 1000 Nil)</code></p>
<h3 id="tree-fold">Tree fold</h3>

<p>For a fixed type <code>a</code>, consider the functor mapping types <code>b</code> to the product type of <code>b</code> with itself, as well as a copy of each term of <code>a</code>. An algebra consists of a function to <code>b</code>, which either acts on <code>a</code> the copy terms, or on two <code>b</code> terms.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TreeAlgebra</span> a b <span class="fu">=</span> (a <span class="ot">-&gt;</span> b, b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="co">-- the "two cases" function is encoded as (f, g)</span>
 
<span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Branch</span> (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a) <span class="co">-- which turns out to be the initial algebra</span>
 
<span class="ot">foldTree ::</span> <span class="dt">TreeAlgebra</span> a b <span class="ot">-&gt;</span> (<span class="dt">Tree</span> a <span class="ot">-&gt;</span> b) <span class="co">-- catamorphisms map from (Tree a) to b</span>
foldTree (f, g) (<span class="dt">Leaf</span> x)            <span class="fu">=</span> f x
foldTree (f, g) (<span class="dt">Branch</span> left right) <span class="fu">=</span> g (foldTree (f, g) left) (foldTree (f, g) right)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">treeDepth ::</span> <span class="dt">TreeAlgebra</span> a <span class="dt">Integer</span> <span class="co">-- an f-algebra to numbers, which works for any input type</span>
treeDepth <span class="fu">=</span> (const <span class="dv">1</span>, \i j <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="fu">+</span> max i j)
 
<span class="ot">treeSum ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">TreeAlgebra</span> a a <span class="co">-- an f-algebra, which works  for any number type </span>
treeSum <span class="fu">=</span> (id, (<span class="fu">+</span>))</code></pre></div>
<h3 id="general-case">General case</h3>

<p>Deeper category theoretical studies of initial algebras reveal that the F-algebra obtained from applying the functor to its own initial algebra is isomorphic to it.</p>

<p>Strong type systems enable us to abstractly specify the initial algebra of a functor <code>f</code> as its fixed point <em>a = f a</em>. The recursively defined catamorphisms can now be coded in single line, where the case analysis (like in the different examples above) is encapsulated by the fmap. Since the domain of the latter are objects in the image of <code>f</code>, the evaluation of the catamorphisms jumps back and forth between <code>a</code> and <code>f a</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Algebra</span> f a <span class="fu">=</span> f a <span class="ot">-&gt;</span> a <span class="co">-- the generic f-algebras</span>

<span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="fu">=</span> <span class="dt">Iso</span> {<span class="ot"> invIso ::</span> f (<span class="dt">Fix</span> f) } <span class="co">-- gives us the initial algebra for the functor f</span>

<span class="ot">cata ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f a <span class="ot">-&gt;</span> (<span class="dt">Fix</span> f <span class="ot">-&gt;</span> a) <span class="co">-- catamorphism from Fix f to a</span>
cata alg <span class="fu">=</span> alg <span class="fu">.</span> fmap (cata alg) <span class="fu">.</span> invIso <span class="co">-- note that invIso and alg map in opposite directions</span></code></pre></div>

<p>Now again the first example, but now via passing the Maybe functor to Fix. Repeated application of the Maybe functor generates a chain of types, which, however, can be united by the isomorphism from the fixed point theorem. We introduce the term <code>zero</code>, which arises from Maybes's <code>Nothing</code> and identify a successor function with repeated application of the <code>Just</code>. This way the natural numbers arise.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Fix</span> <span class="dt">Maybe</span>
<span class="ot">zero ::</span> <span class="dt">Nat</span>
zero <span class="fu">=</span> <span class="dt">Iso</span> <span class="dt">Nothing</span> <span class="co">-- every 'Maybe a' has a term Nothing, and Iso maps it into a</span>
<span class="ot">successor ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span>
successor <span class="fu">=</span> <span class="dt">Iso</span> <span class="fu">.</span> <span class="dt">Just</span> <span class="co">-- Just maps a to 'Maybe a' and Iso maps back to a new term</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pleaseWait ::</span> <span class="dt">Algebra</span> <span class="dt">Maybe</span> <span class="dt">String</span> <span class="co">-- again the silly f-algebra example from above</span>
pleaseWait (<span class="dt">Just</span> string) <span class="fu">=</span> <span class="st">"wait.. "</span> <span class="fu">++</span> string
pleaseWait <span class="dt">Nothing</span> <span class="fu">=</span> <span class="st">"go!"</span></code></pre></div>

<p>Again, the following will evaluate to "wait.. wait.. wait.. wait.. go!": <code>cata pleaseWait (successor.successor.successor.successor $ zero)</code></p>

<p>And now again the tree example. For this we must provide the tree container data type so that we can set up the <code>fmap</code> (we didn't have to do it for the <code>Maybe</code> functor, as it's part of the standard prelude).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tcon</span> a b <span class="fu">=</span> <span class="dt">TconL</span> a <span class="fu">|</span> <span class="dt">TconR</span> b b
<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Tcon</span> a) <span class="kw">where</span>
    fmap f (<span class="dt">TconL</span> x)   <span class="fu">=</span> <span class="dt">TconL</span> x
    fmap f (<span class="dt">TconR</span> y z) <span class="fu">=</span> <span class="dt">TconR</span> (f y) (f z)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Fix</span> (<span class="dt">Tcon</span> a) <span class="co">-- the initial algebra</span>
<span class="ot">end ::</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a
end <span class="fu">=</span> <span class="dt">Iso</span> <span class="fu">.</span> <span class="dt">TconL</span>
<span class="ot">meet ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a
meet l r <span class="fu">=</span> <span class="dt">Iso</span> <span class="fu">$</span> <span class="dt">TconR</span> l r</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">treeDepth ::</span> <span class="dt">Algebra</span> (<span class="dt">Tcon</span> a) <span class="dt">Integer</span> <span class="co">-- again, the treeDepth f-algebra example</span>
treeDepth (<span class="dt">TconL</span> x)   <span class="fu">=</span> <span class="dv">1</span>
treeDepth (<span class="dt">TconR</span> y z) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> max y z</code></pre></div>

<p>The following will evaluate to 4: <code>cata treeDepth $ meet (end "X") (meet (meet (end "YXX") (end "YXY")) (end "YY"))</code></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Morphism" title="wikilink">Morphism</a></li>
<li><a class="uri" href="Anamorphism" title="wikilink">Anamorphism</a></li>
<li><a href="Hylomorphism_(computer_science)" title="wikilink">Hylomorphism</a></li>
<li><a class="uri" href="Paramorphism" title="wikilink">Paramorphism</a></li>
<li><a class="uri" href="Apomorphism" title="wikilink">Apomorphism</a></li>
</ul>
<h2 id="references">References</h2>
<h3 id="further-reading">Further reading</h3>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.haskell.org/haskellwiki/Catamorphisms">Catamorphisms</a> at HaskellWiki</li>
<li><a href="http://www.fpcomplete.com/user/edwardk/recursion-schemes/catamorphisms">Catamorphisms</a> by Edward Kmett</li>
<li>Catamorphisms in <a href="F_Sharp_(programming_language)" title="wikilink">F#</a> (Part <a href="http://lorgonblog.wordpress.com/2008/04/05/catamorphisms-part-one/">1</a>, <a href="http://lorgonblog.wordpress.com/2008/04/06/catamorphisms-part-two/">2</a>, <a href="http://lorgonblog.wordpress.com/2008/04/09/catamorphisms-part-three/">3</a>, <a href="http://lorgonblog.wordpress.com/2008/05/24/catamorphisms-part-four/">4</a>, <a href="http://lorgonblog.wordpress.com/2008/05/31/catamorphisms-part-five/">5</a>, <a href="http://lorgonblog.wordpress.com/2008/06/02/catamorphisms-part-six/">6</a>, <a href="http://lorgonblog.wordpress.com/2008/06/07/catamorphisms-part-seven/">7</a>) by Brian McNamara</li>
<li><a href="http://ulissesaraujo.wordpress.com/2007/12/19/catamorphisms-in-haskell/">Catamorphisms in Haskell</a></li>
</ul>

<p>"</p>

<p><a href="Category:Category_theory" title="wikilink">Category:Category theory</a> <a href="Category:Recursion_schemes" title="wikilink">Category:Recursion schemes</a> <a href="Category:Functional_programming" title="wikilink">Category:Functional programming</a> <a class="uri" href="Category:Morphisms" title="wikilink">Category:Morphisms</a> <a href="Category:Iteration_in_programming" title="wikilink">Category:Iteration in programming</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>

