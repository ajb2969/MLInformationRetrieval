<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="904">Succinct data structure</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Succinct data structure</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, a <strong>succinct data structure</strong> is a <a href="data_structure" title="wikilink">data structure</a> which uses an amount of space that is "close" to the <a class="uri" href="information-theoretic" title="wikilink">information-theoretic</a> lower bound, but (unlike other compressed representations) still allows for efficient query operations. The concept was originally introduced by Jacobson<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> to encode <a href="bit_vector" title="wikilink">bit vectors</a>, (unlabeled) <a href="tree_(data_structure)" title="wikilink">trees</a>, and <a href="planar_graph" title="wikilink">planar graphs</a>. Unlike general <a href="lossless_data_compression" title="wikilink">lossless data compression</a> algorithms, succinct data structures retain the ability to use them in-place, without decompressing them first. A related notion is that of a <a href="compressed_data_structure" title="wikilink">compressed data structure</a>, in which the size of the data structure depends upon the particular data being represented.</p>

<p>Suppose that 

<math display="inline" id="Succinct_data_structure:0">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 is the information-theoretical optimal number of bits needed to store some data. A representation of this data is called:</p>
<ul>
<li><em><a href="implicit_data_structure" title="wikilink">implicit</a></em> if it takes 

<math display="inline" id="Succinct_data_structure:1">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>+</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>Z</ci>
    <apply>
     <times></times>
     <ci>O</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z+O(1)
  </annotation>
 </semantics>
</math>

 bits of space,</li>
<li><em>succinct</em> if it takes 

<math display="inline" id="Succinct_data_structure:2">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>+</mo>
   <mrow>
    <mi>o</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>Z</ci>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z+o(Z)
  </annotation>
 </semantics>
</math>

 bits of space, and</li>
<li><em>compact</em> if it takes 

<math display="inline" id="Succinct_data_structure:3">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>Z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(Z)
  </annotation>
 </semantics>
</math>

 bits of space.</li>
</ul>

<p>For example, a data structure that uses 

<math display="inline" id="Succinct_data_structure:4">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>Z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>Z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2Z
  </annotation>
 </semantics>
</math>

 bits of storage is compact, 

<math display="inline" id="Succinct_data_structure:5">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>+</mo>
   <msqrt>
    <mi>Z</mi>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>Z</ci>
    <apply>
     <root></root>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z+\sqrt{Z}
  </annotation>
 </semantics>
</math>

 bits is succinct, 

<math display="inline" id="Succinct_data_structure:6">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>+</mo>
   <mrow>
    <mi>lg</mi>
    <mi>Z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>Z</ci>
    <apply>
     <ci>lg</ci>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z+\lg Z
  </annotation>
 </semantics>
</math>

 bits is also succinct, and 

<math display="inline" id="Succinct_data_structure:7">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>+</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>Z</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z+3
  </annotation>
 </semantics>
</math>

 bits is implicit.</p>

<p>Implicit structures are thus usually reduced to storing information using some permutation of the input data; the most well-known example of this is the <a href="Heap_(data_structure)" title="wikilink">heap</a>.</p>
<h2 id="succinct-dictionaries">Succinct dictionaries</h2>

<p>Succinct indexable dictionaries, also called <em>rank/select</em> dictionaries, form the basis of a number of succinct representation techniques, including <a href="binary_trees" title="wikilink">binary trees</a>, 

<math display="inline" id="Succinct_data_structure:8">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-ary trees and <a class="uri" href="multisets" title="wikilink">multisets</a>,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> as well as <a href="suffix_tree" title="wikilink">suffix trees</a> and <a href="suffix_array" title="wikilink">arrays</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The basic problem is to store a subset 

<math display="inline" id="Succinct_data_structure:9">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 of a universe 

<math display="inline" id="Succinct_data_structure:10">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mi mathvariant="normal">…</mi>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo>-</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">U</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <cn type="integer">0</cn>
     <ci>normal-,</ci>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <csymbol cd="unknown">n</csymbol>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U=[0\dots n)=\{0,1,\dots,n-1\}
  </annotation>
 </semantics>
</math>

, usually represented as a bit array 

<math display="inline" id="Succinct_data_structure:11">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mi mathvariant="normal">…</mi>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">B</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B[0\dots n)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Succinct_data_structure:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>i</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>B</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>i</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B[i]=1
  </annotation>
 </semantics>
</math>

 iff 

<math display="inline" id="Succinct_data_structure:13">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>i</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\in S
  </annotation>
 </semantics>
</math>

. An indexable dictionary supports the usual methods on dictionaries (queries, and insertions/deletions in the dynamic case) as well as the following operations:</p>
<ul>
<li>

<math display="inline" id="Succinct_data_structure:14">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐫𝐚𝐧𝐤</mi>
     <mi>q</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>k</mi>
      <mo>∈</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mn>0</mn>
        <mi mathvariant="normal">…</mi>
        <mi>x</mi>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mi>B</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>k</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mi>q</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐫𝐚𝐧𝐤</ci>
      <ci>q</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <in></in>
       <ci>k</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <cn type="integer">0</cn>
         <ci>normal-…</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <ci>B</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>k</ci>
        </apply>
       </apply>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{rank}_{q}(x)=|\{k\in[0\dots x]:B[k]=q\}|
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Succinct_data_structure:15">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐬𝐞𝐥𝐞𝐜𝐭</mi>
    <mi>q</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>min</mi>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>k</mi>
    <mo>∈</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mi mathvariant="normal">…</mi>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>:</mo>
    <msub>
     <mi>𝐫𝐚𝐧𝐤</mi>
     <mi>q</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>x</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐬𝐞𝐥𝐞𝐜𝐭</ci>
     <ci>q</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <min></min>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">k</csymbol>
     <in></in>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <cn type="integer">0</cn>
      <ci>normal-…</ci>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐫𝐚𝐧𝐤</ci>
      <ci>q</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">k</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{select}_{q}(x)=\min\{k\in[0\dots n):\mathbf{rank}_{q}(k)=x\}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>for 

<math display="inline" id="Succinct_data_structure:16">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>q</ci>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\in\{0,1\}
  </annotation>
 </semantics>
</math>

.</p>

<p>In other words, 

<math display="inline" id="Succinct_data_structure:17">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐫𝐚𝐧𝐤</mi>
    <mi>q</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐫𝐚𝐧𝐤</ci>
     <ci>q</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{rank}_{q}(x)
  </annotation>
 </semantics>
</math>

 returns the number of elements equal to 

<math display="inline" id="Succinct_data_structure:18">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 up to position 

<math display="inline" id="Succinct_data_structure:19">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 while 

<math display="inline" id="Succinct_data_structure:20">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐬𝐞𝐥𝐞𝐜𝐭</mi>
    <mi>q</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐬𝐞𝐥𝐞𝐜𝐭</ci>
     <ci>q</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{select}_{q}(x)
  </annotation>
 </semantics>
</math>

 returns the position of the 

<math display="inline" id="Succinct_data_structure:21">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

-th occurrence of 

<math display="inline" id="Succinct_data_structure:22">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

.</p>

<p>There is a simple representation<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> which uses 

<math display="inline" id="Succinct_data_structure:23">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mrow>
    <mi>o</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+o(n)
  </annotation>
 </semantics>
</math>

 bits of storage space (the original bit array and an 

<math display="inline" id="Succinct_data_structure:24">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o(n)
  </annotation>
 </semantics>
</math>

 auxiliary structure) and supports <strong>rank</strong> and <strong>select</strong> in constant time. It uses an idea similar to that for <a href="Range_Minimum_Query" title="wikilink">range-minimum queries</a>; there are a constant number of recursions before stopping at a subproblem of a limited size. The bit array 

<math display="inline" id="Succinct_data_structure:25">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is partitioned into <em>large blocks</em> of size 

<math display="inline" id="Succinct_data_structure:26">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>lg</mi>
     <mn>2</mn>
    </msup>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>l</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>lg</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l=\lg^{2}n
  </annotation>
 </semantics>
</math>

 bits and <em>small blocks</em> of size 

<math display="inline" id="Succinct_data_structure:27">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mi>lg</mi>
    <mrow>
     <mi>n</mi>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <ci>lg</ci>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=\lg n/2
  </annotation>
 </semantics>
</math>

 bits. For each large block, the rank of its first bit is stored in a separate table 

<math display="inline" id="Succinct_data_structure:28">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>l</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mi mathvariant="normal">…</mi>
    <mi>n</mi>
    <mo>/</mo>
    <mi>l</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>l</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <csymbol cd="unknown">n</csymbol>
     <divide></divide>
     <csymbol cd="unknown">l</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{l}[0\dots n/l)
  </annotation>
 </semantics>
</math>

; each such entry takes 

<math display="inline" id="Succinct_data_structure:29">
 <semantics>
  <mrow>
   <mi>lg</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>lg</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lg n
  </annotation>
 </semantics>
</math>

 bits for a total of 

<math display="inline" id="Succinct_data_structure:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>/</mo>
      <mi>l</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>lg</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>n</mi>
    <mo>/</mo>
    <mrow>
     <mi>lg</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <ci>l</ci>
     </apply>
     <apply>
      <ci>lg</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <apply>
      <ci>lg</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n/l)\lg n=n/\lg n
  </annotation>
 </semantics>
</math>

 bits of storage. Within a large block, another directory 

<math display="inline" id="Succinct_data_structure:31">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>s</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mi mathvariant="normal">…</mi>
    <mi>l</mi>
    <mo>/</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>s</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cn type="integer">0</cn>
     <ci>normal-…</ci>
     <csymbol cd="unknown">l</csymbol>
     <divide></divide>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{s}[0\dots l/s)
  </annotation>
 </semantics>
</math>

 stores the rank of each of the 

<math display="inline" id="Succinct_data_structure:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>l</mi>
    <mo>/</mo>
    <mi>s</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mrow>
     <mi>lg</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>l</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <ci>lg</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l/s=2\lg n
  </annotation>
 </semantics>
</math>

 small blocks it contains. The difference here is that it only needs 

<math display="inline" id="Succinct_data_structure:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>lg</mi>
    <mi>l</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>lg</mi>
    <mrow>
     <msup>
      <mi>lg</mi>
      <mn>2</mn>
     </msup>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mrow>
     <mi>lg</mi>
     <mrow>
      <mi>lg</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <ci>lg</ci>
      <ci>l</ci>
     </apply>
     <apply>
      <ci>lg</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>lg</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <ci>lg</ci>
       <apply>
        <ci>lg</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lg l=\lg\lg^{2}n=2\lg\lg n
  </annotation>
 </semantics>
</math>

 bits for each entry, since only the differences from the rank of the first bit in the containing large block need to be stored. Thus, this table takes a total of 

<math display="inline" id="Succinct_data_structure:34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>/</mo>
      <mi>s</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>lg</mi>
     <mi>l</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>4</mn>
    <mi>n</mi>
    <mrow>
     <mi>lg</mi>
     <mrow>
      <mi>lg</mi>
      <mrow>
       <mi>n</mi>
       <mo>/</mo>
       <mrow>
        <mi>lg</mi>
        <mi>n</mi>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <ci>lg</ci>
      <ci>l</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">4</cn>
     <ci>n</ci>
     <apply>
      <ci>lg</ci>
      <apply>
       <ci>lg</ci>
       <apply>
        <divide></divide>
        <ci>n</ci>
        <apply>
         <ci>lg</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n/s)\lg l=4n\lg\lg n/\lg n
  </annotation>
 </semantics>
</math>

 bits. A lookup table 

<math display="inline" id="Succinct_data_structure:35">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{p}
  </annotation>
 </semantics>
</math>

 can then be used that stores the answer to every possible rank query on a bit string of length 

<math display="inline" id="Succinct_data_structure:36">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Succinct_data_structure:37">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>i</ci>
    <interval closure="closed-open">
     <cn type="integer">0</cn>
     <ci>s</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\in[0,s)
  </annotation>
 </semantics>
</math>

; this requires 

<math display="inline" id="Succinct_data_structure:38">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mn>2</mn>
     <mi>s</mi>
    </msup>
    <mi>s</mi>
    <mrow>
     <mi>lg</mi>
     <mi>s</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msqrt>
       <mi>n</mi>
      </msqrt>
      <mrow>
       <mi>lg</mi>
       <mrow>
        <mi>n</mi>
        <mrow>
         <mi>lg</mi>
         <mrow>
          <mi>lg</mi>
          <mi>n</mi>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>s</ci>
     </apply>
     <ci>s</ci>
     <apply>
      <ci>lg</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <times></times>
      <apply>
       <root></root>
       <ci>n</ci>
      </apply>
      <apply>
       <ci>lg</ci>
       <apply>
        <times></times>
        <ci>n</ci>
        <apply>
         <ci>lg</ci>
         <apply>
          <ci>lg</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{s}s\lg s=O(\sqrt{n}\lg n\lg\lg n)
  </annotation>
 </semantics>
</math>

 bits of storage space. Thus, since each of these auxiliary tables take 

<math display="inline" id="Succinct_data_structure:39">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o(n)
  </annotation>
 </semantics>
</math>

 space, this data structure supports rank queries in 

<math display="inline" id="Succinct_data_structure:40">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1)
  </annotation>
 </semantics>
</math>

 time and 

<math display="inline" id="Succinct_data_structure:41">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mrow>
    <mi>o</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+o(n)
  </annotation>
 </semantics>
</math>

 bits of space.</p>

<p>To answer a query for 

<math display="inline" id="Succinct_data_structure:42">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐫𝐚𝐧𝐤</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐫𝐚𝐧𝐤</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{rank}_{1}(x)
  </annotation>
 </semantics>
</math>

 in constant time, a constant time algorithm computes:</p>
<ul>
<li>

<math display="inline" id="Succinct_data_structure:43">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐫𝐚𝐧𝐤</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>l</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mo stretchy="false">⌊</mo>
       <mrow>
        <mi>x</mi>
        <mo>/</mo>
        <mi>l</mi>
       </mrow>
       <mo stretchy="false">⌋</mo>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>s</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mo stretchy="false">⌊</mo>
       <mrow>
        <mi>x</mi>
        <mo>/</mo>
        <mi>s</mi>
       </mrow>
       <mo stretchy="false">⌋</mo>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>p</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">⌊</mo>
        <mrow>
         <mi>x</mi>
         <mo>/</mo>
         <mi>s</mi>
        </mrow>
        <mo stretchy="false">⌋</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>x</mi>
       <mtext>mod</mtext>
       <mi>s</mi>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐫𝐚𝐧𝐤</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>l</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <floor></floor>
        <apply>
         <divide></divide>
         <ci>x</ci>
         <ci>l</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>s</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <floor></floor>
        <apply>
         <divide></divide>
         <ci>x</ci>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>p</ci>
      </apply>
      <interval closure="closed">
       <apply>
        <times></times>
        <ci>x</ci>
        <apply>
         <floor></floor>
         <apply>
          <divide></divide>
          <ci>x</ci>
          <ci>s</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>x</ci>
        <mtext>mod</mtext>
        <ci>s</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{rank}_{1}(x)=R_{l}[\lfloor x/l\rfloor]+R_{s}[\lfloor x/s\rfloor]+R_{p}%
[x\lfloor x/s\rfloor,x\text{ mod }s]
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>In practice, the lookup table 

<math display="inline" id="Succinct_data_structure:44">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{p}
  </annotation>
 </semantics>
</math>

 can be replaced by bitwise operations and smaller tables to perform find the number of bits set in the small blocks. This is often beneficial, since succinct data structures find their uses in large data sets, in which case cache misses become much more frequent and the chances of the lookup table being evicted from closer CPU caches becomes higher.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Select queries can be easily supported by doing a binary search on the same auxiliary structure used for <strong>rank</strong>; however, this takes 

<math display="inline" id="Succinct_data_structure:45">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>lg</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <ci>lg</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\lg n)
  </annotation>
 </semantics>
</math>

 time in the worst case. A more complicated structure using 

<math display="inline" id="Succinct_data_structure:46">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mn>3</mn>
      <mi>n</mi>
     </mrow>
     <mo>/</mo>
     <mrow>
      <mi>lg</mi>
      <mrow>
       <mi>lg</mi>
       <mi>n</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msqrt>
        <mi>n</mi>
       </msqrt>
       <mrow>
        <mi>lg</mi>
        <mrow>
         <mi>n</mi>
         <mrow>
          <mi>lg</mi>
          <mrow>
           <mi>lg</mi>
           <mi>n</mi>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>o</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <ci>n</ci>
      </apply>
      <apply>
       <ci>lg</ci>
       <apply>
        <ci>lg</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <times></times>
       <apply>
        <root></root>
        <ci>n</ci>
       </apply>
       <apply>
        <ci>lg</ci>
        <apply>
         <times></times>
         <ci>n</ci>
         <apply>
          <ci>lg</ci>
          <apply>
           <ci>lg</ci>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3n/\lg\lg n+O(\sqrt{n}\lg n\lg\lg n)=o(n)
  </annotation>
 </semantics>
</math>

 bits of additional storage can be used to support <strong>select</strong> in constant time.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> In practice, many of these solutions have hidden constants in the 

<math display="inline" id="Succinct_data_structure:47">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>⋅</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>normal-⋅</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\cdot)
  </annotation>
 </semantics>
</math>

 notation which dominate before any asymptotic advantage becomes apparent; implementations using broadword operations and word-aligned blocks often perform better in practice.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="entropy-compressed-dictionaries">Entropy-compressed dictionaries</h3>

<p>The 

<math display="inline" id="Succinct_data_structure:48">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mrow>
    <mi>o</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+o(n)
  </annotation>
 </semantics>
</math>

 space approach can be improved by noting that there are 

<math display="inline" id="Succinct_data_structure:49">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mstyle scriptlevel="+1">
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mi>n</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mi>m</mi>
      </mtd>
     </mtr>
    </mtable>
   </mstyle>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">binomial</csymbol>
    <ci>n</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle{\left({{n}\atop{m}}\right)}
  </annotation>
 </semantics>
</math>

 distinct 

<math display="inline" id="Succinct_data_structure:50">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

-subsets of 

<math display="inline" id="Succinct_data_structure:51">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>n</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[)</csymbol>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [n)
  </annotation>
 </semantics>
</math>

 (or binary strings of length 

<math display="inline" id="Succinct_data_structure:52">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 with exactly 

<math display="inline" id="Succinct_data_structure:53">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 1’s), and thus 

<math display="inline" id="Succinct_data_structure:54">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℬ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⌈</mo>
    <mrow>
     <mi>lg</mi>
     <mrow>
      <mo>(</mo>
      <mstyle scriptlevel="+1">
       <mtable columnspacing="0.4em" rowspacing="0.2ex">
        <mtr>
         <mtd>
          <mi>n</mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd>
          <mi>m</mi>
         </mtd>
        </mtr>
       </mtable>
      </mstyle>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">⌉</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ℬ</ci>
     <interval closure="open">
      <ci>m</ci>
      <ci>n</ci>
     </interval>
    </apply>
    <apply>
     <ceiling></ceiling>
     <apply>
      <ci>lg</ci>
      <apply>
       <csymbol cd="latexml">binomial</csymbol>
       <ci>n</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\mathcal{B}(m,n)=\lceil\lg{\left({{n}\atop{m}}\right)}\rceil
  </annotation>
 </semantics>
</math>

 is an information theoretic lower bound on the number of bits needed to store 

<math display="inline" id="Succinct_data_structure:55">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

. There is a succinct (static) dictionary which attains this bound, namely using 

<math display="inline" id="Succinct_data_structure:56">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℬ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>o</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi class="ltx_font_mathcaligraphic">ℬ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>m</mi>
       <mo>,</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>ℬ</ci>
     <interval closure="open">
      <ci>m</ci>
      <ci>n</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>o</ci>
     <apply>
      <times></times>
      <ci>ℬ</ci>
      <interval closure="open">
       <ci>m</ci>
       <ci>n</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}(m,n)+o(\mathcal{B}(m,n))
  </annotation>
 </semantics>
</math>

 space.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> This structure can be extended to support <strong>rank</strong> and <strong>select</strong> queries and takes 

<math display="inline" id="Succinct_data_structure:57">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℬ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>m</mi>
      <mo>+</mo>
      <mrow>
       <mi>n</mi>
       <mrow>
        <mi>lg</mi>
        <mrow>
         <mi>lg</mi>
         <mrow>
          <mi>n</mi>
          <mo>/</mo>
          <mrow>
           <mi>lg</mi>
           <mi>n</mi>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>ℬ</ci>
     <interval closure="open">
      <ci>m</ci>
      <ci>n</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <plus></plus>
      <ci>m</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <ci>lg</ci>
        <apply>
         <ci>lg</ci>
         <apply>
          <divide></divide>
          <ci>n</ci>
          <apply>
           <ci>lg</ci>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}(m,n)+O(m+n\lg\lg n/\lg n)
  </annotation>
 </semantics>
</math>

 space.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> This bound can be reduced to a space/time tradeoff by reducing the storage space of the dictionary to 

<math display="inline" id="Succinct_data_structure:58">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℬ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>n</mi>
        <msup>
         <mi>t</mi>
         <mi>t</mi>
        </msup>
       </mrow>
       <mo>/</mo>
       <mrow>
        <msup>
         <mi>lg</mi>
         <mi>t</mi>
        </msup>
        <mi>n</mi>
       </mrow>
      </mrow>
      <mo>+</mo>
      <msup>
       <mi>n</mi>
       <mrow>
        <mn>3</mn>
        <mo>/</mo>
        <mn>4</mn>
       </mrow>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>ℬ</ci>
     <interval closure="open">
      <ci>m</ci>
      <ci>n</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <plus></plus>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>n</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>t</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>lg</ci>
         <ci>t</ci>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <apply>
        <divide></divide>
        <cn type="integer">3</cn>
        <cn type="integer">4</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{B}(m,n)+O(nt^{t}/\lg^{t}n+n^{3/4})
  </annotation>
 </semantics>
</math>

 with queries taking 

<math display="inline" id="Succinct_data_structure:59">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(t)
  </annotation>
 </semantics>
</math>

 time.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="examples">Examples</h2>

<p>A <a href="null-terminated_string" title="wikilink">null-terminated string</a> (<a href="C_string" title="wikilink">C string</a>) takes <em>Z</em> + 1 space, and is thus implicit. A string with an arbitrary length (<a href="Pascal_string" title="wikilink">Pascal string</a>) takes <em>Z</em> + log(<em>Z</em>) space, and is thus succinct. If there is a maximum length – which is the case in practice, since 2<sup>32</sup> = 4 GiB of data is a very long string, and 2<sup>64</sup> = 16 EiB of data is larger than any string in practice – then a string with a length is also implicit, taking <em>Z</em> + <em>k</em> space, where <em>k</em> is the number of data to represent the maximum length (e.g., bytes in a word).</p>

<p>When a sequence of variable-length items (such as strings) needs to be encoded, there are various possibilities. A direct approach is to store a length and an item in each record – these can then be placed one after another. This allows efficient next, but not finding the <em>k</em>th item. An alternative is to place the items in order with a delimiter (e.g., <a href="null-terminated_string" title="wikilink">null-terminated string</a>). This use a delimiter instead of a length, and is substantially slower, since the entire sequence must be scanned for delimiters. Both of these are space-efficient. An alternative approach is out-of-band separation: the items can simply be placed one after another, with no delimiters. Item bounds can then be stored as a sequence of length, or better, offsets into this sequence. Alternatively, a separate binary string consisting of 1s in the positions where an item begins, and 0s everywhere else is encoded along with it. Given this string, the 

<math display="inline" id="Succinct_data_structure:60">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi>e</mi>
   <mi>l</mi>
   <mi>e</mi>
   <mi>c</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>e</ci>
    <ci>l</ci>
    <ci>e</ci>
    <ci>c</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   select
  </annotation>
 </semantics>
</math>

 function can quickly determine where each item begins, given its index.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> This is <em>compact</em> but not <em>succinct,</em> as it takes 2<em>Z</em> space, which is O(<em>Z</em>).</p>

<p>Another example is the representation of a <a href="binary_tree" title="wikilink">binary tree</a>: an arbitrary binary tree on 

<math display="inline" id="Succinct_data_structure:61">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 nodes can be represented in 

<math display="inline" id="Succinct_data_structure:62">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>n</mi>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>o</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2n+o(n)
  </annotation>
 </semantics>
</math>

 bits while supporting a variety of operations on any node, which includes finding its parent, its left and right child, and returning the size of its subtree, each in constant time. The number of different binary trees on 

<math display="inline" id="Succinct_data_structure:63">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 nodes is 

<math display="inline" id="Succinct_data_structure:64">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mstyle scriptlevel="+1">
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mrow>
        <mn>2</mn>
        <mi>n</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mi>n</mi>
      </mtd>
     </mtr>
    </mtable>
   </mstyle>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">binomial</csymbol>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{\textstyle\left({{2n}\atop{n}}\right)}}
  </annotation>
 </semantics>
</math>



<math display="inline" id="Succinct_data_structure:65">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>/</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   /(n+1)
  </annotation>
 </semantics>
</math>

. For large 

<math display="inline" id="Succinct_data_structure:66">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, this is about 

<math display="inline" id="Succinct_data_structure:67">
 <semantics>
  <msup>
   <mn>4</mn>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">4</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4^{n}
  </annotation>
 </semantics>
</math>

; thus we need at least about 

<math display="inline" id="Succinct_data_structure:68">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mn>4</mn>
      <mi>n</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">4</cn>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log_{2}(4^{n})=2n
  </annotation>
 </semantics>
</math>

 bits to encode it. A succinct binary tree therefore would occupy only 

<math display="inline" id="Succinct_data_structure:69">
 <semantics>
  <mn>2</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">2</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2
  </annotation>
 </semantics>
</math>

 bits per node.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Minimal_perfect_hash_function" title="wikilink">Minimal perfect hash function</a></li>
</ul>
<h2 id="references">References</h2>
<references>

<p><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> <a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> <a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> <a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> <a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> <a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> <a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
</references>

<p>"</p>

<p><a href="Category:Data_structures" title="wikilink">Category:Data structures</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
</ol>
</section>
</body>
</html>
