<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="25">Standard array</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Standard array</h1>
<hr/>

<p>In <a href="coding_theory" title="wikilink">coding theory</a>, a <strong>standard array</strong> (or Slepian array) is a 

<math display="inline" id="Standard_array:0">
 <semantics>
  <msup>
   <mi>q</mi>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mi>k</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>q</ci>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q^{n-k}
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Standard_array:1">
 <semantics>
  <msup>
   <mi>q</mi>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>q</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q^{k}
  </annotation>
 </semantics>
</math>

 array that lists all elements of a particular 

<math display="inline" id="Standard_array:2">
 <semantics>
  <msubsup>
   <mi>ùîΩ</mi>
   <mi>q</mi>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ùîΩ</ci>
     <ci>q</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{F}_{q}^{n}
  </annotation>
 </semantics>
</math>

 <a href="vector_space" title="wikilink">vector space</a>. Standard arrays are used to <a href="Decoding_methods" title="wikilink">decode</a> <a href="linear_code" title="wikilink">linear codes</a>; i.e. to find the corresponding <a class="uri" href="codeword" title="wikilink">codeword</a> for any received vector.</p>
<h2 id="definition">Definition</h2>

<p>A standard array for an [<em>n</em>,<em>k</em>]-code is a 

<math display="inline" id="Standard_array:3">
 <semantics>
  <msup>
   <mi>q</mi>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mi>k</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>q</ci>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q^{n-k}
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Standard_array:4">
 <semantics>
  <msup>
   <mi>q</mi>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>q</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q^{k}
  </annotation>
 </semantics>
</math>

 array where:</p>
<ol>
<li>The first row lists all <a class="uri" href="codewords" title="wikilink">codewords</a> (with the <u>0</u> codeword on the extreme left)</li>
<li>Each row is a <a class="uri" href="coset" title="wikilink">coset</a> with the <a href="coset_leader" title="wikilink">coset leader</a> in the first column</li>
<li>The entry in the i-th row and j-th column is the sum of the i-th coset leader and the j-th codeword.</li>
</ol>

<p>For example, the [<em>n</em>,<em>k</em>]-code 

<math display="inline" id="Standard_array:5">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{3}
  </annotation>
 </semantics>
</math>

 = {<u>0</u>, 01101, 10110, 11011} has a standard array as follows:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><u><a href="Zero_vector" title="wikilink">0</a></u></p></td>
<td style="text-align: left;">
<p>01101</p></td>
<td style="text-align: left;">
<p>10110</p></td>
<td style="text-align: left;">
<p>11011</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>10000</p></td>
<td style="text-align: left;">
<p>11101</p></td>
<td style="text-align: left;">
<p>00110</p></td>
<td style="text-align: left;">
<p>01011</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>01000</p></td>
<td style="text-align: left;">
<p>00101</p></td>
<td style="text-align: left;">
<p>11110</p></td>
<td style="text-align: left;">
<p>10011</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>00100</p></td>
<td style="text-align: left;">
<p>01001</p></td>
<td style="text-align: left;">
<p>10010</p></td>
<td style="text-align: left;">
<p>11111</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>00010</p></td>
<td style="text-align: left;">
<p>01111</p></td>
<td style="text-align: left;">
<p>10100</p></td>
<td style="text-align: left;">
<p>11001</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>00001</p></td>
<td style="text-align: left;">
<p>01100</p></td>
<td style="text-align: left;">
<p>10111</p></td>
<td style="text-align: left;">
<p>11010</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>11000</p></td>
<td style="text-align: left;">
<p>10101</p></td>
<td style="text-align: left;">
<p>01110</p></td>
<td style="text-align: left;">
<p>00011</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>10001</p></td>
<td style="text-align: left;">
<p>11100</p></td>
<td style="text-align: left;">
<p>00111</p></td>
<td style="text-align: left;">
<p>01010</p></td>
</tr>
</tbody>
</table>

<p>Note that the above is only one possibility for the standard array; had 00011 been chosen as the first <a href="coset_leader" title="wikilink">coset leader</a> of weight two, another standard array representing the code would have been constructed.</p>

<p>Note that the first row contains the <u>0</u> vector and the codewords of 

<math display="inline" id="Standard_array:6">
 <semantics>
  <msub>
   <mi>C</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{3}
  </annotation>
 </semantics>
</math>

 (<u>0</u> itself being a codeword). Also, the leftmost column contains the vectors of <a href="Hamming_weight" title="wikilink">minimum weight</a> enumerating vectors of weight 1 first and then using vectors of weight 2. Note also that each possible vector in the vector space appears exactly once.</p>
<h2 id="constructing-a-standard-array">Constructing a standard array</h2>

<p>Because each possible vector can appear only once in a standard array some care must be taken during construction. A standard array can be created as follows:</p>
<ol>
<li>List the codewords of 

<math display="inline" id="Standard_array:7">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

, starting with <u>0</u>, as the first row</li>
<li>Choose any vector of minimum weight not already in the array. Write this as the first entry of the next row. This vector is denoted the <strong>'coset leader</strong>'.</li>
<li>Fill out the row by adding the coset leader to the codeword at the top of each column. The sum of the i-th coset leader and the j-th codeword becomes the entry in row i, column j.</li>
<li>Repeat steps 2 and 3 until all rows/cosets are listed and each vector appears exactly once.</li>
</ol>

<p>Note that adding vectors is done mod q. For example, binary codes are added mod 2 (which equivalent to bit-wise XOR addition). For example, in 

<math display="inline" id="Standard_array:8">
 <semantics>
  <msub>
   <mi>Z</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Z</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{2}
  </annotation>
 </semantics>
</math>

, 11000 + 11011 = 00011.</p>

<p>Note also that selecting different coset leaders will create a slightly different but equivalent standard array, and will not affect results when decoding.</p>
<h3 id="construction-example">Construction example</h3>

<p>Let 

<math display="inline" id="Standard_array:9">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 be the <a href="Binary_code" title="wikilink">binary</a> [4,2]-code. i.e. C = {0000, 1011, 0101, 1110}. To construct the standard array, we first list the codewords in a row.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0000</p></td>
<td style="text-align: left;">
<p>1011</p></td>
<td style="text-align: left;">
<p>0101</p></td>
<td style="text-align: left;">
<p>1110</p></td>
</tr>
</tbody>
</table>

<p>We then select a vector of minimum weight (in this case, weight 1) that has not been used. This vector becomes the coset leader for the second row.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0000</p></td>
<td style="text-align: left;">
<p>1011</p></td>
<td style="text-align: left;">
<p>0101</p></td>
<td style="text-align: left;">
<p>1110</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1000</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>

<p>Following step 3, we complete the row by adding the coset leader to each codeword.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0000</p></td>
<td style="text-align: left;">
<p>1011</p></td>
<td style="text-align: left;">
<p>0101</p></td>
<td style="text-align: left;">
<p>1110</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1000</p></td>
<td style="text-align: left;">
<p>0011</p></td>
<td style="text-align: left;">
<p>1101</p></td>
<td style="text-align: left;">
<p>0110</p></td>
</tr>
</tbody>
</table>

<p>We then repeat steps 2 and 3 until we have completed all rows. We stop when we have reached 

<math display="inline" id="Standard_array:10">
 <semantics>
  <mrow>
   <msup>
    <mi>q</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mi>k</mi>
    </mrow>
   </msup>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mn>4</mn>
     <mo>-</mo>
     <mn>2</mn>
    </mrow>
   </msup>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>q</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <cn type="integer">4</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q^{n-k}=2^{4-2}=2^{2}=4
  </annotation>
 </semantics>
</math>

 rows.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0000</p></td>
<td style="text-align: left;">
<p>1011</p></td>
<td style="text-align: left;">
<p>0101</p></td>
<td style="text-align: left;">
<p>1110</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1000</p></td>
<td style="text-align: left;">
<p>0011</p></td>
<td style="text-align: left;">
<p>1101</p></td>
<td style="text-align: left;">
<p>0110</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0100</p></td>
<td style="text-align: left;">
<p>1111</p></td>
<td style="text-align: left;">
<p>0001</p></td>
<td style="text-align: left;">
<p>1010</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0010</p></td>
<td style="text-align: left;">
<p>1001</p></td>
<td style="text-align: left;">
<p>0111</p></td>
<td style="text-align: left;">
<p>1100</p></td>
</tr>
</tbody>
</table>

<p>Note that in this example we could not have chosen the vector 0001 as the coset leader of the final row, even though it meets the critedia of having minimal weight (1), because the vector was already present in the array. We could, however, have chosen it as the first coset leader and constructed a different standard array.</p>
<h2 id="decoding-via-standard-array">Decoding via standard array</h2>

<p>To decode a vector using a standard array, subtract the error vector - or coset leader - from the vector received. The result will be one of the codewords in 

<math display="inline" id="Standard_array:11">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

. For example, say we are using the code C = {0000, 1011, 0101, 1110}, and have constructed the corresponding standard array, as shown from the example above. If we receive the vector 0110 as a message, we find that vector in the standard array. We then subtract the vector's coset leader, namely 1000, to get the result 1110. We have received the codeword 1110.</p>

<p>Decoding via a standard array is a form of <a href="nearest_neighbour_decoding" title="wikilink">nearest neighbour decoding</a>. In practise, decoding via a standard array requires large amounts of storage - a code with 32 codewords requires a standard array with 

<math display="inline" id="Standard_array:12">
 <semantics>
  <msup>
   <mn>2</mn>
   <mn>32</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <cn type="integer">32</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{32}
  </annotation>
 </semantics>
</math>

 entries. Other forms of decoding, such as <a href="syndrome_decoding" title="wikilink">syndrome decoding</a>, are more efficient.</p>

<p>Note that decoding via standard array does not guarantee that all vectors are decoded correctly. If we receive the vector 1010, using the standard array above would decode the message as 1110, a codeword distance 1 away. However, 1010 is also distance 1 away from the codeword 1011. In such a case some implementations might ask for the message to be resent. This ambiguity is another reason that different decoding methods are sometimes used.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Linear_code" title="wikilink">Linear code</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Coding_theory" title="wikilink">Category:Coding theory</a></p>
</body>
</html>
