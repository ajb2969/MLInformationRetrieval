<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="147">Asymptotically optimal algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Asymptotically optimal algorithm</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, an <a class="uri" href="algorithm" title="wikilink">algorithm</a> is said to be <strong>asymptotically optimal</strong> if, roughly speaking, for large inputs it performs at worst a constant factor (independent of the input size) worse than the best possible algorithm. It is a term commonly encountered in computer science research as a result of widespread use of <a href="big-O_notation" title="wikilink">big-O notation</a>.</p>

<p>More formally, an algorithm is asymptotically optimal with respect to a particular resource if the problem has been proven to require Ω(f(n)) of that resource, and the algorithm has been proven to use only O(f(n)).</p>

<p>These proofs require an assumption of a particular <a href="model_of_computation" title="wikilink">model of computation</a>, i.e., certain restrictions on operations allowable with the input data.</p>

<p>As a simple example, it's known that all <a href="comparison_sort" title="wikilink">comparison sorts</a> require at least Ω(<em>n</em> log <em>n</em>) comparisons in the average and worst cases. <a class="uri" href="Mergesort" title="wikilink">Mergesort</a> and <a class="uri" href="heapsort" title="wikilink">heapsort</a> are comparison sorts which perform O(<em>n</em> log <em>n</em>) comparisons, so they are asymptotically optimal in this sense.</p>

<p>If the input data have some <em><a href="a_priori_and_a_posteriori" title="wikilink">a priori</a></em> properties which can be exploited in construction of algorithms, in addition to comparisons, then asymptotically faster algorithms may be possible. For example, if it is known that the N objects are <a href="integer" title="wikilink">integers</a> from the range [1, N], then they may be sorted O(N) time, e.g., by the <a href="bucket_sort" title="wikilink">bucket sort</a>.</p>

<p>A consequence of an algorithm being asymptotically optimal is that, for large enough inputs, no algorithm can outperform it by more than a constant factor. For this reason, asymptotically optimal algorithms are often seen as the "end of the line" in research, the attaining of a result that cannot be dramatically improved upon. Conversely, if an algorithm is not asymptotically optimal, this implies that as the input grows in size, the algorithm performs increasingly worse than the best possible algorithm.</p>

<p>In practice it's useful to find algorithms that perform better, even if they do not enjoy any asymptotic advantage. New algorithms may also present advantages such as better performance on specific inputs, decreased use of resources, or being simpler to describe and implement. Thus asymptotically optimal algorithms are not always the "end of the line".</p>

<p>Although asymptotically optimal algorithms are important theoretical results, an asymptotically optimal algorithm might not be used in a number of practical situations:</p>
<ul>
<li>It only outperforms more commonly used methods for <em>n</em> beyond the range of practical input sizes, such as inputs with more bits than could fit in any computer storage system.</li>
<li>It is too complex, so that the difficulty of comprehending and implementing it correctly outweighs its potential benefit in the range of input sizes under consideration.</li>
<li>The inputs encountered in practice fall into special cases that have more efficient algorithms or that heuristic algorithms with bad worst-case times can nevertheless solve efficiently.</li>
<li>On modern computers, hardware optimizations such as memory cache and parallel processing may be "broken" by an asymptotically optimal algorithm (assuming the analysis did not take these hardware optimizations into account). In this case, there could be sub-optimal algorithms that make better use of these features and outperform an optimal algorithm on realistic data.</li>
</ul>

<p>An example of an asymptotically optimal algorithm not used in practice is <a href="Bernard_Chazelle" title="wikilink">Bernard Chazelle</a>'s linear-time algorithm for <a class="uri" href="triangulation" title="wikilink">triangulation</a> of a <a href="simple_polygon" title="wikilink">simple polygon</a>. Another is the <a href="resizable_array" title="wikilink">resizable array</a> data structure published in "Resizable Arrays in Optimal Time and Space",<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> which can index in constant time but on many machines carries a heavy practical penalty compared to ordinary array indexing.</p>
<h2 id="formal-definitions">Formal definitions</h2>

<p>Formally, suppose that we have a lower-bound theorem showing that a problem requires Ω(f(<em>n</em>)) time to solve for an instance (input) of size <em>n</em> (see <a href="big-O_notation#Other_standard_computer_science_notation:_Ω,_ω,_Θ,_O,_o,_Õ,_∼" title="wikilink">big-O notation</a> for the definition of Ω). Then, an algorithm which solves the problem in O(f(<em>n</em>)) time is said to be asymptotically optimal. This can also be expressed using limits: suppose that b(<em>n</em>) is a lower bound on the running time, and a given algorithm takes time t(<em>n</em>). Then the algorithm is asymptotically optimal if:</p>

<p>

<math display="block" id="Asymptotically_optimal_algorithm:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mo movablelimits="false">lim</mo>
      <mrow>
       <mi>n</mi>
       <mo>→</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
     </munder>
     <mfrac>
      <mrow>
       <mi>t</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>b</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
    <mo><</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>n</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>t</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim_{n\rightarrow\infty}\frac{t(n)}{b(n)}<\infty.
  </annotation>
 </semantics>
</math>

</p>

<p>Note that this limit, if it exists, is always at least 1, as t(<em>n</em>) ≥ b(<em>n</em>).</p>

<p>Although usually applied to time efficiency, an algorithm can be said to use asymptotically optimal space, random bits, number of processors, or any other resource commonly measured using big-O notation.</p>

<p>Sometimes vague or implicit assumptions can make it unclear whether an algorithm is asymptotically optimal. For example, a lower bound theorem might assume a particular <a href="abstract_machine" title="wikilink">abstract machine</a> model, as in the case of comparison sorts, or a particular organization of memory. By violating these assumptions, a new algorithm could potentially asymptotically outperform the lower bound and the "asymptotically optimal" algorithms.</p>
<h2 id="speedup">Speedup</h2>

<p>The nonexistence of an asymptotically optimal algorithm is called speedup. <a href="Blum's_speedup_theorem" title="wikilink">Blum's speedup theorem</a> shows that there exist artificially constructed problems with speedup. However, it is an <a href="open_problem" title="wikilink">open problem</a> whether many of the most well-known algorithms today are asymptotically optimal or not. For example, there is an O(<em>n</em>α(<em>n</em>)) algorithm for finding <a href="minimum_spanning_tree" title="wikilink">minimum spanning trees</a>, where α(<em>n</em>) is the very slowly growing inverse of the <a href="Ackermann_function" title="wikilink">Ackermann function</a>, but the best known lower bound is the trivial Ω(<em>n</em>). Whether this algorithm is asymptotically optimal is unknown, and would be likely to be hailed as a significant result if it were resolved either way. Coppersmith and Winograd (1982) proved that matrix multiplication has a weak form of speed-up among a restricted class of algorithms (Strassen-type bilinear identities with lambda-computation).</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Element_uniqueness_problem" title="wikilink">Element uniqueness problem</a></li>
<li><a href="Asymptotic_computational_complexity" title="wikilink">Asymptotic computational complexity</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Analysis_of_algorithms" title="wikilink">Category:Analysis of algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
