<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1632">Advantage (cryptography)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Advantage (cryptography)</h1>
<hr/>

<p>In <a class="uri" href="cryptography" title="wikilink">cryptography</a>, an adversary's <strong>advantage</strong> is a measure of how successfully it can attack a cryptographic <a class="uri" href="algorithm" title="wikilink">algorithm</a>, by distinguishing it from an idealized version of that type of algorithm. Note that in this context, the "<a href="Adversary_(cryptography)" title="wikilink">adversary</a>" is itself an algorithm and not a <a class="uri" href="person" title="wikilink">person</a>. A cryptographic algorithm is considered secure if no adversary has a non-negligible advantage, subject to specified bounds on the adversary's computational resources (see <a href="concrete_security" title="wikilink">concrete security</a>). "Negligible" usually means "within <a href="Big_O_notation" title="wikilink">O</a>(2<sup>−p</sup>)" where p is a <a href="security_parameter" title="wikilink">security parameter</a> associated with the algorithm. For example, p might be the number of bits in a block cipher's <a href="key_(cryptography)" title="wikilink">key</a>.</p>
<h2 id="description-of-concept">Description of concept</h2>

<p>Let F be an <a href="oracle_machine" title="wikilink">oracle</a> for the function being studied, and let G be an oracle for an idealized function of that type. The adversary A is a probabilistic algorithm given F or G as input and which outputs 1 or 0. A's job is to distinguish F from G based on making queries to the oracle that it's given. We say: 

<math display="inline" id="Advantage_(cryptography):0">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>d</mi>
    <mi>v</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>Pr</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mrow>
         <mi>A</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>F</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>Pr</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mrow>
         <mi>A</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>G</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>d</ci>
     <ci>v</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <ci>Pr</ci>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>F</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <ci>Pr</ci>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>G</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Adv(A)=|\Pr[A(F)=1]-\Pr[A(G)=1]|
  </annotation>
 </semantics>
</math>

</p>
<h2 id="examples">Examples</h2>

<p>Let F be a random instance of the <a href="Data_Encryption_Standard" title="wikilink">DES</a> <a href="block_cipher" title="wikilink">block cipher</a>. This cipher has 64-bit blocks and a 56-bit key. The key therefore selects one of a family of 2<sup>56</sup> <a href="permutation" title="wikilink">permutations</a> on the 2<sup>64</sup> possible 64-bit blocks. A "random DES instance" means our oracle F computes DES using some key K (which is unknown to the adversary) where K is selected from the 2<sup>56</sup> possible keys with equal probability.</p>

<p>We want to compare the DES instance with an <a href="Platonic_ideal" title="wikilink">idealized</a> 64-bit block cipher, meaning a permutation selected at random from the (2<sup>64</sup>)<a href="factorial" title="wikilink">!</a> possible permutations on 64-bit blocks. Call this randomly selected permutation G. Note from <a href="Stirling's_approximation" title="wikilink">Stirling's approximation</a> that (2<sup>64</sup>)! is around 

<math display="inline" id="Advantage_(cryptography):1">
 <semantics>
  <msup>
   <mn>10</mn>
   <mrow>
    <mn>3.47</mn>
    <mo>×</mo>
    <msup>
     <mn>10</mn>
     <mn>20</mn>
    </msup>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">10</cn>
    <apply>
     <times></times>
     <cn type="float">3.47</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">10</cn>
      <cn type="integer">20</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   10^{3.47\times 10^{20}}
  </annotation>
 </semantics>
</math>

, so even specifying which permutation is selected requires writing down a number too large to represent exactly in any real computer. Viewed another way, G is an instance of a "cipher" whose "key length" is about 10<sup>21</sup> bits, which again is too large to fit in a computer. (We can, however, implement G with storage space proportional to the number of queries, using a <a href="random_oracle" title="wikilink">random oracle</a>).</p>

<p>Note that because the oracles we're given encrypt plaintext of our choosing, we're modelling a <a href="chosen-plaintext_attack" title="wikilink">chosen-plaintext attack</a> or <strong>CPA</strong>, and the advantage we're calculating can be called the CPA-advantage of a given adversary. If we also had decryption oracles available, we'd be doing a <a href="chosen-ciphertext_attack" title="wikilink">chosen-ciphertext attack</a> or <strong>CCA</strong> and finding the CCA-advantage of the adversary.</p>
<h3 id="example-1-guess-at-random">Example 1: Guess at random</h3>

<p>Call this adversary A<sub>0</sub>. It simply flips a coin and returns 1 or 0 with equal probability and without making any oracle calls. Thus, Pr[A<sub>0</sub>(F)=1] and Pr[A<sub>0</sub>(G)=1] are both 0.5. The difference between these probabilities is zero, so Adv(A<sub>0</sub>) is zero. The same thing applies if we always return 0, or always return 1: the probability is the same for both F and G, so the advantage is zero. This adversary can't tell F and G apart. If we're cipher designers, our desire (maybe not achievable) is to make it so that it's <a href="Computational_complexity_theory#Intractability" title="wikilink">computationally infeasible</a> for <em>any</em> adversary to do significantly better than this. We will have succeeded if we can make a cipher for which there's no distinguisher faster than brute force search.</p>
<h3 id="example-2-brute-force-search">Example 2: Brute force search</h3>

<p>This adversary (call it A<sub>1</sub>) will attempt to cryptanalyze its input by <a href="brute_force_attack" title="wikilink">brute force</a>. It has its own DES implementation. It gives a single query to its oracle, asking for the 64-bit string of all zeroes to be encrypted. Call the resulting ciphertext E<sub>0</sub>. It then runs an exhaustive key search. The algorithm looks like this:</p>

<p><code> E</code><sub><code>0</code></sub><code> = oracle_query(0)</code><br/>
<code> for k in 0,1,...,2</code><sup><code>56</code></sup><code>-1:</code><br/>
<code>   if DES</code><sub><code>k</code></sub><code>(0) == E</code><sub><code>0</code></sub><code>: </code><br/>
<code>      return 1</code><br/>
<code> return 0</code></p>

<p>This searches the entire 56-bit DES keyspace and returns "1" if it probably finds a matching key. In practice, several plaintexts are required to confirm the key, as two different keys can result in one or more matching plaintext-ciphertext pairs. If no key is found, it returns 0.</p>

<p>If the input oracle is DES, this exhaustive search is certain to find the key, so Pr[A<sub>1</sub>(F)=1] = 1. If the input oracle is a random permutation, there are 2<sup>64</sup> possible values of E<sub>0</sub>, and at most 2<sup>56</sup> of them will get examined in the DES keysearch. So the probability of A<sub>1</sub> returning 1 is at most 2<sup>−8</sup>. That is:</p>

<p>Pr[A<sub>1</sub>(G)=1] −8, so</p>

<p>Adv(A<sub>1</sub>) = |Pr[A<sub>1</sub>(F)=1] - Pr[A<sub>1</sub>(G)=1]| &gt;= 1 - 2<sup>−8</sup></p>

<p>so the advantage is at least about 0.996. This is a near-certain distinguisher, but it's not a security failure because it's no faster than brute force search, after all, it <em>is</em> the brute force search.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Pseudorandom-function_advantage" title="wikilink">Pseudorandom-function advantage</a></li>
<li><a href="Key-recovery_advantage" title="wikilink">Key-recovery advantage</a></li>
<li><a href="PR-CPA_advantage" title="wikilink">PR-CPA advantage</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><a href="Phillip_Rogaway" title="wikilink">Phillip Rogaway</a> and <a href="Mihir_Bellare" title="wikilink">Mihir Bellare</a>, <a href="http://www-cse.ucsd.edu/~mihir/cse207/classnotes.html">Introduction to Modern Cryptography</a></li>
<li>Oded Goldreich, <a href="http://theory.lcs.mit.edu/~oded/frag.html">Foundations of Cryptography (Fragments of a Book)</a></li>
</ul>

<p>"</p>

<p><a href="Category:Theory_of_cryptography" title="wikilink">Category:Theory of cryptography</a></p>
</body>
</html>
