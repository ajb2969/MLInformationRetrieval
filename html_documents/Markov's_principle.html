<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1716">Markov's principle</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Markov's principle</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>An artistic representation of a <a href="Turing_machine" title="wikilink">Turing machine</a>. Markov's principle says that if it is impossible that a Turing machine will not halt, then it must halt.</figcaption>
</figure>

<p><strong>Markov's principle</strong>, named after <a href="Andrey_Markov_(Soviet_mathematician)" title="wikilink">Andrey Markov Jr</a>, is a specific statement in <a href="computability_theory" title="wikilink">computability theory</a> that is obvious true classically (i.e. it is a <a href="tautology_(logic)" title="wikilink">tautology</a>), but must be proved when using <a href="constructivism_(mathematics)" title="wikilink">constructive</a> mathematics. There are many equivalent formulations of Markov's principle.</p>
<h2 id="statements-of-the-principle">Statements of the principle</h2>

<p>In the language of <a href="computability_theory" title="wikilink">computability theory</a>, Markov's principle is a formal expression of the claim that if it is impossible that an algorithm does not terminate, then it does terminate. This is equivalent to the claim that if a set and its complement are both <a href="computably_enumerable" title="wikilink">computably enumerable</a>, then the set is <a href="recursive_set" title="wikilink">decidable</a>.</p>

<p>In <a href="predicate_logic" title="wikilink">predicate logic</a>, if <em>P</em> is a predicate over the <a href="natural_number" title="wikilink">natural numbers</a>, it is expressed as:</p>

<p>

<math display="block" id="Markov's_principle:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo>∀</mo>
       <mrow>
        <mi>n</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <mi>P</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo>∨</mo>
          <mrow>
           <mi mathvariant="normal">¬</mi>
           <mi>P</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>∧</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi mathvariant="normal">¬</mi>
        <mrow>
         <mo>∀</mo>
         <mrow>
          <mi>n</mi>
          <mi mathvariant="normal">¬</mi>
          <mi>P</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>n</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <mpadded width="+2.8pt">
        <mi>n</mi>
       </mpadded>
       <mi>P</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <or></or>
        <apply>
         <times></times>
         <ci>P</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <not></not>
         <ci>P</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <not></not>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <times></times>
        <ci>n</ci>
        <not></not>
        <ci>P</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>P</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall n(P(n)\vee\neg P(n))\wedge(\neg\forall n\neg P(n)))\rightarrow(%
\exists n\;P(n)).
  </annotation>
 </semantics>
</math>

</p>

<p>That is, if <em>P</em> is decidable, and it cannot be false for every natural number <em>n</em>, then it is true for some <em>n</em>. (In general, a predicate <em>P</em> over some domain is called <em>decidable</em> if for every <em>x</em> in the domain, either <em>P</em>(<em>x</em>) is true, or <em>P</em>(<em>x</em>) is not true, which is not always the case constructively.)</p>

<p>It is equivalent in the language of <a href="Heyting_arithmetic" title="wikilink">arithmetic</a> to:</p>

<p>

<math display="block" id="Markov's_principle:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi mathvariant="normal">¬</mi>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <mpadded width="+2.8pt">
        <mi>n</mi>
       </mpadded>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
    <mo>→</mo>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <mpadded width="+2.8pt">
       <mi>n</mi>
      </mpadded>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <not></not>
      <not></not>
      <apply>
       <exists></exists>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>f</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>f</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\neg\exists n\;f(n)=0\rightarrow\exists n\;f(n)=0,
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Markov's_principle:2">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 a <a href="computable_function" title="wikilink">total recursive function</a> on the natural numbers.</p>

<p>It is equivalent, in the language of <a href="real_analysis" title="wikilink">real analysis</a>, to the following principles:</p>
<ul>
<li>For each real number <em>x</em>, if it is contradictory that <em>x</em> is equal to 0, then there exists <em>y</em> ∈ <a href="rational_number" title="wikilink">Q</a> such that 0 &lt; <em>y</em> &lt; |<em>x</em>|, often expressed by saying that <em>x</em> is <a href="apartness_relation" title="wikilink">apart</a> from, or constructively unequal to, 0.</li>
<li>For each real number <em>x</em>, if it is contradictory that <em>x</em> is equal to 0, then there exists <em>y</em> ∈ R such that <em>xy</em> = 1.</li>
</ul>
<h2 id="realizability">Realizability</h2>

<p>If constructive arithmetic is translated into a classical meta-theory using <a class="uri" href="realizability" title="wikilink">realizability</a>, then Markov's principle is justified: a realizer is the <a href="unbounded_search" title="wikilink">unbounded search</a> that successively checks if 

<math display="inline" id="Markov's_principle:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>P</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>P</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(0),P(1),P(2),\dots
  </annotation>
 </semantics>
</math>


 is true. Because 

<math display="inline" id="Markov's_principle:4">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is not everywhere false, the search cannot go on forever. Using classical logic one concludes that the search therefore stops, namely at a value at which 

<math display="inline" id="Markov's_principle:5">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 holds.</p>

<p>If instead the realizability interpretation is used in a constructive meta-theory, then it is not justified. Indeed, for first-order arithmetic, Markov's principle exactly captures the difference between a constructive and classical meta-theory. Specifically, a statement is provable in <a href="Heyting_arithmetic" title="wikilink">Heyting arithmetic</a> with <a href="Church's_thesis_(constructive_mathematics)" title="wikilink">Extended Church's thesis</a> if and only if there is a number that provably realizes it in <a href="Heyting_arithmetic" title="wikilink">Heyting arithmetic</a>; and it is provable in <a href="Heyting_arithmetic" title="wikilink">Heyting arithmetic</a> with <a href="Church's_thesis_(constructive_mathematics)" title="wikilink">Extended Church's thesis</a> <em>and Markov's principle</em> if and only if there is a number that provably realizes it in <a href="Peano_arithmetic" title="wikilink">Peano arithmetic</a>.</p>

<p>Modified <a class="uri" href="realizability" title="wikilink">realizability</a> does not justify Markov's principle, even if classical logic is used in the meta-theory: there is no realizer in the language of <a href="simply_typed_lambda_calculus" title="wikilink">simply typed lambda calculus</a> as this language is not <a class="uri" href="Turing-complete" title="wikilink">Turing-complete</a> and arbitrary loops cannot be defined in it.</p>
<h2 id="markovs-rule">Markov's rule</h2>

<p><strong>Markov's rule</strong> is the formulation of Markov's principle as a rule. It states that 

<math display="inline" id="Markov's_principle:6">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mrow>
    <mpadded width="+2.8pt">
     <mi>n</mi>
    </mpadded>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>P</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists n\;P(n)
  </annotation>
 </semantics>
</math>

 is derivable as soon as 

<math display="inline" id="Markov's_principle:7">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mpadded width="+2.8pt">
      <mi>n</mi>
     </mpadded>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <not></not>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>P</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\neg\exists n\;P(n)
  </annotation>
 </semantics>
</math>

 is, for 

<math display="inline" id="Markov's_principle:8">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>


 decidable. It was proved by Anne S. Troelstra<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> that Markov's rule is an <a href="admissible_rule" title="wikilink">admissible rule</a> in <a href="Heyting_arithmetic" title="wikilink">Heyting arithmetic</a>. Later on, the logician <a href="Harvey_Friedman" title="wikilink">Harvey Friedman</a> showed that Markov's rule is an admissible rule in all of <a href="intuitionistic_logic" title="wikilink">intuitionistic logic</a>, <a href="Heyting_arithmetic" title="wikilink">Heyting arithmetic</a>, and various other intuitionistic theories,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> using the <a href="Friedman_translation" title="wikilink">Friedman translation</a>.</p>
<h2 id="weak-markovs-principle">Weak Markov's principle</h2>

<p>A weaker form of Markov's principle may be stated in the language of analysis as</p>

<p><span class="LaTeX">$$\forall x\in\mathbb{R}\ (\forall y\in\mathbb{R}\ \neg\neg(0<y) 0<x.<="" \neg\neg(y<x))="" \to="" \vee="" math="">

This form can be justified by [[L. E. J. Brouwer|Brouwer's]] [[Brouwer's continuity principles|continuity principles]], whereas the stronger form contradicts them. Thus it can be derived from intuitionistic, realizability, and classical reasoning, in each case for different reasons, but this principle is not valid in the general constructive sense of Bishop.<ref>[[Ulrich Kohlenbach]], "[http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.24.7455 On weak Markov's principle]". ''Mathematical Logic Quarterly'' (2002), vol 48, issue S1, pp. 59–65.</ref>

== See also ==
* [[Church's thesis (constructive mathematics)]]

== References ==

{{reflist}}

== External links ==
* [http://plato.stanford.edu/entries/mathematics-constructive Constructive Mathematics (Stanford Encyclopedia of Philosophy)]

{{DEFAULTSORT:Markov's Principle}}
[[Category:Logic]]
[[Category:Constructivism (mathematics)]]
[[Category:Mathematical principles]]"</y)>$$</span></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Anne S. Troelstra. Metamathematical Investigation of Intuitionistic Arithmetic and Analysis, Springer Verlag (1973), Theorem 4.2.4 of the 2nd edition.<a href="#fnref1">↩</a></li>
<li id="fn2">Harvey Friedman. Classically and Intuitionistically Provably Recursive Functions. In Scott, D. S. and Muller, G. H. Editors, Higher Set Theory, Volume 699 of Lecture Notes in Mathematics, Springer Verlag (1978), pp. 21–28.<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
