<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="46">String kernel</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>String kernel</h1>
<hr/>

<p>In <a href="machine_learning" title="wikilink">machine learning</a> and <a href="data_mining" title="wikilink">data mining</a>, a <strong>string kernel</strong> is a <a href="Positive-definite_kernel" title="wikilink">kernel function</a> that operates on <a href="String_(computer_science)" title="wikilink">strings</a>, i.e. finite sequences of symbols that need not be of the same length. String kernels can be intuitively understood as functions measuring the similarity of pairs of strings: the more similar two strings <em>a</em> and <em>b</em> are, the higher the value of a string kernel <em>K</em>(<em>a</em>, <em>b</em>) will be.</p>

<p>Using string kernels with <a href="Kernel_trick" title="wikilink">kernelized</a> learning algorithms such as <a href="support_vector_machine" title="wikilink">support vector machines</a> allow such algorithms to work with strings, without having to translate these to fixed-length, real-valued <a href="feature_vector" title="wikilink">feature vectors</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> String kernels are used in domains where sequence data are to be <a href="Cluster_analysis" title="wikilink">clustered</a> or <a href="statistical_classification" title="wikilink">classified</a>, e.g. in <a href="text_mining" title="wikilink">text mining</a> and <a href="bioinformatics" title="wikilink">gene analysis</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="informal-introduction">Informal introduction</h2>

<p>Suppose one wants to compare some text passages automatically and indicate their relative similarity. For many applications, it might be sufficient to find some keywords which match exactly. One example where exact matching is not always enough is found in <a href="Spam_(electronic)" title="wikilink">spam</a> detection.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Another would be in computational gene analysis, where <a href="Homology_(biology)" title="wikilink">homologous</a> <a class="uri" href="genes" title="wikilink">genes</a> have <a class="uri" href="mutated" title="wikilink">mutated</a>, resulting in common subsequences along with deleted, inserted or replaced symbols.</p>
<h2 id="motivation">Motivation</h2>

<p>Since several well-proven data clustering, classification and information retrieval</p>

<p>methods (for example support vector machines) are designed to work on vectors (i.e. data are elements of a vector space), using a string kernel allows the extension of these methods to handle sequence data.</p>

<p>The string kernel method is to be contrasted with earlier approaches for text classification where feature vectors only indicated the presence or absence of a word. Not only does it improve on these approaches, but it is an example for a whole class of kernels adapted to data structures, which began to appear at the turn of the 21st century. A survey of such methods has been compiled by G√§rtner.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="definition">Definition</h2>

<p>A <a href="Kernel_trick" title="wikilink">kernel</a> on a domain 

<math display="inline" id="String_kernel:0">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 is a function 

<math display="inline" id="String_kernel:1">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>D</mi>
     <mo>√ó</mo>
     <mi>D</mi>
    </mrow>
    <mo>‚Üí</mo>
    <mi>‚Ñù</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>K</ci>
    <apply>
     <ci>normal-‚Üí</ci>
     <apply>
      <times></times>
      <ci>D</ci>
      <ci>D</ci>
     </apply>
     <ci>‚Ñù</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K:D\times D\rightarrow\mathbb{R}
  </annotation>
 </semantics>
</math>

 satisfying some conditions (being <a class="uri" href="symmetric" title="wikilink">symmetric</a> in the arguments, <a href="continuous_function" title="wikilink">continuous</a> and <a href="Positive-semidefinite_function" title="wikilink">positive semidefinite</a> in a certain sense).</p>

<p><a href="Mercer's_theorem" title="wikilink">Mercer's theorem</a> asserts that 

<math display="inline" id="String_kernel:2">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 can then be expressed as 

<math display="inline" id="String_kernel:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>œÜ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>‚ãÖ</mo>
     <mi>œÜ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-‚ãÖ</ci>
      <apply>
       <times></times>
       <ci>œÜ</ci>
       <ci>x</ci>
      </apply>
      <ci>œÜ</ci>
     </apply>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(x,y)=\varphi(x)\cdot\varphi(y)
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="String_kernel:4">
 <semantics>
  <mi>œÜ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>œÜ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 mapping the arguments into an <a href="inner_product_space" title="wikilink">inner product space</a>.</p>

<p>We can now reproduce the definition of a <strong>string subsequence kernel</strong><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> on strings over an <a href="Alphabet_(computer_science)" title="wikilink">alphabet</a> 

<math display="inline" id="String_kernel:5">
 <semantics>
  <mi mathvariant="normal">Œ£</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Œ£</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

. Coordinate-wise, the mapping is defined as follows:</p>

<p>

<math display="block" id="String_kernel:6">
 <semantics>
  <mrow>
   <msub>
    <mi>œÜ</mi>
    <mi>u</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <msup>
         <mi mathvariant="normal">Œ£</mi>
         <mi>n</mi>
        </msup>
        <mo>‚Üí</mo>
        <msup>
         <mi>‚Ñù</mi>
         <msup>
          <mi mathvariant="normal">Œ£</mi>
          <mi>n</mi>
         </msup>
        </msup>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>s</mi>
        <mo>‚Ü¶</mo>
        <mrow>
         <munder>
          <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
          <mrow>
           <mi>ùê¢</mi>
           <mo>:</mo>
           <mrow>
            <mi>u</mi>
            <mo>=</mo>
            <msub>
             <mi>s</mi>
             <mi>ùê¢</mi>
            </msub>
           </mrow>
          </mrow>
         </munder>
         <msup>
          <mi>Œª</mi>
          <mrow>
           <mi>l</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>ùê¢</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </msup>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mi></mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>œÜ</ci>
     <ci>u</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <matrix>
      <matrixrow>
       <apply>
        <ci>normal-‚Üí</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-Œ£</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>‚Ñù</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>normal-Œ£</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="latexml">maps-to</csymbol>
        <ci>s</ci>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <ci>normal-:</ci>
           <ci>ùê¢</ci>
           <apply>
            <eq></eq>
            <ci>u</ci>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>s</ci>
             <ci>ùê¢</ci>
            </apply>
           </apply>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>Œª</ci>
          <apply>
           <times></times>
           <ci>l</ci>
           <ci>ùê¢</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi_{u}:\left\{\begin{array}[]{l}\Sigma^{n}\rightarrow\mathbb{R}^{\Sigma^{%
n}}\\
s\mapsto\sum_{\mathbf{i}:u=s_{\mathbf{i}}}\lambda^{l(\mathbf{i})}\end{array}\right.
  </annotation>
 </semantics>
</math>

</p>

<p>The 

<math display="inline" id="String_kernel:7">
 <semantics>
  <mi>ùê¢</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùê¢</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{i}
  </annotation>
 </semantics>
</math>

 are <a class="uri" href="multiindices" title="wikilink">multiindices</a> and 

<math display="inline" id="String_kernel:8">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 is a string of length 

<math display="inline" id="String_kernel:9">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

: subsequences can occur in a non-contiguous manner, but gaps are penalized. The parameter 

<math display="inline" id="String_kernel:10">
 <semantics>
  <mi>Œª</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œª</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 may be set to any value between 

<math display="inline" id="String_kernel:11">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 (gaps are not allowed) and 

<math display="inline" id="String_kernel:12">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 (even widely-spread "occurrences" are weighted the same as appearances as a contiguous substring).</p>

<p>For several relevant algorithms, data enters into the algorithm only in expressions involving an inner product of feature vectors, hence the name <a href="kernel_methods" title="wikilink">kernel methods</a>. A desirable consequence of this is that one does not need to explicitly calculate the transformation 

<math display="inline" id="String_kernel:13">
 <semantics>
  <mrow>
   <mi>œï</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>œï</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(x)
  </annotation>
 </semantics>
</math>

, only the inner product via the kernel, which may be a lot quicker, especially when <a href="approximation" title="wikilink">approximated</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Algorithms_on_strings" title="wikilink">Category:Algorithms on strings</a> <a href="Category:Kernel_methods_for_machine_learning" title="wikilink">Category:Kernel methods for machine learning</a> <a href="Category:Natural_language_processing" title="wikilink">Category:Natural language processing</a> <a href="Category:String_similarity_measures" title="wikilink">Category:String similarity measures</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"><a href="#fnref2">‚Ü©</a></li>
<li id="fn3"><a href="#fnref3">‚Ü©</a></li>
<li id="fn4"><a href="#fnref4">‚Ü©</a></li>
<li id="fn5"><a href="#fnref5">‚Ü©</a></li>
<li id="fn6"></li>
</ol>
</section>
</body>
</html>
