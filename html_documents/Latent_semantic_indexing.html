<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1888">Latent semantic indexing</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Latent semantic indexing</h1>
<hr/>

<p><strong>Latent semantic indexing</strong> (<strong>LSI</strong>) is an indexing and retrieval method that uses a mathematical technique called <a href="singular_value_decomposition" title="wikilink">singular value decomposition</a> (SVD) to identify patterns in the relationships between the <a href="terminology" title="wikilink">terms</a> and <a href="concept" title="wikilink">concepts</a> contained in an unstructured collection of text. LSI is based on the principle that words that are used in the same contexts tend to have similar meanings. A key feature of LSI is its ability to extract the conceptual content of a <a href="Text_corpus" title="wikilink">body of text</a> by establishing associations between those terms that occur in similar <a href="context_(language_use)" title="wikilink">contexts</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>LSI is also an application of <a href="correspondence_analysis" title="wikilink">correspondence analysis</a>, a multivariate statistical technique developed by <a href="Jean-Paul_Benzécri" title="wikilink">Jean-Paul Benzécri</a><ref>{{ cite book</ref></p>

<p><code>| author = Benzécri, J.-P.</code><br/>
<code>| publisher=Dunod |location= Paris, France</code><br/>
<code>| year = 1973</code><br/>
<code>| title = L'Analyse des Données. Volume II. L'Analyse des Correspondences</code><br/>
<code>}}</code><code> in the early 1970s, to a </code><a href="contingency_table" title="wikilink"><code>contingency</code> <code>table</code></a><code> built from word counts in documents.</code></p>

<p>Called Latent Semantic Indexing because of its ability to correlate semantically related terms that are latent in a collection of text, it was first applied to text at <a class="uri" href="Bellcore" title="wikilink">Bellcore</a> in the late 1980s. The method, also called <a href="latent_semantic_analysis" title="wikilink">latent semantic analysis</a> (LSA), uncovers the underlying latent semantic structure in the usage of words in a body of text and how it can be used to extract the meaning of the text in response to user queries, commonly referred to as concept searches. Queries, or concept searches, against a set of documents that have undergone LSI will return results that are conceptually similar in meaning to the search criteria even if the results don’t share a specific word or words with the search criteria.</p>

<p>__TOC__</p>
<h2 id="benefits-of-lsi">Benefits of LSI</h2>

<p>LSI overcomes two of the most problematic constraints of Boolean <a href="keyword_search" title="wikilink">keyword queries</a>: multiple words that have similar meanings (<a class="uri" href="synonymy" title="wikilink">synonymy</a>) and words that have more than one meaning (<a class="uri" href="polysemy" title="wikilink">polysemy</a>). Synonymy is often the cause of mismatches in the vocabulary used by the authors of documents and the users of <a href="information_retrieval" title="wikilink">information retrieval</a> systems.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> As a result, Boolean or keyword queries often return irrelevant results and miss information that is relevant.</p>

<p>LSI is also used to perform automated <a href="document_categorization" title="wikilink">document categorization</a>. In fact, several experiments have demonstrated that there are a number of correlations between the way LSI and humans process and categorize text.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Document categorization is the assignment of documents to one or more predefined categories based on their similarity to the conceptual content of the categories.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> LSI uses <em>example</em> documents to establish the conceptual basis for each category. During categorization processing, the concepts contained in the documents being categorized are compared to the concepts contained in the example items, and a category (or categories) is assigned to the documents based on the similarities between the concepts they contain and the concepts that are contained in the example documents.</p>

<p>Dynamic clustering based on the conceptual content of documents can also be accomplished using LSI. Clustering is a way to group documents based on their conceptual similarity to each other without using example documents to establish the conceptual basis for each cluster. This is very useful when dealing with an unknown collection of unstructured text.</p>

<p>Because it uses a strictly mathematical approach, LSI is inherently independent of language. This enables LSI to elicit the semantic content of information written in any language without requiring the use of auxiliary structures, such as dictionaries and thesauri. LSI can also perform cross-linguistic concept searching and example-based categorization. For example, queries can be made in one language, such as English, and conceptually similar results will be returned even if they are composed of an entirely different language or of multiple languages.</p>

<p>LSI is not restricted to working only with words. It can also process arbitrary character strings. Any object that can be expressed as text can be represented in an LSI vector space.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> For example, tests with MEDLINE abstracts have shown that LSI is able to effectively classify genes based on conceptual modeling of the biological information contained in the titles and abstracts of the MEDLINE citations.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>LSI automatically adapts to new and changing terminology, and has been shown to be very tolerant of noise (i.e., misspelled words, typographical errors, unreadable characters, etc.).<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> This is especially important for applications using text derived from Optical Character Recognition (OCR) and speech-to-text conversion. LSI also deals effectively with sparse, ambiguous, and contradictory data.</p>

<p>Text does not need to be in sentence form for LSI to be effective. It can work with lists, free-form notes, email, Web-based content, etc. As long as a collection of text contains multiple terms, LSI can be used to identify patterns in the relationships between the important terms and concepts contained in the text.</p>

<p>LSI has proven to be a useful solution to a number of conceptual matching problems.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> The technique has been shown to capture key relationship information, including causal, goal-oriented, and taxonomic information.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="lsi-timeline">LSI timeline</h2>
<ul>
<li><strong>Mid-1960s</strong> – Factor analysis technique first described and tested (H. Borko and M. Bernick)</li>
<li><strong>1988</strong> – Seminal paper on LSI technique published <a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></li>
<li><strong>1989</strong> – Original patent granted <a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></li>
<li><strong>1992</strong> – First use of LSI to assign articles to reviewers<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></li>
<li><strong>1994</strong> – Patent granted for the cross-lingual application of LSI (Landauer et al.)</li>
<li><strong>1995</strong> – First use of LSI for grading essays (Foltz, et al., Landauer et al.)</li>
<li><strong>1999</strong> – First implementation of LSI technology for intelligence community for analyzing unstructured text (<a href="Science_Applications_International_Corporation" title="wikilink">SAIC</a>).</li>
<li><strong>2002</strong> – LSI-based product offering to intelligence-based government agencies (SAIC)</li>
<li><strong>2005</strong> – First vertical-specific application – publishing – EDB (EBSCO, <a href="Content_Analyst_Company" title="wikilink">Content Analyst Company</a>)</li>
</ul>
<h2 id="mathematics-of-lsi">Mathematics of LSI</h2>

<p>LSI uses common linear algebra techniques to learn the conceptual correlations in a collection of text. In general, the process involves constructing a weighted term-document matrix, performing a <a href="Singular_value_decomposition" title="wikilink"><strong>Singular Value Decomposition</strong></a> on the matrix, and using the matrix to identify the concepts contained in the text.</p>
<h3 id="term-document-matrix">Term-document matrix</h3>

<p>LSI begins by constructing a term-document matrix, 

<math display="inline" id="Latent_semantic_indexing:0">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, to identify the occurrences of the 

<math display="inline" id="Latent_semantic_indexing:1">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 unique terms within a collection of 

<math display="inline" id="Latent_semantic_indexing:2">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 documents. In a term-document matrix, each term is represented by a row, and each document is represented by a column, with each matrix cell, 

<math display="inline" id="Latent_semantic_indexing:3">
 <semantics>
  <msub>
   <mi>a</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{ij}
  </annotation>
 </semantics>
</math>

, initially representing the number of times the associated term appears in the indicated document, 

<math display="inline" id="Latent_semantic_indexing:4">
 <semantics>
  <msub>
   <mi>tf</mi>
   <mi>ij</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>tf</ci>
    <ci>ij</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{tf_{ij}}
  </annotation>
 </semantics>
</math>

. This matrix is usually very large and very sparse.</p>

<p>Once a term-document matrix is constructed, local and global weighting functions can be applied to it to condition the data. The weighting functions transform each cell, 

<math display="inline" id="Latent_semantic_indexing:5">
 <semantics>
  <msub>
   <mi>a</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{ij}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Latent_semantic_indexing:6">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, to be the product of a local term weight, 

<math display="inline" id="Latent_semantic_indexing:7">
 <semantics>
  <msub>
   <mi>l</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>l</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l_{ij}
  </annotation>
 </semantics>
</math>

, which describes the relative frequency of a term in a document, and a global weight, 

<math display="inline" id="Latent_semantic_indexing:8">
 <semantics>
  <msub>
   <mi>g</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i}
  </annotation>
 </semantics>
</math>

, which describes the relative frequency of the term within the entire collection of documents.</p>

<p>Some common local weighting functions <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> are defined in the following table.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Binary</strong></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Latent_semantic_indexing:9">
 <semantics>
  <mrow>
   <msub>
    <mi>l</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>l</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l_{ij}=1
  </annotation>
 </semantics>
</math>

 if the term exists in the document, or else 

<math display="inline" id="Latent_semantic_indexing:10">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>TermFrequency</strong></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Latent_semantic_indexing:11">
 <semantics>
  <mrow>
   <msub>
    <mi>l</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>tf</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>l</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>tf</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l_{ij}=\mathrm{tf}_{ij}
  </annotation>
 </semantics>
</math>

, the number of occurrences of term 

<math display="inline" id="Latent_semantic_indexing:12">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 in document 

<math display="inline" id="Latent_semantic_indexing:13">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Log</strong></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Latent_semantic_indexing:14">
 <semantics>
  <mrow>
   <msub>
    <mi>l</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>tf</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>l</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <log></log>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>tf</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l_{ij}=\log(\mathrm{tf}_{ij}+1)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>Augnorm</strong></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Latent_semantic_indexing:15">
 <semantics>
  <mrow>
   <msub>
    <mi>l</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mo maxsize="160%" minsize="160%">(</mo>
      <mfrac>
       <msub>
        <mi>tf</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
       <mrow>
        <msub>
         <mi>max</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>tf</mi>
          <mrow>
           <mi>i</mi>
           <mi>j</mi>
          </mrow>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
      <mo maxsize="160%" minsize="160%">)</mo>
     </mrow>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>l</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>tf</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <max></max>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>tf</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l_{ij}=\frac{\Big(\frac{\mathrm{tf}_{ij}}{\max_{i}(\mathrm{tf}_{ij})}\Big)+1}{2}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Some common global weighting functions are defined in the following table.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Binary</strong></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Latent_semantic_indexing:16">
 <semantics>
  <mrow>
   <msub>
    <mi>g</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i}=1
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>Normal</strong></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Latent_semantic_indexing:17">
 <semantics>
  <mrow>
   <msub>
    <mi>g</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <msqrt>
     <mrow>
      <mstyle displaystyle="false">
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <mi>j</mi>
       </msub>
      </mstyle>
      <msubsup>
       <mi>tf</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
       <mn>2</mn>
      </msubsup>
     </mrow>
    </msqrt>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>tf</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i}=\frac{1}{\sqrt{\sum_{j}\mathrm{tf}_{ij}^{2}}}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>GfIdf</strong></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Latent_semantic_indexing:18">
 <semantics>
  <mrow>
   <msub>
    <mi>g</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>gf</mi>
     <mi>i</mi>
    </msub>
    <mo>/</mo>
    <msub>
     <mi>df</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>gf</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>df</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i}=\mathrm{gf}_{i}/\mathrm{df}_{i}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Latent_semantic_indexing:19">
 <semantics>
  <msub>
   <mi>gf</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>gf</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{gf}_{i}
  </annotation>
 </semantics>
</math>

 is the total number of times term 

<math display="inline" id="Latent_semantic_indexing:20">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 occurs in the whole collection, and 

<math display="inline" id="Latent_semantic_indexing:21">
 <semantics>
  <msub>
   <mi>df</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>df</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{df}_{i}
  </annotation>
 </semantics>
</math>

 is the number of documents in which term 

<math display="inline" id="Latent_semantic_indexing:22">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 occurs.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong><a href="Tf–idf#Inverse_document_frequency_2" title="wikilink">Idf (Inverse Document Frequency)</a></strong></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Latent_semantic_indexing:23">
 <semantics>
  <mrow>
   <msub>
    <mi>g</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mfrac>
     <mi>n</mi>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <msub>
       <mi>df</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>df</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i}=\log_{2}\frac{n}{1+\mathrm{df}_{i}}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Entropy</strong></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Latent_semantic_indexing:24">
 <semantics>
  <mrow>
   <msub>
    <mi>g</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>j</mi>
     </msub>
     <mfrac>
      <mrow>
       <msub>
        <mi>p</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
       <mrow>
        <mi>log</mi>
        <msub>
         <mi>p</mi>
         <mrow>
          <mi>i</mi>
          <mi>j</mi>
         </mrow>
        </msub>
       </mrow>
      </mrow>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <log></log>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <apply>
           <times></times>
           <ci>i</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <log></log>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i}=1+\sum_{j}\frac{p_{ij}\log p_{ij}}{\log n}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Latent_semantic_indexing:25">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mi>tf</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <msub>
     <mi>gf</mi>
     <mi>i</mi>
    </msub>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>tf</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>gf</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{ij}=\frac{\mathrm{tf}_{ij}}{\mathrm{gf}_{i}}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Empirical studies with LSI report that the Log Entropy weighting functions work well, in practice, with many data sets.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> In other words, each entry 

<math display="inline" id="Latent_semantic_indexing:26">
 <semantics>
  <msub>
   <mi>a</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{ij}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Latent_semantic_indexing:27">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is computed as:</p>

<p>

<math display="block" id="Latent_semantic_indexing:28">
 <semantics>
  <mrow>
   <msub>
    <mi>g</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>j</mi>
     </munder>
     <mfrac>
      <mrow>
       <msub>
        <mi>p</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
       <mrow>
        <mi>log</mi>
        <msub>
         <mi>p</mi>
         <mrow>
          <mi>i</mi>
          <mi>j</mi>
         </mrow>
        </msub>
       </mrow>
      </mrow>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>j</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <log></log>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <apply>
           <times></times>
           <ci>i</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <log></log>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{i}=1+\sum_{j}\frac{p_{ij}\log p_{ij}}{\log n}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Latent_semantic_indexing:29">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <msub>
      <mi>g</mi>
      <mi>i</mi>
     </msub>
    </mpadded>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>tf</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <log></log>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>tf</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{ij}=g_{i}\ \log(\mathrm{tf}_{ij}+1)
  </annotation>
 </semantics>
</math>

</p>
<h3 id="rank-reduced-singular-value-decomposition">Rank-reduced singular value decomposition</h3>

<p>A rank-reduced, <a href="singular_value_decomposition" title="wikilink">singular value decomposition</a> is performed on the matrix to determine patterns in the relationships between the terms and concepts contained in the text. The SVD forms the foundation for LSI.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> It computes the term and document vector spaces by approximating the single term-frequency matrix, 

<math display="inline" id="Latent_semantic_indexing:30">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, into three other matrices— an <strong><em>m</em></strong> by <strong><em>r</em></strong> term-concept vector matrix 

<math display="inline" id="Latent_semantic_indexing:31">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

, an <strong><em>r</em></strong> by <strong><em>r</em></strong> singular values matrix 

<math display="inline" id="Latent_semantic_indexing:32">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, and a <strong><em>n</em></strong> by <strong><em>r</em></strong> concept-document vector matrix, 

<math display="inline" id="Latent_semantic_indexing:33">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

, which satisfy the following relations:</p>

<p>

<math display="inline" id="Latent_semantic_indexing:34">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>≈</mo>
   <mrow>
    <mi>T</mi>
    <mi>S</mi>
    <msup>
     <mi>D</mi>
     <mi>T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>D</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\approx TSD^{T}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Latent_semantic_indexing:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>T</mi>
      <mi>T</mi>
     </msup>
     <mi>T</mi>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>I</mi>
     <mi>r</mi>
    </msub>
   </mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>D</mi>
      <mi>T</mi>
     </msup>
     <mi>D</mi>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>I</mi>
     <mi>r</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <ci>T</ci>
      </apply>
      <ci>T</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>D</ci>
       <ci>T</ci>
      </apply>
      <ci>D</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T^{T}T=I_{r}\quad D^{T}D=I_{r}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Latent_semantic_indexing:36">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>S</mi>
     <mrow>
      <mn>1</mn>
      <mo>,</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>≥</mo>
    <msub>
     <mi>S</mi>
     <mrow>
      <mn>2</mn>
      <mo>,</mo>
      <mn>2</mn>
     </mrow>
    </msub>
    <mo>≥</mo>
    <mi mathvariant="normal">…</mi>
    <mo>≥</mo>
    <msub>
     <mi>S</mi>
     <mrow>
      <mi>r</mi>
      <mo>,</mo>
      <mi>r</mi>
     </mrow>
    </msub>
    <mo>></mo>
    <mn>0</mn>
   </mrow>
   <mrow>
    <msub>
     <mi>S</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mpadded width="+2.8pt">
      <mn>0</mn>
     </mpadded>
     <mpadded width="+2.8pt">
      <mtext>where</mtext>
     </mpadded>
     <mi>i</mi>
    </mrow>
    <mo>≠</mo>
    <mi>j</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <geq></geq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <list>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <list>
        <cn type="integer">2</cn>
        <cn type="integer">2</cn>
       </list>
      </apply>
     </apply>
     <apply>
      <geq></geq>
      <share href="#.cmml">
      </share>
      <ci>normal-…</ci>
     </apply>
     <apply>
      <geq></geq>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <list>
        <ci>r</ci>
        <ci>r</ci>
       </list>
      </apply>
     </apply>
     <apply>
      <gt></gt>
      <share href="#.cmml">
      </share>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <list>
        <ci>i</ci>
        <ci>j</ci>
       </list>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">0</cn>
       <mtext>where</mtext>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <neq></neq>
      <share href="#.cmml">
      </share>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1,1}\geq S_{2,2}\geq\ldots\geq S_{r,r}>0\quad S_{i,j}=0\;\text{where}\;i\neq
j
  </annotation>
 </semantics>
</math>

</p>

<p>In the formula, <strong>A</strong> is the supplied <strong><em>m</em></strong> by <strong><em>n</em></strong> weighted matrix of term frequencies in a collection of text where <strong><em>m</em></strong> is the number of unique terms, and <strong><em>n</em></strong> is the number of documents. <strong>T</strong> is a computed <strong><em>m</em></strong> by <strong><em>r</em></strong> matrix of term vectors where <strong><em>r</em></strong> is the rank of <strong>A</strong>—a measure of its unique dimensions <strong>≤ min(<em>m,n</em>)</strong>. <strong>S</strong> is a computed <strong><em>r</em></strong> by <strong><em>r</em></strong> diagonal matrix of decreasing singular values, and <strong>D</strong> is a computed <strong><em>n</em></strong> by <strong><em>r</em></strong> matrix of document vectors.</p>

<p>The SVD is then <a href="Singular_value_decomposition#Truncated_SVD" title="wikilink">truncated</a> to reduce the rank by keeping only the largest <strong><em>k</em></strong> « <strong><em>r</em></strong> diagonal entries in the singular value matrix <strong>S</strong>, where <strong><em>k</em></strong> is typically on the order 100 to 300 dimensions. This effectively reduces the term and document vector matrix sizes to <strong><em>m</em></strong> by <strong><em>k</em></strong> and <strong><em>n</em></strong> by <strong><em>k</em></strong> respectively. The SVD operation, along with this reduction, has the effect of preserving the most important semantic information in the text while reducing noise and other undesirable artifacts of the original space of <strong>A</strong>. This reduced set of matrices is often denoted with a modified formula such as:</p>
<dl>
<dd><dl>
<dd><strong>A ≈ A<em><sub>k</sub></em> = T<em><sub>k</sub></em> S<em><sub>k</sub></em> D<em><sub>k</sub></em><sup>T</sup></strong>
</dd>
</dl>
</dd>
</dl>

<p>Efficient LSI algorithms only compute the first <strong><em>k</em></strong> singular values and term and document vectors as opposed to computing a full SVD and then truncating it.</p>

<p>Note that this rank reduction is essentially the same as doing <a href="Principal_Component_Analysis" title="wikilink">Principal Component Analysis</a> (PCA) on the matrix <strong>A</strong>, except that PCA subtracts off the means. PCA loses the sparseness of the <strong>A</strong> matrix, which can make it infeasible for large lexicons.</p>
<h2 id="querying-and-augmenting-lsi-vector-spaces">Querying and augmenting LSI vector spaces</h2>

<p>The computed <strong>T<em><sub>k</sub></em></strong> and <strong>D<em><sub>k</sub></em></strong> matrices define the term and document vector spaces, which with the computed singular values, <strong>S<em><sub>k</sub></em></strong>, embody the conceptual information derived from the document collection. The similarity of terms or documents within these spaces is a factor of how close they are to each other in these spaces, typically computed as a function of the angle between the corresponding vectors.</p>

<p>The same steps are used to locate the vectors representing the text of queries and new documents within the document space of an existing LSI index. By a simple transformation of the <strong>A = T S D<sup>T</sup></strong> equation into the equivalent <strong>D = A<sup>T</sup> T S<sup>−1</sup></strong> equation, a new vector, <strong><em>d</em></strong>, for a query or for a new document can be created by computing a new column in <strong>A</strong> and then multiplying the new column by <strong>T S<sup>−1</sup></strong>. The new column in <strong>A</strong> is computed using the originally derived global term weights and applying the same local weighting function to the terms in the query or in the new document.</p>

<p>A drawback to computing vectors in this way, when adding new searchable documents, is that terms that were not known during the SVD phase for the original index are ignored. These terms will have no impact on the global weights and learned correlations derived from the original collection of text. However, the computed vectors for the new text are still very relevant for similarity comparisons with all other document vectors.</p>

<p>The process of augmenting the document vector spaces for an LSI index with new documents in this manner is called <em>folding in</em>. Although the folding-in process does not account for the new semantic content of the new text, adding a substantial number of documents in this way will still provide good results for queries as long as the terms and concepts they contain are well represented within the LSI index to which they are being added. When the terms and concepts of a new set of documents need to be included in an LSI index, either the term-document matrix, and the SVD, must be recomputed or an incremental update method (such as the one described in <a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a>) be used.</p>
<h2 id="additional-uses-of-lsi">Additional uses of LSI</h2>

<p>It is generally acknowledged that the ability to work with text on a semantic basis is essential to modern information retrieval systems. As a result, the use of LSI has significantly expanded in recent years as earlier challenges in scalability and performance have been overcome.</p>

<p>LSI is being used in a variety of information retrieval and text processing applications, although its primary application has been for concept searching and automated document categorization.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> Below are some other ways in which LSI is being used:</p>
<ul>
<li>Information discovery<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> (eDiscovery, Government/Intelligence community, Publishing)</li>
<li>Automated document classification (eDiscovery, Government/Intelligence community, Publishing)<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></li>
<li>Text summarization<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> (eDiscovery, Publishing)</li>
<li>Relationship discovery<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> (Government, Intelligence community, Social Networking)</li>
<li>Automatic generation of link charts of individuals and organizations<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> (Government, Intelligence community)</li>
<li>Matching technical papers and grants with reviewers<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> (Government)</li>
<li>Online customer support<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> (Customer Management)</li>
<li>Determining document authorship<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> (Education)</li>
<li>Automatic keyword annotation of images<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></li>
<li>Understanding software source code<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> (Software Engineering)</li>
<li>Filtering <a href="Spam_(electronic)" title="wikilink">spam</a><a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> (System Administration)</li>
<li>Information visualization<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></li>
<li><a href="Automated_essay_scoring" title="wikilink">Essay scoring</a><a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> (Education)</li>
<li><a href="Literature-based_discovery" title="wikilink">Literature-based discovery</a><a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></li>
</ul>

<p>LSI is increasingly being used for electronic document discovery (eDiscovery) to help enterprises prepare for litigation. In eDiscovery, the ability to cluster, categorize, and search large collections of unstructured text on a conceptual basis is essential. Concept-based searching using LSI has been applied to the eDiscovery process by leading providers as early as 2003.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>
<h2 id="challenges-to-lsi">Challenges to LSI</h2>

<p>Early challenges to LSI focused on scalability and performance. LSI requires relatively high computational performance and memory in comparison to other information retrieval techniques.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> However, with the implementation of modern high-speed processors and the availability of inexpensive memory, these considerations have been largely overcome. Real-world applications involving more than 30 million documents that were fully processed through the matrix and SVD computations are not uncommon in some LSI applications. A fully scalable (unlimited number of documents, online training) implementation of LSI is contained in the open source <a class="uri" href="gensim" title="wikilink">gensim</a> software package.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p>

<p>Another challenge to LSI has been the alleged difficulty in determining the optimal number of dimensions to use for performing the SVD. As a general rule, fewer dimensions allow for broader comparisons of the concepts contained in a collection of text, while a higher number of dimensions enable more specific (or more relevant) comparisons of concepts. The actual number of dimensions that can be used is limited by the number of documents in the collection. Research has demonstrated that around 300 dimensions will usually provide the best results with moderate-sized document collections (hundreds of thousands of documents) and perhaps 400 dimensions for larger document collections (millions of documents).<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> However, recent studies indicate that 50-1000 dimensions are suitable depending on the size and nature of the document collection.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a></p>

<p>Checking the amount of variance in the data after computing the SVD can be used to determine the optimal number of dimensions to retain. The variance contained in the data can be viewed by plotting the singular values (S) in a <a href="scree_plot" title="wikilink">scree plot</a>. Some LSI practitioners select the dimensionality associated with the knee of the curve as the cut-off point for the number of dimensions to retain. Others argue that some quantity of the variance must be retained, and the amount of variance in the data should dictate the proper dimensionality to retain. Seventy percent is often mentioned as the amount of variance in the data that should be used to select the optimal dimensionality for recomputing the SVD.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a><a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a><a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Latent_semantic_analysis" title="wikilink">Latent semantic analysis</a></li>
<li><a href="Latent_Semantic_Structure_Indexing" title="wikilink">Latent Semantic Structure Indexing</a></li>
<li><a href="Principal_component_analysis" title="wikilink">Principal component analysis</a></li>
<li><a href="Correspondence_analysis" title="wikilink">Correspondence analysis</a></li>
<li><a href="Probabilistic_latent_semantic_analysis" title="wikilink">Probabilistic latent semantic analysis</a></li>
<li><a href="Latent_Dirichlet_allocation" title="wikilink">Latent Dirichlet allocation</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li>

<p><a href="http://nlp.stanford.edu/fsnlp/">Companion webpage</a></p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cs.utk.edu/~lsi/">Michael Berry’s site</a></li>
<li><a href="http://radimrehurek.com/gensim">Gensim</a> contains a scalable Python+<a class="uri" href="NumPy" title="wikilink">NumPy</a> implementation of LSI, even for datasets larger than the available RAM.</li>
<li><a href="http://scgroup.hpclab.ceid.upatras.gr/scgroup/Projects/TMG/">Text to Matrix Generator (TMG)</a> MATLAB toolbox that can be used for various tasks in text mining (TM) specifically i) indexing, ii) retrieval, iii) dimensionality reduction, iv) clustering, v) classification. Most of TMG is written in MATLAB and parts in Perl. It contains implementations of LSI, clustered LSI, NMF and other methods.</li>
<li><a href="http://www.youtube.com/watch?v=QGd06MTRMHs">Stanford University Andrew Ng Video on LSI</a></li>
</ul>

<p>"</p>

<p><a href="Category:Information_retrieval_techniques" title="wikilink">Category:Information retrieval techniques</a> <a href="Category:Semantic_Web" title="wikilink">Category:Semantic Web</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Deerwester, S., et al, Improving Information Retrieval with Latent Semantic Indexing, Proceedings of the 51st Annual Meeting of the American Society for Information Science 25, 1988, pp. 36–40.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">Landauer, T., et al., Learning Human-like Knowledge by Singular Value Decomposition: A Progress Report, M. I. Jordan, M. J. Kearns &amp; S. A. Solla (Eds.), Advances in Neural Information Processing Systems 10, Cambridge: MIT Press, 1998, pp. 45–51.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">Zukas, Anthony, Price, Robert J., Document Categorization Using Latent Semantic Indexing, White Paper, <a href="Content_Analyst_Company" title="wikilink">Content Analyst Company</a>, LLC<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8">Ding, C., A Similarity-based Probability Model for Latent Semantic Indexing, Proceedings of the 22nd International ACM SIGIR Conference on Research and Development in Information Retrieval, 1999, pp. 59–65.<a href="#fnref8">↩</a></li>
<li id="fn9">Bartell, B., Cottrell, G., and Belew, R., Latent Semantic Indexing is an Optimal Special Case of Multidimensional Scaling, Proceedings, ACM SIGIR Conference on Research and Development in Information Retrieval, 1992, pp. 161–167.<a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14">Berry, M. W., and Browne, M., Understanding Search Engines: Mathematical Modeling and Text Retrieval, Society for Industrial and Applied Mathematics, Philadelphia, (2005).<a href="#fnref14">↩</a></li>
<li id="fn15">Landauer, T., et al., Handbook of Latent Semantic Analysis, Lawrence Erlbaum Associates, 2007.<a href="#fnref15">↩</a></li>
<li id="fn16">Berry, Michael W., Dumais, Susan T., O'Brien, Gavin W., Using Linear Algebra for Intelligent Information Retrieval, December 1994, SIAM Review 37:4 (1995), pp. 573–595.<a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18">Dumais, S., Latent Semantic Analysis, ARIST Review of Information Science and Technology, vol. 38, 2004, Chapter 4.<a href="#fnref18">↩</a></li>
<li id="fn19">Best Practices Commentary on the Use of Search and Information Retrieval Methods in E-Discovery, the Sedona Conference, 2007, pp. 189–223.<a href="#fnref19">↩</a></li>
<li id="fn20">Foltz, P. W. and Dumais, S. T. Personalized Information Delivery: An analysis of information filtering methods, Communications of the ACM, 1992, 34(12), 51-60.<a href="#fnref20">↩</a></li>
<li id="fn21">Gong, Y., and Liu, X., Creating Generic Text Summaries, Proceedings, Sixth International Conference on Document Analysis and Recognition, 2001, pp. 903–907.<a href="#fnref21">↩</a></li>
<li id="fn22">Bradford, R., Efficient Discovery of New Information in Large Text Databases, Proceedings, IEEE International Conference on Intelligence and Security Informatics, Atlanta, Georgia, LNCS Vol. 3495, Springer, 2005, pp. 374–380.<a href="#fnref22">↩</a></li>
<li id="fn23">Bradford, R., Application of Latent Semantic Indexing in Generating Graphs of Terrorist Networks, in: Proceedings, IEEE International Conference on Intelligence and Security Informatics, ISI 2006, San Diego, CA, USA, May 23–24, 2006, Springer, LNCS vol. 3975, pp. 674–675.<a href="#fnref23">↩</a></li>
<li id="fn24">Yarowsky, D., and Florian, R., Taking the Load off the Conference Chairs: Towards a Digital Paper-routing Assistant, Proceedings of the 1999 Joint SIGDAT Conference on Empirical Methods in NLP and Very-Large Corpora, 1999, pp. 220–230.<a href="#fnref24">↩</a></li>
<li id="fn25">Caron, J., Applying LSA to Online Customer Support: A Trial Study, Unpublished Master's Thesis, May 2000.<a href="#fnref25">↩</a></li>
<li id="fn26">Soboroff, I., et al, Visualizing Document Authorship Using N-grams and Latent Semantic Indexing, Workshop on New Paradigms in Information Visualization and Manipulation, 1997, pp. 43–48.<a href="#fnref26">↩</a></li>
<li id="fn27">Monay, F., and Gatica-Perez, D., On Image Auto-annotation with Latent Space Models, Proceedings of the 11th ACM international conference on Multimedia, Berkeley, CA, 2003, pp. 275–278.<a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29">Gee, K., Using Latent Semantic Indexing to Filter Spam, in: Proceedings, 2003 ACM Symposium on Applied Computing, Melbourne, Florida, pp. 460–464.<a href="#fnref29">↩</a></li>
<li id="fn30">Landauer, T., Laham, D., and Derr, M., From Paragraph to Graph: Latent Semantic Analysis for Information Visualization, Proceedings of the National Academy of Science, 101, 2004, pp. 5214–5219.<a href="#fnref30">↩</a></li>
<li id="fn31">Foltz, Peter W., Laham, Darrell, and Landauer, Thomas K., Automated Essay Scoring: Applications to Educational Technology, Proceedings of EdMedia, 1999.<a href="#fnref31">↩</a></li>
<li id="fn32">Gordon, M., and Dumais, S., Using Latent Semantic Indexing for Literature Based Discovery, Journal of the American Society for Information Science, 49(8), 1998, pp. 674–685.<a href="#fnref32">↩</a></li>
<li id="fn33">There Has to be a Better Way to Search, 2008, White Paper, Fios, Inc.<a href="#fnref33">↩</a></li>
<li id="fn34">Karypis, G., Han, E., Fast Supervised Dimensionality Reduction Algorithm with Applications to Document Categorization and Retrieval, Proceedings of CIKM-00, 9th ACM Conference on Information and Knowledge Management.<a href="#fnref34">↩</a></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36">Bradford, R., An Empirical Study of Required Dimensionality for Large-scale Latent Semantic Indexing Applications, Proceedings of the 17th ACM Conference on Information and Knowledge Management, Napa Valley, California, USA, 2008, pp. 153–162.<a href="#fnref36">↩</a></li>
<li id="fn37">Landauer, Thomas K., and Dumais, Susan T., Latent Semantic Analysis, Scholarpedia, 3(11):4356, 2008.<a href="#fnref37">↩</a></li>
<li id="fn38">Cangelosi, R., Goriely A., Component Retention In Principal Component Analysis With Application to Cdna Microarray Data, BMC Biology Direct 2(2) (2007).<a href="#fnref38">↩</a></li>
<li id="fn39">Jolliffe, L. T., Principal Component Analysis, Springer-Verlag, New York, (1986).<a href="#fnref39">↩</a></li>
<li id="fn40">Hu, X., Z. Cai, et al., LSA: First Dimension and Dimensional Weighting, 25th Annual Meeting of the Cognitive Science Society, Boston, MA.<a href="#fnref40">↩</a></li>
</ol>
</section>
</body>
</html>
