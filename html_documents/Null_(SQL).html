<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1933">Null (SQL)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Null (SQL)</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>
<figure><b>(Figure)</b>
<figcaption>The Greek lowercase <a href="Omega" title="wikilink">omega (ω)</a> character is used to represent Null in <a href="database_theory" title="wikilink">database theory</a>.</figcaption>
</figure>

<p><strong>Null</strong> is a special marker used in <a href="SQL" title="wikilink">Structured Query Language</a> (SQL) to indicate that a data value does not exist in the database. Introduced by the creator of the <a href="Relational_model" title="wikilink">relational</a> database model, <a href="Edgar_F._Codd" title="wikilink">E. F. Codd</a>, <a class="uri" href="SQL" title="wikilink">SQL</a> Null serves to fulfill the requirement that all <em>true <a href="RDBMS" title="wikilink">relational database management systems (RDBMS)</a></em> support a representation of "missing information and inapplicable information". Codd also introduced the use of the lowercase <a href="Greek_alphabet" title="wikilink">Greek</a> <a class="uri" href="omega" title="wikilink">omega</a> (ω) symbol to represent Null in <a href="database_theory" title="wikilink">database theory</a>. <code>NULL</code> is also an SQL <a href="reserved_word" title="wikilink">reserved keyword</a> used to identify the Null special marker.</p>

<p>For people new to the subject, a good way to remember what null means is to remember that in terms of <a class="uri" href="information" title="wikilink">information</a>, "lack of a value" is not the same thing as "a value of zero"; similarly, "lack of an answer" is not the same thing as "an answer of no". For example, consider the question "How many books does Juan own?" The answer may be "zero" (we <em>know</em> that he owns <em>none</em>) or "null" (we <em>do not know</em> how many he owns, or doesn't own). In a database table, the column reporting this answer would start out with a value of null, and it would not be updated with "zero" until we have ascertained that Juan owns no books.</p>

<p>SQL null is a state (unknown) and not a value. This usage is quite different from most programming languages, where null means not assigned to a particular instance.</p>
<h2 id="history">History</h2>

<p>E. F. Codd mentioned nulls as a method of representing missing data in the <a href="relational_model" title="wikilink">relational model</a> in a 1975 paper in the <em>FDT Bulletin of <a href="Association_for_Computing_Machinery" title="wikilink">ACM</a>-<a class="uri" href="SIGMOD" title="wikilink">SIGMOD</a></em>. Codd's paper that is most commonly cited in relation with the semantics of Null (as adopted in SQL) is his 1979 paper in the <em><a href="ACM_Transactions_on_Database_Systems" title="wikilink">ACM Transactions on Database Systems</a></em>, in which he also introduced his <a href="Relational_Model/Tasmania" title="wikilink">Relational Model/Tasmania</a>, although much of the other proposals from the latter paper have remained obscure. Section 2.3 of his 1979 paper details the semantics of Null propagation in arithmetic operations as well as comparisons employing a <a href="Ternary_logic" title="wikilink">ternary (three-valued)</a> logic when comparing to nulls; it also details the treatment of Nulls on other set operations (the latter issue still controversial today). In <a href="database_theory" title="wikilink">database theory</a> circles, the original proposal of Codd (1975, 1979) is now referred to as "Krokk tables".<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Codd later reinforced his requirement that all RDBMSs support Null to indicate missing data in a 1985 two-part article published in <em><a class="uri" href="ComputerWorld" title="wikilink">ComputerWorld</a></em> magazine.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>The 1986 SQL standard basically adopted Codd's proposal after an implementation prototype in <a href="IBM_System_R" title="wikilink">IBM System R</a>. Although <a href="Don_Chamberlin" title="wikilink">Don Chamberlin</a> recognized nulls (alongside duplicate rows) as one of the most controversial features of SQL, he defended the design of Nulls in SQL invoking the pragmatic arguments that it was the least expensive form of system support for missing information, saving the programmer from many duplicative application-level checks (see <a href="semipredicate_problem" title="wikilink">semipredicate problem</a>) while at the same time providing the database designer with the option not to use Nulls if he so desires; for example, in order to avoid well known anomalies (discussed in the <a href="#missing-value_semantics" title="wikilink">semantics section</a> of this article). Chamberlin also argued that besides providing some missing-value functionality, practical experience with Nulls also led to other language features which rely on Nulls, like certain grouping constructs and outer joins. Finally, he argued that in practice Nulls also end up being used as a quick way to patch an existing schema when it needs to evolve beyond its original intent, coding not for missing but rather for inapplicable information; for example, a database that quickly needs to support electric cars while having a miles-per-gallon column.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Codd indicated in his 1990 book <em>The Relational Model for Database Management, Version 2</em> that the single Null mandated by the SQL standard was inadequate, and should be replaced by two separate Null-type markers to indicate the reason why data is missing. In Codd's book, these two Null-type markers are referred to as 'A-Values' and 'I-Values', representing 'Missing But Applicable' and 'Missing But Inapplicable', respectively.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Codd's recommendation would have required SQL's logic system be expanded to accommodate a four-valued logic system. Because of this additional complexity, the idea of multiple Null-type values has not gained widespread acceptance in the database practitioners' domain. It remains an active field of research though, with numerous papers still being published.</p>
<h3 id="challenges">Challenges</h3>

<p>Null has been the focus of controversy and a source of debate because of its associated <a href="three-valued_logic" title="wikilink">three-valued logic</a> (3VL), special requirements for its use in <a href="Join_(SQL)" title="wikilink">SQL joins</a>, and the special handling required by aggregate functions and SQL grouping operators. Computer science professor Ron van der Meyden summarized the various issues as: "The inconsistencies in the SQL standard mean that it is not possible to ascribe any intuitive logical semantics to the treatment of nulls in SQL."<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Although various proposals have been made for resolving these issues, the complexity of the alternatives has prevented their widespread adoption.</p>
<h2 id="null-propagation">Null propagation</h2>
<h3 id="arithmetic-operations">Arithmetic operations</h3>

<p>Because Null is not a data value, but a marker for an unknown value, using mathematical operators on Null results in an unknown value, which is represented by Null.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> In the following example, multiplying 10 by Null results in Null:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="dv">10</span> * <span class="kw">NULL</span>          <span class="co">-- Result is NULL</span></code></pre></div>

<p>This can lead to unanticipated results. For instance, when an attempt is made to divide Null by zero, platforms may return Null instead of throwing an expected "data exception - division by zero".<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Though this behavior is not defined by the ISO SQL standard many DBMS vendors treat this operation similarly. For instance, the Oracle, PostgreSQL, MySQL Server, and Microsoft SQL Server platforms all return a Null result for the following:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">NULL</span> / <span class="dv">0</span></code></pre></div>
<h3 id="string-concatenation">String concatenation</h3>

<p>String <a class="uri" href="concatenation" title="wikilink">concatenation</a> operations, which are common in SQL, also result in Null when one of the operands is Null.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> The following example demonstrates the Null result returned by using Null with the SQL <code>||</code> string concatenation operator.</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="st">'Fish '</span> || <span class="kw">NULL</span> || <span class="st">'Chips'</span>   <span class="co">-- Result is NULL</span></code></pre></div>

<p>This is not true for all database implementations. In an Oracle RDBMS for example NULL and the empty string are considered the same thing and therefore 'Fish ' || NULL || 'Chips' results in 'Fish Chips'.</p>
<h2 id="comparisons-with-null-and-the-three-valued-logic-3vl">Comparisons with NULL and the three-valued logic (3VL)</h2>

<p>Since Null is not a member of any <a href="data_domain" title="wikilink">data domain</a>, it is not considered a "value", but rather a marker (or placeholder) indicating the <a href="undefined_value" title="wikilink">absence of value</a>. Because of this, comparisons with Null can never result in either True or False, but always in a third logical result, Unknown.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> The logical result of the expression below, which compares the value 10 to Null, is Unknown:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="dv">10</span> = <span class="kw">NULL</span>       <span class="co">-- Results in Unknown</span></code></pre></div>

<p>However, certain operations on Null can return values if the value of Null is not relevant to the outcome of the operation. Consider the following example:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="kw">NULL</span> <span class="kw">OR</span> <span class="kw">TRUE</span>   <span class="co">-- Results in True</span></code></pre></div>

<p>In this case, the fact that the value on the left of OR is unknowable is irrelevant, because the outcome of the OR operation would be True regardless of the value on the left.</p>

<p>SQL implements three logical results, so SQL implementations must provide for a specialized <a href="Ternary_logic" title="wikilink">three-valued logic (3VL)</a>. The rules governing SQL three-valued logic are shown in the tables below (<strong>p</strong> and <strong>q</strong> represent logical states)"<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> The truth tables SQL uses for AND, OR, and NOT correspond to a common fragment of the Kleene and Łukasiewicz three-valued logic (which differ in their definition of implication, however SQL defines no such operation).<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>p</em></p></td>
<td style="text-align: left;">
<p><em>q</em></p></td>
<td style="text-align: left;">
<p><em>p</em> OR <em>q</em></p></td>
<td style="text-align: left;">
<p><em>p</em> AND <em>q</em></p></td>
<td style="text-align: left;">
<p><em>p</em> = <em>q</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>True</p></td>
<td style="text-align: left;">
<p>True</p></td>
<td style="text-align: left;">
<p>True</p></td>
<td style="text-align: left;">
<p>True</p></td>
<td style="text-align: left;">
<p>True</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>True</p></td>
<td style="text-align: left;">
<p>False</p></td>
<td style="text-align: left;">
<p>True</p></td>
<td style="text-align: left;">
<p>False</p></td>
<td style="text-align: left;">
<p>False</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>True</p></td>
<td style="text-align: left;">
<p>Unknown</p></td>
<td style="text-align: left;">
<p>True</p></td>
<td style="text-align: left;">
<p>Unknown</p></td>
<td style="text-align: left;">
<p>Unknown</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>False</p></td>
<td style="text-align: left;">
<p>True</p></td>
<td style="text-align: left;">
<p>True</p></td>
<td style="text-align: left;">
<p>False</p></td>
<td style="text-align: left;">
<p>False</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>False</p></td>
<td style="text-align: left;">
<p>False</p></td>
<td style="text-align: left;">
<p>False</p></td>
<td style="text-align: left;">
<p>False</p></td>
<td style="text-align: left;">
<p>True</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>False</p></td>
<td style="text-align: left;">
<p>Unknown</p></td>
<td style="text-align: left;">
<p>Unknown</p></td>
<td style="text-align: left;">
<p>False</p></td>
<td style="text-align: left;">
<p>Unknown</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Unknown</p></td>
<td style="text-align: left;">
<p>True</p></td>
<td style="text-align: left;">
<p>True</p></td>
<td style="text-align: left;">
<p>Unknown</p></td>
<td style="text-align: left;">
<p>Unknown</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Unknown</p></td>
<td style="text-align: left;">
<p>False</p></td>
<td style="text-align: left;">
<p>Unknown</p></td>
<td style="text-align: left;">
<p>False</p></td>
<td style="text-align: left;">
<p>Unknown</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Unknown</p></td>
<td style="text-align: left;">
<p>Unknown</p></td>
<td style="text-align: left;">
<p>Unknown</p></td>
<td style="text-align: left;">
<p>Unknown</p></td>
<td style="text-align: left;">
<p>Unknown</p></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>p</em></p></td>
<td style="text-align: left;">
<p>NOT <em>p</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>True</p></td>
<td style="text-align: left;">
<p>False</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>False</p></td>
<td style="text-align: left;">
<p>True</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Unknown</p></td>
<td style="text-align: left;">
<p>Unknown</p></td>
</tr>
</tbody>
</table>
<h3 id="effect-of-unknown-in-where-clauses">Effect of Unknown in WHERE clauses</h3>

<p>SQL three-valued logic is encountered in <a href="Data_Manipulation_Language" title="wikilink">Data Manipulation Language</a> (DML) in comparison predicates of DML statements and queries. The <code>[[Where (SQL)|WHERE]]</code> clause causes the DML statement to act on only those rows for which the predicate evaluates to True. Rows for which the predicate evaluates to either False or Unknown are not acted on by <code>[[Insert (SQL)|INSERT]]</code>, <code>[[Update (SQL)|UPDATE]]</code>, or <code>[[Delete (SQL)|DELETE]]</code> DML statements, and are discarded by <code>[[Select (SQL)|SELECT]]</code> queries. Interpreting Unknown and False as the same logical result is a common error encountered while dealing with Nulls.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> The following simple example demonstrates this fallacy:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * 
<span class="kw">FROM</span> t 
<span class="kw">WHERE</span> i = <span class="kw">NULL</span>;</code></pre></div>

<p>The example query above logically always returns zero rows because the comparison of the <em>i</em> column with Null always returns Unknown, even for those rows where <em>i</em> is Null. The Unknown result causes the <code>SELECT</code> statement to summarily discard each and every row. (However, in practice, some SQL tools will retrieve rows using a comparison with Null.)</p>
<h3 id="null-specific-and-3vl-specific-comparison-predicates">Null-specific and 3VL-specific comparison predicates</h3>

<p>Basic SQL comparison operators always return Unknown when comparing anything with Null, so the SQL standard provides for two special Null-specific comparison predicates. The <code>IS NULL</code> and <code>IS NOT NULL</code> predicates (which use a <a href="Reverse_Polish_notation" title="wikilink">postfix</a> syntax) test whether data is, or is not, Null.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>The SQL standard contains an extension F571 "Truth value tests" that introduces three additional logical unary operators (six in fact, if we count their negation, which is part of their syntax), also using postfix notation. They have the following truth tables:<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>p</p></th>
<th style="text-align: left;">
<p>true</p></th>
<th style="text-align: left;">
<p>false</p></th>
<th style="text-align: left;">
<p>unknown</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>p IS TRUE</p></td>
<td style="text-align: left;">
<p>true</p></td>
<td style="text-align: left;">
<p>false</p></td>
<td style="text-align: left;">
<p>false</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>p IS NOT TRUE</p></td>
<td style="text-align: left;">
<p>false</p></td>
<td style="text-align: left;">
<p>true</p></td>
<td style="text-align: left;">
<p>true</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>p IS FALSE</p></td>
<td style="text-align: left;">
<p>false</p></td>
<td style="text-align: left;">
<p>true</p></td>
<td style="text-align: left;">
<p>false</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>p IS NOT FALSE</p></td>
<td style="text-align: left;">
<p>true</p></td>
<td style="text-align: left;">
<p>false</p></td>
<td style="text-align: left;">
<p>true</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>p IS UNKNOWN</p></td>
<td style="text-align: left;">
<p>false</p></td>
<td style="text-align: left;">
<p>false</p></td>
<td style="text-align: left;">
<p>true</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>p IS NOT UNKNOWN</p></td>
<td style="text-align: left;">
<p>true</p></td>
<td style="text-align: left;">
<p>true</p></td>
<td style="text-align: left;">
<p>false</p></td>
</tr>
</tbody>
</table>

<p>The F571 extension is orthogonal to the presence of the boolean datatype in SQL (discussed later in this article) and, despite syntactic similarities, F571 does not introduce boolean or three-valued <a href="Literal_(computer_programming)" title="wikilink">literals</a> in the language. The F571 extension was actually present in <a class="uri" href="SQL92" title="wikilink">SQL92</a>,<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> well before the boolean datatype was introduced to the standard in 1999. The F571 extension is implemented by few systems however; PostgreSQL is one of those implementing it.</p>

<p>The addition of IS UNKNOWN to the other operators of SQL's three-valued logic makes the SQL three-valued logic <a href="functionally_complete" title="wikilink">functionally complete</a>,<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> meaning its logical operators can express (in combination) any conceivable three-valued logical function.</p>

<p>On systems which don't support the F571 extension, it is possible to emulate IS UNKNOWN <em>p</em> by going over every argument that could make the expression <em>p</em> Unknown and test those arguments with IS NULL or other NULL-specific functions, although this may be more cumbersome.</p>
<h3 id="law-of-the-excluded-fourth-in-where-clauses">Law of the excluded fourth (in WHERE clauses)</h3>

<p>In SQL's three-valued logic the <a href="law_of_excluded_middle" title="wikilink">law of the excluded middle</a>, <em>p</em> OR NOT <em>p</em>, no longer evaluates to true for all <em>p</em>. More precisely, in SQL's three-valued logic <em>p</em> OR NOT <em>p</em> is unknown precisely when <em>p</em> is unknown and true otherwise. Because direct comparisons with Null result in the unknown logical value, the following query</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> stuff <span class="kw">WHERE</span> ( x = <span class="dv">10</span> ) <span class="kw">OR</span> <span class="kw">NOT</span> ( x = <span class="dv">10</span> );</code></pre></div>

<p>is not equivalent in SQL with</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> stuff;</code></pre></div>

<p>if the column x contains any Nulls; in that case the second query would return some rows the first one does not return, namely all those in which x is Null. In classical two-valued logic, the law of the excluded middle would allow the simplification of the WHERE clause predicate, in fact its elimination. Attempting to apply the law of the excluded middle to SQL's 3VL is effectively a <a href="False_dilemma" title="wikilink">false dichotomy</a>. The second query is actually equivalent with:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> stuff;
<span class="co">-- is (because of 3VL) equivalent to:</span>
<span class="kw">SELECT</span> * <span class="kw">FROM</span> stuff <span class="kw">WHERE</span> ( x = <span class="dv">10</span> ) <span class="kw">OR</span> <span class="kw">NOT</span> ( x = <span class="dv">10</span> ) <span class="kw">OR</span> x <span class="kw">IS</span> <span class="kw">NULL</span>;</code></pre></div>

<p>Thus, to correctly simplify the first statement in SQL requires that we return all rows in which x is not null.</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> stuff <span class="kw">WHERE</span> x <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">NULL</span>;</code></pre></div>

<p>In view of the above, observe that for SQL's WHERE clause a <a href="Tautology_(logic)" title="wikilink">tautology</a> similar to the law of excluded middle can be written. Assuming the IS UNKNOWN operator is present, <em>p</em> OR (NOT <em>p</em>) OR (<em>p</em> IS UNKNOWN) is true for every predicate <em>p</em>. Among logicians, this is called <a href="law_of_excluded_fourth" title="wikilink">law of excluded fourth</a>.</p>

<p>There are some SQL expressions in which it is less obvious where the false dilemma occurs, for example:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="st">'ok'</span> <span class="kw">WHERE</span> <span class="dv">1</span> <span class="kw">NOT</span> <span class="kw">IN</span> (<span class="kw">SELECT</span> <span class="fu">CAST</span> (<span class="kw">NULL</span> <span class="kw">AS</span> <span class="dt">INTEGER</span>))
<span class="kw">UNION</span>
<span class="kw">SELECT</span> <span class="st">'ok'</span> <span class="kw">WHERE</span> <span class="dv">1</span> <span class="kw">IN</span> (<span class="kw">SELECT</span> <span class="fu">CAST</span> (<span class="kw">NULL</span> <span class="kw">AS</span> <span class="dt">INTEGER</span>));</code></pre></div>

<p>produces no rows because <code>IN</code> is translates to an iterated version of equality over the argument set and 1NULL is Unknown, just a as 1=NULL is Unknown. (The CAST in this example is needed only in some SQL implementations like PostgreSQL, which would reject it with a type checking error otherwise. In many systems plain SELECT NULL works in the subquery.) The missing case above is of course:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="st">'ok'</span> <span class="kw">WHERE</span> (<span class="dv">1</span> <span class="kw">IN</span> (<span class="kw">SELECT</span> <span class="fu">CAST</span> (<span class="kw">NULL</span> <span class="kw">AS</span> <span class="dt">INTEGER</span>))) <span class="kw">IS</span> UNKNOWN;</code></pre></div>
<h3 id="effect-of-null-and-unknown-in-other-constructs">Effect of Null and Unknown in other constructs</h3>
<h4 id="joins">Joins</h4>

<p>Joins evaluate using the same comparison rules as for WHERE clauses. Therefore, care must be taken when using nullable columns in SQL join criteria. In particular a table containing any nulls is <em>not equal</em> with a natural self-join of itself, meaning that whereas 

<math display="inline" id="Null_(SQL):0">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>⋈</mo>
   <mi>R</mi>
   <mo>=</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-⋈</ci>
     <ci>R</ci>
     <ci>R</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\bowtie R=R
  </annotation>
 </semantics>
</math>

 is true for any relation <em>R</em> in <a href="relational_algebra" title="wikilink">relational algebra</a>, a SQL self-join will exclude all rows having a null value anywhere.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> An example of this behavior is given in the section analyzing the missing-value semantics of Nulls.</p>

<p>The SQL <code>COALESCE</code> function or <code>CASE</code> expressions can be used to "simulate" Null equality in join criteria, and the <code>IS NULL</code> and <code>IS NOT NULL</code> predicates can be used in the join criteria as well. The following predicate tests for equality of the values A and B and treats Nulls as being equal.</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql">(A = B) <span class="kw">OR</span> (A <span class="kw">IS</span> <span class="kw">NULL</span> <span class="kw">AND</span> B <span class="kw">IS</span> <span class="kw">NULL</span>)</code></pre></div>
<h4 id="case-expressions">CASE expressions</h4>

<p>SQL provides <a href="Case_(SQL)" title="wikilink">two flavours of conditional expressions</a>. One is called "simple CASE" and operates like a <a href="switch_statement" title="wikilink">switch statement</a>. The other is called a "searched CASE" in the standard, and operates like an <a href="Conditional_(programming)#Else_if" title="wikilink">if...elseif</a>.</p>

<p>The simple <code>CASE</code> expressions use implicit equality comparisons which operate under the same rules as the DML <code>WHERE</code> clause rules for Null. Thus, a <em>simple <code>CASE</code> expression</em> cannot check for the existence of Null directly. A check for Null in a simple <code>CASE</code> expression always results in Unknown, as in the following:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="kw">CASE</span> i <span class="kw">WHEN</span> <span class="kw">NULL</span> <span class="kw">THEN</span> <span class="st">'Is Null'</span>  <span class="co">-- This will never be returned</span>
              <span class="kw">WHEN</span>    <span class="dv">0</span> <span class="kw">THEN</span> <span class="st">'Is Zero'</span>  <span class="co">-- This will be returned when i = 0</span>
              <span class="kw">WHEN</span>    <span class="dv">1</span> <span class="kw">THEN</span> <span class="st">'Is One'</span>   <span class="co">-- This will be returned when i = 1</span>
              <span class="kw">END</span>
<span class="kw">FROM</span> t;</code></pre></div>

<p>Because the expression <code>i = NULL</code> evaluates to Unknown no matter what value column <em>i</em> contains (even if it contains Null), the string <code>'Is Null'</code> will never be returned.</p>

<p>On the other hand, a "searched" <code>CASE</code> expression can use predicates like <code>IS NULL</code> and <code>IS NOT NULL</code> in its conditions. The following example shows how to use a searched <code>CASE</code> expression to properly check for Null:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="kw">CASE</span> <span class="kw">WHEN</span> i <span class="kw">IS</span> <span class="kw">NULL</span> <span class="kw">THEN</span> <span class="st">'Null Result'</span>  <span class="co">-- This will be returned when i is NULL</span>
            <span class="kw">WHEN</span>     i = <span class="dv">0</span> <span class="kw">THEN</span> <span class="st">'Zero'</span>         <span class="co">-- This will be returned when i = 0</span>
            <span class="kw">WHEN</span>     i = <span class="dv">1</span> <span class="kw">THEN</span> <span class="st">'One'</span>          <span class="co">-- This will be returned when i = 1</span>
            <span class="kw">END</span>
<span class="kw">FROM</span> t;</code></pre></div>

<p>In the searched <code>CASE</code> expression, the string <code>'Null Result'</code> is returned for all rows in which <em>i</em> is Null.</p>

<p>Oracle's dialect of SQL provides a built-in function <code>DECODE</code> which can be used instead of the simple CASE expressions and considers two nulls equal.</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="fu">DECODE</span>(i, <span class="kw">NULL</span>, <span class="st">'Null Result'</span>, <span class="dv">0</span>, <span class="st">'Zero'</span>, <span class="dv">1</span>, <span class="st">'One'</span>) <span class="kw">FROM</span> t;</code></pre></div>

<p>Finally, all these constructs return a NULL if no match is found; they have a default <code>ELSE NULL</code> clause.</p>
<h4 id="if-statements-in-procedural-extensions">IF statements in procedural extensions</h4>

<p><a class="uri" href="SQL/PSM" title="wikilink">SQL/PSM</a> (SQL Persistent Stored Modules) defines <a href="Procedural_programming" title="wikilink">procedural</a> extensions for SQL, such as the <code>[[Conditional (programming)|IF]]</code> statement. However, the major SQL vendors have historically included their own proprietary procedural extensions. Procedural extensions for looping and comparisons operate under Null comparison rules similar to those for DML statements and queries. The following code fragment, in ISO SQL standard format, demonstrates the use of Null 3VL in an <code>IF</code> statement.</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">IF</span> i = <span class="kw">NULL</span> <span class="kw">THEN</span>
      <span class="kw">SELECT</span> <span class="st">'Result is True'</span>
ELSEIF <span class="kw">NOT</span>(i = <span class="kw">NULL</span>) <span class="kw">THEN</span>
      <span class="kw">SELECT</span> <span class="st">'Result is False'</span>
<span class="kw">ELSE</span>
      <span class="kw">SELECT</span> <span class="st">'Result is Unknown'</span>;</code></pre></div>

<p>The <code>IF</code> statement performs actions only for those comparisons that evaluate to True. For statements that evaluate to False or Unknown, the <code>IF</code> statement passes control to the <code>[[Conditional (programming)|ELSEIF]]</code> clause, and finally to the <code>[[Conditional (programming)|ELSE]]</code> clause. The result of the code above will always be the message <code>'Result is Unknown'</code> since the comparisons with Null always evaluate to Unknown.</p>
<h2 id="analysis-of-sql-null-missing-value-semantics"> Analysis of SQL Null missing-value semantics</h2>

<p>The groundbreaking work of T. Imielinski and W. Lipski (1984) provided a framework in which to evaluate the intended semantics of various proposals to implement missing-value semantics. This section roughly follows chapter 19 the "Alice" textbook.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> A similar presentation appears in the review of Ron van der Meyden, §10.4.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h3 id="in-selections-and-projections-weak-representation">In selections and projections: weak representation</h3>

<p>Constructs representing missing information, such as Codd tables, are actually intended to represent a set of relations, one for each possible instantiation of their parameters; in the case of Codd tables, this means replacement of Nulls with some concrete value. For example,</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>the Codd table</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>Emp</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Name</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>George</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Harriet</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Charles</p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>| may represent</p></td>
<td style="text-align: left;">
<p>| the relation</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>EmpH22</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Name</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>George</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Harriet</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Charles</p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>| or equally well</p></td>
<td style="text-align: left;">
<p>| the relation</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>EmpH37</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Name</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>George</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Harriet</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Charles</p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table>

<p>A construct (such as a Codd table) is said to be a <em>strong representation</em> system (of missing information) if any answer to a query made on the construct can be particularized to obtain an answer for <em>any</em> corresponding query on the relations it represents, which are seen as <a href="Structure_(mathematical_logic)" title="wikilink">models</a> of the construct. More precisely, if 

<math display="inline" id="Null_(SQL):1">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 is a query formula in the <a href="relational_algebra" title="wikilink">relational algebra</a> (of "pure" relations) and if 

<math display="inline" id="Null_(SQL):2">
 <semantics>
  <mover accent="true">
   <mi>q</mi>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{q}
  </annotation>
 </semantics>
</math>

 is its lifting to a construct intended to represent missing information, a strong representation has the property that for any query <em>q</em> and (table) construct <em>T</em>, 

<math display="inline" id="Null_(SQL):3">
 <semantics>
  <mover accent="true">
   <mi>q</mi>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{q}
  </annotation>
 </semantics>
</math>

 lifts <em>all</em> the answers to the construct, i.e.:</p>

<p>

<math display="block" id="Null_(SQL):4">
 <semantics>
  <mrow>
   <mrow>
    <mo>Models</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mover accent="true">
       <mi>q</mi>
       <mo stretchy="false">¯</mo>
      </mover>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>T</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>R</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>R</mi>
     <mo>∈</mo>
     <mrow>
      <mo>Models</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>T</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>Models</ci>
     <apply>
      <times></times>
      <apply>
       <ci>normal-¯</ci>
       <ci>q</ci>
      </apply>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <ci>q</ci>
      <ci>R</ci>
     </apply>
     <apply>
      <in></in>
      <ci>R</ci>
      <apply>
       <ci>Models</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathop{\mathrm{Models}}(\bar{q}(T))=\{q(R)\,|R\in\mathop{\mathrm{Models}}(T)\}
  </annotation>
 </semantics>
</math>

</p>

<p>(The above has to hold for queries taking any number of tables as arguments, but the restriction to one table suffices for this discussion.) Clearly Codd tables do not have this strong property if selections and projections are considered as part of the query language. For example, <em>all</em> the answers to</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> Emp <span class="kw">WHERE</span> Age = <span class="dv">22</span>;</code></pre></div>

<p>should include the possibility that a relation like EmpH22 may exist. However Codd tables cannot represent the disjunction "result with possibly 0 or 1 rows". A device, mostly of theoretical interest, called <a href="conditional_table" title="wikilink">conditional table</a> (or c-table) can however represent such an answer:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>Result</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Name</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Harriet</p></td>
</tr>
<tr class="even">
</tr>
</tbody>
</table>

<p>where the condition column is interpreted as the row doesn't exist if the condition is false. It turns out that because the formulas in the condition column of a c-table can be arbitrary <a href="propositional_logic" title="wikilink">propositional logic</a> formulas, an algorithm for the problem whether a c-table represents some concrete relation has a <a class="uri" href="co-NP-complete" title="wikilink">co-NP-complete</a> complexity, thus is of little practical value.</p>

<p>A weaker notion of representation is therefore desirable. Imielinski and Lipski introduced the notion of <em>weak representation</em>, which essentially allows (lifted) queries over a construct to return a representation only for <em>sure</em> information, i.e. if it's valid for all "<a href="possible_world" title="wikilink">possible world</a>" instantiations (models) of the construct. Concretely, a construct is a weak representation system if</p>

<p>

<math display="block" id="Null_(SQL):5">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋂</mo>
    <mrow>
     <mo>Models</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mover accent="true">
        <mi>q</mi>
        <mo stretchy="false">¯</mo>
       </mover>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>T</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋂</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>q</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>R</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>R</mi>
      <mo>∈</mo>
      <mrow>
       <mo>Models</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>T</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <intersect></intersect>
     <apply>
      <ci>Models</ci>
      <apply>
       <times></times>
       <apply>
        <ci>normal-¯</ci>
        <ci>q</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <intersect></intersect>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <times></times>
       <ci>q</ci>
       <ci>R</ci>
      </apply>
      <apply>
       <in></in>
       <ci>R</ci>
       <apply>
        <ci>Models</ci>
        <ci>T</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigcap\mathop{\mathrm{Models}}(\bar{q}(T))=\bigcap\{q(R)\,|R\in\mathop{%
\mathrm{Models}}(T)\}
  </annotation>
 </semantics>
</math>

</p>

<p>The right-hand side of the above equation is the <em>sure</em> information, i.e. information which can be certainly extracted from the database regardless of what values are used to replace Nulls in the database. In the example we considered above, it's easy to see that the intersection of all possible models (i.e. the sure information) of the query selecting WHERE Age = 22 is actually empty because, for instance, the (unlifted) query returns no rows for the relation EmpH37. More generally, it was shown by Imielinski and Lipski that Codd tables are a weak representation system if the query language is restricted to projections, selections (and renaming of columns). However, as soon as we add either joins or unions to the query language, even this weak property is lost, as evidenced in the next section.</p>
<h3 id="if-joins-or-unions-are-considered-not-even-weak-representation">If joins or unions are considered: not even weak representation</h3>

<p>Let us consider the following query over the same Codd table Emp from the previous section:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> Name <span class="kw">FROM</span> Emp <span class="kw">WHERE</span> Age = <span class="dv">22</span>
<span class="kw">UNION</span>
<span class="kw">SELECT</span> Name <span class="kw">FROM</span> Emp <span class="kw">WHERE</span> Age &lt;&gt; <span class="dv">22</span>;</code></pre></div>

<p>Whatever concrete value one would choose for the NULL age of Harriet, the above query will return the full column of names of any model of Emp, but when the (lifted) query is run on Emp itself, Harriet will always be missing, i.e. we have:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Query result on Emp:</p></td>
<td style="text-align: left;">
<p>|</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Name</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>George</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Charles</p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>| Query result on any model of Emp:</p></td>
<td style="text-align: left;">
<p>|</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Name</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>George</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Harriet</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Charles</p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table>

<p>Thus when unions are added to the query language, Codd tables are not even a weak representation system of missing information, meaning that queries over them don't even report all <em>sure</em> information. It's important to note here that semantics of UNION on Nulls, which are discussed in a later section, did not even come into play in this query. The "forgetful" nature of the two sub-queries was all that it took to guarantee that some sure information went unreported when the above query was run on the Codd table Emp.</p>

<p>For <a href="natural_join" title="wikilink">natural joins</a>, the example needed to show that sure information may be unreported by some query is slightly more complicated. Consider the table</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>J</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>F1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>11</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>21</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>31</p></td>
</tr>
</tbody>
</table>

<p>and the query</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> F1, F3 <span class="kw">FROM</span>
  (<span class="kw">SELECT</span> F1, F2 <span class="kw">FROM</span> J) <span class="kw">AS</span> F12
  <span class="kw">NATURAL</span> <span class="kw">JOIN</span>
  (<span class="kw">SELECT</span> F2, F3 <span class="kw">FROM</span> J) <span class="kw">AS</span> F23;</code></pre></div>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Query result on J:</p></td>
<td style="text-align: left;">
<p>|</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>F1</p></td>
<td style="text-align: left;">
<p>F3</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>31</p></td>
<td style="text-align: left;">
<p>33</p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;">
<p>| Query result on any model of J:</p></td>
<td style="text-align: left;">
<p>|</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>F1</p></td>
<td style="text-align: left;">
<p>F3</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>11</p></td>
<td style="text-align: left;">
<p>13</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>21</p></td>
<td style="text-align: left;">
<p>23</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>31</p></td>
<td style="text-align: left;">
<p>33</p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table>

<p>The intuition for what happens above is that the Codd tables representing the projections in the subqueries lose track of the fact that the Null values in the columns F12.F2 and F23.F2 are actually copies of the originals in the table J. This observation suggests that a relatively simple improvement of Codd tables (which works correctly for this example) would be to use <em>Skolem constants</em> (meaning <a href="Skolem_function" title="wikilink">Skolem functions</a> which are also <a href="constant_function" title="wikilink">constant functions</a>), say ω<sub>12</sub> and ω<sub>22</sub> instead of a single NULL symbol. Such an approach, called v-tables or Naive tables, is computationally less expensive that the c-tables discussed above. However it is still not a complete solution for incomplete information in the sense that v-tables are only a weak representation for queries not using any negations in selection (and not using any set difference either). The first example considered in this section is using a negative selection clause, WHERE Age  22, so it is also an example where v-tables queries would not report sure information.</p>
<h2 id="check-constraints-and-foreign-keys">Check constraints and foreign keys</h2>

<p>The primary place in which SQL three-valued logic intersects with SQL <a href="Data_Definition_Language" title="wikilink">Data Definition Language</a> (DDL) is in the form of <a href="check_constraint" title="wikilink">check constraints</a>. A check constraint placed on a column operates under a slightly different set of rules than those for the DML <code>WHERE</code> clause. While a DML <code>WHERE</code> clause must evaluate to True for a row, a check constraint must not evaluate to False. (From a logic perspective, the <a href="designated_value" title="wikilink">designated values</a> are True and Unknown.) This means that a check constraint will succeed if the result of the check is either True or Unknown. The following example table with a check constraint will prohibit any integer values from being inserted into column <em>i</em>, but will allow Null to be inserted since the result of the check will always evaluate to Unknown for Nulls.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CREATE</span> <span class="kw">TABLE</span> t (
     i <span class="dt">INTEGER</span>,
     <span class="kw">CONSTRAINT</span> ck_i <span class="kw">CHECK</span> ( i &lt; <span class="dv">0</span> <span class="kw">AND</span> i = <span class="dv">0</span> <span class="kw">AND</span> i &gt; <span class="dv">0</span> ) );</code></pre></div>

<p>Because of the change in designated values relative to the WHERE clause, from a logic perspective the law of excluded middle is a tautology for CHECK constraints, meaning CHECK (<em>p</em> OR NOT <em>p</em>) always succeeds. Furthermore, assuming Nulls are to be interpreted as existing but unknown values, some pathological CHECKs like the one above allow insertion of Nulls that could never be replaced by any non-null value.</p>

<p>In order to constrain a column to reject Nulls, the <code>NOT NULL</code> constraint can be applied, as shown in the example below. The <code>NOT NULL</code> constraint is semantically equivalent to a <a href="check_constraint" title="wikilink">check constraint</a> with an <code>IS NOT NULL</code> predicate.</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CREATE</span> <span class="kw">TABLE</span> t ( i <span class="dt">INTEGER</span> <span class="kw">NOT</span> <span class="kw">NULL</span> );</code></pre></div>

<p>By default check constraints against <a href="foreign_key" title="wikilink">foreign keys</a> succeed if any of the fields in such keys are Null. For example the table</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CREATE</span> <span class="kw">TABLE</span> Books
( title <span class="dt">VARCHAR</span>(<span class="dv">100</span>),
  author_last <span class="dt">VARCHAR</span>(<span class="dv">20</span>),
  author_first <span class="dt">VARCHAR</span>(<span class="dv">20</span>),
<span class="kw">FOREIGN</span> <span class="kw">KEY</span> (author_last, author_first)
  <span class="kw">REFERENCES</span> Authors(last_name, first_name));</code></pre></div>

<p>would allow insertion of rows where author_last or author_first are NULL irrespective of how the table Authors is defined or what it contains. More precisely, a null in any of these fields would allow any value in the other one, even on that is not found in Authors table. For example if Authors contained only ('Doe', 'John'), then ('Smith', NULL) would satisfy the foreign key constraint. <a class="uri" href="SQL-92" title="wikilink">SQL-92</a> added two extra options for narrowing down the matches in such cases. If <code>MATCH PARTIAL</code> is added after the <code>REFERENCES</code> declaration then any non-null must match the foreign key, e. g. ('Doe', NULL) would still match, but ('Smith', NULL) would not. Finally, if <code>MATCH FULL</code> is added then ('Smith', NULL) would not match the constraint either, but (NULL, NULL) would still match it.</p>
<h2 id="outer-joins">Outer joins</h2>

<p> SQL <a href="Join_(SQL)" title="wikilink">outer joins</a>, including left outer joins, right outer joins, and full outer joins, automatically produce Nulls as placeholders for missing values in related tables. For left outer joins, for instance, Nulls are produced in place of rows missing from the table appearing on the right-hand side of the <code>LEFT OUTER JOIN</code> operator. The following simple example uses two tables to demonstrate Null placeholder production in a left outer join.</p>

<p>The first table (<strong>Employee</strong>) contains employee ID numbers and names, while the second table (<strong>PhoneNumber</strong>) contains related employee ID numbers and <a href="Telephone_number" title="wikilink">phone numbers</a>, as shown below.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
</tr>
<tr class="even">
</tr>
<tr class="odd">
</tr>
<tr class="even">
</tr>
<tr class="odd">
</tr>
<tr class="even">
</tr>
<tr class="odd">
</tr>
<tr class="even">
</tr>
</tbody>
</table></td>
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
</tr>
<tr class="even">
</tr>
<tr class="odd">
</tr>
<tr class="even">
</tr>
<tr class="odd">
</tr>
<tr class="even">
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table>

<p>The following sample SQL query performs a left outer join on these two tables.</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> e.ID, e.LastName, e.FirstName, pn.Number
<span class="kw">FROM</span> Employee e
<span class="kw">LEFT</span> <span class="kw">OUTER</span> <span class="kw">JOIN</span> PhoneNumber pn
<span class="kw">ON</span> e.ID = pn.ID;</code></pre></div>

<p>The result set generated by this query demonstrates how SQL uses Null as a placeholder for values missing from the right-hand (<strong>PhoneNumber</strong>) table, as shown below.</p>
<table>
<tbody>
<tr class="odd">
</tr>
<tr class="even">
</tr>
<tr class="odd">
</tr>
<tr class="even">
</tr>
<tr class="odd">
</tr>
<tr class="even">
</tr>
<tr class="odd">
</tr>
<tr class="even">
</tr>
</tbody>
</table>
<h2 id="aggregate-functions">Aggregate functions</h2>

<p>SQL defines <a href="aggregate_function" title="wikilink">aggregate functions</a> to simplify server-side aggregate calculations on data. Except for the <code>COUNT(*)</code> function, all aggregate functions perform a Null-elimination step, so that Null values are not included in the final result of the calculation.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p>Note that the elimination of Null values is not equivalent to replacing those values with zero. For example, in the following table, <code>AVG(i)</code> (the average of the values of <code>i</code>) will give a different result from that of <code>AVG(j)</code>:</p>
<table>
<tbody>
<tr class="odd">
</tr>
<tr class="even">
</tr>
<tr class="odd">
</tr>
<tr class="even">
</tr>
<tr class="odd">
</tr>
<tr class="even">
</tr>
<tr class="odd">
</tr>
</tbody>
</table>

<p>Here <code>AVG(i)</code> is 200 (the average of 150, 200, and 250), while <code>AVG(j)</code> is 150 (the average of 150, 200, 250, and 0). A well-known side effect of this is that in SQL <code>AVG(z)</code> is not equivalent with <code>SUM(z)/COUNT(*)</code>.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>
<h2 id="when-two-nulls-are-equal-grouping-sorting-and-some-set-operations">When two nulls are equal: grouping, sorting, and some set operations</h2>

<p>Because <a class="uri" href="SQL:2003" title="wikilink">SQL:2003</a> defines all Null markers as being unequal to one another, a special definition was required in order to group Nulls together when performing certain operations. SQL defines "any two values that are equal to one another, or any two Nulls", as "not distinct".<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> This definition of <em>not distinct</em> allows SQL to group and sort Nulls when the <code>GROUP BY</code> clause (and other keywords that perform grouping) are used.</p>

<p>Other SQL operations, clauses, and keywords use "not distinct" in their treatment of Nulls. These include the following:</p>
<ul>
<li><code>PARTITION BY</code> clause of ranking and windowing functions like <code>ROW_NUMBER</code></li>
<li><code>UNION</code>, <code>INTERSECT</code>, and <code>EXCEPT</code> operator, which treat NULLs as the same for row comparison/elimination purposes</li>
<li><code>DISTINCT</code> keyword used in <code>SELECT</code> queries</li>
</ul>

<p>The principle that Nulls aren't equal to each other (but rather that the result is Unknown) is effectively violated in the SQL specification for the <code>UNION</code> operator, which does identify nulls with each other.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> Consequently, some set operations in SQL, like union or difference, may produce results not representing sure information, unlike operations involving explicit comparisons with NULL (e.g. those in a <code>WHERE</code> clause discussed above). In Codd's 1979 proposal (which was basically adopted by SQL92) this semantic inconsistency is rationalized by arguing that removal of duplicates in set operations happens "at a lower level of detail than equality testing in the evaluation of retrieval operations."<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>

<p>The SQL standard does not explicitly define a default sort order for Nulls. Instead, on conforming systems, Nulls can be sorted before or after all data values by using the <code>NULLS FIRST</code> or <code>NULLS LAST</code> clauses of the <code>ORDER BY</code> list, respectively. Not all DBMS vendors implement this functionality, however. Vendors who do not implement this functionality may specify different treatments for Null sorting in the DBMS.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>
<h2 id="effect-on-index-operation">Effect on index operation</h2>

<p>Some SQL products do not index keys containing NULL values. For instance, <a class="uri" href="PostgreSQL" title="wikilink">PostgreSQL</a> versions prior to 8.3 did not, with the documentation for a <a class="uri" href="B-tree" title="wikilink">B-tree</a> index stating that<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> </p>

<p>In cases where the index enforces uniqueness, NULL values are excluded from the index and uniqueness is not enforced between NULL values. Again, quoting from the <a class="uri" href="PostgreSQL" title="wikilink">PostgreSQL</a> documentation:<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> </p>

<p>This is consistent with the <a class="uri" href="SQL:2003" title="wikilink">SQL:2003</a>-defined behavior of scalar Null comparisons.</p>

<p>Another method of indexing Nulls involves handling them as <em>not distinct</em> in accordance with the SQL:2003-defined behavior. For example, <a href="Microsoft_SQL_Server" title="wikilink">Microsoft SQL Server</a> documentation states the following:<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> </p>

<p>Both of these indexing strategies are consistent with the SQL:2003-defined behavior of Nulls. Because indexing methodologies are not explicitly defined by the SQL:2003 standard, indexing strategies for Nulls are left entirely to the vendors to design and implement.</p>
<h2 id="null-handling-functions">Null-handling functions</h2>

<p>SQL defines two functions to explicitly handle Nulls: <code>NULLIF</code> and <code>COALESCE</code>. Both functions are abbreviations for <a href="Case_(SQL)" title="wikilink">searched <code>CASE</code> expressions</a>.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>
<h3 id="nullif">NULLIF</h3>

<p>The <code>NULLIF</code> function accepts two parameters. If the first parameter is equal to the second parameter, <code>NULLIF</code> returns Null. Otherwise, the value of the first parameter is returned.</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">NULLIF</span>(value1, value2)</code></pre></div>

<p>Thus, <code>NULLIF</code> is an abbreviation for the following <code>CASE</code> expression:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CASE</span> <span class="kw">WHEN</span> value1 = value2 <span class="kw">THEN</span> <span class="kw">NULL</span> <span class="kw">ELSE</span> value1 <span class="kw">END</span></code></pre></div>
<h3 id="coalesce">COALESCE</h3>

<p>The <code>COALESCE</code> function accepts a list of parameters, returning the first non-Null value from the list:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">COALESCE</span>(value1, value2, value3, ...)</code></pre></div>

<p><code>COALESCE</code> is defined as shorthand for the following SQL <code>CASE</code> expression:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CASE</span> <span class="kw">WHEN</span> value1 <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">THEN</span> value1
     <span class="kw">WHEN</span> value2 <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">THEN</span> value2
     <span class="kw">WHEN</span> value3 <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">THEN</span> value3
     ...
     <span class="kw">END</span></code></pre></div>

<p>Some SQL DBMSs implement vendor-specific functions similar to <code>COALESCE</code>. Some systems (e.g. <a class="uri" href="Transact-SQL" title="wikilink">Transact-SQL</a>) implement an <code>ISNULL</code> function, or other similar functions that are functionally similar to <code>COALESCE</code>. (See <a href="Is_functions" title="wikilink"><code>Is</code> functions</a> for more on the <code>IS</code> functions in Transact-SQL.)</p>
<h3 id="nvl">NVL</h3>

<p>The Oracle <code>NVL</code> function accepts two parameters. It returns the first non-NULL parameter or NULL if all parameters are NULL.</p>

<p>A <code>COALESCE</code> expression can be converted into an equivalent <code>NVL</code> expression thus:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">COALESCE</span> ( val1, ... , val{n} )</code></pre></div>

<p>turns into:</p>
<pre class="oracle11"><code>NVL( val1 , NVL( val2 , NVL( val3 , … , NVL ( val{n-1} , val{n} ) … )))</code></pre>

<p>A use case of this function is to replace in an expression a NULL value by a fixed value like in <code>NVL(SALARY, 0)</code> which says, 'if <code>SALARY</code> contains a NULL value, replace it with 0'.</p>

<p>There is, however, one notable exception. In most implementations, <code>COALESCE</code> evaluates its parameters until it reaches the first non-NULL one, while <code>NVL</code> evaluates all of its parameters. This is important for several reasons. A parameter <em>after</em> the first non-NULL parameter could be a function, which could either be computationally expensive, invalid, or could create unexpected side effects.</p>
<h2 id="data-typing-of-null-and-unknown">Data typing of Null and Unknown</h2>

<p>The <code>NULL</code> <a href="Literal_(computer_programming)" title="wikilink">literal</a> is untyped in SQL, meaning that it is not designated as an integer, character, or any other specific <a href="data_type" title="wikilink">data type</a>.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> Because of this, it is sometimes mandatory (or desirable) to explicitly convert Nulls to a specific data type. For instance, if <a href="Function_overloading" title="wikilink">overloaded</a> functions are supported by the RDBMS, SQL might not be able to automatically resolve to the correct function without knowing the data types of all parameters, including those for which Null is passed.</p>

<p>Conversion from the <code>NULL</code> literal to a Null of a specific type is possible using the <code>CAST</code> introduced in <a class="uri" href="SQL-92" title="wikilink">SQL-92</a>. For example:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="fu">CAST</span> (<span class="kw">NULL</span> <span class="kw">AS</span> <span class="dt">INTEGER</span>)</code></pre></div>

<p>represents an integer which has the Null value.</p>

<p>The actual typing of Unknown (distinct or not from NULL itself) varies between SQL implementations. For example the following</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="st">'ok'</span> <span class="kw">WHERE</span> (<span class="kw">NULL</span> &lt;&gt; <span class="dv">1</span>) <span class="kw">IS</span> <span class="kw">NULL</span>;</code></pre></div>

<p>parses and executes successfully in some environments (e.g. <a class="uri" href="SQLite" title="wikilink">SQLite</a> or <a class="uri" href="PostgreSQL" title="wikilink">PostgreSQL</a>) which unify a NULL boolean with Unknown but fails to parse in others (e.g. in <a href="SQL_Server_Compact" title="wikilink">SQL Server Compact</a>). <a class="uri" href="MySQL" title="wikilink">MySQL</a> behaves similarly to <a class="uri" href="PostgreSQL" title="wikilink">PostgreSQL</a> in this regard (with the minor exception that <a class="uri" href="MySQL" title="wikilink">MySQL</a> regards TRUE and FALSE as no different from the ordinary integers 1 and 0). PostgreSQL additionally implements a <code>IS UNKNOWN</code> predicate, which can be used to test whether a three-value logical outcome is Unknown, although this is merely syntactic sugar.</p>
<h2 id="boolean-data-type">BOOLEAN data type</h2>

<p>The ISO <a class="uri" href="SQL:1999" title="wikilink">SQL:1999</a> standard introduced the BOOLEAN data type to SQL, however it's still just an optional, non-core feature, coded T031.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>

<p>When restricted by a <code>NOT NULL</code> constraint, the SQL BOOLEAN works like the <a href="Boolean_type" title="wikilink">Boolean type</a> from other languages. Unrestricted however, the BOOLEAN datatype, despite its name, can hold the truth values TRUE, FALSE, and UNKNOWN, all of which are defined as boolean literals according to the standard. The standard also asserts that NULL and UNKNOWN "may be used interchangeably to mean exactly the same thing".<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a><a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p>

<p>The Boolean type has been subject of criticism, particularly because of the mandated behavior of the UNKNOWN literal, which is never equal to itself because of the identification with NULL.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></p>

<p>As discussed above, in the <a class="uri" href="PostgreSQL" title="wikilink">PostgreSQL</a> implementation of <a class="uri" href="SQL" title="wikilink">SQL</a>, the null value is used to represent all UNKNOWN results, including the UNKNOWN BOOLEAN. PostgreSQL does not implement the UNKNOWN literal (although it does implement the IS UNKNOWN operator, which is an orthogonal feature.) Most other major vendors do not support the Boolean type (as defined in T031) as of 2012.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> The procedural part of Oracle's <a class="uri" href="PL/SQL" title="wikilink">PL/SQL</a> supports BOOLEAN however variables; these can also be assigned NULL and the value is considered the same as UNKNOWN.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a></p>
<h2 id="controversy">Controversy</h2>
<h3 id="common-mistakes">Common mistakes</h3>

<p>Misunderstanding of how Null works is the cause of a great number of errors in SQL code, both in ISO standard SQL statements and in the specific SQL dialects supported by real-world database management systems. These mistakes are usually the result of confusion between Null and either 0 (zero) or an empty string (a string value with a length of zero, represented in SQL as <code><nowiki>''</nowiki></code>). Null is defined by the ISO SQL standard as different from both an empty string and the numerical value <code>0</code>, however. While Null indicates the absence of any value, the empty string and numerical zero both represent actual values.</p>

<p>A classic rookie error is attempting to use the equality operator to find NULL values. Most SQL implementations will execute the following query as syntactically correct (therefore give no error message) but it never returns any rows, regardless of whether NULL values do exist in the table.</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> *
<span class="kw">FROM</span> sometable
<span class="kw">WHERE</span> num = <span class="kw">NULL</span>;  <span class="co">-- Should be "WHERE num IS NULL"</span></code></pre></div>

<p>In a related, but more subtle example, a <code>WHERE</code> clause or conditional statement might compare a column's value with a constant. It is often incorrectly assumed that a missing value would be "less than" or "not equal to" a constant if that field contains Null, but, in fact, such expressions return Unknown. An example is below:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> *
<span class="kw">FROM</span> sometable
<span class="kw">WHERE</span> num &lt;&gt; <span class="dv">1</span>;  <span class="co">-- Rows where num is NULL will not be returned, </span>
                 <span class="co">-- contrary to many users' expectations.</span></code></pre></div>

<p>Similarly, Null values are often confused with empty strings. Consider the <code>LENGTH</code> function, which returns the number of characters in a string. When a Null is passed into this function, the function returns Null. This can lead to unexpected results, if users are not well versed in 3-value logic. An example is below:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> * 
<span class="kw">FROM</span> sometable
<span class="kw">WHERE</span> <span class="fu">LENGTH</span>(string) &lt; <span class="dv">20</span>; <span class="co">-- Rows where string is NULL will not be returned.</span></code></pre></div>

<p>This is complicated by the fact that in some database interface programs (or even database implementations like Oracle's), NULL is reported as an empty string, and empty strings may be incorrectly stored as NULL.</p>
<h3 id="criticisms">Criticisms</h3>

<p>The ISO SQL implementation of Null is the subject of criticism, debate and calls for change. In <em>The Relational Model for Database Management: Version 2</em>, Codd suggested that the SQL implementation of Null was flawed and should be replaced by two distinct Null-type markers. The markers he proposed were to stand for <em>"Missing but Applicable"</em> and <em>"Missing but Inapplicable"</em>, known as <em>A-values</em> and <em>I-values</em>, respectively. Codd's recommendation, if accepted, would have required the implementation of a four-valued logic in SQL.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> Others have suggested adding additional Null-type markers to Codd's recommendation to indicate even more reasons that a data value might be "Missing", increasing the complexity of SQL's logic system. At various times, proposals have also been put forth to implement multiple user-defined Null markers in SQL. Because of the complexity of the Null-handling and logic systems required to support multiple Null markers, none of these proposals have gained widespread acceptance.</p>

<p><a href="Chris_Date" title="wikilink">Chris Date</a> and <a href="Hugh_Darwen" title="wikilink">Hugh Darwen</a>, authors of <em><a href="The_Third_Manifesto" title="wikilink">The Third Manifesto</a></em>, have suggested that the SQL Null implementation is inherently flawed and should be eliminated altogether,<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> pointing to inconsistencies and flaws in the implementation of SQL Null-handling (particularly in aggregate functions) as proof that the entire concept of Null is flawed and should be removed from the relational model.<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> Others, like author <a href="Fabian_Pascal" title="wikilink">Fabian Pascal</a>, have stated a belief that "how the function calculation should treat missing values is not governed by the relational model."</p>
<h3 id="closed-world-assumption">Closed world assumption</h3>

<p>Another point of conflict concerning Nulls is that they violate the <a href="closed_world_assumption" title="wikilink">closed world assumption</a> model of relational databases by introducing an <a href="open_world_assumption" title="wikilink">open world assumption</a> into it.<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> The closed world assumption, as it pertains to databases, states that "Everything stated by the database, either explicitly or implicitly, is true; everything else is false."<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> This view assumes that the knowledge of the world stored within a database is complete. Nulls, however, operate under the open world assumption, in which some items stored in the database are considered unknown, making the database's stored knowledge of the world incomplete.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="SQL" title="wikilink">SQL</a></li>
<li><a href="b:Structured_Query_Language/NULLs_and_the_Three_Valued_Logic" title="wikilink">NULLs in: Wikibook SQL</a></li>
<li><a href="Tutorial_D" title="wikilink">Tutorial D</a></li>
<li><a href="Ternary_logic" title="wikilink">Ternary logic</a></li>
<li><a href="Data_Manipulation_Language" title="wikilink">Data Manipulation Language</a></li>
<li><a href="Codd's_12_rules" title="wikilink">Codd's 12 rules</a></li>
<li><a href="Check_Constraint" title="wikilink">Check Constraint</a></li>
<li><a href="Relational_Model/Tasmania" title="wikilink">Relational Model/Tasmania</a></li>
<li><a href="RDBMS" title="wikilink">Relational Database Management System</a></li>
<li><a href="Join_(SQL)" title="wikilink">Join (SQL)</a></li>
<li><a href="The_Third_Manifesto" title="wikilink">The Third Manifesto</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>E. F. Codd. Understanding relations (installment #7). FDT Bulletin of ACM-SIGMOD, 7(3-4):23–28, 1975.</li>
<li>

<p>Especially §2.3.</p></li>
<li></li>
<li>Klein, Hans-Joachim. "<a href="http://www.acm.org/sigmod/record/issues/9409/sql.ps">How to modify SQL queries in order to guarantee sure answers</a>". ACM SIGMOD Record 23.3 (1994): 14-20.</li>
<li>Claude Rubinson, <a href="http://www.u.arizona.edu/~rubinson/scrawl/Rubinson.2007.Nulls_Three-Valued_Logic_and_Ambiguity_in_SQL.pdf">Nulls, Three-Valued Logic, and Ambiguity in SQL: Critiquing Date's Critique</a>, SIGMOD Record, December 2007 (Vol. 36, No. 4)</li>
<li>John Grant, <a href="http://www09.sigmod.org/sigmod/record/issues/0809/p23.grant.pdf">Null Values in SQL</a>. SIGMOD Record, September 2008 (Vol. 37, No. 3)</li>
<li>Waraporn, Narongrit, and Kriengkrai Porkaew. "<a href="http://www.iaeng.org/IJCS/issues_v35/issue_3/IJCS_35_3_08.pdf">Null semantics for subqueries and atomic predicates</a>". <a class="uri" href="IAENG" title="wikilink">IAENG</a> International Journal of Computer Science 35.3 (2008): 305-313.</li>
<li>Bernhard Thalheim, Klaus-Dieter Schewe, "NULL 'Value' Algebras and Logics" in Anneli Heimbürger, Yasushi Kiyoki, Takehiro Tokuda, Hannu Jaakkola, Naofumi Yoshida (eds.) Information Modelling and Knowledge Bases XXII, Frontiers in Artificial Intelligence and Applications, Volume 225, 2011, IOS Press, ISBN 978-1-60750-689-8, pp. 354–367 </li>
<li>Enrico Franconi and Sergio Tessaris, <a href="http://ceur-ws.org/Vol-866/paper8.pdf">On the Logic of SQL Nulls</a>, Proceedings of the 6th Alberto Mendelzon International Workshop on Foundations of Data Management, Ouro Preto, Brazil, June 27–30, 2012. pp. 114–128</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.psoug.org/reference/null.html">Oracle NULLs</a></li>
<li><a href="http://www.thethirdmanifesto.com/">The Third Manifesto</a></li>
<li><a href="http://www.sqlexpert.co.uk/2006/05/treatment-of-nulls-by-oracle-sql.html">Implications of NULLs in sequencing of data</a></li>
<li><a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4032732">Java bug report about jdbc not distinguishing null and empty string, which Sun closed as "not a bug"</a></li>
<li><a href="http://www.theintegrationengineer.com/the-nature-of-null/">TheIntegrationEngineer</a> explains how NULL works and the logic behind it.</li>
</ul>

<p>"</p>

<p><a href="Category:SQL_keywords" title="wikilink">Category:SQL keywords</a> <a href="Category:Articles_with_example_SQL_code" title="wikilink">Category:Articles with example SQL code</a> <a href="Category:Unknown_content" title="wikilink">Category:Unknown content</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">Ron van der Meyden, "[<a class="uri" href="http://books.google.com/books?id=gF0b85IuqQwC&amp;pg">http://books.google.com/books?id=gF0b85IuqQwC&amp;pg;</a>;=PA344 Logical approaches to incomplete information: a survey]" in Chomicki, Jan; Saake, Gunter (Eds.) <em>Logics for Databases and Information Systems</em>, Kluwer Academic Publishers ISBN 978-0-7923-8129-7, p. 344; <a href="http://www.cse.unsw.edu.au/~meyden/research/indef-review.ps">PS preprint</a> (note: page numbering differs in preprint from the published version)<a href="#fnref6">↩</a></li>
<li id="fn7">.<a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15">C.J. Date (2004), <em>An introduction to database systems</em>, 8th ed., Pearson Education, p. 594<a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17">C. J. Date, <em>Relational database writings, 1991-1994</em>, Addison-Wesley, 1995, p. 371<a href="#fnref17">↩</a></li>
<li id="fn18">C.J. Date (2004), <em>An introduction to database systems</em>, 8th ed., Pearson Education, p. 584<a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"></li>
<li id="fn26"></li>
<li id="fn27"></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"><a href="#fnref33">↩</a></li>
<li id="fn34"><a href="#fnref34">↩</a></li>
<li id="fn35">ISO/IEC 9075-2:2011 §4.5<a href="#fnref35">↩</a></li>
<li id="fn36"><a href="#fnref36">↩</a></li>
<li id="fn37">Troels Arvin, <a href="http://troels.arvin.dk/db/rdbms/#data_types-boolean">Survey of BOOLEAN data type implementation</a><a href="#fnref37">↩</a></li>
<li id="fn38"><a href="#fnref38">↩</a></li>
<li id="fn39"><a href="#fnref39">↩</a></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42"><a href="#fnref42">↩</a></li>
<li id="fn43"><a href="#fnref43">↩</a></li>
</ol>
</section>
</body>

