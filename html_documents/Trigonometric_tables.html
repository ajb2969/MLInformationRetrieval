<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="408">Trigonometric tables</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Trigonometric tables</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, tables of <a href="trigonometric_function" title="wikilink">trigonometric functions</a> are useful in a number of areas. Before the existence of <a href="pocket_calculator" title="wikilink">pocket calculators</a>, <strong>trigonometric tables</strong> were essential for <a class="uri" href="navigation" title="wikilink">navigation</a>, <a class="uri" href="science" title="wikilink">science</a> and <a class="uri" href="engineering" title="wikilink">engineering</a>. The calculation of <a href="mathematical_table" title="wikilink">mathematical tables</a> was an important area of study, which led to the development of the <a href="history_of_computing" title="wikilink">first mechanical computing devices</a>.</p>

<p>Modern computers and pocket calculators now generate trigonometric function values on demand, using special libraries of mathematical code. Often, these libraries use pre-calculated tables internally, and compute the required value by using an appropriate interpolation method. Interpolation of simple look-up tables of trigonometric functions is still used in <a href="computer_graphics" title="wikilink">computer graphics</a>, where only modest accuracy may be required and speed is often paramount.</p>

<p>Another important application of trigonometric tables and generation schemes is for <a href="fast_Fourier_transform" title="wikilink">fast Fourier transform</a> (FFT) algorithms, where the same trigonometric function values (called <em>twiddle factors</em>) must be evaluated many times in a given transform, especially in the common case where many transforms of the same size are computed. In this case, calling generic library routines every time is unacceptably slow. One option is to call the library routines once, to build up a table of those trigonometric values that will be needed, but this requires significant memory to store the table. The other possibility, since a regular sequence of values is required, is to use a recurrence formula to compute the trigonometric values on the fly. Significant research has been devoted to finding accurate, stable recurrence schemes in order to preserve the accuracy of the FFT (which is very sensitive to trigonometric errors).</p>
<h2 id="on-demand-computation">On-demand computation</h2>
<figure><b>(Figure)</b>
<figcaption>A page from a 1619 book of <a href="mathematical_table" title="wikilink">mathematical tables</a>.</figcaption>
</figure>

<p>Modern computers and calculators use a variety of techniques to provide trigonometric function values on demand for arbitrary angles (Kantabutra, 1996). One common method, especially on higher-end processors with <a href="Floating_point" title="wikilink">floating-point</a> units, is to combine a <a class="uri" href="polynomial" title="wikilink">polynomial</a> or <a href="rational_function" title="wikilink">rational</a> <a href="approximation_theory" title="wikilink">approximation</a> (such as <a href="Chebyshev_approximation" title="wikilink">Chebyshev approximation</a>, best uniform approximation, and <a href="Padé_approximant" title="wikilink">Padé approximation</a>, and typically for higher or variable precisions, <a href="Taylor_series" title="wikilink">Taylor</a> and <a href="Laurent_series" title="wikilink">Laurent series</a>) with range reduction and a table lookup — they first look up the closest angle in a small table, and then use the polynomial to compute the correction. Maintaining precision while performing such interpolation is nontrivial, however; and methods like <a href="Gal's_accurate_tables" title="wikilink">Gal's accurate tables</a>, Cody and Waite reduction, and Payne and Hanek reduction algorithms can be used for this purpose. On simpler devices that lack a <a href="multiplication_ALU" title="wikilink">hardware multiplier</a>, there is an algorithm called <a class="uri" href="CORDIC" title="wikilink">CORDIC</a> (as well as related techniques) that is more efficient, since it uses only <a href="shift_operator" title="wikilink">shifts</a> and additions. All of these methods are commonly implemented in <a href="computer_hardware" title="wikilink">hardware</a> for performance reasons.</p>

<p>For <a href="arbitrary-precision_arithmetic" title="wikilink">very high precision</a> calculations, when series-expansion convergence becomes too slow, trigonometric functions can be approximated by the <a href="arithmetic-geometric_mean" title="wikilink">arithmetic-geometric mean</a>, which itself approximates the trigonometric function by the (<a href="complex_number" title="wikilink">complex</a>) <a href="elliptic_integral" title="wikilink">elliptic integral</a> (Brent, 1976).</p>

<p>Trigonometric functions of angles that are <a href="rational_number" title="wikilink">rational</a> multiples of 2π are <a href="algebraic_number" title="wikilink">algebraic numbers</a>, related to <a href="roots_of_unity" title="wikilink">roots of unity</a>, and can be computed with a <a class="uri" href="polynomial" title="wikilink">polynomial</a> <a href="root-finding_algorithm" title="wikilink">root-finding algorithm</a> in the <a href="complex_plane" title="wikilink">complex plane</a>. For example, the cosine and sine of 2π ⋅ 5/37 are the <a href="real_part" title="wikilink">real</a> and <a href="imaginary_part" title="wikilink">imaginary parts</a>, respectively, of a 37th root of unity, corresponding to a root of a <a href="degree_of_a_polynomial" title="wikilink">degree</a>-37 polynomial <em>x</em><sup>37</sup> − 1. Root-finding algorithms such as <a href="Newton's_method" title="wikilink">Newton's method</a> are much simpler than the arithmetic-geometric mean algorithms above while converging at a similar asymptotic rate; the latter algorithms are required for <a href="transcendental_number" title="wikilink">transcendental</a> trigonometric constants, however.</p>
<h2 id="half-angle-and-angle-addition-formulas">Half-angle and angle-addition formulas</h2>

<p>Historically, the earliest method by which trigonometric tables were computed, and probably the most common until the advent of computers, was to repeatedly apply the half-angle and angle-addition <a href="Trigonometric_identity" title="wikilink">trigonometric identities</a> starting from a known value (such as sin(π/2) = 1, cos(π/2) = 0). This method was used by the ancient astronomer <a class="uri" href="Ptolemy" title="wikilink">Ptolemy</a>, who derived them in the <em><a class="uri" href="Almagest" title="wikilink">Almagest</a></em>, a treatise on astronomy. In modern form, the identities he derived are stated as follows (with signs determined by the quadrant in which <em>x</em> lies;</p>

<p>

<math display="block" id="Trigonometric_tables:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>cos</mi>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mi>x</mi>
      <mn>2</mn>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>±</mo>
    <msqrt>
     <mrow>
      <mstyle displaystyle="false">
       <mfrac>
        <mn>1</mn>
        <mn>2</mn>
       </mfrac>
      </mstyle>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mrow>
         <mi>cos</mi>
         <mi>x</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <cos></cos>
     <apply>
      <divide></divide>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">plus-or-minus</csymbol>
     <apply>
      <root></root>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <cos></cos>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cos\left(\frac{x}{2}\right)=\pm\sqrt{\tfrac{1}{2}(1+\cos x)}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Trigonometric_tables:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>sin</mi>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mi>x</mi>
      <mn>2</mn>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>±</mo>
    <msqrt>
     <mrow>
      <mstyle displaystyle="false">
       <mfrac>
        <mn>1</mn>
        <mn>2</mn>
       </mfrac>
      </mstyle>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mrow>
         <mi>cos</mi>
         <mi>x</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <sin></sin>
     <apply>
      <divide></divide>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">plus-or-minus</csymbol>
     <apply>
      <root></root>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <cos></cos>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sin\left(\frac{x}{2}\right)=\pm\sqrt{\tfrac{1}{2}(1-\cos x)}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Trigonometric_tables:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>sin</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>±</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>sin</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>cos</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>±</mo>
    <mrow>
     <mrow>
      <mi>cos</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>sin</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <sin></sin>
     <apply>
      <csymbol cd="latexml">plus-or-minus</csymbol>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">plus-or-minus</csymbol>
     <apply>
      <times></times>
      <apply>
       <sin></sin>
       <ci>x</ci>
      </apply>
      <apply>
       <cos></cos>
       <ci>y</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <cos></cos>
       <ci>x</ci>
      </apply>
      <apply>
       <sin></sin>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sin(x\pm y)=\sin(x)\cos(y)\pm\cos(x)\sin(y)\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Trigonometric_tables:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>cos</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>±</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>cos</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>cos</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>∓</mo>
    <mrow>
     <mrow>
      <mi>sin</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>sin</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <cos></cos>
     <apply>
      <csymbol cd="latexml">plus-or-minus</csymbol>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">minus-or-plus</csymbol>
     <apply>
      <times></times>
      <apply>
       <cos></cos>
       <ci>x</ci>
      </apply>
      <apply>
       <cos></cos>
       <ci>y</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <sin></sin>
       <ci>x</ci>
      </apply>
      <apply>
       <sin></sin>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cos(x\pm y)=\cos(x)\cos(y)\mp\sin(x)\sin(y)\,
  </annotation>
 </semantics>
</math>

</p>

<p>These were used to construct <a href="Ptolemy's_table_of_chords" title="wikilink">Ptolemy's table of chords</a>, which was applied to astronomical problems.</p>

<p>Various other permutations on these identities are possible: for example, some early trigonometric tables used not sine and cosine, but sine and <a class="uri" href="versine" title="wikilink">versine</a>).</p>
<h2 id="a-quick-but-inaccurate-approximation">A quick, but inaccurate, approximation</h2>

<p>A quick, but inaccurate, algorithm for calculating a table of <em>N</em> approximations <em>s</em><sub><em>n</em></sub> for <a href="sine" title="wikilink">sin</a>(2<a href="Pi" title="wikilink">π</a><em>n</em>/<em>N</em>) and <em>c</em><sub><em>n</em></sub> for <a href="cosine" title="wikilink">cos</a>(2π<em>n</em>/<em>N</em>) is:</p>
<dl>
<dd><em>s</em><sub>0</sub> = 0
</dd>
<dd><em>c</em><sub>0</sub> = 1
</dd>
<dd><em>s</em><sub><em>n</em>+1</sub> = <em>s</em><sub><em>n</em></sub> + <em>d</em> × <em>c</em><sub><em>n</em></sub>
</dd>
<dd><em>c</em><sub><em>n</em>+1</sub> = <em>c</em><sub><em>n</em></sub> − <em>d</em> × <em>s</em><sub><em>n</em></sub>
</dd>
</dl>

<p>for <em>n</em> = 0,...,<em>N</em> − 1, where <em>d</em> = 2π/<em>N</em>.</p>

<p>This is simply the <a href="Numerical_ordinary_differential_equations#Euler_method" title="wikilink">Euler method</a> for integrating the <a href="differential_equation" title="wikilink">differential equation</a>:</p>

<p>

<math display="block" id="Trigonometric_tables:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>d</mi>
      <mi>s</mi>
     </mrow>
     <mo>/</mo>
     <mi>d</mi>
    </mrow>
    <mi>t</mi>
   </mrow>
   <mo>=</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>s</ci>
      </apply>
      <ci>d</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ds/dt=c
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Trigonometric_tables:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>d</mi>
      <mi>c</mi>
     </mrow>
     <mo>/</mo>
     <mi>d</mi>
    </mrow>
    <mi>t</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mi>s</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>c</ci>
      </apply>
      <ci>d</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   dc/dt=-s
  </annotation>
 </semantics>
</math>

</p>

<p>with initial conditions <em>s</em>(0) = 0 and <em>c</em>(0) = 1, whose analytical solution is <em>s</em> = sin(<em>t</em>) and <em>c</em> = cos(<em>t</em>).</p>

<p>Unfortunately, this is not a useful algorithm for generating sine tables because it has a significant error, proportional to 1/<em>N</em>.</p>

<p>For example, for <em>N</em> = 256 the maximum error in the sine values is ~0.061 (<em>s</em><sub>202</sub> = −1.0368 instead of −0.9757). For <em>N</em> = 1024, the maximum error in the sine values is ~0.015 (<em>s</em><sub>803</sub> = −0.99321 instead of −0.97832), about 4 times smaller. If the sine and cosine values obtained were to be plotted, this algorithm would draw a logarithmic spiral rather than a circle.</p>
<h2 id="a-better-but-still-imperfect-recurrence-formula">A better, but still imperfect, recurrence formula</h2>

<p>A simple recurrence formula to generate trigonometric tables is based on <a href="Euler's_formula" title="wikilink">Euler's formula</a> and the relation:</p>

<p>

<math display="block" id="Trigonometric_tables:6">
 <semantics>
  <mrow>
   <msup>
    <mi>e</mi>
    <mrow>
     <mi>i</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>θ</mi>
       <mo>+</mo>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>e</mi>
     <mrow>
      <mi>i</mi>
      <mi>θ</mi>
     </mrow>
    </msup>
    <mo>×</mo>
    <msup>
     <mi>e</mi>
     <mrow>
      <mi>i</mi>
      <mi mathvariant="normal">Δ</mi>
      <mi>θ</mi>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <apply>
       <plus></plus>
       <ci>θ</ci>
       <ci>normal-Δ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>θ</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>normal-Δ</ci>
       <ci>θ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{i(\theta+\Delta)}=e^{i\theta}\times e^{i\Delta\theta}
  </annotation>
 </semantics>
</math>

</p>

<p>This leads to the following recurrence to compute trigonometric values <em>s</em><sub><em>n</em></sub> and <em>c</em><sub><em>n</em></sub> as above:</p>
<dl>
<dd><em>c</em><sub>0</sub> = 1
</dd>
<dd><em>s</em><sub>0</sub> = 0
</dd>
<dd><em>c</em><sub><em>n</em>+1</sub> = <em>w</em><sub><em>r</em></sub> <em>c</em><sub><em>n</em></sub> − <em>w</em><sub><em>i</em></sub> <em>s</em><sub><em>n</em></sub>
</dd>
<dd><em>s</em><sub><em>n</em>+1</sub> = <em>w</em><sub><em>i</em></sub> <em>c</em><sub><em>n</em></sub> + <em>w</em><sub><em>r</em></sub> <em>s</em><sub><em>n</em></sub>
</dd>
</dl>

<p>for <em>n</em> = 0, ..., <em>N</em> − 1, where <em>w</em><sub><em>r</em></sub> = cos(2π/<em>N</em>) and <em>w</em><sub><em>i</em></sub> = sin(2π/<em>N</em>). These two starting trigonometric values are usually computed using existing library functions (but could also be found e.g. by employing <a href="Newton's_method" title="wikilink">Newton's method</a> in the complex plane to solve for the primitive <a href="root_of_unity" title="wikilink">root</a> of <em>z</em><sup><em>N</em></sup> − 1).</p>

<p>This method would produce an <em>exact</em> table in exact arithmetic, but has errors in finite-precision <a class="uri" href="floating-point" title="wikilink">floating-point</a> arithmetic. In fact, the errors grow as O(ε <em>N</em>) (in both the worst and average cases), where ε is the floating-point precision.</p>

<p>A significant improvement is to use the following modification to the above, a trick (due to Singleton, 1967) often used to generate trigonometric values for FFT implementations:</p>
<dl>
<dd><em>c</em><sub>0</sub> = 1
</dd>
<dd><em>s</em><sub>0</sub> = 0
</dd>
<dd><em>c</em><sub><em>n</em>+1</sub> = <em>c</em><sub><em>n</em></sub> − (α<em>c</em><sub><em>n</em></sub> + β <em>s</em><sub><em>n</em></sub>)
</dd>
<dd><em>s</em><sub><em>n</em>+1</sub> = <em>s</em><sub><em>n</em></sub> + (β <em>c</em><sub><em>n</em></sub> − α <em>s</em><sub><em>n</em></sub>)
</dd>
</dl>

<p>where α = 2 sin<sup>2</sup>(π/<em>N</em>) and β = sin(2π/<em>N</em>). The errors of this method are much smaller, O(ε √<em>N</em>) on average and O(ε <em>N</em>) in the worst case, but this is still large enough to substantially degrade the accuracy of FFTs of large sizes.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Numerical_analysis" title="wikilink">Numerical analysis</a></li>
<li><a class="uri" href="CORDIC" title="wikilink">CORDIC</a></li>
<li><a href="Exact_trigonometric_constants" title="wikilink">Exact trigonometric constants</a></li>
<li><a href="Aryabhata's_sine_table" title="wikilink">Aryabhata's sine table</a></li>
<li><a href="Madhava's_sine_table" title="wikilink">Madhava's sine table</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Carl B. Boyer, <em>A History of Mathematics</em>, 2nd ed. (Wiley, New York, 1991).</li>
<li>Manfred Tasche and Hansmartin Zeuner, "Improved roundoff error analysis for precomputed twiddle factors," <em>J. Computational Analysis and Applications</em> <strong>4</strong> (1), 1–18 (2002).</li>
<li>James C. Schatzman, "Accuracy of the discrete Fourier transform and the fast Fourier transform," <em>SIAM J. Sci. Comput.</em> <strong>17</strong> (5), 1150–1166 (1996).</li>
<li>Vitit Kantabutra, "On hardware for computing exponential and trigonometric functions," <em>IEEE Trans. Computers</em> <strong>45</strong> (3), 328–339 (1996).</li>
<li>R. P. Brent, "<a href="http://doi.acm.org/10.1145/321941.321944">Fast Multiple-Precision Evaluation of Elementary Functions</a>", <em>J. ACM</em> <strong>23</strong>, 242–251 (1976).</li>
<li>Singleton, Richard C. (1967). On computing the fast Fourier transform. <em>Comm. ACM</em>, vol. 10, 647–654.</li>
<li>Gal, Shmuel and Bachelis, Boris. An accurate elementary mathematical library for the IEEE floating point standard, ACM Transaction on Mathematical Software (1991).</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Trigonometry" title="wikilink">Category:Trigonometry</a> <a href="Category:Numerical_analysis" title="wikilink">Category:Numerical analysis</a></p>
</body>
</html>
