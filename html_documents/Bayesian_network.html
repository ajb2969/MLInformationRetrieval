<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="970">Bayesian network</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Bayesian network</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>A simple Bayesian network. Rain influences whether the sprinkler is activated, and both rain and the sprinkler influence whether the grass is wet.</figcaption>
</figure>

<p>A <strong>Bayesian network</strong>, <strong>Bayes network</strong>, <strong>belief network</strong>, <strong>Bayes(ian) model</strong> or <strong>probabilistic directed acyclic graphical model</strong> is a <a href="Graphical_model" title="wikilink">probabilistic graphical model</a> (a type of <a href="statistical_model" title="wikilink">statistical model</a>) that represents a set of <a href="random_variables" title="wikilink">random variables</a> and their <a href="conditional_independence" title="wikilink">conditional dependencies</a> via a <a href="directed_acyclic_graph" title="wikilink">directed acyclic graph</a> (DAG). For example, a Bayesian network could represent the probabilistic relationships between diseases and symptoms. Given symptoms, the network can be used to compute the probabilities of the presence of various diseases.</p>

<p>Formally, Bayesian networks are DAGs whose nodes represent random variables in the <a href="Bayesian_probability" title="wikilink">Bayesian</a> sense: they may be observable quantities, <a href="latent_variable" title="wikilink">latent variables</a>, unknown parameters or hypotheses. Edges represent conditional dependencies; nodes that are not connected represent variables that are <a href="conditional_independence" title="wikilink">conditionally independent</a> of each other. Each node is associated with a <a href="probability_function" title="wikilink">probability function</a> that takes, as input, a particular set of values for the node's <a href="Glossary_of_graph_theory#Directed_acyclic_graphs" title="wikilink">parent</a> variables, and gives (as output) the probability (or probability distribution, if applicable) of the variable represented by the node. For example, if 

<math display="inline" id="Bayesian_network:0">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 parent nodes represent 

<math display="inline" id="Bayesian_network:1">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 <a href="Boolean_data_type" title="wikilink">Boolean variables</a> then the probability function could be represented by a table of <small>

<math display="inline" id="Bayesian_network:2">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>m</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{m}
  </annotation>
 </semantics>
</math>

</small> entries, one entry for each of the <small>

<math display="inline" id="Bayesian_network:3">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>m</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{m}
  </annotation>
 </semantics>
</math>


</small> possible combinations of its parents being true or false. Similar ideas may be applied to undirected, and possibly cyclic, graphs; such are called <a href="Markov_network" title="wikilink">Markov networks</a>.</p>

<p>Efficient algorithms exist that perform <a class="uri" href="inference" title="wikilink">inference</a> and <a href="machine_learning" title="wikilink">learning</a> in Bayesian networks. Bayesian networks that model sequences of variables (<em>e.g.</em> <a href="speech_recognition" title="wikilink">speech signals</a> or <a href="peptide_sequence" title="wikilink">protein sequences</a>) are called <a href="dynamic_Bayesian_network" title="wikilink">dynamic Bayesian networks</a>. Generalizations of Bayesian networks that can represent and solve decision problems under uncertainty are called <a href="influence_diagram" title="wikilink">influence diagrams</a>.</p>
<h2 id="example">Example</h2>
<figure><b>(Figure)</b>
<figcaption>A simple Bayesian network with <a href="conditional_probability_table" title="wikilink">conditional probability tables</a> </figcaption>
</figure>

<p>Suppose that there are two events which could cause grass to be wet: either the sprinkler is on or it's raining. Also, suppose that the rain has a direct effect on the use of the sprinkler (namely that when it rains, the sprinkler is usually not turned on). Then the situation can be modeled with a Bayesian network (shown). All three variables have two possible values, T (for true) and F (for false).</p>

<p>The <a href="Joint_probability_distribution" title="wikilink">joint probability function</a> is:</p>

<p>

<math display="block" id="Bayesian_network:4">
 <semantics>
  <mrow>
   <mi mathvariant="normal">P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo>,</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo>∣</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal">P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>∣</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal">P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">G</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">G</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{P}(G,S,R)=\mathrm{P}(G\mid S,R)\mathrm{P}(S\mid R)\mathrm{P}(R)
  </annotation>
 </semantics>
</math>

</p>

<p>where the names of the variables have been abbreviated to <em>G = Grass wet (yes/no)</em>, <em>S = Sprinkler turned on (yes/no)</em>, and <em>R = Raining (yes/no)</em>.</p>

<p>The model can answer questions like "What is the probability that it is raining, given the grass is wet?" by using the <a href="conditional_probability" title="wikilink">conditional probability</a> formula and summing over all <a href="nuisance_variable" title="wikilink">nuisance variables</a>:</p>

<p>

<math display="block" id="Bayesian_network:5">
 <semantics>
  <mrow>
   <mi mathvariant="normal">P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo>=</mo>
    <mi>T</mi>
    <mo>∣</mo>
    <mi>G</mi>
    <mo>=</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi mathvariant="normal">P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>G</mi>
      <mo>=</mo>
      <mi>T</mi>
      <mo>,</mo>
      <mi>R</mi>
      <mo>=</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi mathvariant="normal">P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>G</mi>
      <mo>=</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>S</mi>
       <mo>∈</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mi>T</mi>
        <mo>,</mo>
        <mi>F</mi>
        <mo stretchy="false">}</mo>
       </mrow>
      </mrow>
     </msub>
     <mi mathvariant="normal">P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>G</mi>
      <mo>=</mo>
      <mi>T</mi>
      <mo>,</mo>
      <mi>S</mi>
      <mo>,</mo>
      <mi>R</mi>
      <mo>=</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mrow>
        <mi>S</mi>
        <mo>,</mo>
        <mi>R</mi>
       </mrow>
       <mo>∈</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mi>T</mi>
        <mo>,</mo>
        <mi>F</mi>
        <mo stretchy="false">}</mo>
       </mrow>
      </mrow>
     </msub>
     <mi mathvariant="normal">P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>G</mi>
      <mo>=</mo>
      <mi>T</mi>
      <mo>,</mo>
      <mi>S</mi>
      <mo>,</mo>
      <mi>R</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">R</csymbol>
     <eq></eq>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">G</csymbol>
     <eq></eq>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">G</csymbol>
       <eq></eq>
       <csymbol cd="unknown">T</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">R</csymbol>
       <eq></eq>
       <csymbol cd="unknown">T</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">G</csymbol>
       <eq></eq>
       <csymbol cd="unknown">T</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>S</ci>
        <set>
         <ci>T</ci>
         <ci>F</ci>
        </set>
       </apply>
      </apply>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">G</csymbol>
       <eq></eq>
       <csymbol cd="unknown">T</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">S</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">R</csymbol>
       <eq></eq>
       <csymbol cd="unknown">T</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <list>
         <ci>S</ci>
         <ci>R</ci>
        </list>
        <set>
         <ci>T</ci>
         <ci>F</ci>
        </set>
       </apply>
      </apply>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">G</csymbol>
       <eq></eq>
       <csymbol cd="unknown">T</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">S</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">R</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{P}(\mathit{R}=T\mid\mathit{G}=T)\par
=\frac{\mathrm{P}(\mathit{G}=T,%
\mathit{R}=T)}{\mathrm{P}(\mathit{G}=T)}\par
=\frac{\sum_{\mathit{S}\in\{T,F\}%
}\mathrm{P}(\mathit{G}=T,\mathit{S},\mathit{R}=T)}{\sum_{\mathit{S},\mathit{R}%
\in\{T,F\}}\mathrm{P}(\mathit{G}=T,\mathit{S},\mathit{R})}
  </annotation>
 </semantics>
</math>

</p>

<p>Using the expansion for the joint probability function 

<math display="inline" id="Bayesian_network:6">
 <semantics>
  <mrow>
   <mi mathvariant="normal">P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo>,</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-P</ci>
    <vector>
     <ci>G</ci>
     <ci>S</ci>
     <ci>R</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{P}(G,S,R)
  </annotation>
 </semantics>
</math>

 and the conditional probabilities from the <a href="Conditional_probability_table" title="wikilink">conditional probability tables (CPTs)</a> stated in the diagram, one can evaluate each term in the sums in the numerator and denominator. For example,</p>

<p>

<math display="inline" id="Bayesian_network:7">
 <semantics>
  <mrow>
   <mi mathvariant="normal">P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo>=</mo>
    <mi>T</mi>
    <mo>,</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">G</csymbol>
     <eq></eq>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-,</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\mathrm{P}(G=T,
  </annotation>
 </semantics>
</math>


</p>

<p>Then the numerical results (subscripted by the associated variable values) are</p>

<p>

<math display="inline" id="Bayesian_network:8">
 <semantics>
  <mrow>
   <mi mathvariant="normal">P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo>=</mo>
    <mi>T</mi>
    <mo>∣</mo>
    <mi>G</mi>
    <mo>=</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">R</csymbol>
     <eq></eq>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">G</csymbol>
     <eq></eq>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\mathrm{P}(R=T\mid G=T)
  </annotation>
 </semantics>
</math>


</p>

<p>If, on the other hand, we wish to answer an interventional question: "What is the probability that it would rain, given that we wet the grass?" the answer would be governed by the post-intervention joint distribution function 

<math display="inline" id="Bayesian_network:9">
 <semantics>
  <mrow>
   <mi mathvariant="normal">P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo>∣</mo>
    <mtext>do</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo>=</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>∣</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-∣</ci>
     <mtext>do</mtext>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">G</csymbol>
      <eq></eq>
      <csymbol cd="unknown">T</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{P}(S,R\mid\text{do}(G=T))=P(S\mid R)P(R)
  </annotation>
 </semantics>
</math>

 obtained by removing the factor 

<math display="inline" id="Bayesian_network:10">
 <semantics>
  <mrow>
   <mi mathvariant="normal">P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo>∣</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">G</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{P}(G\mid S,R)
  </annotation>
 </semantics>
</math>

 from the pre-intervention distribution. As expected, the probability of rain is unaffected by the action

<math display="block" id="Bayesian_network:11">
 <semantics>
  <mrow>
   <mi mathvariant="normal">P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo>∣</mo>
    <mtext>do</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo>=</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-∣</ci>
     <mtext>do</mtext>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">G</csymbol>
      <eq></eq>
      <csymbol cd="unknown">T</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{P}(R\mid\text{do}(G=T))=P(R)
  </annotation>
 </semantics>
</math>

.</p>

<p>If, moreover, we wish to predict the impact of turning the sprinkler on, we have</p>

<p>

<math display="block" id="Bayesian_network:12">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo>,</mo>
    <mi>G</mi>
    <mo>∣</mo>
    <mtext>do</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo>=</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo>∣</mo>
    <mi>R</mi>
    <mo>,</mo>
    <mi>S</mi>
    <mo>=</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">G</csymbol>
     <ci>normal-∣</ci>
     <mtext>do</mtext>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">S</csymbol>
      <eq></eq>
      <csymbol cd="unknown">T</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">G</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">S</csymbol>
     <eq></eq>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(R,G\mid\text{do}(S=T))=P(R)P(G\mid R,S=T)
  </annotation>
 </semantics>
</math>

 with the term 

<math display="inline" id="Bayesian_network:13">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>=</mo>
    <mi>T</mi>
    <mo>∣</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <eq></eq>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(S=T\mid R)
  </annotation>
 </semantics>
</math>


 removed, showing that the action has an effect on the grass but not on the rain.</p>

<p>These predictions may not be feasible when some of the variables are unobserved, as in most policy evaluation problems. The effect of the action 

<math display="inline" id="Bayesian_network:14">
 <semantics>
  <mrow>
   <mtext>do</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>do</mtext>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{do}(x)
  </annotation>
 </semantics>
</math>

 can still be predicted, however, whenever a criterion called "back-door" is satisfied.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> It states that, if a set <em>Z</em> of nodes can be observed that <em>d</em>-separates<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> (or blocks) all back-door paths from <em>X</em> to <em>Y</em> then 

<math display="inline" id="Bayesian_network:15">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>Z</mi>
    <mo>∣</mo>
    <mtext>do</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo>,</mo>
    <mi>Z</mi>
    <mo>,</mo>
    <mi>X</mi>
    <mo>=</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>=</mo>
    <mi>x</mi>
    <mo>∣</mo>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">Z</csymbol>
     <ci>normal-∣</ci>
     <mtext>do</mtext>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">Z</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">X</csymbol>
     <eq></eq>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <divide></divide>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">X</csymbol>
     <eq></eq>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">Z</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(Y,Z\mid\text{do}(x))=P(Y,Z,X=x)/P(X=x\mid Z)
  </annotation>
 </semantics>
</math>

. A back-door path is one that ends with an arrow into <em>X</em>. Sets that satisfy the back-door criterion are called "sufficient" or "admissible." For example, the set <em>Z</em> = <em>R</em> is admissible for predicting the effect of <em>S</em> = <em>T</em> on <em>G</em>, because <em>R</em> <em>d</em>-separate the (only) back-door path <em>S</em> ← <em>R</em> → <em>G</em>. However, if <em>S</em> is not observed, there is no other set that <em>d</em>-separates this path and the effect of turning the sprinkler on (<em>S</em> = <em>T</em>) on the grass (<em>G</em>) cannot be predicted from passive observations. We then say that <em>P</em>(<em>G</em> | do(<em>S</em> = <em>T</em>)) is not "identified." This reflects the fact that, lacking interventional data, we cannot determine if the observed dependence between <em>S</em> and <em>G</em> is due to a causal connection or is spurious (apparent dependence arising from a common cause, <em>R</em>). (see <a href="Simpson's_paradox" title="wikilink">Simpson's paradox</a>)</p>

<p>To determine whether a causal relation is identified from an arbitrary Bayesian network with unobserved variables, one can use the three rules of "<em>do</em>-calculus"<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> and test whether all <em>do</em> terms can be removed from the expression of that relation, thus confirming that the desired quantity is estimable from frequency data.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Using a Bayesian network can save considerable amounts of memory, if the dependencies in the joint distribution are sparse. For example, a naive way of storing the conditional probabilities of 10 two-valued variables as a table requires storage space for 

<math display="inline" id="Bayesian_network:16">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mn>10</mn>
   </msup>
   <mo>=</mo>
   <mn>1024</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <cn type="integer">10</cn>
    </apply>
    <cn type="integer">1024</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{10}=1024
  </annotation>
 </semantics>
</math>

 values. If the local distributions of no variable depends on more than three parent variables, the Bayesian network representation only needs to store at most 

<math display="inline" id="Bayesian_network:17">
 <semantics>
  <mrow>
   <mrow>
    <mn>10</mn>
    <mo>⋅</mo>
    <msup>
     <mn>2</mn>
     <mn>3</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mn>80</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <cn type="integer">10</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <cn type="integer">80</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   10\cdot 2^{3}=80
  </annotation>
 </semantics>
</math>

 values.</p>

<p>One advantage of Bayesian networks is that it is intuitively easier for a human to understand (a sparse set of) direct dependencies and local distributions than complete joint distributions.</p>
<h2 id="inference-and-learning">Inference and learning</h2>

<p>There are three main inference tasks for Bayesian networks.</p>
<h3 id="inferring-unobserved-variables">Inferring unobserved variables</h3>

<p>Because a Bayesian network is a complete model for the variables and their relationships, it can be used to answer probabilistic queries about them. For example, the network can be used to find out updated knowledge of the state of a subset of variables when other variables (the <em>evidence</em> variables) are observed. This process of computing the <em>posterior</em> distribution of variables given evidence is called probabilistic inference. The posterior gives a universal <a href="sufficient_statistic" title="wikilink">sufficient statistic</a> for detection applications, when one wants to choose values for the variable subset which minimize some expected loss function, for instance the probability of decision error. A Bayesian network can thus be considered a mechanism for automatically applying <a href="Bayes'_theorem" title="wikilink">Bayes' theorem</a> to complex problems.</p>

<p>The most common exact inference methods are: <a href="variable_elimination" title="wikilink">variable elimination</a>, which eliminates (by integration or summation) the non-observed non-query variables one by one by distributing the sum over the product; <a href="clique_tree_propagation" title="wikilink">clique tree propagation</a>, which caches the computation so that many variables can be queried at one time and new evidence can be propagated quickly; and <a href="recursive_conditioning" title="wikilink">recursive conditioning</a> and <a href="AND/OR_search" title="wikilink">AND/OR search</a>, which allow for a <a href="space-time_tradeoff" title="wikilink">space-time tradeoff</a> and match the efficiency of variable elimination when enough space is used. All of these methods have complexity that is exponential in the network's <a class="uri" href="treewidth" title="wikilink">treewidth</a>. The most common <a href="approximate_inference" title="wikilink">approximate inference</a> algorithms are <a href="importance_sampling" title="wikilink">importance sampling</a>, stochastic <a href="Markov_chain_Monte_Carlo" title="wikilink">MCMC</a> simulation, <a href="mini-bucket_elimination" title="wikilink">mini-bucket elimination</a>, <a href="loopy_belief_propagation" title="wikilink">loopy belief propagation</a>, <a href="generalized_belief_propagation" title="wikilink">generalized belief propagation</a>, and <a href="variational_Bayes" title="wikilink">variational methods</a>.</p>
<h3 id="parameter-learning">Parameter learning</h3>

<p>In order to fully specify the Bayesian network and thus fully represent the <a href="joint_probability_distribution" title="wikilink">joint probability distribution</a>, it is necessary to specify for each node <em>X</em> the probability distribution for <em>X</em> conditional upon <em>X</em>'s parents. The distribution of <em>X</em> conditional upon its parents may have any form. It is common to work with discrete or <a href="normal_distribution" title="wikilink">Gaussian distributions</a> since that simplifies calculations. Sometimes only constraints on a distribution are known; one can then use the <a href="principle_of_maximum_entropy" title="wikilink">principle of maximum entropy</a> to determine a single distribution, the one with the greatest <a href="information_entropy" title="wikilink">entropy</a> given the constraints. (Analogously, in the specific context of a <a href="dynamic_Bayesian_network" title="wikilink">dynamic Bayesian network</a>, one commonly specifies the conditional distribution for the hidden state's temporal evolution to maximize the <a href="entropy_rate" title="wikilink">entropy rate</a> of the implied stochastic process.)</p>

<p>Often these conditional distributions include parameters which are unknown and must be estimated from data, sometimes using the <a href="maximum_likelihood" title="wikilink">maximum likelihood</a> approach. Direct maximization of the likelihood (or of the <a href="posterior_probability" title="wikilink">posterior probability</a>) is often complex when there are unobserved variables. A classical approach to this problem is the <a href="expectation-maximization_algorithm" title="wikilink">expectation-maximization algorithm</a> which alternates computing expected values of the unobserved variables conditional on observed data, with maximizing the complete likelihood (or posterior) assuming that previously computed expected values are correct. Under mild regularity conditions this process converges on maximum likelihood (or maximum posterior) values for parameters.</p>

<p>A more fully Bayesian approach to parameters is to treat parameters as additional unobserved variables and to compute a full posterior distribution over all nodes conditional upon observed data, then to integrate out the parameters. This approach can be expensive and lead to large dimension models, so in practice classical parameter-setting approaches are more common.</p>
<h3 id="structure-learning">Structure learning</h3>

<p>In the simplest case, a Bayesian network is specified by an expert and is then used to perform inference. In other applications the task of defining the network is too complex for humans. In this case the network structure and the parameters of the local distributions must be learned from data.</p>

<p>Automatically learning the graph structure of a Bayesian network is a challenge pursued within <a href="machine_learning" title="wikilink">machine learning</a>. The basic idea goes back to a recovery algorithm developed by Rebane and Pearl (1987)<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> and rests on the distinction between the three possible types of adjacent triplets allowed in a directed acyclic graph (DAG):</p>
<ol>
<li>

<math display="inline" id="Bayesian_network:18">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>→</mo>
   <mi>Y</mi>
   <mo>→</mo>
   <mi>Z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\rightarrow Y\rightarrow Z
  </annotation>
 </semantics>
</math>


</li>
<li>

<math display="inline" id="Bayesian_network:19">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>←</mo>
   <mi>Y</mi>
   <mo>→</mo>
   <mi>Z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-←</ci>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\leftarrow Y\rightarrow Z
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Bayesian_network:20">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>→</mo>
   <mi>Y</mi>
   <mo>←</mo>
   <mi>Z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <ci>normal-←</ci>
     <share href="#.cmml">
     </share>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\rightarrow Y\leftarrow Z
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>Type 1 and type 2 represent the same dependencies (

<math display="inline" id="Bayesian_network:21">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bayesian_network:22">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 are independent given 

<math display="inline" id="Bayesian_network:23">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>


) and are, therefore, indistinguishable. Type 3, however, can be uniquely identified, since 

<math display="inline" id="Bayesian_network:24">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bayesian_network:25">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 are marginally independent and all other pairs are dependent. Thus, while the <em>skeletons</em> (the graphs stripped of arrows) of these three triplets are identical, the directionality of the arrows is partially identifiable. The same distinction applies when 

<math display="inline" id="Bayesian_network:26">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bayesian_network:27">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 have common parents, except that one must first condition on those parents. Algorithms have been developed to systematically determine the skeleton of the underlying graph and, then, orient all arrows whose directionality is dictated by the conditional independencies observed.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>An alternative method of structural learning uses optimization based search. It requires a <a href="scoring_function" title="wikilink">scoring function</a> and a <a href="search_strategy" title="wikilink">search strategy</a>. A common scoring function is <a href="posterior_probability" title="wikilink">posterior probability</a> of the structure given the training data. The time requirement of an <a href="exhaustive_search" title="wikilink">exhaustive search</a> returning a structure that maximizes the score is <a href="Tetration" title="wikilink">superexponential</a> in the number of variables. A local search strategy makes incremental changes aimed at improving the score of the structure. A global search algorithm like <a href="Markov_chain_Monte_Carlo" title="wikilink">Markov chain Monte Carlo</a> can avoid getting trapped in <a href="maxima_and_minima" title="wikilink">local minima</a>. Friedman et al.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> discuss using <a href="mutual_information" title="wikilink">mutual information</a> between variables and finding a structure that maximizes this. They do this by restricting the parent candidate set to <em>k</em> nodes and exhaustively searching therein.</p>

<p>Another method consists of focusing on the sub-class of decomposable models, for which the <a href="Maximum_likelihood_estimate" title="wikilink">MLE</a> have a closed form. It is then possible to discover a consistent structure for hundreds of variables.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>A Bayesian network can be augmented with nodes and edges using rule-based <a href="machine_learning" title="wikilink">machine learning</a> techniques. <a href="Inductive_logic_programming" title="wikilink">Inductive logic programming</a> can be used to mine rules and create new nodes.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> <a href="Statistical_relational_learning" title="wikilink">Statistical relational learning</a> (SRL) approaches use a <a href="scoring_function" title="wikilink">scoring function</a> based on the Bayes network structure to guide the structural search and augment the network.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> A common SRL scoring function is the area under the <a href="ROC_curve" title="wikilink">ROC curve</a>.</p>
<h2 id="statistical-introduction">Statistical introduction</h2>

<p>Given data 

<math display="inline" id="Bayesian_network:28">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,\!
  </annotation>
 </semantics>
</math>


 and parameter 

<math display="inline" id="Bayesian_network:29">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>

, a simple <a href="Bayesian_statistics" title="wikilink">Bayesian analysis</a> starts with a <a href="prior_probability" title="wikilink">prior probability</a> (<em>prior</em>) 

<math display="inline" id="Bayesian_network:30">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\theta)
  </annotation>
 </semantics>
</math>

 and <a href="likelihood_function" title="wikilink">likelihood</a> 

<math display="inline" id="Bayesian_network:31">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>∣</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x\mid\theta)
  </annotation>
 </semantics>
</math>

 to compute a <a href="posterior_probability" title="wikilink">posterior probability</a> 

<math display="inline" id="Bayesian_network:32">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo>∣</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∝</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>∣</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proportional-to</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\theta\mid x)\propto p(x\mid\theta)p(\theta)
  </annotation>
 </semantics>
</math>

.</p>

<p>Often the prior on 

<math display="inline" id="Bayesian_network:33">
 <semantics>
  <mi>θ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>θ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta
  </annotation>
 </semantics>
</math>


 depends in turn on other parameters 

<math display="inline" id="Bayesian_network:34">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 that are not mentioned in the likelihood. So, the prior 

<math display="inline" id="Bayesian_network:35">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\theta)
  </annotation>
 </semantics>
</math>

 must be replaced by a likelihood 

<math display="inline" id="Bayesian_network:36">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo>∣</mo>
    <mi>φ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">φ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\theta\mid\varphi)
  </annotation>
 </semantics>
</math>

, and a prior 

<math display="inline" id="Bayesian_network:37">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>φ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\varphi)
  </annotation>
 </semantics>
</math>

 on the newly introduced parameters 

<math display="inline" id="Bayesian_network:38">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>


 is required, resulting in a posterior probability</p>

<p>

<math display="block" id="Bayesian_network:39">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo>,</mo>
    <mi>φ</mi>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∝</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">|</mo>
    <mi>φ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>φ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">φ</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proportional-to</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">θ</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">φ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">φ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\theta,\varphi|x)\propto p(x|\theta)p(\theta|\varphi)p(\varphi).
  </annotation>
 </semantics>
</math>

</p>

<p>This is the simplest example of a <em>hierarchical Bayes model</em>.</p>

<p>The process may be repeated; for example, the parameters 

<math display="inline" id="Bayesian_network:40">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 may depend in turn on additional parameters 

<math display="inline" id="Bayesian_network:41">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi\,\!
  </annotation>
 </semantics>
</math>

, which will require their own prior. Eventually the process must terminate, with priors that do not depend on any other unmentioned parameters.</p>
<h3 id="introductory-examples">Introductory examples</h3>

<p>Suppose we have measured the quantities 

<math display="inline" id="Bayesian_network:42">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\dots,x_{n}\,\!
  </annotation>
 </semantics>
</math>

each with <a href="Normal_distribution" title="wikilink">normally distributed</a> errors of known <a href="standard_deviation" title="wikilink">standard deviation</a> 

<math display="inline" id="Bayesian_network:43">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\,\!
  </annotation>
 </semantics>
</math>


,</p>

<p>

<math display="block" id="Bayesian_network:44">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>∼</mo>
   <mrow>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>θ</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msup>
      <mi>σ</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>N</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>σ</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}\sim N(\theta_{i},\sigma^{2})
  </annotation>
 </semantics>
</math>

</p>

<p>Suppose we are interested in estimating the 

<math display="inline" id="Bayesian_network:45">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}
  </annotation>
 </semantics>
</math>

. An approach would be to estimate the 

<math display="inline" id="Bayesian_network:46">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}
  </annotation>
 </semantics>
</math>

 using a <a href="maximum_likelihood" title="wikilink">maximum likelihood</a> approach; since the observations are independent, the likelihood factorizes and the maximum likelihood estimate is simply</p>

<p>

<math display="block" id="Bayesian_network:47">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}=x_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>However, if the quantities are related, so that for example we may think that the individual 

<math display="inline" id="Bayesian_network:48">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}
  </annotation>
 </semantics>
</math>


 have themselves been drawn from an underlying distribution, then this relationship destroys the independence and suggests a more complex model, e.g.,</p>

<p>

<math display="block" id="Bayesian_network:49">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>∼</mo>
    <mrow>
     <mi>N</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>θ</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msup>
       <mi>σ</mi>
       <mn>2</mn>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>N</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>θ</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>σ</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}\sim N(\theta_{i},\sigma^{2}),
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Bayesian_network:50">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mi>i</mi>
   </msub>
   <mo>∼</mo>
   <mrow>
    <mi>N</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>φ</mi>
     <mo>,</mo>
     <msup>
      <mi>τ</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>N</ci>
     <interval closure="open">
      <ci>φ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>τ</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}\sim N(\varphi,\tau^{2})
  </annotation>
 </semantics>
</math>

</p>

<p>with <a href="improper_prior" title="wikilink">improper priors</a> 

<math display="inline" id="Bayesian_network:51">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>∼</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <ci>φ</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi\sim
  </annotation>
 </semantics>
</math>

flat, 

<math display="inline" id="Bayesian_network:52">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mo>∼</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <ci>τ</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau\sim
  </annotation>
 </semantics>
</math>

flat

<math display="inline" id="Bayesian_network:53">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mi mathvariant="normal">∞</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <csymbol cd="latexml">absent</csymbol>
    <interval closure="open">
     <cn type="integer">0</cn>
     <infinity></infinity>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in(0,\infty)
  </annotation>
 </semantics>
</math>


. When 

<math display="inline" id="Bayesian_network:54">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>≥</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>n</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\geq 3
  </annotation>
 </semantics>
</math>

, this is an <a href="identified_model" title="wikilink">identified model</a> (i.e. there exists a unique solution for the model's parameters), and the posterior distributions of the individual 

<math display="inline" id="Bayesian_network:55">
 <semantics>
  <msub>
   <mi>θ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>θ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{i}
  </annotation>
 </semantics>
</math>

 will tend to move, or <em><a href="Shrinkage_estimator" title="wikilink">shrink</a></em> away from the maximum likelihood estimates towards their common mean. This <em>shrinkage</em> is a typical behavior in hierarchical Bayes models.</p>
<h3 id="restrictions-on-priors">Restrictions on priors</h3>

<p>Some care is needed when choosing priors in a hierarchical model, particularly on scale variables at higher levels of the hierarchy such as the variable 

<math display="inline" id="Bayesian_network:56">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau\,\!
  </annotation>
 </semantics>
</math>

 in the example. The usual priors such as the <a href="Jeffreys_prior" title="wikilink">Jeffreys prior</a> often do not work, because the posterior distribution will be improper (not normalizable), and estimates made by minimizing the <a href="Loss_function#Expected_loss" title="wikilink">expected loss</a> will be <a href="admissible_decision_rule" title="wikilink">inadmissible</a>.</p>
<h2 id="definitions-and-concepts">Definitions and concepts</h2>

<p>There are several equivalent definitions of a Bayesian network. For all the following, let <em>G</em> = (<em>V</em>,<em>E</em>) be a <a href="directed_acyclic_graph" title="wikilink">directed acyclic graph</a> (or DAG), and let <em>X</em> = (<em>X</em><sub><em>v</em></sub>)<sub><em>v</em> ∈ <em>V</em></sub> be a set of <a href="random_variable" title="wikilink">random variables</a> indexed by <em>V</em>.</p>
<h3 id="factorization-definition">Factorization definition</h3>

<p><em>X</em> is a Bayesian network with respect to <em>G</em> if its joint <a href="probability_density_function" title="wikilink">probability density function</a> (with respect to a <a href="product_measure" title="wikilink">product measure</a>) can be written as a product of the individual density functions, conditional on their parent variables: 

<math display="inline" id="Bayesian_network:57">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mo largeop="true" symmetric="true">∏</mo>
    <mrow>
     <mi>v</mi>
     <mo>∈</mo>
     <mi>V</mi>
    </mrow>
   </msub>
   <mi>p</mi>
   <mrow>
    <mo>(</mo>
    <mpadded width="+1.7pt">
     <msub>
      <mi>x</mi>
      <mi>v</mi>
     </msub>
    </mpadded>
    <mo mathsize="120%" rspace="4.2pt" stretchy="false">|</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mo>pa</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msub>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">product</csymbol>
     <apply>
      <in></in>
      <ci>v</ci>
      <ci>V</ci>
     </apply>
    </apply>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>v</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <ci>pa</ci>
       <ci>v</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)=\prod_{v\in V}p\left(x_{v}\,\big|\,x_{\operatorname{pa}(v)}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>where pa(<em>v</em>) is the set of parents of <em>v</em> (i.e. those vertices pointing directly to <em>v</em> via a single edge).</p>

<p>For any set of random variables, the probability of any member of a <a href="joint_distribution" title="wikilink">joint distribution</a> can be calculated from conditional probabilities using the <a href="chain_rule_(probability)" title="wikilink">chain rule</a> (given a <a href="topological_ordering" title="wikilink">topological ordering</a> of <em>X</em>) as follows: 

<math display="inline" id="Bayesian_network:58">
 <semantics>
  <mrow>
   <mi mathvariant="normal">P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msubsup>
    <mo largeop="true" symmetric="true">∏</mo>
    <mrow>
     <mi>v</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>n</mi>
   </msubsup>
   <mi mathvariant="normal">P</mi>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>X</mi>
     <mi>v</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mi>v</mi>
    </msub>
    <mo>∣</mo>
    <msub>
     <mi>X</mi>
     <mrow>
      <mi>v</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>v</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <eq></eq>
       <ci>v</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>v</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>v</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <apply>
       <plus></plus>
       <ci>v</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <plus></plus>
       <ci>v</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{P}(X_{1}=x_{1},\ldots,X_{n}=x_{n})=\prod_{v=1}^{n}\mathrm{P}\left(X_{v%
}=x_{v}\mid X_{v+1}=x_{v+1},\ldots,X_{n}=x_{n}\right)
  </annotation>
 </semantics>
</math>


</p>

<p>Compare this with the definition above, which can be written as:</p>

<p>

<math display="inline" id="Bayesian_network:59">
 <semantics>
  <mrow>
   <mi mathvariant="normal">P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msubsup>
    <mo largeop="true" symmetric="true">∏</mo>
    <mrow>
     <mi>v</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>n</mi>
   </msubsup>
   <mi mathvariant="normal">P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mi>v</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mi>v</mi>
    </msub>
    <mo>∣</mo>
    <msub>
     <mi>X</mi>
     <mi>j</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mi>j</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <eq></eq>
       <ci>v</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>v</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>v</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>j</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{P}(X_{1}=x_{1},\ldots,X_{n}=x_{n})=\prod_{v=1}^{n}\mathrm{P}(X_{v}=x_{%
v}\mid X_{j}=x_{j}
  </annotation>
 </semantics>
</math>

 for each 

<math display="inline" id="Bayesian_network:60">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>X</mi>
    <mi>j</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{j}\,
  </annotation>
 </semantics>
</math>

 which is a parent of 

<math display="inline" id="Bayesian_network:61">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <msub>
     <mi>X</mi>
     <mi>v</mi>
    </msub>
   </mpadded>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>v</ci>
    </apply>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{v}\,)
  </annotation>
 </semantics>
</math>

</p>

<p>The difference between the two expressions is the <a href="conditional_independence" title="wikilink">conditional independence</a> of the variables from any of their non-descendants, given the values of their parent variables.</p>
<h3 id="local-markov-property">Local Markov property</h3>

<p><em>X</em> is a Bayesian network with respect to <em>G</em> if it satisfies the <em>local Markov property</em>: each variable is <a href="Conditional_independence" title="wikilink">conditionally independent</a> of its non-descendants given its parent variables:</p>

<p>

<math display="block" id="Bayesian_network:62">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mi>v</mi>
   </msub>
   <mo rspace="0pt">⟂</mo>
   <mo>⟂</mo>
   <msub>
    <mi>X</mi>
    <mrow>
     <mi>V</mi>
     <mo>∖</mo>
     <mrow>
      <mo>de</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msub>
   <mo>∣</mo>
   <msub>
    <mi>X</mi>
    <mrow>
     <mo>pa</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
   <mtext>for all</mtext>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>v</ci>
    </apply>
    <csymbol cd="latexml">perpendicular-to</csymbol>
    <csymbol cd="latexml">perpendicular-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <setdiff></setdiff>
      <ci>V</ci>
      <apply>
       <ci>de</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <ci>pa</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <ci></ci>
    <mtext>for all</mtext>
    <csymbol cd="unknown">v</csymbol>
    <in></in>
    <csymbol cd="unknown">V</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{v}\perp\!\!\!\perp X_{V\setminus\operatorname{de}(v)}\mid X_{\operatorname{%
pa}(v)}\quad\text{for all }v\in V
  </annotation>
 </semantics>
</math>

</p>

<p>where de(<em>v</em>) is the set of descendants and <em>V</em> \ de(<em>v</em>) is the set of non-descendants of <em>v</em>.</p>

<p>This can also be expressed in terms similar to the first definition, as</p>

<p>

<math display="block" id="Bayesian_network:63">
 <semantics>
  <mrow>
   <mi mathvariant="normal">P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mi>v</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mi>v</mi>
    </msub>
    <mo>∣</mo>
    <msub>
     <mi>X</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>v</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>v</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>i</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{P}(X_{v}=x_{v}\mid X_{i}=x_{i}
  </annotation>
 </semantics>
</math>

 for each 

<math display="inline" id="Bayesian_network:64">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>X</mi>
    <mi>i</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{i}\,
  </annotation>
 </semantics>
</math>

 which is not a descendant of 

<math display="inline" id="Bayesian_network:65">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <msub>
     <mi>X</mi>
     <mi>v</mi>
    </msub>
   </mpadded>
   <mo stretchy="false">)</mo>
   <mo>=</mo>
   <mi>P</mi>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>X</mi>
    <mi>v</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mi>v</mi>
   </msub>
   <mo>∣</mo>
   <msub>
    <mi>X</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>v</ci>
    </apply>
    <ci>normal-)</ci>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-(</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>v</ci>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>v</ci>
    </apply>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>j</ci>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>j</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{v}\,)=P(X_{v}=x_{v}\mid X_{j}=x_{j}
  </annotation>
 </semantics>
</math>

 for each 

<math display="inline" id="Bayesian_network:66">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>X</mi>
    <mi>j</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{j}\,
  </annotation>
 </semantics>
</math>

 which is a parent of 

<math display="inline" id="Bayesian_network:67">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <msub>
     <mi>X</mi>
     <mi>v</mi>
    </msub>
   </mpadded>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>v</ci>
    </apply>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{v}\,)
  </annotation>
 </semantics>
</math>

</p>

<p>Note that the set of parents is a subset of the set of non-descendants because the graph is <a href="Cycle_(graph_theory)" title="wikilink">acyclic</a>.</p>
<h3 id="developing-bayesian-networks">Developing Bayesian networks</h3>

<p>To develop a Bayesian network, we often first develop a DAG <em>G</em> such that we believe <em>X</em> satisfies the local Markov property with respect to <em>G</em>. Sometimes this is done by creating a causal DAG. We then ascertain the conditional probability distributions of each variable given its parents in <em>G</em>. In many cases, in particular in the case where the variables are discrete, if we define the joint distribution of <em>X</em> to be the product of these conditional distributions, then <em>X</em> is a Bayesian network with respect to <em>G</em>.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h3 id="markov-blanket">Markov blanket</h3>

<p>The <a href="Markov_blanket" title="wikilink">Markov blanket</a> of a node is the set of nodes consisting of its parents, its children, and any other parents of its children. This set renders it independent of the rest of the network; the joint distribution of the variables in the Markov blanket of a node is sufficient knowledge for calculating the distribution of the node. <em>X</em> is a Bayesian network with respect to <em>G</em> if every node is conditionally independent of all other nodes in the network, given its <a href="Markov_blanket" title="wikilink">Markov blanket</a>.</p>
<h4 id="d-separation"><em>d</em>-separation</h4>

<p>This definition can be made more general by defining the "d"-separation of two nodes, where d stands for directional.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> Let <em>P</em> be a trail (that is, a collection of edges which is like a path, but each of whose edges may have any direction) from node <em>u</em> to <em>v</em>. Then <em>P</em> is said to be <em>d</em>-separated by a set of nodes <em>Z</em> if and only if (at least) one of the following holds:</p>
<ol>
<li><em>P</em> contains a <em>chain</em>, <em>u</em> ← <em>m</em> ← <em>v</em>, such that the middle node <em>m</em> is in <em>Z</em>,</li>
<li><em>P</em> contains a <em>fork</em>, <em>u</em> ← <em>m</em> → <em>v</em>, such that the middle node <em>m</em> is in <em>Z</em>, or</li>
<li><em>P</em> contains an <em>inverted fork</em> (or <em>collider</em>), <em>u</em> → <em>m</em> ← <em>v</em>, such that the middle node <em>m</em> is <strong>not</strong> in <em>Z</em> and no descendant of <em>m</em> is in <em>Z</em>.</li>
</ol>

<p>Thus <em>u</em> and <em>v</em> are said to be <em>d</em>-separated by <em>Z</em> if all trails between them are <em>d</em>-separated. If <em>u</em> and <em>v</em> are not d-separated, they are called d-connected.</p>

<p><em>X</em> is a Bayesian network with respect to <em>G</em> if, for any two nodes <em>u</em>, <em>v</em>:</p>

<p>

<math display="block" id="Bayesian_network:68">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mi>u</mi>
   </msub>
   <mo rspace="0pt">⟂</mo>
   <mo>⟂</mo>
   <msub>
    <mi>X</mi>
    <mi>v</mi>
   </msub>
   <mo>∣</mo>
   <msub>
    <mi>X</mi>
    <mi>Z</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>u</ci>
    </apply>
    <csymbol cd="latexml">perpendicular-to</csymbol>
    <csymbol cd="latexml">perpendicular-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>v</ci>
    </apply>
    <ci>normal-∣</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>Z</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{u}\perp\!\!\!\perp X_{v}\mid X_{Z}
  </annotation>
 </semantics>
</math>

 where <em>Z</em> is a set which <em>d</em>-separates <em>u</em> and <em>v</em>. (The <a href="Markov_blanket" title="wikilink">Markov blanket</a> is the minimal set of nodes which <em>d</em>-separates node <em>v</em> from all other nodes.)</p>
<h3 id="hierarchical-models">Hierarchical models</h3>

<p>The term <em>hierarchical model</em> is sometimes considered a particular type of Bayesian network, but has no formal definition. Sometimes the term is reserved for models with three or more levels of random variables; other times, it is reserved for models with <a href="latent_variable" title="wikilink">latent variables</a>. In general, however, any moderately complex Bayesian network is usually termed "hierarchical".</p>
<h3 id="causal-networks">Causal networks</h3>

<p>Although Bayesian networks are often used to represent <a href="causality" title="wikilink">causal</a> relationships, this need not be the case: a directed edge from <em>u</em> to <em>v</em> does not require that <em>X<sub>v</sub></em> is causally dependent on <em>X<sub>u</sub></em>. This is demonstrated by the fact that Bayesian networks on the graphs:</p>

<p>

<math display="block" id="Bayesian_network:69">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>⟶</mo>
    <mi>b</mi>
    <mo>⟶</mo>
    <mi>c</mi>
   </mrow>
   <mrow>
    <mrow>
     <mtext>and</mtext>
     <mi>a</mi>
    </mrow>
    <mo>⟵</mo>
    <mi>b</mi>
    <mo>⟵</mo>
    <mi>c</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <ci>normal-⟶</ci>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <ci>normal-⟶</ci>
      <share href="#.cmml">
      </share>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <ci>normal-⟵</ci>
      <list>
       <mtext>and</mtext>
       <ci>a</ci>
      </list>
      <ci>b</ci>
     </apply>
     <apply>
      <ci>normal-⟵</ci>
      <share href="#.cmml">
      </share>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\longrightarrow b\longrightarrow c\qquad\text{and}\qquad a\longleftarrow b\longleftarrow
c
  </annotation>
 </semantics>
</math>

</p>

<p>are equivalent: that is they impose exactly the same conditional independence requirements.</p>

<p>A <strong>causal network</strong> is a Bayesian network with an explicit requirement that the relationships be causal. The additional semantics of the causal networks specify that if a node <em>X</em> is actively caused to be in a given state <em>x</em> (an action written as do(<em>X</em> = <em>x</em>)), then the probability density function changes to the one of the network obtained by cutting the links from the parents of <em>X</em> to <em>X</em>, and setting <em>X</em> to the caused value <em>x</em>.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> Using these semantics, one can predict the impact of external interventions from data obtained prior to intervention.</p>
<h2 id="applications">Applications</h2>

<p>Bayesian networks are used for <a href="mathematical_model" title="wikilink">modelling</a> beliefs in <a href="computational_biology" title="wikilink">computational biology</a> and <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a> (<a href="gene_regulatory_network" title="wikilink">gene regulatory networks</a>, <a href="protein_structure" title="wikilink">protein structure</a>, <a href="gene_expression" title="wikilink">gene expression</a> analysis,<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> learning epistasis from GWAS data sets<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a>) <a class="uri" href="medicine" title="wikilink">medicine</a>,<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> <a class="uri" href="biomonitoring" title="wikilink">biomonitoring</a>,<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> <a href="document_classification" title="wikilink">document classification</a>, <a href="information_retrieval" title="wikilink">information retrieval</a>,<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> <a href="semantic_search" title="wikilink">semantic search</a>,<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> <a href="image_processing" title="wikilink">image processing</a>, <a href="data_fusion" title="wikilink">data fusion</a>, <a href="decision_support_system" title="wikilink">decision support systems</a>,<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> <a class="uri" href="engineering" title="wikilink">engineering</a>, sports betting,<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a><a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> gaming, <a class="uri" href="law" title="wikilink">law</a>,<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a><a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a><a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> study design<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> and <a href="risk_analysis" title="wikilink">risk analysis</a>.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a><a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a><a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> There are texts applying Bayesian networks to bioinformatics<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> and financial and marketing informatics.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a></p>
<h3 id="software">Software</h3>
<ul>
<li><a class="uri" href="WinBUGS" title="wikilink">WinBUGS</a></li>
<li><a class="uri" href="OpenBUGS" title="wikilink">OpenBUGS</a> (<a href="http://www.openbugs.net/w/FrontPage">website</a>), further (open source) development of WinBUGS.</li>
<li><a href="http://research.project-10.de/dgm">Direct Graphical Models</a> (DGM) is an open source C++ library, implementing various tasks in probabilistic graphical models with pairwise dependencies.</li>
<li><a href="http://www.openmarkov.org/">OpenMarkov</a>, open source software and API implemented in Java</li>
<li><a href="http://melodi.ee.washington.edu/gmtk">Graphical Models Toolkit</a> (GMTK) — GMTK is an open source, publicly available toolkit for rapidly prototyping statistical models using dynamic graphical models (DGMs) and dynamic Bayesian networks (DBNs). GMTK can be used for applications and research in speech and language processing, bioinformatics, activity recognition, and any time series application.</li>
<li><a href="Just_another_Gibbs_sampler" title="wikilink">Just another Gibbs sampler</a> (JAGS) (<a href="http://www-fis.iarc.fr/~martyn/software/jags/">website</a>)</li>
<li><a href="Stan_(software)" title="wikilink">Stan (software)</a> (<a href="http://mc-stan.org/">website</a>) — Stan is an open-source package for obtaining Bayesian inference using the No-U-Turn sampler, a variant of Hamiltonian Monte Carlo. It’s somewhat like BUGS, but with a different language for expressing models and a different sampler for sampling from their posteriors. RStan is the R interface to Stan.</li>
<li><a href="http://pymc-devs.github.io/pymc/">PyMC</a> — PyMC is a python module that implements Bayesian statistical models and fitting algorithms, including Markov chain Monte Carlo. Its flexibility and extensibility make it applicable to a large suite of problems. Along with core sampling functionality, PyMC includes methods for summarizing output, plotting, goodness-of-fit and convergence diagnostics.</li>
<li>GeNIe&amp;Smile; (<a href="http://genie.sis.pitt.edu/">website</a>) — SMILE is a C++ library for BN and ID, and GeNIe is a GUI for it</li>
<li>SamIam (<a href="http://reasoning.cs.ucla.edu/samiam/">website</a>), a Java-based system with GUI and Java API</li>
<li><a href="http://www.BayesServer.com/">Bayes Server</a> - User Interface and API for Bayesian networks, includes support for time series and sequences</li>
<li>Belief and Decision Networks on <a href="http://www.aispace.org/bayes/index.shtml">AIspace</a></li>
<li><a href="http://library.bayesia.com/display/HOME/The+BayesiaLab+Library/">BayesiaLab</a> by Bayesia</li>
<li><a href="http://www.hugin.com/">Hugin</a></li>
<li><a href="http://www.norsys.com/netica.html">Netica</a> by Norsys</li>
<li><a href="http://www.aparasw.com/index.php/en">dVelox</a> by Apara Software</li>
<li><a href="http://www.inatas.com">System Modeler</a> by Inatas AB</li>
<li><a href="http://sourceforge.net/projects/unbbayes/">UnBBayes</a> by GIA-UnB (Intelligence Artificial Group - University of Brasilia)</li>
</ul>
<h2 id="history">History</h2>

<p>The term "Bayesian networks" was coined by <a href="Judea_Pearl" title="wikilink">Judea Pearl</a> in 1985 to emphasize three aspects:<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a></p>
<ol>
<li>The often subjective nature of the input information.</li>
<li>The reliance on Bayes' conditioning as the basis for updating information.</li>
<li>The distinction between causal and evidential modes of reasoning, which underscores <a href="Thomas_Bayes" title="wikilink">Thomas Bayes</a>' posthumously published paper of 1763.<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a></li>
</ol>

<p>In the late 1980s Judea Pearl's text <em>Probabilistic Reasoning in Intelligent Systems</em><a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> and Richard E. Neapolitan's text <em>Probabilistic Reasoning in Expert Systems</em><a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> summarized the properties of Bayesian networks and established Bayesian networks as a field of study.</p>

<p>Informal variants of such networks were first used by <a href="legal_scholar" title="wikilink">legal scholar</a> <a href="John_Henry_Wigmore" title="wikilink">John Henry Wigmore</a>, in the form of <a href="Wigmore_chart" title="wikilink">Wigmore charts</a>, to analyse <a href="trial_(law)" title="wikilink">trial</a> <a href="evidence_(law)" title="wikilink">evidence</a> in 1913.<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> Another variant, called <a href="path_analysis_(statistics)" title="wikilink">path diagrams</a>, was developed by the geneticist <a href="Sewall_Wright" title="wikilink">Sewall Wright</a><a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a> and used in <a href="Social_sciences" title="wikilink">social</a> and <a href="behavioral_science" title="wikilink">behavioral sciences</a> (mostly with linear parametric models).</p>
<h2 id="see-also">See also</h2>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>(This paper puts <a href="Decision_tree_learning" title="wikilink">decision trees</a> in internal nodes of Bayes networks using <a href="http://www.csse.monash.edu.au/~dld/MML.html">Minimum Message Length</a> (<a href="Minimum_message_length" title="wikilink">MML</a>). An earlier version is <a href="http://www.csse.monash.edu.au/~dld/David.Dowe.publications.html#ComleyDowe2003">Comley and Dowe (2003)</a>, <a href="http://www.csse.monash.edu.au/~dld/Publications/2003/Comley+Dowe03_HICS2003_GeneralBayesianNetworksAsymmetricLanguages.pdf">.pdf</a>.)</p></li>
</ul>
<ul>
<li></li>
<li>Dowe, David L. (2010). <a href="http://www.csse.monash.edu.au/~dld/Publications/2010/Dowe2010_MML_HandbookPhilSci_Vol7_HandbookPhilStat_MML+hybridBayesianNetworkGraphicalModels+StatisticalConsistency+InvarianceAndUniqueness_pp901-982.pdf">MML, hybrid Bayesian network graphical models, statistical consistency, invariance and uniqueness</a>, in Handbook of Philosophy of Science (Volume 7: Handbook of Philosophy of Statistics), Elsevier, <a href="http://japan.elsevier.com/products/books/HPS.pdf">ISBN 978-0-444-51862-0</a>, pp <a href="http://www.csse.monash.edu.au/~dld/Publications/2010/Dowe2010_MML_HandbookPhilSci_Vol7_HandbookPhilStat_MML+hybridBayesianNetworkGraphicalModels+StatisticalConsistency+InvarianceAndUniqueness_pp901-982.pdf">901–982</a>.</li>
<li>Fenton, Norman; Neil, Martin E. (November 2007). <em><a href="http://www.agenarisk.com/resources/apps_bayesian_networks.pdf">Managing Risk in the Modern World: Applications of Bayesian Networks</a></em> – A Knowledge Transfer Report from the London Mathematical Society and the Knowledge Transfer Network for Industrial Mathematics. <a href="London" title="wikilink">London (England)</a>: <a href="London_Mathematical_Society" title="wikilink">London Mathematical Society</a>.</li>
<li></li>
<li></li>
<li>

<p>.</p></li>
</ul>
<dl>
<dd>Also appears as 
</dd>
<dd>An earlier version appears as <a href="http://research.microsoft.com/research/pubs/view.aspx?msr_tr_id=MSR-TR-95-06">Technical Report MSR-TR-95-06</a>, Microsoft Research, March 1, 1995. The paper is about both parameter and structure learning in Bayesian networks.
</dd>
</dl>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>.</p></li>
<li>

<p>This paper presents variable elimination for belief networks.</p></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li><em>Computational Intelligence: A Methodological Introduction</em> by Kruse, Borgelt, Klawonn, Moewes, Steinbrecher, Held, 2013, Springer, ISBN 9781447150121</li>
<li><em>Graphical Models - Representations for Learning, Reasoning and Data Mining</em>, 2nd Edition, by Borgelt, Steinbrecher, Kruse, 2009, J. Wiley &amp; Sons, ISBN 9780470749562</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://research.microsoft.com/research/pubs/view.aspx?msr_tr_id=MSR-TR-95-06">A tutorial on learning with Bayesian Networks</a></li>
<li><a href="http://www.niedermayer.ca/papers/bayesian/bayes.html">An Introduction to Bayesian Networks and their Contemporary Applications</a></li>
<li><a href="http://www.dcs.qmw.ac.uk/%7Enorman/BBNs/BBNs.htm">On-line Tutorial on Bayesian nets and probability</a></li>
<li><a href="http://princesofserendib.com/">Web-App to create Bayesian nets and run it with a Monte Carlo method</a></li>
<li><a href="http://robotics.stanford.edu/~nodelman/papers/ctbn.pdf">Continuous Time Bayesian Networks</a></li>
<li><a href="http://wiki.syncleus.com/index.php/DANN:Bayesian_Network">Bayesian Networks: Explanation and Analogy</a></li>
<li><a href="http://videolectures.net/kdd07_neapolitan_lbn/">A live tutorial on learning Bayesian networks</a></li>
<li><a href="http://www.biomedcentral.com/1471-2105/7/514/abstract">A hierarchical Bayes Model for handling sample heterogeneity in classification problems</a>, provides a classification model taking into consideration the uncertainty associated with measuring replicate samples.</li>
<li><a href="http://www.labmedinfo.org/download/lmi339.pdf">Hierarchical Naive Bayes Model for handling sample uncertainty</a>, shows how to perform classification and learning with continuous and discrete variables with replicated measurements.</li>
</ul>

<p>"</p>

<p><a href="Category:Bayesian_networks" title="wikilink"> </a> <a class="uri" href="Category:Networks" title="wikilink">Category:Networks</a> <a href="Category:Statistical_models" title="wikilink">Category:Statistical models</a> <a href="Category:Graphical_models" title="wikilink">Category:Graphical models</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">I. Shpitser, J. Pearl, "Identification of Conditional Interventional Distributions" In R. Dechter and T.S. Richardson (Eds.), <em>Proceedings of the Twenty-Second Conference on Uncertainty in Artificial Intelligence</em>, 437–444, Corvallis, OR: AUAI Press, 2006.<a href="#fnref6">↩</a></li>
<li id="fn7">Rebane, G. and Pearl, J., "The Recovery of Causal Poly-trees from Statistical Data," <em>Proceedings, 3rd Workshop on Uncertainty in AI,</em> (Seattle, WA) pages 222–228, 1987<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26">Christos L. Koumenides and Nigel R. Shadbolt. 2012. <a href="http://eprints.soton.ac.uk/342220">Combining link and content-based information in a Bayesian inference model for entity search.</a> In Proceedings of the 1st Joint International Workshop on Entity-Oriented and Semantic Search (JIWES '12). ACM, New York, NY, USA, , Article 3 , 6 pages. <a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"><a href="#fnref33">↩</a></li>
<li id="fn34"><a href="#fnref34">↩</a></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36"><a href="#fnref36">↩</a></li>
<li id="fn37"><a href="#fnref37">↩</a></li>
<li id="fn38"><a href="#fnref38">↩</a></li>
<li id="fn39"><a href="#fnref39">↩</a></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42"><a href="#fnref42">↩</a></li>
<li id="fn43"></li>
<li id="fn44"><a href="#fnref44">↩</a></li>
</ol>
</section>
</body>
</html>
