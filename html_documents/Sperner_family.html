<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="559">Sperner family</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Sperner family</h1>
<hr/>

<p>In <a class="uri" href="combinatorics" title="wikilink">combinatorics</a>, a <strong>Sperner family</strong> (or <strong>Sperner system</strong>), named in honor of <a href="Emanuel_Sperner" title="wikilink">Emanuel Sperner</a>, is a <a href="family_of_sets" title="wikilink">family of sets</a> (<strong><em>F</em></strong>, <em>E</em>) in which none of the sets is contained in another. Equivalently, a Sperner family is an <a class="uri" href="antichain" title="wikilink">antichain</a> in the inclusion <a href="Lattice_(order)" title="wikilink">lattice</a> over the <a href="power_set" title="wikilink">power set</a> of <em>E</em>. A Sperner family is also sometimes called an <strong>independent system</strong> or a <strong>clutter</strong>.</p>

<p>Sperner families are counted by the <a href="Dedekind_number" title="wikilink">Dedekind numbers</a>, and their size is bounded by <a href="Sperner's_theorem" title="wikilink">Sperner's theorem</a> and the <a href="Lubell–Yamamoto–Meshalkin_inequality" title="wikilink">Lubell–Yamamoto–Meshalkin inequality</a>. They may also be described in the language of <a href="hypergraph" title="wikilink">hypergraphs</a> rather than set families, where they are called <strong>clutters</strong>.</p>
<h2 id="dedekind-numbers">Dedekind numbers</h2>

<p>The number of different Sperner families on a set of <em>n</em> elements is counted by the <a href="Dedekind_number" title="wikilink">Dedekind numbers</a>, the first few of which are</p>
<dl>
<dd>2, 3, 6, 20, 168, 7581, 7828354, 2414682040998, 56130437228687557907788 .
</dd>
</dl>

<p>Although accurate <a href="asymptotic_expansion" title="wikilink">asymptotic</a> estimates are known for larger values of <em>n</em>, it is unknown whether there exists an exact formula that can be used to compute these numbers efficiently.</p>
<h2 id="bounds-on-the-size-of-a-sperner-family">Bounds on the size of a Sperner family</h2>
<h3 id="sperners-theorem">Sperner's theorem</h3>

<p>The <em>k</em>-element subsets of an <em>n</em>-element set form a Sperner family, the size of which is maximized when <em>k</em> = <em>n</em>/2 (or the nearest integer to it). <a href="Sperner's_theorem" title="wikilink">Sperner's theorem</a> states that these families are the largest possible Sperner families over an <em>n</em>-element set. Formally, the theorem states that, for every Sperner family <em>S</em> over an <em>n</em>-element set,</p>

<p>

<math display="block" id="Sperner_family:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>S</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mo>(</mo>
     <mtable columnspacing="0.4em" rowspacing="0.2ex">
      <mtr>
       <mtd>
        <mi>n</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mrow>
         <mo stretchy="false">⌊</mo>
         <mrow>
          <mi>n</mi>
          <mo>/</mo>
          <mn>2</mn>
         </mrow>
         <mo stretchy="false">⌋</mo>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <ci>S</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">binomial</csymbol>
     <ci>n</ci>
     <apply>
      <floor></floor>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |S|\leq{\left({{n}\atop{\lfloor n/2\rfloor}}\right)}.
  </annotation>
 </semantics>
</math>

</p>
<h3 id="lym-inequality">LYM inequality</h3>

<p>The <a href="Lubell–Yamamoto–Meshalkin_inequality" title="wikilink">Lubell–Yamamoto–Meshalkin inequality</a> provides another bound on the size of a Sperner family, and can be used to prove Sperner's theorem. It states that, if <em>a<sub>k</sub></em> denotes the number of sets of size <em>k</em> in a Sperner family over a set of <em>n</em> elements, then</p>

<p>

<math display="block" id="Sperner_family:1">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <mfrac>
     <msub>
      <mi>a</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo>(</mo>
      <mstyle scriptlevel="+1">
       <mtable columnspacing="0.4em" rowspacing="0.2ex">
        <mtr>
         <mtd>
          <mi>n</mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd>
          <mi>k</mi>
         </mtd>
        </mtr>
       </mtable>
      </mstyle>
      <mo>)</mo>
     </mrow>
    </mfrac>
   </mrow>
   <mo>≤</mo>
   <mn>1.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">binomial</csymbol>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <cn type="float">1.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{k=0}^{n}\frac{a_{k}}{{n\choose k}}\leq 1.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="clutters">Clutters</h2>

<p>A <strong>clutter</strong> <em>H</em> is a <a class="uri" href="hypergraph" title="wikilink">hypergraph</a> 

<math display="inline" id="Sperner_family:2">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>V</mi>
   <mo>,</mo>
   <mi>E</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>V</ci>
    <ci>E</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (V,E)
  </annotation>
 </semantics>
</math>

, with the added property that 

<math display="inline" id="Sperner_family:3">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>⊈</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-subset-of-or-equals</csymbol>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\not\subseteq B
  </annotation>
 </semantics>
</math>

 whenever 

<math display="inline" id="Sperner_family:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
   </mrow>
   <mo>∈</mo>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>A</ci>
     <ci>B</ci>
    </list>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A,B\in E
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sperner_family:5">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>≠</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\neq B
  </annotation>
 </semantics>
</math>

 (i.e. no edge properly contains another). That is, the sets of vertices represented by the hyperedges form a Sperner family. Clutters are an important structure in the study of combinatorial optimization. An opposite notion to a clutter is an <a href="abstract_simplicial_complex" title="wikilink">abstract simplicial complex</a>, where every subset of an edge is contained in the hypergraph (this is an <a href="order_ideal" title="wikilink">order ideal</a> in the poset of subsets of <em>E</em>).</p>

<p>If 

<math display="inline" id="Sperner_family:6">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=(V,E)
  </annotation>
 </semantics>
</math>

 is a clutter, then the <strong>blocker</strong> of <em>H</em>, denoted 

<math display="inline" id="Sperner_family:7">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>b</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b(H)
  </annotation>
 </semantics>
</math>

, is the clutter with vertex set <em>V</em> and edge set consisting of all minimal sets 

<math display="inline" id="Sperner_family:8">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>⊆</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>B</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\subseteq V
  </annotation>
 </semantics>
</math>

 so that 

<math display="inline" id="Sperner_family:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>B</mi>
    <mo>∩</mo>
    <mi>A</mi>
   </mrow>
   <mo>≠</mo>
   <mi mathvariant="normal">∅</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <intersect></intersect>
     <ci>B</ci>
     <ci>A</ci>
    </apply>
    <emptyset></emptyset>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\cap A\neq\varnothing
  </annotation>
 </semantics>
</math>

 for every 

<math display="inline" id="Sperner_family:10">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∈</mo>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>A</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in E
  </annotation>
 </semantics>
</math>

. It can be shown that 

<math display="inline" id="Sperner_family:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>H</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>b</ci>
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>H</ci>
     </apply>
    </apply>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b(b(H))=H
  </annotation>
 </semantics>
</math>

 , so blockers give us a type of duality. We define 

<math display="inline" id="Sperner_family:12">
 <semantics>
  <mrow>
   <mi>ν</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ν</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu(H)
  </annotation>
 </semantics>
</math>

 to be the size of the largest collection of disjoint edges in <em>H</em> and 

<math display="inline" id="Sperner_family:13">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>τ</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau(H)
  </annotation>
 </semantics>
</math>

 to be the size of the smallest edge in 

<math display="inline" id="Sperner_family:14">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>b</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b(H)
  </annotation>
 </semantics>
</math>

. It is easy to see that 

<math display="inline" id="Sperner_family:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>ν</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>H</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>τ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>H</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>ν</ci>
     <ci>H</ci>
    </apply>
    <apply>
     <times></times>
     <ci>τ</ci>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu(H)\leq\tau(H)
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="examples">Examples</h3>
<ol>
<li>If <em>G</em> is a simple loopless graph, then 

<math display="inline" id="Sperner_family:16">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>G</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>G</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>G</ci>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>G</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=(V(G),E(G))
  </annotation>
 </semantics>
</math>

 is a clutter and 

<math display="inline" id="Sperner_family:17">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>b</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b(H)
  </annotation>
 </semantics>
</math>

 is the collection of all minimal <a href="vertex_cover" title="wikilink">vertex covers</a>. Here 

<math display="inline" id="Sperner_family:18">
 <semantics>
  <mrow>
   <mi>ν</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ν</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu(H)
  </annotation>
 </semantics>
</math>

 is the size of the largest matching and 

<math display="inline" id="Sperner_family:19">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>τ</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau(H)
  </annotation>
 </semantics>
</math>

 is the size of the smallest vertex cover. <a href="König's_theorem_(graph_theory)" title="wikilink">König's theorem</a> states that, for <a href="bipartite_graph" title="wikilink">bipartite graphs</a>, 

<math display="inline" id="Sperner_family:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>ν</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>H</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>τ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>H</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ν</ci>
     <ci>H</ci>
    </apply>
    <apply>
     <times></times>
     <ci>τ</ci>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu(H)=\tau(H)
  </annotation>
 </semantics>
</math>

. However for other graphs these two quantities may differ.</li>
<li>Let <em>G</em> be a graph and let 

<math display="inline" id="Sperner_family:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mo>,</mo>
    <mi>t</mi>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>s</ci>
     <ci>t</ci>
    </list>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s,t\in V(G)
  </annotation>
 </semantics>
</math>

. Define 

<math display="inline" id="Sperner_family:22">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=(V,E)
  </annotation>
 </semantics>
</math>

 by setting 

<math display="inline" id="Sperner_family:23">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>V</ci>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V=E(G)
  </annotation>
 </semantics>
</math>

 and letting <em>E</em> be the collection of all edge-sets of <em>s</em>-<em>t</em> paths. Then <em>H</em> is a clutter, and 

<math display="inline" id="Sperner_family:24">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>b</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b(H)
  </annotation>
 </semantics>
</math>

 is the collection of all minimal edge cuts which separate <em>s</em> and <em>t</em>. In this case 

<math display="inline" id="Sperner_family:25">
 <semantics>
  <mrow>
   <mi>ν</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ν</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu(H)
  </annotation>
 </semantics>
</math>

 is the maximum number of edge-disjoint <em>s</em>-<em>t</em> paths, and 

<math display="inline" id="Sperner_family:26">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>τ</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau(H)
  </annotation>
 </semantics>
</math>

 is the size of the smallest edge-cut separating <em>s</em> and <em>t</em>, so <a href="Menger's_theorem" title="wikilink">Menger's theorem</a> (edge-connectivity version) asserts that 

<math display="inline" id="Sperner_family:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>ν</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>H</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>τ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>H</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ν</ci>
     <ci>H</ci>
    </apply>
    <apply>
     <times></times>
     <ci>τ</ci>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu(H)=\tau(H)
  </annotation>
 </semantics>
</math>

.</li>
<li>Let <em>G</em> be a connected graph and let <em>H</em> be the clutter on 

<math display="inline" id="Sperner_family:28">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(G)
  </annotation>
 </semantics>
</math>

 consisting of all edge sets of spanning trees of <em>G</em>. Then 

<math display="inline" id="Sperner_family:29">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>b</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b(H)
  </annotation>
 </semantics>
</math>

 is the collection of all minimal edge cuts in <em>G</em>.</li>
</ol>
<h3 id="minors">Minors</h3>

<p>There is a minor relation on clutters which is similar to the <a href="minor_(graph_theory)" title="wikilink">minor relation</a> on graphs. If 

<math display="inline" id="Sperner_family:30">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H=(V,E)
  </annotation>
 </semantics>
</math>

 is a clutter and 

<math display="inline" id="Sperner_family:31">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in V
  </annotation>
 </semantics>
</math>

, then we may <strong>delete</strong> <em>v</em> to get the clutter 

<math display="inline" id="Sperner_family:32">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>∖</mo>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <setdiff></setdiff>
    <ci>H</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H\setminus v
  </annotation>
 </semantics>
</math>

 with vertex set 

<math display="inline" id="Sperner_family:33">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>∖</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>v</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <setdiff></setdiff>
    <ci>V</ci>
    <set>
     <ci>v</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\setminus\{v\}
  </annotation>
 </semantics>
</math>

 and edge set consisting of all 

<math display="inline" id="Sperner_family:34">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∈</mo>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>A</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in E
  </annotation>
 </semantics>
</math>

 which do not contain <em>v</em>. We <strong>contract</strong> <em>v</em> to get the clutter 

<math display="inline" id="Sperner_family:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mo>/</mo>
    <mi>v</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>b</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>b</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>H</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>∖</mo>
      <mi>v</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>H</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <times></times>
     <ci>b</ci>
     <apply>
      <setdiff></setdiff>
      <apply>
       <times></times>
       <ci>b</ci>
       <ci>H</ci>
      </apply>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H/v=b(b(H)\setminus v)
  </annotation>
 </semantics>
</math>

. These two operations commute, and if <em>J</em> is another clutter, we say that <em>J</em> is a <strong>minor</strong> of <em>H</em> if a clutter isomorphic to <em>J</em> may be obtained from <em>H</em> by a sequence of deletions and contractions.</p>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Set_families" title="wikilink">Category:Set families</a></p>
</body>
</html>
