<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="425">Forcing (mathematics)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Forcing (mathematics)</h1>
<hr/>

<p>In the mathematical discipline of <a href="set_theory" title="wikilink">set theory</a>, <strong>forcing</strong> is a technique discovered by <a href="Paul_Cohen_(mathematician)" title="wikilink">Paul Cohen</a> for proving <a class="uri" href="consistency" title="wikilink">consistency</a> and <a href="independence_(mathematical_logic)" title="wikilink">independence</a> results. It was first used, in 1963, to prove the independence of the <a href="axiom_of_choice" title="wikilink">axiom of choice</a> and the <a href="continuum_hypothesis" title="wikilink">continuum hypothesis</a> from <a href="Zermelo–Fraenkel_set_theory" title="wikilink">Zermelo–Fraenkel set theory</a>. Forcing was considerably reworked and simplified in the following years, and has since served as a powerful technique both in set theory and in areas of <a href="mathematical_logic" title="wikilink">mathematical logic</a> such as <a href="recursion_theory" title="wikilink">recursion theory</a>.</p>

<p><a href="Descriptive_set_theory" title="wikilink">Descriptive set theory</a> uses the notion of forcing from both recursion theory and set theory. Forcing has also been used in <a href="model_theory" title="wikilink">model theory</a> but it is common in model theory to define <a href="generic_(mathematics)" title="wikilink">genericity</a> directly without mention of forcing.</p>
<h2 id="intuitions">Intuitions</h2>

<p>Forcing is equivalent to the method of <a href="Boolean-valued_model" title="wikilink">Boolean-valued models</a>, which some feel is conceptually more natural and intuitive, but usually much more difficult to apply.</p>

<p>Intuitively, forcing consists of expanding the set theoretical <a href="universe_(mathematics)" title="wikilink">universe</a> <em>V</em> to a larger universe <em>V</em>*. In this bigger universe, for example, one might have lots of new <a href="subset" title="wikilink">subsets</a> of <a href="Aleph_number#Aleph-naught" title="wikilink"><em>ω</em></a> = 

<math display="inline" id="Forcing_(mathematics):0">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {0,1,2,…}
  </annotation>
 </semantics>
</math>

 that were not there in the old universe, and thereby violate the <a href="continuum_hypothesis" title="wikilink">continuum hypothesis</a>. While impossible on the face of it, this is just another version of <a href="Cantor's_paradox" title="wikilink">Cantor's paradox</a> about infinity. In principle, one could consider</p>

<p>

<math display="block" id="Forcing_(mathematics):1">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>V</mi>
     <mo>*</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <mi>V</mi>
     <mo>×</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <times></times>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V^{*}=V\times\{0,1\},\,
  </annotation>
 </semantics>
</math>

</p>

<p>identify 

<math display="inline" id="Forcing_(mathematics):2">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in V
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Forcing_(mathematics):3">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mn>0</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <cn type="integer">0</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,0)
  </annotation>
 </semantics>
</math>

, and then introduce an expanded membership relation involving the "new" sets of the form 

<math display="inline" id="Forcing_(mathematics):4">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,1)
  </annotation>
 </semantics>
</math>

. Forcing is a more elaborate version of this idea, reducing the expansion to the existence of one new set, and allowing for fine control over the properties of the expanded universe.</p>

<p>Cohen's original technique, now called <a href="ramified_forcing" title="wikilink">ramified forcing</a>, is slightly different from the <strong>unramified forcing</strong> expounded here.</p>
<h2 id="forcing-posets">Forcing posets</h2>

<p>A <strong>forcing poset</strong> is an ordered triple, 

<math display="inline" id="Forcing_(mathematics):5">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>P</mi>
   <mo>,</mo>
   <mi mathvariant="normal">≤</mi>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>P</ci>
    <ci>normal-≤</ci>
    <cn type="integer">1</cn>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P,≤,1)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Forcing_(mathematics):6">
 <semantics>
  <mi mathvariant="normal">≤</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-≤</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ≤
  </annotation>
 </semantics>
</math>

 is a <a class="uri" href="preorder" title="wikilink">preorder</a> on 

<math display="inline" id="Forcing_(mathematics):7">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 that satisfies following splitting condition:</p>
<ul>
<li>For all 

<math display="inline" id="Forcing_(mathematics):8">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mi mathvariant="normal">∈</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>normal-∈</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p∈P
  </annotation>
 </semantics>
</math>

, there are 

<math display="inline" id="Forcing_(mathematics):9">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>,</mo>
   <mrow>
    <mi>r</mi>
    <mi mathvariant="normal">∈</mi>
    <mi>P</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>q</ci>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>normal-∈</ci>
     <ci>P</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q,r∈P
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Forcing_(mathematics):10">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>,</mo>
   <mrow>
    <mi>r</mi>
    <mi mathvariant="normal">≤</mi>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>q</ci>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>normal-≤</ci>
     <ci>p</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q,r≤p
  </annotation>
 </semantics>
</math>

 with no 

<math display="inline" id="Forcing_(mathematics):11">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi mathvariant="normal">∈</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>normal-∈</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s∈P
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Forcing_(mathematics):12">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mi mathvariant="normal">≤</mi>
    <mi>q</mi>
   </mrow>
   <mo>,</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>normal-≤</ci>
     <ci>q</ci>
    </apply>
    <ci>r</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s≤q,r
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>The largest element of 

<math display="inline" id="Forcing_(mathematics):13">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Forcing_(mathematics):14">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

, that is, 

<math display="inline" id="Forcing_(mathematics):15">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mi mathvariant="normal">≤</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>normal-≤</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p≤1
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Forcing_(mathematics):16">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mi mathvariant="normal">∈</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>normal-∈</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p∈P
  </annotation>
 </semantics>
</math>

. Members of 

<math display="inline" id="Forcing_(mathematics):17">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 are called <strong>forcing conditions</strong> or just <strong>conditions</strong>. One reads 

<math display="inline" id="Forcing_(mathematics):18">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mi mathvariant="normal">≤</mi>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>normal-≤</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p≤q
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Forcing_(mathematics):19">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is <strong>stronger</strong> than 

<math display="inline" id="Forcing_(mathematics):20">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

. Intuitively, the "smaller" condition provides "more" information, just as the smaller interval [3.1415926,3.1415927] provides more information about the number <a href="Pi" title="wikilink">π</a> than the interval [3.1,3.2] does.</p>

<p>There are various conventions in use. Some authors require 

<math display="inline" id="Forcing_(mathematics):21">
 <semantics>
  <mi mathvariant="normal">≤</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-≤</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ≤
  </annotation>
 </semantics>
</math>

 to also be <a href="antisymmetric_relation" title="wikilink">antisymmetric</a>, so that the relation is a <a href="partial_order" title="wikilink">partial order</a>. Some use the term <a href="partial_order" title="wikilink">partial order</a> anyway, conflicting with standard terminology, while some use the term <a class="uri" href="preorder" title="wikilink">preorder</a>. The largest element can be dispensed with. The reverse ordering is also used, most notably by <a href="Saharon_Shelah" title="wikilink">Saharon Shelah</a> and his co-authors.</p>
<h3 id="p-names">P-names</h3>

<p>Associated with a forcing poset 

<math display="inline" id="Forcing_(mathematics):22">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is the class <mtpl></mtpl> of 

<math display="inline" id="Forcing_(mathematics):23">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

-<strong>names</strong>. 

<math display="inline" id="Forcing_(mathematics):24">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

-names are sets of the form</p>
<ul>
<li>

<math display="inline" id="Forcing_(mathematics):25">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:</mo>
   <mi>u</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-:</ci>
    <csymbol cd="unknown">u</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{(}}(u,p):u
  </annotation>
 </semantics>
</math>

 is a 

<math display="inline" id="Forcing_(mathematics):26">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

-name and 

<math display="inline" id="Forcing_(mathematics):27">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mi mathvariant="normal">∈</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>normal-∈</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p∈P
  </annotation>
 </semantics>
</math>

 and (some criterion involving 

<math display="inline" id="Forcing_(mathematics):28">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Forcing_(mathematics):29">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

)

<math display="inline" id="Forcing_(mathematics):30">
 <semantics>
  <mo stretchy="false">)</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-)</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{)}}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Using <a href="transfinite_recursion" title="wikilink">transfinite recursion</a>, one defines</p>
<ul>
<li>

<math display="inline" id="Forcing_(mathematics):31">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <mi>a</mi>
    <mi>m</mi>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>a</ci>
     <ci>m</ci>
     <ci>e</ci>
     <cn type="integer">0</cn>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Name(0)={}
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Forcing_(mathematics):32">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mi>a</mi>
   <mi>m</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>α</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>a</ci>
    <ci>m</ci>
    <ci>e</ci>
    <apply>
     <plus></plus>
     <ci>α</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Name(α+1)
  </annotation>
 </semantics>
</math>

 = the power set of 

<math display="inline" id="Forcing_(mathematics):33">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>N</mi>
    <mi>a</mi>
    <mi>m</mi>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>α</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">×</mi>
    <mi>P</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>a</ci>
    <ci>m</ci>
    <ci>e</ci>
    <ci>α</ci>
    <ci>normal-×</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Name(α)×P)
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Forcing_(mathematics):34">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>and then the class of 

<math display="inline" id="Forcing_(mathematics):37">
 <semantics>
  <mo stretchy="false">)</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-)</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {{)}}
  </annotation>
 </semantics>
</math>

-names is defined by</p>
<dl>
<dd><mtpl> ∪{{(}}Name(α) : α}}</mtpl> is an ordinal

<math display="inline" id="Forcing_(mathematics):38">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>

<p>The 

<math display="inline" id="Forcing_(mathematics):39">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mi mathvariant="normal">∈</mi>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>normal-∈</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x∈V
  </annotation>
 </semantics>
</math>

-names are, in fact, an expansion of the <a href="von_Neumann_universe" title="wikilink">universe</a>. Given 

<math display="inline" id="Forcing_(mathematics):40">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mi mathvariant="normal">ˇ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>normal-ˇ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   xˇ
  </annotation>
 </semantics>
</math>

, one defines 

<math display="inline" id="Forcing_(mathematics):41">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 to be the 

<math display="inline" id="Forcing_(mathematics):42">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mi mathvariant="normal">ˇ</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>y</mi>
      <mi mathvariant="normal">ˇ</mi>
     </mrow>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>y</mi>
    <mi mathvariant="normal">∈</mi>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>normal-ˇ</ci>
     </apply>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>y</ci>
       <ci>normal-ˇ</ci>
      </apply>
      <cn type="integer">1</cn>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>normal-∈</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   xˇ={(yˇ,1):y∈x}
  </annotation>
 </semantics>
</math>

-name</p>
<dl>
<dd>

<math display="inline" id="Forcing_(mathematics):43">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>

<p>Again, this is really a definition by transfinite recursion.</p>
<h3 id="interpretation">Interpretation</h3>

<p>Given any subset 

<math display="inline" id="Forcing_(mathematics):44">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Forcing_(mathematics):45">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, one next defines the <strong>interpretation</strong> or <strong>valuation</strong> map from 

<math display="inline" id="Forcing_(mathematics):46">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>v</mi>
     <mi>a</mi>
     <mi>l</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>G</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>v</mi>
     <mi>a</mi>
     <mi>l</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>G</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">∃</mi>
     <mi>p</mi>
     <mi mathvariant="normal">∈</mi>
     <mi>G</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>v</mi>
      <mo>,</mo>
      <mi>p</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">∈</mi>
     <mi>u</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>v</ci>
      <ci>a</ci>
      <ci>l</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>G</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>v</ci>
      <ci>a</ci>
      <ci>l</ci>
      <interval closure="open">
       <ci>v</ci>
       <ci>G</ci>
      </interval>
     </apply>
    </apply>
    <list>
     <apply>
      <times></times>
      <ci>normal-∃</ci>
      <ci>p</ci>
      <ci>normal-∈</ci>
      <ci>G</ci>
     </apply>
     <apply>
      <times></times>
      <interval closure="open">
       <ci>v</ci>
       <ci>p</ci>
      </interval>
      <ci>normal-∈</ci>
      <ci>u</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   val(u,G)={val(v,G):∃p∈G,(v,p)∈u}
  </annotation>
 </semantics>
</math>

-names by</p>
<dl>
<dd>

<math display="inline" id="Forcing_(mathematics):47">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>

<p>(Again a definition by transfinite recursion.) Note that if 

<math display="inline" id="Forcing_(mathematics):48">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is in 

<math display="inline" id="Forcing_(mathematics):49">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mi>a</mi>
    <mi>l</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mi mathvariant="normal">ˇ</mi>
     </mrow>
     <mo>,</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>a</ci>
     <ci>l</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>normal-ˇ</ci>
      </apply>
      <ci>G</ci>
     </interval>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   val(xˇ,G)=x
  </annotation>
 </semantics>
</math>

, then</p>
<dl>
<dd>

<math display="inline" id="Forcing_(mathematics):50">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>B</mi>
    <mi>o</mi>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐈</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">⊆</mi>
   <mo>,</mo>
   <mi>𝐈</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <times></times>
     <ci>B</ci>
     <ci>o</ci>
     <ci>r</ci>
     <ci>𝐈</ci>
    </apply>
    <ci>normal-⊆</ci>
    <ci>𝐈</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Bor(\mathbf{I}),⊆,\mathbf{I})
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>

<p>One defines</p>
<dl>
<dd><mtpl>  }}</mtpl>,
</dd>
</dl>

<p>so that</p>
<dl>
<dd><mtpl> G}}</mtpl>.
</dd>
</dl>
<h3 id="example">Example</h3>

<p>A good example of a forcing poset is 

<math display="inline" id="Forcing_(mathematics):51">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>11</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>I</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">11</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I=0,11
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Forcing_(mathematics):52">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mi>o</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <ci>o</ci>
    <ci>r</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Bor(I)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Forcing_(mathematics):53">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 are the <a href="Borel_subset" title="wikilink">Borel subsets</a> of 

<math display="inline" id="Forcing_(mathematics):54">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mi>o</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <ci>o</ci>
    <ci>r</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Bor(I)
  </annotation>
 </semantics>
</math>

 having non-zero <a href="Lebesgue_measure" title="wikilink">Lebesgue measure</a>. In this case, one can talk about the conditions as being probabilities, and a 

<math display="inline" id="Forcing_(mathematics):55">
 <semantics>
  <msub>
   <mo>⊩</mo>
   <mrow>
    <mi>M</mi>
    <mo>,</mo>
    <mi>P</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">forces</csymbol>
    <list>
     <ci>M</ci>
     <ci>P</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Vdash_{M,P}
  </annotation>
 </semantics>
</math>

-name assigns membership in a probabilistic sense. Because of the ready intuition this example can provide, probabilistic language is sometimes used with other forcing posets.</p>
<h2 id="countable-transitive-models-and-generic-filters">Countable transitive models and generic filters</h2>

<p>The key step in forcing is, given a ZFC universe <em>V</em>, to find appropriate <em>G</em> not in <em>V</em>. The resulting class of all interpretations of <strong>P</strong>-names will turn out to be a model of ZFC, properly extending the original <em>V</em> (since <em>G</em>∉<em>V</em>).</p>

<p>Instead of working with <em>V</em>, one considers a <strong>countable transitive model</strong> <strong>M</strong> with (<strong>P</strong>,≤,1) ∈ <strong>M</strong>. By model, we mean a model of set theory, either of all of ZFC, or a model of a large but finite subset of the ZFC axioms, or some variant thereof. Transitivity means that if <em>x</em> ∈ <em>y</em> ∈ <strong>M</strong>, then <em>x</em> ∈ <strong>M</strong>. The <a href="Mostowski_collapse" title="wikilink">Mostowski collapsing theorem</a> says this can be assumed if the membership relation is <a class="uri" href="well-founded" title="wikilink">well-founded</a>. The effect of transitivity is that membership and other elementary notions can be handled intuitively. Countability of the model relies on the <a href="Löwenheim–Skolem_theorem" title="wikilink">Löwenheim–Skolem theorem</a>.</p>

<p>Since <strong>M</strong> is a set, there are sets not in <strong>M</strong> – this follows from <a href="Russell's_paradox" title="wikilink">Russell's paradox</a>. The appropriate set <strong>G</strong> to pick, and adjoin to <strong>M</strong>, is a <strong>generic filter</strong> on <strong>P</strong>. The <em>filter</em> condition means that <em>G</em>⊆<strong>P</strong> and</p>

<p>:*1 ∈ <em>G</em> ;</p>

<p>:*if <em>p</em> ≥ <em>q</em> ∈ <em>G</em>, then <em>p</em> ∈ <em>G</em> ;</p>

<p>:*if <em>p</em>,<em>q</em> ∈ <em>G</em>, then ∃<em>r</em> ∈ <em>G</em>, <em>r</em> ≤ <em>p</em> and <em>r</em> ≤ <em>q</em> ; For <em>G</em> to be <em>generic</em> means</p>

<p>:*if <em>D</em> ∈ <strong>M</strong> is a <em>dense</em> subset of <strong>P</strong> (that is, <em>p</em> ∈ <strong>P</strong> implies ∃<em>q</em> ∈ <em>D</em>, <em>q</em> ≤ <em>p</em>) then <em>G</em>∩<em>D</em> ≠ 0 .</p>

<p>The existence of a generic filter <em>G</em> follows from the <a href="Rasiowa–Sikorski_lemma" title="wikilink">Rasiowa–Sikorski lemma</a>. In fact, slightly more is true: given a condition <em>p</em> ∈ <strong>P</strong>, one can find a generic filter <em>G</em> such that <em>p</em> ∈ <em>G</em>. Due to the splitting condition, if <em>G</em> is filter, then <strong>P</strong>\<em>G</em> is dense. If <em>G</em> is in <strong>M</strong> then <strong>P</strong>\<em>G</em> is in <strong>M</strong> because <strong>M</strong> is model of set theory. By this reason, a generic filter is never in <strong>M</strong>.</p>
<h2 id="forcing">Forcing</h2>

<p>Given a generic filter <em>G</em>⊆<strong>P</strong>, one proceeds as follows. The subclass of <strong>P</strong>-names in <strong>M</strong> is denoted <strong>M</strong><sup>(<strong>P</strong>)</sup>. Let <strong>M</strong>[<em>G</em>]=<mtpl></mtpl>. To reduce the study of the set theory of <strong>M</strong>[<em>G</em>] to that of <strong>M</strong>, one works with the <em>forcing language</em>, which is built up like ordinary <a href="first-order_logic" title="wikilink">first-order logic</a>, with membership as binary relation and all the names as constants.</p>

<p>Define <em>p</em> 

<math display="inline" id="Forcing_(mathematics):56">
 <semantics>
  <msub>
   <mo>⊩</mo>
   <mrow>
    <mi>M</mi>
    <mo>,</mo>
    <mi>P</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">forces</csymbol>
    <list>
     <ci>M</ci>
     <ci>P</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Vdash_{M,P}
  </annotation>
 </semantics>
</math>

 φ(<em>u</em><sub>1</sub>,…,<em>u</em><sub><em>n</em></sub>) (read "<em>p</em> forces φ in model <strong>M</strong> with poset P") where <em>p</em> is a condition, φ is a formula in the forcing language, and the <em>u</em><sub><em>i</em></sub> are names, to mean that if <em>G</em> is a generic filter containing <em>p</em>, then <strong>M</strong>[<em>G</em>] ⊨ φ(val(<em>u</em><sub>1</sub>,<em>G</em>),…,val(<em>u</em><sub><em>n</em></sub>,<em>G</em>)). The special case 1 

<math display="inline" id="Forcing_(mathematics):57">
 <semantics>
  <msub>
   <mo>⊩</mo>
   <mrow>
    <mi>M</mi>
    <mo>,</mo>
    <mi>P</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">forces</csymbol>
    <list>
     <ci>M</ci>
     <ci>P</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Vdash_{M,P}
  </annotation>
 </semantics>
</math>

 φ is often written <strong>P</strong> 

<math display="inline" id="Forcing_(mathematics):58">
 <semantics>
  <msub>
   <mo>⊩</mo>
   <mrow>
    <mi>M</mi>
    <mo>,</mo>
    <mi>P</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">forces</csymbol>
    <list>
     <ci>M</ci>
     <ci>P</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Vdash_{M,P}
  </annotation>
 </semantics>
</math>

 φ or 

<math display="inline" id="Forcing_(mathematics):59">
 <semantics>
  <msub>
   <mo>⊩</mo>
   <mrow>
    <mi>M</mi>
    <mo>,</mo>
    <mi>P</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">forces</csymbol>
    <list>
     <ci>M</ci>
     <ci>P</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Vdash_{M,P}
  </annotation>
 </semantics>
</math>

 φ. Such statements are true in <strong>M</strong>[<em>G</em>] no matter what <em>G</em> is.</p>

<p>What is important is that this "external" definition of the forcing relation <em>p</em> 

<math display="inline" id="Forcing_(mathematics):60">
 <semantics>
  <msub>
   <mo>⊩</mo>
   <mrow>
    <mi>M</mi>
    <mo>,</mo>
    <mi>P</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">forces</csymbol>
    <list>
     <ci>M</ci>
     <ci>P</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Vdash_{M,P}
  </annotation>
 </semantics>
</math>

 φ is equivalent to an "internal" definition, defined by transfinite induction over the names on instances of <em>u</em> ∈ <em>v</em> and <em>u</em> = <em>v</em>, and then by ordinary induction over the complexity of formulas. This has the effect that all the properties of <strong>M</strong>[<em>G</em>] are really properties of <strong>M</strong>, and the verification of ZFC in <strong>M</strong>[<em>G</em>] becomes straightforward. This is usually summarized as three key properties:</p>
<ul>
<li><strong>Truth</strong>: <strong>M</strong>[<em>G</em>] ⊨ φ(val(<em>u</em><sub>1</sub>,<em>G</em>),…,val(<em>u</em><sub><em>n</em></sub>,<em>G</em>)) <a href="if_and_only_if" title="wikilink">if and only if</a> it is forced by <em>G</em>, that is, for some condition <em>p</em> ∈ <em>G</em>, <em>p</em> 

<math display="inline" id="Forcing_(mathematics):61">
 <semantics>
  <msub>
   <mo>⊩</mo>
   <mrow>
    <mi>M</mi>
    <mo>,</mo>
    <mi>P</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">forces</csymbol>
    <list>
     <ci>M</ci>
     <ci>P</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Vdash_{M,P}
  </annotation>
 </semantics>
</math>

 φ(<em>u</em><sub>1</sub>,…,<em>u</em><sub><em>n</em></sub>).</li>
<li><strong>Definability</strong>: The statement "<em>p</em> 

<math display="inline" id="Forcing_(mathematics):62">
 <semantics>
  <msub>
   <mo>⊩</mo>
   <mrow>
    <mi>M</mi>
    <mo>,</mo>
    <mi>P</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">forces</csymbol>
    <list>
     <ci>M</ci>
     <ci>P</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Vdash_{M,P}
  </annotation>
 </semantics>
</math>

 φ(<em>u</em><sub>1</sub>,…,<em>u</em><sub><em>n</em></sub>)" is definable in <strong>M</strong>.</li>
<li><strong>Coherence</strong>: If <em>p</em> 

<math display="inline" id="Forcing_(mathematics):63">
 <semantics>
  <msub>
   <mo>⊩</mo>
   <mrow>
    <mi>M</mi>
    <mo>,</mo>
    <mi>P</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <csymbol cd="latexml">forces</csymbol>
    <list>
     <ci>M</ci>
     <ci>P</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Vdash_{M,P}
  </annotation>
 </semantics>
</math>

 φ(<em>u</em><sub>1</sub>,…,<em>u</em><sub><em>n</em></sub>) and <em>q</em> ≤ <em>p</em>, then <em>q</em> 

<math display="inline" id="Forcing_(mathematics):64">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 φ(<em>u</em><sub>1</sub>,…,<em>u</em><sub><em>n</em></sub>).</li>
</ul>

<p>We define the forcing relation in 

<math display="inline" id="Forcing_(mathematics):65">
 <semantics>
  <mrow>
   <mi>p</mi>
   <msub>
    <mo>⊩</mo>
    <mi>P</mi>
   </msub>
   <mi>a</mi>
   <mo>∈</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">forces</csymbol>
      <ci>P</ci>
     </apply>
     <ci>p</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\Vdash_{P}a\in b
  </annotation>
 </semantics>
</math>

 by induction on complexity, in which we simultaneously define forcing of atomic formulas by ∈-induction and then we define it by induction on formula complexity.</p>

<p>1. 

<math display="inline" id="Forcing_(mathematics):66">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>q</mi>
    <mo>≤</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∃</mo>
    <mi>r</mi>
    <mo>≤</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∃</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo>,</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>b</mi>
    <mo>∧</mo>
    <mi>r</mi>
    <mo>≤</mo>
    <mi>s</mi>
    <mo>∧</mo>
    <mi>r</mi>
    <msub>
     <mo>⊩</mo>
     <mi>P</mi>
    </msub>
    <mi>a</mi>
    <mo>=</mo>
    <mi>c</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">q</csymbol>
     <leq></leq>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">r</csymbol>
     <leq></leq>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">c</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">c</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">b</csymbol>
     <and></and>
     <csymbol cd="unknown">r</csymbol>
     <leq></leq>
     <csymbol cd="unknown">s</csymbol>
     <and></and>
     <csymbol cd="unknown">r</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">forces</csymbol>
      <ci>P</ci>
     </apply>
     <csymbol cd="unknown">a</csymbol>
     <eq></eq>
     <csymbol cd="unknown">c</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall q\leq p)(\exists r\leq q)(\exists s,c)((s,c)\in b\land r\leq s\land r%
\Vdash_{P}a=c)
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Forcing_(mathematics):67">
 <semantics>
  <mrow>
   <mi>p</mi>
   <msub>
    <mo>⊩</mo>
    <mi>P</mi>
   </msub>
   <mi>a</mi>
   <mo>=</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">forces</csymbol>
      <ci>P</ci>
     </apply>
     <ci>p</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\Vdash_{P}a=b
  </annotation>
 </semantics>
</math>

.</p>

<p>2. 

<math display="inline" id="Forcing_(mathematics):68">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>q</mi>
    <mo>≤</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>c</mi>
    <mo>∈</mo>
    <msup>
     <mi>V</mi>
     <mi>P</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>q</mi>
    <msub>
     <mo>⊩</mo>
     <mi>P</mi>
    </msub>
    <mi>c</mi>
    <mo>∈</mo>
    <mpadded width="+1.7pt">
     <mi>a</mi>
    </mpadded>
    <mo>⇔</mo>
    <mi>q</mi>
    <msub>
     <mo>⊩</mo>
     <mi>P</mi>
    </msub>
    <mi>c</mi>
    <mo>∈</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">q</csymbol>
     <leq></leq>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">c</csymbol>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <ci>P</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">q</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">forces</csymbol>
      <ci>P</ci>
     </apply>
     <csymbol cd="unknown">c</csymbol>
     <in></in>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-⇔</ci>
     <csymbol cd="unknown">q</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">forces</csymbol>
      <ci>P</ci>
     </apply>
     <csymbol cd="unknown">c</csymbol>
     <in></in>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall q\leq p)(\forall c\in V^{P})(q\Vdash_{P}c\in a\,\Leftrightarrow q%
\Vdash_{P}c\in b)
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Forcing_(mathematics):69">
 <semantics>
  <mrow>
   <mi>p</mi>
   <msub>
    <mo>⊩</mo>
    <mi>P</mi>
   </msub>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>f</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">forces</csymbol>
     <ci>P</ci>
    </apply>
    <ci>p</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\Vdash_{P}\lnot f
  </annotation>
 </semantics>
</math>

.</p>

<p>3. 

<math display="inline" id="Forcing_(mathematics):70">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mo>∃</mo>
        <mi>q</mi>
       </mrow>
       <mo>≤</mo>
       <mi>p</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mi>q</mi>
   </mrow>
   <msub>
    <mo>⊩</mo>
    <mi>P</mi>
   </msub>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">forces</csymbol>
     <ci>P</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <not></not>
      <apply>
       <leq></leq>
       <apply>
        <exists></exists>
        <ci>q</ci>
       </apply>
       <ci>p</ci>
      </apply>
     </apply>
     <ci>q</ci>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lnot(\exists q\leq p)q\Vdash_{P}f
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Forcing_(mathematics):71">
 <semantics>
  <mrow>
   <mi>p</mi>
   <msub>
    <mo>⊩</mo>
    <mi>P</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>f</mi>
     <mo>∧</mo>
     <mi>g</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">forces</csymbol>
     <ci>P</ci>
    </apply>
    <ci>p</ci>
    <apply>
     <and></and>
     <ci>f</ci>
     <ci>g</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\Vdash_{P}(f\land g)
  </annotation>
 </semantics>
</math>

.</p>

<p>4. 

<math display="inline" id="Forcing_(mathematics):72">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>p</mi>
    <msub>
     <mo>⊩</mo>
     <mi>P</mi>
    </msub>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>f</mi>
     </mpadded>
     <mo rspace="4.2pt">∧</mo>
     <mi>p</mi>
    </mrow>
    <msub>
     <mo>⊩</mo>
     <mi>P</mi>
    </msub>
    <mi>g</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">forces</csymbol>
      <ci>P</ci>
     </apply>
     <ci>p</ci>
     <apply>
      <and></and>
      <ci>f</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">forces</csymbol>
      <ci>P</ci>
     </apply>
     <share href="#.cmml">
     </share>
     <ci>g</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p\Vdash_{P}f\,\land\,p\Vdash_{P}g)
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Forcing_(mathematics):73">
 <semantics>
  <mrow>
   <mi>p</mi>
   <msub>
    <mo>⊩</mo>
    <mi>P</mi>
   </msub>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∀</mo>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>f</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">forces</csymbol>
     <ci>P</ci>
    </apply>
    <ci>p</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>x</ci>
     </apply>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\Vdash_{P}(\forall x)f
  </annotation>
 </semantics>
</math>

.</p>

<p>5. 

<math display="inline" id="Forcing_(mathematics):74">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <msup>
     <mi>V</mi>
     <mi>P</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>p</mi>
   <msub>
    <mo>⊩</mo>
    <mi>P</mi>
   </msub>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <ci>P</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">forces</csymbol>
     <ci>P</ci>
    </apply>
    <csymbol cd="unknown">f</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall x\in V^{P})p\Vdash_{P}f
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Forcing_(mathematics):75">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

.</p>

<p>In 1–5 

<math display="inline" id="Forcing_(mathematics):76">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is an arbitrary condition. In 1 and 2 

<math display="inline" id="Forcing_(mathematics):77">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Forcing_(mathematics):78">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 are arbitrary names and in 3–5 

<math display="inline" id="Forcing_(mathematics):79">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Forcing_(mathematics):80">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{1},\dots,x_{n})
  </annotation>
 </semantics>
</math>

 are arbitrary formulas where all free occurrences of variables referring names. This definition is syntax transform of formulas. This means that for any given formula 

<math display="inline" id="Forcing_(mathematics):81">
 <semantics>
  <mrow>
   <mi>p</mi>
   <msub>
    <mo>⊨</mo>
    <mi>P</mi>
   </msub>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-⊨</ci>
     <ci>P</ci>
    </apply>
    <ci>p</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\vDash_{P}f(x_{1},\dots,x_{n})
  </annotation>
 </semantics>
</math>

 the formula 

<math display="inline" id="Forcing_(mathematics):82">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>,</mo>
   <mi>P</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>p</ci>
    <ci>P</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p,P,x_{1},\dots,x_{n}
  </annotation>
 </semantics>
</math>

 with free variables 

<math display="inline" id="Forcing_(mathematics):83">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{1},\dots,x_{n})
  </annotation>
 </semantics>
</math>

 is well defined. In fact this syntax transform has following properties: any equivalence given by 1-5 is theorem (single theorem per formula) and for any formula 

<math display="inline" id="Forcing_(mathematics):84">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>P</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <msub>
     <mo>⊩</mo>
     <mi>P</mi>
    </msub>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⇒</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mi>o</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>P</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∧</mo>
     <mi>p</mi>
     <mo>∈</mo>
     <mi>d</mi>
     <mi>o</mi>
     <mi>m</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>P</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∧</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>∈</mo>
     <msup>
      <mi>V</mi>
      <mi>P</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">forces</csymbol>
      <ci>P</ci>
     </apply>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <ci>normal-…</ci>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-⇒</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <csymbol cd="unknown">o</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">P</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <and></and>
      <csymbol cd="unknown">p</csymbol>
      <in></in>
      <csymbol cd="unknown">d</csymbol>
      <csymbol cd="unknown">o</csymbol>
      <csymbol cd="unknown">m</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">P</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <and></and>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <ci>normal-…</ci>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <in></in>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>V</ci>
       <ci>P</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall p,P,x_{1},\dots,x_{n})(p\Vdash_{P}f(x_{1},\dots,x_{n})\Rightarrow(po(%
P)\land p\in dom(P)\land x_{1},\dots,x_{n}\in V^{P})
  </annotation>
 </semantics>
</math>

 following formula 

<math display="inline" id="Forcing_(mathematics):85">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>o</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   po(P)
  </annotation>
 </semantics>
</math>

 is theorem where 

<math display="inline" id="Forcing_(mathematics):86">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 means that 

<math display="inline" id="Forcing_(mathematics):87">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is partial order with splitting condition. The bit of definition is existence of syntax transform with these properties.</p>

<p>This definition provides the possibility of working in 

<math display="inline" id="Forcing_(mathematics):88">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 without any countable transitive model 

<math display="inline" id="Forcing_(mathematics):89">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>M</mi>
    <mo>,</mo>
    <mi>P</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mi>t</mi>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mi>p</mi>
    <mi>o</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>P</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mi>P</mi>
    <mo>∈</mo>
    <mi>M</mi>
    <mo>∧</mo>
    <mi>p</mi>
    <mo>∈</mo>
    <mi>d</mi>
    <mi>o</mi>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>P</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo>∈</mo>
    <msup>
     <mi>M</mi>
     <mi>P</mi>
    </msup>
    <mo>⇒</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <msub>
      <mo>⊩</mo>
      <mrow>
       <mi>M</mi>
       <mo>,</mo>
       <mi>P</mi>
      </mrow>
     </msub>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mo rspace="4.2pt">⇔</mo>
     <mi>M</mi>
     <mo>⊧</mo>
     <mi>p</mi>
     <msub>
      <mo>⊩</mo>
      <mi>P</mi>
     </msub>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">c</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <csymbol cd="unknown">m</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">M</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">o</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">P</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="unknown">P</csymbol>
     <in></in>
     <csymbol cd="unknown">M</csymbol>
     <and></and>
     <csymbol cd="unknown">p</csymbol>
     <in></in>
     <csymbol cd="unknown">d</csymbol>
     <csymbol cd="unknown">o</csymbol>
     <csymbol cd="unknown">m</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">P</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>M</ci>
      <ci>P</ci>
     </apply>
     <ci>normal-⇒</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">p</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">forces</csymbol>
       <list>
        <ci>M</ci>
        <ci>P</ci>
       </list>
      </apply>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-,</ci>
       <ci>normal-…</ci>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-⇔</ci>
      <csymbol cd="unknown">M</csymbol>
      <csymbol cd="latexml">models</csymbol>
      <csymbol cd="unknown">p</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">forces</csymbol>
       <ci>P</ci>
      </apply>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-,</ci>
       <ci>normal-…</ci>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall M,P,x_{1},\dots,x_{n})(ctm(M)\land po(P)\land P\in M\land p\in dom(P)%
\land x_{1},\dots,x_{n}\in M^{P}\Rightarrow(p\Vdash_{M,P}f(x_{1},\dots,x_{n})%
\,\Leftrightarrow\,M\models p\Vdash_{P}f(x_{1},\dots,x_{n})))
  </annotation>
 </semantics>
</math>

. The following statement gives announced definability:</p>

<p>

<math display="inline" id="Forcing_(mathematics):90">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mi>t</mi>
   <mi>m</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <ci>t</ci>
    <ci>m</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ctm(M)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Forcing_(mathematics):91">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 means that 

<math display="inline" id="Forcing_(mathematics):92">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Z</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ZF
  </annotation>
 </semantics>
</math>

 is countable transitive model satisfying some finite part of 

<math display="inline" id="Forcing_(mathematics):93">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 axioms depending on formula 

<math display="inline" id="Forcing_(mathematics):94">
 <semantics>
  <mo>⊩</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">forces</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Vdash
  </annotation>
 </semantics>
</math>

.</p>

<p>(Where no confusion is possible we simply write 

<math display="inline" id="Forcing_(mathematics):95">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {0,1}
  </annotation>
 </semantics>
</math>

.)</p>
<h2 id="consistency">Consistency</h2>

<p>The above can be summarized by saying the fundamental consistency result is that given a forcing poset <strong>P</strong>, we may assume that there exists a generic filter <em>G</em>, not in the universe <em>V</em>, such that <em>V</em>[<em>G</em>] is again a set theoretic universe, modelling ZFC. Furthermore, all truths in <em>V</em>[<em>G</em>] can be reduced to truths in <em>V</em> regarding the forcing relation.</p>

<p>Both styles, adjoining <em>G</em> to a countable transitive model <strong>M</strong> or to the whole universe <em>V</em>, are commonly used. Less commonly seen is the approach using the "internal" definition of forcing, and no mention of set or class models is made. This was Cohen's original method, and in one elaboration, it becomes the method of Boolean-valued analysis.</p>
<h2 id="cohen-forcing">Cohen forcing</h2>

<p>The simplest nontrivial forcing poset is ( Fin(ω,2), ⊇, 0 ), the finite partial functions from ω to 2=

<math display="inline" id="Forcing_(mathematics):96">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>:</mo>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>i</mi>
    <mi>s</mi>
    <mi>d</mi>
    <mi>e</mi>
    <mi>f</mi>
    <mi>i</mi>
    <mi>n</mi>
    <mi>e</mi>
    <mi>d</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>p</ci>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>n</ci>
     <ci>i</ci>
     <ci>s</ci>
     <ci>d</ci>
     <ci>e</ci>
     <ci>f</ci>
     <ci>i</ci>
     <ci>n</ci>
     <ci>e</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {p:p(n)isdefined}
  </annotation>
 </semantics>
</math>

 under <em>reverse</em> inclusion. That is, a condition <em>p</em> is essentially two disjoint finite subsets <em>p</em><sup>−1</sup>[1] and <em>p</em><sup>−1</sup>[0] of ω, to be thought of as the "yes" and "no" parts of <em>p</em>, with no information provided on values outside the domain of <em>p</em>. <em>q</em> is stronger than <em>p</em> means that <em>q</em> ⊇ <em>p</em>, in other words, the "yes" and "no" parts of <em>q</em> are supersets of the "yes" and "no" parts of <em>p</em>, and in that sense, provide more information.</p>

<p>Let <em>G</em> be a generic filter for this poset. If <em>p</em> and <em>q</em> are both in <em>G</em>, then <em>p</em>∪<em>q</em> is a condition, because <em>G</em> is a filter. This means that <em>g</em>=⋃<em>G</em> is a well-defined partial function from ω to 2, because any two conditions in <em>G</em> agree on their common domain.</p>

<p><em>g</em> is in fact a total function. Given <em>n</em> ∈ ω, let <em>D</em><sub><em>n</em></sub>=

<math display="inline" id="Forcing_(mathematics):97">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi mathvariant="normal">ˇ</mi>
    </mrow>
    <mo>,</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>normal-ˇ</ci>
     </apply>
     <ci>p</ci>
    </interval>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>n</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {(nˇ,p):p(n)=1}
  </annotation>
 </semantics>
</math>

, then <em>D</em><sub><em>n</em></sub> is dense. (Given any <em>p</em>, if <em>n</em> is not in <em>p</em>’s domain, adjoin a value for <em>n</em>, the result is in <em>D</em><sub><em>n</em></sub>.) A condition <em>p</em> ∈ <em>G</em>∩<em>D</em><sub><em>n</em></sub> has <em>n</em> in its domain, and since <em>p</em> ⊆ <em>g</em>, <em>g</em>(<em>n</em>) is defined.</p>

<p>Let <em>X</em>=<em>g</em><sup>−1</sup>[1], the set of all "yes" members of the generic conditions. It is possible to give a name for <em>X</em> directly. Let <u><em>X</em></u> = 

<math display="inline" id="Forcing_(mathematics):98">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi mathvariant="normal">∃</mi>
      <mi>n</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>n</mi>
      <mi mathvariant="normal">∈</mi>
      <mi>d</mi>
      <mi>o</mi>
      <mi>m</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>p</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>a</mi>
      <mi>n</mi>
      <mi>d</mi>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mi>i</mi>
     <mi>f</mi>
     <mi>a</mi>
     <mi>n</mi>
     <mi>d</mi>
     <mi>o</mi>
     <mi>n</mi>
     <mi>l</mi>
     <mi>y</mi>
     <mi>i</mi>
     <mi>f</mi>
     <mi>n</mi>
     <mi mathvariant="normal">∉</mi>
     <mi>A</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>p</ci>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <times></times>
       <ci>normal-∃</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>normal-∈</ci>
       <ci>d</ci>
       <ci>o</ci>
       <ci>m</ci>
       <ci>p</ci>
       <ci>a</ci>
       <ci>n</ci>
       <ci>d</ci>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
     </list>
     <apply>
      <times></times>
      <cn type="integer">1</cn>
      <ci>i</ci>
      <ci>f</ci>
      <ci>a</ci>
      <ci>n</ci>
      <ci>d</ci>
      <ci>o</ci>
      <ci>n</ci>
      <ci>l</ci>
      <ci>y</ci>
      <ci>i</ci>
      <ci>f</ci>
      <ci>n</ci>
      <ci>normal-∉</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {p:∃n,n∈dom(p)andp(n)=1ifandonlyifn∉A}
  </annotation>
 </semantics>
</math>

, then val( <u><em>X</em></u>, <em>G</em> ) = <em>X</em>. Now suppose <em>A</em>⊆ω in <em>V</em>. We claim that <em>X</em>≠<em>A</em>. Let <em>D</em><sub><em>A</em></sub> = 

<math display="inline" id="Forcing_(mathematics):99">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">∃</mi>
     <mi>n</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>,</mo>
      <mi>α</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">≠</mi>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>,</mo>
      <mi>β</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>p</ci>
    <list>
     <apply>
      <times></times>
      <ci>normal-∃</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>p</ci>
      <interval closure="open">
       <ci>n</ci>
       <ci>α</ci>
      </interval>
      <ci>normal-≠</ci>
      <ci>p</ci>
      <interval closure="open">
       <ci>n</ci>
       <ci>β</ci>
      </interval>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {p:∃n,p(n,α)≠p(n,β)}
  </annotation>
 </semantics>
</math>

. <em>D</em><sub><em>A</em></sub> is dense. (Given any <em>p</em>, if <em>n</em> is not in <em>p</em>’s domain, adjoin a value for <em>n</em> contrary to the status of "<em>n</em>∈<em>A</em>".) Then any <em>p</em>∈<em>G</em>∩<em>D</em><sub><em>A</em></sub> witnesses <em>X</em>≠<em>A</em>. To summarize, <em>X</em> is a <em>new</em> subset of ω, necessarily infinite.</p>

<p>Replacing ω with ω×ω<sub>2</sub>, that is, consider instead finite partial functions whose inputs are of the form (<em>n</em>,α), with <em>n</em>&lt;ω and α2, and whose outputs are 0 or 1, one gets ω<sub>2</sub> new subsets of ω. They are all distinct, by a density argument: given α2, let <em>D</em><sub>α,β</sub>=

<math display="inline" id="Forcing_(mathematics):100">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mi mathvariant="normal">≤</mi>
     <mi>q</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>s</mi>
     <mi>o</mi>
     <mi>m</mi>
     <mi>e</mi>
     <mi>q</mi>
     <mi mathvariant="normal">∈</mi>
     <mi>A</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>p</ci>
    <list>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>normal-≤</ci>
      <ci>q</ci>
     </apply>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>o</ci>
      <ci>m</ci>
      <ci>e</ci>
      <ci>q</ci>
      <ci>normal-∈</ci>
      <ci>A</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {p:p≤q,someq∈A}
  </annotation>
 </semantics>
</math>

, then each <em>D</em><sub>α,β</sub> is dense, and a generic condition in it proves that the αth new set disagrees somewhere with the βth new set.</p>

<p>This is not yet the falsification of the continuum hypothesis. One must prove that no new maps have been introduced which map ω onto ω<sub>1</sub> or ω<sub>1</sub> onto ω<sub>2</sub>. For example, if one considers instead Fin(ω,ω<sub>1</sub>), finite partial functions from ω to ω<sub>1</sub>, the <a href="first_uncountable_ordinal" title="wikilink">first uncountable ordinal</a>, one gets in <em>V</em>[<em>G</em>] a bijection from ω to ω<sub>1</sub>. In other words, ω<sub>1</sub> has <em>collapsed</em>, and in the forcing extension, is a countable ordinal.</p>

<p>The last step in showing the independence of the continuum hypothesis, then, is to show that Cohen forcing does not collapse cardinals. For this, a sufficient combinatorial property is that all of the <a href="antichain" title="wikilink">antichains</a> of this poset are countable.</p>
<h2 id="the-countable-chain-condition">The countable chain condition</h2>

<p>An antichain <em>A</em> of <strong>P</strong> is a subset such that if <em>p</em> and <em>q</em> are in <em>A</em>, then <em>p</em> and <em>q</em> are <em>incompatible</em> (written <em>p</em> ⊥ <em>q</em>), meaning there is no <em>r</em> in <strong>P</strong> such that <em>r</em> ≤ <em>p</em> and <em>r</em> ≤ <em>q</em>. In the Borel sets example, incompatibility means <em>p</em>∩<em>q</em> has measure zero. In the finite partial functions example, incompatibility means that <em>p</em>∪<em>q</em> is not a function, in other words, <em>p</em> and <em>q</em> assign different values to some domain input.</p>

<p><strong>P</strong> satisfies the <strong><a href="countable_chain_condition" title="wikilink">countable chain condition</a></strong> (c.c.c.) if every antichain in <strong>P</strong> is countable. (The name, which is obviously inappropriate, is a holdover from older terminology. Some mathematicians write "c.a.c." for "countable antichain condition".)</p>

<p>It is easy to see that Bor(<strong>I</strong>) satisfies the c.c.c., because the measures add up to at most 1. Fin(<em>E</em>,2) is also c.c.c., but the proof is more difficult.</p>

<p>Given an uncountable subfamily <em>W</em> ⊆ Fin(<em>E</em>,2), shrink <em>W</em> to an uncountable subfamily <em>W</em><sub>0</sub> of sets of size <em>n</em>, for some <em>n</em>&lt;ω. If p(<em>e</em><sub>1</sub>)=<em>b</em><sub>1</sub> for uncountably many <em>p</em> ∈ <em>W</em><sub>0</sub>, shrink to this uncountable subfamily <em>W</em><sub>1</sub>, and repeat, getting a finite set <mtpl></mtpl>, and an uncountable family <em>W</em><sub><em>k</em></sub> of incompatible conditions of size <em>n</em>−<em>k</em> such that every <em>e</em> is in at most countably many dom(<em>p</em>) for <em>p</em> ∈ <em>W</em><sub><em>k</em></sub>. Now pick an arbitrary <em>p</em> ∈ <em>W</em><sub><em>k</em></sub>, and pick from <em>W</em><sub><em>k</em></sub> any <em>q</em> that is not one of the countably many members that have a domain member in common with <em>p</em>. Then <em>p</em> ∪ <mtpl></mtpl> and <em>q</em> ∪ <mtpl></mtpl> are compatible, so <em>W</em> is not an antichain. In other words, Fin(<em>E</em>,2) antichains are countable.</p>

<p>The importance of antichains in forcing is that for most purposes, dense sets and maximal antichains are equivalent. A <em>maximal</em> antichain <em>A</em> is one that cannot be extended and still be an antichain. This means every element of <em>p</em> ∈ <strong>P</strong> is compatible with some member of <em>A</em>. Their existence follows from <a href="Zorn's_lemma" title="wikilink">Zorn's lemma</a>. Given a maximal antichain <em>A</em>, let <em>D</em> = 

<math display="inline" id="Forcing_(mathematics):101">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi mathvariant="normal">∃</mi>
      <mi>q</mi>
      <mi mathvariant="normal">≤</mi>
      <mi>p</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>q</mi>
      <mi>f</mi>
      <mi>o</mi>
      <mi>r</mi>
      <mi>c</mi>
      <mi>e</mi>
      <mi>s</mi>
      <mi>u</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>a</mi>
        <mi mathvariant="normal">ˇ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>b</mi>
     <mi mathvariant="normal">ˇ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>b</ci>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <times></times>
       <ci>normal-∃</ci>
       <ci>q</ci>
       <ci>normal-≤</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <times></times>
       <ci>q</ci>
       <ci>f</ci>
       <ci>o</ci>
       <ci>r</ci>
       <ci>c</ci>
       <ci>e</ci>
       <ci>s</ci>
       <ci>u</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>normal-ˇ</ci>
       </apply>
      </apply>
     </list>
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>normal-ˇ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {b:∃q≤p,qforcesu(aˇ)=bˇ}
  </annotation>
 </semantics>
</math>

. <em>D</em> is dense, and <em>G</em>∩<em>D</em>≠0 if and only if <em>G</em>∩<em>A</em>≠0. Conversely, given a dense set <em>D</em>, Zorn's lemma shows there exists a maximal antichain <em>A</em>⊆<em>D</em>, and then <em>G</em>∩<em>D</em>≠0 if and only if <em>G</em>∩<em>A</em>≠0.</p>

<p>Assume <strong>P</strong> is c.c.c. Given <em>x</em>,<em>y</em> ∈ <em>V</em>, with <em>f</em>:<em>x</em>→<em>y</em> in <em>V</em>[<em>G</em>], one can approximate <em>f</em> inside <em>V</em> as follows. Let <em>u</em> be a name for <em>f</em> (by the definition of <em>V</em>[<em>G</em>]) and let <em>p</em> be a condition which forces <em>u</em> to be a function from <em>x</em> to <em>y</em>. Define a function <em>F</em> whose domain is <em>x</em> by <em>F</em>(<em>a</em>) = 

<math display="inline" id="Forcing_(mathematics):102">
 <semantics>
  <mrow>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>i</mi>
      <mi>n</mi>
      <mi>V</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>r</mi>
     <mi mathvariant="normal">∈</mi>
     <mi>B</mi>
    </mrow>
    <mo>*</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>i</mi>
      <mi>n</mi>
      <mi>V</mi>
      <mi>G</mi>
      <mi>G</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>B</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>n</ci>
      <ci>V</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>normal-∈</ci>
      <ci>B</ci>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>n</ci>
      <ci>V</ci>
      <ci>G</ci>
      <ci>G</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {B(inV):r∈B*(inVGG)}
  </annotation>
 </semantics>
</math>

. By definability of forcing, this definition makes sense within <em>V</em>. By coherence of forcing, different <em>b</em>’s come from incompatible <em>p</em>’s. By c.c.c., <em>F</em>(<em>a</em>) is countable.</p>

<p>In summary, <em>f</em> is unknown in <em>V</em>, since it depends on <em>G</em>, but it is not wildly unknown for a c.c.c. forcing. One can identify a countable set of guesses for what the value of <em>f</em> is at any input, independent of <em>G</em>.</p>

<p>This has the following very important consequence. If in <em>V</em>[<em>G</em>], <em>f</em>:α→β is a surjection from one infinite ordinal to another, then there is a surjection <em>g</em>:ω×α→β in <em>V</em> and consequently a surjection <em>h</em>:α→β in <em>V</em>. In particular, cardinals cannot collapse. The conclusion is that 2<sup>ℵ₀</sup> ≥ ℵ<sub>2</sub> in <em>V</em>[<em>G</em>].</p>
<h2 id="easton-forcing">Easton forcing</h2>

<p>The exact value of the continuum in the above Cohen model, and variants like Fin(ω × κ , 2) for cardinals κ in general, was worked out by <a href="Robert_M._Solovay" title="wikilink">Robert M. Solovay</a>, who also worked out how to violate GCH (the <a href="Continuum_hypothesis#The_generalized_continuum_hypothesis" title="wikilink">generalized continuum hypothesis</a>), for <a href="regular_cardinal" title="wikilink">regular cardinals</a> only, a finite number of times. For example, in the above Cohen model, if CH holds in <em>V</em>, then 2<sup>ℵ₀</sup> = ℵ<sub>2</sub> holds in <em>V</em>[<em>G</em>].</p>

<p><a href="W._B._Easton" title="wikilink">W. B. Easton</a> worked out the infinite and proper class version of violating the GCH for regular cardinals, basically showing the known restrictions (monotonicity, <a href="Cantor's_theorem" title="wikilink">Cantor's theorem</a>, and <a href="König's_theorem_(set_theory)" title="wikilink">König's theorem</a>) were the only ZFC provable restrictions. See <a href="Easton's_theorem" title="wikilink">Easton's theorem</a>.</p>

<p>Easton's work was notable in that it involved forcing with a proper class of conditions. In general, the method of forcing with a proper class of conditions will fail to give a model of ZFC. For example, Fin ( ω × On , 2 ), where "On" is the proper class of all ordinals, will make the continuum a proper class. Fin ( ω, On ) will introduce a countable enumeration of the ordinals. In both cases, the resulting <em>V</em>[<em>G</em>] is visibly not a model of ZFC.</p>

<p>At one time, it was thought that more sophisticated forcing would also allow arbitrary variation in the powers of <a href="Regular_cardinal" title="wikilink">singular cardinals</a>. But this has turned out to be a difficult, subtle and even surprising problem, with several more <a href="PCF_theory" title="wikilink">restrictions provable</a> in ZFC, and with the forcing models depending on the consistency of various <a href="large_cardinal" title="wikilink">large cardinal</a> properties. Many open problems remain.</p>
<h2 id="random-reals">Random reals</h2>

<p>In the Borel sets ( Bor(<strong>I</strong>), ⊆, <strong>I</strong> ) example, the generic filter converges to a real number <em>r</em>, called a <em>random</em> real. A name for the decimal expansion of <em>r</em> (in the sense of the canonical set of decimal intervals that converge to <em>r</em>) can be given by letting <u><em>r</em></u> = <mtpl> [ <em>k</em>⋅10<sup>−<em>n</em></sup>, (<em>k</em> + 1)⋅10<sup>−<em>n</em></sup> ], 0 ≤ <em>k</em> <em>n</em> }}</mtpl>. This is, in some sense, just a subname of <u><em>G</em></u>.</p>

<p>To recover <em>G</em> from <em>r</em>, one takes those Borel subsets of <strong>I</strong> that "contain" <em>r</em>. Since the forcing poset is in <em>V</em>, but <em>r</em> is not in <em>V</em>, this containment is actually impossible. But there is a natural sense in which the interval [0.5, 0.6] in <em>V</em> "contains" a random real whose decimal expansion begins 0.5. This is formalized by the notion of "Borel code".</p>

<p>Every Borel set can, nonuniquely, be built up, starting from intervals with rational endpoints and applying the operations of complement and countable unions, a countable number of times. The record of such a construction is called a <em>Borel code</em>. Given a Borel set <em>B</em> in <em>V</em>, one recovers a Borel code, and then applies the same construction sequence in <em>V</em>[<em>G</em>], getting a Borel set <em>B</em>*. One can prove that one gets the same set independent of the construction of <em>B</em>, and that basic properties are preserved. For example, if <em>B</em>⊆<em>C</em>, then <em>B</em>*⊆<em>C</em>*. If <em>B</em> has measure zero, then <em>B</em>* has measure zero.</p>

<p>So given <em>r</em>, a random real, one can show that <em>G</em> = 

<math display="inline" id="Forcing_(mathematics):103">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Z</mi>
     <mi>F</mi>
     <mi>C</mi>
    </mrow>
    <mo>⊢</mo>
    <mrow>
     <mrow>
      <mo>Con</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>Z</mi>
        <mi>F</mi>
        <mi>C</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>→</mo>
     <mrow>
      <mo>Con</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>Z</mi>
         <mi>F</mi>
         <mi>C</mi>
        </mrow>
        <mo>+</mo>
        <mi>H</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <apply>
     <times></times>
     <ci>Z</ci>
     <ci>F</ci>
     <ci>C</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <ci>Con</ci>
      <apply>
       <times></times>
       <ci>Z</ci>
       <ci>F</ci>
       <ci>C</ci>
      </apply>
     </apply>
     <apply>
      <ci>Con</ci>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>Z</ci>
        <ci>F</ci>
        <ci>C</ci>
       </apply>
       <ci>H</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ZFC\vdash\operatorname{Con}(ZFC)\rightarrow\operatorname{Con}(ZFC+H).
  </annotation>
 </semantics>
</math>

. Because of the mutual interdefinability between <em>r</em> and <em>G</em>, one generally writes <em>V</em>[<em>r</em>] for <em>V</em>[<em>G</em>].</p>

<p>A different interpretation of reals in <em>V</em>[<em>G</em>] was provided by <a href="Dana_Scott" title="wikilink">Dana Scott</a>. Rational numbers in <em>V</em>[<em>G</em>] have names that correspond to countably many distinct rational values assigned to a maximal antichain of Borel sets, in other words, a certain rational-valued function on <strong>I</strong> = [0,1]. Real numbers in <em>V</em>[<em>G</em>] then correspond to <a href="Dedekind_cut" title="wikilink">Dedekind cuts</a> of such functions, that is, <a href="measurable_function" title="wikilink">measurable functions</a>.</p>
<h2 id="boolean-valued-models">Boolean-valued models</h2>
<dl>
<dd><em>Main article: <a href="Boolean-valued_model" title="wikilink">Boolean-valued model</a></em>
</dd>
</dl>

<p>Perhaps more clearly, the method can be explained in terms of Boolean-valued models. In these, any statement is assigned a <a href="truth_value" title="wikilink">truth value</a> from some complete atomless <a href="Boolean_algebra_(structure)" title="wikilink">Boolean algebra</a>, rather than just a true/false value. Then an <a class="uri" href="ultrafilter" title="wikilink">ultrafilter</a> is picked in this Boolean algebra, which assigns values true/false to statements of our theory. The point is that the resulting theory has a model which contains this ultrafilter, which can be understood as a new model obtained by extending the old one with this ultrafilter. By picking a Boolean-valued model in an appropriate way, we can get a model that has the desired property. In it, only statements which must be true (are "forced" to be true) will be true, in a sense (since it has this extension/minimality property).</p>
<h2 id="meta-mathematical-explanation">Meta-mathematical explanation</h2>

<p>In forcing we usually seek to show some <a href="sentence_(mathematical_logic)" title="wikilink">sentence</a> is <a href="Consistency_proof" title="wikilink">consistent</a> with <a class="uri" href="ZFC" title="wikilink">ZFC</a> (or optionally some extension of ZFC). One way to interpret the argument is that we assume ZFC is consistent and use it to prove ZFC combined with our new <a href="sentence_(mathematical_logic)" title="wikilink">sentence</a> is also consistent.</p>

<p>Each "condition" is a finite piece of information – the idea is that only finite pieces are relevant for consistency, since by the <a href="compactness_theorem" title="wikilink">compactness theorem</a> a theory is satisfiable if and only if every finite subset of its axioms is satisfiable. Then, we can pick an infinite set of consistent conditions to extend our model. Thus, assuming consistency of set theory, we prove consistency of the theory extended with this infinite set.</p>
<h2 id="logical-explanation">Logical explanation</h2>

<p>By Gödel's incompleteness theorem one cannot prove the consistency of any sufficiently strong formal theory, such as ZFC, using only the axioms of the theory itself, unless the theory itself is inconsistent. Consequently mathematicians do not attempt to prove the consistency of ZFC using only the axioms of ZFC, or to prove ZFC+H is consistent for any hypothesis H using only ZFC+H. For this reason the aim of a consistency proof is to prove the consistency of ZFC + <em>H</em> relative to consistency of ZFC. Such problems are known as problems of relative consistency. In fact one proves</p>

<p>(*) 

<math display="block" id="Forcing_(mathematics):104">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mi>F</mi>
   <mi>C</mi>
   <mo>+</mo>
   <mi mathvariant="normal">¬</mi>
   <mo>Con</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Z</mi>
    <mi>F</mi>
    <mi>C</mi>
    <mo>+</mo>
    <mi>H</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mo>∃</mo>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>Fin</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mi>T</mi>
    <mo>⊂</mo>
    <mi>Z</mi>
    <mi>F</mi>
    <mi>C</mi>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo>⊢</mo>
     <mi mathvariant="normal">¬</mi>
     <mi>H</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Z</csymbol>
    <csymbol cd="unknown">F</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <plus></plus>
    <not></not>
    <ci>Con</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Z</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <plus></plus>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proves</csymbol>
    <exists></exists>
    <csymbol cd="unknown">T</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>Fin</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">T</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="unknown">T</csymbol>
     <subset></subset>
     <csymbol cd="unknown">Z</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">T</csymbol>
      <csymbol cd="latexml">proves</csymbol>
      <not></not>
      <csymbol cd="unknown">H</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ZFC+\lnot\operatorname{Con}(ZFC+H)\vdash\exists T(\operatorname{Fin}(T)\land T%
\subset ZFC\land(T\vdash\lnot H)).
  </annotation>
 </semantics>
</math>

</p>

<p>We will give the general schema of relative consistency proofs. Because any proof is finite it uses finite number of axioms.</p>

<p>

<math display="block" id="Forcing_(mathematics):105">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mi>F</mi>
   <mi>C</mi>
   <mo>⊢</mo>
   <mo>∀</mo>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo>⊢</mo>
     <mi mathvariant="normal">¬</mi>
     <mi>H</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Z</mi>
     <mi>F</mi>
     <mi>C</mi>
     <mo>⊢</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo>⊢</mo>
      <mi mathvariant="normal">¬</mi>
      <mi>H</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Z</csymbol>
    <csymbol cd="unknown">F</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">T</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">T</csymbol>
      <csymbol cd="latexml">proves</csymbol>
      <not></not>
      <csymbol cd="unknown">H</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">Z</csymbol>
      <csymbol cd="unknown">F</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <csymbol cd="latexml">proves</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">T</csymbol>
       <csymbol cd="latexml">proves</csymbol>
       <not></not>
       <csymbol cd="unknown">H</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ZFC\vdash\forall T((T\vdash\lnot H)\rightarrow(ZFC\vdash(T\vdash\lnot H))).
  </annotation>
 </semantics>
</math>

</p>

<p>For any given proof ZFC can verify validity of this proof. This is provable by induction by the length of the proof.</p>

<p>

<math display="block" id="Forcing_(mathematics):106">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mi>F</mi>
   <mi>C</mi>
   <mo>+</mo>
   <mi mathvariant="normal">¬</mi>
   <mo>Con</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Z</mi>
    <mi>F</mi>
    <mi>C</mi>
    <mo>+</mo>
    <mi>H</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mo>∃</mo>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>Fin</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mi>T</mi>
    <mo>⊂</mo>
    <mi>Z</mi>
    <mi>F</mi>
    <mi>C</mi>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Z</mi>
     <mi>F</mi>
     <mi>C</mi>
     <mo>⊢</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo>⊢</mo>
      <mi mathvariant="normal">¬</mi>
      <mi>H</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Z</csymbol>
    <csymbol cd="unknown">F</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <plus></plus>
    <not></not>
    <ci>Con</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Z</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <plus></plus>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proves</csymbol>
    <exists></exists>
    <csymbol cd="unknown">T</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>Fin</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">T</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="unknown">T</csymbol>
     <subset></subset>
     <csymbol cd="unknown">Z</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">Z</csymbol>
      <csymbol cd="unknown">F</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <csymbol cd="latexml">proves</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">T</csymbol>
       <csymbol cd="latexml">proves</csymbol>
       <not></not>
       <csymbol cd="unknown">H</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ZFC+\lnot\operatorname{Con}(ZFC+H)\vdash\exists T(\operatorname{Fin}(T)\land T%
\subset ZFC\land(ZFC\vdash(T\vdash\lnot H))).
  </annotation>
 </semantics>
</math>

</p>

<p>Now we obtain</p>

<p>

<math display="inline" id="Forcing_(mathematics):107">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mi>F</mi>
   <mi>C</mi>
   <mo>⊢</mo>
   <mo>∀</mo>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>Fin</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mi>T</mi>
    <mo>⊂</mo>
    <mi>Z</mi>
    <mi>F</mi>
    <mi>C</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Z</mi>
     <mi>F</mi>
     <mi>C</mi>
     <mo>⊢</mo>
     <mo>Con</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo>+</mo>
      <mi>H</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Z</csymbol>
    <csymbol cd="unknown">F</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">T</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>Fin</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">T</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="unknown">T</csymbol>
     <subset></subset>
     <csymbol cd="unknown">Z</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">Z</csymbol>
      <csymbol cd="unknown">F</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <csymbol cd="latexml">proves</csymbol>
      <ci>Con</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">T</csymbol>
       <plus></plus>
       <csymbol cd="unknown">H</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ZFC\vdash\forall T(\operatorname{Fin}(T)\land T\subset ZFC\rightarrow(ZFC%
\vdash\operatorname{Con}(T+H)))
  </annotation>
 </semantics>
</math>

</p>

<p>If we prove the following</p>

<p>(**) 

<math display="block" id="Forcing_(mathematics):108">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mi>F</mi>
   <mi>C</mi>
   <mo>+</mo>
   <mi mathvariant="normal">¬</mi>
   <mo>Con</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Z</mi>
    <mi>F</mi>
    <mi>C</mi>
    <mo>+</mo>
    <mi>H</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊢</mo>
   <mo>∃</mo>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>Fin</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mi>T</mi>
    <mo>⊂</mo>
    <mi>Z</mi>
    <mi>F</mi>
    <mi>C</mi>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Z</mi>
     <mi>F</mi>
     <mi>C</mi>
     <mo>⊢</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo>⊢</mo>
      <mi mathvariant="normal">¬</mi>
      <mi>H</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Z</mi>
     <mi>F</mi>
     <mi>C</mi>
     <mo>⊢</mo>
     <mo>Con</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo>+</mo>
      <mi>H</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Z</csymbol>
    <csymbol cd="unknown">F</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <plus></plus>
    <not></not>
    <ci>Con</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Z</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <plus></plus>
     <csymbol cd="unknown">H</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">proves</csymbol>
    <exists></exists>
    <csymbol cd="unknown">T</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>Fin</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">T</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="unknown">T</csymbol>
     <subset></subset>
     <csymbol cd="unknown">Z</csymbol>
     <csymbol cd="unknown">F</csymbol>
     <csymbol cd="unknown">C</csymbol>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">Z</csymbol>
      <csymbol cd="unknown">F</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <csymbol cd="latexml">proves</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">T</csymbol>
       <csymbol cd="latexml">proves</csymbol>
       <not></not>
       <csymbol cd="unknown">H</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">Z</csymbol>
      <csymbol cd="unknown">F</csymbol>
      <csymbol cd="unknown">C</csymbol>
      <csymbol cd="latexml">proves</csymbol>
      <ci>Con</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">T</csymbol>
       <plus></plus>
       <csymbol cd="unknown">H</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ZFC+\lnot\operatorname{Con}(ZFC+H)\vdash\exists T(\operatorname{Fin}(T)\land T%
\subset ZFC\land(ZFC\vdash(T\vdash\lnot H))\land(ZFC\vdash\operatorname{Con}(T%
+H)))
  </annotation>
 </semantics>
</math>

</p>

<p>we can conclude that</p>

<p>

<math display="block" id="Forcing_(mathematics):109">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Z</mi>
     <mi>F</mi>
     <mi>C</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mrow>
      <mo>Con</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>Z</mi>
         <mi>F</mi>
         <mi>C</mi>
        </mrow>
        <mo>+</mo>
        <mi>H</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo>Con</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>Z</mi>
       <mi>F</mi>
       <mi>C</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>Z</ci>
      <ci>F</ci>
      <ci>C</ci>
     </apply>
     <apply>
      <times></times>
      <not></not>
      <apply>
       <ci>Con</ci>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>Z</ci>
         <ci>F</ci>
         <ci>C</ci>
        </apply>
        <ci>H</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <apply>
      <ci>Con</ci>
      <apply>
       <times></times>
       <ci>Z</ci>
       <ci>F</ci>
       <ci>C</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ZFC+\lnot\operatorname{Con}(ZFC+H)\vdash\lnot\operatorname{Con}(ZFC)
  </annotation>
 </semantics>
</math>

</p>

<p>which is equivalent to</p>

<p>

<math display="inline" id="Forcing_(mathematics):110">
 <semantics>
  <mrow>
   <mrow>
    <mi>Z</mi>
    <mi>F</mi>
    <mi>C</mi>
   </mrow>
   <mo>⊢</mo>
   <mrow>
    <mo>Con</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>Z</mi>
      <mi>F</mi>
      <mi>C</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>↔</mo>
   <mrow>
    <mo>Con</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>Z</mi>
      <mi>F</mi>
      <mi>L</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">proves</csymbol>
     <apply>
      <times></times>
      <ci>Z</ci>
      <ci>F</ci>
      <ci>C</ci>
     </apply>
     <apply>
      <ci>Con</ci>
      <apply>
       <times></times>
       <ci>Z</ci>
       <ci>F</ci>
       <ci>C</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-↔</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>Con</ci>
      <apply>
       <times></times>
       <ci>Z</ci>
       <ci>F</ci>
       <ci>L</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ZFC\vdash\operatorname{Con}(ZFC)\leftrightarrow\operatorname{Con}(ZFL)
  </annotation>
 </semantics>
</math>

</p>

<p>which gives (*). The core of the relative consistency proof is proving (**). One has to construct a ZFC proof of Con(<em>T</em> + <em>H</em>) for any given finite set <em>T</em> of ZFC axioms (by ZFC instruments of course). (No universal proof of Con(<em>T</em> + <em>H</em>) of course.)</p>

<p>In ZFC it is provable that for any condition p the set of formulas (evaluated by names) forced by <em>p</em> is deductively closed. Also, for any ZFC axiom, ZFC proves that this axiom is forced by 1. Then it suffices to prove that there is at least one condition which forces H.</p>

<p>In the case of Boolean valued forcing, the procedure is similar – one has to prove that the Boolean value of <em>H</em> is not 0.</p>

<p>Another approach uses the reflection theorem. For any given finite set of ZFC axioms there is ZFC proof that this set of axioms has a countable transitive model. For any given finite set T of ZFC axioms there is finite set T' of ZFC axioms such that ZFC proves that if a countable transitive model <em>M</em> satisfies T' then <em>M</em>[<em>G</em>] satisfies <em>T</em>. One has to prove that there is finite set T" of ZFC axioms such that if a countable transitive model M satisfies T" then <em>M</em>[<em>G</em>] satisfies the hypothesis <em>H</em>. Then, for any given finite set T of ZFC axioms, ZFC proves Con(<em>T</em> + <em>H</em>).</p>

<p>Sometimes in (**) some stronger theory <em>S</em> than ZFC is used for proving Con(<em>T</em> + <em>H</em>). Then we have proof of consistency of ZFC + H relative to the consistency of <em>S</em>. Note that <span class="LaTeX">$ZFC\vdash \operatorname{Con}(ZFC)\leftrightarrow \operatorname{Con}(ZFL)$</span>, where ZFL is ZF + V = L (axiom of constructibility).</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="List_of_forcing_notions" title="wikilink">List of forcing notions</a></li>
<li><a href="Nice_name" title="wikilink">Nice name</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Bell, J. L. (1985) <em>Boolean-Valued Models and Independence Proofs in Set Theory</em>, Oxford. ISBN 0-19-853241-5</li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>Nik Weaver's book <a href="http://www.worldscientific.com/worldscibooks/10.1142/8962">Forcing for Mathematicians</a> was written for mathematicians who want to learn the basic machinery of forcing. No background in logic is assumed, beyond the facility with formal syntax which should be second nature to any well-trained mathematician.</li>
<li>Tim Chow's article <a href="http://arxiv.org/abs/0712.1320">A Beginner's Guide to Forcing</a> is a good introduction to the concepts of forcing that avoids a lot of technical detail. This paper grew out of Chow's newsgroup article <a href="http://alum.mit.edu/www/tchow/mathstuff/forcingdum">Forcing for dummies</a>. In addition to improved exposition, the Beginner's Guide includes a section on Boolean Valued Models.</li>
<li>See also Kenny Easwaran's article <a href="http://arxiv.org/abs/0712.2279">A Cheerful Introduction to Forcing and the Continuum Hypothesis</a>, which is also aimed at the beginner but includes more technical details than Chow's article.</li>
<li><a href="http://dx.doi.org/10.1073/pnas.50.6.1143">The Independence of the Continuum Hypothesis</a> Paul J. Cohen, Proceedings of the National Academy of Sciences of the United States of America, Vol. 50, No. 6. (Dec. 15, 1963), pp. 1143–1148.</li>
<li><a href="http://dx.doi.org/10.1073/pnas.51.1.105">The Independence of the Continuum Hypothesis, II</a> Paul J. Cohen Proceedings of the National Academy of Sciences of the United States of America, Vol. 51, No. 1. (Jan. 15, 1964), pp. 105–110.</li>
<li>Paul Cohen gave a historical lecture [<a class="uri" href="http://projecteuclid.org/DPubS?service=UI&amp;version">http://projecteuclid.org/DPubS?service=UI&amp;version;</a>;=1.0&amp;verb;=Display&amp;handle;=euclid.rmjm/1181070010 The Discovery of Forcing] (Rocky Mountain J. Math. Volume 32, Number 4 (2002), 1071–1100) about how he developed his independence proof. The linked page has a download link for an open access PDF but your browser must send a <a class="uri" href="referer" title="wikilink">referer</a> header from the linked page to retrieve it.</li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Forcing_(mathematics)" title="wikilink"> </a></p>
</body>
</html>
