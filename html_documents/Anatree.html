<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1723">Anatree</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Anatree</h1>
<hr/>

<p>  An <strong>Anatree</strong> <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> is a <a href="data_structure" title="wikilink">data structure</a> designed to solve <a class="uri" href="anagrams" title="wikilink">anagrams</a>. Solving an anagram is the problem of finding a word from a given list of letters. These problems are commonly encountered in word games like wordwheel, <a class="uri" href="scrabble" title="wikilink">scrabble</a> or <a class="uri" href="crossword" title="wikilink">crossword</a> puzzles that we find in newspapers. The problem for the wordwheel also has the condition that the central letter appear in all the words framed with the given set. Some other conditions may be introduced regarding the frequency (number of appearances) of each of the letters in the given input string. These problems are classified as <a href="Constraint_satisfaction_problem" title="wikilink">Constraint satisfaction problem</a> in computer science literature.</p>

<p>An anatree is represented as a directed <a class="uri" href="tree" title="wikilink">tree</a> which contains a set of words (W) encoded as strings in some <a class="uri" href="alphabet" title="wikilink">alphabet</a>. The internal vertices are labelled with some letter in the alphabet and the leaves contain words. The edges are labelled with non-negative integers. An anatree has the property that the sum of the edge labels from the root to the leaf is the length of the word stored at the leaf. If the internal vertices are labelled as 

<math display="inline" id="Anatree:0">
 <semantics>
  <msub>
   <mi>α</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{1}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Anatree:1">
 <semantics>
  <msub>
   <mi>α</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{2}
  </annotation>
 </semantics>
</math>

 ... 

<math display="inline" id="Anatree:2">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{l}
  </annotation>
 </semantics>
</math>

, and the edge labels are 

<math display="inline" id="Anatree:3">
 <semantics>
  <msub>
   <mi>n</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{1}
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Anatree:4">
 <semantics>
  <msub>
   <mi>n</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{2}
  </annotation>
 </semantics>
</math>

 ... 

<math display="inline" id="Anatree:5">
 <semantics>
  <msub>
   <mi>n</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{l}
  </annotation>
 </semantics>
</math>

, then the path from the root to the leaf along these vertices and edges are a list of words that contain 

<math display="inline" id="Anatree:6">
 <semantics>
  <msub>
   <mi>n</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{1}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Anatree:7">
 <semantics>
  <msub>
   <mi>α</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{1}
  </annotation>
 </semantics>
</math>

 s, 

<math display="inline" id="Anatree:8">
 <semantics>
  <msub>
   <mi>n</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{2}
  </annotation>
 </semantics>
</math>


 

<math display="inline" id="Anatree:9">
 <semantics>
  <msub>
   <mi>α</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{2}
  </annotation>
 </semantics>
</math>

 s and so on. Anatrees are intended to be read only data structures with all the words available at construction time.</p>

<p>A <strong>Mixed Anatree</strong> is an anatree where the internal vertices also store words. A mixed anatree can have words of varying lengths, where as in a regular anatree, all words are of the same length.</p>
<h2 id="data-structures-for-solving-anagrams">Data Structures for solving Anagrams</h2>

<p>A number of data structures have been proposed to solve anagrams in constant time. Two of the most commonly used data structures are the <strong>Alphabetic map</strong> and the <strong>Frequency map</strong>. The Alphabetic map maintains a <a href="hash_table" title="wikilink">hash table</a> of all the possible words that can be in the language (this is referred to as the <a class="uri" href="lexicon" title="wikilink">lexicon</a>). For a given input sting, sort the letters in alphabetic order. This sorted string maps onto a word in the hash table. Hence finding the anagram requires sorting the letters and a looking up the word in the hash table. The sorting can be done in linear time by the <a href="counting_sort" title="wikilink">counting sort</a> and hash table look up can be done in constant time.</p>

<p>For example for the word ANATREE, the alphabetic map would produce a mapping of 

<math display="inline" id="Anatree:10">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>A</mi>
   <mi>A</mi>
   <mi>E</mi>
   <mi>E</mi>
   <mi>N</mi>
   <mi>R</mi>
   <mi>T</mi>
   <mo>-</mo>
   <mo>></mo>
   <mrow>
    <msup>
     <mo stretchy="false">{</mo>
     <mi>′′</mi>
    </msup>
    <mi>a</mi>
    <mi>n</mi>
    <mi>a</mi>
    <mi>t</mi>
    <mi>r</mi>
    <mi>e</mi>
    <msup>
     <mi>e</mi>
     <mi>′′</mi>
    </msup>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-{</ci>
    <csymbol cd="unknown">A</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <csymbol cd="unknown">E</csymbol>
    <csymbol cd="unknown">N</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <csymbol cd="unknown">T</csymbol>
    <minus></minus>
    <gt></gt>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-{</ci>
      <ci>′′</ci>
     </apply>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <ci>′′</ci>
     </apply>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-}</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{AAEENRT->\{^{\prime\prime}anatree^{\prime\prime}\}\}
  </annotation>
 </semantics>
</math>

.</p>

<p>A Frequency map also stores the list of all possible words in the lexicon in a hash table. For a given input string, the frequency map maintains the frequencies (number of appearances) of all the letters and uses this count to perform a look up in the hash table. The worst case execution time is found to be linear in size of the lexicon.</p>

<p>For example for the word ANATREE, the alphabetic map would produce a mapping of 

<math display="inline" id="Anatree:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
    </mrow>
    <mo>></mo>
    <mn>2</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>E</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
     </mrow>
     <mo>></mo>
     <mn>2</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mrow>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>N</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
      </mrow>
      <mo>></mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mrow>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>R</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
       </mrow>
       <mo>></mo>
       <mn>1</mn>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mrow>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>T</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
       </mrow>
       <mo>></mo>
       <mn>2</mn>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <gt></gt>
     <apply>
      <csymbol cd="latexml">limit-from</csymbol>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>A</ci>
      </apply>
      <minus></minus>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <gt></gt>
      <apply>
       <csymbol cd="latexml">limit-from</csymbol>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>E</ci>
       </apply>
       <minus></minus>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <gt></gt>
       <apply>
        <csymbol cd="latexml">limit-from</csymbol>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>N</ci>
        </apply>
        <minus></minus>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <gt></gt>
        <apply>
         <csymbol cd="latexml">limit-from</csymbol>
         <apply>
          <times></times>
          <ci>f</ci>
          <ci>R</ci>
         </apply>
         <minus></minus>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <gt></gt>
        <apply>
         <csymbol cd="latexml">limit-from</csymbol>
         <apply>
          <times></times>
          <ci>f</ci>
          <ci>T</ci>
         </apply>
         <minus></minus>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(A)->2,f(E)->2,f(N)->1,f(R)->1,f(T)->2
  </annotation>
 </semantics>
</math>

. The words that do not appear in the string are not written in the map.</p>
<h2 id="construction-of-an-anatree">Construction of an Anatree</h2>

<p>The construction of an Anatree begins by selecting a label for the root and partitioning words based on the label chosen for the root. This process is repeated recursively for all the labels of the tree. Anatree construction is non-canonical for a given set of words, depending on the label chosen for the root, the anatree will differ accordingly. The performance of the anatree is greatly impacted by the choice of labels.</p>

<p>The following are some heuristics for choosing labels:</p>
<ul>
<li>Start labeling vertices in alphabetical order from the root. This approach reduces construction overhead</li>
<li>Start labeling vertices based on the relative frequency. A probabilistic approach is used to assign labels to vertices. If 

<math display="inline" id="Anatree:12">
 <semantics>
  <msubsup>
   <mi>W</mi>
   <mi>n</mi>
   <mi>α</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <ci>n</ci>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{n}^{\alpha}
  </annotation>
 </semantics>
</math>

 is the set of words that contain 

<math display="inline" id="Anatree:13">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi>α</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>α</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\alpha s
  </annotation>
 </semantics>
</math>


, then we label the vertex with 

<math display="inline" id="Anatree:14">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 if it maximizes the expected distance to the leaf. This approach has the most frequently appearing characters (like E) labeled at the root and the least frequently appearing characters labeled at the leaves. The following equation is maximized 

<math display="inline" id="Anatree:15">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mi>α</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>n</mi>
    </msub>
    <mrow>
     <mi>n</mi>
     <mfrac>
      <mrow>
       <mo stretchy="false">|</mo>
       <msubsup>
        <mi>W</mi>
        <mi>n</mi>
        <mi>α</mi>
       </msubsup>
       <mo stretchy="false">|</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>W</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>α</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <divide></divide>
       <apply>
        <abs></abs>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>W</ci>
          <ci>n</ci>
         </apply>
         <ci>α</ci>
        </apply>
       </apply>
       <apply>
        <abs></abs>
        <ci>W</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{\alpha}=\sum_{n}n\frac{|W_{n}^{\alpha}|}{|W|}
  </annotation>
 </semantics>
</math>

. This approach prevents long sequences of zero labeled edges since they do not contribute letters to the words generated by the anatree.</li>
</ul>
<h2 id="finding-anagrams-in-an-anatree">Finding Anagrams in an Anatree</h2>

<p>To find a word in an anatree, start at the root, depending on the frequency of the label in the given input string, follow the edge that has that frequency till the leaf. The leaf contains the required word. For example, consider the anatree in the figure, to find the word 

<math display="inline" id="Anatree:16">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>o</mi>
   <mi>g</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>o</ci>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   dog
  </annotation>
 </semantics>
</math>

, the given string may be 

<math display="inline" id="Anatree:17">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mi>g</mi>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <ci>g</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ogd
  </annotation>
 </semantics>
</math>

. Start at the root and follow the edge that has 

<math display="inline" id="Anatree:18">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>


 as the label. We follow this label since the given input string has 

<math display="inline" id="Anatree:19">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Anatree:20">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

. Traverse this edge until the leaf is encountered. That gives the required word.</p>
<h2 id="space-and-time-requirements">Space and Time Requirements</h2>

<p>A lexicon that stores 

<math display="inline" id="Anatree:21">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

 words (each word can be 

<math display="inline" id="Anatree:22">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

 characters long) in an alphabet 

<math display="inline" id="Anatree:23">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>


 has the following space requirements.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Data Structure</p></th>
<th style="text-align: left;">
<p>Space Requirements</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Alphabetic Map</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Anatree:24">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mi>l</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mo stretchy="false">|</mo>
     <mi>A</mi>
     <mo stretchy="false">|</mo>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">O</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">w</csymbol>
     <csymbol cd="unknown">l</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">l</csymbol>
      <csymbol cd="unknown">o</csymbol>
      <csymbol cd="unknown">g</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-|</ci>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(wl(log|A|)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Frequency Map</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Anatree:25">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>w</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mrow>
         <mo stretchy="false">|</mo>
         <mi>A</mi>
         <mo stretchy="false">|</mo>
        </mrow>
        <mi>l</mi>
        <mi>o</mi>
        <mi>g</mi>
        <mi>l</mi>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>l</mi>
        <mi>l</mi>
        <mi>o</mi>
        <mi>g</mi>
        <mrow>
         <mo stretchy="false">|</mo>
         <mi>A</mi>
         <mo stretchy="false">|</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>w</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <abs></abs>
        <ci>A</ci>
       </apply>
       <ci>l</ci>
       <ci>o</ci>
       <ci>g</ci>
       <ci>l</ci>
      </apply>
      <apply>
       <times></times>
       <ci>l</ci>
       <ci>l</ci>
       <ci>o</ci>
       <ci>g</ci>
       <apply>
        <abs></abs>
        <ci>A</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(w(|A|logl+llog|A|))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Anatree</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Anatree:26">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>w</mi>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>A</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>l</mi>
        <mi>o</mi>
        <mi>g</mi>
        <mrow>
         <mo stretchy="false">|</mo>
         <mi>A</mi>
         <mo stretchy="false">|</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mi>l</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>w</ci>
     <apply>
      <abs></abs>
      <ci>A</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>l</ci>
       <ci>o</ci>
       <ci>g</ci>
       <apply>
        <abs></abs>
        <ci>A</ci>
       </apply>
      </apply>
      <ci>l</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(w|A|(log|A|+l))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>The worst case execution time of an anatree is 

<math display="inline" id="Anatree:27">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>w</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>l</mi>
       <mo>+</mo>
       <mrow>
        <mi>w</mi>
        <msup>
         <mrow>
          <mo stretchy="false">|</mo>
          <mi>A</mi>
          <mo stretchy="false">|</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <abs></abs>
      <ci>w</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>l</ci>
      <apply>
       <times></times>
       <ci>w</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <abs></abs>
         <ci>A</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(|w|(l+w|A|^{2}))
  </annotation>
 </semantics>
</math>

</p>
<h2 id="see-also">See also</h2>
<ul>
<li>Anagram <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></li>
<li>Damn Cool Algorithms Part 3 - Anagram Trees <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
<li><a class="uri" href="Anagrams" title="wikilink">Anagrams</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Data_structures" title="wikilink">Category:Data structures</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
