<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1533">Interleave lower bound</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Interleave lower bound</h1>
<hr/>

<p>In the theory of <a href="Optimal_binary_search_tree" title="wikilink">Optimal binary search trees</a>, the <strong>interleave lower bound</strong> is a lower bound on the number of operations required by a binary search tree (BST) to execute a given sequence of accesses.</p>

<p>Several variants of this lower bound have been proved.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> This article is based on one of the variants.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="definitions">Definitions</h2>

<p>The bound is based on a <em>perfect BST</em>, P, which contains the keys 1,2,...,<em>n</em>. The structure of <em>P</em> is fixed. For example, for <em>n</em>=7, <em>P</em> can be represented by the following parenthesis structure:</p>
<dl>
<dd><dl>
<dd>[([1] 2 [3]) 4 ([5] 6 [7])]
</dd>
</dl>
</dd>
</dl>

<p>For each node <em>y</em> in P, define:</p>
<ul>
<li><em>Left(y)</em> = <em>y</em> itself and its left subtree;</li>
<li><em>Right(y)</em> = the right subtree of <em>y</em>.</li>
</ul>

<p>There is a sequence of accesses to elements of the tree: <em>X</em> = (<em>x1</em>, <em>x2</em>, ..., <em>xm</em>).</p>

<p>For each access <em>x</em> and node <em>y</em>, define the label of <em>x</em> for <em>y</em> as:</p>
<ul>
<li>"<em>L</em>" - if <em>x</em> is in <em>Left(y)</em>;</li>
<li>"<em>R</em>" - if <em>x</em> is in <em>Right(y)</em>;</li>
<li>null - otherwise.</li>
</ul>

<p>The label of <em>y</em> is the concatenation of the labels from all the accesses.</p>

<p>For example, if the sequence of accesses is: 7,6,3, then the label of the root (4) is: "RRL", the label of 6 is: "RL", and the label of 2 is: "R".</p>

<p>For every node <em>y</em>, the <em>amount of interleaving through y</em> is the number of alternations between L and R in the label of <em>y</em>. In the above example, the interleaving through 4 and 6 is 1 and the interleaving through all other nodes is 0.</p>

<p>The <em>interleave bound</em>, 

<math display="inline" id="Interleave_lower_bound:0">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mi>B</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>B</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   IB(X)
  </annotation>
 </semantics>
</math>

, is the sum of the interleaving through all the nodes of the tree. The interleave bound of the above sequence is 2.</p>
<h2 id="bound">Bound</h2>

<p>The <em>interleave bound lemma</em> says that <em>every</em> BST that has to access the elements in the sequence <em>X</em>, must do at least 

<math display="inline" id="Interleave_lower_bound:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>I</mi>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mo>-</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>I</ci>
      <ci>B</ci>
      <ci>X</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   IB(X)/2-n
  </annotation>
 </semantics>
</math>

 actions.</p>
<h2 id="proof">Proof</h2>

<p>Let Ti be the state of an arbitrary BST at time i.</p>

<p>For every node <em>y</em> ∈ {1,...,<em>n</em>}, define the <em>transition point</em>, <em>Trans(y,Ti)</em>, as the minimum-depth node <em>z</em> in the BST Ti such that the path from the root of Ti to <em>z</em> includes both a node from <em>Left(y)</em> and a node from <em>Right(y)</em>. Intuitively, any BST algorithm on Ti that accesses an element from <em>Right(y)</em> and then an element from <em>Left(y)</em> (or vice versa) must touch <em>Trans(y,Ti)</em> at least once. The following properties of the transition point can be proved:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>1. The transition point is well-defined. I.e., for any node <em>y</em> and time <em>i</em>, there is a unique transition point for <em>y</em> in <em>Ti</em>.</p>

<p>2. The transition point is 'stable', not changing until it is accessed. I.e., if <em>z=Trans(y,Tj)</em> and the BST access algorithm does not touch <em>z</em> in Ti for all <em>i</em> in the interval [<em>j</em>,<em>k</em>], then <em>z=Trans(y,Tk)</em>.</p>

<p>3. Every node has a different transition point, i.e. the mapping <em>y</em> -&gt; <em>Trans(y,Ti)</em> is one-to-one, i.e. no node in <em>Ti</em> is the transition point for multiple nodes.</p>

<p>These properties are used to prove the bound.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Tango_tree" title="wikilink">Tango tree</a></li>
<li><a href="Optimal_binary_search_tree" title="wikilink">Optimal binary search tree</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Binary_trees" title="wikilink">Category:Binary trees</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
</ol>
</section>
</body>
</html>
