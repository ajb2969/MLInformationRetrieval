<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="749">Configural frequency analysis</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Configural frequency analysis</h1>
<hr>'''Configural frequency analysis (CFA)''' is a method of [[exploratory data analysis]], introduced by [[Gustav A. Lienert]] in 1969.<r
<p>ef&gt; The goal of a configural frequency analysis is to detect patterns in the data that occur <a href="Statistical_significance" title="wikilink">significantly</a> more (such patterns are called <em>Types</em>) or significantly less often (such patterns are called <em>Antitypes</em>) than expected by chance. Thus, the idea of a CFA is to provide by the identified types and antitypes some insight into the structure of the data. Types are interpreted as concepts which are constituted by a pattern of variable values. Antitypes are interpreted as patterns of variable values that do in general not occur together.</r
<p></hr></body></html>
<h2 id="basic-idea-of-the-cfa-algorithm">Basic idea of the CFA algorithm</h2>

<p>We explain the basic idea of CFA by a simple example. Assume that we have a data set that describes for each of <em>n</em> patients if they show certain symptoms <em>s</em><sub>1</sub>, ..., <em>s</em><sub><em>m</em></sub>. We assume for simplicity that a symptom is shown or not, i.e. we have a dichotomous data set.</p>

<p>Each record in the data set is thus an <em>m</em>-tuple (<em>x</em><sub>1</sub>, ..., <em>x</em><sub><em>m</em></sub>) where each <em>x</em><sub><em>i</em></sub> is either equal to 0 (patient does not show symptom <em>i</em>) or 1 (patient does show symptom <em>i</em>). Each such <em>m</em>-tuple is called a <em>configuration</em>. Let <em>C</em> be the set of all possible configurations, i.e. the set of all possible <em>m</em>-tuples on {0,1}<sup><em>m</em></sup>. The data set can thus be described by listing the observed frequencies <em>f</em>(<em>c</em>) of all possible configurations in <em>C</em>.</p>

<p>The basic idea of CFA is to estimate the frequency of each configuration under the assumption that the <em>m</em> symptoms are <a href="statistically_independent" title="wikilink">statistically independent</a>. Let <em>e</em>(<em>c</em>) be this estimated frequency under the assumption of independence.</p>

<p>Let <em>p</em><sub><em>i</em></sub>(1) be the probability that a member of the investigated population shows symptom <em>s<sub>i</sub></em> and <em>p</em><sub><em>i</em></sub>(0) be the probability that a member of the investigated population does not show symptom <em>s<sub>i</sub></em>. Under the assumption that all symptoms are independent we can calculate the expected relative frequency of a configuration <em>c</em> = (<em>c</em><sub>1</sub> , ..., <em>c</em><sub><em>m</em></sub>) by:</p>

<p>

<math display="block" id="Configural_frequency_analysis:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>e</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>m</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>p</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>c</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>c</ci>
    </apply>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(c)=n\prod_{i=1}^{m}p_{i}(c_{i}).
  </annotation>
 </semantics>
</math>

</p>

<p>Now <em>f</em>(<em>c</em>) and <em>e</em>(<em>c</em>) can be compared by a statistical test (typical tests applied in CFA are <a href="Pearson's_chi-squared_test" title="wikilink">Pearson's chi-squared test</a>, the <a href="binomial_test" title="wikilink">binomial test</a> or the hypergeometric test of Lehmacher).</p>

<p>If the statistical test suggests for a given 

<math display="inline" id="Configural_frequency_analysis:1">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

-level that the difference between <em>f</em>(<em>c</em>) and <em>e</em>(<em>c</em>) is significant then <em>c</em> is called a <em>type</em> if <em>f</em>(<em>c</em>) &gt; <em>e</em>(<em>c</em>) and is called an antitype if <em>f</em>(<em>c</em>)  There are a number of alternative methods to control the <em>α</em>-level. One alternative, the <a href="Holm–Bonferroni_method" title="wikilink">Holm–Bonferroni method</a> introduced by <a href="Sture_Holm" title="wikilink">Sture Holm</a>, considers the number of tests already finished when the <em>i</em>th test is performed.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Thus, in this method the alpha–level is not constant for all tests.</p>
<h2 id="algorithm-in-the-non-dichotomous-case">Algorithm in the non-dichotomous case</h2>

<p>In our example above we assumed for simplicity that the symptoms are dichotomous. This is however not a necessary restriction. CFA can also be applied for symptoms (or more general attributes of an object) that are not dichotomous but have a finite number of degrees. In this case a configuration is an element of <em>C = S<sub>1</sub> x ... x S<sub>m</sub></em>, where <em>S<sub>i</sub></em> is the set of the possible degrees for symptom <em>s<sub>i</sub></em>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="chance-model">Chance model</h2>

<p>The assumption of the independence of the symptoms can be replaced by another method to calculate the expected frequencies <em>e</em>(<em>c</em>) of the configurations. Such a method is called a <em>chance model</em>.</p>

<p>In most applications of CFA the assumption that all symptoms are independent is used as the chance model. A CFA using that chance model is called <em>first-order CFA</em>. This is the classical method of CFA that is in many publications even considered to be the only CFA method. An example of an alternative chance model is the assumption that all configurations have the same probability. A CFA using that chance model is called <em>zero-order CFA</em>.</p>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Exploratory_data_analysis" title="wikilink">Category:Exploratory data analysis</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>


