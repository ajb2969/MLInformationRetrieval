<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1883">Vertex model</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Vertex model</h1>
<hr>A '''vertex model''' is 
<p>a type of <a href="statistical_mechanics" title="wikilink">statistical mechanics</a> <a href="Scientific_modelling" title="wikilink">model</a> in which the <a href="Partition_function_(statistical_mechanics)" title="wikilink">Boltzmann weights</a> are associated with a <a href="vertex_(graph_theory)" title="wikilink">vertex</a> in the model (representing an <a class="uri" href="atom" title="wikilink">atom</a> or particle).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> This contrasts with a nearest-neighbour model, such as the <a href="Ising_model" title="wikilink">Ising model</a>, in which the energy, and thus the Boltzmann weight of a statistical microstate is attributed to the bonds connecting two neighbouring particles. The energy associated with a vertex in the lattice of particles is thus dependent on the state of the bonds which connect it to adjacent vertices. It turns out that every solution of the <a href="Yang-Baxter_equation" title="wikilink">Yang-Baxter equation</a> with spectral parameters in a tensor product of <a href="vector_space" title="wikilink">vector spaces</a> 

<math display="inline" id="Vertex_model:0">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>⊗</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <ci>V</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\otimes V
  </annotation>
 </semantics>
</math>

 yields an exactly-solvable vertex model.</p>

<p> Although the model can be applied to various <a href="geometry" title="wikilink">geometries</a> in any number of dimensions, with any number of possible states for a given bond, the most fundamental examples occur for two dimensional lattices, the simplest being a <a href="square_lattice" title="wikilink">square lattice</a> where each bond has two possible states. In this model, every particle is connected to four other particles, and each of the four bonds adjacent to the particle has two possible states, indicated by the direction of an arrow on the bond. In this model, each vertex can adopt 

<math display="inline" id="Vertex_model:1">
 <semantics>
  <msup>
   <mn>2</mn>
   <mn>4</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{4}
  </annotation>
 </semantics>
</math>

 possible configurations. The <a class="uri" href="energy" title="wikilink">energy</a> for a given vertex can be given by 

<math display="inline" id="Vertex_model:2">
 <semantics>
  <msubsup>
   <mi>ε</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mi mathvariant="normal">ℓ</mi>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ε</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>normal-ℓ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon_{ij}^{k\ell}
  </annotation>
 </semantics>
</math>

,  with a state of the lattice is an assignment of a state of each bond, with the total energy of the state being the sum of the vertex energies. As the energy is often divergent for an infinite lattice, the model is studied for a finite lattice as the lattice approaches infinite size. <a href="periodic_function" title="wikilink">Periodic</a> or domain wall<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a href="boundary_condition" title="wikilink">boundary conditions</a> may be imposed on the model.</p>
<h2 id="discussion">Discussion</h2>

<p>For a given state of the lattice, the Boltzmann weight can be written as the product over the vertices of the Boltzmann weights of the corresponding vertex states</p>

<p>

<math display="block" id="Vertex_model:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>β</mi>
       <mi>ε</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mtext>state</mtext>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mtext>vertices</mtext>
    </munder>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>β</mi>
        <msubsup>
         <mi>ε</mi>
         <mrow>
          <mi>i</mi>
          <mi>j</mi>
         </mrow>
         <mrow>
          <mi>k</mi>
          <mi mathvariant="normal">ℓ</mi>
         </mrow>
        </msubsup>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <exp></exp>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>β</ci>
       <ci>ε</ci>
       <mtext>state</mtext>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <mtext>vertices</mtext>
     </apply>
     <apply>
      <exp></exp>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>β</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ε</ci>
          <apply>
           <times></times>
           <ci>i</ci>
           <ci>j</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>k</ci>
          <ci>normal-ℓ</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exp(-\beta\varepsilon(\mbox{state}))=\prod_{\mbox{vertices}}\exp(-\beta%
\varepsilon_{ij}^{k\ell})
  </annotation>
 </semantics>
</math>

</p>

<p>where the Boltzmann weights for the vertices are written</p>

<p>

<math display="block" id="Vertex_model:4">
 <semantics>
  <mrow>
   <msubsup>
    <mi>R</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
    <mrow>
     <mi>k</mi>
     <mi mathvariant="normal">ℓ</mi>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>β</mi>
       <msubsup>
        <mi>ε</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
        <mrow>
         <mi>k</mi>
         <mi mathvariant="normal">ℓ</mi>
        </mrow>
       </msubsup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>k</ci>
      <ci>normal-ℓ</ci>
     </apply>
    </apply>
    <apply>
     <exp></exp>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>β</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ε</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>k</ci>
         <ci>normal-ℓ</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{ij}^{k\ell}=\exp(-\beta\varepsilon_{ij}^{k\ell})
  </annotation>
 </semantics>
</math>

,</p>

<p>and the <em>i</em>, <em>j</em>, <em>k</em>, <em>l</em> range over the possible statuses of each of the four edges attached to the vertex. The vertex states of adjacent vertices must satisfy compatibility conditions along the connecting edges (bonds) in order for the state to be admissible.</p>

<p>The <a class="uri" href="probability" title="wikilink">probability</a> of the system being in any given state at a particular time, and hence the properties of the system are determined by the <a href="partition_function_(statistical_mechanics)" title="wikilink">partition function</a>, for which an analytic form is desired.</p>

<p>

<math display="block" id="Vertex_model:5">
 <semantics>
  <mrow>
   <mi>ℤ</mi>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mtext>states</mtext>
    </munder>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>β</mi>
        <mi>ε</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mtext>state</mtext>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ℤ</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <mtext>states</mtext>
     </apply>
     <apply>
      <exp></exp>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>β</ci>
        <ci>ε</ci>
        <mtext>state</mtext>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}=\sum_{\mbox{states}}\exp(-\beta\varepsilon(\mbox{state}))
  </annotation>
 </semantics>
</math>

</p>

<p>where β=<em>1/kT</em>, <em>T</em> is <a class="uri" href="temperature" title="wikilink">temperature</a> and <em>k</em> is <a href="Boltzmann's_constant" title="wikilink">Boltzmann's constant</a>. The probability that the system is in any given state (<a class="uri" href="microstate" title="wikilink">microstate</a>) is given by</p>

<p>

<math display="block" id="Vertex_model:6">
 <semantics>
  <mfrac>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>β</mi>
       <mi>ε</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mtext>state</mtext>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mi>ℤ</mi>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <exp></exp>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>β</ci>
       <ci>ε</ci>
       <mtext>state</mtext>
      </apply>
     </apply>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\exp(-\beta\varepsilon(\mbox{state}))}{\mathbb{Z}}
  </annotation>
 </semantics>
</math>

</p>

<p>so that the average value of the energy of the system is given by</p>

<p>

<math display="block" id="Vertex_model:7">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>ε</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mtext>states</mtext>
     </msub>
     <mrow>
      <mi>ε</mi>
      <mrow>
       <mi>exp</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mi>β</mi>
          <mi>ε</mi>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mtext>states</mtext>
     </msub>
     <mrow>
      <mi>exp</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>β</mi>
         <mi>ε</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <msup>
     <mi>T</mi>
     <mn>2</mn>
    </msup>
    <mfrac>
     <mo>∂</mo>
     <mrow>
      <mo>∂</mo>
      <mi>T</mi>
     </mrow>
    </mfrac>
    <mrow>
     <mi>ln</mi>
     <mi>ℤ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <ci>ε</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <mtext>states</mtext>
       </apply>
       <apply>
        <times></times>
        <ci>ε</ci>
        <apply>
         <exp></exp>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <ci>β</ci>
           <ci>ε</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <mtext>states</mtext>
       </apply>
       <apply>
        <exp></exp>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>β</ci>
          <ci>ε</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>k</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <divide></divide>
       <partialdiff></partialdiff>
       <apply>
        <partialdiff></partialdiff>
        <ci>T</ci>
       </apply>
      </apply>
      <apply>
       <ln></ln>
       <ci>ℤ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\varepsilon\rangle=\frac{\sum_{\mbox{states}}\varepsilon\exp(-\beta%
\varepsilon)}{\sum_{\mbox{states}}\exp(-\beta\varepsilon)}=kT^{2}\frac{%
\partial}{\partial T}\ln\mathbb{Z}
  </annotation>
 </semantics>
</math>

</p>

<p>In order to evaluate the partition function, firstly examine the states of a row of vertices.</p>
<figure><b>(Figure)</b>
<figcaption>A row of vertices in the square lattice vertex model</figcaption>
</figure>

<p>The external edges are free variables, with summation over the internal bonds. Hence, form the row partition function</p>

<p>

<math display="block" id="Vertex_model:8">
 <semantics>
  <mrow>
   <msubsup>
    <mi>T</mi>
    <mrow>
     <msub>
      <mi>i</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>k</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>k</mi>
      <mi>N</mi>
     </msub>
    </mrow>
    <mrow>
     <msubsup>
      <mi>i</mi>
      <mn>1</mn>
      <mo>′</mo>
     </msubsup>
     <msub>
      <mi mathvariant="normal">ℓ</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>l</mi>
      <mi>N</mi>
     </msub>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <msub>
       <mi>r</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>r</mi>
       <mrow>
        <mi>N</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
    </munder>
    <mrow>
     <msubsup>
      <mi>R</mi>
      <mrow>
       <msub>
        <mi>i</mi>
        <mn>1</mn>
       </msub>
       <msub>
        <mi>k</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mrow>
       <msub>
        <mi>r</mi>
        <mn>1</mn>
       </msub>
       <msub>
        <mi mathvariant="normal">ℓ</mi>
        <mn>1</mn>
       </msub>
      </mrow>
     </msubsup>
     <msubsup>
      <mi>R</mi>
      <mrow>
       <msub>
        <mi>r</mi>
        <mn>1</mn>
       </msub>
       <msub>
        <mi>k</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mrow>
       <msub>
        <mi>r</mi>
        <mn>2</mn>
       </msub>
       <msub>
        <mi mathvariant="normal">ℓ</mi>
        <mn>2</mn>
       </msub>
      </mrow>
     </msubsup>
     <mi mathvariant="normal">⋯</mi>
     <msubsup>
      <mi>R</mi>
      <mrow>
       <msub>
        <mi>r</mi>
        <mrow>
         <mi>N</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <msub>
        <mi>k</mi>
        <mi>N</mi>
       </msub>
      </mrow>
      <mrow>
       <msubsup>
        <mi>i</mi>
        <mn>1</mn>
        <mo>′</mo>
       </msubsup>
       <msub>
        <mi mathvariant="normal">ℓ</mi>
        <mi>N</mi>
       </msub>
      </mrow>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>i</ci>
        <ci>normal-′</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-ℓ</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <apply>
         <minus></minus>
         <ci>N</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </list>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-ℓ</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>k</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-ℓ</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <apply>
           <minus></minus>
           <ci>N</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>k</ci>
          <ci>N</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>i</ci>
          <ci>normal-′</ci>
         </apply>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-ℓ</ci>
         <ci>N</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{i_{1}k_{1}\dots k_{N}}^{i^{\prime}_{1}\ell_{1}\dots l_{N}}=\sum_{r_{1},%
\dots,r_{N-1}}R_{i_{1}k_{1}}^{r_{1}\ell_{1}}R_{r_{1}k_{2}}^{r_{2}\ell_{2}}%
\cdots R_{r_{N-1}k_{N}}^{i^{\prime}_{1}\ell_{N}}
  </annotation>
 </semantics>
</math>

</p>

<p>This can be reformulated in terms of an auxiliary <em>n</em>-dimensional vector space <em>V</em>, with a <a href="basis_(linear_algebra)" title="wikilink">basis</a> 

<math display="inline" id="Vertex_model:9">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>v</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{v_{1},\ldots,v_{n}\}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Vertex_model:10">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>∈</mo>
   <mrow>
    <mi>E</mi>
    <mi>n</mi>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>V</mi>
      <mo>⊗</mo>
      <mi>V</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>R</ci>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>n</ci>
     <ci>d</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>V</ci>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\in End(V\otimes V)
  </annotation>
 </semantics>
</math>

 as</p>

<p>

<math display="block" id="Vertex_model:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>v</mi>
       <mi>i</mi>
      </msub>
      <mo>⊗</mo>
      <msub>
       <mi>v</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>,</mo>
      <mi mathvariant="normal">ℓ</mi>
     </mrow>
    </munder>
    <mrow>
     <mrow>
      <msubsup>
       <mi>R</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
       <mrow>
        <mi>k</mi>
        <mi mathvariant="normal">ℓ</mi>
       </mrow>
      </msubsup>
      <msub>
       <mi>v</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mo>⊗</mo>
     <msub>
      <mi>v</mi>
      <mi mathvariant="normal">ℓ</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <list>
       <ci>k</ci>
       <ci>normal-ℓ</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>k</ci>
         <ci>normal-ℓ</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>normal-ℓ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(v_{i}\otimes v_{j})=\sum_{k,\ell}R_{ij}^{k\ell}v_{k}\otimes v_{\ell}
  </annotation>
 </semantics>
</math>

</p>

<p>and 

<math display="inline" id="Vertex_model:12">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>∈</mo>
   <mrow>
    <mi>E</mi>
    <mi>n</mi>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>V</mi>
      <mo>⊗</mo>
      <msup>
       <mi>V</mi>
       <mrow>
        <mi></mi>
        <mo>⊗</mo>
        <mi>N</mi>
       </mrow>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>T</ci>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>n</ci>
     <ci>d</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>V</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>V</ci>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <csymbol cd="latexml">absent</csymbol>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\in End(V\otimes V^{\otimes N})
  </annotation>
 </semantics>
</math>

 as</p>

<p>

<math display="block" id="Vertex_model:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>v</mi>
       <msub>
        <mi>i</mi>
        <mn>1</mn>
       </msub>
      </msub>
      <mo>⊗</mo>
      <msub>
       <mi>v</mi>
       <msub>
        <mi>k</mi>
        <mn>1</mn>
       </msub>
      </msub>
      <mo>⊗</mo>
      <mi mathvariant="normal">⋯</mi>
      <mo>⊗</mo>
      <msub>
       <mi>v</mi>
       <msub>
        <mi>k</mi>
        <mi>N</mi>
       </msub>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <msubsup>
       <mi>i</mi>
       <mn>1</mn>
       <mo>′</mo>
      </msubsup>
      <mo>,</mo>
      <msub>
       <mi mathvariant="normal">ℓ</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mrow>
       <mi mathvariant="normal">…</mi>
       <msub>
        <mi mathvariant="normal">ℓ</mi>
        <mi>N</mi>
       </msub>
      </mrow>
     </mrow>
    </munder>
    <mrow>
     <mrow>
      <msubsup>
       <mi>T</mi>
       <mrow>
        <msub>
         <mi>i</mi>
         <mn>1</mn>
        </msub>
        <msub>
         <mi>k</mi>
         <mn>1</mn>
        </msub>
        <mi mathvariant="normal">…</mi>
        <msub>
         <mi>k</mi>
         <mi>N</mi>
        </msub>
       </mrow>
       <mrow>
        <msubsup>
         <mi>i</mi>
         <mn>1</mn>
         <mo>′</mo>
        </msubsup>
        <msub>
         <mi mathvariant="normal">ℓ</mi>
         <mn>1</mn>
        </msub>
        <mi mathvariant="normal">…</mi>
        <msub>
         <mi mathvariant="normal">ℓ</mi>
         <mi>N</mi>
        </msub>
       </mrow>
      </msubsup>
      <msub>
       <mi>v</mi>
       <msubsup>
        <mi>i</mi>
        <mn>1</mn>
        <mo>′</mo>
       </msubsup>
      </msub>
     </mrow>
     <mo>⊗</mo>
     <msub>
      <mi>v</mi>
      <msub>
       <mi mathvariant="normal">ℓ</mi>
       <mn>1</mn>
      </msub>
     </msub>
     <mo>⊗</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>⊗</mo>
     <msub>
      <mi>v</mi>
      <msub>
       <mi mathvariant="normal">ℓ</mi>
       <mi>N</mi>
      </msub>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>i</ci>
         <ci>normal-′</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-ℓ</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-ℓ</ci>
         <ci>N</ci>
        </apply>
       </apply>
      </list>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>k</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>normal-…</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>k</ci>
           <ci>N</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>i</ci>
           <ci>normal-′</ci>
          </apply>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>normal-ℓ</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>normal-ℓ</ci>
          <ci>N</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>i</ci>
          <ci>normal-′</ci>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-ℓ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-ℓ</ci>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(v_{i_{1}}\otimes v_{k_{1}}\otimes\cdots\otimes v_{k_{N}})=\sum_{i^{\prime}_{%
1},\ell_{1},\dots\ell_{N}}T_{i_{1}k_{1}\dots k_{N}}^{i^{\prime}_{1}\ell_{1}%
\dots\ell_{N}}v_{i^{\prime}_{1}}\otimes v_{\ell_{1}}\otimes\cdots\otimes v_{%
\ell_{N}}
  </annotation>
 </semantics>
</math>

</p>

<p>thereby implying that <em>T</em> can be written as</p>

<p>

<math display="block" id="Vertex_model:14">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>R</mi>
     <mn>01</mn>
    </msub>
    <msub>
     <mi>R</mi>
     <mn>02</mn>
    </msub>
    <mi mathvariant="normal">⋯</mi>
    <msub>
     <mi>R</mi>
     <mrow>
      <mn>0</mn>
      <mi>N</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">01</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">02</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <apply>
       <times></times>
       <cn type="integer">0</cn>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=R_{01}R_{02}\cdots R_{0N}
  </annotation>
 </semantics>
</math>

</p>

<p>where the indices indicate the factors of the <a href="tensor_product" title="wikilink">tensor product</a> 

<math display="inline" id="Vertex_model:15">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>⊗</mo>
   <msup>
    <mi>V</mi>
    <mrow>
     <mi></mi>
     <mo>⊗</mo>
     <mi>N</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\otimes V^{\otimes N}
  </annotation>
 </semantics>
</math>

 on which <em>R</em> operates. Summing over the states of the bonds in the first row with the periodic boundary conditions 

<math display="inline" id="Vertex_model:16">
 <semantics>
  <mrow>
   <msub>
    <mi>i</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <msubsup>
    <mi>i</mi>
    <mn>1</mn>
    <mo>′</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>i</ci>
      <ci>normal-′</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{1}=i^{\prime}_{1}
  </annotation>
 </semantics>
</math>

, gives</p>

<p>

<math display="block" id="Vertex_model:17">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mo>trace</mo>
      <mi>V</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <msub>
     <mi>k</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>k</mi>
     <mi>N</mi>
    </msub>
   </mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">ℓ</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi mathvariant="normal">ℓ</mi>
     <mi>N</mi>
    </msub>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>trace</ci>
       <ci>V</ci>
      </apply>
      <ci>T</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-ℓ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-ℓ</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\operatorname{trace}_{V}(T))_{k_{1}\dots k_{N}}^{\ell_{1}\dots\ell_{N}}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Vertex_model:18">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>trace</mo>
     <mi>V</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>τ</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>trace</ci>
      <ci>V</ci>
     </apply>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau=\operatorname{trace}_{V}(T)
  </annotation>
 </semantics>
</math>

 is the row-transfer matrix. </p>

<p>By summing the contributions over two rows, the result is</p>

<p>

<math display="block" id="Vertex_model:19">
 <semantics>
  <mrow>
   <msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mo>trace</mo>
       <mi>V</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>T</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <msub>
      <mi>k</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>k</mi>
      <mi>N</mi>
     </msub>
    </mrow>
    <mrow>
     <msub>
      <mi mathvariant="normal">ℓ</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi mathvariant="normal">ℓ</mi>
      <mi>N</mi>
     </msub>
    </mrow>
   </msubsup>
   <msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mo>trace</mo>
       <mi>V</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>T</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <msub>
      <mi>j</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>j</mi>
      <mi>N</mi>
     </msub>
    </mrow>
    <mrow>
     <msub>
      <mi>k</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>k</mi>
      <mi>N</mi>
     </msub>
    </mrow>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>trace</ci>
        <ci>V</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-ℓ</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-ℓ</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>trace</ci>
        <ci>V</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>j</ci>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\operatorname{trace}_{V}(T))_{k_{1}\dots k_{N}}^{\ell_{1}\dots\ell_{N}}(%
\operatorname{trace}_{V}(T))_{j_{1}\dots j_{N}}^{k_{1}\dots k_{N}}
  </annotation>
 </semantics>
</math>

</p>

<p>which upon summation over the vertical bonds connecting the first two rows gives

<math display="block" id="Vertex_model:20">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mo>trace</mo>
        <mi>V</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>T</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <msub>
     <mi>j</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>j</mi>
     <mi>N</mi>
    </msub>
   </mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">ℓ</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi mathvariant="normal">ℓ</mi>
     <mi>N</mi>
    </msub>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>trace</ci>
        <ci>V</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>j</ci>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-ℓ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-ℓ</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((\operatorname{trace}_{V}(T))^{2})_{j_{1}\dots j_{N}}^{\ell_{1}\dots\ell_{N}}
  </annotation>
 </semantics>
</math>

</p>

<p>for <em>M</em> rows, this gives</p>

<p>

<math display="block" id="Vertex_model:21">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mo>trace</mo>
        <mi>V</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>T</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>M</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <msubsup>
     <mi mathvariant="normal">ℓ</mi>
     <mn>1</mn>
     <mo>′</mo>
    </msubsup>
    <mi mathvariant="normal">…</mi>
    <msubsup>
     <mi mathvariant="normal">ℓ</mi>
     <mi>N</mi>
     <mo>′</mo>
    </msubsup>
   </mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">ℓ</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi mathvariant="normal">ℓ</mi>
     <mi>N</mi>
    </msub>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>trace</ci>
        <ci>V</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <ci>M</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-ℓ</ci>
        <ci>normal-′</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-ℓ</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-ℓ</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-ℓ</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ((\operatorname{trace}_{V}(T))^{M})_{\ell^{\prime}_{1}\dots\ell^{\prime}_{N}}^%
{\ell_{1}\dots\ell_{N}}
  </annotation>
 </semantics>
</math>

</p>

<p>and then applying the periodic boundary conditions to the vertical columns, the partition function can be expressed in terms of the transfer matrix 

<math display="inline" id="Vertex_model:22">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 as</p>

<p>

<math display="block" id="Vertex_model:23">
 <semantics>
  <mrow>
   <mi>ℤ</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>trace</mo>
     <msup>
      <mi>V</mi>
      <mrow>
       <mi></mi>
       <mo>⊗</mo>
       <mi>N</mi>
      </mrow>
     </msup>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>τ</mi>
      <mi>M</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∼</mo>
   <msubsup>
    <mi>λ</mi>
    <mrow>
     <mi>m</mi>
     <mi>a</mi>
     <mi>x</mi>
    </mrow>
    <mi>M</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>ℤ</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>trace</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>V</ci>
        <apply>
         <csymbol cd="latexml">tensor-product</csymbol>
         <csymbol cd="latexml">absent</csymbol>
         <ci>N</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>τ</ci>
       <ci>M</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">similar-to</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>a</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}=\operatorname{trace}_{V^{\otimes N}}(\tau^{M})\sim\lambda_{max}^{M}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Vertex_model:24">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mrow>
    <mi>m</mi>
    <mi>a</mi>
    <mi>x</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{max}
  </annotation>
 </semantics>
</math>

 is the largest <a class="uri" href="eigenvalue" title="wikilink">eigenvalue</a> of 

<math display="inline" id="Vertex_model:25">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

. The approximation follows from the fact that the eigenvalues of 

<math display="inline" id="Vertex_model:26">
 <semantics>
  <msup>
   <mi>τ</mi>
   <mi>M</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>τ</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau^{M}
  </annotation>
 </semantics>
</math>

 are the eigenvalues of 

<math display="inline" id="Vertex_model:27">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 to the power of <em>M</em>, and as 

<math display="inline" id="Vertex_model:28">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>M</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\rightarrow\infty
  </annotation>
 </semantics>
</math>

, the power of the largest eigenvalue becomes much larger than the others. As the <a href="trace_(linear_algebra)" title="wikilink">trace</a> is the sum of the eigenvalues, the problem of calculating 

<math display="inline" id="Vertex_model:29">
 <semantics>
  <mi>ℤ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℤ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}
  </annotation>
 </semantics>
</math>

 reduces to the problem of finding the maximum eigenvalue of 

<math display="inline" id="Vertex_model:30">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

. This in it itself is another field of study. However, a standard approach to the problem of finding the largest eigenvalue of 

<math display="inline" id="Vertex_model:31">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 is to find a large family of operators which commute with 

<math display="inline" id="Vertex_model:32">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

. This implies that the <a href="eigenspace" title="wikilink">eigenspaces</a> are common, and restricts the possible space of solutions. Such a family of commuting operators is usually found by means of the <a href="Yang-Baxter_equation" title="wikilink">Yang-Baxter equation</a>, which thus relates statistical mechanics to the study of <a href="quantum_group" title="wikilink">quantum groups</a>.</p>
<h2 id="integrability">Integrability</h2>

<p><strong>Definition</strong>: A vertex model is <em>integrable</em> if, 

<math display="inline" id="Vertex_model:33">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>μ</mi>
   </mrow>
   <mo>,</mo>
   <mi>ν</mi>
   <mo>,</mo>
   <mrow>
    <mo>∃</mo>
    <mi>λ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>μ</ci>
    </apply>
    <ci>ν</ci>
    <apply>
     <exists></exists>
     <ci>λ</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\mu,\nu,\exists\lambda
  </annotation>
 </semantics>
</math>

 such that</p>

<p>

<math display="block" id="Vertex_model:34">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mn>12</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>R</mi>
     <mn>13</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>μ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>R</mi>
     <mn>23</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ν</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>R</mi>
     <mn>23</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ν</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>R</mi>
     <mn>13</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>μ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>R</mi>
     <mn>12</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">12</cn>
     </apply>
     <ci>λ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">13</cn>
     </apply>
     <ci>μ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">23</cn>
     </apply>
     <ci>ν</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">23</cn>
     </apply>
     <ci>ν</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">13</cn>
     </apply>
     <ci>μ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">12</cn>
     </apply>
     <ci>λ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{12}(\lambda)R_{13}(\mu)R_{23}(\nu)=R_{23}(\nu)R_{13}(\mu)R_{12}(\lambda)
  </annotation>
 </semantics>
</math>

</p>

<p>This is a parameterized version of the Yang-Baxter equation, corresponding to the possible dependence of the vertex energies,and hence the Boltzmann weights <em>R</em> on external parameters, such as temperature, external fields, etc.</p>

<p>The integrability condition implies the following relation.</p>

<p><strong>Proposition</strong>: For an integrable vertex model, with 

<math display="inline" id="Vertex_model:35">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>,</mo>
   <mi>μ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>λ</ci>
    <ci>μ</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda,\mu
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Vertex_model:36">
 <semantics>
  <mi>ν</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ν</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu
  </annotation>
 </semantics>
</math>

 defined as above, then</p>

<p>

<math display="block" id="Vertex_model:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mn>1</mn>
       <mo>⊗</mo>
       <mi>T</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>μ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>T</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ν</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⊗</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>T</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ν</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⊗</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mn>1</mn>
       <mo>⊗</mo>
       <mi>T</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>μ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>λ</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <cn type="integer">1</cn>
       <ci>T</ci>
      </apply>
      <ci>μ</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>ν</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>ν</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <cn type="integer">1</cn>
       <ci>T</ci>
      </apply>
      <ci>μ</ci>
     </apply>
     <ci>R</ci>
     <ci>λ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(\lambda)(1\otimes T(\mu))(T(\nu)\otimes 1)=(T(\nu)\otimes 1)(1\otimes T(\mu)%
)R(\lambda)
  </annotation>
 </semantics>
</math>

</p>

<p>as <a href="endomorphism" title="wikilink">endomorphisms</a> of 

<math display="inline" id="Vertex_model:38">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>⊗</mo>
   <mi>V</mi>
   <mo>⊗</mo>
   <msup>
    <mi>V</mi>
    <mrow>
     <mi></mi>
     <mo>⊗</mo>
     <mi>N</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <ci>V</ci>
    <ci>V</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <csymbol cd="latexml">absent</csymbol>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\otimes V\otimes V^{\otimes N}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Vertex_model:39">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(\lambda)
  </annotation>
 </semantics>
</math>

 acts on the first two vectors of the tensor product.</p>

<p>It follows by multiplying both sides of the above equation on the right by 

<math display="inline" id="Vertex_model:40">
 <semantics>
  <mrow>
   <mi>R</mi>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>λ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>λ</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(\lambda)^{-1}
  </annotation>
 </semantics>
</math>

 and using the cyclic property of the trace operator that the following corollary holds.</p>

<p><strong>Corollary</strong>: For an integrable vertex model for which 

<math display="inline" id="Vertex_model:41">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>R</ci>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(\lambda)
  </annotation>
 </semantics>
</math>

 is invertible 

<math display="inline" id="Vertex_model:42">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>λ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\lambda
  </annotation>
 </semantics>
</math>

, the transfer matrix 

<math display="inline" id="Vertex_model:43">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>μ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>τ</ci>
    <ci>μ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau(\mu)
  </annotation>
 </semantics>
</math>

 commutes with 

<math display="inline" id="Vertex_model:44">
 <semantics>
  <mrow>
   <mrow>
    <mi>τ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ν</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <mo>∀</mo>
    <mi>μ</mi>
   </mrow>
   <mo>,</mo>
   <mi>ν</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>τ</ci>
     <ci>ν</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>μ</ci>
    </apply>
    <ci>ν</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau(\nu),\ \forall\mu,\nu
  </annotation>
 </semantics>
</math>

.</p>

<p>This illustrates the role of the Yang-Baxter equation in the solution of solvable lattice models. Since the transfer matrices 

<math display="inline" id="Vertex_model:45">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 commute for all 

<math display="inline" id="Vertex_model:46">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>,</mo>
   <mi>ν</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>λ</ci>
    <ci>ν</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda,\nu
  </annotation>
 </semantics>
</math>

, the eigenvectors of 

<math display="inline" id="Vertex_model:47">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 are common, and hence independent of the parameterization. It is a recurring theme which appears in many other types of statistical mechanical models to look for these commuting transfer matrices.</p>

<p>From the definition of <em>R</em> above, it follows that for every solution of the Yang-Baxter equation in the tensor product of two <em>n</em>-dimensional vector spaces, there is a corresponding 2-dimensional solvable vertex model where each of the bonds can be in the possible states 

<math display="inline" id="Vertex_model:48">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mi>n</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">1</cn>
    <ci>normal-…</ci>
    <ci>n</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{1,\ldots,n\}
  </annotation>
 </semantics>
</math>

, where <em>R</em> is an endomorphism in the space spanned by 

<math display="inline" id="Vertex_model:49">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mi>a</mi>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo>⊗</mo>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mi>b</mi>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo>,</mo>
     <mn>1</mn>
    </mrow>
    <mo>≤</mo>
    <mi>a</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>b</mi>
    <mo>≤</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <list>
      <set>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <ci>a</ci>
        </apply>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <ci>b</ci>
        </apply>
       </apply>
      </set>
      <cn type="integer">1</cn>
     </list>
     <ci>a</ci>
    </apply>
    <apply>
     <leq></leq>
     <ci>b</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{|a\rangle\otimes|b\rangle\},1\leq a,b\leq n
  </annotation>
 </semantics>
</math>

. This motivates the classification of all the finite-dimensional irreducible <a href="representation_theory" title="wikilink">representations</a> of a given <a href="Quantum_algebra" title="wikilink">Quantum algebra</a> in order to find solvable models coreesponding to it.</p>
<h2 id="notable-vertex-models">Notable vertex models</h2>
<ul>
<li><a href="Six-vertex_model" title="wikilink">Six-vertex model</a>
<ul>
<li></li>
</ul></li>
<li><a href="Eight-vertex_model" title="wikilink">Eight-vertex model</a>
<ul>
<li></li>
</ul></li>
<li>[<a class="uri" href="http://projecteuclid.org/DPubS?service=UI&amp;version">http://projecteuclid.org/DPubS?service=UI&amp;version;</a>;=1.0&amp;verb;=Display&amp;handle;=euclid.cmp/1103909051 Nineteen-vertex model] (Izergin-Korepin model) <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Statistical_mechanics" title="wikilink">Category:Statistical mechanics</a> <a href="Category:Lattice_models" title="wikilink">Category:Lattice models</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">R.J. Baxter, <em>Exactly solved models in statistical mechanics</em>, London, Academic Press, 1982<a href="#fnref1">↩</a></li>
<li id="fn2">V. Chari and A.N. Pressley, <em>A Guide to Quantum Groups</em> Cambridge University Press, 1994<a href="#fnref2">↩</a></li>
<li id="fn3">V.E. Korepin et al., <em>Quantum inverse scattering method and correlation functions</em>, New York, Press Syndicate of the University of Cambridge, 1993<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="http://www.springerlink.com/content/v866837136883838/?p=8b77f6f1d1bf4e5aaed3e580361fd581π=0">A. G. Izergin and V. E. Korepin, The inverse scattering method approach to the quantum Shabat-Mikhailov model. <em>Communications in Mathematical Physics</em>, <strong>79</strong>, 303 (1981)</a><a href="#fnref4">↩</a></li>
</ol>
</section>
</hr></body>
</html>
