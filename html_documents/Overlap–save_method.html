<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="439">Overlap–save method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Overlap–save method</h1>
<hr/>

<p><strong>Overlap–save</strong> is the traditional name for an efficient way to evaluate the <a href="Convolution#Discrete_convolution" title="wikilink">discrete convolution</a> between a very long signal 

<math display="inline" id="Overlap–save_method:0">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x[n]
  </annotation>
 </semantics>
</math>

 and a <a href="finite_impulse_response" title="wikilink">finite impulse response</a> (FIR) filter 

<math display="inline" id="Overlap–save_method:1">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h[n]
  </annotation>
 </semantics>
</math>

<strong>:</strong></p>

<p>{=} \ \sum_{m=-\infty}^{\infty} h[m] \cdot x[n-m] = \sum_{m=1}^{M} h[m] \cdot x[n-m],\,|<mtpl><eqref>Eq.1<eqref></eqref></eqref></mtpl>}}</p>

<p>where h[m]=0 for m outside the region [1, <em>M</em>].</p>

<p> The concept is to compute short segments of <em>y</em>[<em>n</em>] of an arbitrary length <em>L</em>, and concatenate the segments together. Consider a segment that begins at <em>n</em> = <em>kL</em> + <em>M</em>, for any integer <em>k</em>, and define<strong>:</strong></p>

<p>

<math display="block" id="Overlap–save_method:2">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo rspace="7.5pt" stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mover>
    <mo movablelimits="false">=</mo>
    <mi>def</mi>
   </mover>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>x</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mrow>
           <mi>k</mi>
           <mi>L</mi>
          </mrow>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mn>1</mn>
        <mo>≤</mo>
        <mi>n</mi>
        <mo>≤</mo>
        <mrow>
         <mrow>
          <mi>L</mi>
          <mo>+</mo>
          <mi>M</mi>
         </mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mtext>otherwise</mtext>
        <mo>.</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <ci>def</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <apply>
         <times></times>
         <ci>k</ci>
         <ci>L</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <and></and>
      <apply>
       <leq></leq>
       <cn type="integer">1</cn>
       <ci>n</ci>
      </apply>
      <apply>
       <leq></leq>
       <share href="#.cmml">
       </share>
       <apply>
        <minus></minus>
        <apply>
         <plus></plus>
         <ci>L</ci>
         <ci>M</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <cn type="integer">0</cn>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}[n]\ \stackrel{\mathrm{def}}{=}\begin{cases}x[n+kL]&1\leq n\leq L+M-1\\
0&\textrm{otherwise}.\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Overlap–save_method:3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo rspace="7.5pt" stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mpadded width="+5pt">
    <mover>
     <mo movablelimits="false">=</mo>
     <mi>def</mi>
    </mover>
   </mpadded>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>n</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>*</mo>
     <mi>h</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo rspace="4.2pt" stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <ci>def</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>n</ci>
       </apply>
      </apply>
      <ci>h</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}[n]\ \stackrel{\mathrm{def}}{=}\ x_{k}[n]*h[n]\,
  </annotation>
 </semantics>
</math>

</p>

<p>Then, for <em>kL</em> + <em>M</em>  ≤  <em>n</em>  ≤  <em>kL</em> + <em>L</em> + <em>M</em> − 1, and equivalently <em>M</em>  ≤  <em>n</em> − <em>kL</em>  ≤  <em>L</em> + <em>M</em> − 1, we can write<strong>:</strong></p>

<p>

<math display="inline" id="Overlap–save_method:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mstyle displaystyle="true">
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>m</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>M</mi>
     </munderover>
    </mstyle>
    <mrow>
     <mrow>
      <mrow>
       <mi>h</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>m</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>⋅</mo>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mrow>
        <mi>k</mi>
        <mi>L</mi>
       </mrow>
       <mo>-</mo>
       <mi>m</mi>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>M</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <ci>h</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>m</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <apply>
         <times></times>
         <ci>k</ci>
         <ci>L</ci>
        </apply>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle y[n]=\sum_{m=1}^{M}h[m]\cdot x_{k}[n-kL-m]
  </annotation>
 </semantics>
</math>


</p>

<p>The task is thereby reduced to computing <em>y</em><sub><em>k</em></sub>[<em>n</em>], for <em>M</em>  ≤  <em>n</em>  ≤  <em>L</em> +<em> M</em> − 1. The process described above is illustrated in the accompanying figure.</p>

<p>Now note that if we periodically extend <em>x</em><sub><em>k</em></sub>[<em>n</em>] with period <em>N</em>  ≥  <em>L</em> + <em>M</em> − 1, according to<strong>:</strong></p>

<p>

<math display="block" id="Overlap–save_method:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>k</mi>
       <mo>,</mo>
       <mi>N</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo rspace="7.5pt" stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mpadded width="+5pt">
     <mover>
      <mo movablelimits="false">=</mo>
      <mi>def</mi>
     </mover>
    </mpadded>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi mathvariant="normal">ℓ</mi>
       <mo>=</mo>
       <mrow>
        <mo>-</mo>
        <mi mathvariant="normal">∞</mi>
       </mrow>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mrow>
         <mi mathvariant="normal">ℓ</mi>
         <mi>N</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <ci>def</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <list>
       <ci>k</ci>
       <ci>N</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>normal-ℓ</ci>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <apply>
         <times></times>
         <ci>normal-ℓ</ci>
         <ci>N</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k,N}[n]\ \stackrel{\mathrm{def}}{=}\ \sum_{\ell=-\infty}^{\infty}x_{k}[n-%
\ell N],
  </annotation>
 </semantics>
</math>

</p>

<p>the convolutions  

<math display="inline" id="Overlap–save_method:6">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>k</mi>
      <mo>,</mo>
      <mi>N</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>*</mo>
   <mpadded width="+1.7pt">
    <mi>h</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <list>
      <ci>k</ci>
      <ci>N</ci>
     </list>
    </apply>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{k,N})*h\,
  </annotation>
 </semantics>
</math>

  and  

<math display="inline" id="Overlap–save_method:7">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>k</mi>
   </msub>
   <mo>*</mo>
   <mpadded width="+1.7pt">
    <mi>h</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}*h\,
  </annotation>
 </semantics>
</math>

  are equivalent in the region <em>M</em>  ≤  <em>n</em>  ≤  <em>L</em> + <em>M</em> − 1. So it is sufficient to compute the <strong>N</strong>-point <a href="circular_convolution" title="wikilink">circular (or cyclic) convolution</a> of 

<math display="inline" id="Overlap–save_method:8">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo rspace="4.2pt" stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}[n]\,
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Overlap–save_method:9">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo rspace="4.2pt" stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h[n]\,
  </annotation>
 </semantics>
</math>

  in the region [1, <em>N</em>].  The subregion [<em>M</em>, <em>L</em> + <em>M</em> − 1] is appended to the output stream, and the other values are <u>discarded</u>.</p>

<p>The advantage is that the circular convolution can be computed very efficiently as follows, according to the <a href="Discrete_Fourier_transform#Circular_convolution_theorem_and_cross-correlation_theorem" title="wikilink">circular convolution theorem</a><strong>:</strong></p>

<p>

<math display="block" id="Overlap–save_method:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mtext>DFT</mtext>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo rspace="7.5pt" stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mrow>
         <mtext>DFT</mtext>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mi>x</mi>
            <mi>k</mi>
           </msub>
           <mrow>
            <mo stretchy="false">[</mo>
            <mi>n</mi>
            <mo stretchy="false">]</mo>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>⋅</mo>
        <mtext>DFT</mtext>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>h</mi>
         <mrow>
          <mo stretchy="false">[</mo>
          <mi>n</mi>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
        <mo rspace="7.5pt" stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>DFT</mtext>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <mtext>DFT</mtext>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>k</ci>
         </apply>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
       <mtext>DFT</mtext>
      </apply>
      <apply>
       <times></times>
       <ci>h</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}[n]=\scriptstyle\text{DFT}^{-1}\displaystyle(\ \scriptstyle\text{DFT}%
\displaystyle(x_{k}[n])\cdot\scriptstyle\text{DFT}\displaystyle(h[n])\ ),
  </annotation>
 </semantics>
</math>

</p>

<p>where<strong>:</strong></p>
<ul>
<li>DFT and DFT<sup>−1</sup> refer to the Discrete Fourier transform and inverse Discrete Fourier transform, respectively, evaluated over <em>N</em> discrete points, and</li>
<li><em>N</em> is customarily chosen to be an integer power-of-2, which optimizes the efficiency of the <a href="Fast_Fourier_transform" title="wikilink">FFT</a> algorithm.</li>
<li>Optimal N is in the range [4M, 8M].</li>
</ul>
<h2 id="pseudocode">Pseudocode</h2>

<p><code>
<span style="color:green;">(''Overlap–save algorithm for linear convolution'')</span>
  h = FIR_impulse_response
  M = length(h)
  overlap = M-1
  N = 4*overlap    <span style="color:green;">(or a nearby power-of-2)</span>
  step_size = N-overlap
  H = DFT(h, N)
  position = 0
  '''while''' position+N &lt;= length(x)
      yt = IDFT( DFT( x(1+position : N+position), N ) * H, N )
      y(1+position : step_size+position) = yt(M : N)    #discard M-1 y-values
      position = position + step_size
  '''end'''
</code></p>
<h2 id="efficiency">Efficiency</h2>

<p>When the DFT and its inverse is implemented by the FFT algorithm, the pseudocode above requires about <strong>N log<sub>2</sub>(N) + N</strong> complex multiplications for the FFT, product of arrays, and IFFT.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Each iteration produces <strong>N-M+1</strong> output samples, so the number of complex multiplications per output sample is about<strong>:</strong></p>

<p>For example, when <strong>M</strong>=201 and <strong>N</strong>=1024,  equals 13.67, whereas direct evaluation of  would require up to 201 complex multiplications per output sample, the worst case being when both <strong>x</strong> and <strong>h</strong> are complex-valued. Also note that for any given <strong>M</strong>,  has a minimum with respect to <strong>N</strong>. It diverges for both small and large block sizes.</p>
<h2 id="overlapdiscard">Overlap–discard</h2>

<p><em>Overlap–discard</em><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and <em>Overlap–scrap</em><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> are less commonly used labels for the same method described here. However, these labels are actually better (than <em>overlap–save</em>) to distinguish from <a href="Overlap–add_method" title="wikilink">overlap–add</a>, because <u>both</u> methods "save", but only one discards. "Save" merely refers to the fact that <em>M</em> − 1 input (or output) samples from segment <em>k</em> are needed to process segment <em>k</em> + 1.</p>
<h3 id="extending-overlapsave">Extending overlap–save</h3>

<p>The overlap-save algorithm may be extended to include other common operations of a system:<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<ul>
<li>additional channels can be processed more cheaply than the first by reusing the forward FFT</li>
<li>sampling rates can be changed by using different sized forward and inverse FFTs</li>
<li>frequency translation (mixing) can be accomplished by rearranging frequency bins</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Overlap–add_method" title="wikilink">Overlap–add method</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Rabiner, Lawrence R.; Gold, Bernard (1975). <em>Theory and application of digital signal processing</em>. Englewood Cliffs, N.J.: Prentice-Hall. pp 65–67. <a href="http://isbndb.com/d/book/theory_and_application_of_digital_signal_processing.html">ISBN 0139141014</a>.</li>
<li>Harris, F.J. (1987). "Time domain signal processing with the DFT". <em>Handbook of Digital Signal Processing</em>, D.F.Elliot, ed., San Diego: Academic Press. pp 633–699. <a href="http://isbndb.com/d/book/handbook_of_digital_signal_processing.html">ISBN 0122370759</a>.</li>
<li>Frerking, Marvin (1994). <em>Digital Signal Processing in Communication Systems</em>. New York: Van Nostrand Reinhold. <a href="http://isbndb.com/d/book/digital_signal_processing_in_communication_systems.html">ISBN 0442016166</a>.</li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Signal_processing" title="wikilink">Category:Signal processing</a> <a class="uri" href="Category:Transforms" title="wikilink">Category:Transforms</a> <a href="Category:Fourier_analysis" title="wikilink">Category:Fourier analysis</a> <a href="Category:Numerical_analysis" title="wikilink">Category:Numerical analysis</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Cooley-Tukey FFT algorithm for N=2<sup>k</sup> needs (N/2) log<sub>2</sub>(N) - see <a href="Fast_Fourier_transform#Definition_and_speed" title="wikilink">FFT - Definition and speed</a><a href="#fnref1">↩</a></li>
<li id="fn2">Harris 1987.<a href="#fnref2">↩</a></li>
<li id="fn3">Frerking 1994.<a href="#fnref3">↩</a></li>
<li id="fn4">Carlin et al. 1999, p 31, col 20.<a href="#fnref4">↩</a></li>
<li id="fn5">Borgerding 2006, pp 158–161.<a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
